<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥩 🎺 🙋🏽 Seluruh kebenaran tentang RTOS. Artikel # 6. Layanan RTOS lainnya 🕖 🤘 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami membahas fungsionalitas kernel dalam hal tugas yang dilakukan dan interaksi di antaranya. Pada artikel ini, kita melihat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 6. Layanan RTOS lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami membahas fungsionalitas kernel dalam hal tugas yang dilakukan dan interaksi di antaranya.  Pada artikel ini, kita melihat apa lagi yang dapat dilakukan kernel, yang sebagian besar dimanifestasikan dalam sejumlah panggilan API lain yang tersedia.  Kami juga akan menjawab pertanyaan, apa yang mengubah kernel menjadi sistem operasi? <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h2>  Manajemen tugas </h2><br>  Selain penjadwalan tugas dan interaksi di antara mereka, RTOS akan mencakup fungsionalitas (panggilan API) untuk mengelola tugas dengan berbagai cara.  Mari kita pertimbangkan beberapa kemungkinan. <br><br>  <b>Buat dan hapus tugas</b> <br><br>  Dalam RTOS "dinamis" ada panggilan fungsi yang memungkinkan Anda untuk membuat tugas (dan objek RTOS lainnya) saat diperlukan.  Panggilan semacam itu mencakup berbagai parameter yang menentukan tugas, misalnya, titik masuk, ukuran tumpukan, dan prioritas.  Panggilan API penghapusan tugas terkait memungkinkan Anda membebaskan sumber daya setelah tugas selesai. <br><br>  Dalam RTOS "statis", parameter yang menentukan tugas dikonfigurasikan dalam semacam file konfigurasi selama perakitan. <br><br>  <b>Jeda dan lanjutkan tugas</b> <br><br>  Seperti yang kita lihat, sebagian besar RTOS memiliki konsep tugas yang "ditangguhkan".  Ini dapat dicapai dengan berbagai cara.  Salah satunya adalah panggilan eksplisit ke fungsi Suspend Task API.  Itu bisa disebabkan oleh dirinya sendiri atau tugas lain.  Panggilan "Lanjutkan tugas" yang sesuai memungkinkan tugas untuk mengantri lagi untuk perencanaan. <br><br>  <b>Status tidur tugas</b> <br><br>  Untuk sistem waktu-nyata, kontrol waktu adalah persyaratan penting dan dapat mengambil berbagai bentuk.  Pandangan sederhana adalah kemampuan tugas untuk "tertidur", yaitu tugas ditangguhkan untuk periode waktu tertentu.  Ketika waktu habis, tugas "bangun" dan lagi-lagi mengantri untuk perencanaan.  Panggilan API biasanya akan tersedia untuk tujuan ini.  Tentu saja, fungsi ini tergantung pada ketersediaan pengatur waktu. <br><br>  <b>Pembebasan</b> <br><br>  Saat menggunakan penjadwal Round Robin ("carousel"), sebuah tugas dapat menolak untuk mengontrol prosesor untuk tugas selanjutnya dalam rantai.  Untuk melakukan ini, fungsi API "Tugas rilis" akan tersedia.  Tugas ini tidak ditangguhkan, itu akan tersedia untuk perencanaan ketika gilirannya tiba.  Saat menggunakan penjadwal Time slice, ada kemungkinan bahwa suatu tugas dapat membebaskan sebagian dari interval waktunya jika tidak ada pekerjaan penting yang harus dilakukan segera.  Melepaskan tugas tidak memiliki arti logis saat menjalankan Jalankan ke penyelesaian atau Penjadwal prioritas. <br><br>  <b>Penyelesaian tugas</b> <br><br>  Dalam artikel sebelumnya, kami menemukan bahwa selain status "Siap" atau "Ditangguhkan", RTOS dapat mendukung status tugas lainnya.  Tugas dapat "Selesai", yang berarti bahwa fungsi utamanya baru saja tersisa: tidak ada panggilan API khusus yang diperlukan.  Suatu tugas dapat "Dihentikan", yang berarti tidak tersedia untuk perencanaan dan harus diatur ulang agar tersedia untuk diluncurkan lagi, lihat "Mengatur ulang tugas" di bawah ini.  Ini membutuhkan panggilan API khusus.  Ketersediaan status tugas tambahan ini, terminologi yang digunakan, dan definisi pastinya akan berbeda tergantung pada RTOS. <br><br>  <b>Atur ulang tugas</b> <br><br>  Banyak RTOS menawarkan panggilan ke fungsi "Reset Task" API, yang memungkinkan Anda mengembalikan tugas ke kondisi semula.  Dia mungkin dalam keadaan ditangguhkan dan membutuhkan fungsi "Lanjutkan tugas" untuk dieksekusi untuk mengantri untuk perencanaan. <br><br>  <b>Tugas Prioritas, dll.</b> <br><br>  Dalam RTOS "dinamis", panggilan API mungkin tersedia untuk mengonfigurasi beberapa parameter tugas pada saat dijalankan.  Contohnya termasuk prioritas dan durasi interval waktu. <br><br><h2>  Informasi Sistem </h2><br>  Dalam RTOS, akan ada sejumlah panggilan API untuk memberikan sistem informasi tentang tugas tersebut, termasuk: <br>  <b>Informasi tentang tugas</b> .  Berapa banyak tugas dalam sistem, konfigurasi dan status saat ini. <br>  <b>Informasi tentang objek kernel lainnya.</b>  Berapa banyak objek dari masing-masing jenis dalam sistem, konfigurasi dan informasi tentang keadaan saat ini.  Sebagai contoh: <br><br><ul><li>  Berapa kapasitas antrian saat ini? Dapatkah saya menambahkan lebih banyak pesan? </li><li>  berapa banyak tugas yang ditangguhkan pada kotak surat tertentu? </li></ul>  <b>Informasi tentang versi RTOS</b> .  Panggilan API dapat memberikan data serupa. <br><br><h2>  Alokasi memori </h2><br>  Dalam banyak aplikasi, penting bahwa program dapat secara dinamis menangkap beberapa memori ketika dibutuhkan, dan membebaskannya ketika tidak lagi diperlukan.  Hal yang sama terjadi pada firmware.  Namun, pendekatan konvensional rentan terhadap masalah yang tidak mungkin atau tidak nyaman dalam aplikasi desktop, tetapi mereka dapat menjadi bencana bagi sistem tertanam.  Namun demikian, ada cara untuk mengimplementasikan layanan tersebut, bahkan dalam RTOS statis. <br><br><h2>  Masalah dengan fungsi malloc () dan gratis () </h2><br>  Dalam program C desktop, suatu fungsi dapat memanggil <b>malloc ()</b> , menunjukkan berapa banyak memori yang dibutuhkan, dan mendapatkan kembali sebuah pointer ke area penyimpanan.  Menggunakan memori, itu dapat dibebaskan dengan menelepon <b>gratis ()</b> .  Memori dialokasikan dari area yang disebut heap.  Masalah dengan pendekatan ini adalah bahwa dengan urutan panggilan yang tidak terkoordinasi untuk fungsi-fungsi ini, area tumpukan dapat dengan mudah menjadi terfragmentasi, dan kemudian alokasi memori akan gagal bahkan jika tersedia cukup memori, karena  daerah yang berdekatan tidak cukup besar.  Beberapa sistem (seperti Java dan Visual Basic) menggunakan skema pengumpulan sampah canggih untuk defragment.  Masalahnya adalah bahwa skema ini dapat menyebabkan keterlambatan signifikan yang tidak dapat diprediksi dalam runtime dan kebutuhan untuk menggunakan pointer tidak langsung (yang tidak bekerja di C). <br><br>  Jika <b>malloc ()</b> dan <b>free ()</b> diimplementasikan dengan cara reentrant (biasanya tidak) dan digunakan oleh tugas-tugas RTOS, fragmentasi akan terjadi dengan sangat cepat, dan kegagalan sistem hampir tidak terhindarkan.  Di C ++, ada operator <b>baru</b> dan <b>hapus</b> yang umumnya melakukan fungsi yang sama seperti malloc () dan free ().  Mereka tunduk pada batasan dan masalah yang sama. <br><br><h2>  Bagian dari memori </h2><br>  Untuk menyediakan sistem real-time dengan memori yang dapat diakses secara dinamis, pendekatan blok untuk manajemen memori dapat digunakan.  Blok seperti itu biasa disebut "partisi";  partisi dapat dialokasikan dari "pool partisi". <br><br>  Kolam partisi berisi sejumlah blok tertentu, yang masing-masing memiliki ukuran yang sama.  Jumlah dan ukuran blok dalam partisi ditentukan ketika kumpulan partisi dibuat.  Ini bisa dinamis jika sistem itu sendiri memungkinkannya, atau secara statis selama perakitan.  Biasanya, aplikasi dapat menyertakan beberapa kumpulan partisi yang menawarkan blok dengan ukuran berbeda. <br><br>  Jika tugas membutuhkan memori, ia memanggil API yang meminta blok dari kumpulan tertentu.  Jika panggilan ini berhasil, tugas akan menerima pointer ke blok yang dipilih.  Jika panggilan gagal karena  tidak ada partisi yang tersedia di kumpulan yang ditunjukkan, tugas mungkin menerima respons kesalahan.  Atau, tugas mungkin diblokir (ditangguhkan) sampai tugas lain melepaskan blokir di bagian. <br><br>  Biasanya, tugas hanya melewati pointer ke blok memori dalam kode apa pun yang menggunakan blok tersebut.  Ini mengarah ke masalah ketika blok tidak lagi diperlukan.  Jika kode hanya memiliki pointer ke blok, bagaimana bisa memberitahu RTOS melalui panggilan API, dari kumpulan partisi mana yang ingin membebaskan memori?  Jawabannya adalah bahwa sebagian besar RTOS mendukung data tambahan dalam blok khusus (biasanya offset negatif dari pointer) yang menyediakan informasi yang diperlukan.  Jadi, untuk memanggil API untuk membebaskan blok, hanya alamatnya yang diperlukan. <br><br>  Artikel berikut akan memiliki informasi lebih lanjut tentang partisi memori. <br><br><h2>  Waktu </h2><br>  Fungsionalitas yang terkait dengan penggunaan dan kontrol waktu kemungkinan akan tersedia di OS waktu nyata.  Peluang akan bervariasi tergantung pada RTOS, tetapi kami akan mempertimbangkan yang tersedia untuk umum.  Bagaimanapun, penghitung waktu-nyata adalah elemen yang sangat diperlukan untuk berfungsinya salah satu dari layanan ini. <br><br>  <b>Waktu sistem</b> <br><br>  Waktu sistem yang sederhana, atau "penghitung waktu jam", hampir selalu tersedia.  Ini hanya penghitung (biasanya 32 bit), yang ditambahkan menggunakan rutin layanan interupsi waktu nyata dan dapat diatur dan dibaca melalui panggilan API. <br><br>  <b>Timeout Panggilan Layanan</b> <br><br>  Biasanya, RTOS memungkinkan pemblokiran panggilan API, yaitu, tugas panggilan ditunda (diblokir) sampai layanan yang diminta disediakan.  Biasanya kunci ini tidak jelas, tetapi beberapa RTOS menawarkan batas waktu selama panggilan kembali ketika batas waktu berakhir jika layanan terus tidak tersedia.  Waktu tunggu panggilan API tidak didukung oleh semua RTOS. <br><br>  <b>Status tidur tugas</b> <br><br>  Biasanya, tugas memiliki kemampuan untuk menjeda diri mereka sendiri untuk jangka waktu tertentu.  Ini telah dibahas sebelumnya di bagian Manajemen Tugas. <br><br>  <b>Pengatur waktu perangkat lunak</b> <br><br>  Agar tugas-tugas program melakukan fungsi penghitungan waktu, sebagian besar RTOS menawarkan objek penghitung waktu.  Ini adalah timer independen yang diperbarui oleh penangan interupsi timer waktu nyata, yang dapat dikontrol oleh panggilan API.  Panggilan semacam itu mengonfigurasikan, memantau, dan memantau pengoperasian timer.  Sebagai aturan, mereka dapat diatur untuk aktuasi tunggal atau restart otomatis.  Rutin kedaluwarsa juga biasanya didukung, fungsi yang berjalan setiap kali timer menyelesaikan siklus.  Artikel selanjutnya akan memberikan informasi lebih lanjut tentang penghitung waktu perangkat lunak dan deskripsi penerapannya. <br><br><h2>  Interupsi, Driver, dan I / O </h2><br>  Sejauh mana RTOS dikaitkan dengan interupsi dan I / O sangat berbeda.  Demikian juga, beberapa RTOS memiliki struktur yang sangat jelas untuk driver perangkat, yang dapat menambah masalah ketika memilih produk tertentu. <br><br>  <b>Gangguan</b> <br><br>  Interupsi menghadirkan masalah bagi RTOS karena dua alasan. <br><br><ul><li>  Tanpa tindakan pencegahan, interrupt handler (ISR) akan "mencuri" waktu prosesor, sehingga mengganggu perilaku RTOS real-time. </li><li>  Jika ISR membuat panggilan API yang memengaruhi penjadwalan tugas, ini harus dipantau, dan RTOS harus dapat menjalankan algoritme penjadwalannya. </li></ul>  Contoh panggilan API tersebut adalah prosedur untuk membangunkan tugas dengan prioritas lebih tinggi daripada yang diluncurkan saat interupsi terjadi. <br><br>  Beberapa RTOS sepenuhnya mengontrol semua interupsi.  Serangkaian panggilan API tersedia untuk "mendaftar" program ISR.  Pendekatan ini memungkinkan penjadwal untuk menentukan kapan interupsi diaktifkan, dan memfasilitasi penggunaan sebagian besar panggilan API dari ISR. <br><br>  Sebagai contoh, Nucleus RTOS mengimplementasikan konsep interrupt handler “prioritas rendah” dan “prioritas tinggi”, yang menyediakan manajemen interupsi yang andal tanpa overhead yang tidak perlu (yaitu, peningkatan penundaan interupsi). <br><br>  RTOS lain dapat menggunakan mode “hands off” otomatis untuk interupsi, yang memberikan pengembang lebih banyak opsi untuk memastikan bahwa interrupt handler bekerja dengan benar.  Sebagai aturan, awalan ISR tambahan (prolog) dan sufiks (epilog) disediakan untuk melindungi panggilan API yang dibuat di dalamnya. <br>  Nucleus SE menggunakan rutin interupsi ringan, yang akan dijelaskan dalam artikel mendatang. <br><br>  <b>Driver</b> <br><br>  Sebagian besar RTOS menentukan struktur driver perangkat.  Detail dapat bervariasi tergantung pada RTOS, tetapi driver biasanya terdiri dari dua komponen yang saling berinteraksi: kode tertanam (panggilan API) dan ISR.  Biasanya, panggilan API lain akan tersedia untuk mengelola dan mendaftarkan driver. <br><br>  <b>Input / output</b> <br><br>  Saat ini, sebagian besar RTOS di pasaran tidak peduli dengan level input / output yang lebih tinggi, tetapi beberapa dari mereka mendefinisikan aliran input / output, yang pada dasarnya membangun koneksi antara driver perangkat yang sesuai dan fungsi bahasa C standar, seperti printf (). <br>  Secara historis, RTOS sering mendukung "konsol", antarmuka pengguna ke RTOS melalui saluran serial.  Ini terutama digunakan untuk diagnostik dan debugging.  Menggunakan debugger modern yang mendukung aplikasi debugging dengan RTOS menghilangkan kebutuhan untuk objek tersebut. <br><br><h2>  Diagnostik </h2><br>  Biasanya, RTOS membutuhkan kinerja maksimum dengan jejak memori minimal.  Karena itu, pemeriksaan integritas bukan prioritas tinggi.  Dengan bantuan teknologi debugging modern yang memperhitungkan fitur-fitur RTOS, sebagian besar pemeriksaan dapat dilakukan di luar RTOS itu sendiri. <br><br><h2>  Memeriksa Parameter Panggilan API </h2><br>  Panggilan API dapat memiliki banyak parameter kompleks.  Ini dapat menyebabkan kesalahan.  Banyak RTOS menyediakan pemeriksaan parameter runtime dengan mengembalikan kode kesalahan jika parameter yang salah.  Karena ini memerlukan kode tambahan, dan pemeriksaan itu sendiri mempengaruhi kinerja, lebih baik untuk memeriksa parameter selama perakitan atau konfigurasi. <br><br><h2>  Pemeriksaan tumpukan </h2><br>  Untuk sebagian besar jenis penjadwal (kecuali Jalankan ke Penyelesaian) setiap tugas memiliki tumpukan sendiri, yang ukurannya ditentukan secara individual.  Dalam beberapa RTOS, kernel memiliki tumpukan yang terpisah, di yang lain, tumpukan tugas "dipinjam" selama panggilan API.  Jelas, integritas tumpukan penting untuk keandalan sistem secara keseluruhan.  Oleh karena itu, RTOS sering menawarkan alat untuk memeriksa integritas tumpukan saat runtime.  Ada beberapa opsi: <br><br><ul><li>  Panggilan API yang mengembalikan jumlah ruang stack untuk tugas saat ini atau yang ditentukan. </li><li>  Parameter pembatas tumpukan.  Mereka diberi nilai unik (biasanya ganjil dan tidak nol), yang secara berkala diperiksa untuk penulisan ulang. </li></ul><br><br><h2>  Diagnosis aplikasi </h2><br>  Terlepas dari kenyataan bahwa fungsi ini tidak secara langsung didukung dalam RTOS, tugas aplikasi dapat dialokasikan untuk memeriksa integritas seluruh sistem.  Tugas semacam itu mungkin bertanggung jawab untuk mengatur ulang pengawas waktu.  Suatu tugas dapat menerima data input berkala (misalnya, parameter sinyal) dari setiap tugas penting.  Menyetel ulang pengawas waktu (yang akan mencegah sistem dari reboot) akan dilakukan hanya setelah data dari semua tugas telah tiba. <br><br><h2>  Layanan Non Kernel </h2><br>  RTOS lebih dari sekadar inti yang sejauh ini kami fokuskan.  Sistem operasi desktop ini sangat berbeda dari RTOS yang disematkan.  Biasanya, dalam OS desktop, semua komponen tambahan dibundel atau dapat diinstal (semua PC desktop memiliki antarmuka pengguna grafis, dan hanya beberapa dari mereka yang tidak memiliki akses jaringan).  PC desktop tidak memiliki batas sumber daya nyata: selalu ada memori bebas, ruang hard disk, dan sumber daya CPU yang tidak digunakan.  Dalam dunia sistem tertanam dengan sumber daya terbatas, komponen tambahan seperti kartu video, komponen jaringan, dan sistem file mungkin diperlukan, tetapi mereka harus diputuskan dan dapat diskalakan untuk meminimalkan jejak memori. <br><br>  <b>Fitur jaringan</b> <br><br>  Sebagian besar sistem embedded entah bagaimana terkait dengan jaringan.  Dengan demikian, diharapkan ada minat yang signifikan dalam solusi jaringan untuk sistem embedded, karena ada sejumlah besar produk di pasar. <br><br>  <b>TCP / IP</b> adalah protokol standar yang banyak digunakan dan merupakan pilihan yang jelas untuk banyak aplikasi.  Biasanya, TCP / IP digunakan untuk protokol Ethernet (IEEE802.3), yang menyediakan kecepatan rata-rata 10 Mb / s.  Saat ini, 100 Mb / s sangat umum, dan pada pendekatan 1 Gb / s.  Selain itu, TCP / IP dapat digunakan untuk protokol lain.  Misalnya, PPP (Point-to-Point Protocol) adalah implementasi TCP / IP untuk transfer data serial yang telah diadaptasi untuk koneksi internet broadband. <br><br>  Sampai saat ini, versi v4 protokol IP (IPv4) digunakan.  Namun, itu menjadi usang karena alamat gratis habis.  Solusinya adalah IPv6, secara signifikan meningkatkan jumlah alamat yang mungkin dan menyediakan alat yang lebih efisien untuk pemeliharaan dan keamanan.  IPv6 tersedia secara luas dan digunakan dalam peralatan di banyak negara, serta sistem militer di seluruh dunia. <br>  Alternatif adalah User Datagram Protocol (UDP).  Protokol ini digunakan untuk kinerja maksimum.  UDP tidak memberikan keandalan dan konsistensi yang sama dengan TCP, tetapi ringan dan sangat efisien. <br><br>  <b>USB</b> adalah Universal Serial Bus, banyak digunakan dalam perangkat untuk menghubungkan ke komputer desktop.  Ini menyediakan antarmuka plug-and-play yang sangat mudah digunakan yang menyembunyikan perangkat lunak yang cukup canggih.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkat tertanam yang harus terhubung ke PC harus diimplementasikan sebagai fungsi USB, yang memerlukan komponen perangkat lunak tertentu. Jika perangkat harus mengelola perangkat lain yang terhubung melalui USB (seperti PC biasa), perangkat ini memerlukan perangkat lunak jenis host. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEEE1394</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah standar antarmuka serial lain yang digunakan untuk dengan cepat mentransfer sejumlah besar data antar perangkat (misalnya, untuk mentransmisikan data video), juga dikenal sebagai FireWire dan i.Link.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol nirkabel - kenyamanan dan prevalensi berbagai teknologi nirkabel di antara konsumen telah menyebabkan permintaan tinggi untuk kemampuan nirkabel pada perangkat yang disematkan. Wi-Fi (standar IEEE802.11) menyediakan serangkaian kemampuan jaringan yang lengkap, memungkinkan Anda untuk mengimplementasikan topologi rekan dan infrastruktur pada jarak yang cukup. Ketertarikan terhadap keamanan data di jaringan tersebut semakin meningkat, yang berarti bahwa ini akan mempengaruhi perangkat lunak. Teknologi radio lainnya, terutama Bluetooth dan ZigBee, menyediakan komunikasi nirkabel point-to-point jarak pendek. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifikasi protokol</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena peluang jaringan sangat diminati, ada banyak pemasok yang menawarkan solusi mereka. Pelanggan menghadapi tantangan untuk memeriksa kualitas produk yang tersedia. Berbeda dengan kernel RTOS, pemeriksaan lengkap fungsi dan kinerja stack protokol bukanlah tugas yang mudah. Untungnya, toolkit tersedia untuk memeriksa protokol (meskipun dengan harga yang signifikan), dan pembeli potensial dapat mencari tahu dari pemasok yang ditetapkan mereka periksa. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka grafis menjadi lebih umum di antara perangkat yang tertanam. Ini bisa berupa LCD monokromatik kecil yang sangat sederhana (seperti pada ponsel lama, pemutar MP3, alarm, dll.). Di sisi lain, penerima televisi digital dapat memiliki layar HDTV resolusi tinggi sendiri. Layar seperti itu membutuhkan dukungan perangkat lunak yang sepenuhnya terintegrasi ke dalam kernel RTOS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena layar biasanya memiliki beberapa jenis perangkat input, dukungan untuk perangkat tersebut sering termasuk dalam paket grafis. Paket semacam itu dapat mendukung perangkat penunjuk (misalnya, mouse), layar sentuh, keypad, dan keyboard lengkap.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik dapat digunakan dengan berbagai cara. Itu hanya dapat memberikan output informasi (misalnya, seperti papan skor elektronik). Atau tampilan dapat menjadi bagian dari antarmuka pengguna grafis bersama dengan menu, jendela, ikon, dan elemen serupa. Dalam kasus apa pun, perangkat lunak yang agak spesifik diperlukan, dan paket grafis yang disertakan dengan RTOS harus memberikan fleksibilitas yang diperlukan tanpa secara signifikan meningkatkan jumlah memori yang digunakan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem file</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika aplikasi yang disematkan perlu menyimpan dan memproses sejumlah besar data, jelas bahwa masuk akal untuk mengatur data ini menjadi semacam sistem file. </font><font style="vertical-align: inherit;">Data dapat dalam RAM, dalam memori flash bawaan, pada USB flash drive, pada hard disk biasa, atau pada disk optik (CD-ROM atau DVD-ROM). </font><font style="vertical-align: inherit;">Sekali lagi, kesempatan seperti itu harus memiliki dukungan perangkat lunak yang sepenuhnya terintegrasi ke dalam RTOS. </font><font style="vertical-align: inherit;">Sistem file harus dirancang dengan hati-hati untuk memenuhi persyaratan reentrant dari sistem multi-tasking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kepatuhan sangat penting untuk sistem file. </font><font style="vertical-align: inherit;">Sebagai contoh, penggunaan format disk yang kompatibel dengan MS-DOS memungkinkan pengembang untuk menggunakan arsitektur yang sudah mapan dan menawarkan pertukaran data lengkap dengan sistem desktop.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418677/">https://habr.com/ru/post/id418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418665/index.html">Adaptasi proyek MR untuk HoloLens</a></li>
<li><a href="../id418667/index.html">Benchmarking HDFS 3 dengan HDFS 2</a></li>
<li><a href="../id418669/index.html">Security Week 28: NetSpectre, menyerang saluran pihak ketiga melalui jaringan</a></li>
<li><a href="../id418673/index.html">Mengapa pasar ERP tumbuh: statistik dan tren</a></li>
<li><a href="../id418675/index.html">Bagaimana saya pergi ke Droidcon Berlin</a></li>
<li><a href="../id418679/index.html">Kami menulis komponen dengan tombol "material" untuk Svelte</a></li>
<li><a href="../id418681/index.html">Hari Persahabatan - Diskon 50% semua IDE JetBrains untuk teman-teman kami</a></li>
<li><a href="../id418683/index.html">Membuat mesin arcade emulator. Bagian 2</a></li>
<li><a href="../id418685/index.html">Generasi Tingkat Prosedural</a></li>
<li><a href="../id418687/index.html">Revolusi 3,5 ": detail ledakan kecil floppy disk dengan uap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>