<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ ⭐️ 🐛 Daripada TestMace lebih baik dari Postman 🔨 ⬆️ 🛫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, dengan sentuhan TestMace ! Mungkin banyak orang tahu tentang kita dari artikel kita sebelumnya . Bagi mereka yang baru saja terhubung: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daripada TestMace lebih baik dari Postman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480734/"><p><img src="https://habrastorage.org/webt/iy/_5/c3/iy_5c3q9lbspu40fmjpvixnwkre.jpeg"></p><br><p> Halo semuanya, dengan sentuhan <a href="https://testmace.com/" rel="nofollow">TestMace</a> !  Mungkin banyak orang tahu tentang kita dari <a href="https://habr.com/ru/post/458964/">artikel</a> <a href="https://habr.com/ru/post/458372/">kita</a> <a href="https://habr.com/ru/post/462585/">sebelumnya</a> .  Bagi mereka yang baru saja terhubung: kami sedang mengembangkan IDE untuk bekerja dengan TestMace API.  Pertanyaan yang paling sering diajukan ketika membandingkan TestMace dengan produk pesaing adalah "Apa bedanya Anda dengan Postman?"  Kami memutuskan bahwa sudah waktunya untuk memberikan jawaban terperinci untuk pertanyaan ini.  Di bawah ini kami telah merinci keunggulan kami di atas <a href="https://www.getpostman.com/" rel="nofollow">tukang pos</a> . </p><a name="habracut"></a><br><h2 id="razdelenie-na-uzly">  Subdivisi </h2><br><p>  Jika Anda bekerja dengan tukang pos, maka Anda tahu bahwa antarmuka permintaan berisi semua fungsi yang diperlukan.  Ada skrip, tes, dan, pada kenyataannya, permintaan itu sendiri.  Ini menyederhanakan pekerjaan untuk pemula, tetapi untuk skenario besar pendekatan ini tidak fleksibel.  Bagaimana jika Anda ingin membuat beberapa permintaan dan menggabungkannya?  Bagaimana jika Anda ingin menjalankan skrip tanpa permintaan atau beberapa skrip yang dipisahkan secara logis dalam satu baris?  Pada akhirnya, alangkah baiknya untuk memisahkan tes dari skrip utilitarian biasa.  Selain itu, pendekatan "tambahkan semua fungsionalitas ke satu simpul" tidak dapat diskalakan - antarmuka dengan cepat menjadi kelebihan beban. </p><br><p>  TestMace awalnya membagi semua fungsi menjadi berbagai jenis node.  Ingin membuat permintaan?  Inilah simpul <a href="https://docs-ru.testmace.com/node-types/requeststep" rel="nofollow">langkah permintaan</a> .  Apakah Anda ingin menulis skrip?  Inilah simpul <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">skrip</a> untuk Anda.  Perlu tes?  Tolong - Node <a href="https://docs-ru.testmace.com/node-types/assertion" rel="nofollow">penegasan</a> .  Oh ya, Anda masih bisa membungkus semuanya ini dalam <a href="https://docs-ru.testmace.com/node-types/folder" rel="nofollow">folder</a> node.  Dan semua ini mudah dikombinasikan satu sama lain.  Pendekatan ini tidak hanya sangat fleksibel, tetapi, sesuai dengan prinsip keunikan tanggung jawab, memungkinkan Anda untuk hanya menggunakan apa yang benar-benar Anda butuhkan saat ini.  Mengapa saya perlu skrip dan tes jika saya hanya ingin mengajukan permintaan? </p><br><h2 id="chelovekochitaemyy-format-proekta">  Format proyek yang dapat dibaca manusia </h2><br><p>  Ada perbedaan konseptual dalam cara penyimpanan antara TestMace dan Postman.  Di tukang pos, semua permintaan disimpan di suatu tempat di penyimpanan lokal.  Jika ada kebutuhan untuk berbagi permintaan antara beberapa pengguna, maka Anda perlu menggunakan sinkronisasi bawaan.  Sebenarnya, ini adalah pendekatan yang diterima secara umum, bukan tanpa cacat.  Bagaimana dengan keamanan data?  Memang, kebijakan beberapa perusahaan mungkin tidak mengizinkan penyimpanan data dari pihak ketiga.  Namun, kami percaya TestMace memiliki sesuatu yang lebih baik untuk ditawarkan!  Dan nama peningkatan ini adalah "format proyek yang dapat dibaca manusia." </p><br><p>  Untuk mulai dengan, TestMace pada dasarnya memiliki entitas proyek.  Dan aplikasi ini awalnya dikembangkan dengan mata menyimpan proyek dalam sistem kontrol versi: pohon proyek diproyeksikan hampir satu-ke-satu ke struktur file, yaml digunakan sebagai format penyimpanan (tanpa tanda kurung tambahan dan koma), dan representasi file dari setiap node dijelaskan secara rinci dalam dokumentasi dengan komentar .  Tetapi dalam kebanyakan kasus Anda tidak akan melihat di sana - semua nama bidang memiliki nama logis. </p><br><p>  Apa ini memberi pengguna?  Ini memungkinkan Anda untuk secara fleksibel mengubah tim alur kerja, menggunakan pendekatan yang biasa.  Misalnya, pengembang dapat menyimpan proyek dalam repositori yang sama dengan backend.  Di cabang, selain mengubah basis kode secara langsung, pengembang dapat memperbaiki skrip dan tes kueri yang ada.  Setelah melakukan perubahan pada repositori (git, svn, lincah - yang paling Anda sukai) CI (favorit Anda, tidak dikenakan pada siapa pun) meluncurkan utilitas konsol <a href="https://www.npmjs.com/package/%40testmace/cli" rel="nofollow">testmace-cli kami</a> , dan laporan diterima setelah eksekusi (misalnya, dalam format junit, yang juga didukung dalam testmace-cli) dikirim ke sistem yang sesuai.  Dan masalah keamanan yang disebutkan di atas tidak lagi menjadi masalah. </p><br><p>  Seperti yang Anda lihat, TestMace tidak memaksakan ekosistem dan paradigmanya.  Sebaliknya, ini mudah diintegrasikan ke dalam proses yang sudah mapan. </p><br><h2 id="dinamicheskie-peremennye">  Variabel dinamis </h2><br><p>  TestMace mengikuti konsep no-code: jika masalah dapat diselesaikan tanpa menggunakan kode, kami mencoba memberikan kesempatan ini.  Bekerja dengan variabel hanyalah fungsi itu, di mana dalam banyak kasus Anda dapat melakukannya tanpa pemrograman. </p><br><p>  Contoh: kami menerima respons dari server, dan kami ingin menyimpan bagian dari respons dalam suatu variabel.  Di Postman, kita akan menulis sesuatu seperti itu dalam skrip uji (yang aneh pada dirinya sendiri): </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, jsonData.data);</code> </pre> <br><p>  Namun menurut pendapat kami, menulis naskah untuk naskah yang sederhana dan sering digunakan seperti itu tampak berlebihan.  Oleh karena itu, di TestMace dimungkinkan untuk menetapkan sepotong respons ke variabel menggunakan antarmuka grafis.  Lihatlah betapa sederhananya: </p><br><p><img src="https://habrastorage.org/webt/3z/w8/qm/3zw8qmh_a7cnwz2wqkozfw4bv8s.gif"></p><br><p>  Dan sekarang, dengan setiap permintaan, variabel dinamis ini akan diperbarui.  Tetapi Anda dapat berdebat, dengan alasan bahwa pendekatan tukang pos lebih fleksibel dan memungkinkan Anda tidak hanya untuk membuat tugas, tetapi juga untuk melakukan beberapa preprocessing.  Berikut ini cara mengubah contoh sebelumnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, CryptoJS.MD5(jsonData.data));</code> </pre> <br><p>  Nah, untuk ini, TestMace memiliki simpul <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">skrip</a> yang mencakup skrip ini.  Untuk mereproduksi kasus sebelumnya, tetapi sudah dalam pelaksanaan TestMace, perlu untuk membuat simpul skrip setelah permintaan dan menggunakan kode berikut sebagai skrip: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = tm.currentNode.prev.response.body.data; tm.currentNode.parent.setDynamicVar(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, crypto.MD5(data));</code> </pre> <br><p>  Seperti yang Anda lihat, komposisi node juga melayani layanan yang baik di sini.  Dan untuk kasus sederhana seperti yang dijelaskan di atas, Anda cukup menetapkan ekspresi <code>${crypto.MD5($response.data)}</code> variabel yang dibuat melalui antarmuka grafis! </p><br><h2 id="sozdanie-testov-cherez-gui">  Membuat tes melalui GUI </h2><br><p>  Tukang pos memungkinkan Anda untuk membuat tes dengan menulis skrip (dalam kasus Tukang pos, ini JavaScript).  Pendekatan ini memiliki keunggulan yang solid - fleksibilitas yang hampir tidak terbatas, ketersediaan solusi siap pakai, dll. </p><br><p>  Namun, kenyataannya sering seperti itu (kami tidak, hidup seperti itu) sehingga tester tidak memiliki keterampilan pemrograman, dan saya ingin membawa manfaat bagi tim sekarang.  Untuk kasus seperti itu, mengikuti konsep tanpa kode, TestMace memungkinkan Anda membuat tes sederhana melalui antarmuka grafis tanpa menggunakan skrip penulisan.  Di sini, misalnya, tampak seperti proses membuat tes yang membandingkan nilai untuk kesetaraan: </p><br><p><img src="https://habrastorage.org/webt/fv/i-/k6/fvi-k6da_gymia7jfvt0kmx1aps.gif"></p><br><p>  Namun, membuat tes dalam editor grafis tidak menghalangi kemampuan untuk <a href="https://docs-ru.testmace.com/node-types/assertion/script" rel="nofollow">menulis tes dalam kode</a> .  Di sini semua pustaka yang sama seperti pada skrip node, dan <a href="https://www.chaijs.com/" rel="nofollow">chai</a> untuk menulis tes. </p><br><h2 id="vozmozhnost-zapustit-uzhe-suschestvuyuschiy-scenariy-po-ssylke-link-uzel">  Kemampuan untuk menjalankan skrip yang ada dengan referensi (Tautan simpul) </h2><br><p>  Situasi seperti itu sering muncul ketika permintaan tertentu atau bahkan seluruh naskah perlu dijalankan beberapa kali di berbagai bagian proyek.  Contoh dari permintaan tersebut adalah otorisasi multi-tahap khusus, membawa lingkungan ke keadaan yang diinginkan, dll.  Secara umum, berbicara dalam hal bahasa pemrograman, saya ingin memiliki fungsi yang dapat digunakan kembali di berbagai bagian aplikasi.  Di TestMace, fungsi ini dilakukan oleh simpul <a href="https://docs-ru.testmace.com/node-types/link" rel="nofollow">tautan</a> .  Menggunakannya sangat sederhana: <br>  1) buat kueri atau skrip <br>  2) membuat simpul bertipe Link <br>  3) pada parameter tentukan tautan ke skrip yang dibuat pada langkah pertama </p><br><p>  Dalam versi yang lebih maju, Anda dapat menentukan variabel dinamis mana dari skrip yang dilemparkan ke tingkat yang lebih tinggi relatif terhadap tautan.  Kedengarannya membingungkan?  Misalkan kita membuat Folder bernama <strong>create-post</strong> , di dalamnya variabel dinamis <code>postId</code> ditugaskan ke node ini.  Sekarang di <strong>tautan</strong> node <strong>create-post-link</strong> , Anda dapat secara eksplisit menentukan bahwa variabel <code>postId</code> ditugaskan ke leluhur <strong>create-post-link</strong> .  Mekanisme ini (sekali lagi, dinyatakan dalam bahasa pemrogram) dapat digunakan untuk mengembalikan hasil dari "fungsi".  Secara umum, keren, KERING dalam pertumbuhan penuh dan sekali lagi tidak satu baris kode pun dirugikan. </p><br><p><img src="https://habrastorage.org/webt/yo/8s/nj/yo8snjixc2ozh3vdrhprnstmess.gif"></p><br><p>  Adapun Postman, permintaan fitur untuk menggunakan kembali permintaan telah <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">menggantung sejak 2015</a> , dan tampaknya ada <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">beberapa petunjuk</a> bahwa mereka sedang mengerjakan masalah ini.  Dalam bentuknya yang sekarang, Postman, tentu saja, memiliki kemampuan untuk mengubah alur eksekusi, yang secara teori mungkin memungkinkan Anda untuk menerapkan perilaku ini, tetapi ini lebih merupakan hack kotor daripada pendekatan yang benar-benar bekerja. </p><br><h2 id="prochie-otlichiya">  Perbedaan lainnya </h2><br><ul><li>  Kontrol yang lebih besar atas ruang lingkup variabel.  Ruang lingkup terkecil di mana Anda dapat mendefinisikan variabel di Postman adalah koleksi.  TestMace memungkinkan Anda untuk menentukan variabel untuk kueri atau folder apa pun.  Di Postman, koleksi Share memungkinkan Anda untuk mengekspor koleksi saja, sementara di berbagi TestMace berfungsi untuk setiap node. </li><li>  TestMace mendukung <a href="http-headers" rel="nofollow">header yang diwarisi</a> , yang secara default dapat diganti dengan permintaan anak.  Dalam Postman, ada <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">tugas</a> dalam hal ini, dan bahkan ditutup, tetapi sebagai solusi diusulkan ... untuk <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">menggunakan skrip</a> .  Di TestMace, ini semua dikonfigurasikan melalui GUI dan ada opsi untuk menonaktifkan header bawaan di turunan spesifik </li><li>  Undo / Redo.  Ia bekerja tidak hanya ketika mengedit node, tetapi juga ketika memindahkan, menghapus, mengganti nama dan operasi lain yang mengubah struktur proyek </li><li>  File yang dilampirkan pada permintaan menjadi bagian dari proyek dan disimpan dengan itu, sementara disinkronkan dengan sempurna, tidak seperti Postman.  (Ya, Anda tidak perlu lagi memilih file secara manual setiap kali Anda memulai dan mentransfernya ke kolega di arsip) </li></ul><br><h2 id="fichi-kotorye-uzhe-na-podhode">  Fitur yang ada di jalan </h2><br><p>  Kami tidak bisa menahan godaan untuk membuka tabir kerahasiaan atas rilis berikutnya, terutama ketika fungsionalitasnya sangat lezat dan sudah mengalami penggilingan pra-rilis.  Jadi kita bertemu. </p><br><h3 id="funkcii">  Fungsi </h3><br><p>  Seperti yang Anda ketahui, Postman menggunakan apa yang disebut variabel dinamis untuk menghasilkan nilai.  <a href="https://learning.getpostman.com/docs/postman/variables-and-environments/variables-list/" rel="nofollow">Daftarnya mengesankan</a> dan sebagian besar fungsi berfungsi untuk menghasilkan nilai palsu.  Misalnya, untuk menghasilkan email acak, Anda perlu menulis: </p><br><pre> <code class="plaintext hljs">{{$randomEmail}}</code> </pre> <br><p>  Namun, karena ini adalah variabel (meskipun yang dinamis), mereka tidak dapat digunakan sebagai fungsi: mereka tidak dapat diparameterisasi, karena itu tidak akan berfungsi untuk mengambil hash dari string. </p><br><p>  Di TestMace, kami berencana untuk menambahkan fitur yang jujur.  Tepat di dalam $ {} Anda tidak hanya dapat mengakses variabel, tetapi juga memanggil fungsi.  Yaitu  jika Anda perlu membuat email palsu terkenal, kami hanya menulis </p><br><pre> <code class="plaintext hljs">${faker.internet.email()}</code> </pre> <br><p>  Selain fakta bahwa ini adalah fungsi, Anda dapat melihat bahwa ada kemungkinan memanggil metode objek.  Dan alih-alih daftar besar variabel dinamis, kami memiliki satu set objek yang dikelompokkan secara logis. </p><br><p>  Tetapi bagaimana jika kita ingin menghitung hash dari string?  Mudah! </p><br><pre> <code class="plaintext hljs">${crypto.MD5($dynamicVar.data)}</code> </pre> <br><p>  Anda mungkin memperhatikan bahwa Anda bahkan dapat meneruskan variabel sebagai parameter!  Di tempat ini, pembaca yang ingin tahu mungkin curiga ada yang salah ... </p><br><h3 id="ispolzovanie-javascript-v-vyrazheniyah">  Menggunakan JavaScript dalam ekspresi </h3><br><p>  ... Dan tidak sia-sia!  Ketika persyaratan untuk fungsi dibentuk, kami tiba-tiba sampai pada kesimpulan bahwa dalam ekspresi Anda perlu membiarkan javascript yang valid ditulis.  Jadi sekarang Anda bebas menulis ekspresi dalam semangat: </p><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> + crypto.MD5(<span class="hljs-string"><span class="hljs-string">'asdf'</span></span>)}</code> </pre> <br><p>  Dan semua ini tanpa skrip tepat di kolom input! </p><br><p>  Sedangkan untuk Postman, hanya variabel yang dapat digunakan, dan ketika mencoba menulis sedikit ekspresi, validator bersumpah dan menolak untuk menghitungnya. </p><br><p><img src="https://habrastorage.org/webt/a_/ul/53/a_ul5311im7wyvy-b1_vlqqlifw.png"></p><br><h3 id="prodvinutoe-avtodopolnenie">  Penyelesaian otomatis tingkat lanjut </h3><br><p>  Saat ini, TestMace memiliki pelengkapan otomatis standar, yang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/kl/2b/ub/kl2bubsefwlskk59_qtdijhdnn0.png"></p><br><p>  Di sini, di samping baris lengkapi-otomatis, apa yang termasuk dalam baris ini diindikasikan.  Mekanisme ini hanya berfungsi dalam ekspresi yang dibingkai dengan tanda kurung $ {}. </p><br><p>  Seperti yang dapat Anda lihat, penanda visual telah ditambahkan yang menunjukkan jenis variabel (misalnya, string, angka, array, dll.).  Anda juga dapat mengubah mode penyelesaian otomatis (misalnya, Anda dapat memilih penyelesaian otomatis dengan variabel atau header).  Tetapi bahkan ini bukan hal yang paling penting! </p><br><p>  Pertama, penyelesaian otomatis berfungsi bahkan dalam ekspresi (jika memungkinkan).  Begini tampilannya: </p><br><p><img src="https://habrastorage.org/webt/vk/vg/f5/vkvgf5vtk4sjh7r1tzamrdpojcm.png"></p><br><p>  Dan kedua, sekarang pelengkapan otomatis juga tersedia dalam skrip.  Lihatlah cara kerjanya! </p><br><p><img src="https://habrastorage.org/webt/ea/rd/2l/eard2lfj7wmtu4189xn-wy2tjjk.gif"></p><br><p>  Tidak masuk akal untuk membandingkan fungsi ini dengan tukang pos - ada penyelesaian otomatis terbatas hanya untuk daftar variabel statis, header dan nilai-nilainya (koreksi saya jika saya lupa itu).  Skrip tidak dilengkapi secara otomatis :( </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Pada bulan Oktober, satu tahun telah berlalu sejak awal pengembangan produk kami.  Selama waktu ini, kami berhasil melakukan banyak hal dan dalam beberapa hal berhasil menyusul pesaing kami.  Namun bagaimanapun, tujuan kami adalah membuat alat yang sangat nyaman untuk bekerja dengan API.  Kami masih memiliki banyak pekerjaan yang harus dilakukan, berikut ini adalah rencana pengembangan kasar untuk proyek kami untuk tahun mendatang: <a href="https://testmace.com/roadmap/" rel="nofollow">https://testmace.com/roadmap</a> . </p><br><p>  Umpan balik Anda akan memungkinkan kami untuk menavigasi dengan lebih baik dalam banyak fitur, dan dukungan Anda akan memberi kami kekuatan dan kepercayaan diri bahwa kami melakukan hal yang benar.  Kebetulan hari ini adalah hari yang penting untuk proyek kami - hari penerbitan TestMace di <a href="https://www.producthunt.com/posts/testmace" rel="nofollow">ProductHunt</a> .  Tolong dukung proyek kami, ini sangat penting bagi kami.  Terlebih lagi, di halaman PH kami hari ini adalah tawaran yang menggiurkan, dan itu terbatas </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480734/">https://habr.com/ru/post/id480734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480714/index.html">Bagaimana cara menambahkan codec ke FFmpeg</a></li>
<li><a href="../id480716/index.html">Matlab vs. Julia vs. Python</a></li>
<li><a href="../id480718/index.html">6 Tips untuk Tinjauan Kode yang Sukses</a></li>
<li><a href="../id480724/index.html">Bahasa yang ditranskompilasi: proyek konversi kode-ke-kode</a></li>
<li><a href="../id480730/index.html">Pengembangan Auto-Moto dan Nginx</a></li>
<li><a href="../id480736/index.html">Mengapa tidak semua kesalahan perlu diperbaiki untuk membuat produk TI lebih baik</a></li>
<li><a href="../id480738/index.html">Pengalaman dalam menciptakan produk di Rusia atau Cara membuat penyedot debu nirkabel "rakyat" PRO-EXPERT</a></li>
<li><a href="../id480740/index.html">4 fitur Numpy keren yang saya gunakan terus-menerus</a></li>
<li><a href="../id480744/index.html">Bagaimana seorang programmer bisa melindungi proyek kesayangannya</a></li>
<li><a href="../id480746/index.html">Preload di php 7.4: Komposer dan pilih file untuk preload</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>