<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 👨‍👧‍👦 👨🏼 Aprenda o OpenGL. Lição 5.8 - Bloom 🐵 🤚🏼 🐩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloom 
 Devido à gama limitada de brilho disponível para monitores convencionais, a tarefa de exibir de forma convincente fontes de luz brilhante e su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Lição 5.8 - Bloom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  Bloom </h2><br>  Devido à gama limitada de brilho disponível para monitores convencionais, a tarefa de exibir de forma convincente fontes de luz brilhante e superfícies iluminadas é difícil por definição.  Um dos métodos comuns para destacar áreas claras no monitor é uma técnica que adiciona um halo de brilho ao redor de objetos brilhantes, dando a impressão de "espalhar" a luz para fora da fonte de luz.  Como resultado, o observador dá a impressão de um alto brilho dessas áreas iluminadas ou fontes de luz. <br><br>  O efeito descrito de um halo e a saída da luz além da fonte são alcançados por uma técnica de pós-processamento chamada <i>bloom</i> .  A aplicação do efeito adiciona um halo característico de brilho a todas as áreas brilhantes da cena exibida, que podem ser vistas no exemplo abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text">  Parte 1. Introdução <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá triângulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol><br>  Parte 2. Iluminação básica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noções básicas de iluminação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Várias fontes de iluminação</a> </li></ol><br>  Parte 3. Baixe modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de polígono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol><br>  Parte 4. Recursos avançados do OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de estêncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões cúbicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipulação avançada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avançado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geométrico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suavização</a> </li></ol><br>  Parte 5. Iluminação Avançada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Iluminação avançada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Correção gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderização adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz analítica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradiação difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposição no espelho.</a> </li></ol><br></div></div><br>  Bloom adiciona uma pista visual distinta à imagem sobre o brilho significativo dos objetos cobertos pelo halo do efeito aplicado.  Sendo aplicado de maneira seletiva e precisa (com a qual muitos jogos, infelizmente, não conseguem lidar), o efeito pode melhorar significativamente a expressividade visual da iluminação usada na cena, além de adicionar drama em determinadas situações. <br><br>  Essa técnica funciona em conjunto com a renderização <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> quase como uma adição evidente.  Aparentemente, por causa disso, muitas pessoas misturam equivocadamente esses dois termos com a total permutabilidade.  No entanto, essas técnicas são completamente independentes e são usadas para diferentes fins.  É possível implementar bloom usando o buffer de quadro padrão com profundidade de cor de 8 bits, assim como aplicar a renderização HDR sem recorrer ao uso de bloom.  A única coisa é que a renderização HDR permite implementar o efeito de uma maneira mais eficiente (veremos isso mais adiante). <br><br>  Para implementar a floração, a cena iluminada é renderizada primeiro da maneira usual.  Em seguida, um buffer de cores HDR e um buffer de cores contendo apenas partes brilhantes da cena são extraídos.  Essa imagem de parte brilhante extraída é então borrada e sobreposta à imagem HDR original da cena. <br><br>  Para tornar mais claro, analisaremos o processo passo a passo.  Renderize uma cena contendo 4 fontes de luz brilhante exibidas como cubos coloridos.  Todos eles têm um valor de brilho na faixa de 1,5 a 15,0.  Se o buffer de cores for enviado para o HDR, o resultado será o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br>  A partir desse buffer de cores HDR, extraímos todos os fragmentos cujo brilho excede um limite predeterminado.  Acontece que uma imagem contém apenas áreas bem iluminadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br>  Além disso, esta imagem de áreas brilhantes é desfocada.  A severidade do efeito é essencialmente determinada pela força e pelo raio do filtro de desfoque aplicado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br>  A imagem borrada resultante de áreas brilhantes é a base do efeito final de halos em torno de objetos brilhantes.  Essa textura é simplesmente misturada com a imagem HDR original da cena.  Como as áreas brilhantes foram borradas, seus tamanhos aumentaram, o que, em última análise, fornece um efeito visual de luminosidade que ultrapassa os limites das fontes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br>  Como você pode ver, o bloom não é a técnica mais sofisticada, mas alcançar sua alta qualidade visual e confiabilidade nem sempre é fácil.  Na maior parte, o efeito depende da qualidade e do tipo de filtro de desfoque aplicado.  Mesmo pequenas alterações nos parâmetros do filtro podem alterar drasticamente a qualidade final do equipamento. <br><br>  Portanto, as ações acima fornecem um algoritmo passo a passo do efeito pós-processamento para o efeito bloom.  A imagem abaixo resume as ações necessárias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br>  Antes de tudo, precisamos de informações sobre as partes brilhantes da cena com base em um determinado valor limite.  É isso que faremos. <br><br><h2>  Extrair destaques </h2><br>  Então, para iniciantes, precisamos obter duas imagens com base em nossa cena.  Seria ingênuo renderizar duas vezes, mas use o método <i>MRT</i> ( <i>Multiple Render Targets</i> ) mais avançado: especificamos mais de uma saída no shader de fragmento final e, graças a isso, duas imagens podem ser extraídas em uma única passagem!  Para especificar em qual buffer de cores o sombreador será produzido, o especificador de <i>layout</i> é usado: <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br>  Obviamente, o método só funcionará se tivermos preparado vários buffers para a escrita.  Em outras palavras, para implementar várias saídas do shader de fragmento, o buffer de quadro usado neste momento deve conter um número suficiente de buffers de cores conectados.  Se passarmos para a lição sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer de quadros</a> , lembre-se de que, ao vincular a textura como um buffer de cores, poderíamos indicar o <i>número do anexo de cores</i> .  Até agora, não precisávamos usar um anexo que não <i>fosse GL_COLOR_ATTACHMENT0</i> , mas desta vez <i>GL_COLOR_ATTACHMENT1</i> será útil, pois precisamos de dois objetivos para gravar ao mesmo tempo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br>  Além disso, chamando <i>glDrawBuffers</i> , você precisará informar explicitamente ao OpenGL que iremos <i>gerar</i> vários buffers.  Caso contrário, a biblioteca ainda produzirá apenas o primeiro anexo, ignorando as operações de gravação em outros anexos.  Como argumento para a função, é passada uma matriz de identificadores dos anexos usados ​​da enumeração correspondente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br>  Para esse buffer de quadro, qualquer sombreador de fragmento que especifique um especificador de <i>local</i> para suas saídas será gravado no buffer de cores correspondente.  E isso é uma ótima notícia, pois dessa maneira evitamos o passe de renderização desnecessário para extrair dados sobre as partes brilhantes da cena - você pode fazer tudo de uma vez em um único sombreador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br>  Neste fragmento, a parte que contém o código típico para calcular a iluminação é omitida.  Seu resultado é gravado na primeira saída do shader - a variável <i>FragColor</i> .  Em seguida, a cor resultante do fragmento é usada para calcular o valor do brilho.  Para isso, é realizada uma tradução ponderada em escala de cinza (por multiplicação escalar, multiplicamos os componentes correspondentes dos vetores e os adicionamos, resultando em um único valor).  Então, quando o brilho de um fragmento de um determinado limite é excedido, registramos sua cor na segunda saída do shader.  Para cubos substituindo fontes de luz, esse sombreador também é executado. <br><br>  Tendo descoberto o algoritmo, podemos entender por que essa técnica funciona tão bem com a renderização HDR.  A renderização no formato HDR permite que os componentes de cor ultrapassem o limite superior de 1,0, o que permite ajustar de forma mais flexível o limite de brilho fora do intervalo padrão [0., 1.], fornecendo a capacidade de ajustar com precisão quais partes da cena são consideradas brilhantes.  Sem usar o HDR, você terá que se contentar com um limite de brilho no intervalo [0., 1.], o que é bastante aceitável, mas leva a um corte mais "nítido" no brilho, o que geralmente torna a flor muito invasiva e chamativa (imagine-se em um campo de neve no alto das montanhas) . <br><br>  Após a execução do shader, dois buffers de destino conterão uma imagem normal da cena, bem como uma imagem contendo apenas áreas claras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br>  Agora, a imagem das áreas claras deve ser processada com o desfoque.  Você pode fazer isso com um simples filtro retangular ( <i>caixa</i> ), usado na seção de pós-processamento da lição do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer de quadros</a> .  Mas um resultado muito melhor é obtido pela <i>filtragem de Gauss</i> . <br><br><h2>  Gaussian Blur </h2><br>  A lição de pós-processamento nos deu uma idéia de desfoque usando a média simples de cores dos fragmentos de imagem adjacentes.  Esse método de desfoque é simples, mas a imagem resultante pode parecer mais atraente.  O desfoque gaussiano é baseado na curva de distribuição em forma de sino com o mesmo nome: valores altos da função estão localizados mais perto do centro da curva e caem nos dois lados dela.  Matematicamente, uma curva gaussiana pode ser expressa com diferentes parâmetros, mas a forma geral da curva permanece a seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br>  O desfoque com pesos com base nos valores da curva de Gauss parece muito melhor do que um filtro retangular: devido ao fato de a curva ter uma área maior nas proximidades de seu centro, o que corresponde a pesos maiores para fragmentos próximos ao centro do núcleo do filtro.  Tomando, por exemplo, o núcleo de 32x32, usaremos os fatores de ponderação quanto menor, mais distante o fragmento do central.  É essa característica de filtro que fornece um resultado de desfoque Gaussiano visualmente mais satisfatório. <br><br>  A implementação do filtro exigirá uma matriz bidimensional de coeficientes de ponderação, que poderá ser preenchida com base na expressão bidimensional que descreve a curva gaussiana.  No entanto, encontraremos imediatamente um problema de desempenho: mesmo um núcleo de desfoque relativamente pequeno em um fragmento de 32x32 exigirá 1024 amostras de textura para cada fragmento da imagem processada! <br><br>  Felizmente para nós, a expressão da curva gaussiana tem uma característica matemática muito conveniente - separabilidade, que permitirá criar duas expressões unidimensionais a partir de uma expressão bidimensional que descrevem os componentes horizontais e verticais.  Isso permitirá que o desfoque, por sua vez, seja feito em duas abordagens: horizontalmente e verticalmente com conjuntos de pesos correspondentes a cada uma das direções.  A imagem resultante será a mesma do processamento de um algoritmo bidimensional, mas exigirá muito menos poder de processamento do processador de vídeo: em vez de 1024 amostras da textura, precisamos apenas de 32 + 32 = 64!  Essa é a essência da filtração gaussiana de duas passagens. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br>  Para nós, tudo isso significa uma coisa: o desfoque de uma imagem terá que ser feito duas vezes, e aqui o uso de objetos de buffer de quadro será útil.  Aplicamos a chamada técnica de pingue-pongue: existem alguns objetos de buffer de quadro e o conteúdo do buffer de cores de um framebuffer é renderizado com algum processamento no buffer de cores do framebuffer atual; em seguida, o framebuffer de origem e o framebuffer-receiver são trocados e esse processo é repetido um determinado número de vezes.  De fato, o buffer de quadro atual para exibir a imagem é simplesmente alternado e, com ele, a textura atual a partir da qual a amostragem é realizada para renderização.  A abordagem permite que você desfoque a imagem original colocando-a no primeiro buffer de quadro, depois desfoque o conteúdo do primeiro buffer de quadro, coloque-o no segundo e depois desfoque o segundo, colocando-o no primeiro e assim por diante. <br><br>  Antes de passar para o código de ajuste do buffer de quadro, vamos dar uma olhada no código do Gaussian Blur Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Como você pode ver, usamos uma amostra bastante pequena de coeficientes da curva gaussiana, que são usados ​​como pesos para amostras horizontal ou verticalmente em relação ao fragmento atual.  O código possui duas ramificações principais que dividem o algoritmo em passagem vertical e horizontal com base no valor do uniforme <i>horizontal</i> .  O deslocamento para cada amostra é definido igual ao tamanho texel, que é definido como o inverso do tamanho da textura (um valor do tipo <i>vec2</i> retornado pela função <i>textureSize</i> ()). <br><br>  Crie dois buffers de quadro contendo um buffer de cor com base na textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  Depois de obter a textura HDR da cena e extrair a textura das áreas brilhantes, preenchemos o buffer de cores de um dos pares de framebuffers preparados com a textura de brilho e iniciamos o processo de ping-pong dez vezes (cinco vezes na vertical, cinco na horizontal): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Em cada iteração, selecionamos e ancoramos um dos buffers de quadro, com base em se essa iteração será borrada horizontal ou verticalmente, e o buffer de cores do outro buffer de moldura será usado como textura de entrada para o sombreador de desfoque.  Na primeira iteração, temos que usar explicitamente uma imagem contendo áreas claras ( <i>brightnessTexture</i> ) - caso contrário, os dois buffers de pingue-pongue permanecerão vazios.  Após dez passagens, a imagem original assume a forma de cinco vezes embaçada por um filtro gaussiano completo.  A abordagem usada nos permite alterar facilmente o grau de desfoque: quanto mais iterações de pingue-pongue, mais forte o desfoque. <br><br>  No nosso caso, o resultado do desfoque é mais ou menos assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br>  Para concluir o efeito, resta apenas combinar a imagem tremida com a imagem HDR original da cena. <br><br><h2>  Mistura de textura </h2><br>  Tendo em mãos a textura HDR da cena renderizada e a textura borrada das áreas superexpostas, tudo o que você precisa para perceber o famoso efeito de brilho ou flor é combinar essas duas imagens.  O sombreador final do fragmento (muito semelhante ao apresentado na lição sobre o formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> ) faz exatamente isso - ele adiciona duas texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  O que procurar: a mixagem é feita antes de aplicar o <i>mapeamento de tons</i> .  Isso traduzirá corretamente o brilho adicional do efeito para a <i>faixa</i> LDR ( <i>baixa faixa dinâmica</i> ), mantendo a distribuição relativa do brilho na cena. <br><br>  O resultado do processamento - todas as áreas brilhantes receberam um efeito de brilho perceptível: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br>  Os cubos que substituem as fontes de luz agora parecem muito mais brilhantes e transmitem melhor a impressão de uma fonte de luz.  Essa cena é bastante primitiva, porque a implementação do efeito de entusiasmo especial não causará, mas em cenas complexas com iluminação cuidadosa, um florescimento realizado qualitativamente pode ser um elemento visual crucial que acrescenta drama. <br><br>  O código fonte do exemplo está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Observo que a lição usou um filtro bastante simples com apenas cinco amostras em cada direção.  Fazendo mais amostras em um raio maior ou executando várias iterações do filtro, você pode melhorar visualmente o efeito.  Além disso, vale dizer que visualmente a qualidade de todo o efeito depende diretamente da qualidade do algoritmo de desfoque usado.  Ao melhorar o filtro, você pode obter melhorias significativas e todo o efeito.  Por exemplo, um resultado mais impressionante é mostrado pela combinação de vários filtros com diferentes tamanhos de núcleo ou diferentes curvas gaussianas.  A seguir, são apresentados recursos adicionais da Kalogirou e da EpicGames, que abordam como melhorar a qualidade da floração, modificando o desfoque gaussiano. <br><br><h2>  Recursos Adicionais </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desfoque Gaussiano eficiente com amostragem linear</a> : uma descrição qualitativa da operação do filtro Gaussiano, juntamente com o estudo de melhoria do desempenho do método através do uso de filtragem bilinear de amostras de textura OpenGL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeito Bloom Post Process</a> : um artigo da EpicGames sobre como melhorar a qualidade de um efeito combinando várias curvas de Gauss. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como fazer bom bloom para renderização HDR</a> : um artigo de Kalogirou descrevendo a melhoria no bloom modificando o algoritmo de filtro Gauss original. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420375/">https://habr.com/ru/post/pt420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420363/index.html">Webinars da HPE de agosto a outubro: novos tópicos (+ SHD, prática de IA, armazenamento de petabytes pronto para uso)</a></li>
<li><a href="../pt420367/index.html">Apocalipse com ar condicionado: cenário de apagão da rede inteligente</a></li>
<li><a href="../pt420369/index.html">Comutação extrema de borda estendida ou IEEE 802.1BR</a></li>
<li><a href="../pt420371/index.html">Sobre a questão da construção de bicicletas no campo do armazenamento de correio elétrico</a></li>
<li><a href="../pt420373/index.html">Quase OCR para obter a senha do VPNBook. PHP + Mikrotik</a></li>
<li><a href="../pt420377/index.html">Como iniciamos as videochamadas</a></li>
<li><a href="../pt420381/index.html">Por que basta considerar as redes neurais como uma caixa preta?</a></li>
<li><a href="../pt420383/index.html">"Yandex.Money não lhe interessa inserir sua inscrição."</a></li>
<li><a href="../pt420385/index.html">Teste de integração baseada em contêiner</a></li>
<li><a href="../pt420387/index.html">Três cubos de Rubik inteligentes: Xiaomi, Roobo e GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>