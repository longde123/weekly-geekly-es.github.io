<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üë®‚Äçüëß‚Äçüë¶ üë®üèº Aprenda o OpenGL. Li√ß√£o 5.8 - Bloom üêµ ü§öüèº üê©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloom 
 Devido √† gama limitada de brilho dispon√≠vel para monitores convencionais, a tarefa de exibir de forma convincente fontes de luz brilhante e su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Li√ß√£o 5.8 - Bloom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  Bloom </h2><br>  Devido √† gama limitada de brilho dispon√≠vel para monitores convencionais, a tarefa de exibir de forma convincente fontes de luz brilhante e superf√≠cies iluminadas √© dif√≠cil por defini√ß√£o.  Um dos m√©todos comuns para destacar √°reas claras no monitor √© uma t√©cnica que adiciona um halo de brilho ao redor de objetos brilhantes, dando a impress√£o de "espalhar" a luz para fora da fonte de luz.  Como resultado, o observador d√° a impress√£o de um alto brilho dessas √°reas iluminadas ou fontes de luz. <br><br>  O efeito descrito de um halo e a sa√≠da da luz al√©m da fonte s√£o alcan√ßados por uma t√©cnica de p√≥s-processamento chamada <i>bloom</i> .  A aplica√ß√£o do efeito adiciona um halo caracter√≠stico de brilho a todas as √°reas brilhantes da cena exibida, que podem ser vistas no exemplo abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do</b> <div class="spoiler_text">  Parte 1. Introdu√ß√£o <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cria√ß√£o de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° tri√¢ngulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transforma√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol><br>  Parte 2. Ilumina√ß√£o b√°sica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas de ilumina√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°rias fontes de ilumina√ß√£o</a> </li></ol><br>  Parte 3. Baixe modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de pol√≠gono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol><br>  Parte 4. Recursos avan√ßados do OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de est√™ncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes c√∫bicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipula√ß√£o avan√ßada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avan√ßado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suaviza√ß√£o</a> </li></ol><br>  Parte 5. Ilumina√ß√£o Avan√ßada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ilumina√ß√£o avan√ßada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corre√ß√£o gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz anal√≠tica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradia√ß√£o difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposi√ß√£o no espelho.</a> </li></ol><br></div></div><br>  Bloom adiciona uma pista visual distinta √† imagem sobre o brilho significativo dos objetos cobertos pelo halo do efeito aplicado.  Sendo aplicado de maneira seletiva e precisa (com a qual muitos jogos, infelizmente, n√£o conseguem lidar), o efeito pode melhorar significativamente a expressividade visual da ilumina√ß√£o usada na cena, al√©m de adicionar drama em determinadas situa√ß√µes. <br><br>  Essa t√©cnica funciona em conjunto com a renderiza√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> quase como uma adi√ß√£o evidente.  Aparentemente, por causa disso, muitas pessoas misturam equivocadamente esses dois termos com a total permutabilidade.  No entanto, essas t√©cnicas s√£o completamente independentes e s√£o usadas para diferentes fins.  √â poss√≠vel implementar bloom usando o buffer de quadro padr√£o com profundidade de cor de 8 bits, assim como aplicar a renderiza√ß√£o HDR sem recorrer ao uso de bloom.  A √∫nica coisa √© que a renderiza√ß√£o HDR permite implementar o efeito de uma maneira mais eficiente (veremos isso mais adiante). <br><br>  Para implementar a flora√ß√£o, a cena iluminada √© renderizada primeiro da maneira usual.  Em seguida, um buffer de cores HDR e um buffer de cores contendo apenas partes brilhantes da cena s√£o extra√≠dos.  Essa imagem de parte brilhante extra√≠da √© ent√£o borrada e sobreposta √† imagem HDR original da cena. <br><br>  Para tornar mais claro, analisaremos o processo passo a passo.  Renderize uma cena contendo 4 fontes de luz brilhante exibidas como cubos coloridos.  Todos eles t√™m um valor de brilho na faixa de 1,5 a 15,0.  Se o buffer de cores for enviado para o HDR, o resultado ser√° o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br>  A partir desse buffer de cores HDR, extra√≠mos todos os fragmentos cujo brilho excede um limite predeterminado.  Acontece que uma imagem cont√©m apenas √°reas bem iluminadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br>  Al√©m disso, esta imagem de √°reas brilhantes √© desfocada.  A severidade do efeito √© essencialmente determinada pela for√ßa e pelo raio do filtro de desfoque aplicado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br>  A imagem borrada resultante de √°reas brilhantes √© a base do efeito final de halos em torno de objetos brilhantes.  Essa textura √© simplesmente misturada com a imagem HDR original da cena.  Como as √°reas brilhantes foram borradas, seus tamanhos aumentaram, o que, em √∫ltima an√°lise, fornece um efeito visual de luminosidade que ultrapassa os limites das fontes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br>  Como voc√™ pode ver, o bloom n√£o √© a t√©cnica mais sofisticada, mas alcan√ßar sua alta qualidade visual e confiabilidade nem sempre √© f√°cil.  Na maior parte, o efeito depende da qualidade e do tipo de filtro de desfoque aplicado.  Mesmo pequenas altera√ß√µes nos par√¢metros do filtro podem alterar drasticamente a qualidade final do equipamento. <br><br>  Portanto, as a√ß√µes acima fornecem um algoritmo passo a passo do efeito p√≥s-processamento para o efeito bloom.  A imagem abaixo resume as a√ß√µes necess√°rias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br>  Antes de tudo, precisamos de informa√ß√µes sobre as partes brilhantes da cena com base em um determinado valor limite.  √â isso que faremos. <br><br><h2>  Extrair destaques </h2><br>  Ent√£o, para iniciantes, precisamos obter duas imagens com base em nossa cena.  Seria ing√™nuo renderizar duas vezes, mas use o m√©todo <i>MRT</i> ( <i>Multiple Render Targets</i> ) mais avan√ßado: especificamos mais de uma sa√≠da no shader de fragmento final e, gra√ßas a isso, duas imagens podem ser extra√≠das em uma √∫nica passagem!  Para especificar em qual buffer de cores o sombreador ser√° produzido, o especificador de <i>layout</i> √© usado: <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br>  Obviamente, o m√©todo s√≥ funcionar√° se tivermos preparado v√°rios buffers para a escrita.  Em outras palavras, para implementar v√°rias sa√≠das do shader de fragmento, o buffer de quadro usado neste momento deve conter um n√∫mero suficiente de buffers de cores conectados.  Se passarmos para a li√ß√£o sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer de quadros</a> , lembre-se de que, ao vincular a textura como um buffer de cores, poder√≠amos indicar o <i>n√∫mero do anexo de cores</i> .  At√© agora, n√£o precis√°vamos usar um anexo que n√£o <i>fosse GL_COLOR_ATTACHMENT0</i> , mas desta vez <i>GL_COLOR_ATTACHMENT1</i> ser√° √∫til, pois precisamos de dois objetivos para gravar ao mesmo tempo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br>  Al√©m disso, chamando <i>glDrawBuffers</i> , voc√™ precisar√° informar explicitamente ao OpenGL que iremos <i>gerar</i> v√°rios buffers.  Caso contr√°rio, a biblioteca ainda produzir√° apenas o primeiro anexo, ignorando as opera√ß√µes de grava√ß√£o em outros anexos.  Como argumento para a fun√ß√£o, √© passada uma matriz de identificadores dos anexos usados ‚Äã‚Äãda enumera√ß√£o correspondente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br>  Para esse buffer de quadro, qualquer sombreador de fragmento que especifique um especificador de <i>local</i> para suas sa√≠das ser√° gravado no buffer de cores correspondente.  E isso √© uma √≥tima not√≠cia, pois dessa maneira evitamos o passe de renderiza√ß√£o desnecess√°rio para extrair dados sobre as partes brilhantes da cena - voc√™ pode fazer tudo de uma vez em um √∫nico sombreador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br>  Neste fragmento, a parte que cont√©m o c√≥digo t√≠pico para calcular a ilumina√ß√£o √© omitida.  Seu resultado √© gravado na primeira sa√≠da do shader - a vari√°vel <i>FragColor</i> .  Em seguida, a cor resultante do fragmento √© usada para calcular o valor do brilho.  Para isso, √© realizada uma tradu√ß√£o ponderada em escala de cinza (por multiplica√ß√£o escalar, multiplicamos os componentes correspondentes dos vetores e os adicionamos, resultando em um √∫nico valor).  Ent√£o, quando o brilho de um fragmento de um determinado limite √© excedido, registramos sua cor na segunda sa√≠da do shader.  Para cubos substituindo fontes de luz, esse sombreador tamb√©m √© executado. <br><br>  Tendo descoberto o algoritmo, podemos entender por que essa t√©cnica funciona t√£o bem com a renderiza√ß√£o HDR.  A renderiza√ß√£o no formato HDR permite que os componentes de cor ultrapassem o limite superior de 1,0, o que permite ajustar de forma mais flex√≠vel o limite de brilho fora do intervalo padr√£o [0., 1.], fornecendo a capacidade de ajustar com precis√£o quais partes da cena s√£o consideradas brilhantes.  Sem usar o HDR, voc√™ ter√° que se contentar com um limite de brilho no intervalo [0., 1.], o que √© bastante aceit√°vel, mas leva a um corte mais "n√≠tido" no brilho, o que geralmente torna a flor muito invasiva e chamativa (imagine-se em um campo de neve no alto das montanhas) . <br><br>  Ap√≥s a execu√ß√£o do shader, dois buffers de destino conter√£o uma imagem normal da cena, bem como uma imagem contendo apenas √°reas claras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br>  Agora, a imagem das √°reas claras deve ser processada com o desfoque.  Voc√™ pode fazer isso com um simples filtro retangular ( <i>caixa</i> ), usado na se√ß√£o de p√≥s-processamento da li√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer de quadros</a> .  Mas um resultado muito melhor √© obtido pela <i>filtragem de Gauss</i> . <br><br><h2>  Gaussian Blur </h2><br>  A li√ß√£o de p√≥s-processamento nos deu uma id√©ia de desfoque usando a m√©dia simples de cores dos fragmentos de imagem adjacentes.  Esse m√©todo de desfoque √© simples, mas a imagem resultante pode parecer mais atraente.  O desfoque gaussiano √© baseado na curva de distribui√ß√£o em forma de sino com o mesmo nome: valores altos da fun√ß√£o est√£o localizados mais perto do centro da curva e caem nos dois lados dela.  Matematicamente, uma curva gaussiana pode ser expressa com diferentes par√¢metros, mas a forma geral da curva permanece a seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br>  O desfoque com pesos com base nos valores da curva de Gauss parece muito melhor do que um filtro retangular: devido ao fato de a curva ter uma √°rea maior nas proximidades de seu centro, o que corresponde a pesos maiores para fragmentos pr√≥ximos ao centro do n√∫cleo do filtro.  Tomando, por exemplo, o n√∫cleo de 32x32, usaremos os fatores de pondera√ß√£o quanto menor, mais distante o fragmento do central.  √â essa caracter√≠stica de filtro que fornece um resultado de desfoque Gaussiano visualmente mais satisfat√≥rio. <br><br>  A implementa√ß√£o do filtro exigir√° uma matriz bidimensional de coeficientes de pondera√ß√£o, que poder√° ser preenchida com base na express√£o bidimensional que descreve a curva gaussiana.  No entanto, encontraremos imediatamente um problema de desempenho: mesmo um n√∫cleo de desfoque relativamente pequeno em um fragmento de 32x32 exigir√° 1024 amostras de textura para cada fragmento da imagem processada! <br><br>  Felizmente para n√≥s, a express√£o da curva gaussiana tem uma caracter√≠stica matem√°tica muito conveniente - separabilidade, que permitir√° criar duas express√µes unidimensionais a partir de uma express√£o bidimensional que descrevem os componentes horizontais e verticais.  Isso permitir√° que o desfoque, por sua vez, seja feito em duas abordagens: horizontalmente e verticalmente com conjuntos de pesos correspondentes a cada uma das dire√ß√µes.  A imagem resultante ser√° a mesma do processamento de um algoritmo bidimensional, mas exigir√° muito menos poder de processamento do processador de v√≠deo: em vez de 1024 amostras da textura, precisamos apenas de 32 + 32 = 64!  Essa √© a ess√™ncia da filtra√ß√£o gaussiana de duas passagens. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br>  Para n√≥s, tudo isso significa uma coisa: o desfoque de uma imagem ter√° que ser feito duas vezes, e aqui o uso de objetos de buffer de quadro ser√° √∫til.  Aplicamos a chamada t√©cnica de pingue-pongue: existem alguns objetos de buffer de quadro e o conte√∫do do buffer de cores de um framebuffer √© renderizado com algum processamento no buffer de cores do framebuffer atual; em seguida, o framebuffer de origem e o framebuffer-receiver s√£o trocados e esse processo √© repetido um determinado n√∫mero de vezes.  De fato, o buffer de quadro atual para exibir a imagem √© simplesmente alternado e, com ele, a textura atual a partir da qual a amostragem √© realizada para renderiza√ß√£o.  A abordagem permite que voc√™ desfoque a imagem original colocando-a no primeiro buffer de quadro, depois desfoque o conte√∫do do primeiro buffer de quadro, coloque-o no segundo e depois desfoque o segundo, colocando-o no primeiro e assim por diante. <br><br>  Antes de passar para o c√≥digo de ajuste do buffer de quadro, vamos dar uma olhada no c√≥digo do Gaussian Blur Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Como voc√™ pode ver, usamos uma amostra bastante pequena de coeficientes da curva gaussiana, que s√£o usados ‚Äã‚Äãcomo pesos para amostras horizontal ou verticalmente em rela√ß√£o ao fragmento atual.  O c√≥digo possui duas ramifica√ß√µes principais que dividem o algoritmo em passagem vertical e horizontal com base no valor do uniforme <i>horizontal</i> .  O deslocamento para cada amostra √© definido igual ao tamanho texel, que √© definido como o inverso do tamanho da textura (um valor do tipo <i>vec2</i> retornado pela fun√ß√£o <i>textureSize</i> ()). <br><br>  Crie dois buffers de quadro contendo um buffer de cor com base na textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  Depois de obter a textura HDR da cena e extrair a textura das √°reas brilhantes, preenchemos o buffer de cores de um dos pares de framebuffers preparados com a textura de brilho e iniciamos o processo de ping-pong dez vezes (cinco vezes na vertical, cinco na horizontal): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Em cada itera√ß√£o, selecionamos e ancoramos um dos buffers de quadro, com base em se essa itera√ß√£o ser√° borrada horizontal ou verticalmente, e o buffer de cores do outro buffer de moldura ser√° usado como textura de entrada para o sombreador de desfoque.  Na primeira itera√ß√£o, temos que usar explicitamente uma imagem contendo √°reas claras ( <i>brightnessTexture</i> ) - caso contr√°rio, os dois buffers de pingue-pongue permanecer√£o vazios.  Ap√≥s dez passagens, a imagem original assume a forma de cinco vezes emba√ßada por um filtro gaussiano completo.  A abordagem usada nos permite alterar facilmente o grau de desfoque: quanto mais itera√ß√µes de pingue-pongue, mais forte o desfoque. <br><br>  No nosso caso, o resultado do desfoque √© mais ou menos assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br>  Para concluir o efeito, resta apenas combinar a imagem tremida com a imagem HDR original da cena. <br><br><h2>  Mistura de textura </h2><br>  Tendo em m√£os a textura HDR da cena renderizada e a textura borrada das √°reas superexpostas, tudo o que voc√™ precisa para perceber o famoso efeito de brilho ou flor √© combinar essas duas imagens.  O sombreador final do fragmento (muito semelhante ao apresentado na li√ß√£o sobre o formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> ) faz exatamente isso - ele adiciona duas texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  O que procurar: a mixagem √© feita antes de aplicar o <i>mapeamento de tons</i> .  Isso traduzir√° corretamente o brilho adicional do efeito para a <i>faixa</i> LDR ( <i>baixa faixa din√¢mica</i> ), mantendo a distribui√ß√£o relativa do brilho na cena. <br><br>  O resultado do processamento - todas as √°reas brilhantes receberam um efeito de brilho percept√≠vel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br>  Os cubos que substituem as fontes de luz agora parecem muito mais brilhantes e transmitem melhor a impress√£o de uma fonte de luz.  Essa cena √© bastante primitiva, porque a implementa√ß√£o do efeito de entusiasmo especial n√£o causar√°, mas em cenas complexas com ilumina√ß√£o cuidadosa, um florescimento realizado qualitativamente pode ser um elemento visual crucial que acrescenta drama. <br><br>  O c√≥digo fonte do exemplo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Observo que a li√ß√£o usou um filtro bastante simples com apenas cinco amostras em cada dire√ß√£o.  Fazendo mais amostras em um raio maior ou executando v√°rias itera√ß√µes do filtro, voc√™ pode melhorar visualmente o efeito.  Al√©m disso, vale dizer que visualmente a qualidade de todo o efeito depende diretamente da qualidade do algoritmo de desfoque usado.  Ao melhorar o filtro, voc√™ pode obter melhorias significativas e todo o efeito.  Por exemplo, um resultado mais impressionante √© mostrado pela combina√ß√£o de v√°rios filtros com diferentes tamanhos de n√∫cleo ou diferentes curvas gaussianas.  A seguir, s√£o apresentados recursos adicionais da Kalogirou e da EpicGames, que abordam como melhorar a qualidade da flora√ß√£o, modificando o desfoque gaussiano. <br><br><h2>  Recursos Adicionais </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desfoque Gaussiano eficiente com amostragem linear</a> : uma descri√ß√£o qualitativa da opera√ß√£o do filtro Gaussiano, juntamente com o estudo de melhoria do desempenho do m√©todo atrav√©s do uso de filtragem bilinear de amostras de textura OpenGL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeito Bloom Post Process</a> : um artigo da EpicGames sobre como melhorar a qualidade de um efeito combinando v√°rias curvas de Gauss. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como fazer bom bloom para renderiza√ß√£o HDR</a> : um artigo de Kalogirou descrevendo a melhoria no bloom modificando o algoritmo de filtro Gauss original. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420375/">https://habr.com/ru/post/pt420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420363/index.html">Webinars da HPE de agosto a outubro: novos t√≥picos (+ SHD, pr√°tica de IA, armazenamento de petabytes pronto para uso)</a></li>
<li><a href="../pt420367/index.html">Apocalipse com ar condicionado: cen√°rio de apag√£o da rede inteligente</a></li>
<li><a href="../pt420369/index.html">Comuta√ß√£o extrema de borda estendida ou IEEE 802.1BR</a></li>
<li><a href="../pt420371/index.html">Sobre a quest√£o da constru√ß√£o de bicicletas no campo do armazenamento de correio el√©trico</a></li>
<li><a href="../pt420373/index.html">Quase OCR para obter a senha do VPNBook. PHP + Mikrotik</a></li>
<li><a href="../pt420377/index.html">Como iniciamos as videochamadas</a></li>
<li><a href="../pt420381/index.html">Por que basta considerar as redes neurais como uma caixa preta?</a></li>
<li><a href="../pt420383/index.html">"Yandex.Money n√£o lhe interessa inserir sua inscri√ß√£o."</a></li>
<li><a href="../pt420385/index.html">Teste de integra√ß√£o baseada em cont√™iner</a></li>
<li><a href="../pt420387/index.html">Tr√™s cubos de Rubik inteligentes: Xiaomi, Roobo e GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>