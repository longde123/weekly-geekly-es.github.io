<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 😯 🛌 Proyecto de software y evolución de OOP ✂️ 👞 ◽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dominando las recetas para el desarrollo efectivo de un proyecto de software, traté de encontrar por mí mismo las razones que hacen que sea útil utili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyecto de software y evolución de OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448026/"><p>  Dominando las recetas para el desarrollo efectivo de un proyecto de software, traté de encontrar por mí mismo las razones que hacen que sea útil utilizar los principios de desarrollo de la arquitectura SOLID (artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo no entender los principios de desarrollo de la arquitectura SOLID</a> ). </p><br><p>  Un análisis de estos principios permitió identificar varios patrones clave y elementos básicos que existen en el desarrollo.  Nos permitieron describir, comprender e implementar SOLID en el trabajo real con un proyecto de software. </p><br><p>  Se hizo interesante realizar un análisis de la aplicabilidad de estos conceptos para paradigmas de programación generalmente aceptados, por ejemplo, para OOP.  Bueno, si el resultado de este trabajo te será útil. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/291/b01/aa4/291b01aa4949513c726bbf5cb33fad80.jpg" alt="imagen"></p><a name="habracut"></a><br><p>  Hoy en día, existen muchos enfoques para el diseño y la posterior implementación de proyectos de software.  Los más demandados para trabajar con grandes proyectos de software son: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación estructural</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación funcional</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación orientada a objetos</a> . </p><br><p>  Para mí, se volvió interesante analizar las causas de estos enfoques de diseño.  Y en el proceso de análisis, el descubrimiento inesperado fue el hecho de que todos están implícitamente basados ​​en la siguiente premisa: </p><br><pre><code class="plaintext hljs">          ,      .</code> </pre> <br><h2 id="razvitie-programmnogo-proekta">  Desarrollo de proyectos de software </h2><br><p>  ¿Qué es un proyecto sin necesidad de desarrollo?  Tales proyectos rara vez se encuentran y se caracterizan principalmente por un pago rápido a destajo sin ninguna obligación posterior por parte del programador, por ejemplo: </p><br><ul><li>  un pequeño proyecto que se puede escribir con un enfoque; </li><li>  Un proyecto sin código estructuralmente complejo, cargado con una gran cantidad de relaciones; </li><li>  producto de software sin la necesidad de su soporte y soporte de usuario. </li></ul><br><p>  En tales situaciones, se desperdician los esfuerzos del programador para mantener, por ejemplo, un enfoque orientado a objetos.  A menudo sucede que me encuentro en una lección sin sentido durante el desarrollo de una utilidad de consola única, cuando de repente me doy cuenta de que escribir el texto de 4to grado en este proyecto me retrasó por 15 minutos y no me acercó al resultado.  Lo más triste es que todas las clases que apenas se escribieron en tales proyectos se olvidan y no se reutilizan, es decir, no facilitan nuestro trabajo en el futuro. </p><br><p>  En todas las demás situaciones, el programador, minimizando su trabajo, debe desarrollar un proyecto estructuralmente complejo, es decir: </p><br><ul><li>  Corrija los errores analizando el código y encontrando los lugares donde se generan estos errores. </li><li>  Introducir nuevas funcionalidades, manteniendo la funcionalidad de todas las capacidades disponibles anteriormente.  Al hacerlo, utilice el código existente (escrito y probado) en la implementación de estas nuevas tareas. </li><li>  Brindar asistencia en el uso de un producto de software. </li><li>  Realice una descripción y coordinación de la funcionalidad de todas las versiones del proyecto. </li><li>  Mantenga todos los formatos de datos utilizados por el proyecto (incluso obsoletos) operativos. </li><li>  Y realice muchas otras tareas que aparecen en la confrontación con competidores causada por cambios en los marcos o el fin del soporte para SO obsoletos ... </li></ul><br><p>  Si busca analogías para el desarrollo de un proyecto de software, puede recordar la evolución de una especie biológica. </p><br><pre> <code class="plaintext hljs">     "".     -       .       -  .</code> </pre> <br><p>  El trabajo del programador no es fácil, pero el programador tiene un "ayudante".  Este ayudante está oculto en algún lugar profundo de la estructura de nuestro mundo, en el que hay dos características: </p><br><ul><li>  la capacidad de escribir un algoritmo útil y usarlo para muchas tareas similares, </li><li>  La presencia de una gran cantidad de tareas similares en su solución. </li></ul><br><p>  Este algoritmo, útil en muchos campos, se denominará algoritmo <em>universal</em> por brevedad.  Su implementación para un campo de aplicación específico puede llamarse especialización, ya que el proceso de refinación del algoritmo para su uso en un campo de aplicación estrecho es similar a la especialización evolutiva de las células en un organismo vivo. </p><br><p>  Obviamente, para crear un algoritmo, es necesario identificar características que aseguren la aplicabilidad del algoritmo.  Estos signos deben buscarse en los datos de entrada y en la descripción de la situación inicial (contexto).  Para crear un algoritmo <em>universal</em> , es necesario en cada área temática, que tiene sus propios conjuntos de signos de datos y situaciones, identificar signos de aplicabilidad que sean idénticos para todas las áreas.  El algoritmo <em>universal</em> ignora todos los demás signos que no proporcionan aplicabilidad.  Formalizando el algoritmo <em>universal</em> , hemos llegado a la necesidad de utilizar la <em>abstracción</em> , uno de los principios más importantes de la POO.  Además, OOP se caracteriza por un énfasis solo en la abstracción de datos. </p><br><p>  Aquí intentaré escribir ejemplos de cómo usar la <em>abstracción</em> de diferentes áreas. </p><br><table><thead><tr><th>  Abstracción </th><th>  Algoritmos </th><th>  Campo de aplicación </th></tr></thead><tbody><tr><td>  Números naturales </td><td>  Algoritmos de cálculo cuantitativo </td><td>  Tareas de contabilidad de valores económicos </td></tr><tr><td>  Masa característica del cuerpo material </td><td>  Algoritmos para comparar la cantidad de sustancia </td><td>  Tareas de comparar el valor de un producto no responsable </td></tr><tr><td>  Interfaz con operaciones para una colección de elementos: rastreo completo, comparación e intercambio de posiciones </td><td>  Algoritmos de clasificación de colecciones </td><td>  Programacion </td></tr><tr><td>  La interfaz de las mismas operaciones para el "nodo final" y el "nodo de rama" en el árbol </td><td>  Algoritmos basados ​​en el patrón de diseño de diseño </td><td>  Desarrollo de un proyecto de software complejo. </td></tr><tr><td>  Concepto clave "Empleado" </td><td>  Redacción en la sección "Contrato de trabajo" </td><td>  Código laboral </td></tr></tbody></table><br><h2 id="stroitelnyy-blok-programmnogo-proekta">  Bloque de construcción de un proyecto de software </h2><br><p>  Usando varias técnicas de abstracción, el programador implementa el algoritmo en forma de una sección de código, que es un elemento separado y completo de su trabajo.  Este elemento, dependiendo del lenguaje de programación utilizado, puede ser una función, un objeto y una secuencia de instrucciones.  Para una mayor discusión, llamaremos a este fragmento de código la palabra " <strong>componente</strong> ". </p><br><p>  <strong>Componente</strong> : un fragmento de código (procedimiento, clase, componente de implementación, etc.): </p><br><ul><li>  que implementa un algoritmo completo que funciona en ciertas situaciones iniciales y con ciertos datos de entrada, </li><li>  que se puede usar varias veces en un proyecto (incluso mejor muchas veces en diferentes proyectos), </li><li>  todas las instrucciones están ubicadas cerca y vistas sin la necesidad de operaciones de búsqueda adicionales en el entorno de desarrollo, </li><li>  cambios en los que el programador se desempeña de manera relativamente independiente con respecto al resto del código. </li></ul><br><h2 id="zakonomernosti-v-razvitii-programmnogo-proekta">  Patrones en el desarrollo de un proyecto de software. </h2><br><p>  Usando el término <strong>componente</strong> , se hace posible formular un conjunto de leyes simples que existen en el desarrollo de un proyecto de software.  Presentaré estos patrones en la forma de las siguientes declaraciones, divididas en 3 categorías. </p><br><ol><li>  Declaraciones que describen las propiedades de un <strong>componente</strong> . <br>  1.1.  Un <strong>componente</strong> escrito correctamente <strong>se</strong> usa necesariamente y más a menudo varias veces. <br>  1.2.  En todos los lugares donde <strong>se</strong> usa el <strong>componente</strong> , se espera un comportamiento constante del mismo, lo que conduce a un resultado repetible. <br>  1.3.  Cuando se usa el <strong>componente</strong> en varios lugares, el resultado debe satisfacer cada lugar de uso. <br>  1.4.  El comportamiento incrustado en el <strong>componente</strong> crea restricciones en los lugares de uso de este <strong>componente</strong> . <br>  1.5.  En cada lugar de uso del <strong>componente</strong> , todas sus restricciones pueden estar involucradas. <br>  1.6.  Cualquier cambio en un <strong>componente</strong> cambia sus limitaciones y requiere la verificación de todos los lugares de su uso, lo que hace que un programador pierda tiempo. <br>  1.7.  <strong>Es</strong> aconsejable escribir el <strong>componente</strong> en forma de código en una instancia, es decir, es necesario eliminar la duplicación del mismo código.  Esto reducirá el número de ediciones al hacer un cambio en un <strong>componente</strong> . </li><li>  Declaraciones que describen patrones en la implementación de una nueva tarea por parte del programador. <br>  2.1 Es aconsejable elegir una opción para implementar una nueva tarea mientras se minimiza el tiempo dedicado por el programador. <br>  2.2.  Para implementar una nueva tarea, un programador puede agregar nuevos <strong>componentes</strong> o cambiar el comportamiento de los <strong>componentes</strong> antiguos. <br>  2.3.  Agregar un <strong>componente</strong> básicamente requiere verificar solo en el lugar de nuevo uso, y genera un tiempo mínimo para el programador. <br>  2.4.  Según la declaración [1.6], un cambio en el comportamiento de un <strong>componente</strong> causado por una nueva tarea requiere verificación en el lugar de uso nuevo y en todos los lugares de uso anterior, lo que crea costos adicionales de tiempo del programador en comparación con la situación en la declaración [2.3].  En el caso de un <strong>componente</strong> publicado <strong>,</strong> esto requiere el trabajo de todos los programadores que usan el <strong>componente</strong> modificado. </li><li>  Declaraciones que describen patrones en la interacción de algoritmos <em>universales</em> y sus especializaciones: <br>  3.1.  Existe la oportunidad de escribir un <strong>componente</strong> <em>base</em> (el nombre se introduce por analogía con la clase base y por razones de brevedad usaremos la palabra " <em>base</em> ").  <em>La base</em> cumple solo las características más importantes de algunos algoritmos <em>universales</em> . <br>  3.2.  Es posible escribir un <strong>componente:</strong> especialización (en adelante, por brevedad, usaremos la palabra " <em>especialización</em> ").  <em>La especialización</em> complementa el algoritmo <em>universal</em> de la <em>base</em> , haciéndolo aplicable en un área particular de uso. <br>  3.3.  <em>La base</em> , como se desprende de las declaraciones [3.1], [3.2], tiene menos complejidad y menos restricciones de aplicación que la <em>especialización</em> . <br>  3.4.  Según la declaración [1.7], es aconsejable desarrollar una <em>especialización</em> sin duplicación del código del algoritmo <em>universal</em> de la <em>base de datos</em> . <br>  3.5.  Los lugares de uso de la <em>base</em> de <em>datos</em> no requieren verificación después de realizar cambios en la <em>especialización</em> formada correctamente. </li></ol><br><h2 id="ponyatiya-obektno-orientirovannogo-programmirovaniya">  Conceptos de programación orientada a objetos </h2><br><p>  Intentaré, utilizando las declaraciones anteriores, analizar los conceptos básicos de la programación orientada a objetos.  Este análisis omite el concepto de <em>abstracción</em> , ya que ya se ha descrito anteriormente en la formalización del método de construcción de un algoritmo <em>universal</em> . </p><br><h3 id="klass-obekt">  Clase, objeto </h3><br><p>  Estos conceptos de OOP refuerzan la viabilidad de usar un tipo especial de <strong>componente</strong> descrito por una combinación de algunos datos internos y métodos para trabajar con estos datos.  Todas las declaraciones del grupo [1] y [2] se traducen a OOP, para las cuales el término <strong>componente</strong> se reemplaza por el concepto de <em>clase</em> . </p><br><p>  Al mismo tiempo, a primera vista, las relaciones de una <em>clase</em> y un <em>objeto se</em> agotan por el grupo de declaraciones [3], en el que la <em>base</em> se reemplaza por el concepto de <em>clase</em> , y la <em>implementación</em> por el concepto de <em>un objeto</em> .  Además, la <em>implementación</em> es dinámica, es decir, modificable durante la ejecución del programa. </p><br><h3 id="inkapsulyaciya">  Encapsulación </h3><br><p>  El concepto de " <em>encapsulación</em> " puede considerarse desde dos "lados". </p><br><p>  El primer lado del concepto de " <em>encapsulación</em> " es el aislamiento del <strong>componente</strong> de otras partes del código.  Esta propiedad permite al programador realizar operaciones en áreas del código que se encuentran "cerca" para realizar cambios en el <strong>componente</strong> .  Es decir, para minimizar el tiempo dedicado por el programador al excluir del trabajo la búsqueda y el análisis de elementos interactivos dispares del programa.  Este lado está definido por las propiedades del <strong>componente que</strong> sigue a su definición. </p><br><p>  El segundo lado del concepto de " <em>encapsulación</em> " es el ocultamiento de la implementación interna del <strong>componente</strong> .  Esta ocultación es posible utilizando los conceptos de <em>base</em> e <em>implementación</em> descritos en el grupo de declaraciones [3].  Para hacer esto, los métodos de <em>clase</em> pública <em>se</em> identifican con la <em>base</em> , y los métodos de clase privados y protegidos <em>se</em> identifican con la <em>implementación</em> .  En los lugares de uso, se utilizan las restricciones formadas por la <em>base</em> y, por lo tanto, es posible realizar cambios en la <em>implementación</em> que no están relacionados con las restricciones <em>básicas</em> .  Y estos cambios de <em>implementación</em> no necesitan ser verificados en los lugares donde <em>se</em> usa la <em>base de datos</em> [3.5], lo que minimiza el trabajo del programador. </p><br><p>  Es de destacar que el concepto de " <em>encapsulación</em> " tiene una analogía en biología.  Este primer proceso es similar a las funciones biológicas de la " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">membrana celular</a> ". </p><br><h3 id="nasledovanie">  Herencia </h3><br><p>  El concepto de " <em>herencia</em> " continúa reforzando la importancia de utilizar una combinación de <em>base</em> + <em>implementación</em> .  Para esto, en el grupo de declaraciones [3] es necesario identificar los métodos de la clase padre con la <em>base</em> , e identificar los métodos de la clase sucesora con la <em>implementación</em> . </p><br><p>  En su implementación, el concepto de “ <em>herencia</em> ” permite el uso de la declaración [2.3], es decir, usar la adición de código en lugar de cambiarlo y duplicarlo.  En este caso, es necesario excluir la duplicación del algoritmo <em>básico</em> .  Sin embargo, un enfoque que utiliza la <em>herencia</em> para especializar un algoritmo <em>universal</em> tiene una desventaja significativa.  Esta desventaja es la presencia de dos <strong>componentes</strong> fuertemente conectados, que son difíciles de cambiar de forma independiente.  Estas relaciones de dependencia son generadas por la relación padre-hijo. </p><br><p>  Hay muchas formas alternativas de usar el paquete de <em>implementación</em> <em>base</em> +.  Daré más ejemplos de tales métodos. </p><br><table><thead><tr><th>  <em>Base</em> </th><th>  <em>Implementación</em> </th><th>  Campo de aplicación </th></tr></thead><tbody><tr><td>  Métodos de clase pública </td><td>  Métodos de clase privada </td><td>  <em>Encapsulación</em> </td></tr><tr><td>  Métodos protegidos de la clase padre. </td><td>  Métodos de clase de herencia </td><td>  <em>Herencia</em> </td></tr><tr><td>  Interfaz de biblioteca dinámica </td><td>  Funcionalidad de biblioteca dinámica </td><td>  <strong>Componente</strong> = biblioteca dinámica </td></tr><tr><td>  Métodos y clases de plantilla (generalizada) (plantilla, genérica) </td><td>  Crear instancias de una plantilla con argumentos especificados </td><td>  Programación general </td></tr><tr><td>  Métodos genéricos que aceptan delegados. </td><td>  Especialización de métodos que indican procedimientos de procesamiento específicos. </td><td>  Procedimientos para ordenar o formar un árbol, indicando el método para evaluar el orden de los elementos. </td></tr><tr><td>  Clases que permiten la interacción con la plantilla de visitante </td><td>  Formación de "Visitante" con la funcionalidad requerida </td><td>  Patrón de diseño de visitante </td></tr><tr><td>  Panel de control de NPP </td><td>  El conjunto de automatización y equipamiento de centrales nucleares. </td><td>  Ocultación de la complejidad del sistema por parte del operador de la central nuclear. </td></tr></tbody></table><br><p>  Al mismo tiempo, noto que para el concepto de " <em>herencia</em> " de la OLP, también se puede encontrar una analogía en los procesos de evolución biológica.  En biología, el término " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>herencia</em></a> " se utiliza para esto. </p><br><h3 id="polimorfizm">  Polimorfismo </h3><br><p>  En mi opinión, el concepto de " <em>polimorfismo</em> " es el segundo lado cuando se observa el procedimiento para crear un algoritmo <em>universal</em> .  El primer lado ( <em>abstracción</em> ) es una vista desde el punto de vista de cómo crear un algoritmo <em>universal</em> .  Al mismo tiempo, cuando observamos el algoritmo <em>universal</em> desde el punto de vista del usuario, obtenemos un registro del concepto de <em>polimorfismo</em> .  Es decir, el <em>polimorfismo</em> es una capacidad útil de una función ( <strong>componente</strong> ) para procesar datos de varios tipos.  Agregar este concepto a OOP fortalece la utilidad del uso de un algoritmo <em>universal</em> en el desarrollo de un proyecto de software. </p><br><p>  Las implementaciones de polimorfismo en diferentes lenguajes de programación son muy diferentes.  En el artículo de Wikipedia para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polimorfismo</a> , dependiendo de su implementación, hay 4 subtipos: paramétrico, inclusión (o subtipos), sobrecarga, conversión de tipos.  Estas implementaciones tienen diferencias significativas, pero todas están unidas por un objetivo: escribir un algoritmo <em>universal</em> que no necesitará duplicarse para su <em>especialización</em> específica. </p><br><p>  Y esta vez, casi sin sorpresa, encontró una analogía para el concepto de " <em>polimorfismo</em> " en biología.  El nombre de este término biológico coincide totalmente con el concepto de OOP.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Polimorfismo</em></a> ": la capacidad de un organismo para existir en estados con diferentes estructuras internas o en diferentes formas externas. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Por lo tanto, casi todos los conceptos básicos de OOP se pueden representar como un conjunto de declaraciones simples formadas sobre la base de las leyes de desarrollo de un proyecto de software.  Además, para OOP, el término <strong>componente se</strong> identifica con el concepto de una <em>clase</em> .  Si seleccionamos un significado diferente para el término <strong>componente</strong> , por ejemplo, una <em>función</em> , entonces es posible formular los conceptos básicos de la <em>programación</em> <em>funcional</em> . </p><br><p>  En el proceso de redacción del artículo, se encontraron analogías biológicas para los conceptos utilizados en la programación.  Estas analogías aparecen debido a la similitud de los métodos de desarrollo de un producto de software y algunos procesos de evolución biológica. </p><br><p>  En mi humilde opinión, es aconsejable considerar estas dos áreas científicas juntas.  En este caso, puede ser posible llevar a cabo la transferencia de leyes de una industria a otra, y así garantizar el desarrollo de la tecnología de la información y las descripciones formales de los procesos biológicos. </p><br><p>  Gracias por su atencion </p><br><h2 id="otzyvy">  Comentarios </h2><br><p>  Estaría muy agradecido por los comentarios, sugerencias y sugerencias, ya que me ayudan a ajustar la dirección del desarrollo del trabajo en esta área. </p><br><h2 id="ssylki">  Referencias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teoría general de algoritmos wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primer articulo de la serie</a> </li></ul><br><p>  Editado por Borisova M.V. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448026/">https://habr.com/ru/post/448026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448010/index.html">3 semanas con el Galaxy S10: pros y contras</a></li>
<li><a href="../448016/index.html">Análisis clínico de orina en el hogar en tiras reactivas: pros y contras</a></li>
<li><a href="../448018/index.html">Eventos digitales en Moscú del 15 al 21 de abril.</a></li>
<li><a href="../448022/index.html">Compilador angular de 200 líneas</a></li>
<li><a href="../448024/index.html">Los reguladores europeos se oponen a las pancartas de cookies</a></li>
<li><a href="../448030/index.html">Visualización y optimización de la salida del terminal en la web.</a></li>
<li><a href="../448032/index.html">Más robots: Walmart presenta miles de máquinas para operar en sus tiendas</a></li>
<li><a href="../448034/index.html">Búsqueda de tareas en JIRA (lenguaje simple). Parte 1: Búsqueda rápida y básica</a></li>
<li><a href="../448036/index.html">Importar a J. Connect desde el archivo de lista de usuarios a través de API</a></li>
<li><a href="../448038/index.html">Nuevas características para autores de extensiones en Visual Studio 2019 v.16.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>