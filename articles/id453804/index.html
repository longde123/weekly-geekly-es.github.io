<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘š ğŸ“» ğŸ’´ Buku â€œDaya Saing dan Konkurensi pada Platform .NET. Pola Desain yang Efektif â€ ğŸˆ ğŸšª ğŸ‘©ğŸ¼â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Buku Riccardo Terrell memberikan panduan tentang cara membuat program yang kompetitif dan dapat diukur dalam .NET, menyoroti manfaa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku â€œDaya Saing dan Konkurensi pada Platform .NET. Pola Desain yang Efektif â€</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453804/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/xh/fk/az/xhfkazyaueuwhx3c7cjwt5ohyea.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Buku Riccardo Terrell memberikan panduan tentang cara membuat program yang kompetitif dan dapat diukur dalam .NET, menyoroti manfaat dari paradigma fungsional dan menyediakan alat dan prinsip yang tepat untuk menjaga persaingan secara kompetitif dan mudah.  Akibatnya, dengan dibekali keterampilan baru, Anda akan menerima pengetahuan yang diperlukan untuk menjadi ahli dalam memberikan solusi kinerja tinggi yang sukses. <br><br>  Jika Anda menulis kode multithreaded dalam .NET, maka buku ini dapat membantu Anda.  Jika Anda tertarik menggunakan paradigma fungsional untuk menyederhanakan pemrograman kompetitif dan memaksimalkan kinerja aplikasi, buku ini akan menjadi panduan penting bagi Anda.  Ini akan menguntungkan setiap pengembang .NET yang ingin menulis aplikasi kompetitif, reaktif dan asinkron yang mengukur dan secara otomatis beradaptasi dengan sumber daya perangkat keras yang tersedia di mana pun program tersebut bekerja. <br><a name="habracut"></a><br><h3>  Struktur publikasi: peta jalan </h3><br>  Empat belas bab dari buku ini dibagi menjadi tiga bagian.  Bagian I menyajikan konsep fungsional pemrograman kompetitif dan menjelaskan keterampilan yang diperlukan untuk memahami aspek fungsional penulisan program multithreaded. <br><br><ul><li>  Bab 1 menjelaskan konsep dasar dan tujuan pemrograman kompetitif, serta alasan untuk menggunakan pemrograman fungsional untuk menulis aplikasi multi-utas. </li><li>  Bab 2 mengeksplorasi berbagai teknologi pemrograman fungsional untuk meningkatkan kinerja aplikasi multi-utas.  Tujuan bab ini adalah untuk memberi pembaca konsep-konsep yang digunakan dalam sisa buku ini dan untuk memperkenalkan ide-ide kuat yang muncul dari paradigma fungsional. </li><li>  Bab 3 memberikan tinjauan umum tentang konsep fungsional kekekalan.  Ini menjelaskan bagaimana immutabilitas digunakan untuk menulis program kompetitif yang dapat diprediksi dan mengoreksi dan untuk mengimplementasikan struktur data fungsional yang sifatnya aman. </li></ul><br>  Pada bagian II, berbagai model pemrograman kompetitif dalam paradigma fungsional diperiksa secara mendalam.  Kami akan mengeksplorasi topik seperti Task Parallel Library (TPL), dan menerapkan pola paralel seperti Fork / Gabung, bagilah dan taklukkan, dan MapReduce.  Bagian ini juga membahas tata letak deklaratif, abstraksi tingkat tinggi dalam operasi asinkron, pemrograman agen, dan semantik transfer pesan. <br><br><ul><li>  Bab 4 menguraikan dasar-dasar pemrosesan paralel sejumlah besar data, termasuk template seperti Fork / Gabung. </li><li>  Bab 5 memperkenalkan metode yang lebih canggih untuk pemrosesan paralel sejumlah besar informasi, seperti agregasi paralel, reduksi data, dan implementasi templat MapReduce paralel. </li><li>  Bab 6 memberikan informasi terperinci tentang metode fungsional untuk memproses stream peristiwa (data) secara real time menggunakan operator fungsional tingkat tinggi di .NET Reactive Extensions untuk membentuk kombinator acara asinkron.  Metode yang dipelajari kemudian akan digunakan untuk mengimplementasikan template reaktif penerbit-pelanggan yang dirancang secara kompetitif. </li><li> Bab 7 memberikan penjelasan tentang model pemrograman berbasis tugas sebagaimana diterapkan pada pemrograman fungsional untuk menerapkan operasi kompetitif menggunakan template Monadic.  Kemudian metode ini digunakan untuk membangun jalur pipa kompetitif berdasarkan paradigma pemrograman fungsional. </li><li>  Bab 8 dikhususkan untuk implementasi komputasi paralel tak terbatas menggunakan model pemrograman asinkron C #.  Bab ini juga membahas metode penanganan kesalahan dan metode untuk membangun operasi asinkron. </li><li>  Bab 9 menjelaskan alur kerja asinkron dalam F #.  Ini menunjukkan bagaimana penilaian yang ditangguhkan dan eksplisit dalam model ini memungkinkan untuk semantik komposisi yang lebih tinggi.  Kemudian kita akan belajar bagaimana menerapkan ekspresi komputasi khusus untuk meningkatkan level abstraksi ke pemrograman deklaratif. </li><li>  Bab 10 menunjukkan bagaimana, berdasarkan pengetahuan yang diperoleh dalam bab-bab sebelumnya, kombinator dan template, seperti Functor, Monad, dan Applicative, dapat diimplementasikan untuk menyusun dan menjalankan beberapa operasi asinkron dan menangani kesalahan tanpa efek samping. </li><li>  Bab 11 menganalisis pemrograman reaktif menggunakan model pesan perangkat lunak.  Ini mengungkapkan konsep isolasi alami sebagai teknologi yang melengkapi kekekalan dan memungkinkan penciptaan program kompetitif.  Bab ini berfokus pada kelas MailboxProcessor yang digunakan dalam F # untuk mendistribusikan pekerjaan paralel menggunakan pemrograman agen dan pendekatan bebas sumber daya. </li><li>  Bab 12 menjelaskan pemrograman agen menggunakan perpustakaan TPL Dataflow dari .NET dengan contoh dalam C #.  Ini menunjukkan bagaimana menerapkan agen stateless dan stateful di C #, serta bagaimana melakukan beberapa perhitungan secara paralel yang bertukar data satu sama lain, menggunakan (mengirim) pesan dalam gaya pipa. </li></ul><br>  Bagian III menunjukkan bagaimana mempraktikkan semua metode fungsional pemrograman kompetitif yang dipelajari dalam bab-bab sebelumnya. <br><br><ul><li>  Bab 13 menyajikan serangkaian resep yang berguna untuk memecahkan masalah persaingan yang kompleks, yang diambil dari praktik nyata.  Resep-resep ini menggunakan semua pola fungsional yang dijelaskan dalam buku ini. </li><li>  Bab 14 menjelaskan aplikasi lengkap yang dikembangkan dan diimplementasikan menggunakan templat kompetitif fungsional dan metode yang dipelajari dalam buku ini.  Anda akan membuat aplikasi server yang sangat skalabel dan responsif dan program klien yang responsif.  Buku ini berisi dua versi: satu untuk iOS (iPad), dibuat menggunakan Xamarin Visual Studio, dan yang kedua dibuat menggunakan Windows Presentation Foundation (WPF).  Untuk memastikan skalabilitas maksimum dalam aplikasi server, kombinasi berbagai model pemrograman, seperti asinkron, agen, dan reaktif, digunakan. </li></ul><br>  Buku itu juga memuat tiga aplikasi. <br><br><ul><li>  Lampiran A menjelaskan secara singkat konsep dasar pemrograman fungsional, serta menyajikan teori dasar metode fungsional yang digunakan dalam buku ini. </li><li>  Lampiran B mengungkapkan konsep dasar bahasa F #.  Ini adalah ulasan dasar dari F #, yang akan memungkinkan Anda untuk berkenalan dengan bahasa ini dan merasa nyaman saat membaca buku. </li><li>  Lampiran B menunjukkan beberapa metode yang menyederhanakan interaksi antara alur kerja asinkron di F # dan tugas .NET di C #. </li></ul><br><h3>  Kutipan.  11.6.  F # MailboxProcessor: 10.000 agen untuk Game of Life </h3><br>  Dibandingkan dengan utas, MailboxProcessor dalam kombinasi dengan alur kerja asinkron adalah unit komputasi sederhana (primitif).  Agen dapat muncul dan dihancurkan dengan biaya minimal.  Anda bisa mendistribusikan pekerjaan di antara beberapa objek MailboxProcessor dengan cara yang sama seperti Anda bisa menggunakan utas, tanpa overhead tambahan yang terkait dengan membuat utas baru.  Berkat ini, sangat mungkin untuk membuat aplikasi yang terdiri dari ratusan ribu agen yang bekerja secara paralel dengan beban minimum pada sumber daya komputer. <br><br>  Di bagian ini, kita akan menggunakan beberapa contoh MailboxProcessor untuk mengimplementasikan game Game of Life (game "Life") ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki-eng</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki-eng</a> ).  Menurut Wikipedia, Game of Life, dengan kata sederhana, adalah otomat seluler.  Ini adalah gim tanpa pemain - dengan kata lain, saat gim dimulai dengan konfigurasi awal acak, gim ini berjalan tanpa input lainnya.  Gim ini terdiri dari sekumpulan sel yang membentuk kisi;  di setiap sel beberapa aturan matematika terpenuhi.  Sel bisa hidup, mati, dan berlipat ganda.  Setiap sel berinteraksi dengan delapan tetangga (sel tetangga).  Untuk memindahkan sel sesuai dengan aturan ini, perlu untuk terus-menerus menghitung keadaan grid yang baru. <br><br>  Game of Life memiliki aturan berikut: <br><br><ul><li>  jika sel hanya memiliki satu tetangga atau tidak memiliki tetangga, maka ia mati "karena kesepian"; </li><li>  jika empat atau lebih tetangga sel mati, maka ia mati "karena kelebihan populasi"; </li><li>  jika sel memiliki dua atau tiga tetangga, maka ia tetap hidup; </li><li>  jika sel memiliki tiga tetangga, maka itu berkembang biak. </li></ul><br>  Tergantung pada kondisi awal, sel-sel membentuk struktur karakteristik sepanjang permainan.  Melalui penerapan berulang dari aturan, generasi sel berikutnya dibuat sampai sel mencapai kondisi stabil (Gbr. 11.12). <br><br>  Listing 11.9 memperlihatkan implementasi sel Game of Life AgentCell, berdasarkan tipe F # dari MailboxProcessor.  Setiap sel agen berinteraksi dengan sel tetangga melalui pesan asinkron, sehingga menciptakan Game of Life yang sepenuhnya paralel.  Untuk singkatnya, saya menghilangkan beberapa bagian dari kode, karena mereka tidak terkait dengan topik utama contoh.  Anda akan menemukan implementasi penuh dalam kode sumber untuk buku ini, diposting di situs web penerbit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/qb/jp/siqbjpp_zc4oqi7dgpk032_8xe8.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/j9/u2/2dj9u2y7qplsftitwupamkmaji0.png" alt="gambar"></div><br>  AgentCell menjelaskan sel di kisi Game of Life.  Konsep dasarnya adalah bahwa setiap agen bertukar informasi dengan sel-sel tetangga tentang keadaan saat ini melalui pesan asinkron.  Templat ini membuat rantai komunikasi paralel yang saling berhubungan yang melibatkan semua sel mengirim negara mereka yang diperbarui ke MailboxProcessor updateAgent.  Setelah menerima data ini, updateAgent memperbarui grafik di antarmuka pengguna (Listing 11.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/qy/j2/1aqyj2_ar1ua7a4mjylo8gxdqgg.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wr/jx/l4wrjxuth4-3quliytnseqegjw8.png" alt="gambar"></div><br>  updateAgent, seperti namanya, memperbarui keadaan setiap piksel sesuai dengan nilai sel yang diterima dalam pesan Pembaruan.  Agen mempertahankan status piksel dan menggunakannya untuk membuat gambar baru saat semua sel meneruskan status baru mereka.  UpdateAgent kemudian memperbarui GUI WPF menggunakan gambar baru ini yang cocok dengan kisi Game of Life saat ini: <br><br><pre><code class="plaintext hljs">do! Async.SwitchToContext ctx image.Source &lt;- createImage pixels do! Async.SwitchToThreadPool()</code> </pre> <br>  Penting untuk dicatat bahwa updateAgent menggunakan konteks sinkronisasi saat ini untuk memperbarui pengontrol WPF dengan benar.  Utas saat ini dialihkan ke utas antarmuka pengguna menggunakan fungsi Async.SwitchToContext (dijelaskan pada Bab 9). <br><br>  Bagian terakhir dari kode untuk mengeksekusi Game of Life menghasilkan grid yang berfungsi sebagai taman bermain untuk sel, dan kemudian timer memberitahukan sel tentang perlunya melakukan pembaruan (Listing 11.11).  Dalam contoh ini, kotak adalah kuadrat dari 100 Ã— 100 sel, total 10.000 sel (objek MailboxProcessor), yang dihitung secara paralel dengan penghitung waktu setiap 50 ms, seperti yang ditunjukkan pada Gambar.  11.13.  Sepuluh ribu objek MailboxProcessor berinteraksi dan memperbarui antarmuka pengguna 20 kali per detik (kode yang harus Anda perhatikan ditunjukkan dengan huruf tebal). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/px/jw/uepxjwb4re6grfx1wqbmp4rx6pq.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/cg/tx/eqcgtxipd3wr4kipmnbpqj0-rjm.png" alt="gambar"></div><br>  Pemberitahuan untuk semua sel (agen) dikirim secara paralel menggunakan PLINQ.  Sel adalah urutan F # yang diperlakukan sebagai .NET IEnumerable, membuat LINQ / PLINQ mudah diintegrasikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/9u/wl/rc9uwlhsymr64zmqrffpte7gqcc.png" alt="gambar"></div><br>  Ketika kode dieksekusi, program menghasilkan 10.000 F # objek dari jenis MailboxProcessor dalam waktu kurang dari 1 ms, sementara agen menempati kurang dari 25 MB memori.  Mengesankan! <br><br><h3>  Ringkasan </h3><br><ul><li>  Model pemrograman berbasis agen secara alami memberikan ketidakmampuan dan isolasi saat menulis sistem kompetitif, membuatnya lebih mudah untuk membahas sistem yang kompleks, karena agen dienkapsulasi dalam objek aktif. </li><li>  Manifes reaktif mendefinisikan properti untuk menerapkan sistem reaktif yang fleksibel, longgar, dan dapat diskalakan. </li><li>  Isolasi alami penting untuk menulis kode kompetitif tanpa memblokir.  Dalam program multi-utas, isolasi memecahkan masalah status bersama dengan memberikan setiap utas potongan data yang disalin untuk melakukan perhitungan lokal.  Saat menggunakan insulasi, tidak ada kondisi balapan. </li><li>  Menjadi asinkron, agen sederhana karena mereka tidak memblokir utas sambil menunggu pesan.  Alhasil, Anda bisa menggunakan ratusan ribu agen dalam satu aplikasi tanpa banyak berdampak pada jumlah memori. </li><li>  Objek MailboxProcessor F # menyediakan komunikasi dua arah: agen dapat menggunakan saluran asinkron untuk mengembalikan (merespons) ke objek panggilan hasil perhitungan. </li><li>  Model pemrograman agen dalam F # melalui MailboxProcessor adalah alat yang sangat baik untuk memecahkan kemacetan dalam aplikasi, seperti beberapa akses database bersamaan.  Bahkan, dengan bantuan agen, Anda dapat secara signifikan mempercepat pekerjaan aplikasi, sambil mempertahankan daya tanggap server. </li><li>  Bahasa pemrograman .NET lainnya memungkinkan Anda untuk menggunakan MailboxProcessor tipe F, menyediakan metode menggunakan model pemrograman TPL yang nyaman berdasarkan tugas. </li></ul><br>  Â»Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 20% untuk penjaja - <b>Konkurensi dalam .NET</b> <br><br>  Setelah pembayaran versi kertas buku, versi elektronik buku dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453804/">https://habr.com/ru/post/id453804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453788/index.html">Jaringan saraf lebih suka tekstur dan cara menghadapinya.</a></li>
<li><a href="../id453790/index.html">"Klien sudah pergi - apakah selamanya?" Bagaimana cara menghitung churn pelanggan dalam SaaS dan apa yang salah dengan metrik dasar</a></li>
<li><a href="../id453792/index.html">Sistem pemberi rekomendasi: ide, pendekatan, tugas</a></li>
<li><a href="../id453796/index.html">Apakah orang membutuhkan matematika?</a></li>
<li><a href="../id453800/index.html">Cara mengatasi "Minesweeper" (dan membuatnya lebih baik)</a></li>
<li><a href="../id453806/index.html">Penanganan Kesalahan saat Go</a></li>
<li><a href="../id453808/index.html">Kami membongkar model bisnis Viking</a></li>
<li><a href="../id453810/index.html">Umpan balik biometrik</a></li>
<li><a href="../id453812/index.html">Tema, gaya, dan lainnya</a></li>
<li><a href="../id453816/index.html">Tick-borne encephalitis: bahaya yang diabaikan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>