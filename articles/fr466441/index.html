<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîπ ü§¥üèΩ üêß Code buggy Python: 10 erreurs les plus courantes que les d√©veloppeurs font ‚ôâÔ∏è üìÉ üîä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä propos de Python 
 Python est un langage de programmation interpr√©t√©, orient√© objet et de haut niveau avec une s√©mantique dynamique. Les structures ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Code buggy Python: 10 erreurs les plus courantes que les d√©veloppeurs font</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  √Ä propos de Python </h3><br>  Python est un langage de programmation interpr√©t√©, orient√© objet et de haut niveau avec une s√©mantique dynamique.  Les structures de donn√©es de haut niveau int√©gr√©es combin√©es √† la frappe dynamique et √† la liaison dynamique le rendent tr√®s attrayant pour BRPS (d√©veloppement rapide d'applications), ainsi que pour une utilisation en tant que langage de script et de connexion pour connecter des composants ou des services existants.  Python prend en charge les modules et les packages, encourageant ainsi la modularit√© du programme et la r√©utilisation du code. <br><br><h3>  √Ä propos de cet article </h3><br>  La simplicit√© et la facilit√© d'apprentissage de ce langage peuvent √™tre d√©routantes pour les d√©veloppeurs (en particulier ceux qui commencent tout juste √† apprendre Python), vous pouvez donc perdre de vue certaines subtilit√©s importantes et sous-estimer la puissance de la vari√©t√© des solutions possibles utilisant Python. <br><br>  Dans cet esprit, cet article pr√©sente le ¬´top 10¬ª des erreurs subtiles et difficiles √† trouver que m√™me les d√©veloppeurs Python avanc√©s peuvent commettre. <br><a name="habracut"></a><br>
<h3>  Erreur # 1: mauvaise utilisation des expressions comme valeurs par d√©faut pour les arguments de fonction </h3><br>  Python vous permet d'indiquer qu'une fonction peut avoir des arguments facultatifs en d√©finissant une valeur par d√©faut pour eux.  Ceci, bien s√ªr, est une caract√©ristique tr√®s pratique du langage, mais peut entra√Æner des cons√©quences d√©sagr√©ables si le type de cette valeur est modifiable.  Par exemple, consid√©rez la d√©finition de fonction suivante: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Une erreur courante dans ce cas est de penser que la valeur d'un argument facultatif sera d√©finie sur une valeur par d√©faut √† chaque fois qu'une fonction est appel√©e sans valeur pour cet argument.  Dans le code ci-dessus, par exemple, nous pouvons supposer qu'en appelant √† plusieurs reprises la fonction foo () (c'est-√†-dire sans sp√©cifier de valeur pour l'argument bar), elle renverra toujours ¬´baz¬ª, car il est suppos√© que chaque fois que foo () est appel√© (sans sp√©cifiant l'argument bar), bar est d√©fini sur [] (c'est-√†-dire une nouvelle liste vide). <br><br>  Mais voyons ce qui se passera r√©ellement: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Hein?  Pourquoi la fonction continue-t-elle d'ajouter la valeur par d√©faut ¬´baz¬ª √† la liste existante √† chaque appel de foo (), au lieu de cr√©er une nouvelle liste √† chaque fois? <br><br>  La r√©ponse √† cette question sera une compr√©hension plus approfondie de ce qui se passe avec Python ¬´sous le capot¬ª.  A savoir: la valeur par d√©faut de la fonction n'est initialis√©e qu'une seule fois, lors de la d√©finition de la fonction.  Ainsi, l'argument bar est initialis√© par d√©faut (c'est-√†-dire une liste vide) uniquement lorsque foo () est d√©fini pour la premi√®re fois, mais les appels ult√©rieurs √† foo () (c'est-√†-dire sans sp√©cifier l'argument bar) continueront √† utiliser la m√™me liste qui √©tait cr√©√© pour la barre d'argument lors de la premi√®re d√©finition de fonction. <br><br>  Pour r√©f√©rence, une ¬´solution de contournement¬ª courante pour cette erreur est la d√©finition suivante: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Erreur # 2: mauvaise utilisation des variables de classe </h3><br>  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Tout semble √™tre en ordre. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ouais, tout √©tait comme pr√©vu. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Que diable?!  Nous venons de changer Ax. Pourquoi Cx a-t-il chang√© aussi? <br><br>  En Python, les variables de classe sont trait√©es comme des dictionnaires et suivent ce qu'on appelle souvent l'ordre de r√©solution de m√©thode (MRO).  Ainsi, dans le code ci-dessus, puisque l'attribut x ne se trouve pas dans la classe C, il le sera dans ses classes de base (uniquement A dans l'exemple ci-dessus, bien que Python supporte l'h√©ritage multiple).  En d'autres termes, C n'a pas sa propre propri√©t√© x ind√©pendante de A. Ainsi, les r√©f√©rences √† Cx sont en fait des r√©f√©rences √† Ax. Cela causera des probl√®mes si ces cas ne sont pas trait√©s correctement.  Ainsi, lorsque vous apprenez Python, portez une attention particuli√®re aux attributs de classe et travaillez avec eux. <br><br><h3>  Erreur n ¬∞ 3: param√®tres incorrects pour le bloc d'exception </h3><br>  Supposons que vous ayez le code suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Le probl√®me ici est que l'expression d'exception n'accepte pas la liste des exceptions sp√©cifi√©es de cette mani√®re.  Au lieu de cela, dans Python 2.x, l'expression ¬´sauf exception, e¬ª est utilis√©e pour lier l'exception √† un second param√®tre facultatif donn√© (dans ce cas, e) pour le rendre disponible pour une inspection plus approfondie.  Par cons√©quent, dans le code ci-dessus, une exception IndexError n'est pas intercept√©e par l'instruction except;  √† la place, l'exception se termine par la liaison √† un param√®tre nomm√© IndexError. <br><br>  La fa√ßon correcte d'attraper plusieurs exceptions avec l'expression d'exception consiste √† sp√©cifier le premier param√®tre sous la forme d'un tuple contenant toutes les exceptions que vous souhaitez intercepter.  De plus, pour une compatibilit√© maximale, utilisez le mot cl√© as, car cette syntaxe est prise en charge √† la fois dans Python 2 et Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Erreur # 4: incompr√©hension des r√®gles de port√©e Python </h3><br>  La port√©e en Python est bas√©e sur la soi-disant r√®gle LEGB, qui est une abr√©viation de Local (noms attribu√©s de quelque mani√®re que ce soit √† l'int√©rieur d'une fonction (def ou lambda), et non d√©clar√©e globale dans cette fonction), Enclosing (nom dans la port√©e locale de toute fonction incluant statiquement ( def ou lambda), de interne √† externe), Global (noms attribu√©s au niveau sup√©rieur du fichier de module, ou en ex√©cutant les instructions globales en def dans le fichier), Built-in (noms pr√©c√©demment attribu√©s dans le module de nom int√©gr√©: open, range, SyntaxError, ...).  Cela semble assez simple, non?  Eh bien, en fait, il existe quelques subtilit√©s sur la fa√ßon dont cela fonctionne en Python, ce qui nous am√®ne au probl√®me de programmation Python plus complexe ci-dessous.  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Quel est le probl√®me? <br><br>  L'erreur ci-dessus se produit car lorsque vous affectez une variable dans la port√©e, Python la consid√®re automatiquement comme locale pour cette port√©e et masque toute variable portant le m√™me nom dans n'importe quelle port√©e parent. <br><br>  Ainsi, beaucoup sont surpris lorsqu'ils re√ßoivent UnboundLocalError dans du code en cours d'ex√©cution, lorsqu'il est modifi√© en ajoutant un op√©rateur d'affectation quelque part dans le corps de la fonction. <br><br>  Cette fonctionnalit√© est particuli√®rement d√©routante pour les d√©veloppeurs lors de l'utilisation de listes.  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Hein?  Pourquoi foo2 plante-t-il alors que foo1 fonctionne correctement? <br><br>  La r√©ponse est la m√™me que dans l'exemple pr√©c√©dent, mais, selon la croyance populaire, la situation ici est plus subtile.  foo1 n'applique pas l'op√©rateur d'affectation √† lst, contrairement √† foo2.  En gardant √† l'esprit que lst + = [5] n'est en fait qu'un raccourci pour lst = lst + [5], nous voyons que nous essayons d'affecter la valeur lst (donc Python suppose qu'elle est de port√©e locale).  Cependant, la valeur que nous voulons attribuer √† lst est bas√©e sur lst lui-m√™me (encore une fois, il est maintenant suppos√© √™tre de port√©e locale), qui n'a pas encore √©t√© d√©termin√©e.  Et nous obtenons une erreur. <br><br><h3>  Erreur # 5: changer une liste pendant l'it√©ration dessus </h3><br>  Le probl√®me dans le morceau de code suivant devrait √™tre assez √©vident: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  La suppression d'un √©l√©ment d'une liste ou d'un tableau pendant l'it√©ration est un probl√®me Python bien connu de tout d√©veloppeur de logiciels exp√©riment√©.  Mais, bien que l'exemple ci-dessus puisse √™tre assez √©vident, m√™me les d√©veloppeurs exp√©riment√©s peuvent se lancer dans ce r√¢teau dans un code beaucoup plus complexe. <br><br>  Heureusement, Python comprend un certain nombre de paradigmes de programmation √©l√©gants qui, lorsqu'ils sont utilis√©s correctement, peuvent conduire √† une simplification et une optimisation significatives du code.  Une autre cons√©quence agr√©able de ceci est que dans un code plus simple, la probabilit√© de tomber dans l'erreur de supprimer accidentellement un √©l√©ment de liste pendant l'it√©ration sur lui est beaucoup moins.  Un tel paradigme est celui des g√©n√©rateurs de listes.  De plus, la compr√©hension du fonctionnement des g√©n√©rateurs de listes est particuli√®rement utile pour √©viter ce probl√®me particulier, comme le montre cette impl√©mentation alternative du code ci-dessus, qui fonctionne tr√®s bien: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Erreur # 6: malentendu sur la fa√ßon dont Python lie les variables dans les fermetures </h3><br>  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Vous pouvez vous attendre √† la sortie suivante: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Mais en r√©alit√©, vous obtenez ceci: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Surprise! <br><br>  Cela est d√ª √† une liaison tardive en Python, ce qui signifie que les valeurs des variables utilis√©es dans les fermetures sont recherch√©es lors de l'appel √† la fonction interne.  Ainsi, dans le code ci-dessus, chaque fois que l'une des fonctions retourn√©es est appel√©e, la valeur de i est recherch√©e dans la port√©e environnante lors de son appel (et √† ce moment-l√†, le cycle √©tait d√©j√† termin√©, par cons√©quent, le r√©sultat final avait d√©j√† √©t√© attribu√© - valeur 4) . <br><br>  La solution √† ce probl√®me Python courant serait: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Nous utilisons ici les arguments par d√©faut pour g√©n√©rer des fonctions anonymes afin d'obtenir le comportement souhait√©.  Certains qualifieraient cette solution d'√©l√©gante.  Certains sont <br>  mince.  Certaines personnes d√©testent ces choses.  Mais si vous √™tes un d√©veloppeur Python, de toute fa√ßon, il est important de comprendre. <br><br><h3>  Erreur # 7: cr√©ation de d√©pendances de module cycliques </h3><br>  Supposons que vous ayez deux fichiers, a.py et b.py, chacun important l'autre, comme suit: <br><br>  Dans a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  Dans b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Tout d'abord, essayez d'importer a.py: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Cela a tr√®s bien fonctionn√©.  Cela peut vous surprendre.  Apr√®s tout, les modules s‚Äôimportent cycliquement et cela devrait probablement √™tre un probl√®me, non? <br><br>  La r√©ponse est que la simple importation cyclique de modules n'est pas en soi un probl√®me en Python.  Si le module a d√©j√† √©t√© import√©, Python est suffisamment intelligent pour ne pas essayer de le r√©importer.  Cependant, selon le point auquel chaque module essaie d'acc√©der aux fonctions ou variables d√©finies dans un autre, vous pouvez r√©ellement rencontrer des probl√®mes. <br><br>  Donc, pour revenir √† notre exemple, lorsque nous avons import√© a.py, il n'a eu aucun probl√®me √† importer b.py, car b.py ne n√©cessite pas de d√©finir a.py lors de son importation.  La seule r√©f√©rence dans b.py √† a est un appel √† af ().  Mais cet appel dans g () et rien dans a.py ou b.py n'appelle pas g ().  Donc, tout fonctionne bien. <br><br>  Mais que se passe-t-il si nous essayons d'importer b.py (sans d'abord importer a.py, c'est-√†-dire): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh, oh.  Ce n'est pas bon!  Le probl√®me ici est que pendant le processus d'importation de b.py, il essaie d'importer a.py, qui √† son tour appelle f (), qui essaie d'acc√©der √† bx Mais bx n'a pas encore √©t√© d√©fini.  D'o√π l'exception AttributeError. <br><br>  Au moins une solution √† ce probl√®me est assez banale.  Modifiez simplement b.py pour importer a.py dans g (): <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Maintenant, quand nous l'importons, tout va bien: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Erreur # 8: intersection de noms avec des noms de modules dans la biblioth√®que standard Python </h3><br>  L'un des charmes de Python est ses nombreux modules qui sortent de la bo√Æte.  Mais par cons√©quent, si vous ne suivez pas consciemment cela, vous pouvez constater que le nom de votre module peut avoir le m√™me nom que le module dans la biblioth√®que standard fournie avec Python (par exemple, dans votre code, il peut y avoir un module avec le nom email.py, qui entrera en conflit avec le module de biblioth√®que standard du m√™me nom). <br><br>  Cela peut entra√Æner de graves probl√®mes.  Par exemple, si l'un des modules essaie d'importer la version du module √† partir de la biblioth√®que standard Python et que vous avez un module dans le projet avec le m√™me nom, qui sera import√© par erreur au lieu du module de la biblioth√®que standard. <br><br>  Par cons√©quent, il convient de ne pas utiliser les m√™mes noms que dans les modules de la biblioth√®que standard Python.  Il est beaucoup plus facile de changer le nom du module dans votre projet que de soumettre une demande pour changer le nom du module dans la biblioth√®que standard et obtenir son approbation. <br><br><h3>  Erreur n ¬∞ 9: non prise en compte des diff√©rences entre Python 2 et Python 3 </h3><br>  Consid√©rez le fichier foo.py suivant: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  Sur Python 2, cela fonctionnera bien: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Mais maintenant, voyons comment cela fonctionnera en Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  Qu'est-ce qui vient de se passer ici?  Le "probl√®me" est qu'en Python 3, un objet dans un bloc d'exception n'est pas disponible en dehors de celui-ci.  (La raison en est qu'autrement, les objets de ce bloc seront stock√©s en m√©moire jusqu'√† ce que le garbage collector d√©marre et en supprime les r√©f√©rences). <br><br>  Une fa√ßon d'√©viter ce probl√®me consiste √† conserver la r√©f√©rence √† l'objet bloc d'exception en dehors de ce bloc afin qu'il reste disponible.  Voici la version de l'exemple pr√©c√©dent qui utilise cette technique, obtenant ainsi du code adapt√© √† la fois √† Python 2 et Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  Ex√©cutez-le dans Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Hourra! <br><br><h3>  Erreur # 10: mauvaise utilisation de la m√©thode __del__ </h3><br>  Disons que vous avez un fichier mod.py comme celui-ci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  Et vous essayez de le faire √† partir d'un autre another_mod.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  Et obtenez une terrible AttributeError. <br><br>  Pourquoi?  Parce que, comme indiqu√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , lorsque l'interpr√©teur s'arr√™te, les variables globales du module ont toutes la valeur None.  Par cons√©quent, dans l'exemple ci-dessus, lorsque __del__ a √©t√© appel√©, le nom foo √©tait d√©j√† d√©fini sur Aucun. <br><br>  La solution √† cette "t√¢che avec un ast√©risque" consiste √† utiliser atexit.register ().  Ainsi, lorsque votre programme termine l'ex√©cution (c'est-√†-dire lorsqu'il se termine normalement), vos descripteurs sont supprim√©s avant que l'interpr√©teur ne termine son travail. <br><br>  Dans cet esprit, le correctif pour le code mod.py ci-dessus pourrait ressembler √† ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Une telle impl√©mentation fournit un moyen simple et fiable d'appeler tout nettoyage n√©cessaire apr√®s la fin d'un programme normal.  √âvidemment, la d√©cision sur la fa√ßon de traiter l'objet associ√© au nom self.myhandle est laiss√©e √† foo.cleanup, mais je pense que vous comprenez l'id√©e. <br><br><h3>  Conclusion </h3><br>  Python est un langage puissant et flexible avec de nombreux m√©canismes et paradigmes qui peuvent am√©liorer consid√©rablement les performances.  Cependant, comme avec tout outil logiciel ou langage, avec une compr√©hension ou une √©valuation limit√©e de ses capacit√©s, des probl√®mes impr√©vus peuvent survenir pendant le d√©veloppement. <br><br>  Une introduction aux nuances Python abord√©es dans cet article vous aidera √† optimiser votre utilisation du langage, tout en √©vitant certaines erreurs courantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466441/">https://habr.com/ru/post/fr466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466431/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 40. Norme 802.1X et famille de protocoles AAA</a></li>
<li><a href="../fr466433/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 41. DHCP Snooping et Nondefault Native VLAN</a></li>
<li><a href="../fr466435/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 42. Routage inter-VLAN et SVI</a></li>
<li><a href="../fr466437/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 43. Protocoles de routage Distance du vecteur et √©tat de la liaison</a></li>
<li><a href="../fr466439/index.html">V√©rifiez vous-m√™me: combien de questions pouvez-vous r√©pondre √† ChGK?</a></li>
<li><a href="../fr466443/index.html">ShIoTiny et le monde: capteurs analogiques ou ADC pour les plus petits</a></li>
<li><a href="../fr466445/index.html">Attaques entre approbations entre domaines</a></li>
<li><a href="../fr466447/index.html">Pourquoi devrions-nous construire un CDN?</a></li>
<li><a href="../fr466449/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 44. Introduction √† OSPF</a></li>
<li><a href="../fr466451/index.html">Read_You can't_throw</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>