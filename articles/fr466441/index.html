<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔹 🤴🏽 🐧 Code buggy Python: 10 erreurs les plus courantes que les développeurs font ♉️ 📃 🔊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À propos de Python 
 Python est un langage de programmation interprété, orienté objet et de haut niveau avec une sémantique dynamique. Les structures ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Code buggy Python: 10 erreurs les plus courantes que les développeurs font</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  À propos de Python </h3><br>  Python est un langage de programmation interprété, orienté objet et de haut niveau avec une sémantique dynamique.  Les structures de données de haut niveau intégrées combinées à la frappe dynamique et à la liaison dynamique le rendent très attrayant pour BRPS (développement rapide d'applications), ainsi que pour une utilisation en tant que langage de script et de connexion pour connecter des composants ou des services existants.  Python prend en charge les modules et les packages, encourageant ainsi la modularité du programme et la réutilisation du code. <br><br><h3>  À propos de cet article </h3><br>  La simplicité et la facilité d'apprentissage de ce langage peuvent être déroutantes pour les développeurs (en particulier ceux qui commencent tout juste à apprendre Python), vous pouvez donc perdre de vue certaines subtilités importantes et sous-estimer la puissance de la variété des solutions possibles utilisant Python. <br><br>  Dans cet esprit, cet article présente le «top 10» des erreurs subtiles et difficiles à trouver que même les développeurs Python avancés peuvent commettre. <br><a name="habracut"></a><br>
<h3>  Erreur # 1: mauvaise utilisation des expressions comme valeurs par défaut pour les arguments de fonction </h3><br>  Python vous permet d'indiquer qu'une fonction peut avoir des arguments facultatifs en définissant une valeur par défaut pour eux.  Ceci, bien sûr, est une caractéristique très pratique du langage, mais peut entraîner des conséquences désagréables si le type de cette valeur est modifiable.  Par exemple, considérez la définition de fonction suivante: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Une erreur courante dans ce cas est de penser que la valeur d'un argument facultatif sera définie sur une valeur par défaut à chaque fois qu'une fonction est appelée sans valeur pour cet argument.  Dans le code ci-dessus, par exemple, nous pouvons supposer qu'en appelant à plusieurs reprises la fonction foo () (c'est-à-dire sans spécifier de valeur pour l'argument bar), elle renverra toujours «baz», car il est supposé que chaque fois que foo () est appelé (sans spécifiant l'argument bar), bar est défini sur [] (c'est-à-dire une nouvelle liste vide). <br><br>  Mais voyons ce qui se passera réellement: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Hein?  Pourquoi la fonction continue-t-elle d'ajouter la valeur par défaut «baz» à la liste existante à chaque appel de foo (), au lieu de créer une nouvelle liste à chaque fois? <br><br>  La réponse à cette question sera une compréhension plus approfondie de ce qui se passe avec Python «sous le capot».  A savoir: la valeur par défaut de la fonction n'est initialisée qu'une seule fois, lors de la définition de la fonction.  Ainsi, l'argument bar est initialisé par défaut (c'est-à-dire une liste vide) uniquement lorsque foo () est défini pour la première fois, mais les appels ultérieurs à foo () (c'est-à-dire sans spécifier l'argument bar) continueront à utiliser la même liste qui était créé pour la barre d'argument lors de la première définition de fonction. <br><br>  Pour référence, une «solution de contournement» courante pour cette erreur est la définition suivante: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Erreur # 2: mauvaise utilisation des variables de classe </h3><br>  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Tout semble être en ordre. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ouais, tout était comme prévu. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Que diable?!  Nous venons de changer Ax. Pourquoi Cx a-t-il changé aussi? <br><br>  En Python, les variables de classe sont traitées comme des dictionnaires et suivent ce qu'on appelle souvent l'ordre de résolution de méthode (MRO).  Ainsi, dans le code ci-dessus, puisque l'attribut x ne se trouve pas dans la classe C, il le sera dans ses classes de base (uniquement A dans l'exemple ci-dessus, bien que Python supporte l'héritage multiple).  En d'autres termes, C n'a pas sa propre propriété x indépendante de A. Ainsi, les références à Cx sont en fait des références à Ax. Cela causera des problèmes si ces cas ne sont pas traités correctement.  Ainsi, lorsque vous apprenez Python, portez une attention particulière aux attributs de classe et travaillez avec eux. <br><br><h3>  Erreur n ° 3: paramètres incorrects pour le bloc d'exception </h3><br>  Supposons que vous ayez le code suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Le problème ici est que l'expression d'exception n'accepte pas la liste des exceptions spécifiées de cette manière.  Au lieu de cela, dans Python 2.x, l'expression «sauf exception, e» est utilisée pour lier l'exception à un second paramètre facultatif donné (dans ce cas, e) pour le rendre disponible pour une inspection plus approfondie.  Par conséquent, dans le code ci-dessus, une exception IndexError n'est pas interceptée par l'instruction except;  à la place, l'exception se termine par la liaison à un paramètre nommé IndexError. <br><br>  La façon correcte d'attraper plusieurs exceptions avec l'expression d'exception consiste à spécifier le premier paramètre sous la forme d'un tuple contenant toutes les exceptions que vous souhaitez intercepter.  De plus, pour une compatibilité maximale, utilisez le mot clé as, car cette syntaxe est prise en charge à la fois dans Python 2 et Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Erreur # 4: incompréhension des règles de portée Python </h3><br>  La portée en Python est basée sur la soi-disant règle LEGB, qui est une abréviation de Local (noms attribués de quelque manière que ce soit à l'intérieur d'une fonction (def ou lambda), et non déclarée globale dans cette fonction), Enclosing (nom dans la portée locale de toute fonction incluant statiquement ( def ou lambda), de interne à externe), Global (noms attribués au niveau supérieur du fichier de module, ou en exécutant les instructions globales en def dans le fichier), Built-in (noms précédemment attribués dans le module de nom intégré: open, range, SyntaxError, ...).  Cela semble assez simple, non?  Eh bien, en fait, il existe quelques subtilités sur la façon dont cela fonctionne en Python, ce qui nous amène au problème de programmation Python plus complexe ci-dessous.  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Quel est le problème? <br><br>  L'erreur ci-dessus se produit car lorsque vous affectez une variable dans la portée, Python la considère automatiquement comme locale pour cette portée et masque toute variable portant le même nom dans n'importe quelle portée parent. <br><br>  Ainsi, beaucoup sont surpris lorsqu'ils reçoivent UnboundLocalError dans du code en cours d'exécution, lorsqu'il est modifié en ajoutant un opérateur d'affectation quelque part dans le corps de la fonction. <br><br>  Cette fonctionnalité est particulièrement déroutante pour les développeurs lors de l'utilisation de listes.  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Hein?  Pourquoi foo2 plante-t-il alors que foo1 fonctionne correctement? <br><br>  La réponse est la même que dans l'exemple précédent, mais, selon la croyance populaire, la situation ici est plus subtile.  foo1 n'applique pas l'opérateur d'affectation à lst, contrairement à foo2.  En gardant à l'esprit que lst + = [5] n'est en fait qu'un raccourci pour lst = lst + [5], nous voyons que nous essayons d'affecter la valeur lst (donc Python suppose qu'elle est de portée locale).  Cependant, la valeur que nous voulons attribuer à lst est basée sur lst lui-même (encore une fois, il est maintenant supposé être de portée locale), qui n'a pas encore été déterminée.  Et nous obtenons une erreur. <br><br><h3>  Erreur # 5: changer une liste pendant l'itération dessus </h3><br>  Le problème dans le morceau de code suivant devrait être assez évident: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  La suppression d'un élément d'une liste ou d'un tableau pendant l'itération est un problème Python bien connu de tout développeur de logiciels expérimenté.  Mais, bien que l'exemple ci-dessus puisse être assez évident, même les développeurs expérimentés peuvent se lancer dans ce râteau dans un code beaucoup plus complexe. <br><br>  Heureusement, Python comprend un certain nombre de paradigmes de programmation élégants qui, lorsqu'ils sont utilisés correctement, peuvent conduire à une simplification et une optimisation significatives du code.  Une autre conséquence agréable de ceci est que dans un code plus simple, la probabilité de tomber dans l'erreur de supprimer accidentellement un élément de liste pendant l'itération sur lui est beaucoup moins.  Un tel paradigme est celui des générateurs de listes.  De plus, la compréhension du fonctionnement des générateurs de listes est particulièrement utile pour éviter ce problème particulier, comme le montre cette implémentation alternative du code ci-dessus, qui fonctionne très bien: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Erreur # 6: malentendu sur la façon dont Python lie les variables dans les fermetures </h3><br>  Prenons l'exemple suivant: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Vous pouvez vous attendre à la sortie suivante: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Mais en réalité, vous obtenez ceci: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Surprise! <br><br>  Cela est dû à une liaison tardive en Python, ce qui signifie que les valeurs des variables utilisées dans les fermetures sont recherchées lors de l'appel à la fonction interne.  Ainsi, dans le code ci-dessus, chaque fois que l'une des fonctions retournées est appelée, la valeur de i est recherchée dans la portée environnante lors de son appel (et à ce moment-là, le cycle était déjà terminé, par conséquent, le résultat final avait déjà été attribué - valeur 4) . <br><br>  La solution à ce problème Python courant serait: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Nous utilisons ici les arguments par défaut pour générer des fonctions anonymes afin d'obtenir le comportement souhaité.  Certains qualifieraient cette solution d'élégante.  Certains sont <br>  mince.  Certaines personnes détestent ces choses.  Mais si vous êtes un développeur Python, de toute façon, il est important de comprendre. <br><br><h3>  Erreur # 7: création de dépendances de module cycliques </h3><br>  Supposons que vous ayez deux fichiers, a.py et b.py, chacun important l'autre, comme suit: <br><br>  Dans a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  Dans b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Tout d'abord, essayez d'importer a.py: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Cela a très bien fonctionné.  Cela peut vous surprendre.  Après tout, les modules s’importent cycliquement et cela devrait probablement être un problème, non? <br><br>  La réponse est que la simple importation cyclique de modules n'est pas en soi un problème en Python.  Si le module a déjà été importé, Python est suffisamment intelligent pour ne pas essayer de le réimporter.  Cependant, selon le point auquel chaque module essaie d'accéder aux fonctions ou variables définies dans un autre, vous pouvez réellement rencontrer des problèmes. <br><br>  Donc, pour revenir à notre exemple, lorsque nous avons importé a.py, il n'a eu aucun problème à importer b.py, car b.py ne nécessite pas de définir a.py lors de son importation.  La seule référence dans b.py à a est un appel à af ().  Mais cet appel dans g () et rien dans a.py ou b.py n'appelle pas g ().  Donc, tout fonctionne bien. <br><br>  Mais que se passe-t-il si nous essayons d'importer b.py (sans d'abord importer a.py, c'est-à-dire): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh, oh.  Ce n'est pas bon!  Le problème ici est que pendant le processus d'importation de b.py, il essaie d'importer a.py, qui à son tour appelle f (), qui essaie d'accéder à bx Mais bx n'a pas encore été défini.  D'où l'exception AttributeError. <br><br>  Au moins une solution à ce problème est assez banale.  Modifiez simplement b.py pour importer a.py dans g (): <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Maintenant, quand nous l'importons, tout va bien: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Erreur # 8: intersection de noms avec des noms de modules dans la bibliothèque standard Python </h3><br>  L'un des charmes de Python est ses nombreux modules qui sortent de la boîte.  Mais par conséquent, si vous ne suivez pas consciemment cela, vous pouvez constater que le nom de votre module peut avoir le même nom que le module dans la bibliothèque standard fournie avec Python (par exemple, dans votre code, il peut y avoir un module avec le nom email.py, qui entrera en conflit avec le module de bibliothèque standard du même nom). <br><br>  Cela peut entraîner de graves problèmes.  Par exemple, si l'un des modules essaie d'importer la version du module à partir de la bibliothèque standard Python et que vous avez un module dans le projet avec le même nom, qui sera importé par erreur au lieu du module de la bibliothèque standard. <br><br>  Par conséquent, il convient de ne pas utiliser les mêmes noms que dans les modules de la bibliothèque standard Python.  Il est beaucoup plus facile de changer le nom du module dans votre projet que de soumettre une demande pour changer le nom du module dans la bibliothèque standard et obtenir son approbation. <br><br><h3>  Erreur n ° 9: non prise en compte des différences entre Python 2 et Python 3 </h3><br>  Considérez le fichier foo.py suivant: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  Sur Python 2, cela fonctionnera bien: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Mais maintenant, voyons comment cela fonctionnera en Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  Qu'est-ce qui vient de se passer ici?  Le "problème" est qu'en Python 3, un objet dans un bloc d'exception n'est pas disponible en dehors de celui-ci.  (La raison en est qu'autrement, les objets de ce bloc seront stockés en mémoire jusqu'à ce que le garbage collector démarre et en supprime les références). <br><br>  Une façon d'éviter ce problème consiste à conserver la référence à l'objet bloc d'exception en dehors de ce bloc afin qu'il reste disponible.  Voici la version de l'exemple précédent qui utilise cette technique, obtenant ainsi du code adapté à la fois à Python 2 et Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  Exécutez-le dans Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Hourra! <br><br><h3>  Erreur # 10: mauvaise utilisation de la méthode __del__ </h3><br>  Disons que vous avez un fichier mod.py comme celui-ci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  Et vous essayez de le faire à partir d'un autre another_mod.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  Et obtenez une terrible AttributeError. <br><br>  Pourquoi?  Parce que, comme indiqué <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , lorsque l'interpréteur s'arrête, les variables globales du module ont toutes la valeur None.  Par conséquent, dans l'exemple ci-dessus, lorsque __del__ a été appelé, le nom foo était déjà défini sur Aucun. <br><br>  La solution à cette "tâche avec un astérisque" consiste à utiliser atexit.register ().  Ainsi, lorsque votre programme termine l'exécution (c'est-à-dire lorsqu'il se termine normalement), vos descripteurs sont supprimés avant que l'interpréteur ne termine son travail. <br><br>  Dans cet esprit, le correctif pour le code mod.py ci-dessus pourrait ressembler à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Une telle implémentation fournit un moyen simple et fiable d'appeler tout nettoyage nécessaire après la fin d'un programme normal.  Évidemment, la décision sur la façon de traiter l'objet associé au nom self.myhandle est laissée à foo.cleanup, mais je pense que vous comprenez l'idée. <br><br><h3>  Conclusion </h3><br>  Python est un langage puissant et flexible avec de nombreux mécanismes et paradigmes qui peuvent améliorer considérablement les performances.  Cependant, comme avec tout outil logiciel ou langage, avec une compréhension ou une évaluation limitée de ses capacités, des problèmes imprévus peuvent survenir pendant le développement. <br><br>  Une introduction aux nuances Python abordées dans cet article vous aidera à optimiser votre utilisation du langage, tout en évitant certaines erreurs courantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466441/">https://habr.com/ru/post/fr466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466431/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 40. Norme 802.1X et famille de protocoles AAA</a></li>
<li><a href="../fr466433/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 41. DHCP Snooping et Nondefault Native VLAN</a></li>
<li><a href="../fr466435/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 42. Routage inter-VLAN et SVI</a></li>
<li><a href="../fr466437/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 43. Protocoles de routage Distance du vecteur et état de la liaison</a></li>
<li><a href="../fr466439/index.html">Vérifiez vous-même: combien de questions pouvez-vous répondre à ChGK?</a></li>
<li><a href="../fr466443/index.html">ShIoTiny et le monde: capteurs analogiques ou ADC pour les plus petits</a></li>
<li><a href="../fr466445/index.html">Attaques entre approbations entre domaines</a></li>
<li><a href="../fr466447/index.html">Pourquoi devrions-nous construire un CDN?</a></li>
<li><a href="../fr466449/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 44. Introduction à OSPF</a></li>
<li><a href="../fr466451/index.html">Read_You can't_throw</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>