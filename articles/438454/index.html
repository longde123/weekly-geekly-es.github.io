<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üßîüèΩ üíÖüèø OpenSceneGraph: Niveles de detalle (LOD) y carga de fondo de objetos ü•û ü•É üí•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Una de las tareas m√°s interesantes resueltas por medio de gr√°ficos tridimensionales es la creaci√≥n de "grandes mundos": escenas largas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Niveles de detalle (LOD) y carga de fondo de objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438454/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Una de las tareas m√°s interesantes resueltas por medio de gr√°ficos tridimensionales es la creaci√≥n de "grandes mundos": escenas largas que contienen una gran cantidad de objetos con la posibilidad de un movimiento ilimitado por el escenario.  La soluci√≥n a este problema se basa en las limitaciones entendibles inherentes al hardware de la computadora. <br><br>  <i>Un ejemplo t√≠pico: el "gran mundo" cuando se visualiza el ferrocarril en el motor OSG.</i>  <i>Todo lo que falta son los langoliers que devoran el mundo detr√°s del tren ...</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YEaYugmhO2Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En este sentido, es necesario administrar los recursos de la aplicaci√≥n, lo que se reduce a una soluci√≥n obvia: cargar solo los recursos (modelos, texturas, etc.) que se necesitan para formar una escena en el momento actual con la posici√≥n actual del observador;  reducci√≥n de niveles de detalle de objetos remotos;  la descarga de objetos ya no es necesaria desde la memoria del sistema.  En su mayor parte, los motores de gr√°ficos y juegos proporcionan un cierto conjunto de herramientas para resolver tales problemas.  Hoy miramos cu√°les de ellos est√°n disponibles en OpenSceneGraph. <br><a name="habracut"></a><br><h1>  1. Uso de niveles de detalle (LOD) </h1><br>  La t√©cnica de usar niveles de detalle le permite mostrar el mismo objeto con m√°s o menos detalle, dependiendo de la distancia desde el mismo hasta el observador.  El uso de esta t√©cnica se basa en la simple consideraci√≥n de que los peque√±os detalles de un modelo tridimensional son indistinguibles en una gran distancia, lo que significa que no hay necesidad de dibujarlos.  Por un lado, esta t√©cnica le permite reducir el n√∫mero total de primitivas geom√©tricas que salen al b√∫fer de cuadros y, por otro lado, no perder el rango de visualizaci√≥n de los objetos de la escena, lo cual es muy √∫til cuando se crean grandes mundos abiertos. <br><br>  OSG proporciona herramientas para implementar esta t√©cnica a trav√©s de la clase osg :: LOD, heredada del mismo grupo osg ::.  Esta clase le permite representar el mismo objeto en varios niveles de detalle.  Cada nivel de detalle se caracteriza por una distancia m√≠nima y m√°xima al observador, en cuya observaci√≥n se cambia la visualizaci√≥n del objeto en este nivel de detalle. <br><br>  osg :: LOD le permite especificar este rango inmediatamente al definir un nodo secundario, o posterior, utilizando los m√©todos setRange () <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; lodNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; lodNode-&gt;addChild(node2, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>, FLT_MAX); lodNode-&gt;addChild(node1); . . . lodNode-&gt;setRange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>);</code> </pre> <br>  Continuamos atormentando a Cessna e ilustramos la t√©cnica descrita con un ejemplo <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Lod</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/LOD&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgUtil/Simplifier&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; modelL2 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osgUtil::Simplifier simplifer; simplifer.setSampleRatio(0.5f); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(0.1f); modelL1-&gt;accept(simplifer); osg::ref_ptr&lt;osg::LOD&gt; root = new osg::LOD; root-&gt;addChild(modelL1.get(), 200.0f, FLT_MAX); root-&gt;addChild(modelL2.get(), 50.0f, 200.0f); root-&gt;addChild(modelL3.get(), 0.0f, 50.0f); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Primero, cargue el modelo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Ahora necesita generar varios modelos (nos limitaremos a dos ejemplos), con un menor nivel de detalle.  Para hacer esto, copie el nodo cargado dos veces, utilizando la t√©cnica de la llamada copia "profunda" de la clase, para el nodo implementado por el m√©todo clone () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL));</code> </pre><br>  Ahora reducimos la geometr√≠a de estos modelos usando la clase osgUtil :: Simplifer.  El grado de simplificaci√≥n del modelo se establece mediante el m√©todo setSampleRatio () de esta clase: cuanto m√°s peque√±o sea el par√°metro pasado, menos detallado ser√° el modelo despu√©s de aplicar el procedimiento de reducci√≥n <br><br><pre> <code class="cpp hljs">osgUtil::Simplifier simplifer; simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>); modelL1-&gt;accept(simplifer);</code> </pre><br>  Cuando tenemos modelos de diferentes niveles de detalle, podemos cargarlos al nodo ra√≠z, creado como un puntero inteligente para osg :: LOD.  Para cada nivel de detalle, configure la distancia de visualizaci√≥n de este nivel <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; root-&gt;addChild(modelL1.get(), <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX); root-&gt;addChild(modelL2.get(), <span class="hljs-number"><span class="hljs-number">50.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>); root-&gt;addChild(modelL3.get(), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">50.0f</span></span>);</code> </pre><br>  Por FLT_MAX se entiende de alguna manera una "gran distancia" infinita al observador.  Despu√©s de iniciar el visor, obtenemos la siguiente imagen <br><br>  Nivel de detalle 3 <br><br><img src="https://habrastorage.org/webt/ww/d7/bq/wwd7bqrlttw9sgedue6m5xoxjgu.png"><br><br>  Nivel de detalle 2 <br><br><img src="https://habrastorage.org/webt/us/ku/h0/uskuh0x_zfchoklahjzoqjeq--c.png"><br><br>  Nivel de detalle 1 <br><br><img src="https://habrastorage.org/webt/lh/gi/ca/lhgica7l6z4dnl9w8yekiodyxn0.png"><br><br>  Se puede ver que cuando la c√°mara se aleja del objeto, el detalle de la geometr√≠a visualizada disminuye.  Con esta t√©cnica, puede lograr un alto realismo de la escena con un bajo consumo de recursos. <br><br><h1>  2. T√©cnica de carga de fondo para nodos de escena </h1><br>  El motor OSG proporciona las clases osg :: ProxyNode y osg :: PagedLOD, dise√±adas para equilibrar la carga al representar la escena.  Ambas clases heredan de osg :: Group. <br><br>  Un nodo del tipo osg :: ProxyNode reduce el tiempo de inicio de la aplicaci√≥n antes de renderizar, si la escena tiene una gran cantidad de modelos cargados desde el disco y mostrados.  Funciona como una interfaz para archivos externos, lo que permite la carga diferida de modelos.  Para agregar nodos secundarios, use el m√©todo setFileName () (en lugar de addChild) para establecer el nombre del archivo del modelo en el disco y cargarlo din√°micamente. <br><br>  El nodo osg :: PagedNode hereda los m√©todos osg :: LOD y carga y descarga los niveles de detalle de manera que se evite sobrecargar la canalizaci√≥n de OpenGL y garantizar una representaci√≥n fluida de la escena. <br><br><h1>  3. Carga din√°mica (tiempo de ejecuci√≥n) del modelo </h1><br>  Veamos c√≥mo ocurre el proceso de cargar el modelo usando osg :: ProxyNode. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de proxynodo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ProxyNode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ProxyNode&gt; root = new osg::ProxyNode; root-&gt;setFileName(0, "../data/cow.osg"); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  El proceso de descarga aqu√≠ es un poco diferente <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::ProxyNode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::ProxyNode; root-&gt;setFileName(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"../data/cow.osg"</span></span>);</code> </pre><br>  En lugar de cargar expl√≠citamente el modelo de vaca, le indicamos al nodo ra√≠z el nombre del archivo donde se encuentran el modelo y el √≠ndice del nodo secundario, donde este modelo debe colocarse despu√©s de cargarlo.  Al ejecutar el programa, obtenemos este resultado <br><br><img src="https://habrastorage.org/webt/4u/z_/yb/4uz_ybvtau_okn8gtbsyvesuqo8.png"><br><br>  Se puede ver que el punto de vista no se eligi√≥ de la mejor manera: la c√°mara descansa directamente en el lado del espejo de la vaca.  Esto sucedi√≥ porque el modelo se carg√≥ despu√©s de iniciar el renderizado e inicializar la c√°mara, cuando el nodo 0 a√∫n no era visible.  El espectador simplemente no pudo calcular los par√°metros necesarios de la c√°mara.  Sin embargo, el modelo se ha cargado y podemos configurar el modo de visualizaci√≥n manipulando el mouse <br><br><img src="https://habrastorage.org/webt/kj/qp/hm/kjqphmpi5-thkedfpuqflwfywoa.png"><br><br>  ¬øQu√© sucede en el ejemplo anterior?  osg :: ProxyNode y osg :: PagedLOD funcionan en este caso como contenedores.  El administrador de datos interno de OSG enviar√° solicitudes y cargar√° datos en el gr√°fico de escena a medida que surja la necesidad de archivos de modelo y niveles de detalle. <br><br>  Este mecanismo funciona en varias secuencias en segundo plano y controla la carga de datos est√°ticos ubicados en archivos en el disco y datos din√°micos generados y agregados durante la ejecuci√≥n del programa. <br><br>  El motor procesa autom√°ticamente los nodos que no se muestran en la ventana gr√°fica actual y los elimina del gr√°fico de escena cuando el renderizado est√° sobrecargado.  Sin embargo, este comportamiento no afecta a los nodos osg :: ProxyNode. <br><br>  Al igual que el nodo proxy, la clase osg :: PagedLOD tambi√©n tiene un m√©todo setFileName () para especificar la ruta al modelo cargado, sin embargo, debe establecer el rango de visibilidad para √©l, como para el nodo osg :: LOD.  Siempre que tengamos un archivo cessna.osg y un modelo low-poly de nivel L1, podemos organizar el nodo paginado de la siguiente manera <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; pagedLOD-&gt;addChild(modelL1, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX ); pagedLOD-&gt;setFileName( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span> ); pagedLOD-&gt;setRange( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span> );</code> </pre><br>  Debe comprender que el nodo modelL1 no se puede descargar de la memoria, ya que este es un nodo secundario no proxy normal. <br><br>  Al renderizar, la diferencia entre osg :: LOD y osg :: PagedLOD no es visible cuando se usa solo un nivel de detalle del modelo.  Una idea interesante ser√≠a organizar un gran grupo de modelos Cessna utilizando la clase osg :: MatrixTransform.  Para esto, puede usar, por ejemplo, dicha funci√≥n <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLODNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3&amp; pos )</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; ‚Ä¶ osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;setMatrix( osg::Matrix::translate(pos) ); mt-&gt;addChild( pagedLOD.get() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mt.release(); }</code> </pre><br>  Un programa de ejemplo que implementa la carga en segundo plano de 10.000 aviones. <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PagedLOD&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLODNode(const std::string &amp;filepath, const osg::Vec3 &amp;pos) { osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = new osg::PagedLOD; pagedLOD-&gt;setFileName(0, filepath); pagedLOD-&gt;setRange(0, 0.0f, FLT_MAX); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;setMatrix(osg::Matrix::translate(pos)); mt-&gt;addChild(pagedLOD.get()); return mt.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; float dist = 50.0f; int N = 100; for (int i = 0; i &lt; N; ++i) { float x = i * dist; for (int j = 0; j &lt; N; ++j) { float y = j * dist; osg::Vec3 pos(x, y, 0.0f); osg::ref_ptr&lt;osg::Node&gt; node = createLODNode("../data/cessna.osg", pos); root-&gt;addChild(node.get()); } } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Se supone que el avi√≥n se ubicar√° en un avi√≥n con un intervalo de 50 unidades de coordenadas.  Al cargar, veremos que solo se cargan los cessna que entran en el marco.  Esos planos que desaparecen del marco desaparecen del √°rbol de la escena. <br><br><img src="https://habrastorage.org/webt/zx/cc/j4/zxccj4cjwh5a0ejfpl6mjudq8zi.png"><br><br><h1>  Conclusi√≥n </h1><br>  Esta lecci√≥n de la serie OpenSceneGraph ser√° la √∫ltima en el formato C√≥mo.  En el transcurso de doce art√≠culos, fue posible ajustar los principios b√°sicos de trabajo y uso de OpenSceneGraph en la pr√°ctica.  Realmente espero que este motor se haya vuelto m√°s claro para el desarrollador de habla rusa. <br><br>  Esto no significa que est√© cerrando el tema de OpenSceneGraph en el recurso, por el contrario, est√° previsto dedicar futuros art√≠culos a t√©cnicas y m√©todos m√°s avanzados de uso de OSG en el desarrollo de aplicaciones gr√°ficas.  Pero para esto necesita acumular buen material y procesar muchas fuentes de habla inglesa, y esto lleva tiempo. <br><br>  Pero no me despido, gracias por su atenci√≥n y hasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pronto!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438454/">https://habr.com/ru/post/438454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438438/index.html">Alimento para loros Bitrix. Probamos el rendimiento, seleccionamos hierro</a></li>
<li><a href="../438442/index.html">Reenv√≠o de solicitudes de Apache a Payara Server 5 en Ubuntu</a></li>
<li><a href="../438446/index.html">Punto de referencia como base para decidir sobre un cambio de c√≥digo</a></li>
<li><a href="../438448/index.html">¬øQu√© PC Speaker es capaz de hacer?</a></li>
<li><a href="../438450/index.html">¬øPor qu√© la plantilla de pol√≠tica de privacidad no es adecuada para usted?</a></li>
<li><a href="../438456/index.html">Configuraci√≥n de inicio de sesi√≥n √∫nico en Zimbra Collaboration Suite</a></li>
<li><a href="../438458/index.html">La Conferencia DUMP 2019 se llevar√° a cabo el 19 de abril. Te invitamos a hablar en las secciones de Frontend, Backend y Ciencia.</a></li>
<li><a href="../438460/index.html">Serializaci√≥n a nivel de base de datos</a></li>
<li><a href="../438462/index.html">Una forma r√°pida de agregar notificaciones a una aplicaci√≥n de Android</a></li>
<li><a href="../438464/index.html">SciPy, algoritmos gr√°ficos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>