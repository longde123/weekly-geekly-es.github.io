<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üñäÔ∏è ü•¢ werf - nuestra herramienta para CI / CD en Kubernetes (revisi√≥n y video informe) üå± üë©üèΩ‚Äçüé® üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El 27 de mayo, en la sala principal de la conferencia DevOpsConf 2019, celebrada como parte del festival RIT ++ 2019 , como parte de la secci√≥n Entreg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>werf - nuestra herramienta para CI / CD en Kubernetes (revisi√≥n y video informe)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460351/">  El 27 de mayo, en la sala principal de la conferencia DevOpsConf 2019, celebrada como parte del festival <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RIT ++ 2019</a> , como parte de la secci√≥n Entrega continua, se hizo un informe "werf es nuestra herramienta para CI / CD en Kubernetes".  Habla sobre los <b>problemas y desaf√≠os que todos enfrentan cuando se implementan en Kubernetes</b> , as√≠ como sobre los matices que pueden no ser inmediatamente perceptibles.  Analizando posibles soluciones, mostramos c√≥mo se implementa esto en la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> Open Source. <br><br>  Desde el programa, nuestra utilidad (anteriormente conocida como dapp) ha superado el l√≠mite hist√≥rico de <b>1000 estrellas en GitHub</b> ; esperamos que la creciente comunidad de usuarios simplifique la vida de muchos ingenieros de DevOps. <br><br><img src="https://habrastorage.org/webt/lh/k9/x1/lhk9x1wf3gzo6bk1lsjosnvjg1g.jpeg"><br><br>  Entonces, presentamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>video con el informe</b></a> (~ 47 minutos, mucho m√°s informativo que el art√≠culo) y el extracto principal del mismo en forma de texto.  Vamos! <a name="habracut"></a><br><br><h2>  Entrega de c√≥digo en Kubernetes </h2><br>  La charla ya no ser√° sobre werf, sino sobre CI / CD en Kubernetes, lo que implica que nuestro software est√° empaquetado en contenedores Docker <i>(habl√© de esto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el informe de 2016</a> )</i> , y los K8 se usar√°n para lanzarlo en producci√≥n <i>(sobre esto - en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2017</a> )</i> . <br><br>  ¬øC√≥mo es la entrega de Kubernetes? <br><br><ul><li>  Hay un repositorio Git con c√≥digo e instrucciones para construirlo.  La aplicaci√≥n se compila en una imagen de Docker y se publica en el Registro de Docker. </li><li>  En el mismo repositorio hay instrucciones sobre c√≥mo implementar y ejecutar la aplicaci√≥n.  En la etapa de implementaci√≥n, estas instrucciones se env√≠an a Kubernetes, que recibe la imagen deseada del registro y la inicia. </li><li>  Adem√°s, generalmente hay pruebas.  Algunos de ellos se pueden realizar al publicar una imagen.  Tambi√©n puede (siguiendo las mismas instrucciones) desplegar una copia de la aplicaci√≥n (en un espacio de nombres K8s separado o en un cl√∫ster separado) y ejecutar pruebas all√≠. </li><li>  Finalmente, necesitamos un sistema de CI que reciba eventos de Git (o clics de bot√≥n) y llame a todas las etapas indicadas: compilar, publicar, implementar, probar. </li></ul><br><img src="https://habrastorage.org/webt/vd/jh/ks/vdjhksq3874swybast6v7oerqe4.gif"><br><br>  Aqu√≠ hay algunas notas importantes: <br><br><ol><li>  Como tenemos una infraestructura inmutable, la imagen de la aplicaci√≥n que se utiliza en todas las etapas (puesta en escena, producci√≥n, etc.) <b>debe ser una</b> .  <i>Habl√© m√°s sobre esto y con ejemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</i> </li><li>  Dado que estamos siguiendo la infraestructura como un <i>enfoque de</i> c√≥digo <i>(IaC)</i> , el c√≥digo de la aplicaci√≥n y las instrucciones para construirlo y ejecutarlo deben estar <b>en un repositorio</b> .  <i>Para m√°s informaci√≥n sobre esto, vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el mismo informe</a> .</i> </li><li>  Por lo general, vemos la cadena de entrega <i>(entrega)</i> as√≠: la aplicaci√≥n se ensambla, se prueba, se lanza <i>(etapa de lanzamiento)</i> y eso es todo: la entrega se ha producido.  Pero en realidad, el usuario recibe lo que usted implement√≥, <b>no</b> cuando lo entreg√≥ a producci√≥n, sino cuando pudo ir all√≠ y esta producci√≥n funcion√≥.  Por lo tanto, creo que la cadena de entrega finaliza <b>solo en la etapa operativa</b> <i>(ejecuci√≥n)</i> , y m√°s precisamente, incluso en el momento en que el c√≥digo se elimin√≥ de la producci√≥n (reemplaz√°ndolo por uno nuevo). </li></ol><br>  Volvamos al esquema de entrega de Kubernetes descrito anteriormente: fue inventado no solo por nosotros, sino literalmente por todos los que se ocuparon de este problema.  En esencia, este patr√≥n ahora se llama GitOps <i>(puede encontrar m√°s informaci√≥n sobre el t√©rmino y las ideas detr√°s de √©l <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> )</i> .  Veamos las etapas del esquema. <br><br><h2>  Etapa de construcci√≥n </h2><br>  Parece que en 2019 puedes contar sobre el ensamblaje de las im√°genes de Docker, cuando todos sepan c√≥mo escribir Dockerfiles y ejecutar Docker <code>docker build</code> ? ... Aqu√≠ est√°n los matices a los que me gustar√≠a prestar atenci√≥n: <br><br><ol><li>  <b>El peso de la imagen es</b> importante, as√≠ que use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√∫ltiples etapas</a> para dejar solo la aplicaci√≥n realmente necesaria para la imagen. </li><li>  <b>El n√∫mero de capas</b> debe minimizarse combinando las cadenas de comandos <code>RUN</code> dentro del significado. </li><li>  Sin embargo, esto se suma a los problemas de <b>depuraci√≥n</b> , ya que cuando el ensamblaje falla, debe encontrar el comando necesario de la cadena que caus√≥ el problema. </li><li>  <b>La velocidad de creaci√≥n es</b> importante porque queremos implementar r√°pidamente los cambios y ver el resultado.  Por ejemplo, no quiero volver a ensamblar las dependencias en las bibliotecas de idiomas con cada compilaci√≥n de la aplicaci√≥n. </li><li>  A menudo, se requieren <b>muchas im√°genes</b> de un repositorio Git, que puede resolverse mediante un conjunto de Dockerfiles (o etapas con nombre en un archivo) y un script Bash con su ensamblaje secuencial. </li></ol><br>  Era solo la punta del iceberg que todos enfrentan.  Pero hay otros problemas, y en particular: <br><br><ol><li>  A menudo, en la etapa de ensamblaje, necesitamos <b>montar</b> algo (por ejemplo, almacenar en cach√© el resultado de un comando como apt en un directorio de terceros). </li><li>  Queremos <b>Ansible en</b> lugar de escribir en el shell. </li><li>  Queremos <b>construir sin Docker</b> (¬øpor qu√© necesitamos una m√°quina virtual adicional en la que necesite configurar todo para esto cuando ya hay un cl√∫ster de Kubernetes en el que puede ejecutar contenedores?). </li><li>  <b>Ensamblaje en paralelo</b> , que puede entenderse de diferentes maneras: diferentes comandos del Dockerfile (si se usan varias etapas), varias confirmaciones de un repositorio, varios Dockerfiles. </li><li>  <b>Ensamblaje distribuido</b> : queremos recolectar algo en vainas que sean "ef√≠meras", porque  su cach√© desaparece, lo que significa que debe almacenarse en alg√∫n lugar por separado. </li><li>  Finalmente, llam√© <b>al</b> pin√°culo de los deseos auto- <b>m√°gico</b> : ser√≠a ideal ir al repositorio, escribir alg√∫n equipo y obtener una imagen preparada, ensamblada con una comprensi√≥n de c√≥mo y qu√© hacer bien.  Sin embargo, personalmente no estoy seguro de que todos los matices se puedan prever de esta manera. </li></ol><br>  Y aqu√≠ est√°n los proyectos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">moby / buildkit</a> : un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">creador</a> de la compa√±√≠a Docker Inc (ya integrado en las versiones actuales de Docker), que est√° tratando de resolver todos estos problemas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kaniko</a> : un recopilador de Google, que le permite construir sin Docker; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buildpacks.io</a> : un intento de CNCF de hacer magia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autom√°tica</a> y, en particular, una soluci√≥n interesante con rebase para capas; </li><li>  y un mont√≥n de otras utilidades como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buildah</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">genuinetools / img</a> ... </li></ul><br>  ... y ver cu√°ntas estrellas tienen en GitHub.  Es decir, por un lado, la <code>docker build</code> es y puede hacer algo, pero en realidad, el <b>problema no se ha resuelto por completo</b> ; esto se evidencia por el desarrollo paralelo de constructores alternativos, cada uno de los cuales resuelve algunos de los problemas. <br><br><h2>  Construir en werf </h2><br>  As√≠ que llegamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> <i>(anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conocido</a> como dapp)</i> , la utilidad Open Source de Flant, que hemos estado haciendo durante muchos a√±os.  Todo comenz√≥ hace unos 5 a√±os con scripts Bash que optimizan el ensamblaje de Dockerfiles, y en los √∫ltimos 3 a√±os, el desarrollo completo ha estado en curso dentro del marco de un proyecto con su propio repositorio Git <i>(primero en Ruby, y luego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reescrito</a> en Go, y al mismo tiempo renombrado)</i> .  ¬øQu√© problemas de compilaci√≥n se resuelven en werf? <br><br><img src="https://habrastorage.org/webt/--/1-/ca/--1-cakzswwfhrcrgnees6cvf-a.png"><br><br>  Los problemas de sombreado azul ya se han implementado, el ensamblaje paralelo se ha realizado dentro del mismo host, y planeamos completar las preguntas amarillas para el final del verano. <br><br><h2>  Etapa de publicaci√≥n en el registro (publicar) </h2><br>  Escribimos <code>docker push</code> ... ¬øQu√© puede ser dif√≠cil al subir una imagen al registro?  Y luego surge la pregunta: "¬øQu√© etiqueta poner la imagen?"  Surge por la raz√≥n de que tenemos <b>Gitflow</b> (u otra estrategia de Git) y Kubernetes, y la industria se compromete a garantizar que lo que sucede en Kubernetes siga lo que se est√° haciendo en Git.  Git es nuestra √∫nica fuente de verdad. <br><br>  ¬øQu√© es tan complicado?  <b>Garantice la reproducibilidad</b> : desde un commit en Git, que es inherentemente <i>inmutable</i> , hasta una imagen de Docker que debe mantenerse igual. <br><br>  Tambi√©n es importante para nosotros <b>determinar el origen</b> , porque queremos entender a partir de qu√© compromiso se cre√≥ la aplicaci√≥n lanzada en Kubernetes (entonces podemos hacer diferencias y cosas similares). <br><br><h3>  Estrategias de etiquetado </h3><br>  El primero es una simple <b>etiqueta git</b> .  Tenemos un registro con una imagen etiquetada como <code>1.0</code> .  Kubernetes tiene escenario y producci√≥n, donde se bombea esta imagen.  En Git, hacemos commits y en alg√∫n momento ponemos la etiqueta <code>2.0</code> .  Lo recopilamos de acuerdo con las instrucciones del repositorio y lo colocamos en el registro con la etiqueta <code>2.0</code> .  Lo lanzamos al escenario y, si todo est√° bien, a la producci√≥n. <br><br><img src="https://habrastorage.org/webt/4f/ub/u4/4fubu4r-0obh9gkzs4_kftnlqxs.gif"><br><br>  El problema con este enfoque es que primero configuramos la etiqueta, y solo luego la probamos y la implementamos.  Por qu√©  En primer lugar, esto es simplemente il√≥gico: entregamos una versi√≥n de software que ni siquiera hemos probado (no podemos hacer lo contrario, porque para verificar, debe colocar una etiqueta).  En segundo lugar, esta forma no es compatible con Gitflow. <br><br>  La segunda opci√≥n es <b>git commit + tag</b> .  Hay una etiqueta <code>1.0</code> en la rama maestra;  para √©l en el registro: una imagen desplegada en producci√≥n.  Adem√°s, el cl√∫ster de Kubernetes tiene bucles de vista previa y etapas.  Adem√°s, seguimos a Gitflow: en la rama principal para el desarrollo <code>develop</code> nuevas caracter√≠sticas, como resultado de lo cual existe una confirmaci√≥n con el identificador <code>#c1</code> .  Lo recopilamos y lo publicamos en el registro utilizando este identificador ( <code>#c1</code> ).  Lanzamos la vista previa con el mismo identificador.  Hacemos lo mismo con los commits <code>#c2</code> y <code>#c3</code> . <br><br>  Cuando nos damos cuenta de que hay suficientes caracter√≠sticas, comenzamos a estabilizar todo.  En Git, cree la rama <code>release_1.1</code> (basada en <code>#c3</code> de <code>develop</code> ).  No es necesario recopilar esta versi√≥n porque  Esto se hizo en el paso anterior.  Por lo tanto, podemos implementarlo en la puesta en escena.  Solucionamos errores en <code>#c4</code> y de forma similar se implementan en la puesta en escena.  Al mismo tiempo, el desarrollo est√° en curso en el <code>develop</code> , donde los cambios de la <code>release_1.1</code> se toman peri√≥dicamente.  En alg√∫n momento, nos comprometemos y nos comprometemos con la puesta en escena, con lo que estamos contentos ( <code>#c25</code> ). <br><br>  Luego hacemos una fusi√≥n (con avance r√°pido) de la rama de lanzamiento ( <code>release_1.1</code> ) en master.  Ponemos una etiqueta con la nueva versi√≥n ( <code>1.1</code> ) en este commit.  Pero esta imagen ya est√° ensamblada en el registro, por lo que para no volver a recopilarla, solo agregamos una segunda etiqueta a la imagen existente (ahora tiene las etiquetas <code>#c25</code> y <code>1.1</code> en el registro).  Despu√©s de eso, lo implementamos en producci√≥n. <br><br>  Existe el inconveniente de que una imagen ( <code>#c25</code> ) se <code>#c25</code> en la preparaci√≥n y otra ( <code>1.1</code> ) se <code>#c25</code> en la producci√≥n, pero sabemos que "f√≠sicamente" es la misma imagen del registro. <br><br><img src="https://habrastorage.org/webt/mb/pq/iu/mbpqiumzomvrouhp8llx5aishza.gif"><br><br>  El verdadero inconveniente es que no hay soporte para merge commit'ov, debe avanzar r√°pidamente. <br><br>  Puede ir m√°s all√° y hacer el truco ... Considere un ejemplo de un Dockerfile simple: <br><br><pre> <code class="plaintext hljs">FROM ruby:2.3 as assets RUN mkdir -p /app WORKDIR /app COPY . ./ RUN gem install bundler &amp;&amp; bundle install RUN bundle exec rake assets:precompile CMD bundle exec puma -C config/puma.rb FROM nginx:alpine COPY --from=assets /app/public /usr/share/nginx/www/public</code> </pre> <br>  Construimos un archivo a partir de √©l de acuerdo con este principio, que tomamos: <br><br><ul><li>  SHA256 de identificadores de im√°genes usadas ( <code>ruby:2.3</code> y <code>nginx:alpine</code> ), que son sumas de comprobaci√≥n de su contenido; </li><li>  todos los equipos ( <code>RUN</code> , <code>CMD</code> , etc.); </li><li>  SHA256 de los archivos que se agregaron. </li></ul><br>  ... y tome la suma de comprobaci√≥n (nuevamente SHA256) de dicho archivo.  Esta es la <b>firma de</b> todo lo que define el contenido de una imagen Docker. <br><br><img src="https://habrastorage.org/webt/zp/w2/ju/zpw2jup54xa66mit1bt9u7amwlk.gif"><br><br>  Volvamos al esquema y en <b>lugar de commits usaremos tales firmas</b> , es decir.  etiquetar im√°genes con firmas. <br><br><img src="https://habrastorage.org/webt/pr/d3/wf/prd3wfn6ctkod9ddqqmgtqnr1ew.gif"><br><br>  Ahora, cuando necesite, por ejemplo, fusionar los cambios de la versi√≥n a la maestra, podemos hacer una confirmaci√≥n de fusi√≥n real: tendr√° un identificador diferente, pero la misma firma.  Con el mismo identificador, tambi√©n desplegaremos la imagen en producci√≥n. <br><br>  La desventaja es que ahora no ser√° posible determinar qu√© tipo de compromiso se ha aplicado a la producci√≥n: las sumas de verificaci√≥n funcionan solo en una direcci√≥n.  Este problema se resuelve con una capa adicional con metadatos; m√°s adelante te contar√© m√°s. <br><br><h3>  Etiquetado en werf </h3><br>  En werf, hemos ido a√∫n m√°s lejos y nos estamos preparando para hacer un ensamblaje distribuido con un cach√© que no est√° almacenado en la misma m√°quina ... Entonces, tenemos dos tipos de im√°genes Docker, las llamamos <i>escenario</i> e <i>imagen</i> . <br><br>  El repositorio werf Git almacena instrucciones de compilaci√≥n espec√≠ficas que describen las diferentes etapas de la compilaci√≥n ( <i>beforeInstall</i> , <i>install</i> , <i>beforeSetup</i> , <i>setup</i> ).  Recopilamos la imagen de la primera etapa con una firma definida como la suma de comprobaci√≥n de los primeros pasos.  Luego agregamos el c√≥digo fuente, para la nueva imagen de escenario consideramos su suma de comprobaci√≥n ... Estas operaciones se repiten para todas las etapas, como resultado de lo cual obtenemos un conjunto de im√°genes de escenario.  Luego hacemos la imagen-imagen final que contiene tambi√©n metadatos sobre su origen.  Y etiquetamos esta imagen de diferentes maneras (detalles m√°s adelante). <br><br><img src="https://habrastorage.org/webt/4a/uw/am/4auwamdra7bm0xtvht35kpbstye.gif"><br><br>  Despu√©s de eso, aparece una nueva confirmaci√≥n, en la que solo se cambia el c√≥digo de la aplicaci√≥n.  Que va a pasar  Se crear√° un parche para cambios de c√≥digo, se preparar√° una nueva imagen de escenario.  Su firma se definir√° como la suma de comprobaci√≥n de la imagen del escenario anterior y el nuevo parche.  A partir de esta imagen se formar√° una nueva imagen-imagen final.  Se producir√° un comportamiento similar con los cambios en otras etapas. <br><br>  Por lo tanto, las im√°genes de escenario son un cach√© que se puede distribuir distribuido, y las im√°genes de im√°genes ya creadas a partir de √©l se cargan en el Registro Docker. <br><br><img src="https://habrastorage.org/webt/sc/8j/me/sc8jme4f1jfqbrbwt1anf2-rja8.gif"><br><br><h3>  Limpieza del registro </h3><br>  No se trata de eliminar capas que permanecen colgadas despu√©s de las etiquetas eliminadas; esta es una caracter√≠stica est√°ndar del propio Registro de Docker.  Esta es una situaci√≥n en la que se est√°n acumulando muchas etiquetas Docker y entendemos que ya no necesitamos algunas, y que ocupan espacio (y / o pagamos por ello). <br><br>  ¬øCu√°les son las estrategias de limpieza? <br><br><ol><li>  Simplemente <b>no</b> puedes <b>limpiar</b> nada.  A veces es realmente m√°s f√°cil pagar un poco por el espacio extra que desentra√±ar una gran bola de etiquetas.  Pero esto solo funciona hasta cierto punto. </li><li>  <b>Restablecimiento completo</b>  Si elimina todas las im√°genes y reconstruye solo las relevantes en el sistema CI, puede surgir un problema.  Si el contenedor se reinicia en producci√≥n, se cargar√° una nueva imagen, una que a√∫n no ha sido probada por nadie.  Esto mata la idea de infraestructura inmutable. </li><li>  <b>Azul verdoso</b>  Un registro comenz√≥ a desbordarse, cargando im√°genes en otro.  El mismo problema que en el m√©todo anterior: ¬øen qu√© punto puede limpiar el registro que comenz√≥ a desbordarse? </li><li>  <b>Por tiempo</b>  ¬øEliminar todas las im√°genes de m√°s de 1 mes?  Pero seguramente habr√° un servicio que no se haya actualizado durante un mes ... </li><li>  Determine <b>manualmente</b> lo que ya se puede eliminar. </li></ol><br>  Hay dos opciones realmente viables: no limpiar o una combinaci√≥n de azul-verde + manualmente.  En el √∫ltimo caso, estamos hablando de lo siguiente: cuando comprenda que es hora de limpiar el registro, cree uno nuevo y agregue todas las im√°genes nuevas durante, por ejemplo, un mes.  Un mes despu√©s, vea qu√© pods en Kubernetes todav√≠a usan el registro anterior y transfi√©ralos tambi√©n al nuevo registro. <br><br>  <b>¬ø</b> A <b>d√≥nde</b> fuimos a <b>werf</b> ?  Recopilamos: <br><br><ol><li>  Cabeza de Git: todas las etiquetas, todas las ramas, suponiendo que todo lo que se prueba en Git, necesitamos en las im√°genes (y si no, necesitamos eliminarlo en el propio Git); </li><li>  todos los pods que ahora se descargan en Kubernetes; </li><li>  ReplicaSets antiguos (algo que se extrajo recientemente), as√≠ como tambi√©n planeamos escanear lanzamientos de Helm y seleccionar las √∫ltimas im√°genes all√≠. </li></ol><br>  ... y hacemos una lista blanca de este conjunto, una lista de im√°genes que no eliminaremos.  Limpiamos todo lo dem√°s, despu√©s de lo cual encontramos las im√°genes de escenario hu√©rfanas y las eliminamos tambi√©n. <br><br><h2>  Etapa de implementaci√≥n (implementaci√≥n) </h2><br><h3>  Declaratividad robusta </h3><br>  El primer punto al que me gustar√≠a llamar la atenci√≥n en la implementaci√≥n es implementar la configuraci√≥n de recursos actualizada, declarada declarativamente.  El documento original de YAML que describe los recursos de Kubernetes siempre es muy diferente del resultado que realmente funciona en el cl√∫ster.  Porque Kubernetes agrega a la configuraci√≥n: <br><br><ol><li>  identificadores </li><li>  informaci√≥n de servicio; </li><li>  muchos valores por defecto; </li><li>  secci√≥n con estado actual; </li><li>  cambios realizados como parte del webhook de admisi√≥n; </li><li>  El resultado del trabajo de varios controladores (y planificador). </li></ol><br>  Por lo tanto, cuando aparece una nueva configuraci√≥n de un recurso ( <i>nuevo</i> ), no podemos simplemente tomar y sobrescribir la configuraci√≥n actual "en vivo" (en <i>vivo</i> ).  Para hacer esto, tenemos que comparar <i>nuevo</i> con la √∫ltima configuraci√≥n aplicada ( <i>√∫ltima aplicaci√≥n</i> ) y poner el parche resultante en <i>vivo</i> . <br><br>  Este enfoque se llama <b>fusi√≥n bidireccional</b> .  Se usa, por ejemplo, en Helm. <br><br>  Tambi√©n hay una <b>fusi√≥n de 3 v√≠as</b> , que difiere en que: <br><br><ul><li>  comparando el <i>√∫ltimo aplicado</i> y el <i>nuevo</i> , observamos lo que se ha eliminado; </li><li>  Al comparar lo <i>nuevo</i> y lo <i>vivo</i> , vemos lo que se ha agregado o cambiado; </li><li>  aplique el parche resumido para <i>vivir</i> . </li></ul><br>  Implementamos m√°s de 1000 aplicaciones con Helm, por lo que en realidad vivimos con una fusi√≥n bidireccional.  Sin embargo, tiene una serie de problemas que resolvimos con nuestros parches que ayudan a Helm a funcionar normalmente. <br><br><h3>  Estado de despliegue real </h3><br>  Despu√©s del pr√≥ximo evento, nuestro sistema CI gener√≥ una nueva configuraci√≥n para Kubernetes, la env√≠a para <i>aplicar</i> al cl√∫ster usando Helm o <code>kubectl apply</code> .  A continuaci√≥n, tiene lugar la fusi√≥n N-way ya descrita, a lo que la API de Kubernetes aprueba el sistema CI y este √∫ltimo responde a su usuario. <br><br><img src="https://habrastorage.org/webt/sk/vh/-u/skvh-uifcwg6_d5mgxhehh39q9i.png"><br><br>  Sin embargo, hay un gran problema: despu√©s de todo, una <b>aplicaci√≥n exitosa no significa una implementaci√≥n exitosa</b> .  Si Kubernetes entiende qu√© cambios aplicar, lo aplica, a√∫n no sabemos cu√°l ser√° el resultado.  Por ejemplo, actualizar y reiniciar pods en la interfaz puede ser exitoso, pero no en el backend, y obtendremos diferentes versiones de las im√°genes de la aplicaci√≥n en ejecuci√≥n. <br><br>  Para hacer todo bien, surge un enlace adicional en este esquema: un rastreador especial que recibir√° informaci√≥n de estado de la API de Kubernetes y la transmitir√° para un an√°lisis m√°s detallado del estado real de las cosas.  Creamos una biblioteca de c√≥digo abierto en Go, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>kubedog</b></a> <i>(vea su anuncio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> )</i> , que resuelve este problema y est√° integrado en werf. <br><br>  El comportamiento de este rastreador en el nivel werf se configura mediante anotaciones que se colocan en implementaciones o StatefulSets.  La anotaci√≥n principal, <code>fail-mode</code> , comprende los siguientes significados: <br><br><ul><li>  <code>IgnoreAndContinueDeployProcess</code> : ignore los problemas de <code>IgnoreAndContinueDeployProcess</code> de este componente y contin√∫e con la implementaci√≥n; </li><li>  <code>FailWholeDeployProcessImmediately</code> : un error en este componente detiene el proceso de implementaci√≥n; </li><li>  <code>HopeUntilEndOfDeployProcess</code> : esperamos que este componente funcione al final de la implementaci√≥n. </li></ul><br>  Por ejemplo, una combinaci√≥n de recursos y valores de anotaci√≥n en <code>fail-mode</code> : <br><br><img src="https://habrastorage.org/webt/ja/qf/ot/jaqfotxaxoxwznieu2lvnnyhih0.png"><br><br>  Cuando se implementa por primera vez, es posible que la base de datos (MongoDB) a√∫n no est√© lista: las implementaciones se bloquear√°n.  Pero puede esperar hasta el momento en que comience, y la implementaci√≥n a√∫n pasar√°. <br><br>  Hay dos anotaciones m√°s para kubedog en werf: <br><br><ul><li>  <code>failures-allowed-per-replica</code> - el n√∫mero de ca√≠das permitidas por r√©plica; </li><li>  <code>show-logs-until</code> : ajusta el momento hasta el cual werf muestra registros (en stdout) de todas las vainas que se est√°n desplegando.  De forma predeterminada, esto es <code>PodIsReady</code> (para ignorar los mensajes que apenas necesitamos cuando el tr√°fico comienza a llegar al pod), sin embargo, los valores <code>ControllerIsReady</code> y <code>EndOfDeploy</code> tambi√©n <code>EndOfDeploy</code> . </li></ul><br><h3>  ¬øQu√© m√°s queremos del despliegue? </h3><br>  Adem√°s de los dos puntos ya descritos, nos gustar√≠a: <br><br><ul><li>  ver <b>registros</b> , y solo es necesario, pero no todo; </li><li>  realizar <b>un</b> seguimiento del <b>progreso</b> , porque si un trabajo "en silencio" se cuelga durante varios minutos, es importante comprender lo que est√° sucediendo all√≠; </li><li>  tener una <b>reversi√≥n autom√°tica</b> en caso de que algo salga mal (y, por lo tanto, es fundamental conocer el estado real de la implementaci√≥n).  El despliegue debe ser at√≥mico: o llega al final o todo vuelve a su estado anterior. </li></ul><br><h2>  Resumen </h2><br>  Como empresa, para nosotros, para implementar todos los matices descritos en las diferentes etapas de entrega (compilaci√≥n, publicaci√≥n, implementaci√≥n), el sistema CI y la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suficientes</a> . <br><br>  En lugar de una conclusi√≥n: <br><br><img src="https://habrastorage.org/webt/ja/1y/tc/ja1ytcqobpkbw5rtf78ykb4clnm.png"><br><br>  Con la ayuda de werf, hemos hecho un buen progreso en la resoluci√≥n de una gran cantidad de problemas de los ingenieros de DevOps y nos alegrar√° si la comunidad en general al menos prueba esta utilidad en la pr√°ctica.  Lograr un buen resultado juntos ser√° m√°s f√°cil. <br><br><h2>  Videos y diapositivas </h2><br>  Video de la actuaci√≥n (~ 47 minutos): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cK3ackGUTLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Presentaci√≥n del informe: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Otros informes de Kubernetes en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autoescalado y gesti√≥n de recursos en Kubernetes</a> " <i>(Dmitry Stolyarov; 27 de abril de 2019 en la "Huelga")</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Expandiendo y complementando a Kubernetes</a> " <i>(Andrey Polov; 8 de abril de 2019 en Saint HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bases de datos y Kubernetes</a> " <i>(Dmitry Stolyarov; 8 de noviembre de 2018 en HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitoreo y Kubernetes</a> " <i>(Dmitry Stolyarov; 28 de mayo de 2018 en RootConf)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejores pr√°cticas de CI / CD con Kubernetes y GitLab</a> " <i>(Dmitry Stolyarov; 7 de noviembre de 2017 en HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en peque√±os proyectos</a> " <i>(Dmitry Stolyarov; 6 de junio de 2017 en RootConf)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460351/">https://habr.com/ru/post/460351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460341/index.html">ASO continuo: tendencias, calificaciones y un poco de retroalimentaci√≥n</a></li>
<li><a href="../460343/index.html">La historia de c√≥mo el desarrollo del juego se ha convertido en parte de mi vida.</a></li>
<li><a href="../460345/index.html">Instalar y configurar Sonata Admin en Symfony 4</a></li>
<li><a href="../460347/index.html">Administraci√≥n de dispositivos m√≥viles y m√°s con la soluci√≥n UEM de Sophos</a></li>
<li><a href="../460349/index.html">Tarjetas Check Point Falcon Acceleration - Acelerando el procesamiento del tr√°fico</a></li>
<li><a href="../460353/index.html">Red neuronal en el cristal. No requiere energ√≠a, reconoce n√∫meros</a></li>
<li><a href="../460355/index.html">Salvar al ahogamiento es nuestro negocio: c√≥mo lidiar con la desmotivaci√≥n del equipo</a></li>
<li><a href="../460359/index.html">Curso para j√≥venes dise√±adores de juegos 2: Equilibrio de progresi√≥n y din√°mica sin matem√°ticas</a></li>
<li><a href="../460361/index.html">Grandes preguntas frecuentes sobre ciberseguridad de los sistemas de informaci√≥n m√©dica</a></li>
<li><a href="../460363/index.html">7 factores faltantes en el enfoque 12 Factor App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>