<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåÔ∏è ‚ôçÔ∏è üõ¢Ô∏è El isomorfismo se apresura al rescate üíÖ ü§≥üèæ üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El "isomorfismo" es uno de los conceptos b√°sicos de las matem√°ticas modernas. Usando ejemplos concretos en Haskell y C #, no solo explicar√© la teor√≠a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El isomorfismo se apresura al rescate</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436756/"><p> El "isomorfismo" es uno de los conceptos b√°sicos de las matem√°ticas modernas.  Usando ejemplos concretos en Haskell y C #, no solo explicar√© la teor√≠a para los no matem√°ticos (sin usar ning√∫n s√≠mbolo y t√©rmino matem√°tico oscuro), sino que tambi√©n mostrar√© c√≥mo se puede usar esto en la pr√°ctica diaria. </p><a name="habracut"></a><br><p>  El problema es que la igualdad estricta (por ejemplo, 2 + 2 = 4) suele ser demasiado estricta.  Aqu√≠ hay un ejemplo: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add</span></span> :: (a, a) -&gt; a add (x, y) = x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">pair</span></span>) { return pair.Item1 + pair.Item2; }</code> </pre> </div></div><br><p>  Sin embargo, hay una forma m√°s, m√°s complicada y en muchas situaciones mucho m√°s pr√°ctica, de definir la misma funci√≥n <b>en cierto sentido</b> : </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add'</span></span> :: a -&gt; a -&gt; a add' x = \y -&gt; x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>) { return y =&gt; x + y; }</code> </pre> </div></div><br><p>  Contrariamente al hecho obvio de que para dos <i>x, y</i> ambas funciones siempre devolver√°n el mismo resultado, no satisfacen la igualdad estricta: </p><br><ul><li>  la primera funci√≥n devuelve inmediatamente la cantidad (es decir, realiza el c√°lculo en el momento de la exportaci√≥n), </li><li>  mientras que la segunda funci√≥n devuelve otra funci√≥n (que al final devolver√° la suma; si alguien la llama, por supuesto, de lo contrario no se realizar√° ning√∫n c√°lculo: este es un ejemplo de c√°lculo retrasado y tambi√©n hay un isomorfismo aqu√≠, al que volver√©) un poco mas tarde). </li></ul><br><p>  Y esto es "ser demasiado estricto". </p><br><p>  El isomorfismo es "bastante estricto";  no requiere una igualdad completa que lo abarque todo, sino que se limita a la igualdad "en cierto sentido", que siempre est√° determinada por un contexto espec√≠fico. </p><br><p>  Como puede suponer, las dos definiciones anteriores son isomorfas.  Esto significa exactamente lo siguiente: si solo me dan uno de ellos, entonces ambos me lo dan <em>impl√≠citamente</em> : todo gracias al <b>isomorfismo, un convertidor bidireccional de uno a otro</b> .  Resumiendo un poco los tipos: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> :: ((a, b) ‚Üí c) ‚Üí a ‚Üí b ‚Üí c curry fxy = f (x, y), uncurry :: (a ‚Üí b ‚Üí c) ‚Üí (a, b) ‚Üí c uncurry f (x, y) = fxy</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uncurried</span></span>) { return arg1 =&gt; arg2 =&gt; uncurried(Tuple.Create(arg1, arg2)); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">curried</span></span>) { return pair =&gt; curried(pair.Item1)(pair.Item2); }</code> </pre> </div></div><br><p>  ... y ahora para cualquier <em>x, y</em> : </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> add $ x, y = uncurry add' $ (x, y)</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>))</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Un poco m√°s de matem√°tica para los especialmente curiosos</b> <div class="spoiler_text"><p>  De hecho, deber√≠a verse as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> . uncurry = id uncurry . curry = id id x = x</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, : <span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span>&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); } ...  <span class="hljs-selector-tag"><span class="hljs-selector-tag">extension-</span></span> (  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>   ): <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, : <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); }</code> </pre> </div></div><br><p>  Id deber√≠a entenderse como "no pas√≥ nada".  Dado que el isomorfismo es un transformador de dos v√≠as por definici√≥n, siempre puedes 1) tomar una cosa, 2) convertirla en otra y 3) volver a convertirla en la primera.  Solo hay dos operaciones de este tipo: porque en la primera etapa (N ¬∞ 1), la elecci√≥n es de solo dos opciones.  Y en ambos casos, la operaci√≥n deber√≠a conducir a exactamente el mismo resultado, como si nada hubiera sucedido (es por esta raz√≥n que est√° involucrada la igualdad estricta, porque nada ha cambiado <strong>en</strong> absoluto, y no "algo" no ha cambiado). </p><br><p>  Adem√°s de esto, existe un teorema de que el elemento id siempre es √∫nico.  Tenga en cuenta que la funci√≥n Id es gen√©rica, polim√≥rfica y, por lo tanto, verdaderamente √∫nica con respecto a cada tipo en particular. </p></div></div><br><p>  El isomorfismo es muy, muy √∫til precisamente porque es estricto, pero no demasiado.  Conserva ciertas propiedades importantes (en el ejemplo anterior, el mismo resultado con los mismos argumentos), al tiempo que le permite transformar libremente las estructuras de datos (portadores de comportamiento y propiedades isom√≥rficas).  Y esto es absolutamente seguro, porque el isomorfismo siempre funciona en ambas direcciones, lo que significa que siempre puede regresar sin perder esas "propiedades importantes".  Dar√© otro ejemplo que es tan √∫til en la pr√°ctica que incluso apuntala muchos lenguajes de programaci√≥n "avanzados" como el de Haskell: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">toLazy</span></span> :: a -&gt; () -&gt; a toLazy x = \_ -&gt; a fromLazy :: (() -&gt; a) -&gt; a fromLazy f = f ()</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">res</span></span>) { return () =&gt; res; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">lazy</span></span>) { return lazy(); }</code> </pre> </div></div><br><p>  Este isomorfismo conserva el resultado del c√°lculo diferido en s√≠ mismo: esta es la "propiedad importante", mientras que las estructuras de datos son diferentes. </p><br><p>  La conclusi√≥n?  OOP, especialmente fuertemente tipado, (forzado) funciona al nivel de "igualdad estricta".  Y por lo tanto, a ra√≠z de los ejemplos anteriores, a menudo es demasiado estricto.  Cuando te acostumbras a pensar "demasiado estrictamente" (y esto sucede imperceptiblemente: se filtra en el programador, especialmente si no est√° buscando inspiraci√≥n en matem√°ticas), tus decisiones pierden involuntariamente la flexibilidad deseada (o al menos objetivamente posible).  Comprender el isomorfismo: en una comunidad con un intento consciente de estar m√°s atento al propio <br>  y c√≥digo extranjero: ayuda a definir m√°s claramente el c√≠rculo de "propiedades importantes", abstrayendo de detalles innecesarios: a saber, de estructuras de datos espec√≠ficas en las que se imprimen estas "propiedades importantes" (tambi√©n son "detalles de implementaci√≥n").  En primer lugar, esta es una forma de pensar, y solo entonces: soluciones (micro) arquitect√≥nicas m√°s exitosas y, como consecuencia natural, un enfoque revisado para las pruebas. </p><br><p>  PD: Si veo que el art√≠culo se ha beneficiado, volver√© a los temas de "soluciones (micro) arquitect√≥nicas m√°s exitosas" y "un enfoque revisado para las pruebas". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436756/">https://habr.com/ru/post/es436756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436746/index.html">C√≥mo degradar el rendimiento al mejorarlo</a></li>
<li><a href="../es436748/index.html">Desarrollar hexapod desde cero (parte 3) - cinem√°tica</a></li>
<li><a href="../es436750/index.html">An√°lisis de tendencias de YouTube ruso para 2018</a></li>
<li><a href="../es436752/index.html">El pastel es una mentira</a></li>
<li><a href="../es436754/index.html">Q2VKPT: Quake II completamente reescrito con iluminaci√≥n realista</a></li>
<li><a href="../es436762/index.html">Couchbase en Telecom</a></li>
<li><a href="../es436764/index.html">Creando tu jsfiddle, parte 1</a></li>
<li><a href="../es436768/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 282 (del 14 al 20 de enero)</a></li>
<li><a href="../es436770/index.html">Los operadores m√≥viles rusos ganan en las nubes</a></li>
<li><a href="../es436772/index.html">Ley "sobre comunicaciones" y vulnerabilidad en mensajeros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>