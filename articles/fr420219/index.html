<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ§› ğŸ‘¨â€ğŸ‘§ PrÃ©sentation des techniques de mise en Å“uvre de Game AI ğŸ•µğŸ» ğŸ§’ğŸ¼ ğŸ‘¨ğŸ»â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PrÃ©sentation 
 Cet article vous prÃ©sentera un large Ã©ventail de concepts d'intelligence artificielle dans les jeux (Â«gaming AIÂ»), afin que vous compre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PrÃ©sentation des techniques de mise en Å“uvre de Game AI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420219/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png" alt="image"></div><br><h1>  PrÃ©sentation </h1><br>  Cet article vous prÃ©sentera un large Ã©ventail de concepts d'intelligence artificielle dans les jeux (Â«gaming AIÂ»), afin que vous compreniez quels outils peuvent Ãªtre utilisÃ©s pour rÃ©soudre les problÃ¨mes d'IA, comment ils fonctionnent ensemble et comment commencer Ã  les implÃ©menter dans le moteur sÃ©lectionnÃ©. <br><br>  Je suppose que vous Ãªtes familier avec les jeux vidÃ©o, un peu familiarisÃ© avec des concepts mathÃ©matiques tels que la gÃ©omÃ©trie, la trigonomÃ©trie, etc.  La plupart des exemples de code seront Ã©crits en pseudo-code, vous n'avez donc pas besoin de connaÃ®tre une langue spÃ©cifique. <br><br><h1>  Qu'est-ce <i>qu'une</i> "IA de jeu"? </h1><br>  Le jeu AI traite principalement de la sÃ©lection des actions d'une entitÃ© en fonction des conditions actuelles.  Dans la littÃ©rature traditionnelle sur l'IA, on parle de gestion des Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">agents intelligents</a> Â».  L'agent est gÃ©nÃ©ralement un personnage du jeu, mais il peut s'agir d'une machine, d'un robot ou mÃªme de quelque chose de plus abstrait - un groupe entier d'entitÃ©s, un pays ou une civilisation.  Dans tous les cas, c'est un objet qui surveille son environnement, prend des dÃ©cisions en fonction de lui et agit conformÃ©ment Ã  ces dÃ©cisions.  C'est ce qu'on appelle parfois le cycle perception-pensÃ©e-action (Sens / Penser / Agir): <br><br><ul><li>  Perception: l'agent reconnaÃ®t - ou en est informÃ© - des informations sur l'environnement qui peuvent affecter son comportement (par exemple, les dangers Ã  proximitÃ©, les objets collectÃ©s, les points importants, etc.) </li><li>  RÃ©flexion: l'agent dÃ©cide comment rÃ©agir (par exemple, dÃ©cide s'il est sÃ»r de collecter des objets, s'il doit se battre ou mieux se cacher en premier) </li><li>  Action: l'agent effectue des actions pour mettre en Å“uvre ses dÃ©cisions (par exemple, commence Ã  se dÃ©placer le long de la route vers l'ennemi ou vers le sujet, etc.) </li><li>  ... puis, en raison des actions des personnages, la situation change, donc le cycle doit Ãªtre rÃ©pÃ©tÃ© avec de nouvelles donnÃ©es. </li></ul><a name="habracut"></a><br>  Les tÃ¢ches de l'IA dans le monde rÃ©el, en particulier celles qui sont pertinentes aujourd'hui, se concentrent gÃ©nÃ©ralement sur la Â«perceptionÂ».  Par exemple, les vÃ©hicules sans pilote devraient recevoir des images de la route devant eux, en les combinant avec d'autres donnÃ©es (radar et lidar) et en essayant d'interprÃ©ter ce qu'ils voient.  Habituellement, cette tÃ¢che est rÃ©solue par l'apprentissage automatique, qui fonctionne particuliÃ¨rement bien avec de grands tableaux de donnÃ©es bruyantes du monde rÃ©el (par exemple, avec des photos de la route devant la voiture ou quelques images de vidÃ©o) et leur donne un sens, en extrayant des informations sÃ©mantiques, par exemple, Â«il y a 20 mÃ¨tres devant moi une autre voiture. "  Ces tÃ¢ches sont appelÃ©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">problÃ¨mes de classification</a> . <br><br>  Les jeux sont inhabituels dans la mesure oÃ¹ ils n'ont pas besoin d'un systÃ¨me complexe pour extraire ces informations, car ils font partie intÃ©grante de la simulation.  Il n'est pas nÃ©cessaire d'exÃ©cuter des algorithmes de reconnaissance d'image pour dÃ©tecter l'ennemi devant vous;  le jeu <i>sait</i> qu'il y a un ennemi et peut transmettre ces informations directement au processus dÃ©cisionnel.  Par consÃ©quent, la Â«perceptionÂ» dans ce cycle est gÃ©nÃ©ralement grandement simplifiÃ©e, et toute la complexitÃ© se pose dans la mise en Å“uvre de la Â«pensÃ©eÂ» et de Â«l'actionÂ». <br><br><h1>  Limitations du dÃ©veloppement de l'IA de jeu </h1><br>  L'IA de jeu prend gÃ©nÃ©ralement en compte les restrictions suivantes: <br><br><ul><li>  Contrairement Ã  l'algorithme d'apprentissage automatique, il ne s'entraÃ®ne gÃ©nÃ©ralement pas Ã  l'avance;  lors du dÃ©veloppement d'un jeu, il n'est pas pratique d'Ã©crire un rÃ©seau de neurones pour surveiller des dizaines de milliers de joueurs afin de trouver la meilleure faÃ§on de jouer contre eux, car le jeu n'est pas encore sorti et il n'a pas de joueurs! </li><li>  On suppose gÃ©nÃ©ralement que le jeu doit divertir et dÃ©fier le joueur, et ne pas Ãªtre Â«optimalÂ» - par consÃ©quent, mÃªme si vous pouvez former des agents Ã  rÃ©sister aux joueurs de la meilleure faÃ§on, les concepteurs ont le plus souvent besoin de quelque chose de diffÃ©rent d'eux. </li><li>  Souvent, les agents doivent avoir un comportement Â«rÃ©alisteÂ» pour que les joueurs sentent qu'ils rivalisent avec des adversaires de type humain.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le programme AlphaGo</a> s'est avÃ©rÃ© bien meilleur que les gens, mais les mouvements qu'il choisit sont si loin de la comprÃ©hension traditionnelle du jeu que les adversaires expÃ©rimentÃ©s en parlaient comme d'un match contre un Ã©tranger.  Si le jeu prÃ©tend Ãªtre un adversaire humain, cela n'est gÃ©nÃ©ralement pas souhaitable, donc l'algorithme doit Ãªtre configurÃ© de sorte qu'il prenne <i>des</i> dÃ©cisions <i>plausibles</i> , pas <i>idÃ©ales</i> . </li><li>  L'IA doit Ãªtre exÃ©cutÃ©e en temps rÃ©el.  Dans ce contexte, cela signifie que l'algorithme ne peut pas, pour une dÃ©cision, monopoliser les ressources du processeur pendant longtemps.  MÃªme 10 millisecondes pour prendre une dÃ©cision, c'est trop, car la plupart des jeux ne disposent que de 16 Ã  33 millisecondes pour terminer toutes les opÃ©rations pour la prochaine image du graphique. </li><li>  IdÃ©alement, au moins une partie du systÃ¨me devrait dÃ©pendre des donnÃ©es et ne pas Ãªtre codÃ©e en dur afin que les non-programmeurs puissent apporter des modifications plus rapidement. </li></ul><br>  AprÃ¨s avoir appris tout cela, nous pouvons commencer Ã  envisager des approches extrÃªmement simples de la crÃ©ation de l'IA, qui mettent en Å“uvre le cycle complet de la "perception-pensÃ©e-action" de maniÃ¨re Ã  garantir l'efficacitÃ© et Ã  permettre aux concepteurs de jeux de choisir des comportements complexes similaires aux actions humaines. <br><br><h1>  Prise de dÃ©cision facile </h1><br>  CommenÃ§ons par un jeu trÃ¨s simple, comme Pong.  La tÃ¢che du joueur est de dÃ©placer la "raquette" de maniÃ¨re Ã  ce que la balle rebondisse dessus, plutÃ´t que de passer devant.  Les rÃ¨gles sont similaires au tennis - vous perdez si vous manquez la balle.  L'IA a une tÃ¢che relativement simple de prendre des dÃ©cisions sur le choix du sens de dÃ©placement de la raquette. <br><br><h2>  Constructions conditionnelles codÃ©es en dur </h2><br>  Si nous voulions Ã©crire de l'IA pour contrÃ´ler la raquette, il existe une solution intuitive et simple - il suffit de dÃ©placer constamment la raquette pour qu'elle soit sous la balle.  Lorsque la balle atteint la raquette, elle est dÃ©jÃ  en position parfaite et peut la frapper. <br><br>  Un algorithme simple pour cela, exprimÃ© en pseudo-code, pourrait Ãªtre: <br><br><pre>  dans chaque image / mise Ã  jour pendant le jeu:<font></font>
<font></font>
 si le ballon est Ã  gauche de la raquette:<font></font>
<font></font>
	 dÃ©placer la raquette vers la gauche<font></font>
<font></font>
 sinon si le ballon est Ã  droite de la raquette:<font></font>
<font></font>
	 dÃ©placer la raquette vers la droite </pre><br>  Si nous supposons que la raquette peut se dÃ©placer Ã  une vitesse non infÃ©rieure Ã  celle de la balle, alors ce sera l'algorithme parfait pour le joueur IA Ã  Pong.  Dans les cas oÃ¹ il n'y a pas tellement de donnÃ©es de Â«perceptionÂ» Ã  traiter et peu d'actions que l'agent peut effectuer, nous n'avons besoin de rien de plus compliquÃ©. <br><br>  Cette approche est si simple qu'elle montre Ã  peine tout le cycle de la Â«perception-pensÃ©e-actionÂ».  Mais il l' <i>est</i> . <br><br><ul><li>  Les perceptions sont deux dÃ©clarations if.  Le jeu sait oÃ¹ sont la balle et la raquette.  Par consÃ©quent, l'IA demande au jeu sa position, Â«sentantÂ» ainsi si le ballon est Ã  gauche ou Ã  droite. </li><li>  La rÃ©flexion est Ã©galement intÃ©grÃ©e Ã  deux instructions if.  Ils contiennent deux solutions, qui dans ce cas s'excluent mutuellement, conduisant au choix de l'une des trois actions - dÃ©placer la raquette vers la gauche, la dÃ©placer vers la droite ou ne rien faire si la raquette est dÃ©jÃ  correctement positionnÃ©e. </li><li>  Une Â«actionÂ» consiste Ã  Â«dÃ©placer la raquette vers la gaucheÂ» ou Â«Ã  dÃ©placer la raquette vers la droiteÂ».  Selon la faÃ§on dont le jeu est implÃ©mentÃ©, cela peut prendre la forme d'un dÃ©placement instantanÃ© de la position de la raquette ou du rÃ©glage de la vitesse et de la direction de la raquette afin qu'elle puisse Ãªtre dÃ©placÃ©e correctement dans un autre code de jeu. </li></ul><br>  De telles approches sont souvent appelÃ©es Â«rÃ©activesÂ» car il existe un simple ensemble de rÃ¨gles (dans notre cas, ce sont des instructions Â«siÂ» dans le code) qui rÃ©pondent Ã  l'Ã©tat du monde et dÃ©cident instantanÃ©ment de la marche Ã  suivre. <br><br><h2>  Arbres de dÃ©cision </h2><br>  Cet exemple Pong est en fait similaire au concept formel de l'IA appelÃ© l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre de dÃ©cision</a> .  Il s'agit d'un systÃ¨me dans lequel les dÃ©cisions sont organisÃ©es sous la forme d'un arbre et l'algorithme doit le contourner pour atteindre une Â«feuilleÂ» contenant la dÃ©cision finale sur l'action choisie.  Tirons une reprÃ©sentation graphique de l'arbre de dÃ©cision pour l'algorithme de raquette Pong Ã  l'aide d'un organigramme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/4a2/17e/34e4a217e703a6af9b51b5cfbec7370f.png"></div><br>  On peut voir qu'il ressemble Ã  un arbre, seulement renversÃ©! <br><br>  Chaque partie de l'arbre de dÃ©cision est gÃ©nÃ©ralement appelÃ©e "nÅ“ud" car en IA, la thÃ©orie des graphes est utilisÃ©e pour dÃ©crire de telles structures.  Chaque nÅ“ud peut Ãªtre de deux types: <br><br><ol><li>  NÅ“uds de solutions: le choix de deux alternatives basÃ©es sur la vÃ©rification d'une condition.  Chaque alternative est prÃ©sentÃ©e comme son propre nÅ“ud; </li><li>  Noeuds finaux: action effectuÃ©e qui reprÃ©sente la dÃ©cision finale prise par l'arbre. </li></ol><br>  L'algorithme dÃ©marre Ã  partir du premier nÅ“ud attribuÃ© par la Â«racineÂ» de l'arbre, aprÃ¨s quoi il dÃ©cide Ã  quel nÅ“ud enfant aller en fonction de la condition, ou effectue l'action stockÃ©e dans le nÅ“ud, puis arrÃªte de fonctionner. <br><br>  Ã€ premiÃ¨re vue, l'avantage de l'arbre de dÃ©cision n'est pas Ã©vident, car il fait exactement le mÃªme travail que les instructions if de la section prÃ©cÃ©dente.  Mais il existe un systÃ¨me trÃ¨s gÃ©nÃ©ral dans lequel chaque solution a exactement 1 condition et 2 rÃ©sultats possibles, ce qui permet au dÃ©veloppeur de construire une IA Ã  partir des donnÃ©es reprÃ©sentant les solutions dans l'arborescence, et en Ã©vitant de l'Ã©crire en dur dans le code.  Il est facile d'imaginer un format de donnÃ©es simple pour dÃ©crire un tel arbre: <br><br><table><tbody><tr><td>  <b>NumÃ©ro de nÅ“ud</b> </td><td>  <b>DÃ©cision (ou "fin")</b> </td><td>  <b>Action</b> </td><td>  <b>Action</b> </td></tr><tr><td>  1 </td><td>  La balle Ã  gauche de la raquette? </td><td>  Hein?  VÃ©rifier le nÅ“ud 2 </td><td>  Non?  VÃ©rifier le noeud 3 </td></tr><tr><td>  2 </td><td>  <i>La fin</i> </td><td colspan="2">  DÃ©placer la raquette vers la gauche </td></tr><tr><td>  3 </td><td>  La balle Ã  droite de la raquette? </td><td>  Hein?  Aller au nÅ“ud 4 </td><td>  Non?  Aller au nÅ“ud 5 </td></tr><tr><td>  4 </td><td>  <i>La fin</i> </td><td colspan="2">  DÃ©placer la raquette vers la droite </td></tr><tr><td>  5 </td><td>  <i>La fin</i> </td><td colspan="2">  Ne fais rien </td></tr></tbody></table><br>  Du point de vue du code, nous devons forcer le systÃ¨me Ã  lire chacune de ces lignes, crÃ©er pour chaque nÅ“ud, attacher la logique de dÃ©cision basÃ©e sur la deuxiÃ¨me colonne et attacher des nÅ“uds enfants basÃ©s sur les troisiÃ¨me et quatriÃ¨me colonnes.  Nous devons toujours dÃ©finir manuellement les conditions et les actions, mais nous pouvons maintenant imaginer un jeu plus complexe dans lequel vous pouvez ajouter de nouvelles solutions et actions, ainsi que configurer l'intÃ©gralitÃ© de l'IA en modifiant le seul fichier texte qui contient la dÃ©finition de l'arborescence.  Nous pouvons transfÃ©rer le fichier au concepteur de jeu, qui pourra personnaliser le comportement sans avoir besoin de recompiler le jeu et de changer le code - Ã  condition que le code ait dÃ©jÃ  des conditions et des actions utiles. <br><br>  Les arbres de dÃ©cision peuvent Ãªtre trÃ¨s puissants lorsqu'ils sont construits automatiquement sur la base d'un grand nombre d'exemples (par exemple, en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme ID3</a> ).  Cela en fait un outil efficace et performant pour classer la situation sur la base des donnÃ©es entrantes, mais ce sujet dÃ©passe le cadre des concepteurs crÃ©ant des systÃ¨mes simples pour sÃ©lectionner des actions pour les agents. <br><br><h2>  Scripting </h2><br>  Ci-dessus, nous avons examinÃ© un systÃ¨me d'arbre de dÃ©cision qui utilise des conditions et des actions prÃ©-crÃ©Ã©es.  Le dÃ©veloppeur d'IA peut reconstruire l'arborescence de la maniÃ¨re dont il a besoin, mais il doit s'appuyer sur le fait que le programmeur a dÃ©jÃ  crÃ©Ã© toutes les conditions et actions nÃ©cessaires pour lui.  Mais que se passe-t-il si nous donnons au designer des outils plus puissants qui lui permettent de crÃ©er ses propres conditions, et peut-Ãªtre ses actions? <br><br>  Par exemple, au lieu de forcer l'encodeur Ã  Ã©crire les conditions Â«Balle Ã  gauche de la raquette?Â»  et "La balle Ã  droite de la raquette?", il peut simplement crÃ©er un systÃ¨me dans lequel le concepteur Ã©crit de maniÃ¨re indÃ©pendante les conditions de contrÃ´le de ces valeurs.  Par consÃ©quent, les donnÃ©es de l'arbre de dÃ©cision peuvent ressembler Ã  ceci: <br><br><table><tbody><tr><td>  <b>NumÃ©ro de nÅ“ud</b> </td><td>  <b>DÃ©cision (ou "fin")</b> </td><td>  <b>Solution</b> </td><td>  <b>Action</b> </td></tr><tr><td>  1 </td><td>  <b>ball.position.x &lt;paddle.position.x</b> </td><td>  Hein?  VÃ©rifier le nÅ“ud 2 </td><td>  Non?  VÃ©rifier le noeud 3 </td></tr><tr><td>  2 </td><td>  <i>La fin</i> </td><td colspan="2">  DÃ©placer la raquette vers la gauche </td></tr><tr><td>  3 </td><td>  <b>ball.position.x&gt; paddle.position.x</b> </td><td>  Hein?  VÃ©rifier le noeud 4 </td><td>  Non?  VÃ©rifier le nÅ“ud 5 </td></tr><tr><td>  4 </td><td>  <i>La fin</i> </td><td colspan="2">  DÃ©placer la raquette vers la droite </td></tr><tr><td>  5 </td><td>  <i>La fin</i> </td><td colspan="2">  Ne fais rien </td></tr></tbody></table><br>  Comme avant, mais maintenant les solutions ont leur propre code, similaire Ã  la partie conditionnelle de l'instruction if.  Le code lira les nÅ“uds de dÃ©cision de la deuxiÃ¨me colonne et au lieu de rechercher une condition spÃ©cifique (par exemple, "la balle Ã  gauche de la raquette?"), Calculera l'expression conditionnelle et renverra vrai ou faux.  Cela peut Ãªtre implÃ©mentÃ© en incorporant un <i>langage de script</i> , tel que Lua ou Angelscript, qui permet au dÃ©veloppeur de prendre des objets du jeu (par exemple, une balle et une raquette) et de crÃ©er des variables accessibles Ã  partir du script (par exemple ball.position).  Il est gÃ©nÃ©ralement plus facile d'Ã©crire dans un langage de script qu'en C ++, et il ne nÃ©cessite pas une Ã©tape de compilation complÃ¨te, il est donc bien adaptÃ© pour apporter des changements rapides Ã  la logique du jeu et permet aux membres de l'Ã©quipe moins techniquement avertis de crÃ©er des fonctions de jeu sans l'intervention d'un encodeur. <br><br>  Dans l'exemple ci-dessus, le langage de script est utilisÃ© uniquement pour Ã©valuer l'expression conditionnelle, mais les actions finales peuvent Ã©galement Ãªtre dÃ©crites dans le script.  Par exemple, ces actions du type Â«dÃ©placer la raquette vers la droiteÂ» peuvent devenir une construction de script comme <code>ball.position.x += 10</code> , c'est-Ã -dire que l'action est Ã©galement dÃ©finie dans le script sans Ã©crire le code de fonction MovePaddleRight. <br><br>  Si vous faites un autre pas en avant, vous pouvez (et cela est souvent fait) aller Ã  sa conclusion logique et Ã©crire tout l'arbre de dÃ©cision dans un langage de script, et non comme une liste de lignes de donnÃ©es.  Ce sera un code similaire aux constructions conditionnelles prÃ©sentÃ©es ci-dessus, mais elles ne sont pas Â«codÃ©es en durÂ» - elles se trouvent dans des fichiers de script externes, c'est-Ã -dire qu'elles peuvent Ãªtre modifiÃ©es sans recompiler tout le programme.  Il est souvent mÃªme possible de modifier le fichier de script pendant l'exÃ©cution du jeu, ce qui permet aux dÃ©veloppeurs de tester rapidement diffÃ©rentes approches de la mise en Å“uvre de l'IA. <br><br><h2>  RÃ©action aux Ã©vÃ©nements </h2><br>  Les exemples montrÃ©s ci-dessus sont destinÃ©s Ã  l'exÃ©cution d'une seule image dans des jeux simples comme Pong.  L'idÃ©e est qu'ils effectuent continuellement un cycle de "perception-pensÃ©e-action" et continuent d'agir sur la base du dernier Ã©tat du monde.  Mais dans les jeux plus complexes, au lieu de l'informatique, il est souvent plus raisonnable de rÃ©agir aux Â«Ã©vÃ©nementsÂ», c'est-Ã -dire aux changements importants dans l'environnement du jeu. <br><br>  Ce n'est pas particuliÃ¨rement applicable Ã  Pong, alors choisissons un autre exemple.  Imaginez un jeu de tir dans lequel les ennemis sont immobiles jusqu'Ã  ce qu'ils trouvent un joueur, aprÃ¨s quoi ils commencent Ã  effectuer des actions en fonction de leur classe - les combattants de mÃªlÃ©e peuvent se prÃ©cipiter vers le joueur et les tireurs d'Ã©lite restent Ã  distance et tentent de viser.  En substance, il s'agit d'un systÃ¨me rÃ©actif simple - Â«si nous voyons un joueur, alors nous faisons quelque choseÂ» - mais il peut Ãªtre logiquement divisÃ© en un Ã©vÃ©nement (Â«voir un joueurÂ») et une rÃ©action (sÃ©lectionnez une rÃ©ponse et exÃ©cutez-la). <br><br>  Cela nous ramÃ¨ne au cycle perception-pensÃ©e-action.  Nous pouvons avoir un fragment de code, qui est un code de Â«perceptionÂ», qui vÃ©rifie dans chaque image si l'ennemi voit le joueur.  Sinon, rien ne se passe.  Mais s'il voit, cela crÃ©e un Ã©vÃ©nement Â«voir le joueurÂ».  Le code aura une partie distincte, qui dit: Â«lorsque l'Ã©vÃ©nementÂ« voir le joueur Â»se produit, alors nous faisonsÂ« xyz Â», etÂ« xyz Â»est toute rÃ©ponse que nous voulons traiter la pensÃ©e et l'action.  Pour un combattant de personnage, vous pouvez connecter la rÃ©ponse de course et d'attaque Ã  l'Ã©vÃ©nement "voir le joueur".  Pour le tireur d'Ã©lite, nous allons connecter la fonction de rÃ©ponse Â«cacher et viserÂ» Ã  cet Ã©vÃ©nement.  Comme dans les exemples prÃ©cÃ©dents, nous pouvons crÃ©er de telles associations dans le fichier de donnÃ©es afin qu'elles puissent Ãªtre modifiÃ©es rapidement sans reconstruire le moteur.  De plus, il est possible (et cela est souvent utilisÃ©) d'Ã©crire de telles fonctions de rÃ©ponse dans un langage de script afin qu'elles puissent crÃ©er des solutions complexes lorsque des Ã©vÃ©nements se produisent. <br><br><h1>  Prise de dÃ©cision amÃ©liorÃ©e </h1><br>  Bien que les systÃ¨mes rÃ©actifs simples soient trÃ¨s puissants, il existe de nombreuses situations oÃ¹ ils ne sont pas suffisants.  Parfois, nous devons prendre des dÃ©cisions diffÃ©rentes en fonction de ce que fait l'agent en ce moment, et le prÃ©senter comme une condition n'est pas pratique.  Parfois, il y a tout simplement trop de conditions pour les prÃ©senter efficacement sous la forme d'un arbre de dÃ©cision ou d'un script.  Parfois, nous devons rÃ©flÃ©chir Ã  l'avance et Ã©valuer comment la situation va changer avant de dÃ©cider du prochain coup.  Pour de telles tÃ¢ches, des solutions plus complexes sont nÃ©cessaires. <br><br><h2>  Machines d'Ã©tat </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une</a> machine Ã  Ã©tats finis (FSM) est un moyen de dire en d'autres termes qu'un objet - par exemple, l'un de nos agents IA - est actuellement dans l'un des Ã©tats possibles et qu'il peut aller de d'un Ã©tat Ã  l'autre.  Il existe un nombre fini de tels Ã©tats, d'oÃ¹ le nom.  Un exemple du monde rÃ©el est l'ensemble des feux de circulation, passant du rouge au jaune, puis au vert, et encore une fois.  Ã€ diffÃ©rents endroits, il y a diffÃ©rentes sÃ©quences de lumiÃ¨res, mais le principe est le mÃªme - chaque Ã©tat signifie quelque chose ("se tenir", "manger", "se tenir debout, si possible", etc.), Ã  tout moment il n'y a qu'un seul Ã©tat, et les transitions entre elles sont basÃ©es sur des rÃ¨gles simples. <br><br>  Cela s'applique bien aux PNJ dans les jeux.  Le gardien peut avoir les Ã©tats clairement sÃ©parÃ©s suivants: <br><br><ul><li>  Patrouille </li><li>  Assaut </li><li>  Vol </li></ul><br>  Et nous pouvons proposer les rÃ¨gles suivantes pour la transition entre les Ã‰tats: <br><br><ul><li>  Si le garde voit l'ennemi, il attaque </li><li>  Si le garde attaque, mais ne voit plus l'ennemi, il retourne en patrouille </li><li>  Si un garde attaque mais est griÃ¨vement blessÃ©, il s'Ã©chappe </li></ul><br>  Ce schÃ©ma est assez simple et nous pouvons l'Ã©crire avec des opÃ©rateurs Â«siÂ» strictement dÃ©finis et une variable dans laquelle l'Ã©tat du gardien de sÃ©curitÃ© et divers contrÃ´les seront stockÃ©s - la prÃ©sence d'ennemis Ã  proximitÃ©, le niveau de santÃ© du gardien de sÃ©curitÃ©, etc.  Mais imaginez que nous devons ajouter quelques Ã©tats supplÃ©mentaires: <br><br><ul><li>  En attente (entre patrouilles) </li><li>  Recherche (lorsque l'ennemi prÃ©cÃ©demment vu s'est cachÃ©) </li><li>  Ã‰chapper Ã  l'aide (lorsque l'ennemi est repÃ©rÃ©, mais il est trop fort pour se battre avec lui seul) </li></ul><br>  Et les choix disponibles dans chaque Ã©tat sont gÃ©nÃ©ralement limitÃ©s - par exemple, un garde ne voudra probablement pas chercher un ennemi perdu de vue si sa santÃ© est trop faible. <br><br>  TÃ´t ou tard, la longue liste de Â«si &lt;x et y mais pas z&gt; alors &lt;p&gt;Â» devient trop maladroite, et une approche formalisÃ©e de la mise en Å“uvre des Ã©tats et des transitions entre eux peut aider ici.  Pour ce faire, nous considÃ©rons tous les Ã©tats et sous chaque Ã©tat, nous listons toutes les transitions vers d'autres Ã©tats ainsi que les conditions nÃ©cessaires pour eux.  Nous devons Ã©galement indiquer l'Ã©tat initial afin de savoir par oÃ¹ commencer avant d'appliquer d'autres conditions. <br><br><table><tbody><tr><td>  <b>Condition</b> </td><td>  <b>Condition de transition</b> </td><td>  <b>Nouvelle condition</b> </td></tr><tr><td rowspan="4">  En attente </td><td>  attendu pendant 10 secondes </td><td>  Patrouille </td></tr><tr><td>  l'ennemi est visible et l'ennemi est trop fort </td><td>  Recherche d'aide </td></tr><tr><td>  l'ennemi est visible et beaucoup de santÃ© </td><td>  Assaut </td></tr><tr><td>  l'ennemi est visible et peu de santÃ© </td><td>  Vol </td></tr><tr><td rowspan="4">  Patrouille </td><td>  itinÃ©raire de patrouille terminÃ© </td><td>  En attente </td></tr><tr><td>  l'ennemi est visible et l'ennemi est trop fort </td><td>  Recherche d'aide </td></tr><tr><td>  l'ennemi est visible et beaucoup de santÃ© </td><td>  Assaut </td></tr><tr><td>  l'ennemi est visible et peu de santÃ© </td><td>  Vol </td></tr><tr><td rowspan="2">  Assaut </td><td>  l'ennemi n'est pas visible </td><td>  En attente </td></tr><tr><td>  peu de santÃ© </td><td>  Vol </td></tr><tr><td>  Vol </td><td>  l'ennemi n'est pas visible </td><td>  En attente </td></tr><tr><td rowspan="4">  Chercher </td><td>  recherchÃ© pendant 10 secondes </td><td>  En attente </td></tr><tr><td>  l'ennemi est visible et l'ennemi est trop fort </td><td>  Recherche d'aide </td></tr><tr><td>  l'ennemi est visible et beaucoup de santÃ© </td><td>  Assaut </td></tr><tr><td>  l'ennemi est visible et peu de santÃ© </td><td>  Vol </td></tr><tr><td>  Recherche d'aide </td><td>  ami voir </td><td>  Assaut </td></tr><tr><td colspan="3">  <i>Etat initial: en attente</i> </td></tr></tbody></table><br>  Un tel schÃ©ma est appelÃ© une table de transition d'Ã©tat.  C'est une maniÃ¨re complexe (et peu attrayante) de reprÃ©senter un vaisseau spatial.  Ã€ partir de ces donnÃ©es, vous pouvez Ã©galement dessiner un diagramme et obtenir une reprÃ©sentation graphique complexe de ce Ã  quoi pourrait ressembler le comportement des PNJ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/a7b/262/ee0a7b2621204b58f17703a71b78ed67.png"></div><br>  Il capture l'essence mÃªme de la prise de dÃ©cisions pour l'agent en fonction de la situation dans laquelle il se trouve.  Chaque flÃ¨che indique une transition entre les Ã©tats si la condition Ã  cÃ´tÃ© de la flÃ¨che est vraie. <br><br>  Ã€ chaque mise Ã  jour (ou Â«cycleÂ»), nous vÃ©rifions l'Ã©tat actuel de l'agent, examinons la liste des transitions, et si la condition de transition est remplie, puis passons Ã  un nouvel Ã©tat.  L'Ã©tat en attente vÃ©rifie dans chaque trame ou cycle si le temporisateur de 10 secondes a expirÃ©.  S'il a expirÃ©, il dÃ©marre la transition vers l'Ã©tat "Patrouille".  De mÃªme, l'Ã©tat Â«AttackÂ» vÃ©rifie si l'agent a beaucoup de santÃ©, et si c'est le cas, il passe Ã  l'Ã©tat Â«FlightÂ». <br><br>  C'est ainsi que les transitions d'Ã©tats sont gÃ©rÃ©es - mais qu'en est-il des comportements associÃ©s aux Ã©tats eux-mÃªmes?  Du point de vue de l'exÃ©cution des actions elles-mÃªmes pour un Ã©tat, il existe gÃ©nÃ©ralement deux types d'actions d'attachement Ã  un vaisseau spatial: <br><br><ol><li>  Des actions pour l'Ã©tat actuel sont effectuÃ©es pÃ©riodiquement, par exemple, dans chaque trame ou Â«cycleÂ». </li><li>  Les actions sont effectuÃ©es lors de la transition d'un Ã©tat Ã  un autre. </li></ol><br><br>  Un exemple du premier type: l'Ã©tat Â«PatrouilleÂ» dans chaque trame ou cycle continue de dÃ©placer l'agent le long de la route de patrouille.  L'Ã©tat "Attaque" dans chaque image ou cycle essaie de lancer une attaque ou de la dÃ©placer vers une position d'oÃ¹ elle est possible.  Et ainsi de suite. <br><br>  Un exemple du deuxiÃ¨me type: considÃ©rez la transition "si l'ennemi est visible et l'ennemi est trop fort â†’ Cherchez de l'aide."  L'agent doit choisir oÃ¹ aller pour demander de l'aide et stocker ces informations afin que l'Ã©tat Â«Aide Ã  la rechercheÂ» sache oÃ¹ aller.  De mÃªme, dans l'Ã©tat Â«Aide Ã  la rechercheÂ», lorsque l'aide est trouvÃ©e, l'agent revient Ã  l'Ã©tat Â«AttaqueÂ», mais Ã  ce moment, il souhaite informer le personnage amical de la menace, il peut donc y avoir une action Â«informer un ami du dangerÂ» effectuÃ©e pendant cette transition. <br><br>  Et ici, nous pouvons Ã  nouveau considÃ©rer ce systÃ¨me du point de vue de la Â«perception-pensÃ©e-actionÂ».  La perception est intÃ©grÃ©e dans les donnÃ©es utilisÃ©es par la logique de transition.  La rÃ©flexion est intÃ©grÃ©e aux transitions disponibles pour chaque Ã©tat.  Et l'action est rÃ©alisÃ©e par des actions effectuÃ©es pÃ©riodiquement dans un Ã©tat ou lors de la transition entre Ã©tats. <br><br>  Ce systÃ¨me simple fonctionne bien, mÃªme si parfois les conditions de transition avec interrogation peuvent Ãªtre un processus coÃ»teux.  Par exemple, si chaque agent doit effectuer des calculs complexes dans chaque image pour dÃ©terminer la visibilitÃ© des ennemis et dÃ©cider de la transition de la patrouille Ã  l'attaque, cela peut prendre beaucoup de temps au processeur.  Comme nous l'avons vu prÃ©cÃ©demment, il est possible de percevoir des changements importants dans l'Ã©tat du monde comme des Â«Ã©vÃ©nementsÂ» qui sont traitÃ©s aprÃ¨s qu'ils se sont produits.  Par consÃ©quent, au lieu de vÃ©rifier explicitement la condition de transition Â«mon agent peut-il voir le joueur?Â» Dans chaque image, nous pouvons crÃ©er un systÃ¨me de visibilitÃ© distinct qui effectue ces vÃ©rifications un peu moins souvent (par exemple, 5 fois par seconde) et crÃ©e le Â«joueur voir Â»lorsque le test est dÃ©clenchÃ©.  Il est transmis Ã  la machine d'Ã©tat, qui a dÃ©sormais la condition pour la transition Â«ReÃ§u l'Ã©vÃ©nementÂ« joueur voir Â»Â», et qui y rÃ©pond en consÃ©quence.  Le comportement qui en rÃ©sultera sera similaire, Ã  l'exception d'un retard de rÃ©action Ã  peine perceptible (et mÃªme de rÃ©alisme croissant), mais la productivitÃ© augmentera en raison du transfert de la Â«perceptionÂ» vers une partie distincte du programme. <br><br><h2>  Machines Ã  Ã©tats hiÃ©rarchiques </h2><br>  Tout cela est bien, mais avec de grandes machines Ã  Ã©tats, il devient trÃ¨s gÃªnant de travailler.  Si nous voulons Ã©tendre l'Ã©tat "Attaque" en le remplaÃ§ant par des Ã©tats sÃ©parÃ©s "Attaque au corps Ã  corps" et "Attaque Ã  distance", nous devrons changer les transitions entrantes de chaque Ã©tat, prÃ©sent et futur, qui doit pouvoir passer Ã  l'Ã©tat "Attaque". <br><br>  Vous avez probablement Ã©galement remarquÃ© que dans notre exemple, il existe de nombreuses transitions en double.  La plupart des transitions dans l'Ã©tat "En attente" sont identiques aux transitions dans l'Ã©tat "Patrouille", et il serait bon d'Ã©viter la duplication de ce travail, surtout si nous voulons ajouter des Ã©tats encore plus similaires.  Il sera logique de combiner Â«AttenteÂ» et Â«PatrouilleÂ» dans un groupe Â«Ã‰tats non combattantsÂ», qui n'a qu'un seul ensemble commun de transitions pour combattre les Ã‰tats.  Si nous prÃ©sentons ce groupe comme un Ã©tat, nous pouvons considÃ©rer Â«l'attenteÂ» et la Â«patrouilleÂ» comme des Â«sous-Ã©tatsÂ» de cet Ã©tat, ce qui nous permettra de dÃ©crire plus efficacement l'ensemble du systÃ¨me.  Un exemple d'utilisation d'une table de conversion distincte pour un nouveau sous-Ã©tat sans combat: <br><br>  <b><i>Les principales conditions:</i></b> <br><br><table><tbody><tr><td>  <b>Condition</b> </td><td>  <b>Condition de transition</b> </td><td>  <b>Nouvelle condition</b> </td></tr><tr><td rowspan="3">  Non-combat </td><td>  l'ennemi est visible et l'ennemi est trop fort </td><td>  Recherche d'aide </td></tr><tr><td>  l'ennemi est visible et beaucoup de santÃ© </td><td>  Assaut </td></tr><tr><td>  l'ennemi est visible et peu de santÃ© </td><td>  Vol </td></tr><tr><td rowspan="2">  Assaut </td><td>  l'ennemi n'est pas visible </td><td>  Non-combat </td></tr><tr><td>  peu de santÃ© </td><td>  Vol </td></tr><tr><td>  Vol </td><td>  l'ennemi n'est pas visible </td><td>  Non-combat </td></tr><tr><td rowspan="4">  Chercher </td><td>  recherchÃ© pendant 10 secondes </td><td>  Non-combat </td></tr><tr><td>  l'ennemi est visible et l'ennemi est trop fort </td><td>  Recherche d'aide </td></tr><tr><td>  l'ennemi est visible et beaucoup de santÃ© </td><td>  Assaut </td></tr><tr><td>  l'ennemi est visible et peu de santÃ© </td><td>  Vol </td></tr><tr><td>  Recherche d'aide </td><td>  ami voir </td><td>  Assaut </td></tr><tr><td colspan="3">  <i>Ã‰tat initial: non-combat</i> </td></tr></tbody></table><br>  <b><i>Statut de non-combat:</i></b> <br><br><table><tbody><tr><td>  <b>Condition</b> </td><td>  <b>Condition de transition</b> <br><br></td><td>  <b>Nouvelle condition</b> <br><br></td></tr><tr><td>  En attente </td><td>  attendu pendant 10 secondes </td><td>  Patrouille </td></tr><tr><td>  Patrouille </td><td>  terminÃ© la route de patrouille </td><td>  En attente </td></tr><tr><td colspan="3">  <i>Etat initial: en attente</i> </td></tr></tbody></table><br>  Et sous forme de graphique: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/7a0/21f/2407a021fd5e60c214d79069b86148d4.png"></div><br>  En fait, c'est le mÃªme systÃ¨me, seulement maintenant il y a un Ã©tat de non-combat qui remplace "Patrouille" et "Attente", qui est en soi une machine d'Ã©tat avec deux sous-Ã©tats de patrouille et d'attente.  Si chaque Ã©tat peut potentiellement contenir une machine d'Ã©tat de sous-Ã©tats (et ces sous-Ã©tats peuvent Ã©galement contenir sa propre machine d'Ã©tat, etc.), alors nous avons une machine d'Ã©tat hiÃ©rarchique (HFSM).  En regroupant les comportements hors combat, nous supprimons un tas de transitions inutiles, et nous pouvons faire de mÃªme pour tous les nouveaux Ã©tats qui peuvent avoir des transitions communes.  Par exemple, si Ã  l'avenir nous Ã©tendons l'Ã©tat "Attaque" aux Ã©tats "Attaque en mÃªlÃ©e" et "Attaque par projectile", ils peuvent Ãªtre des sous-Ã©tats, dont la transition est basÃ©e sur la distance Ã  l'ennemi et la prÃ©sence de munitions, qui ont des transitions de sortie communes basÃ©es sur les niveaux de santÃ© et d'autres choses.  Ainsi, avec un minimum de transitions dupliquÃ©es, des comportements et sous-comportements complexes peuvent Ãªtre reprÃ©sentÃ©s. <br><br><h2>  Arbres de comportement </h2><br>  Avec HFSM, nous avons eu la possibilitÃ© de crÃ©er des ensembles de comportements assez complexes d'une maniÃ¨re plutÃ´t intuitive.  Cependant, on remarque immÃ©diatement que la prise de dÃ©cision sous forme de rÃ¨gles de transition est Ã©troitement liÃ©e Ã  l'Ã©tat actuel.  De nombreux jeux nÃ©cessitent juste cela.  Et une utilisation prudente de la hiÃ©rarchie des Ã©tats rÃ©duit le nombre de transitions en double.  Mais parfois, nous avons besoin de rÃ¨gles qui s'appliquent quel que soit l'Ã©tat actuel, ou s'appliquent dans presque tous les Ã‰tats.  Par exemple, si la santÃ© de l'agent est tombÃ©e Ã  25%, il peut vouloir s'enfuir, qu'il soit au combat, ou qu'il attend ou parle, ou qu'il se trouve dans un autre Ã©tat.  Nous ne voulons pas nous rappeler que nous devons ajouter cette condition Ã  chaque Ã©tat que nous pourrons ajouter au personnage Ã  l'avenir.  Ainsi, lorsque le concepteur dira plus tard qu'il souhaite modifier la valeur seuil de 25% Ã  10%, nous n'aurions pas Ã  trier et Ã  modifier chaque transition correspondante. <br><br>  Dans une telle situation, l'idÃ©al Ã©tait un systÃ¨me dans lequel les dÃ©cisions concernant l'Ã©tat dans lequel il se trouve existent sÃ©parÃ©ment des Ã‰tats eux-mÃªmes, de sorte que nous ne pouvons changer qu'un seul Ã©lÃ©ment, et que les transitions sont toujours traitÃ©es correctement.  C'est lÃ  que les arbres de comportement sont utiles. <br><br>  Il existe plusieurs faÃ§ons de mettre en Å“uvre des arbres comportementaux, mais l'essentiel est le mÃªme pour la plupart et trÃ¨s similaire Ã  l'arbre de dÃ©cision mentionnÃ© ci-dessus: l'algorithme commence Ã  fonctionner Ã  partir du Â«nÅ“ud racineÂ», et il y a des nÅ“uds dans l'arbre qui indiquent des dÃ©cisions ou des actions.  Cependant, il existe des diffÃ©rences clÃ©s: <br><br><ul><li>  Les nÅ“uds renvoient dÃ©sormais l'une des trois valeurs suivantes: Â«rÃ©ussiÂ» (si le travail est terminÃ©), Â«sans succÃ¨sÂ» (si le travail n'a pas Ã©tÃ© terminÃ©) ou Â«exÃ©cutÃ©Â» (si le travail est toujours en cours et n'a pas complÃ¨tement rÃ©ussi ou Ã©chouÃ©). </li><li>  Maintenant, nous n'avons pas de nÅ“uds de dÃ©cision dans lesquels nous choisissons parmi deux alternatives, mais il existe des nÅ“uds dÃ©corateurs avec un seul nÅ“ud enfant.  S'ils Â«rÃ©ussissentÂ», ils exÃ©cutent leur seul nÅ“ud enfant.  Les nÅ“uds dÃ©corateurs contiennent souvent des conditions qui dÃ©terminent si l'exÃ©cution s'est terminÃ©e avec succÃ¨s (ce qui signifie que vous devez exÃ©cuter leur sous-arbre) ou l'Ã©chec (alors rien ne doit Ãªtre fait).  Ils peuvent Ã©galement revenir "en cours". </li><li>  Les noeuds effectuant des actions renvoient une valeur "en cours d'exÃ©cution" pour indiquer ce qui se passe. </li></ul><br>  Un petit ensemble de nÅ“uds peut Ãªtre combinÃ©, crÃ©ant un grand nombre de comportements complexes, et souvent ce schÃ©ma est trÃ¨s bref.  Par exemple, nous pouvons rÃ©Ã©crire l'autoritÃ© de certification hiÃ©rarchique de la garde de l'exemple prÃ©cÃ©dent sous la forme d'un arbre de comportement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/0f2/d18/9b90f2d18ce7b78b8a9a0673b8cde3d2.png"></div><br>  Lors de l'utilisation de cette structure, il n'est pas nÃ©cessaire de faire une transition explicite des Ã©tats "En attente" ou "Patrouille" aux Ã©tats "Attaque" ou tout autre - si l'arbre est traversÃ© de haut en bas et de gauche Ã  droite, la dÃ©cision correcte est prise en fonction de la situation actuelle.  Si l'ennemi est visible et que le personnage a peu de santÃ©, alors l'arbre terminera la course sur le nÅ“ud "Flight", quel que soit le nÅ“ud terminÃ© prÃ©cÃ©demment ("Patrol", "Waiting", "Attack", etc.). <br><br>  Vous remarquerez peut-Ãªtre que nous n'avons pas encore de transition pour revenir Ã  l'Ã©tat "En attente" de "Patrouille" - et ici, les dÃ©corateurs inconditionnels seront utiles.  Le nÅ“ud dÃ©corateur standard est Â«RÃ©pÃ©terÂ» - il n'a pas de conditions, il intercepte simplement le nÅ“ud enfant qui retourne Â«avec succÃ¨sÂ» et exÃ©cute Ã  nouveau le nÅ“ud enfant, en retournant Â«exÃ©cutÃ©Â».  Le nouvel arbre ressemble Ã  ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/487/d73/187487d733f1db9e07920b0475894bb4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les arbres comportementaux sont assez complexes car il existe souvent de nombreuses maniÃ¨res diffÃ©rentes de crÃ©er un arbre, et trouver la bonne combinaison de nÅ“uds dÃ©corateurs et de composants peut Ãªtre une tÃ¢che ardue. Il y a aussi des problÃ¨mes avec la frÃ©quence Ã  laquelle nous devons vÃ©rifier l'arbre (voulons-nous le parcourir Ã  chaque image ou quand quelque chose se produit qui peut affecter les conditions?) Et comment stocker l'Ã©tat par rapport aux nÅ“uds (comment savons-nous que nous avons attendu 10 secondes? Comment allons-nous savoir combien de nÅ“uds ont Ã©tÃ© exÃ©cutÃ©s pour la derniÃ¨re fois afin de terminer correctement la sÃ©quence?) Par consÃ©quent, il existe de nombreuses implÃ©mentations diffÃ©rentes. Par exemple, sur certains systÃ¨mes, comme le systÃ¨me d'arborescence des comportements d'Unreal Engine 4, les nÅ“uds de dÃ©corateur sont remplacÃ©s par des dÃ©corateurs de chaÃ®ne qui vÃ©rifient l'arborescence uniquement lorsque les conditions du dÃ©corateur changent et fournissent des Â«servicesÂ»,qui peut Ãªtre connectÃ© aux nÅ“uds et fournir des mises Ã  jour pÃ©riodiques mÃªme lorsque l'arborescence n'est pas vÃ©rifiÃ©e Ã  nouveau. Les arbres comportementaux sont des outils puissants, mais apprendre Ã  les utiliser correctement, en particulier avec autant d'implÃ©mentations diffÃ©rentes, peut Ãªtre une tÃ¢che ardue.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SystÃ¨mes basÃ©s sur les services publics </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains jeux nÃ©cessitent l'existence de nombreuses actions diffÃ©rentes, ils nÃ©cessitent donc des rÃ¨gles de transition centralisÃ©es plus simples, mais ils n'ont pas besoin de la puissance nÃ©cessaire pour implÃ©menter complÃ¨tement l'arbre de comportement. </font><font style="vertical-align: inherit;">Au lieu de crÃ©er un ensemble explicite de choix ou un arbre d'actions potentielles avec des positions de repli implicites dÃ©finies par la structure de l'arbre, peut-Ãªtre vaut-il mieux simplement examiner toutes les actions et choisir celle qui est la plus applicable en ce moment? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est ce que font les systÃ¨mes basÃ©s sur l'utilitÃ© - ce sont des systÃ¨mes dans lesquels l'agent a de nombreuses actions Ã  sa disposition, et il choisit d'effectuer une basÃ©e sur l' </font><i><font style="vertical-align: inherit;">utilitÃ©</font></i><font style="vertical-align: inherit;"> relative</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque action. L'utilitÃ© ici est une mesure arbitraire d'importance ou de dÃ©sirabilitÃ© pour un agent d'effectuer cette action. En Ã©crivant des fonctions utilitaires pour calculer l'utilitÃ© d'une action en fonction de l'Ã©tat actuel de l'agent et de son environnement, l'agent peut vÃ©rifier les valeurs de l'utilitaire et sÃ©lectionner l'Ã©tat le plus appropriÃ© Ã  l'heure actuelle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ressemble aussi beaucoup Ã  une machine Ã  Ã©tats finis, sauf que les transitions sont dÃ©terminÃ©es par une Ã©valuation de chaque Ã©tat potentiel, y compris l'actuel. Il convient de noter que dans le cas gÃ©nÃ©ral, nous choisissons la transition vers l'action la plus prÃ©cieuse (ou y sommes si nous effectuons dÃ©jÃ  cette action), mais pour une plus grande variabilitÃ©, il peut s'agir d'un choix alÃ©atoire pondÃ©rÃ© (donnant la prioritÃ© Ã  l'action la plus prÃ©cieuse, mais permettant le choix des autres) , un choix d'action alÃ©atoire parmi les cinq premiers (ou toute autre quantitÃ©), etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le systÃ¨me standard basÃ© sur l'utilitÃ© attribue une certaine plage arbitraire de valeurs d'utilitÃ© - disons de 0 (complÃ¨tement indÃ©sirable) Ã  100 (absolument souhaitable), et chaque action peut avoir un ensemble de facteurs qui influencent la faÃ§on dont la valeur est calculÃ©e. </font><font style="vertical-align: inherit;">Pour revenir Ã  notre exemple avec le gardien, on peut imaginer quelque chose comme Ã§a:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcul de l'utilitÃ©</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche d'aide</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si l'ennemi est visible et que l'ennemi est fort et que sa santÃ© est faible, renvoyez 100, sinon retournez 0 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vol</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si l'ennemi est visible et qu'il y a peu de santÃ©, renvoyez 90, sinon retournez 0 </font></font><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assaut</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si l'ennemi est visible, renvoyez 80 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attente</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous sommes dans un Ã©tat d'attente et attendons dÃ©jÃ  10 secondes, retournez 0, sinon 50 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrouille</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous sommes Ã  la fin de la route de patrouille, retournez 0, sinon 50 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des aspects les plus importants de ce schÃ©ma est que les transitions entre les actions sont exprimÃ©es implicitement - de n'importe quel Ã©tat, vous pouvez complÃ¨tement lÃ©gitimement vous rendre dans un autre. De plus, les prioritÃ©s d'action sont implicites dans les valeurs d'utilitÃ© renvoyÃ©es. Si l'ennemi est visible, et s'il est fort, et que le personnage a peu de santÃ©, les valeurs non nulles renvoient </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flight</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Help Search</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Help Search a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> toujours une note plus Ã©levÃ©e. De mÃªme, les actions non-combat ne retournent jamais plus de 50, ils sont donc toujours vaincus par les combats. Dans cette optique, des actions et leurs calculs d'utilitÃ© sont crÃ©Ã©s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre exemple, les actions renvoient une valeur d'utilitÃ© constante ou l'une des deux valeurs d'utilitÃ© constantes. Un systÃ¨me plus rÃ©aliste utilise une valeur de retour Ã  partir d'une </font><font style="vertical-align: inherit;">plage </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de valeurs. Par exemple, l'action </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut renvoyer des valeurs d'utilitÃ© plus Ã©levÃ©es si la santÃ© de l'agent est infÃ©rieure, et l'action </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut renvoyer des valeurs d'utilitÃ© plus faibles si l'ennemi est trop fort. Cela permettra Ã  </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway de l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> emporter sur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assault.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans toute situation oÃ¹ l'agent estime qu'il n'est pas en assez bonne santÃ© pour combattre l'ennemi. Cela vous permet de modifier les prioritÃ©s relatives des actions sur la base d'un certain nombre de critÃ¨res, ce qui peut rendre cette approche plus flexible qu'un arbre de comportement ou un vaisseau spatial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque action a gÃ©nÃ©ralement plusieurs conditions qui influencent le calcul de l'utilitÃ©. Afin de ne pas tout mettre en dur dans le code, vous pouvez les Ã©crire dans un langage de script ou sous la forme d'une sÃ©rie de formules mathÃ©matiques, assemblÃ©es de maniÃ¨re comprÃ©hensible. Beaucoup plus d'informations Ã  ce sujet sont dans les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confÃ©rences</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prÃ©sentations de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dave Mark ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@IADaveMark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans certains jeux qui tentent de simuler la vie quotidienne du personnage, par exemple, dans Les Sims, une autre couche de calculs est ajoutÃ©e dans laquelle l'agent a des Â«aspirationsÂ» ou des Â«motivationsÂ» qui affectent les valeurs d'utilitÃ©. Par exemple, si un personnage a la motivation Hunger, alors elle peut augmenter avec le temps, et le calcul de l'utilitÃ© de l'action Eat renverra des valeurs de plus en plus Ã©levÃ©es jusqu'Ã  ce que le personnage puisse effectuer cette action, rÃ©duisant le niveau de faim, et l'action " Eat â€est rÃ©duit Ã  une valeur d'utilitÃ© nulle ou presque nulle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'idÃ©e de choisir des actions basÃ©es sur le systÃ¨me de points est assez simple, il est donc Ã©vident que vous pouvez utiliser la prise de dÃ©cision basÃ©e sur l'utilitÃ© dans d'autres processus dÃ©cisionnels de l'IA, et non les remplacer complÃ¨tement par elle. </font><font style="vertical-align: inherit;">L'arbre de dÃ©cision peut interroger la valeur d'utilitÃ© de ses deux nÅ“uds enfants et sÃ©lectionner le nÅ“ud avec la valeur la plus Ã©levÃ©e. </font><font style="vertical-align: inherit;">De mÃªme, un arbre de comportement peut avoir un nÅ“ud utilitaire composite qui compte l'utilitaire pour sÃ©lectionner le nÅ“ud enfant Ã  exÃ©cuter.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement et navigation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans nos exemples prÃ©cÃ©dents, il y avait soit une simple raquette, que nous avions ordonnÃ©e de dÃ©placer de gauche Ã  droite, soit un personnage de garde, qui avait toujours l'ordre de patrouiller ou d'attaquer. </font><font style="vertical-align: inherit;">Mais comment contrÃ´lons-nous exactement le mouvement d'un agent sur une pÃ©riode de temps? </font><font style="vertical-align: inherit;">Comment rÃ©gler la vitesse, Ã©viter les obstacles, planifier un itinÃ©raire lorsqu'il est impossible d'atteindre directement le point final? </font><font style="vertical-align: inherit;">Nous allons maintenant examiner cette tÃ¢che.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direction </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au niveau le plus simple, il est souvent sage de travailler avec chaque agent comme s'il avait une valeur de vitesse qui dÃ©termine la vitesse et la direction de son mouvement. Cette vitesse peut Ãªtre mesurÃ©e en mÃ¨tres par seconde, en miles par heure, en pixels par seconde et ainsi de suite. Si nous rappelons notre cycle Â«perception-pensÃ©e-actionÂ», nous pouvons imaginer que la Â«pensÃ©eÂ» peut choisir la vitesse, aprÃ¨s quoi Â«l'actionÂ» applique cette vitesse Ã  l'agent, le dÃ©plaÃ§ant Ã  travers le monde. Habituellement, dans les jeux, il existe un systÃ¨me de physique qui effectue cette tÃ¢che de maniÃ¨re indÃ©pendante, Ã©tudie la valeur de la vitesse de chaque entitÃ© et modifie sa position en consÃ©quence. Par consÃ©quent, il est souvent possible d'affecter un tel travail Ã  ce systÃ¨me, ne laissant Ã  l'IA que la tÃ¢che de choisir la vitesse de l'agent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous savons oÃ¹ l'agent veut Ãªtre, alors nous devons utiliser notre vitesse pour dÃ©placer l'agent dans cette direction. </font><font style="vertical-align: inherit;">Sous une forme triviale, nous obtenons l'Ã©quation suivante:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desire_travel = destination_position - position_agent </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez un monde 2D dans lequel l'agent est situÃ© aux coordonnÃ©es (-2, -2), et le point cible est approximativement au nord-est, aux coordonnÃ©es (30, 20), c'est-Ã -dire que pour vous y rendre, vous devez vous dÃ©placer (32, 22). </font><font style="vertical-align: inherit;">Supposons que ces positions soient indiquÃ©es en mÃ¨tres. </font><font style="vertical-align: inherit;">Si nous dÃ©cidons que l'agent peut se dÃ©placer Ã  une vitesse de 5 m / s, rÃ©duisons alors l'Ã©chelle du vecteur de dÃ©placement Ã  cette valeur et constatons que nous devons rÃ©gler la vitesse approximativement (4.12, 2.83). </font><font style="vertical-align: inherit;">En se basant sur cette valeur, l'agent arrivera au point final en un peu moins de 8 secondes, comme prÃ©vu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les calculs peuvent Ãªtre effectuÃ©s Ã  tout moment. Par exemple, si l'agent est Ã  mi-chemin de la cible, le mouvement souhaitÃ© sera deux fois moins Ã©levÃ©, mais aprÃ¨s la mise Ã  l'Ã©chelle Ã  la vitesse maximale de l'agent de 5 m / s, la vitesse reste la mÃªme. Cela fonctionne Ã©galement pour les cibles mobiles (dans des limites raisonnables), ce qui permet Ã  l'agent de faire de petits ajustements en cours de route. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous avons souvent besoin de plus de contrÃ´le. Par exemple, nous devrons peut-Ãªtre augmenter lentement la vitesse, comme si le personnage restait d'abord immobile, puis passait Ã  une Ã©tape, puis courait. D'un autre cÃ´tÃ©, nous devrons peut-Ãªtre le ralentir Ã  l'approche de la cible. Souvent, ces tÃ¢ches sont rÃ©solues en utilisant les soi-disant Â« </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportements de pilotageÂ»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"ayant leurs propres noms comme Seek, Flee, Arrival, etc. (Sur HabrÃ©, il y a une sÃ©rie d'articles Ã  leur sujet: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/358366/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Leur idÃ©e est que vous pouvez appliquer la vitesse de l'agent des forces d'accÃ©lÃ©ration basÃ©es sur une comparaison de la position de l'agent et de la vitesse actuelle de dÃ©placement vers la cible, crÃ©ant diffÃ©rentes faÃ§ons de se dÃ©placer vers la cible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque comportement a son propre objectif lÃ©gÃ¨rement diffÃ©rent. Seek et Arrive sont utilisÃ©s pour dÃ©placer l'agent vers sa destination. L'Ã©vitement et la sÃ©paration des obstacles aident l'agent Ã  effectuer de petits mouvements correctifs pour contourner les petits obstacles entre l'agent et sa destination. L'alignement et la cohÃ©sion forcent les agents Ã  se dÃ©placer ensemble, imitant les animaux du troupeau. Toutes les variations de diffÃ©rents comportements de pilotage peuvent Ãªtre combinÃ©es ensemble, souvent sous la forme d'une somme pondÃ©rÃ©e, pour crÃ©er une valeur totale qui prend en compte tous ces diffÃ©rents facteurs et crÃ©e un seul vecteur rÃ©sultant. Par exemple, un agent peut utiliser le comportement d'arrivÃ©e ainsi que les comportements de sÃ©paration et d'Ã©vitement d'obstacles pour rester Ã  l'Ã©cart des murs et d'autres agents. Cette approche fonctionne bien dans des environnements ouverts qui ne sont pas trop complexes et encombrÃ©s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, dans des environnements plus complexes, le simple fait d'ajouter les valeurs de sortie du comportement ne fonctionne pas trÃ¨s bien - parfois le mouvement prÃ¨s de l'objet est trop lent, ou l'agent se coince lorsque le comportement d'arrivÃ©e veut passer Ã  travers l'obstacle, et le comportement d'Ã©vitement d'obstacle pousse l'agent du cÃ´tÃ© d'oÃ¹ il vient. . Par consÃ©quent, il est parfois judicieux d'envisager des variations de comportement de direction plus compliquÃ©es que de simplement additionner toutes les valeurs. L'une des familles de ces approches consiste en une mise en Å“uvre diffÃ©rente - nous ne considÃ©rons pas chacun des comportements qui nous orientent, suivi de leur combinaison pour obtenir un consensus (qui en soi peut Ãªtre inadÃ©quat). Au lieu de cela, nous considÃ©rons le mouvement dans plusieurs directions diffÃ©rentes - par exemple, dans huit directions de la boussole, ou Ã  5-6 points devant l'agent,aprÃ¨s quoi nous choisissons le meilleur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cependant, dans des environnements complexes avec des impasses et des options de virage, nous aurons besoin de quelque chose de plus avancÃ©, et nous allons passer Ã  cela bientÃ´t. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche de chemin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les comportements de direction sont parfaits pour les mouvements simples dans une zone assez ouverte, comme un terrain de football ou une arÃ¨ne, oÃ¹ vous pouvez vous rendre de A Ã  B en ligne droite avec de lÃ©gers ajustements pour Ã©viter les obstacles. </font><font style="vertical-align: inherit;">Mais que se passe-t-il si l'itinÃ©raire vers le point final est plus compliquÃ©? </font><font style="vertical-align: inherit;">Ensuite, nous avons besoin d'un Â«repÃ©rageÂ» - explorer le monde et tracer un chemin le long de celui-ci afin que l'agent atteigne le point final.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple est de tracer une grille sur le monde, et pour chaque cellule Ã  cÃ´tÃ© de l'agent, regardez les cellules voisines dans lesquelles nous pouvons nous dÃ©placer. Si l'un d'eux est notre dernier point, alors revenez sur l'itinÃ©raire, de chaque cellule Ã  la prÃ©cÃ©dente, jusqu'Ã  ce que nous arrivions au dÃ©but, obtenant ainsi un itinÃ©raire. Sinon, rÃ©pÃ©tez le processus avec les voisins accessibles des voisins prÃ©cÃ©dents jusqu'Ã  ce que nous trouvions le point final ou que nous manquions de cellules (cela signifiera qu'il n'y a pas de route). Formellement, cette approche est appelÃ©e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'algorithme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breadth-First Search (BFS), car Ã  chaque Ã©tape, il regarde dans toutes les directions (c'est-Ã -dire "large") avant de dÃ©placer les recherches. L'espace de recherche est comme un front d'onde qui se dÃ©place jusqu'Ã  ce qu'il tombe sur l'endroit que nous recherchions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est un exemple simple de recherche en action. La zone de recherche se dÃ©veloppe Ã  chaque Ã©tape jusqu'Ã  ce qu'un point final y soit inclus, aprÃ¨s quoi vous pouvez suivre le chemin vers le dÃ©but.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/08e/15f/f1208e15fc83ffa2b7ac3eca652854fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En consÃ©quence, nous obtenons une liste de cellules de grille, constituant l'itinÃ©raire que vous devez parcourir. Habituellement, cela s'appelle un "chemin", un chemin (d'oÃ¹ la "recherche de chemins", la recherche de chemins), mais vous pouvez aussi l'imaginer comme un plan, car c'est une liste de lieux que vous devez visiter pour atteindre votre objectif, c'est-Ã -dire le point final. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous connaissons la position de chaque cellule dans le monde, vous pouvez utiliser les comportements de direction dÃ©crits ci-dessus pour vous dÃ©placer le long de l'itinÃ©raire - d'abord du nÅ“ud de dÃ©part au nÅ“ud 2, puis du nÅ“ud 2 au nÅ“ud 3, etc. L'approche la plus simple consiste Ã  se dÃ©placer vers le centre de la cellule suivante, mais il existe Ã©galement une alternative populaire - se dÃ©placer vers le milieu de la nervure entre la cellule actuelle et la suivante. Cela permet Ã  l'agent de couper les coins des virages serrÃ©s pour crÃ©er un mouvement plus rÃ©aliste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, cet algorithme peut gaspiller des ressources car il examine autant de cellules dans la Â«mauvaiseÂ» direction que dans la Â«bonneÂ». De plus, il ne permet pas de prendre en compte les coÃ»ts de dÃ©placement, auxquels certaines cellules peuvent Ãªtre Â«plus chÃ¨resÂ» que d'autres. Nous arrivons ici Ã  l'aide d'un algorithme plus complexe appelÃ© A *. Cela fonctionne Ã  peu prÃ¨s de la mÃªme maniÃ¨re que la recherche en largeur, mais au lieu d'explorer aveuglÃ©ment les voisins, puis les voisins des voisins, puis les voisins des voisins, les voisins, etc., il place tous ces nÅ“uds dans une liste et les trie de sorte que le prochain nÅ“ud examinÃ© soit toujours celui conduit trÃ¨s probablement Ã  l'itinÃ©raire le plus court. Les nÅ“uds sont triÃ©s sur la base d'heuristiques (c'est-Ã -dire, en fait, une hypothÃ¨se raisonnable),qui prend en compte deux aspects - le coÃ»t d'une route hypothÃ©tique vers la cellule (prenant ainsi en compte tous les coÃ»ts nÃ©cessaires au dÃ©placement) et une estimation de la distance de cette cellule par rapport au point final (dÃ©plaÃ§ant ainsi la recherche dans la bonne direction).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/406/091/128406091bee8168b7b0e398386797da.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet exemple, nous avons montrÃ© qu'il examine une cellule Ã  la fois, en choisissant Ã  chaque fois une cellule voisine qui a les meilleures (ou l'une des meilleures) perspectives. </font><font style="vertical-align: inherit;">Le chemin rÃ©sultant est similaire au chemin de recherche en largeur, mais moins de cellules sont examinÃ©es dans le processus, ce qui est trÃ¨s important pour les performances du jeu Ã  des niveaux complexes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement sans maille </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les exemples prÃ©cÃ©dents, une grille superposÃ©e au monde a Ã©tÃ© utilisÃ©e, et nous avons tracÃ© un parcours autour du monde Ã  travers les cellules de cette grille. Mais la plupart des jeux ne chevauchent pas la grille, et donc la superposition de la grille peut conduire Ã  des modÃ¨les de mouvement irrÃ©alistes. En outre, cette approche peut nÃ©cessiter des compromis concernant la taille de chaque cellule - si elle est trop grande, elle ne sera pas en mesure de dÃ©crire correctement les petits couloirs et les virages, si elle est trop petite, la recherche dans des milliers de cellules peut Ãªtre trop longue. Quelles sont les alternatives? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premiÃ¨re chose que nous devons comprendre est que, d'un point de vue mathÃ©matique, la grille nous donne un " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graphique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"de nÅ“uds connectÃ©s. Les algorithmes A * (et BFS) fonctionnent avec des graphiques, et la grille n'est pas importante pour eux. Par consÃ©quent, nous pouvons placer des nÅ“uds dans des positions arbitraires du monde, et s'il y a une ligne droite entre deux nÅ“uds connectÃ©s, mais il y a une ligne entre le dÃ©but et la fin s'il n'y a qu'un seul nÅ“ud, notre algorithme fonctionnera comme avant, et en fait c'est encore mieux, car il y aura moins de nÅ“uds. Ceci est souvent appelÃ© le systÃ¨me de waypoints, car chaque nÅ“ud indique une position importante dans le monde qui peut crÃ©er partie d'un nombre quelconque de pu hypothÃ©tique </font><font style="vertical-align: inherit;">s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/a64/90f/5b0a6490f8fac6a4101d7d6833946325.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple 1: un nÅ“ud dans chaque cellule de la grille. </font><font style="vertical-align: inherit;">La recherche commence par le nÅ“ud dans lequel se trouve l'agent et se termine par la cellule finale.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/a09/70d/0f9a0970dfadfd31260ae81c93d8792b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple 2: un nombre beaucoup plus petit de nÅ“uds, ou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> waypoints </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La recherche commence par l'agent, passe par le nombre requis de points de cheminement et se dÃ©place vers le point de terminaison. Notez que le dÃ©placement vers le premier point du chemin au sud-ouest du lecteur est un itinÃ©raire inefficace, donc un certain post-traitement du chemin gÃ©nÃ©rÃ© est gÃ©nÃ©ralement nÃ©cessaire (par exemple, pour remarquer que le chemin peut aller directement au waypoint au nord-est).</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il s'agit d'un systÃ¨me assez flexible et puissant, mais il nÃ©cessite une localisation soigneuse des points de cheminement, sinon les agents peuvent ne pas voir le point de cheminement le plus proche pour dÃ©marrer la route. Ce serait formidable si nous pouvions en quelque sorte gÃ©nÃ©rer automatiquement des points de cheminement basÃ©s sur la gÃ©omÃ©trie du monde.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis navmesh vient Ã  la rescousse. C'est l'abrÃ©viation de maillage de navigation. Essentiellement, il s'agit (gÃ©nÃ©ralement) d'un maillage bidimensionnel de triangles, chevauchant approximativement la gÃ©omÃ©trie du monde aux endroits oÃ¹ le jeu permet Ã  l'agent de se dÃ©placer. Chacun des triangles du maillage devient un nÅ“ud du graphique et comporte jusqu'Ã  trois triangles adjacents qui deviennent des nÅ“uds adjacents du graphique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple du moteur Unity. Le moteur a analysÃ© la gÃ©omÃ©trie du monde et crÃ©Ã© navmesh (bleu), qui est une approximation de la gÃ©omÃ©trie. Chaque polygone nammesh est une zone dans laquelle un agent peut se tenir et un agent peut se dÃ©placer d'un polygone Ã  un polygone adjacent. (Dans cet exemple, les polygones sont plus Ã©troits que le sol sur lequel ils se trouvent pour tenir compte du rayon de l'agent, qui s'Ã©tend au-delÃ  de la position nominale de l'agent.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/051/69e/86005169e23bd5d646664aeecf688b3a.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons Ã  nouveau rechercher l'itinÃ©raire Ã  travers le maillage en utilisant A *, ce qui nous donnera un itinÃ©raire idÃ©al Ã  travers le monde qui prend en compte toute la gÃ©omÃ©trie et ne nÃ©cessite pas un nombre excessif de nÅ“uds supplÃ©mentaires (comme ce serait le cas avec la grille) et la participation humaine Ã  la gÃ©nÃ©ration de points le chemin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La recherche de chemins est un sujet vaste, auquel il existe de nombreuses approches, surtout si vous devez programmer vous-mÃªme des dÃ©tails de bas niveau. L'une des meilleures sources d'informations complÃ©mentaires est le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site d'Amit Patel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (traduction de l'article sur HabrÃ©: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/331192/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h1>  Planification </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant la recherche de chemins comme exemple, nous avons vu que parfois il ne suffit pas simplement de choisir une direction et de commencer Ã  s'y dÃ©placer - nous devons choisir un itinÃ©raire et effectuer plusieurs mouvements avant d'atteindre le point final souhaitÃ©. Nous pouvons gÃ©nÃ©raliser cette idÃ©e Ã  un large Ã©ventail de concepts dans lesquels l'objectif n'est pas seulement la prochaine Ã©tape. Pour y parvenir, vous devez prendre une sÃ©rie d'Ã©tapes, et pour savoir quelle devrait Ãªtre la premiÃ¨re Ã©tape, vous devrez peut-Ãªtre regarder en avant. Cette approche est appelÃ©e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planification</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La recherche de chemins peut Ãªtre considÃ©rÃ©e comme l'une des applications spÃ©cifiques de la planification, mais ce concept a de nombreuses autres applications. Revenant au cycle Â«perception-pensÃ©e-actionÂ», cette planification est une phase de rÃ©flexion qui tente de planifier plusieurs phases d'action pour l'avenir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardons le jeu Magic: The Gathering. </font><font style="vertical-align: inherit;">Vous avez votre premier coup, il y a plusieurs cartes entre vos mains, dont Â«SwampÂ», qui donne 1 point de mana noir, et Â«ForestÂ», qui donne 1 point de mana vert, Â«ExorcistÂ», qui nÃ©cessite 1 point de mana bleu pour appeler, et Â« Elven Mystic â€, pour appeler ce dont vous avez besoin de 1 point de mana vert. </font><font style="vertical-align: inherit;">(Par souci de simplicitÃ©, nous omettons les trois cartes restantes.) Les rÃ¨gles stipulent qu'un joueur peut jouer une carte de terrain par tour, peut "toucher" ses cartes de terrain pour en obtenir du mana, et peut lancer autant de sorts (y compris les crÃ©atures invoquÃ©es) combien de mana il a. </font><font style="vertical-align: inherit;">Dans cette situation, le joueur est susceptible de jouer Ã  Â«ForestÂ», de le toucher pour obtenir 1 point de mana vert, puis d'appeler Â«Elven MysticÂ». </font><font style="vertical-align: inherit;">Mais comment une IA de jeu sait-elle qu'une telle dÃ©cision doit Ãªtre prise?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Planificateur" simple </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une approche naÃ¯ve peut Ãªtre de simplement rÃ©pÃ©ter chaque action dans l'ordre, jusqu'Ã  ce qu'il y en ait une appropriÃ©e. En regardant la main, l'IA voit qu'elle peut jouer Ã  Â«SwampÂ», et donc elle le fait. Y a-t-il d'autres actions aprÃ¨s ce tour? Il ne peut invoquer ni Elven Mystic ni Exile Wizard, car cela nÃ©cessite du mana vert ou bleu, et le marais jouÃ© ne donne que du mana noir. Et nous ne pouvons pas jouer Ã  Â«ForestÂ» car nous avons dÃ©jÃ  jouÃ© Ã  Â«SwampÂ». Autrement dit, le joueur IA fera le dÃ©placement selon les rÃ¨gles, mais ce ne sera pas trÃ¨s optimal. Heureusement, il existe une meilleure solution.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la mÃªme maniÃ¨re que la recherche de chemins trouve une liste de positions pour se dÃ©placer dans le monde afin d'arriver au bon point, notre planificateur peut trouver une liste d'actions qui mettent le jeu dans le bon Ã©tat. </font><font style="vertical-align: inherit;">Tout comme chaque position sur le chemin a un ensemble de voisins, qui sont des options potentielles pour choisir l'Ã©tape suivante le long du chemin, chaque action du plan a des voisins, ou Â«hÃ©ritiersÂ», qui sont candidats Ã  l'Ã©tape suivante du plan. </font><font style="vertical-align: inherit;">Nous pouvons rechercher ces actions et les actions suivantes jusqu'Ã  atteindre l'Ã©tat souhaitÃ©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons, pour notre exemple, que le rÃ©sultat souhaitÃ© soit Â«invoque une crÃ©ature, si possibleÂ». </font><font style="vertical-align: inherit;">Au dÃ©but du mouvement, nous n'avons que deux actions potentielles autorisÃ©es par les rÃ¨gles du jeu:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jouez "Swamp" (rÃ©sultat: "Swamp" quitte la main et entre dans le jeu)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jouez Ã  "Forest" (rÃ©sultat: "Forest" quitte la main et entre dans le jeu) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque action entreprise peut ouvrir d'autres actions ou les fermer, Ã©galement conformÃ©ment aux rÃ¨gles du jeu. </font><font style="vertical-align: inherit;">Imaginez que nous avons choisi de jouer Ã  "Swamp" - cela ferme la possibilitÃ© de jouer cette carte comme une action d'hÃ©ritage potentielle (parce que "Swamp" a dÃ©jÃ  Ã©tÃ© jouÃ©), ferme la possibilitÃ© de jouer Ã  "Forest" (parce que les rÃ¨gles du jeu vous permettent de jouer une seule carte de terrain par tour) et ajoute la possibilitÃ© de toucher le Â«maraisÂ» pour obtenir 1 point de mana noir - et c'est en fait la seule action hÃ©ritÃ©e. </font><font style="vertical-align: inherit;">Si nous faisons un pas de plus et sÃ©lectionnons "toucher" Marais "", nous obtiendrons 1 point de mana noir avec lequel nous ne pouvons rien faire, donc c'est inutile.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jouez "Swamp" (rÃ©sultat: "Swamp" quitte la main et entre dans le jeu)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Touchez Â«SwampÂ» (rÃ©sultat: nous avons touchÃ© Â«SwampÂ», +1 mana noir est disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Aucune action restante - FIN</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jouez Ã  "Forest" (rÃ©sultat: "Forest" quitte la main et entre dans le jeu) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette courte liste d'actions ne nous a pas donnÃ© grand-chose et a conduit Ã  une Â«impasseÂ», si nous utilisons l'analogie avec la recherche de chemins. </font><font style="vertical-align: inherit;">Par consÃ©quent, nous rÃ©pÃ©tons le processus pour l'Ã©tape suivante. </font><font style="vertical-align: inherit;">Nous choisissons de jouer Ã  Forest. </font><font style="vertical-align: inherit;">Cela supprime Ã©galement la possibilitÃ© de Â«jouer Ã  ForestÂ» et de Â«jouer Ã  SwampÂ», et ouvre comme une prochaine Ã©tape potentielle (et unique) Â«toucher la forÃªtÂ». </font><font style="vertical-align: inherit;">Cela nous donne 1 point de mana vert, qui Ã  son tour ouvre la troisiÃ¨me Ã©tape - "appelez" Elven Mystic "."</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Jouez "Swamp" (rÃ©sultat: "Swamp" quitte la main et entre dans le jeu)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Touchez Â«SwampÂ» (rÃ©sultat: nous avons touchÃ© Â«SwampÂ», +1 mana noir est disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Aucune action restante - FIN</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Jouez Ã  "Forest" (rÃ©sultat: "Forest" quitte la main et entre dans le jeu)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            2.1 Touchez Â«ForÃªtÂ» (rÃ©sultat: nous avons touchÃ© Â«MaraisÂ», +1 de mana vert est disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        2.1.1 Appelez "Elven Mystic" (rÃ©sultat: "Elven Mystic" dans le jeu, -1 mana vert est disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                                    Aucune action restante - FIN </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons Ã©tudiÃ© toutes les actions et actions possibles rÃ©sultant de ces actions, en trouvant un plan qui nous permet d'invoquer la crÃ©ature: "jouer la forÃªt", "toucher la forÃªt", "appeler le" Elven Mystic "". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute Ã©vidence, ceci est un exemple trÃ¨s simplifiÃ©, et gÃ©nÃ©ralement vous devez choisir le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meilleur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un plan, et pas seulement un plan qui satisfait certains critÃ¨res (par exemple, Â«invoquer une crÃ©atureÂ»). Vous pouvez gÃ©nÃ©ralement Ã©valuer les plans potentiels en fonction du rÃ©sultat final ou des avantages cumulatifs de l'utilisation du plan. Par exemple, vous pouvez vous donner 1 point pour une carte terrestre amÃ©nagÃ©e et 3 points pour appeler une crÃ©ature. "Jouer" Swamp "" sera un plan court donnant 1 point, et le plan "jouer" Forest "â†’ toucher" Forest "â†’ appeler" Elven Mystic "" donne 4 points, 1 pour le sol et 3 pour la crÃ©ature. Ce sera le plan le plus rentable disponible, vous devriez donc le choisir si nous avons nommÃ© de tels points.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ci-dessus, nous avons montrÃ© comment la planification fonctionne dans le mÃªme mouvement Magic: The Gathering, mais elle peut Ã©galement Ãªtre appliquÃ©e Ã  des actions dans une sÃ©rie de mouvements (par exemple, "dÃ©placer un pion pour donner de la place au dÃ©veloppement de l'Ã©vÃªque" aux Ã©checs ou "courir Ã  couvert pour une unitÃ©"). pourrait tirer le tour suivant, en Ã©tant en sÃ©curitÃ© "dans XCOM) ou Ã  la stratÃ©gie gÃ©nÃ©rale de tout le jeu (par exemple," construire des pylÃ´nes pour tous les autres bÃ¢timents protoss "dans Starcraft, ou" boire une potion Fortify Health avant d'attaquer l'ennemi "dans Skyrim). </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planification amÃ©liorÃ©e </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, il y a trop d'actions possibles Ã  chaque Ã©tape, et Ã©valuer chaque option est dÃ©raisonnable. Revenons Ã  l'exemple de Magic: The Gathering - imaginez que nous avons plusieurs crÃ©atures en main, de nombreux terrains ont dÃ©jÃ  Ã©tÃ© jouÃ©s, afin que nous puissions appeler n'importe quelle crÃ©ature, plusieurs crÃ©atures avec leurs capacitÃ©s jouÃ©es, et il y a quelques autres cartes de terrain en main - le nombre de permutations la terre, l'utilisation des terres, l'invocation de crÃ©atures et l'utilisation des capacitÃ©s des crÃ©atures peuvent reprÃ©senter des milliers, voire des dizaines de milliers. Heureusement, il existe deux faÃ§ons de rÃ©soudre ce problÃ¨me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier est appelÃ© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaÃ®nage arriÃ¨re</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"(" Aller-retour "). Au lieu de vÃ©rifier toutes les actions et leurs rÃ©sultats, nous pouvons commencer par chacun des rÃ©sultats finaux souhaitÃ©s et voir si nous pouvons trouver un chemin direct vers eux. Vous pouvez comparer cela en essayant d'atteindre une feuille spÃ©cifique dans un arbre - c'est beaucoup plus logique partir de cette feuille et revenir en arriÃ¨re, en Ã©tablissant un itinÃ©raire le long du tronc (et cet itinÃ©raire nous pouvons ensuite aller dans l'ordre inverse), que de partir du tronc et d'essayer de deviner quelle branche choisir Ã  chaque Ã©tape. Si vous partez de la fin et allez dans la direction opposÃ©e, puis crÃ©Ã© e plan sera beaucoup plus rapide et plus facile.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, s'il reste 1 point de vie Ã  l'ennemi, il peut Ãªtre utile d'essayer de trouver un plan pour Â«infliger 1 ou plusieurs points de dÃ©gÃ¢ts directs Ã  l'ennemiÂ». Notre systÃ¨me sait que pour atteindre cet objectif, il doit lancer un sort de dÃ©gÃ¢ts directs, ce qui signifie qu'il doit Ãªtre entre nos mains et nous avons besoin de suffisamment de mana pour le prononcer. Cela signifie que nous devons toucher suffisamment de terrain pour recevoir ce mana, ce qui peut vous obliger Ã  jouer une carte de terrain supplÃ©mentaire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre faÃ§on consiste Ã  rechercher par la premiÃ¨re meilleure correspondance. Au lieu de parcourir toutes les permutations pendant une longue pÃ©riode, nous mesurons la qualitÃ© de chaque plan partiel (similaire Ã  la faÃ§on dont nous avons choisi les options de plan ci-dessus) et calculons le plus beau Ã  chaque fois. Souvent, cela vous permet de crÃ©er un plan optimal, ou du moins assez bon, sans avoir Ã  considÃ©rer chaque rÃ©arrangement possible des plans. A * est une variante de la recherche du premier meilleur match - il explore d'abord les itinÃ©raires les plus prometteurs, de sorte qu'il peut gÃ©nÃ©ralement trouver le chemin vers l'objectif sans avoir Ã  monter trop loin dans d'autres directions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une option de recherche intÃ©ressante et de plus en plus populaire pour la premiÃ¨re meilleure correspondance est la recherche d'arbre </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Monte Carlo</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au lieu de deviner quels plans sont meilleurs que d'autres lors du choix de chaque action subsÃ©quente, cette mÃ©thode choisit des actions subsÃ©quentes alÃ©atoires Ã  chaque Ã©tape jusqu'Ã  ce qu'elle atteigne la fin oÃ¹ aucune action n'est plus possible - probablement parce que le plan hypothÃ©tique a conduit Ã  un Ã©tat de victoire ou de perte. - et utilise ce rÃ©sultat pour donner plus ou moins de poids aux options sÃ©lectionnÃ©es prÃ©cÃ©dentes. Si le processus est rÃ©pÃ©tÃ© plusieurs fois, la mÃ©thode peut crÃ©er une bonne Ã©valuation de la meilleure Ã©tape suivante, mÃªme si la situation change (par exemple, si l'ennemi essaie de contrecarrer nos plans). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, aucune discussion sur la planification dans les jeux ne serait complÃ¨te sans mentionner la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planification des actions basÃ©e sur les objectifs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Planification des actions axÃ©es sur les objectifs, GOAP). </font><font style="vertical-align: inherit;">Il s'agit d'une technique largement utilisÃ©e et largement discutÃ©e, mais si vous ignorez quelques dÃ©tails d'implÃ©mentation spÃ©cifiques, il s'agit essentiellement d'un planificateur aller-retour qui commence par un objectif et essaie de sÃ©lectionner une action menant Ã  cet objectif, ou, plus probablement, une liste d'actions qui mÃ¨ne Ã  au but. </font><font style="vertical-align: inherit;">Par exemple, si le but Ã©tait de Â«tuer le joueurÂ» et que le joueur Ã©tait Ã  couvert, alors le plan pourrait Ãªtre: Â«Fumer le joueur avec une grenadeÂ» â†’ Â«Sortir une armeÂ» â†’ Â«AttaquerÂ».</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a gÃ©nÃ©ralement plusieurs objectifs, et chacun a sa propre prioritÃ©. </font><font style="vertical-align: inherit;">Si les objectifs avec la prioritÃ© la plus Ã©levÃ©e ne peuvent pas Ãªtre atteints, par exemple, aucun ensemble d'actions ne peut former le plan "Tuer le joueur" parce que le joueur n'est pas visible, alors le systÃ¨me revient aux objectifs avec des prioritÃ©s plus faibles, par exemple, "Patrouille" ou "Garde sur place".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formation et adaptation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au dÃ©but de l'article, nous avons mentionnÃ© que l'IA de jeu n'utilise gÃ©nÃ©ralement pas le Â«machine learningÂ» car elle n'est gÃ©nÃ©ralement pas adaptÃ©e au contrÃ´le en temps rÃ©el d'agents intelligents dans le monde du jeu. </font><font style="vertical-align: inherit;">Cependant, cela ne signifie pas que nous ne pouvons pas emprunter quelque chose dans ce domaine oÃ¹ cela a du sens. </font><font style="vertical-align: inherit;">Nous pourrions avoir besoin d'un adversaire informatique dans le jeu de tir pour trouver les meilleurs endroits oÃ¹ se dÃ©placer pour obtenir le plus de victimes. </font><font style="vertical-align: inherit;">Ou nous pourrions vouloir l'adversaire dans un jeu de combat. </font><font style="vertical-align: inherit;">par exemple, dans Tekken ou Street Fighter, il a appris Ã  reconnaÃ®tre un joueur utilisant les mÃªmes combos pour commencer Ã  les bloquer, forÃ§ant le joueur Ã  utiliser des tactiques diffÃ©rentes. </font><font style="vertical-align: inherit;">Autrement dit, il y a des moments oÃ¹ un certain pourcentage de l'apprentissage automatique est utile.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Statistiques et probabilitÃ©s </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de passer Ã  des exemples plus complexes, il convient de dÃ©terminer jusqu'oÃ¹ nous pouvons aller en prenant simplement des mesures et en utilisant ces donnÃ©es pour prendre des dÃ©cisions. Par exemple, disons que nous avons un jeu dans le genre de la stratÃ©gie en temps rÃ©el, et nous devons comprendre si le joueur commencera Ã  se prÃ©cipiter dans les premiÃ¨res minutes pour dÃ©cider de construire plus de dÃ©fense. Nous pouvons extrapoler le comportement antÃ©rieur du joueur pour comprendre quel pourrait Ãªtre le comportement futur. Au dÃ©but, nous ne disposons pas de donnÃ©es extrapolables, mais chaque fois que l'IA joue contre un ennemi vivant, elle peut enregistrer l'heure de la premiÃ¨re attaque. AprÃ¨s quelques matchs, ce temps peut Ãªtre moyennÃ©, et nous obtiendrons une assez bonne approximation du temps d'attaque du joueur Ã  l'avenir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problÃ¨me avec la moyenne simple est qu'elle converge gÃ©nÃ©ralement avec le temps au centre. Par consÃ©quent, si un joueur a utilisÃ© la stratÃ©gie rush les 20 premiÃ¨res fois et que les 20 prochaines fois sont passÃ©s Ã  une stratÃ©gie beaucoup plus lente, la valeur moyenne sera quelque part au milieu, ce qui ne nous donnera aucune information utile. Une faÃ§on d'amÃ©liorer les donnÃ©es consiste Ã  utiliser une fenÃªtre de calcul de moyenne simple qui ne prend en compte que les 20 derniers points de donnÃ©es.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une approche similaire peut Ãªtre utilisÃ©e pour Ã©valuer la probabilitÃ© de certaines actions, en supposant que les prÃ©fÃ©rences prÃ©cÃ©dentes du joueur continueront Ã  l'avenir. Par exemple, si un joueur a attaquÃ© cinq fois avec une boule de feu, deux fois avec la foudre et au corps Ã  corps une seule fois, il prÃ©fÃ©rerait probablement une boule de feu 5 fois sur 8. En extrapolant Ã  partir de ces donnÃ©es, nous pouvons voir que la probabilitÃ© d'utiliser une arme est: Fireball = 62,5%, Lightning = 25% Melee = 12,5%. Nos personnages de l'IA se rendront compte qu'ils feraient mieux de trouver une armure ignifuge!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre mÃ©thode intÃ©ressante consiste Ã  utiliser le Naive Bayes Classifier pour Ã©tudier de grands volumes de donnÃ©es d'entrÃ©e afin de classer la situation actuelle afin que l'agent AI puisse rÃ©pondre en consÃ©quence. Les classificateurs bayÃ©siens sont probablement mieux connus pour leur utilisation dans les filtres de courrier indÃ©sirable, oÃ¹ ils Ã©valuent les mots dans le courrier Ã©lectronique, les comparent avec les mots qui ont Ã©tÃ© le plus souvent trouvÃ©s dans le spam et les messages normaux dans le passÃ©. Sur la base de ces calculs, ils dÃ©cident de la probabilitÃ© que le dernier message reÃ§u soit du spam. Nous pouvons faire quelque chose de similaire, mais avec moins d'entrÃ©e. En enregistrant toutes les informations utiles observables (par exemple, les unitÃ©s ennemies crÃ©Ã©es,sorts utilisÃ©s ou technologies de recherche) et en suivant la situation qui en rÃ©sulte (guerre / paix, stratÃ©gie de rush / stratÃ©gie de dÃ©fense, etc.), nous pouvons sÃ©lectionner le comportement appropriÃ© en fonction de cela.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de toutes ces techniques d'enseignement peut Ãªtre suffisante et souvent et de prÃ©fÃ©rence appliquÃ©e aux donnÃ©es collectÃ©es pendant les tests de jeu avant la sortie du jeu. </font><font style="vertical-align: inherit;">Cela permet Ã  l'IA de s'adapter aux diffÃ©rentes stratÃ©gies utilisÃ©es par les testeurs de jeu et de ne pas changer aprÃ¨s la sortie du jeu. </font><font style="vertical-align: inherit;">Une IA qui s'adapte Ã  un joueur aprÃ¨s la sortie d'un jeu peut devenir trop prÃ©visible ou mÃªme trop complexe pour Ãªtre vaincue.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adaptation facile basÃ©e sur le poids </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allons plus loin. </font><font style="vertical-align: inherit;">Au lieu d'utiliser simplement les donnÃ©es d'entrÃ©e pour choisir entre des stratÃ©gies prÃ©dÃ©finies discrÃ¨tes, vous pouvez modifier l'ensemble de valeurs qui influencent la prise de dÃ©cision. </font><font style="vertical-align: inherit;">Si nous comprenons bien le monde du jeu et les rÃ¨gles du jeu, alors nous pouvons faire ce qui suit:</font></font><br><br><ul><li>              (   ); </li><li>    Â«Â»       ; </li><li>         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez un agent informatique qui peut sÃ©lectionner des piÃ¨ces sur une carte dans un jeu de tir Ã  la premiÃ¨re personne. Chaque piÃ¨ce a un poids qui dÃ©termine l'opportunitÃ© de visiter cette piÃ¨ce. Au dÃ©part, toutes les chambres ont la mÃªme signification. Lors du choix d'une piÃ¨ce, l'IA la sÃ©lectionne au hasard, mais avec l'influence de ces poids. Imaginez maintenant que lorsqu'un agent informatique est tuÃ©, il se souvienne dans quelle piÃ¨ce cela se produit et rÃ©duit son poids afin qu'il soit moins susceptible d'y retourner Ã  l'avenir. De mÃªme, imaginez qu'un agent informatique a commis un meurtre. Ensuite, il peut augmenter le poids de la piÃ¨ce dans laquelle il se trouve afin de le soulever dans la liste des prÃ©fÃ©rences. Donc, si une piÃ¨ce devient particuliÃ¨rement dangereuse pour le joueur IA, alors il commence Ã  l'Ã©viter Ã  l'avenir, et si une autre piÃ¨ce permet Ã  l'IA d'obtenir beaucoup de tueries,puis il y retournera.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ModÃ¨les Markov </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si nous voulions utiliser les donnÃ©es que nous avons collectÃ©es pour faire des prÃ©visions? </font><font style="vertical-align: inherit;">Par exemple, si nous enregistrons chaque piÃ¨ce dans laquelle nous voyons un joueur pendant une certaine pÃ©riode de temps, nous pouvons raisonnablement prÃ©dire dans quelle piÃ¨ce il peut passer. </font><font style="vertical-align: inherit;">En suivant Ã  la fois la piÃ¨ce actuelle dans laquelle se trouve le joueur et la prÃ©cÃ©dente, et en enregistrant ces paires de valeurs, nous pouvons calculer la frÃ©quence Ã  laquelle chacune des situations prÃ©cÃ©dentes mÃ¨ne Ã  la situation suivante et utiliser ces connaissances pour les prÃ©visions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez qu'il y ait trois salles - rouge, verte et bleue, et que pendant la session de jeu nous avons reÃ§u de telles observations:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premiÃ¨re piÃ¨ce dans laquelle le joueur est vu</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total des observations</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chambre suivante</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combien de fois vu</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourcentage</font></font></b> <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rouge </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rouge </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vert </font></font><br><br></td><td>  7 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bleu </font></font><br><br></td><td>  1 <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vert </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rouge </font></font><br><br></td><td>  3 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vert </font></font><br><br></td><td>  5 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bleu </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bleu </font></font><br><br></td><td rowspan="3">  8 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rouge </font></font><br><br></td><td>  6 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 75% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vert </font></font><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bleu </font></font><br><br></td><td>  0 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0% </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de dÃ©tections dans chacune des chambres est assez uniforme, donc cela ne nous permet pas de savoir laquelle des chambres peut Ãªtre un bon endroit pour une embuscade. Les donnÃ©es peuvent Ãªtre dÃ©formÃ©es par le fait que les joueurs apparaissent uniformÃ©ment sur la carte, avec une probabilitÃ© Ã©gale d'apparaÃ®tre dans l'une de ces trois salles. Mais les donnÃ©es sur la visite de la </font><font style="vertical-align: inherit;">piÃ¨ce </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voisine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peuvent Ãªtre utiles et nous aider Ã  prÃ©voir le mouvement du joueur sur la carte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons immÃ©diatement remarquer que la salle verte est trÃ¨s attrayante pour les joueurs - la plupart des joueurs de la salle rouge sont passÃ©s au vert, et 50% des joueurs vus dans la salle verte restent lÃ  lors du prochain contrÃ´le. On peut Ã©galement remarquer que la chambre bleue est un endroit plutÃ´t peu attrayant. Les gens passent rarement des piÃ¨ces rouges ou vertes au bleu et il semble que personne n'aime s'y attarder longtemps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais les donnÃ©es nous disent quelque chose de plus spÃ©cifique - elles disent que lorsqu'un joueur est dans la salle bleue, puis la suivant, il est plus susceptible de choisir le rouge plutÃ´t que le vert. MalgrÃ© le fait que la salle verte est un endroit beaucoup plus populaire que la rouge, la tendance est lÃ©gÃ¨rement opposÃ©e si le joueur est dans la salle bleue. Il semble que l'Ã©tat suivant (c'est-Ã -dire la piÃ¨ce dans laquelle il dÃ©cide d'aller plus loin) dÃ©pend de l'Ã©tat prÃ©cÃ©dent (c'est-Ã -dire la piÃ¨ce dans laquelle il se trouve maintenant), donc ces donnÃ©es nous permettent de crÃ©er de meilleures prÃ©visions sur le comportement des joueurs qu'avec un comptage d'observation indÃ©pendant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette idÃ©e que nous pouvons utiliser la connaissance de l'Ã©tat prÃ©cÃ©dent pour prÃ©dire l'Ã©tat futur s'appelle le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modÃ¨le de Markov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et des exemples similaires dans lesquels nous avons mesurÃ© avec prÃ©cision des Ã©vÃ©nements (par exemple, "dans quelle piÃ¨ce le joueur est") sont appelÃ©s chaÃ®nes de Markov. Puisqu'ils reprÃ©sentent la probabilitÃ© d'une transition entre Ã©tats successifs, ils sont souvent reprÃ©sentÃ©s graphiquement sous la forme d'une machine Ã  Ã©tats finis, Ã  proximitÃ© de chaque transition dont sa probabilitÃ© est indiquÃ©e. Auparavant, nous utilisions une machine Ã  Ã©tats pour reprÃ©senter l'Ã©tat de comportement dans lequel se trouve l'agent, mais ce concept peut Ãªtre Ã©tendu Ã  toutes sortes d'Ã©tats, qu'ils soient associÃ©s ou non Ã  l'agent. Dans notre cas, les Ã‰tats indiquent les chambres occupÃ©es par l'agent. Cela ressemblera Ã  ceci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/53b/691/e4353b691807e7476a2255f91dc2f248.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une approche simple pour indiquer la probabilitÃ© relative de transition vers diffÃ©rents Ã©tats, ce qui donne Ã  l'IA la capacitÃ© de prÃ©dire l'Ã©tat suivant. </font><font style="vertical-align: inherit;">Mais nous pouvons aller plus loin en crÃ©ant un systÃ¨me qui envisage l'avenir en deux ou plusieurs Ã©tapes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si un joueur a Ã©tÃ© repÃ©rÃ© dans la salle verte, nous utiliserons des donnÃ©es qui nous indiquent qu'il y a 50% de chances qu'il soit toujours dans la salle verte lors de la prochaine observation. </font><font style="vertical-align: inherit;">Mais quelle est la probabilitÃ© qu'il y reste pour la troisiÃ¨me fois? </font><font style="vertical-align: inherit;">Ce n'est pas seulement la probabilitÃ© qu'il reste dans la salle verte pour deux observations (50% * 50% = 25%), mais aussi la probabilitÃ© qu'il le quitte et revienne. </font><font style="vertical-align: inherit;">Voici un nouveau tableau avec des valeurs prÃ©cÃ©dentes appliquÃ©es Ã  trois observations: une actuelle et deux hypothÃ©tiques dans le futur.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observation 1</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observation hypothÃ©tique 2</font></font></b> <br><br></td><td> <b>  </b> <br><br></td><td> <b>  3</b> <br><br></td><td> <b>  </b> <br><br></td><td> <b> </b> <br><br></td></tr><tr><td rowspan="10">  <br></td><td rowspan="3">  <br><br></td><td rowspan="3"> 30% <br><br></td><td>  <br><br></td><td> 20% <br><br></td><td>  6% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 70% <br><br></td><td> <b>21%</b> <br><br></td></tr><tr><td>  <br><br></td><td>  10% <br><br></td><td>  3% <br><br></td></tr><tr><td rowspan="3">  <br></td><td rowspan="3"> 50% <br><br></td><td>  <br><br></td><td> 30% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 50% <br><br></td><td> <b>25%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 20% <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3">  <br><br></td><td rowspan="3"> 20% <br><br></td><td>  <br><br></td><td> 75% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 25% <br><br></td><td>  <b>5%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 0% <br><br></td><td> 0% <br><br></td></tr><tr><td></td><td></td><td></td><td> <i>:</i> <br><br></td><td>  100% </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous voyons que la probabilitÃ© de voir un joueur dans la salle verte aprÃ¨s 2 observations est de 51% - 21% de ce qu'il viendra de la salle rouge, 5% de ce que nous voyons le joueur visiter la salle bleue et 25% de ce qu'il est tout le temps restera dans la salle verte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tableau n'est qu'un indice visuel; une procÃ©dure ne nÃ©cessite qu'une multiplication des probabilitÃ©s Ã  chaque Ã©tape. Cela signifie que nous pouvons regarder loin dans l'avenir, mais avec une mise en garde importante: nous faisons l'hypothÃ¨se que la probabilitÃ© d'entrer dans une piÃ¨ce dÃ©pend entiÃ¨rement de la piÃ¨ce dans laquelle nous nous trouvons en ce moment. Cette idÃ©e que l'Ã©tat futur ne dÃ©pend que du courant est appelÃ©e la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriÃ©tÃ© Markov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bien qu'il nous permette d'utiliser des outils puissants tels que les chaÃ®nes de Markov, ce n'est gÃ©nÃ©ralement qu'une approximation. </font><font style="vertical-align: inherit;">Les joueurs peuvent dÃ©cider de visiter les salles en fonction d'autres facteurs, tels que leur niveau de santÃ© et la quantitÃ© de munitions, et comme nous n'enregistrons pas ces informations dans le cadre de la condition, nos prÃ©visions seront moins prÃ©cises.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N grammes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons Ã  notre exemple avec la reconnaissance combinÃ©e dans un jeu de combat. Il s'agit d'une situation similaire dans laquelle nous voulons prÃ©dire l'Ã©tat futur en fonction du passÃ© (afin de dÃ©cider comment bloquer une attaque ou l'esquiver), mais au lieu d'Ã©tudier un seul Ã©tat ou Ã©vÃ©nement, nous considÃ©rerons des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sÃ©quences d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ã©vÃ©nements qui crÃ©ent un mouvement combo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une faÃ§on de procÃ©der consiste Ã  enregistrer chaque entrÃ©e de joueur (par exemple, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dans le tampon et Ã  Ã©crire le tampon entier en tant qu'Ã©vÃ©nement. Imaginez qu'un joueur appuie constamment sur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied</font></i><font style="vertical-align: inherit;"> pour utiliser l'attaque Â« </font><i><font style="vertical-align: inherit;">Death Cancer</font></i><font style="vertical-align: inherit;"> Â»</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", et le systÃ¨me d'IA enregistre toutes les entrÃ©es du joueur dans le tampon et se souvient des 3 derniÃ¨res entrÃ©es utilisÃ©es Ã  chaque Ã©tape. </font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrer</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une sÃ©quence d'entrÃ©e existante</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle mÃ©moire d'entrÃ©e</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td>  <i>non</i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de main </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick </font></font><br><br></td><td>  <i>non</i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick, Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coup de main</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coup de pied, coup de pied, coup de pied, coup de pied, coup de pied</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick, Kick, Kick</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloquer </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied, coup de pied, coup de pied, coup de pied, coup de pied, bloc </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Block </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup, Coup, Coup, Coup, Coup, Coup, Bloc, Coup </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied, blocage, coup de pied </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup de pied </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coup, Coup, Coup, Coup, Coup, Coup, Bloc, Coup, Coup </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloquer, botter, botter </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coup de main</font></font></b> <br><br></td><td> <b> ,  ,  ,  ,  , ,  ,  ,  </b> <br><br></td><td> <b> ,  ,  </b> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(En gras, le joueur effectue l'attaque Â«Superbuck of DeathÂ».) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez regarder toutes ces fois oÃ¹ le joueur a choisi un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied</font></i><font style="vertical-align: inherit;"> dans le passÃ© </font><font style="vertical-align: inherit;">, suivi d'un autre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et notez que la prochaine entrÃ©e est toujours un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela permet Ã  l'agent de l'IA de prÃ©dire que si un joueur vient de choisir un coup de pied, suivi d'un coup de pied, il sÃ©lectionnera trÃ¨s probablement un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suivant </font><font style="vertical-align: inherit;">, lanÃ§ant ainsi le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Death Superkulak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela permet Ã  l'IA de dÃ©cider de choisir une action qui contrecarre ce coup, comme bloquer ou esquiver. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De telles sÃ©quences d'Ã©vÃ©nements sont appelÃ©es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-grammes.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oÃ¹ N est le nombre d'Ã©lÃ©ments stockÃ©s. Dans l'exemple prÃ©cÃ©dent, il s'agissait de 3 grammes, Ã©galement appelÃ©s trigrammes, c'est-Ã -dire que les 2 premiers Ã©lÃ©ments sont utilisÃ©s pour prÃ©dire le troisiÃ¨me. Dans le 5 grammes, le cinquiÃ¨me est prÃ©vu pour les 4 premiers Ã©lÃ©ments, et ainsi de suite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les dÃ©veloppeurs doivent soigneusement choisir la taille des N-grammes (parfois appelÃ©e commande). Plus le nombre est petit, moins la mÃ©moire est nÃ©cessaire, car plus le nombre de permutations autorisÃ©es est petit, mais moins l'historique est sauvegardÃ©, ce qui signifie que le contexte est perdu. Par exemple, un 2 grammes (Ã©galement appelÃ© Â«bigrammeÂ») contiendra des enregistrements de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coups</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied</font></i><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coups de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et des enregistrements de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coups</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied</font></i><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coups de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais ne peut pas enregistrer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">coup de </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par consÃ©quent, ne peut pas suivre ce combo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En revanche, plus la commande est grande, plus la mÃ©moire est importante et le systÃ¨me sera probablement plus difficile Ã  entraÃ®ner, car nous aurons beaucoup plus de permutations possibles, ce qui signifie que nous ne pourrons jamais nous rencontrer deux fois de la mÃªme maniÃ¨re. Par exemple, s'il y a trois entrÃ©es possibles ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coup de pied</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et que nous utilisons un 10 grammes, il y aura prÃ¨s de 60 000 permutations diffÃ©rentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le modÃ¨le de bigramme est essentiellement une chaÃ®ne triviale de Markov - chaque paire Â«Ã©tat futur / Ã©tat actuelÂ» est un bigramme et nous pouvons prÃ©dire le deuxiÃ¨me Ã©tat en fonction du premier. Les trigrammes et les grands N-grammes peuvent Ã©galement Ãªtre considÃ©rÃ©s comme des chaÃ®nes de Markov, oÃ¹ tous les Ã©lÃ©ments du N-gramme, Ã  l'exception du dernier, forment le premier Ã©tat, et le dernier Ã©lÃ©ment est le deuxiÃ¨me Ã©tat. Dans notre exemple de jeu de combat, la probabilitÃ© de transition de l'Ã©tat de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coups</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied et de coups</font></i><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied</font></i><font style="vertical-align: inherit;"> Ã  l'Ã©tat de </font><i><font style="vertical-align: inherit;">coups</font></i><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">pied, puis de coups de pied</font></i><font style="vertical-align: inherit;"> est prÃ©sentÃ©e</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En percevant plusieurs Ã©lÃ©ments de l'historique d'entrÃ©e comme un seul Ã©lÃ©ment, nous transformons essentiellement la sÃ©quence d'entrÃ©e en un fragment de l'Ã©tat, ce qui nous donne une propriÃ©tÃ© Markov, nous permettant d'utiliser des chaÃ®nes de Markov pour prÃ©dire l'entrÃ©e suivante, c'est-Ã -dire en devinant quel mouvement combo suivra.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ReprÃ©sentation des connaissances </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons discutÃ© de plusieurs faÃ§ons de prendre des dÃ©cisions, de crÃ©er des plans et des prÃ©visions, et toutes sont basÃ©es sur les observations de lâ€™agent sur lâ€™Ã©tat du monde. </font><font style="vertical-align: inherit;">Mais comment observer efficacement l'ensemble du monde du jeu? </font><font style="vertical-align: inherit;">Ci-dessus, nous avons vu que la faÃ§on de reprÃ©senter la gÃ©omÃ©trie du monde affecte grandement le mouvement le long de celui-ci, il est donc facile d'imaginer que cela est vrai pour d'autres aspects de l'IA du jeu. </font><font style="vertical-align: inherit;">Comment collecter et organiser toutes les informations nÃ©cessaires de maniÃ¨re optimale (afin qu'elles soient souvent mises Ã  jour et accessibles Ã  de nombreux agents) et pratiques (afin que les informations puissent Ãªtre facilement utilisÃ©es dans le processus dÃ©cisionnel)? </font><font style="vertical-align: inherit;">Comment transformer des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donnÃ©es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples </font><font style="vertical-align: inherit;">en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connaissances</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Pour diffÃ©rents jeux, les solutions peuvent Ãªtre diffÃ©rentes, mais il existe plusieurs approches les plus populaires.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tags / Tags </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, nous avons dÃ©jÃ  une Ã©norme quantitÃ© de donnÃ©es utiles, et la seule chose dont nous avons besoin est un bon moyen de les classer et de les rechercher. Par exemple, dans le monde du jeu, il peut y avoir de nombreux objets, et certains d'entre eux sont un bon abri contre les balles ennemies. Ou, par exemple, nous avons un tas de dialogues audio enregistrÃ©s qui sont applicables dans des situations spÃ©cifiques, et nous avons besoin d'un moyen de les comprendre rapidement. L'Ã©tape Ã©vidente consiste Ã  ajouter une petite information supplÃ©mentaire que vous pouvez utiliser pour effectuer une recherche. Ces fragments sont appelÃ©s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balises</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou balises.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons Ã  l'exemple du refuge; dans le monde du jeu, il peut y avoir un tas d'objets - des boÃ®tes, des tonneaux, des tas d'herbe, des grillages. Certains d'entre eux conviennent Ã  l'abri, par exemple, des boÃ®tes et des barils, d'autres non. Par consÃ©quent, lorsque notre agent effectue l'action Â«DÃ©placer vers un abriÂ», il doit rechercher des objets Ã  proximitÃ© et identifier les candidats appropriÃ©s. Il ne peut pas simplement rechercher par nom - peut-Ãªtre que le jeu a Crate_01, Crate_02, jusqu'Ã  Crate_27, et nous ne voulons pas chercher tous ces noms dans le code. Nous ne voulons pas ajouter un autre nom au code chaque fois que l'artiste crÃ©e une nouvelle variation de la boÃ®te ou du baril. Au lieu de cela, vous pouvez rechercher n'importe quel nom contenant le mot "Crate", mais un jour, un artiste peut ajouter "Broken_Crate" avec un Ã©norme trou, inadaptÃ© comme abri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par consÃ©quent, au lieu de cela, nous allons crÃ©er une balise Â«COVERÂ» et demander aux artistes et aux designers d'attacher cette balise Ã  tous les objets qui peuvent Ãªtre utilisÃ©s comme abri. S'ils ajoutent une balise Ã  tous les barils et boÃ®tes (entiÃ¨res), alors la procÃ©dure AI n'aura qu'Ã  trouver des objets avec cette balise, et elle saura que les objets conviennent Ã  cet effet. La balise fonctionnera mÃªme si les objets sont renommÃ©s ultÃ©rieurement, et elle peut Ãªtre ajoutÃ©e aux objets Ã  l'avenir sans apporter de modifications inutiles au code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le code, les balises sont gÃ©nÃ©ralement reprÃ©sentÃ©es sous forme de chaÃ®nes, mais si toutes les balises utilisÃ©es sont connues, vous pouvez convertir des chaÃ®nes en nombres uniques pour Ã©conomiser de l'espace et accÃ©lÃ©rer la recherche. Dans certains moteurs, les balises sont des fonctionnalitÃ©s intÃ©grÃ©es, par exemple, dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par consÃ©quent, il suffit de dÃ©terminer le choix des balises et de les utiliser conformÃ©ment Ã  leur destination. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objets intelligents </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les balises sont un moyen d'ajouter des informations supplÃ©mentaires Ã  l'environnement de l'agent, pour l'aider Ã  comprendre les options disponibles, afin que les demandes comme Â«Trouvez-moi tous les endroits les plus proches oÃ¹ se cacherÂ» ou Â«Trouvez-moi tous les ennemis Ã  proximitÃ© qui peuvent lancer des sortsÂ» soient exÃ©cutÃ©es efficacement et avec un minimum d'effort travaillÃ© pour de nouvelles ressources de jeu. </font><font style="vertical-align: inherit;">Mais parfois, les balises ne contiennent pas suffisamment d'informations pour leur utilisation complÃ¨te.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez un simulateur d'une ville mÃ©diÃ©vale dans laquelle les aventuriers errent oÃ¹ ils veulent, si nÃ©cessaire, s'entraÃ®nent, se battent et se dÃ©tendent. Nous pouvons organiser des sites d'entraÃ®nement dans diffÃ©rentes parties de la ville et leur attribuer le tag "FORMATION" afin que les personnages puissent facilement trouver un lieu d'entraÃ®nement. Mais imaginons que l'un d'eux soit un champ de tir pour les archers, et l'autre une Ã©cole de sorciers. Dans chacun de ces cas, nous devons montrer notre animation, car sous le nom gÃ©nÃ©ral de "formation", ils reprÃ©sentent diffÃ©rentes actions, et tous les aventuriers ne sont pas intÃ©ressÃ©s par les deux types de formation. Vous pouvez aller encore plus loin et crÃ©er des tags ARCHERY-TRAINING et MAGIC-TRAINING, sÃ©parer les procÃ©dures d'entraÃ®nement les unes des autres et les intÃ©grer dans chaque animation diffÃ©rente. Cela vous aidera Ã  rÃ©soudre le problÃ¨me. Mais imaginezque les concepteurs dÃ©clareront plus tard "Ayons une Ã©cole Robin Hood oÃ¹ vous pourrez apprendre le tir Ã  l'arc et le combat Ã  l'Ã©pÃ©e"! Et puis, lorsque nous ajoutons le combat Ã  l'Ã©pÃ©e, ils demandent la crÃ©ation de l'AcadÃ©mie des sorts et du combat Ã  l'Ã©pÃ©e de Gandalf. En consÃ©quence, nous devrons stocker plusieurs balises pour chaque endroit et rechercher diffÃ©rentes animations en fonction de l'aspect de la formation dont le personnage a besoin, etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre faÃ§on consiste Ã  stocker des informations directement dans l'objet ainsi que l'influence qu'elle a sur le joueur, afin que l'acteur IA puisse simplement lister les options possibles et choisir parmi celles-ci en fonction des besoins de l'agent. </font><font style="vertical-align: inherit;">AprÃ¨s cela, il peut se dÃ©placer Ã  l'endroit appropriÃ©, effectuer les animations appropriÃ©es (ou toute autre action obligatoire), comme indiquÃ© dans l'objet, et recevoir la rÃ©compense appropriÃ©e.</font></font><br><br><table><tbody><tr><td><br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation en cours</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RÃ©sultat utilisateur</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ de tir</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FlÃ¨che de tir </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 compÃ©tence tir Ã  l'arc </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã‰cole de magie</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duel Ã  l'Ã©pÃ©e </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 CompÃ©tence Ã‰pÃ©es </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã‰cole Robin Hood</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FlÃ¨che de tir </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +15 compÃ©tence tir Ã  l'arc </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duel Ã  l'Ã©pÃ©e </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +8 CompÃ©tence Ã‰pÃ©es </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcadÃ©mie Gandalf</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duel Ã  l'Ã©pÃ©e </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 CompÃ©tence Ã‰pÃ©e </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancer un sort </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 compÃ©tence magique </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le personnage archer Ã  cÃ´tÃ© de ces 4 emplacements aura 6 options, dont 4 ne lui sont pas applicables s'il n'utilise pas d'Ã©pÃ©e ou de magie. </font><font style="vertical-align: inherit;">En comparant le rÃ©sultat dans ce cas avec une amÃ©lioration des compÃ©tences, plutÃ´t qu'un nom ou une Ã©tiquette, nous pouvons facilement Ã©largir les possibilitÃ©s du monde avec de nouveaux comportements. </font><font style="vertical-align: inherit;">Vous pouvez ajouter des hÃ´tels pour vous reposer et satisfaire votre faim. </font><font style="vertical-align: inherit;">Vous pouvez laisser les personnages aller Ã  la bibliothÃ¨que et dÃ©couvrir les sorts et les techniques avancÃ©es de tir Ã  l'arc.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nom de l'objet</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation en cours</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RÃ©sultat final</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HÃ´tel </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acheter </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -10 Ã  la faim </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HÃ´tel </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dormir </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -50 Ã  la fatigue </font></font><br><br></td></tr><tr><td>  La bibliothÃ¨que <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lire le livre </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 CompÃ©tence de lanceur de sorts </font></font><br><br></td></tr><tr><td>  La bibliothÃ¨que <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lire le livre </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 CompÃ©tence de tir Ã  l'arc </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons dÃ©jÃ  le comportement "pratique du tir Ã  l'arc", alors mÃªme si nous marquons la bibliothÃ¨que comme un endroit pour la FORMATION Ã€ L'ARCHERIE, alors nous avons trÃ¨s probablement besoin d'un cas spÃ©cial pour traiter l'animation du livre lu au lieu de l'animation habituelle de combat Ã  l'Ã©pÃ©e. </font><font style="vertical-align: inherit;">Ce systÃ¨me nous donne plus de flexibilitÃ© en dÃ©plaÃ§ant ces associations vers des donnÃ©es et en stockant des donnÃ©es dans le monde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'existence d'objets ou de lieux - bibliothÃ¨ques, hÃ´tels ou Ã©coles - nous renseigne sur les services qu'ils proposent, sur le personnage qui peut les obtenir, vous permet d'utiliser un petit nombre d'animations. </font><font style="vertical-align: inherit;">La capacitÃ© de prendre des dÃ©cisions simples sur les rÃ©sultats vous permet de crÃ©er une variÃ©tÃ© de comportements intÃ©ressants. </font><font style="vertical-align: inherit;">Au lieu d'attendre passivement une demande, ces objets peuvent fournir une mine d'informations sur comment et pourquoi les utiliser.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Courbes de rÃ©action </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a souvent une situation oÃ¹ une partie de l'Ã©tat du monde peut Ãªtre mesurÃ©e comme une valeur continue. </font></font> Exemples: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le Â«pourcentage de santÃ©Â» varie gÃ©nÃ©ralement de 0 (mort) Ã  100 (absolument sain) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La "distance Ã  l'ennemi le plus proche" varie de 0 Ã  une valeur positive arbitraire </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, le jeu peut avoir un aspect du systÃ¨me AI, nÃ©cessitant la saisie de valeurs continues dans un autre intervalle. Par exemple, pour prendre la dÃ©cision de fuir, un systÃ¨me dâ€™Ã©valuation de lâ€™utilitÃ© peut exiger Ã  la fois la distance de lâ€™ennemi le plus proche et la santÃ© actuelle du personnage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, le systÃ¨me ne peut pas simplement additionner deux valeurs de l'Ã©tat du monde afin d'obtenir un certain niveau de Â«sÃ©curitÃ©Â», car ces deux unitÃ©s de mesure sont incomparables - les systÃ¨mes supposeront qu'un personnage presque mort Ã  200 mÃ¨tres de l'ennemi est dans la mÃªme sÃ©curitÃ© qu'il est absolument sain. personnage Ã  100 mÃ¨tres de l'ennemi. De plus, bien que la valeur en pourcentage de la santÃ© au sens large soit linÃ©aire, la distance ne l'est pas - la diffÃ©rence de distance par rapport Ã  l'ennemi 200 et 190 mÃ¨tres est moins significative que la diffÃ©rence entre 10 mÃ¨tres et zÃ©ro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IdÃ©alement, nous avons besoin d'une solution qui prend deux indicateurs et les convertit en intervalles similaires afin qu'ils puissent Ãªtre comparÃ©s directement. Et nous avons besoin que les concepteurs puissent contrÃ´ler la faÃ§on dont ces transformations sont calculÃ©es pour contrÃ´ler l'importance relative de chaque valeur. Ã€ cet effet, des courbes de rÃ©action (courbes de rÃ©ponse) sont utilisÃ©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La faÃ§on la plus simple d'expliquer la courbe de rÃ©action est un graphique avec une entrÃ©e le long de l'axe X, des valeurs arbitraires, par exemple, Â«la distance Ã  l'ennemi le plus procheÂ» et une sortie le long de l'axe Y (gÃ©nÃ©ralement une valeur normalisÃ©e dans la plage de 0,0 Ã  1,0). Une ligne ou une courbe sur le graphique dÃ©termine la liaison de l'entrÃ©e Ã  la sortie normalisÃ©e, et les concepteurs ajustent ces lignes pour obtenir le comportement dont ils ont besoin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer le niveau de "sÃ©curitÃ©", vous pouvez maintenir la linÃ©aritÃ© des valeurs de pourcentage de santÃ© - par exemple, 10% de santÃ© en plus - c'est gÃ©nÃ©ralement bon lorsque le personnage est gravement blessÃ© et lorsqu'il se blesse facilement. </font><font style="vertical-align: inherit;">Par consÃ©quent, nous attribuons ces valeurs Ã  l'intervalle de 0 Ã  1 de maniÃ¨re simple:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/65f/9a9/e3f65f9a90b2557c5408e529c477fb12.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance par rapport Ã  l'ennemi le plus proche est lÃ©gÃ¨rement diffÃ©rente, donc nous ne sommes pas du tout gÃªnÃ©s par les ennemis au-delÃ  d'une certaine distance (disons 50 mÃ¨tres), et nous sommes beaucoup plus intÃ©ressÃ©s par les diffÃ©rences Ã  courte distance qu'Ã  longue distance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous voyons que la sortie de Â«sÃ©curitÃ©Â» pour les ennemis Ã  40 et 50 mÃ¨tres est presque la mÃªme: 0,96 et 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b7/8bf/be7/9b78bfbe758bf8407a3abe44b430e7a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il y a une diffÃ©rence beaucoup plus grande entre l'ennemi Ã  15 mÃ¨tres (environ 0,5) et l'ennemi Ã  5 mÃ¨tres (environ 0,2). Un tel calendrier reflÃ¨te mieux l'importance pour l'ennemi de se rapprocher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En normalisant ces deux valeurs dans la plage de 0 Ã  1, nous pouvons calculer la valeur de sÃ©curitÃ© totale comme la moyenne de ces deux valeurs d'entrÃ©e. Un personnage avec 20% de santÃ© et un ennemi Ã  50 mÃ¨tres auront un score de sÃ©curitÃ© de 0,6. Un personnage avec 75% de santÃ© et un ennemi Ã  seulement 5 mÃ¨tres auront un score de sÃ©curitÃ© de 0,47. Un personnage gravement blessÃ© avec 10% de santÃ© et un ennemi de 5 mÃ¨tres auront un indice de sÃ©curitÃ© de seulement 0,145. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les Ã©lÃ©ments suivants doivent Ãªtre pris en compte ici:</font></font><br><br><ul><li>              â€”                  ,   . </li><li>         â€” ,  ,   50  â€”      ,    ,      . </li><li>        ,   (  )        .       ,       â€” ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Unity AnimationCurve</a>    ,           . </li></ul><br><h2> Blackboards </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souvent, nous nous trouvons dans une situation oÃ¹ l'IA de l'agent doit commencer Ã  surveiller les connaissances et les informations obtenues au cours du jeu afin qu'elles puissent Ãªtre utilisÃ©es dans la prise de dÃ©cision. Par exemple, un agent peut avoir besoin de se souvenir du dernier personnage qu'il a attaquÃ© afin de se concentrer sur les attaques de ce personnage pendant une courte pÃ©riode. Ou il doit se rappeler combien de temps s'est Ã©coulÃ© aprÃ¨s avoir entendu un bruit, de sorte qu'aprÃ¨s un certain temps, il cesse de chercher ses raisons et retourne Ã  ses Ã©tudes prÃ©cÃ©dentes. TrÃ¨s souvent, le systÃ¨me d'enregistrement des donnÃ©es est fortement sÃ©parÃ© du systÃ¨me de lecture des donnÃ©es, il doit donc Ãªtre facilement accessible depuis l'agent et ne pas Ãªtre intÃ©grÃ© directement dans divers systÃ¨mes d'IA. La lecture peut avoir lieu un certain temps aprÃ¨s l'Ã©criture, les donnÃ©es doivent donc Ãªtre stockÃ©es quelque part,afin qu'ils puissent Ãªtre rÃ©cupÃ©rÃ©s plus tard (et non calculÃ©s sur demande, ce qui peut ne pas Ãªtre possible).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un systÃ¨me d'IA codÃ© en dur, la solution peut Ãªtre d'ajouter les variables nÃ©cessaires dans le processus du besoin. Ces variables se rapportent Ã  des instances du personnage ou de l'agent, soit en s'intÃ©grant directement dans celui-ci, soit en crÃ©ant une structure / classe distincte pour stocker ces informations. Les procÃ©dures d'IA peuvent Ãªtre adaptÃ©es pour lire et Ã©crire ces donnÃ©es. Dans un systÃ¨me simple, cela fonctionnera bien, mais Ã  mesure que de plus amples informations sont ajoutÃ©es, elles deviennent lourdes et nÃ©cessitent gÃ©nÃ©ralement de reconstruire le jeu Ã  chaque fois.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une meilleure approche consiste Ã  transformer l'entrepÃ´t de donnÃ©es en une structure qui permet aux systÃ¨mes de lire et d'Ã©crire des donnÃ©es arbitraires. Cette solution vous permet d'ajouter de nouvelles variables sans avoir besoin de changer la structure des donnÃ©es, offrant ainsi la possibilitÃ© d'augmenter le nombre de modifications qui peuvent Ãªtre apportÃ©es Ã  partir des fichiers de donnÃ©es et des scripts sans avoir besoin de rÃ©assemblage. Si chaque agent stocke simplement une liste de paires clÃ©-valeur, chacune Ã©tant un Ã©lÃ©ment de connaissance distinct, diffÃ©rents systÃ¨mes d'IA peuvent coopÃ©rer en ajoutant et en lisant ces informations si nÃ©cessaire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le dÃ©veloppement de l'IA, de telles approches sont appelÃ©es Â«tableaux noirsÂ» (Â«tableaux noirsÂ»), car chaque participant - dans notre cas, les procÃ©dures d'IA (par exemple, la perception, trouver un chemin et prendre des dÃ©cisions) - peut Ã©crire sur le Â«tableau noirÂ», lu Ã  partir duquel les donnÃ©es pour l'exÃ©cution de leur tÃ¢che peuvent Ãªtre n'importe quel autre participant. Vous pouvez l'imaginer comme une Ã©quipe d'experts rÃ©unis autour du tableau et Ã©crire quelque chose d'utile que vous devez partager avec le groupe. En mÃªme temps, ils peuvent lire les notes prÃ©cÃ©dentes de leurs collÃ¨gues jusqu'Ã  ce qu'ils parviennent Ã  une dÃ©cision ou Ã  un plan conjoint. Une liste codÃ©e en dur de variables communes dans le code est parfois appelÃ©e Â«tableau noir statiqueÂ» (car les Ã©lÃ©ments dans lesquels les informations sont stockÃ©es sont constants pendant l'exÃ©cution du programme), et une liste arbitraire de paires clÃ©-valeur est souvent appelÃ©e Â«tableau noir dynamiqueÂ».Mais ils sont utilisÃ©s Ã  peu prÃ¨s de la mÃªme maniÃ¨re - comme un lien intermÃ©diaire entre les parties du systÃ¨me d'IA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'IA traditionnelle, l'accent est gÃ©nÃ©ralement mis sur la collaboration de diffÃ©rents systÃ¨mes pour la prise de dÃ©cision conjointe, mais relativement peu de systÃ¨mes sont prÃ©sents dans l'IA de jeu. </font><font style="vertical-align: inherit;">Cependant, un certain degrÃ© de coopÃ©ration peut encore exister. </font><font style="vertical-align: inherit;">Imaginez ce qui suit dans un RPG d'action:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le systÃ¨me de Â«perceptionÂ» balaye rÃ©guliÃ¨rement la zone et Ã©crit les entrÃ©es suivantes dans le tableau noir: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ennemi le plus proche: gobelin 412 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Distance Ã  l'ennemi le plus proche": 35,0 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Ami proche": "Guerrier 43" </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Â«Distance Ã  l'ami le plus procheÂ»: 55,4 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Heure du dernier bruit remarquÃ©": 12h45 </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des systÃ¨mes comme un systÃ¨me de combat peuvent enregistrer des Ã©vÃ©nements clÃ©s sur un tableau noir, par exemple: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dernier dommage subi: 12h34 </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup de ces donnÃ©es peuvent sembler redondantes - au final, vous pouvez toujours obtenir la distance de l'ennemi le plus proche, en sachant simplement qui est cet ennemi et en rÃ©pondant Ã  une demande de position. Mais lorsqu'elle est rÃ©pÃ©tÃ©e plusieurs fois par image, afin de dÃ©cider si un agent menace ou non quelque chose, cela devient une opÃ©ration potentiellement lente, surtout si elle doit effectuer une requÃªte spatiale pour dÃ©terminer l'ennemi le plus proche. Et les horodatages du Â«dernier bruit remarquÃ©Â» ou du Â«dernier dommage reÃ§uÂ» ne pourront toujours pas Ãªtre instantanÃ©s - vous devez enregistrer l'heure Ã  laquelle ces Ã©vÃ©nements ont eu lieu, et le tableau noir est un endroit pratique pour cela.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4 utilise un systÃ¨me de tableau noir dynamique pour stocker les donnÃ©es transmises par les arbres de comportement. </font><font style="vertical-align: inherit;">GrÃ¢ce Ã  cet objet de donnÃ©es commun, les concepteurs peuvent facilement Ã©crire de nouvelles valeurs sur le tableau noir en fonction de leurs plans (scripts visuels), et l'arbre de comportement peut plus tard lire ces valeurs pour sÃ©lectionner le comportement, et tout cela ne nÃ©cessite pas de recompilation du moteur.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartes d'influence </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tÃ¢che standard dans l'IA est de dÃ©cider oÃ¹ l'agent doit se dÃ©placer. </font><font style="vertical-align: inherit;">Dans le jeu de tir, nous pouvons choisir l'action "DÃ©placer vers un abri", mais comment dÃ©cider oÃ¹ se trouve l'abri dans les conditions de dÃ©placement des ennemis? </font><font style="vertical-align: inherit;">Comme pour l'action "Escape" - oÃ¹ est le moyen le plus sÃ»r de s'Ã©chapper? </font><font style="vertical-align: inherit;">Ou dans RTS, nous pouvons avoir besoin des troupes pour attaquer un point faible dans la dÃ©fense de l'ennemi - comment pouvons-nous dÃ©terminer oÃ¹ ce point faible est?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes ces questions peuvent Ãªtre considÃ©rÃ©es comme des tÃ¢ches gÃ©ographiques, car nous posons une question sur la gÃ©omÃ©trie et la forme de l'environnement et la position des entitÃ©s dans celui-ci. Dans notre jeu, toutes ces donnÃ©es sont probablement dÃ©jÃ  disponibles, mais leur donner du sens n'est pas une tÃ¢che facile. Par exemple, si nous voulons trouver un point faible dans la dÃ©fense de l'ennemi, il ne suffit pas de choisir simplement la position du bÃ¢timent ou de la fortification le plus faible s'ils ont deux puissants systÃ¨mes de canons sur les flancs. Il nous faut un moyen de prendre en compte le territoire et de mieux analyser la situation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est Ã  cela que sert la structure de donnÃ©es Â«carte d'influenceÂ». Il dÃ©crit Â«l'influenceÂ» qu'une entitÃ© peut avoir sur la zone qui l'entoure. En combinant l'influence de plusieurs entitÃ©s, nous crÃ©ons un regard plus rÃ©aliste sur l'ensemble du paysage. Du point de vue de la mise en Å“uvre, nous rapprochons le monde du jeu en lui superposant une grille 2D, et aprÃ¨s avoir dÃ©terminÃ© dans quelle cellule de la grille se trouve l'entitÃ©, nous appliquons une Ã©valuation d'impact Ã  celle-ci et aux cellules environnantes, indiquant l'aspect du gameplay que nous voulons simuler. Pour obtenir l'image complÃ¨te, nous accumulons ces valeurs dans la mÃªme grille. AprÃ¨s cela, nous pouvons effectuer diverses requÃªtes de grille afin de comprendre le monde et dÃ©cider du positionnement et des points cibles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons, par exemple, "le point le plus faible de la dÃ©fense de l'ennemi". </font><font style="vertical-align: inherit;">Nous avons un mur dÃ©fensif, Ã  l'attaque duquel nous voulons envoyer des fantassins, mais il y a 3 catapultes derriÃ¨re lui - 2 proches les unes des autres Ã  gauche, 1 Ã  droite. </font><font style="vertical-align: inherit;">Comment choisissons-nous une bonne position d'attaque? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous pouvons attribuer +1 points de protection Ã  toutes les cellules de la grille dans l'attaque de catapulte. </font><font style="vertical-align: inherit;">Le dessin de ces points sur la carte d'influence d'une catapulte ressemble Ã  ceci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/e37/df8/0cee37df8083ed361e0bf7362a7e5666.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le rectangle bleu limite toutes les cellules dans lesquelles vous pouvez lancer une attaque contre le mur. </font><font style="vertical-align: inherit;">Les carrÃ©s rouges indiquent +1 influence de catapulte. </font><font style="vertical-align: inherit;">Dans notre cas, cela signifie la zone de leur attaque et la menace pour les unitÃ©s attaquantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ajoutons l'effet de la deuxiÃ¨me catapulte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/e7f/ef1/db9e7fef10229a2f5a38108197548490.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons une zone sombre dans laquelle se forme l'influence de deux catapultes, ce qui confÃ¨re Ã  ces cellules une protection +2. La cellule +2 Ã  l'intÃ©rieur de la zone bleue peut Ãªtre un endroit particuliÃ¨rement dangereux pour attaquer le mur! Ajoutez l'influence de la derniÃ¨re catapulte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/da0/6d7/1aada06d7ea16ef8e2e6bca315c196c5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[IcÃ´nes: CC-BY: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://game-icons.net/heavenly-dog/originals/defensive-wall.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant une dÃ©signation complÃ¨te de la zone couverte par les catapultes. Dans la zone d'attaque potentielle, il y a une cellule avec +2 influences de catapulte, 11 cellules avec +1 influence, et 2 cellules avec 0 influence de catapulte - ce sont les principaux candidats pour la position d'attaque, en eux nous pouvons attaquer le mur sans crainte d'un incendie de catapulte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'avantage des cartes d'influence est qu'elles transforment un espace continu avec un ensemble presque infini de positions possibles en un ensemble discret de positions approximatives, Ã  propos desquelles nous pouvons prendre des dÃ©cisions trÃ¨s rapidement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous n'avons obtenu cet avantage qu'en choisissant un petit nombre de positions d'attaque potentielles. Pourquoi devrions-nous utiliser la carte d'influence ici au lieu de vÃ©rifier manuellement la distance de chaque catapulte Ã  chacune de ces positions? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PremiÃ¨rement, le calcul d'une carte d'influence peut Ãªtre trÃ¨s peu coÃ»teux. Une fois les points d'influence placÃ©s sur la carte, il n'est pas nÃ©cessaire de la modifier avant que les entitÃ©s commencent Ã  se dÃ©placer. Cela signifie que nous n'avons pas besoin d'effectuer constamment des calculs de distance ou d'interroger de maniÃ¨re itÃ©rative toutes les unitÃ©s possibles - nous Â«incorporonsÂ» ces informations dans la carte et pouvons lui envoyer des demandes autant de fois que nÃ©cessaire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeuxiÃ¨mement, nous pouvons chevaucher et combiner diffÃ©rentes cartes d'influence pour rÃ©pondre Ã  des requÃªtes plus complexes. </font><font style="vertical-align: inherit;">Par exemple, pour sÃ©lectionner un endroit sÃ»r pour s'Ã©chapper, nous pouvons prendre une carte de l'influence de nos ennemis et soustraire la carte de nos amis - les cellules de la grille avec la plus grande valeur nÃ©gative seront considÃ©rÃ©es comme sÃ»res.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le plus rouge, le plus dangereux et le plus vert, le plus sÃ»r. </font><font style="vertical-align: inherit;">Les zones dans lesquelles les chevauchements d'influence peuvent Ãªtre complÃ¨tement ou partiellement neutralisÃ©s pour reflÃ©ter les zones d'influence conflictuelles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, les cartes d'influence sont faciles Ã  visualiser lors du rendu dans le monde. </font><font style="vertical-align: inherit;">Ils peuvent Ãªtre un indice prÃ©cieux pour les concepteurs qui ont besoin de personnaliser l'IA en fonction des propriÃ©tÃ©s visibles, et ils peuvent Ãªtre regardÃ©s en temps rÃ©el pour comprendre pourquoi l'IA choisit ses dÃ©cisions.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espÃ¨re que l'article vous a donnÃ© un aperÃ§u des outils et des approches les plus populaires utilisÃ©s dans l'IA de jeu, ainsi que des situations dans lesquelles ils peuvent Ãªtre appliquÃ©s. </font><font style="vertical-align: inherit;">L'article ne tenait pas compte de nombreuses autres techniques (elles sont utilisÃ©es moins souvent, mais pourraient Ãªtre tout aussi efficaces), notamment les suivantes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithmes de tÃ¢che d'optimisation, y compris la montÃ©e vers le haut, la descente de gradient et les algorithmes gÃ©nÃ©tiques. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des algorithmes de recherche / planification compÃ©titifs tels que l'Ã©crÃªtage minimax et alpha beta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les techniques de classification, par exemple les perceptrons, les rÃ©seaux de neurones et la mÃ©thode des vecteurs de support </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> systÃ¨mes de perception d'agents et de traitement de la mÃ©moire </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approches architecturales de l'IA, telles que les systÃ¨mes hybrides, les architectures prÃ©dicatives (architectures Brooks) et d'autres faÃ§ons de dÃ©composer les systÃ¨mes d'IA en couches </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des outils d'animation tels que la planification et la mise en correspondance des mouvements </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tÃ¢ches liÃ©es aux performances telles que le niveau de dÃ©tail, les algorithmes Ã  tout moment et la synchronisation </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour en savoir plus sur ces sujets, ainsi que sur les sujets abordÃ©s dans cet article, vous pouvez Ã©tudier les sources suivantes. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameDev.net propose des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles et des tutoriels sur l'intelligence artificielle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi qu'un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forum sur l'intelligence artificielle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AiGameDev.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ont de </font><font style="vertical-align: inherit;">nombreuses prÃ©sentations et articles sur un large Ã©ventail de sujets d'intelligence artificielle dans le contexte du dÃ©veloppement de jeux</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDC Vault a des rapports avec GDC AI Summit, dont beaucoup sont disponibles gratuitement: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.gdcvault.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la AI Game Programmers Guild a un tas de liens vers les anciens articles et prÃ©sentations de ce sommet: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://gameai.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le chercheur en intelligence artificielle et dÃ©veloppeur de jeux Tommy Thompson dispose d'une chaÃ®ne YouTube dÃ©diÃ©e Ã  l'explication et Ã  l'exploration de l'IA dans les jeux commerciaux: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/user/tthompso</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup de matÃ©riaux de la plus haute qualitÃ© se trouvent dans les livres, notamment les suivants: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sÃ©rie Game AI Pro est une collection de courts articles expliquant comment implÃ©menter des fonctionnalitÃ©s spÃ©cifiques ou rÃ©soudre des problÃ¨mes spÃ©cifiques. </font><font style="vertical-align: inherit;">Ã€ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gameaipro.com/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publiÃ© des extraits gratuits de livres prÃ©cÃ©dents.</font></font><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KGoB8n%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro: la sagesse des professionnels de Game AI</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KFKyoe%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 2: Sagesse collectÃ©e des professionnels de Game AI</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 3: Sagesse collectÃ©e des professionnels de Game AI</font></font></a> <br></li></ul><br></li><li>  AI Game Programming Wisdom    Game AI Pro.      ,       .    ,          ! <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">AI Game Programming Wisdom 1</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">AI Game Programming Wisdom 2</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">AI Game Programming Wisdom 3</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">AI Game Programming Wisdom 4</a> <br></li></ul></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Artificial Intelligence: A Modern Approach</a> â€”      ,        .       ,     ,         ,      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En outre, il existe plusieurs bons livres sur l'IA de jeu en gÃ©nÃ©ral, Ã©crits par des professionnels de l'industrie. </font><font style="vertical-align: inherit;">Il est difficile de privilÃ©gier qui que ce soit - lisez les avis et choisissez celui qui vous convient.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420219/">https://habr.com/ru/post/fr420219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420205/index.html">ROM Ã  base d'ADN, mÃ©moire d'acide nuclÃ©ique et substrats pour OxRAM</a></li>
<li><a href="../fr420209/index.html">OpenAI dÃ©montre le transfert de manipulations complexes des simulations au monde rÃ©el</a></li>
<li><a href="../fr420211/index.html">La rÃ©flexion magique sur l'apprentissage automatique ne rapprochera pas la vÃ©ritable IA</a></li>
<li><a href="../fr420213/index.html">Vue d'ensemble de la grande imprimante 3D abordable WANHAO D9</a></li>
<li><a href="../fr420215/index.html">Console, commutateurs et beaucoup de cafÃ©: un jour dans la vie de l'hÃ©bergement VDS</a></li>
<li><a href="../fr420221/index.html">Les attaquants ont piratÃ© des milliers de routeurs D-link et redirigÃ© leurs propriÃ©taires vers des ressources malveillantes</a></li>
<li><a href="../fr420223/index.html">Quelques conseils simples: comment Ã©viter d'endommager le drone</a></li>
<li><a href="../fr420225/index.html">MÃ©lodie algorithmique infinie basÃ©e sur des nombres premiers</a></li>
<li><a href="../fr420227/index.html">Le prÃ©sident turc annonce l'interdiction d'importer de l'Ã©lectronique aux Ã‰tats-Unis</a></li>
<li><a href="../fr420229/index.html">Les enfants des villages peuvent-ils devenir des programmeurs s'ils se trouvent Ã  proximitÃ©, ils n'enseignent qu'aux cheminots. Conversation avec le "Cercle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>