<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùÔ∏è üèÇüèæ üë∂üèæ Comment j'ai fait des ombres 2D dans Unity ü§∞üèΩ üïµüèø üéÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qu'est-ce qui vient √† l'esprit d'un d√©veloppeur de jeux ind√©pendants lorsqu'il est confront√© √† la n√©cessit√© d'ajouter une fonctionnalit√© qu'il n'a auc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai fait des ombres 2D dans Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484744/">  Qu'est-ce qui vient √† l'esprit d'un d√©veloppeur de jeux ind√©pendants lorsqu'il est confront√© √† la n√©cessit√© d'ajouter une fonctionnalit√© qu'il n'a aucune id√©e de la mise en ≈ìuvre?  Bien s√ªr, il va chercher des traces de ceux qui ont d√©j√† parcouru ce chemin et qui ont pris la peine d'√©crire leur exp√©rience.  Je l'ai donc fait il y a quelque temps, en commen√ßant √† cr√©er des ombres dans mon jeu.  Trouver la bonne information - sous forme d'articles, de le√ßons et de guides - n'a pas √©t√© difficile.  Cependant, √† ma grande surprise, j'ai trouv√© qu'aucune des solutions d√©crites ne me convenait tout simplement.  Par cons√©quent, apr√®s avoir r√©alis√© le mien, j'ai d√©cid√© d'en parler au monde. <br><br>  Il convient d'avertir √† l'avance que ce texte ne pr√©tend pas √™tre une sorte de guide ultimatum ou de master class.  La m√©thode que j'ai utilis√©e n'est peut-√™tre pas universelle, loin d'√™tre la plus efficace et ne couvre pas enti√®rement la t√¢che de cr√©er des ombres bidimensionnelles.  C'est plut√¥t une histoire sur les astuces auxquelles un d√©veloppeur inexp√©riment√© a d√ª faire face pour obtenir un r√©sultat satisfaisant √† ses exigences. <br><br>  Le r√©sultat lui-m√™me est devant vous: <br><br> <a href=""><img src="https://habrastorage.org/webt/-y/kc/nf/-ykcnfou6b_na1a44jvq-v3-nts.png"></a> <br><br>  Et les d√©tails du chemin vers sa r√©alisation vous attendent sous la coupe. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Un peu sur le jeu lui-m√™me</b> <div class="spoiler_text">  Dwarfinator est un jeu de tir de d√©fense / d√©filement lat√©ral bidimensionnel d√©velopp√© avec un ≈ìil sur les segments mobile et de bureau.  Le gameplay consiste en la destruction syst√©matique des vagues ennemies dans deux modes alternatifs - d√©fense et poursuite.  La progression d'un joueur implique de pomper un ¬´r√©servoir¬ª en am√©liorant et en rempla√ßant divers √©l√©ments, tels que les armes, les moteurs et les roues, ainsi qu'en √©levant le niveau et en apprenant des comp√©tences actives et passives.  La progression de l'environnement implique une augmentation constante du nombre de mobs dans la vague, l'ajout de nouveaux types d'ennemis √† la vague au fur et √† mesure qu'ils progressent √† travers l'emplacement et le changement successif de plusieurs emplacements, chacun ayant son propre ensemble d'adversaires. <br></div></div><br><h3>  √ânonc√© du probl√®me </h3><br>  Donc, au moment de la d√©cision d'ajouter des ombres au jeu, j'avais: <br><br><ul><li>  emplacement sous la forme de deux sprites, l'un pour l'affichage derri√®re les foules et autres entit√©s, le second pour l'affichage devant eux; </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7e/e7/8s/7ee78soifwhkx6g3bgetf4nvfhy.png"></a> <br><br><ul><li>  des foules et des objets destructibles statiques, constamment anim√©s et constitu√©s de sprites s√©par√©s en quantit√© de quelques √† quelques dizaines; </li></ul><br><img src="https://habrastorage.org/webt/yp/ea/my/ypeamyommcilthpim0gr2o820mu.png"><br><br><ul><li>  des obus, propres et ennemis, repr√©sent√©s dans la plupart des cas soit par un sprite, soit par un syst√®me de particules, dans ce dernier cas aucune ombre n'√©tait requise; </li></ul><br><img src="https://habrastorage.org/webt/bt/9n/ml/bt9nmlkym2iuq6qtrqntzkzil7s.png"><br><br><ul><li>  un char constitu√© de plusieurs pi√®ces assembl√©es selon le m√™me sch√©ma que les foules; </li></ul><br><img src="https://habrastorage.org/webt/uv/1y/ed/uv1yedokb8lqcxfwmt788egsvne.png"><br><br><ul><li>  murs avec plusieurs √©tats fixes, qui, encore une fois, sont un ensemble de sprites s√©par√©s. </li></ul><br><img src="https://habrastorage.org/webt/3f/we/7s/3fwe7srgtopajqnn6rvg3kyoiq4.png"><br><br>  Pour tout cela, les ombres les plus simples √©taient n√©cessaires, r√©p√©tant les contours de l'objet et projet√©es √† partir d'une seule source de lumi√®re fixe. <br><br>  Dans le m√™me temps, il faut avoir une attitude attentive √† la productivit√©.  En raison des sp√©cificit√©s du genre et des particularit√©s de sa mise en ≈ìuvre, la plupart des objets projetant des ombres sont localis√©s directement sur l'√©cran √† tout moment.  Et leur nombre total peut √™tre sup√©rieur √† cent, si nous parlons d'entit√©s de jeu, et quelques milliers, si nous parlons de sprites individuels. <br><br><h3>  Impl√©mentation </h3><br>  En fait, le principal probl√®me s'est av√©r√© √™tre que Dwarfinator, en gros, est un jeu 2.5D.  La grande majorit√© des objets existent dans un espace √† deux dimensions avec les axes X et Y, et l'axe Z est extr√™mement rarement utilis√©.  Visuellement, et en partie gameplay, l'axe Y est utilis√© pour afficher √† la fois la hauteur et la profondeur, se divisant de la m√™me mani√®re dans les axes virtuels Y et Z. Il n'√©tait pas possible d'utiliser des outils Unity standard dans une telle situation pour cr√©er des ombres. <br><br>  Mais en fait, je n'avais pas besoin d'un √©clairage honn√™te, c'√©tait suffisant pour pouvoir cr√©er manuellement une ombre pour chaque objet.  Par cons√©quent, la chose la plus simple qui m'est venue √† l'esprit √©tait de simplement en placer une copie derri√®re chaque entit√©, tourn√©e dans un espace tridimensionnel afin de simuler un emplacement sur la surface.  Tous les sprites de cette pseudo-ombre ont √©t√© mis √† noir, tandis que la structure hi√©rarchique du propri√©taire de l'ombre a √©t√© pr√©serv√©e, ce qui lui a permis d'√™tre anim√©e en synchronisation avec le propri√©taire par le m√™me animateur. <br><br>  Une telle animation synchrone ressemblait √† ceci: <br><br><img src="https://habrastorage.org/webt/wv/on/vc/wvonvcn2zlzubgo5orcwcjjuu5e.gif"><br><br>  Cependant, l'ombre exigeait de la transparence.  La solution la plus simple √©tait de la d√©finir pour chaque sprite d'ombre.  Mais une telle mise en ≈ìuvre ne semblait pas satisfaisante - les sprites se chevauchaient, formant des zones moins transparentes sur le site de superposition. <br><br>  La capture d'√©cran ci-dessous montre √† quoi ressemble l'ombre de plusieurs segments translucides.  Les param√®tres de distorsion de l'ombre utilis√©s sont √©galement visibles: rotation le long de l'axe X de -50 degr√©s, rotation le long de l'axe Y de -140 degr√©s et l'√©chelle le long de l'axe X, augment√©e de 1,3 fois par rapport √† l'objet parent. <br><br><img src="https://habrastorage.org/webt/6w/2k/m-/6w2km-vc4g_hhblm2fz3tofrdzq.png"><br><br>  Il est devenu √©vident que la transparence devait √™tre impos√©e √† l'ombre en tant qu'objet solide.  La premi√®re exp√©rience sur ce sujet a √©t√© suspendue √† l'ombre de la cam√©ra, rendant cette ombre dans RenderTexture, qui a ensuite √©t√© utilis√©e comme mat√©riau attach√© au parent de l'ombre du plan.  Il pouvait d√©j√† √©tablir la transparence sans aucun probl√®me.  Les ombres elles-m√™mes √©taient en dehors du cadre pour √©viter le chevauchement des zones de capture de la cam√©ra.  L'approche a fonctionn√©, mais il s'est av√©r√© que d√©j√† quelques dizaines d'ombres causaient de s√©rieux probl√®mes de performances, principalement en raison du nombre de cam√©ras sur la sc√®ne.  De plus, un certain nombre d'animations supposaient un mouvement significatif des sprites de mob individuels dans le cadre de son objet racine, en raison duquel une zone de cam√©ra devrait √™tre situ√©e qui d√©passerait consid√©rablement la taille de l'image r√©elle √† un moment donn√©. <br><br>  La solution a √©t√© trouv√©e rapidement - si vous ne pouvez pas dessiner chaque ombre avec une cam√©ra s√©par√©e - pourquoi ne pas dessiner toutes les ombres avec une seule cam√©ra?  Tout ce qui devait √™tre fait √©tait de placer une zone s√©par√©e de la sc√®ne sous l'ombre, l√©g√®rement plus √©lev√©e que le champ de vision de la cam√©ra principale, de diriger une cam√©ra suppl√©mentaire vers cette zone et d'afficher sa sortie entre l'emplacement et d'autres entit√©s. <br><br>  Ci-dessous, vous pouvez voir un exemple de la sortie de cette cam√©ra: <br><br> <a href=""><img src="https://habrastorage.org/webt/in/bt/vm/inbtvmwj2slb2wn8f8wqqqkhbke.png"></a> <br><br>  La productivit√© d'une telle impl√©mentation a beaucoup moins souffert, donc la solution a √©t√© consid√©r√©e comme fonctionnelle et appliqu√©e √† tous les mobs, objets statiques et obus.  Cela a √©t√© suivi par l'emplacement du sprite.  Il √©tait impossible d'utiliser un sprite sur tous les objets, car il a √©t√© impl√©ment√© pr√©c√©demment.  L'utilisation d'une copie d'un objet comme ombre fonctionne uniquement tant que l'objet est compl√®tement plat.  M√™me lors de la cr√©ation d'ombres pour les foules, il √©tait √† noter que les points de contact avec la surface espac√©e le long de la troisi√®me coordonn√©e violaient l'exactitude de l'ombre par rapport √† ces points. <br><br>  La capture d'√©cran suivante montre un exemple d'une telle violation.  Le talon de la foule est consid√©r√© comme le point de contact avec la surface, mais les ombres des pieds sont d√©j√† au-del√† des pieds eux-m√™mes. <br><br><img src="https://habrastorage.org/webt/-d/zu/an/-dzuan6-5vwdisaiafgysqizvnc.png"><br><br>  Et si dans le cas des pattes de l'ogre vous pouvez encore l√©g√®rement changer la position de l'ombre et masquer le probl√®me, alors pour plusieurs dizaines de troncs d'arbres, il n'y a aucune chance.  Tous les objets de localisation qui √©taient cens√©s projeter une ombre doivent √™tre s√©par√©s en GameObject.  C'est exactement ce que j'ai fait en pla√ßant des copies des objets destructibles correspondants sur le pr√©fabriqu√© d'emplacement et en d√©sactivant les scripts qui ne sont pas utilis√©s dans cette position.  En m√™me temps, gr√¢ce √† cela, il est devenu possible de les inclure dans le tri g√©n√©ral des objets de la sc√®ne, et les obus volant √† l'ext√©rieur de l'emplacement n'√©taient plus dessin√©s strictement au-dessus de tous les objets, mais volaient entre eux.  De plus, il est devenu possible de faire animer les objets eux-m√™mes. <br><br>  Mais alors un nouveau probl√®me m'attendait.  Avec des ombres et des dizaines de nouveaux objets, le nombre maximum de GameObjects simultan√©ment sur la sc√®ne, et avec eux les composants Animator et SpriteRenderer, a plus que doubl√©.  Lorsque j'ai lib√©r√© toute la vague de mobs √† l'endroit, qui repr√©sentait environ 150 pi√®ces, Profiler m'a montr√© un reproche d'environ 40 ms, qui ne sont partis que pour le rendu et l'animation, et la fr√©quence d'images variait g√©n√©ralement autour de 10. J'ai d√©sesp√©r√©ment optimis√© mes propres scripts, luttant pour chaque milliseconde, mais cela ne suffisait pas. <br><br>  √Ä la recherche d'outils d'optimisation suppl√©mentaires, je suis tomb√© sur la vaste documentation et les guides pour le traitement par lots dynamique. <br><br><div class="spoiler">  <b class="spoiler_title">Un peu plus sur le traitement par lots</b> <div class="spoiler_text">  En bref, le traitement par lots est un m√©canisme pour minimiser le nombre d'appels de tirage, et avec lui le temps pass√© au moment du rendu du cadre sur l'interaction entre le CPU et le GPU.  Lorsqu'ils sont utilis√©s au lieu d'envoyer chaque √©l√©ment individuellement pour le rendu, des √©l√©ments similaires sont regroup√©s et dessin√©s ensemble √† la fois.  Dans le cas d'Unity, le moteur lui-m√™me essaie d'utiliser au maximum ce m√©canisme et presque aucune action suppl√©mentaire n'est requise de la part du d√©veloppeur. <br></div></div><br>  Frame Debugger a montr√© que j'avais, au mieux, les d√©tails de chaque objet ou mob s√©par√©ment.  Ayant cr√©√© des sprites pour le premier et le deuxi√®me de l'atlas, j'ai r√©alis√© l'ombre avec seulement quelques appels de tirage, mais les propri√©taires de ces ombres ont obstin√©ment refus√© de se battre. <br><br>  Des exp√©riences sur une sc√®ne distincte ont montr√© que le traitement par lots dynamique se casse lorsque les objets ont un composant SortingGroup, que j'ai utilis√© pour trier l'affichage des entit√©s √† l'√©cran.  Il √©tait possible de s'en passer, cependant, en th√©orie, d√©finir les valeurs de tri pour chaque sprite et syst√®me de particules dans un objet s√©par√©ment pourrait s'av√©rer encore plus cher que l'absence de traitement par lots. <br><br>  Mais quelque chose me hantait.  L'objet fant√¥me, √©tant un descendant de l'objet h√¥te dans la sc√®ne r√©elle, appartenait techniquement au m√™me groupe de tri, cependant, il n'y avait aucun probl√®me avec l'observation dynamique des objets fant√¥mes.  La seule diff√©rence √©tait que les objets h√¥tes √©taient dessin√©s directement sur l'√©cran par la cam√©ra principale, et les objets ombres √©taient d'abord rendus dans RenderTexture. <br><br>  C'√©tait le hic.  La raison exacte de ce comportement est inconnue d'Internet, mais lors du rendu des images de la cam√©ra dans RenderTexture, SortingGroup n'a plus interrompu le traitement par lots.  La d√©cision semblait tr√®s √©trange, illogique et en g√©n√©ral la plus b√©quille.  Mais en mettant en ≈ìuvre le rendu des entit√©s en utilisant la m√™me m√©thode que le rendu des ombres, et ayant ainsi obtenu, en plus de la couche d'ombre, une couche d'entit√©, j'ai d√©j√† atteint des valeurs de performances tout √† fait acceptables. <br><br>  La capture d'√©cran ci-dessous montre un exemple de rendu d'une couche d'entit√©. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/q_/r3/vnq_r3631min5ao58fksxjgcmt0.png"></a> <br><br>  Donc, en g√©n√©ral, le rendu d'une certaine entit√© dans la coordonn√©e Y ressemble √† ceci: <br><br><ol><li>  L'entit√© est plac√©e √† Y-20; </li><li>  Une entit√© est rendue par une cam√©ra observant cette coordonn√©e dans une RenderTexture pour les entit√©s; </li><li>  L'ombre de l'entit√© est plac√©e √† Y + 20; </li><li>  L'ombre d'une entit√© est dessin√©e par une cam√©ra qui observe cette coordonn√©e dans une texture de rendu pour les ombres; </li><li>  La cam√©ra principale dessine l'image-objet de l'emplacement principal sur l'√©cran - le seul √©l√©ment qui est actuellement rendu directement √† l'√©cran; </li><li>  La cam√©ra principale dessine un plan sur l'√©cran avec des ombres RenderTexture comme mat√©riau; </li><li>  La cam√©ra principale dessine un plan √† l'√©cran avec une texture de rendu d'entit√©s en tant que mat√©riau. </li></ol><br>  Un tel g√¢teau en couches. <br><br>  Dans la capture d'√©cran ci-dessous, la cam√©ra de l'√©diteur est configur√©e en mode tridimensionnel pour montrer l'emplacement des couches les unes par rapport aux autres. <br><br> <a href=""><img src="https://habrastorage.org/webt/pz/ix/0v/pzix0vcz_uw8gh4yppbukrsujjw.png"></a> <br><br><h3>  Nuances </h3><br>  Mais comme il s'est av√©r√© au cours du processus de r√©plication de la d√©cision √† d'autres entit√©s, le cas g√©n√©ral n'a pas couvert tous les sc√©narios possibles.  Par exemple, il y avait des entit√©s qui √©taient √† une certaine hauteur par rapport √† la surface, en particulier les coquilles et certains personnages de cin√©matiques.  De plus, les obus avaient √©galement la possibilit√© de tourner en fonction de la direction de leur mouvement sur l'√©cran, en raison de quoi, en plus de d√©finir le point d'intersection de l'objet et de son ombre, il √©tait n√©cessaire de s√©lectionner la partie tournante en tant qu'objet enfant s√©par√©, pour corriger la logique de rotation du projectile et leur animation. <br><br>  La capture d'√©cran suivante montre un exemple de rotation des coques et de leurs ombres. <br><br><img src="https://habrastorage.org/webt/53/a1/dm/53a1dm21tezb3p8wktfmfyibubu.png"><br><br>  Les personnages volants, comme les foules volantes planifi√©es, peuvent √©galement se d√©placer dans leurs coordonn√©es Y virtuelles, ce qui a n√©cessit√© la cr√©ation d'un m√©canisme pour calculer la position de l'ombre √† partir de la position de son propri√©taire sur l'axe Y virtuel. <br><br>  Le GIF ci-dessous montre un exemple de d√©placement d'un objet en hauteur. <br><br><img src="https://habrastorage.org/webt/wh/m8/vz/whm8vzwjlsobsbyhzeapuggku4s.gif"><br><br>  Un autre cas qui est sorti du concept g√©n√©ral √©tait un char.  Contrairement √† toutes les autres entit√©s, le r√©servoir a une taille tr√®s importante le long de l'axe Z virtuel, et la mise en ≈ìuvre globale des ombres, comme d√©j√† mentionn√©, n√©cessite que l'objet soit presque plat.  Le moyen le plus simple de contourner ce probl√®me √©tait de dessiner manuellement des formes d'ombre pour des parties individuelles du r√©servoir, car vous pouviez placer n'importe quoi sur la couche d'ombre. <br><br>  Pour la construction correcte des ombres dessin√©es √† la main, j'ai d√ª assembler une conception de lignes bas√©e sur une capture d'√©cran d'une ombre existante, qui peut √™tre vue dans la capture d'√©cran ci-dessous. <br><br><img src="https://habrastorage.org/webt/md/of/np/mdofnpoa7xwtlus9bkqvnalzpri.png"><br><br>  Si vous mettez √† l'√©chelle et placez cette structure de mani√®re √† ce que la partie sup√©rieure soit √† un certain point de l'objet parent et que la partie inf√©rieure soit au point de contact avec la surface, le coin droit de la structure indiquera l'endroit o√π le point d'ombre correspondant devrait √™tre.  Apr√®s avoir projet√© plusieurs points cl√©s de cette mani√®re, il n'est pas difficile de construire toute l'ombre sur eux. <br><br>  De plus, les parties individuelles du r√©servoir pouvaient avoir des hauteurs diff√©rentes pour fixer des parties enfants, ce qui, comme dans le cas des personnages volants et des foules, n√©cessitait un ajustement de la position de l'ombre de chaque partie sp√©cifique. <br><br>  La capture d'√©cran ci-dessous montre le r√©servoir, son assemblage d'ombre et il se pr√©sente √©galement sous la forme de pi√®ces s√©par√©es. <br><br><img src="https://habrastorage.org/webt/67/bu/5m/67bu5mgmclx_x53nv2efh9mxnqe.png"><br><br>  Les ombres des murs se sont av√©r√©es √™tre une douleur distincte.  Au moment du d√©but des travaux sur les ombres, les murs √©taient de la m√™me nature que les d√©tails du r√©servoir - un objet de plusieurs dizaines de sprites s√©par√©s.  Cependant, les murs avaient plusieurs √©tats contr√¥l√©s par l'animateur. <br><br>  En r√©fl√©chissant bien √† ce que j'en ferais, j'en suis venu √† la conclusion que le concept des murs doit √™tre chang√©.  En cons√©quence, les murs ont √©t√© divis√©s en sections, chacune ayant son propre ensemble d'√©tats, son propre animateur et sa propre ombre.  Cela a permis d'utiliser la m√™me approche pour cr√©er des ombres pour les mobs parall√®les √† l'axe X, comme pour les mobs, et pour les sections qui ne correspondaient pas √† cette r√®gle, ils devaient trouver quelque chose qui leur √©tait propre.  Dans certains cas, j'ai d√ª cr√©er mon propre animateur pour l'ombre de la section et d√©finir manuellement la position des sprites. <br><br>  Par exemple, dans le cas de la section illustr√©e dans la capture d'√©cran ci-dessous, l'ombre est cr√©√©e en appliquant une distorsion pour chaque journal individuel au lieu de la section enti√®re. <br><br><img src="https://habrastorage.org/webt/bc/ef/sm/bcefsmatcqoghwbttkwfhbrpeme.png"><br><br><h3>  Conclusion </h3><br>  En fait, c'est tout.  Malgr√© toutes les nuances ci-dessus, la t√¢che d'origine a √©t√© achev√©e dans son int√©gralit√©, et maintenant mon projet poss√®de des ombres d'aspect assez d√©cent, bien que d'origine quelque peu douteuse.  J'esp√®re, gr√¢ce √† cet article, pour le prochain d√©veloppeur ind√©pendant qui m'a pos√© une question similaire, Internet deviendra un peu plus utile, sinon comme un exemple √† suivre, puis au moins comme une erreur de quelqu'un d'autre pour votre propre apprentissage. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484744/">https://habr.com/ru/post/fr484744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484732/index.html">Qu'est-ce que VMware et pourquoi sa compatibilit√© avec les SSD est-elle importante?</a></li>
<li><a href="../fr484734/index.html">Ce qui aurait pu √™tre pr√©sent√© au CES aux XIXe et XXe si√®cles</a></li>
<li><a href="../fr484736/index.html">Linux: suppression du pool de verrous / dev / random</a></li>
<li><a href="../fr484738/index.html">Proc√©dure d'int√©gration continue pour Laravel 6 sur Google Cloud Run</a></li>
<li><a href="../fr484740/index.html">Semaine de la s√©curit√© 04: probl√®mes de cryptographie dans Windows 10</a></li>
<li><a href="../fr484750/index.html">Schizophr√©nie: un regard apr√®s</a></li>
<li><a href="../fr484752/index.html">√âcrire un pilote d'ordinateur portable pour le plaisir et le profit, ou comment s'engager dans le noyau m√™me si vous n'√™tes pas si intelligent</a></li>
<li><a href="../fr484754/index.html">Intel ne peut pas d√©cider qui est le plus rapide: Comet Lake ou Ice Lake</a></li>
<li><a href="../fr484756/index.html">Th√©orie de l'information visuelle (partie 2)</a></li>
<li><a href="../fr484758/index.html">Ce qui est commun entre la programmation et le d√©marrage d'une entreprise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>