<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ 🔡 ⚙️ Kami meng-overclock cadangan. Kuliah Yandex 🤷 🏎️ 🔪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa kuliah mendatang akan didasarkan pada Y. Subbotnik pertama pada database yang diadakan di musim semi . Pertama, pengembang Andrei Borodin ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami meng-overclock cadangan. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/415817/">  Beberapa kuliah mendatang akan didasarkan pada Y. Subbotnik pertama pada database yang diadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di musim semi</a> .  Pertama, pengembang Andrei Borodin berbicara di Y. Subbotnik.  Dia berbicara tentang WAL-G, alat sederhana dan efektif untuk membuat cadangan PostgreSQL ke cloud, serta algoritma dan teknologi yang memungkinkan WAL-G untuk membuat cadangan lebih cepat.  Fitur utama WAL-G adalah cadangan delta.  Dalam kuliah ini Anda akan belajar tentang implementasi mereka dan bagaimana dukungan untuk teknologi ini berkembang di PostgreSQL. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bXuN4Na0cEo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - hai!  Saya adalah pengembang Yandex dari Yekaterinburg.  Untuk teknologi backup cepat.  Kami telah melakukan pencadangan selama beberapa waktu, ada laporan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Borodin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evgeny Dyukov</a> tentang bagaimana kami meneliti dan apa yang kami kembangkan untuk menyimpan data dengan aman, andal, mudah, dan efisien.  Seri ini didedikasikan untuk perkembangan terbaru di bidang ini. <br><br>  Mari kita bicara tentang cadangan pada PostgreSQL pada prinsipnya.  Utilitas standar untuk mentransfer data - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_dump</a> - didefinisikan sebagai utilitas konsol yang membuat file dengan representasi logis dari data Anda. <br><a name="habracut"></a><br>  Itu adalah salinan yang logis cukup nyaman.  Anda selalu dapat mentransfer data antara versi yang berbeda, Anda dapat memotong basis data Anda menjadi beberapa bagian, dan ini adalah alat standar yang, misalnya, datang dalam sebuah kotak dengan utilitas administrasi PgAdmin. <br><br><img src="https://habrastorage.org/webt/3j/zs/kh/3jzskhrdbobeb5pfvdyebjvv9bi.jpeg"><br>  Pertama-tama, tentang pg_dump Anda perlu tahu bahwa ini adalah alat pengembang. <br><br>  Ini bukan alat pemeliharaan basis data.  pg_dump tidak dirancang untuk bekerja dengan basis data yang sangat dimuat. <br><br><img src="https://habrastorage.org/webt/rb/sk/yf/rbskyfdmcwqb9ctu6-idvcj6ywm.jpeg"><br>  Misalkan semuanya serius dan Anda ingin menggunakan teknologi "Point-in-time recovery", yang menggunakan PostgreSQL API untuk bekerja dengan cadangan online.  Anda memanggil fungsi pg_start_backup dan membuat salinan file dari basis data.  Faktanya, pg_start_backup memaksa database untuk melakukan CHECKPOINT;  dan aktifkan penulisan satu halaman penuh dalam log tulis depan.  Salinan database yang Anda buat saat menelepon API bukan salinan data yang konsisten.  Anda juga memerlukan log tulis-depan agar dapat mengembalikan database Anda selama panggilan pg_stop_backup, yaitu, di akhir cadangan. <br><br><img src="https://habrastorage.org/webt/0a/aw/v1/0aawv1w0gp9okkkbjuja0k-ywg4.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Setelah waktu akhir penghapusan cadangan dan di hadapan catatan terkemuka, Anda dapat memulihkan ke titik yang diinginkan dalam masa hidup database Anda. <br><br>  Utilitas pg_basebackup disediakan di dalam kotak, yang mengimplementasikan semua teknologi ini dalam bentuk kanonik dan memungkinkan Anda membuat cadangan dengan fungsionalitas minimum yang diperlukan. <br><br>  Jika Anda masih lebih serius dari sebelumnya, maka Anda menggunakan beberapa jenis perangkat lunak manajemen cadangan, dan biasanya itu adalah Barman. <br><br>  Ia memiliki beberapa keunggulan.  Kelebihan utama adalah utilitas yang sangat umum, ia memiliki komunitas besar, sejumlah besar pertanyaan tentang Stack Overflow. <br><br><img src="https://habrastorage.org/webt/hk/_s/xx/hk_sxxzzua_byoapw4kvxdexymm.jpeg"><br><br>  Anda hanya perlu mengambil satu server cadangan, dan mencadangkan semua PostgreSQL Anda di sana.  Ini sangat nyaman - selama satu server cadangan sudah cukup untuk Anda. <br><br>  Segera setelah Anda memiliki banyak server cadangan, Anda perlu memantau apakah ada yang penuh.  Dalam hal kegagalan beberapa server cadangan, Anda perlu memahami yang mana dari basis data Anda yang sekarang dalam bahaya.  Anda perlu memahami secara prinsip di mana untuk menyalin kluster basis data baru saat membuatnya. <br><br>  Ada utilitas penghapusan cadangan yang jauh lebih sederhana yang disebut WAL-E. <br><br><img src="https://habrastorage.org/webt/jf/l1/a0/jfl1a07ymxdr0luksh1zg_cb7ii.jpeg"><br>  WAL-E menjalankan empat perintah utama.  Perintah WAL-PUSH mengirim satu file WAL ke cloud, dan WAL-FETCH mengambil satu file WAL jika restore_command perlu dikembalikan. <br><br>  Ada juga BACKUP-PUSH (mengimplementasikan penghapusan API cadangan) dan BACKUP-FETCH (mengambil semua data dari cloud).  Data disimpan di cloud, jadi Anda tidak perlu memonitor apa pun, ini sudah menjadi masalah layanan cloud, bagaimana memastikan ketersediaan data Anda saat Anda membutuhkannya.  Ini mungkin keuntungan utama dari WAL-E. <br><br><img src="https://habrastorage.org/webt/tz/2e/h5/tz2eh51uc_vtsp-oylcltmgep1i.jpeg"><br>  Ada cukup banyak fungsi.  Ada daftar cadangan, ada kebijakan retensi, yaitu, kami ingin menyimpan cadangan selama tujuh hari terakhir, misalnya, atau lima cadangan terakhir, kira-kira seperti itu.  Dan WAL-E dapat mem-backup ke berbagai layanan cloud: S3, Azure, Google, dapat memanggil sistem file lokal cloud. <br><br><img src="https://habrastorage.org/webt/n9/wj/uz/n9wjuz9n4tg_w8cvkkbp4g7_imi.jpeg"><br>  Ini memiliki beberapa properti.  Pertama, ia ditulis dalam Python dan secara aktif menggunakan pipa Unix, sebagian karena ini, ia memiliki dependensi dan tidak terlalu produktif.  Ini normal karena WAL-E berfokus pada kemudahan penggunaan, kemudahan pengaturan sehingga Anda tidak dapat membuat kesalahan ketika Anda membuat rencana cadangan.  Dan itu ide yang sangat bagus. <br><br>  Ada banyak fitur yang ditulis dalam WAL-E, dan di mana penulis mengembangkannya lebih lanjut tidak terlalu jelas bagi penulis.  Gagasan muncul bahwa saya membutuhkan alat baru. <br><br><img src="https://habrastorage.org/webt/ov/tj/ed/ovtjeduv1bhofpvnrbv2oong4ok.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Fitur utamanya adalah bahwa ia ditulis ulang di Go, hampir tidak memiliki ketergantungan eksternal, jika Anda tidak menggunakan enkripsi eksternal, dan itu jauh lebih produktif. <br><br><img src="https://habrastorage.org/webt/fl/pl/h2/flplh2x6ugfya5ydixenji9hmxg.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  WAL-G pada awalnya dibuat oleh dua penulis dari Citus Data, dan keuntungan utama ditunjukkan dalam histogram ini - kecepatan pengiriman "poros".  Kita melihat bahwa WAL-E cepat, bisa apa saja, bisa menjadi kolom besar mendekati nol. <br><br><img src="https://habrastorage.org/webt/r_/si/dn/r_sidnqgiipagw5sosfzo8ze90e.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  WAL-G memiliki bandwidth yang cukup stabil.  Pada tes di Citus Data, ia menunjukkan bahwa ia secara stabil mengirim sekitar 800 Mb / s "poros". <br><br>  Selain itu, di WAL-G, misalnya, saya menulis fitur yang mengimplementasikan cadangan dari replika.  Anda tidak perlu memuat master DB Anda dengan membaca, Anda dapat menghapus cadangan dari replika. <br><br><img src="https://habrastorage.org/webt/ck/bl/jj/ckbljjqa0ujh35rnlmncx5guauw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Tapi ada satu masalah kecil.  Saat Anda mulai membuat cadangan, Anda harus memberi nama cadangan itu entah bagaimana.  Nama ini termasuk timeline, yang akan diubah jika replika dipromosikan.  Jika failover terjadi dalam rantai replika sebelum replika yang Anda buat cadangannya, Anda akan melihat beberapa replika, timeline akan diubah.  WAL-G memahami bahwa situasi ini tidak konsisten, karena memiliki nama di timeline lama, nama itu menjanjikan Anda bahwa Anda dapat melanjutkan pengembangan sejarah database ke arah yang ada.  Tapi ini tidak benar.  Anda telah pergi ke salah satu arah, Anda tidak dapat melompat ke timeline lain dengan mobil belakang.  Oleh karena itu, WAL-G memahami situasi ini dan tidak mengunggah file JSON fiskal ke cloud.  Anda membuat salinan fisik.  Tetapi intervensi administrator diperlukan agar salinan ini dapat digunakan. <br><br><img src="https://habrastorage.org/webt/no/yo/nv/noyonvp7l8d-0myokmscgjts31w.jpeg"><br><br>  Kami telah mengimplementasikan salinan delta di WAL-G, saya juga mengerjakan pengembangan ini.  Ini memungkinkan Anda untuk mengambil lebih sedikit data dalam cadangan basis berikutnya, Anda tidak membuat salinan halaman data yang tidak berubah dari cadangan sebelumnya. <br><br><img src="https://habrastorage.org/webt/dt/cn/ag/dtcnaglkk_z3i6rsm_hvs56m28o.jpeg"><br>  Saat mengatur WAL-G, Anda menentukan jumlah langkah yang paling jauh dari cadangan dasar, cadangan delta, dan menentukan kebijakan salin delta.  Entah Anda membuat salinan dari delta terakhir yang ada, atau Anda membuat delta dari cadangan lengkap asli.  Ini diperlukan dalam kasus ketika komponen database yang sama selalu berubah di database Anda, data yang sama terus berubah. <br><br>  Mengapa pada prinsipnya kita membutuhkan salinan delta dari database?  Secara teori, Anda memiliki WAL, sehingga Anda dapat memutar di mana saja. <br><br>  Pada server yang sibuk, memainkan WAL lima detik fisik di masa lalu mungkin membutuhkan empat detik fisik saat ini.  Jika Anda diminta untuk menggulung WAL dalam empat hari, ini berarti ada kemungkinan bahwa orang yang meminta untuk melakukan ini harus menunggu tiga hari lagi.  Tidak selalu situasi yang dapat diterima. <br><br>  Anda memerlukan cadangan dasar untuk setiap hari, namun demikian, Anda tidak dapat menyimpan 7 atau 14 salinan penuh dari basis data Anda di sana, meskipun WAL-G akan mengarsipkannya, itu masih akan cukup besar.  Dan dalam hal ini, salinan delta membantu. <br><br><img src="https://habrastorage.org/webt/xw/aw/-l/xwaw-ll2y9911p6gjynx3dxhfb0.jpeg"><br>  Ketika mengembangkan salinan delta, beberapa kemungkinan format file data dibahas.  Pertama-tama, format itu diusulkan, ketika kami tidak mengganggu halaman, kami hanya membatalkannya.  Tetapi kami sampai pada kesimpulan bahwa ini bukan cara yang sangat efektif, nol kemudian dikompres secara efektif, tetapi kemudian kami menolak metode penyimpanan ini, karena sulit untuk men-debug itu jika terjadi situasi darurat. <br><br><img src="https://habrastorage.org/webt/y1/cd/m-/y1cdm-xvhv7sq-4wt8e3y_xzaia.jpeg"><br>  Teknologi selanjutnya yang dipertimbangkan adalah pertama-tama menyimpan nomor blok dan kemudian blok yang diubah.  Tetapi di sini kita dihadapkan dengan kekhasan penyimpanan dalam file TAR, bahwa kita harus terlebih dahulu menunjukkan ukuran file TAR di mana kita menyimpan salinan delta kita, dan kemudian mulai merekamnya.  Saya ingin membuat implementasi teknologi dengan konsumsi minimum RAM, jadi kami harus menggunakan format ketiga di mana kami pertama kali benar-benar membaca setiap file data, mencari halaman data yang diubah, pertama-tama menyimpan jumlah blok yang diubah dalam file TAR, dan hanya kemudian blok yang diubah itu sendiri. <br><br><img src="https://habrastorage.org/webt/ew/le/eo/ewleeouqovcrezeke5wv6nndmby.jpeg"><br><img src="https://habrastorage.org/webt/mj/qx/rg/mjqxrg9h-jhu0nlatbxarh1jaaw.jpeg"><br><br>  Fitur ini belum diterapkan.  Saya melihatnya atau mencari seseorang yang ingin mengajukan permintaan tarik di WAL-G.  Ketika memulihkan dari salinan delta, database bertahan setiap reinkarnasi dari database di setiap langkah cadangan delta.  Terkadang di tengah kehidupan beberapa file dihapus.  Pada saat yang sama, kita tidak perlu khawatir tentang kondisi mereka jika mereka tetap dihapus, dan kemudian diciptakan kembali dari salinan delta.  Ini sepertinya bukan fitur yang sangat rumit, jadi jika Anda tertarik untuk menulis sesuatu di Go, lihat fitur ini. <br><br><img src="https://habrastorage.org/webt/g3/fa/7d/g3fa7d6otwscpktvrov045nvmni.jpeg"><br>  Jadwalkan tentang penggunaan jaringan, CPU dan disk.  Di WAL-E, seperti yang bisa kita lihat, cadangan di sini belum berakhir, dimulai pukul satu pagi di Moskow, dan itu tidak berakhir pada laporan terakhir yang kita lihat.  Jadwal WAL-G telah berakhir, ia bekerja lebih cepat dan bahkan lebih banyak dalam hal konsumsi sumber daya. <br><br>  Yang paling menarik adalah grafik konsumsi sumber daya selama salinan delta.  Kami melihat bahwa semua sumber daya menjadi hampir nol.  Beban pada CPU hampir merupakan beban standar pada database, pada malam hari, beberapa permintaan dieksekusi.  Kami melihat cabang besar membaca.  Saya juga menghadapinya, saya juga ingin menarik permintaan atau saya akan melakukannya sendiri di musim panas.  Intinya adalah bahwa kita masih harus membaca data kami untuk mengetahui apa yang telah berubah di dalamnya.  Bacaan ini bisa dihindari. <br><br><img src="https://habrastorage.org/webt/6g/bz/w7/6gbzw7p2zf7bbczdq3hnc-z1ni8.jpeg"><br><br>  Ada penghapusan dalam WAL-G ketika kami menunjukkan jumlah cadangan atau tanggal dari mana kami perlu menyimpan semua WAL dan semua cadangan dasar.  Dan WAL-G sudah berurusan dengan pertanyaan tentang apa WAL dan cadangan dasar yang dibutuhkan.  Sejauh ini kami tidak memiliki fitur yang akan menghapus semuanya.  Dalam WAL-E, ini juga merupakan kesempatan untuk permintaan tarik.  Perintah DELETE EVERYTHING yang menarik belum diimplementasikan. <br><br><img src="https://habrastorage.org/webt/5q/1t/aw/5q1tawrrz1gj-l4wu1igxubfd4q.jpeg"><br><br>  Ada daftar cadangan. <br><br><img src="https://habrastorage.org/webt/kq/gs/mw/kqgsmwqqiezwwifwb8puxmzlugm.jpeg"><br>  Kami mengatur variabel lingkungan yang diperlukan agar WAL-G berfungsi dan memanggil utilitas konsol WAL-G.  Cadangan yang perlu kita lihat ditampilkan. <br><br><img src="https://habrastorage.org/webt/id/uv/rg/iduvrgdmb1nca0nbfcpvs0cxfc8.jpeg"><br>  WAL-G mengimplementasikan cukup banyak teknologi untuk memparalelkan cadangan dan umumnya berbagai operasi.  Sebagai contoh, teknologi ini digunakan untuk mengirim "poros" ke arsip.  Segera setelah PostgreSQL memanggil archive_command untuk mengirim satu file, WAL-G melihat apakah ada lebih banyak file yang siap di dekatnya. <br><br>  Secara umum, ini bukan fitur yang sangat terdokumentasi, sangat stabil di versi terbaru PostgreSQL, banyak teknologi menggunakannya.  Kami melihat apakah ada file WAL yang sudah jadi dalam status arsip, dan kami juga mengirimkannya bersama dengan yang meminta untuk mengirim database ke arsip.  Dan ketika PostgreSQL meminta mereka untuk mengirim, kami sudah mengirimnya, kami siap.  Ini secara signifikan mempercepat pengiriman WAL pada pangkalan yang dimuat dan memungkinkan Anda membuatnya bukan single-threaded.  Biasanya, PostgreSQL menyiapkan satu file, lalu menunggu file itu pergi, menyiapkan yang berikutnya.  Kami berhasil menghindari pekerjaan yang konsisten ini. <br><br><img src="https://habrastorage.org/webt/pc/3k/5f/pc3k5fkukjj7o5zqxm7hsjr3way.jpeg"><br>  Selama WAL-FETCH, ketika kluster dipulihkan, kami juga mencoba mengunduh file N berikut yang akan dibutuhkan, dan mencoba menyeimbangkan jeda antara awal prefetting file WAL baru sehingga kami dapat memanfaatkan semua sumber daya yang kami miliki sebanyak mungkin: apakah berjalan ke dalam jaringan atau mengalami disk dalam kasus yang jarang terjadi. <br><br><img src="https://habrastorage.org/webt/pd/v2/mn/pdv2mnfn4_ne1jbp00nhl35n7y4.jpeg"><br>  Ini semua diatur oleh variabel lingkungan. <br><br><img src="https://habrastorage.org/webt/oe/ro/k5/oerok5u-varh4b3rcwq4dgwarmm.jpeg"><br>  Ada juga konkurensi membuat salinan.  Meskipun fitur ini tidak ada dalam berbagai rilis - A. B. dirilis pada rilis 0.1.10 pada Juni 2018 - karena paralelisme membaca dari disk memungkinkan Anda dijamin berjalan ke jaringan atau disk.  Ini tidak terlalu baik dengan database yang dimuat.  WAL-E memiliki fitur yang memungkinkan pelambatan.  Sejauh ini, kami belum memilikinya.  Hal ini diperlukan untuk membatasi kecepatan penghapusan cadangan sehingga pangkalan dapat hidup sendiri dan melayani beban. <br><br>  Fitur utama kami bukan tentang teknologi. <br><br>  Dua tahun lalu, Zhenya Dyukov mengimplementasikan teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">delta-backup</a> untuk Barman, belum diadakan, komunitas masih mendiskusikannya. <br><br>  Hampir setahun yang lalu, Zhenya memperbaiki bug WAL-E, dan kami mengirimnya selama enam bulan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke GitHub</a> - kira-kira Ed.).  Cukup sering dalam solusi open source ada masalah dengan fakta bahwa mereka tidak terawat dengan baik. <br><br><img src="https://habrastorage.org/webt/jy/hg/mf/jyhgmfxdz_srayrm8vsxdnq-a3q.jpeg"><br>  Dengan WAL-G, semuanya cukup sederhana: kami menggunakannya dan saya memeliharanya.  Jika kami atau Anda membutuhkan sesuatu, Anda cukup melaporkan bahwa Anda memiliki masalah.  Kami akan mencoba menyelesaikannya. <br><br>  Permintaan standar dari komunitas sederhana - "mari kita lakukan yang paling." <br><br>  Lebih banyak kriptografi, lebih banyak platform.  Mungkin bukan hanya PostgreSQL, tapi MySQL masih cadangan atau yang lainnya?  Saya melihat beberapa hal lainnya. <br><br><img src="https://habrastorage.org/webt/yi/sg/ck/yisgckbaa1bhbae-ixrx_u-fetm.jpeg"><br>  Pertama-tama, sekarang ketika mengirim "poros" kita bisa memahami blok basis data mana yang telah berubah, pindai file WAL ini dan simpan informasi tentang apa yang telah berubah. <br><br>  Dan ketika cron tiba dengan cadangan delta lain, kami tidak dapat memindai seluruh basis data, menyimpan file pembacaan disk tersebut dan hanya tahu halaman mana yang perlu kami seret ke cloud. <br><br>  Kami mencoba menggunakan teknologi trek-halaman.  Ini mengimplementasikan pelacakan perubahan halaman di tingkat kernel database.  Cadangan dihapus dengan sangat cepat.  Masalah utama dengan PTRACK adalah sangat invasif.  Ini berisi banyak perubahan pada inti PostgreSQL di tempat-tempat yang sangat sensitif, sehingga sepertinya tidak akan segera diadopsi. <br><br><img src="https://habrastorage.org/webt/4z/ea/px/4zeapxt_ji4odqmc57wnjpxilik.jpeg"><br>  Selain itu, delta-delta-nya sedikit berbeda dari delta-delta yang sekarang kita miliki.  Saat menghapus delta berbasis LSN, kami menghapus semua perubahan dalam file delta yang telah terjadi dari awal sebelumnya hingga saat ini. <br><br><img src="https://habrastorage.org/webt/ul/oh/pi/ulohpi0sz8mtyz5g018fxactms8.jpeg"><br>  Dalam kasus PTRACK, kami mendapatkan perubahan pada file delta, mulai dari delta yang sebelumnya diterima.  Kami tidak memiliki waktu delta yang tepat sebelum dimulainya cadangan, sebelum dimulainya perubahan.  Ini bukan masalah utama PTRACK, secara umum, ini bekerja dengan baik, tetapi sejauh ini sulit untuk diterima. <br><br><img src="https://habrastorage.org/webt/9-/qv/ou/9-qvouutaphuo35-ag0q_w1nnww.jpeg"><br>  PTRACK tidak mengizinkan penghapusan delta dalam mode LATEST_FULL, karena ia menyimpan peta blok yang diubah dari penghapusan peta ini sebelumnya.  Oracle memiliki teknologi yang menarik, ada 8 kartu sebelumnya yang mereka simpan berjaga-jaga.  Mungkin kita bisa melakukan hal serupa, tetapi sejauh ini kita tidak bekerja ke arah ini. <br><br><img src="https://habrastorage.org/webt/bx/do/z-/bxdoz-i2yzsnya6y6kzqbc30e3y.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  September lalu, saya mencoba menawarkan komunitas teknologi berdasarkan fakta bahwa kami hanya menambahkan kait yang kami butuhkan ke kernel, dan kami menerapkan pelacakan untuk perubahan halaman dalam ekstensi sehingga patch pelacakan halaman tidak terlalu invasif.  Setelah membahas teknologi ini, kami sampai pada kesimpulan bahwa kami membutuhkan beberapa prototipe, dan kami akan menambahkan kait ketika ada prototipe.  Mungkin kita akan melihat cara kerjanya.  Saat ini saya sedang mengerjakan prototipe ekstensi ini yang bisa menggunakan kait kernel untuk melacak perubahan basis data. <br><br>  Ada ekspresi di komunitas bahwa setiap postgresista harus memiliki alat cadangan sendiri.  Ini buruk.  Setiap orang melakukan pekerjaannya sendiri, yang melakukan tugas yang sangat penting.  Pasti ada satu hal di mana semuanya akan berada di dalam kotak, semuanya akan sempurna di dunia yang ideal. <br><br>  Apa yang ingin saya lihat di kotak di basebackup?  Kami ingin melihat, mungkin, pengarsipan ke awan.  Dan salinan delta. <br><br><img src="https://habrastorage.org/webt/6w/ea/zh/6weazhzi3fkxbhvzz2tlrdj4ujg.jpeg"><br>  Saya juga ingin kompresi, konkurensi, enkripsi, pelambatan, daftar cadangan, verifikasi, validasi cadangan ... Banyak hal.  Kami memahami bahwa jika semua ini sekarang ditawarkan kepada masyarakat, itu akan menghasilkan beberapa lusin tambalan, yang agak sulit untuk dibahas dan diimplementasikan melalui commitfest.  Oleh karena itu, sekarang kami masih menggunakan alat terpisah, tetapi ada keinginan untuk mencurahkan waktu dan teknologi kepada masyarakat untuk membuat PostgreSQL lebih baik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415817/">https://habr.com/ru/post/id415817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415805/index.html">Modifikasi modul penghalang GSM Doorhan untuk kontrol Internet</a></li>
<li><a href="../id415809/index.html">Cara menggunakan kedelai, requireejs, backbone js dalam plugin untuk Atlassian Jira</a></li>
<li><a href="../id415811/index.html">AI, tentu saja praktis. Tinjauan jaringan saraf untuk klasifikasi gambar</a></li>
<li><a href="../id415813/index.html">Beberapa catatan tentang kondisi Cloud Gaming saat ini</a></li>
<li><a href="../id415815/index.html">Di garis depan sains: analisis artikel arxiv.org</a></li>
<li><a href="../id415819/index.html">Laporan Club of Rome 2018, Bab 3.16: Pemerintah Global</a></li>
<li><a href="../id415821/index.html">Cara menata rumah "pintar" dengan kontrol listrik seluas mungkin</a></li>
<li><a href="../id415823/index.html">FindFace ditutup hanya untuk manusia biasa</a></li>
<li><a href="../id415829/index.html">Pengantar kelas data</a></li>
<li><a href="../id415831/index.html">Sepuluh Perintah Baru dari Roskosmos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>