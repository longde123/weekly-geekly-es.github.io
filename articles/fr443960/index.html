<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∞ ‚öæÔ∏è ü§µüèº Mod√®le jetable (principe de conception jetable) pt.2 üêê üë©üèº‚Äçüè≠ ‚ùï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SafeHandle / CriticalHandle / SafeBuffer / types d√©riv√©s 


 Je sens que je vais ouvrir la bo√Æte de Pandore pour toi. Parlons des types sp√©ciaux: Safe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®le jetable (principe de conception jetable) pt.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443960/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="safehandle--criticalhandle--safebuffer--derived-types">  SafeHandle / CriticalHandle / SafeBuffer / types d√©riv√©s </h2><br><p>  Je sens que je vais ouvrir la bo√Æte de Pandore pour toi.  Parlons des types sp√©ciaux: SafeHandle, CriticalHandle et leurs types d√©riv√©s. </p><br><p>  Ceci est la derni√®re chose √† propos du mod√®le d'un type qui donne acc√®s √† une ressource non g√©r√©e.  Mais d'abord, √©num√©rons tout ce que nous obtenons <em>habituellement</em> du monde non g√©r√©: </p><br><p>  La premi√®re chose et √©vidente est les poign√©es.  Cela peut √™tre un mot vide de sens pour un d√©veloppeur .NET, mais c'est un composant tr√®s important du monde du syst√®me d'exploitation.  Un descripteur est un nombre 32 ou 64 bits par nature.  Il d√©signe une session ouverte d'interaction avec un syst√®me d'exploitation.  Par exemple, lorsque vous ouvrez un fichier, vous obtenez un descripteur de la fonction WinApi.  Ensuite, vous pouvez travailler avec lui et effectuer des op√©rations de <em>recherche</em> , de <em>lecture</em> ou d' <em>√©criture</em> .  Ou, vous pouvez ouvrir un socket pour l'acc√®s au r√©seau.  Encore une fois, un syst√®me d'exploitation vous passera une poign√©e.  Dans .NET, les <em>descripteurs</em> sont stock√©s en tant <em>que</em> type <em>IntPtr</em> ; </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><ul><li>  La deuxi√®me chose est les tableaux de donn√©es.  Vous pouvez travailler avec des tableaux non g√©r√©s via un code dangereux (dangereux est un mot cl√© ici) ou utiliser SafeBuffer qui encapsulera un tampon de donn√©es dans une classe .NET appropri√©e.  Notez que la premi√®re m√©thode est plus rapide (par exemple, vous pouvez optimiser consid√©rablement les boucles), mais la seconde est beaucoup plus s√ªre, car elle est bas√©e sur SafeHandle; </li><li>  Allez ensuite les cordes.  Les cha√Ænes sont simples car nous devons d√©terminer le format et l'encodage de la cha√Æne que nous capturons.  Il est ensuite copi√© pour nous (une cha√Æne est une classe immuable) et nous ne nous en soucions plus. </li><li>  La derni√®re chose est les ValueTypes qui sont juste copi√©s, donc nous n'avons pas besoin d'y penser du tout. </li></ul><br><p>  SafeHandle est une classe CLR .NET sp√©ciale qui h√©rite de CriticalFinalizerObject et doit encapsuler les poign√©es d'un syst√®me d'exploitation de la mani√®re la plus s√ªre et la plus confortable. </p><br><pre><code class="plaintext hljs">[SecurityCritical, SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=true)] public abstract class SafeHandle : CriticalFinalizerObject, IDisposable { protected IntPtr handle; // The handle from OS private int _state; // State (validity, the reference counter) private bool _ownsHandle; // The flag for the possibility to release the handle. // It may happen that we wrap somebody else's handle // have no right to release. private bool _fullyInitialized; // The initialized instance [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle) { } // The finalizer calls Dispose(false) with a pattern [SecuritySafeCritical] ~SafeHandle() { Dispose(false); } // You can set a handle manually or automatically with p/invoke Marshal [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected void SetHandle(IntPtr handle) { this.handle = handle; } // This method is necessary to work with IntPtr directly. It is used to // determine if a handle was created by comparing it with one of the previously // determined known values. Pay attention that this method is dangerous because: // // ‚Äì if a handle is marked as invalid by SetHandleasInvalid, DangerousGetHandle // it will anyway return the original value of the handle. // ‚Äì you can reuse the returned handle at any place. This can at least // mean, that it will stop work without a feedback. In the worst case if // IntPtr is passed directly to another place, it can go to an unsafe code and become // a vector for application attack by resource substitution in one IntPtr [ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public IntPtr DangerousGetHandle() { return handle; } // The resource is closed (no more available for work) public bool IsClosed { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get { return (_state &amp; 1) == 1; } } // The resource is not available for work. You can override the property by changing the logic. public abstract bool IsInvalid { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get; } // Closing the resource through Close() pattern [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Close() { Dispose(true); } // Closing the resource through Dispose() pattern [SecuritySafeCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Dispose() { Dispose(true); } [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected virtual void Dispose(bool disposing) { // ... } // You should call this method every time when you understand that a handle is not operational anymore. // If you don't do it, you can get a leak. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void SetHandleAsInvalid(); // Override this method to point how to release // the resource. You should code carefully, as you cannot // call uncompiled methods, create new objects or produce exceptions from it. // A returned value shows if the resource was releases successfully. // If a returned value = false, SafeHandleCriticalFailure will occur // that will enter a breakpoint if SafeHandleCriticalFailure // Managed Debugger Assistant is activated. [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected abstract bool ReleaseHandle(); // Working with the reference counter. To be explained further. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void DangerousAddRef(ref bool success); public extern void DangerousRelease(); }</code> </pre> <br><p>  Pour comprendre l'utilit√© des classes d√©riv√©es de SafeHandle, vous devez vous rappeler pourquoi les types .NET sont si importants: GC peut collecter leurs instances automatiquement.  Lorsque SafeHandle est g√©r√©, la ressource non g√©r√©e qu'il a encapsul√©e h√©rite de toutes les caract√©ristiques du monde g√©r√©.  Il contient √©galement un compteur interne de r√©f√©rences externes qui ne sont pas disponibles pour CLR.  Je veux dire des r√©f√©rences de code dangereux.  Vous n'avez pas du tout besoin d'incr√©menter ou de d√©cr√©menter un compteur manuellement.  Lorsque vous d√©clarez un type d√©riv√© de SafeHandle en tant que param√®tre d'une m√©thode non s√ªre, le compteur s'incr√©mente lors de la saisie de cette m√©thode ou diminue apr√®s la sortie.  La raison en est que lorsque vous acc√©dez √† un code dangereux en y passant un handle, vous pouvez obtenir ce SafeHandle collect√© par GC, en r√©initialisant la r√©f√©rence √† ce handle dans un autre thread (si vous traitez un handle √† partir de plusieurs threads).  Les choses fonctionnent encore plus facilement avec un compteur de r√©f√©rence: SafeHandle ne sera pas cr√©√© tant que le compteur ne sera pas remis √† z√©ro.  C'est pourquoi vous n'avez pas besoin de changer le compteur manuellement.  Ou, vous devez le faire tr√®s soigneusement en le renvoyant lorsque cela est possible. </p><br><p>  Le deuxi√®me objectif d'un compteur de r√©f√©rences est de d√©finir l'ordre de finalisation de <code>CriticalFinalizerObject</code> qui se r√©f√©rencent mutuellement.  Si un type bas√© sur SafeHandle en r√©f√©rence un autre, vous devez √©galement incr√©menter un compteur de r√©f√©rence dans le constructeur du type de r√©f√©rence et diminuer le compteur dans la m√©thode ReleaseHandle.  Ainsi, votre objet existera jusqu'√† ce que l'objet auquel votre objet fait r√©f√©rence ne soit pas d√©truit.  Cependant, il vaut mieux √©viter de telles perplexit√©s.  Utilisons les connaissances sur SafeHandlers et √©crivons la derni√®re variante de notre classe: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { SafeFileHandle _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; _handle.Dispose(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern SafeFileHandle CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); /// other methods }</code> </pre> <br><p>  En quoi est-ce diff√©rent?  Si vous d√©finissez <strong>un</strong> type bas√© sur SafeHandle (y compris le v√¥tre) comme valeur de retour dans la m√©thode DllImport, Marshal cr√©era et initialisera correctement ce type et d√©finira un compteur √† 1. Sachant cela, nous d√©finissons le type SafeFileHandle comme type de retour pour la fonction du noyau CreateFile.  Lorsque nous l'obtenons, nous l'utilisons exactement pour appeler ReadFile et WriteFile (comme une valeur de compteur incr√©mente lors de l'appel et diminue √† la sortie, elle garantira que le handle existe toujours pendant la lecture et l'√©criture dans un fichier).  Il s'agit d'un type correctement con√ßu et il fermera de mani√®re fiable un descripteur de fichier si un thread est abandonn√©.  Cela signifie que nous n'avons pas besoin d'impl√©menter notre propre finaliseur et tout ce qui s'y rapporte.  Le type entier est simplifi√©. </p><br><h3 id="the-execution-of-a-finalizer-when-instance-methods-work">  L'ex√©cution d'un finaliseur lorsque les m√©thodes d'instance fonctionnent </h3><br><p>  Il existe une technique d'optimisation utilis√©e lors de la r√©cup√©ration de place qui est con√ßue pour collecter plus d'objets en moins de temps.  Regardons le code suivant: </p><br><pre> <code class="plaintext hljs">public void SampleMethod() { var obj = new object(); obj.ToString(); // ... // If GC runs at this point, it may collect obj // as it is not used anymore // ... Console.ReadLine(); }</code> </pre> <br><p>  D'une part, le code semble s√ªr, et on ne sait pas tout de suite pourquoi s'en soucier.  Cependant, si vous vous souvenez qu'il existe des classes qui encapsulent des ressources non manag√©es, vous comprendrez qu'une classe mal con√ßue peut provoquer une exception du monde non manag√©.  Cette exception signale qu'un descripteur pr√©c√©demment obtenu n'est pas actif: </p><br><pre> <code class="plaintext hljs">// The example of an absolutely incorrect implementation void Main() { var inst = new SampleClass(); inst.ReadData(); // inst is not used further } public sealed class SampleClass : CriticalFinalizerObject, IDisposable { private IntPtr _handle; public SampleClass() { _handle = CreateFile("test.txt", 0, 0, IntPtr.Zero, 0, 0, IntPtr.Zero); } public void Dispose() { if (_handle != IntPtr.Zero) { CloseHandle(_handle); _handle = IntPtr.Zero; } } ~SampleClass() { Console.WriteLine("Finalizing instance."); Dispose(); } public unsafe void ReadData() { Console.WriteLine("Calling GC.Collect..."); // I redirected it to the local variable not to // use this after GC.Collect(); var handle = _handle; // The imitation of full GC.Collect GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); Console.WriteLine("Finished doing something."); var overlapped = new NativeOverlapped(); // it is not important what we do ReadFileEx(handle, new byte[] { }, 0, ref overlapped, (a, b, c) =&gt; {;}); } [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, BestFitMapping = false)] static extern IntPtr CreateFile(String lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr securityAttrs, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError = true)] static extern bool ReadFileEx(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, [In] ref NativeOverlapped lpOverlapped, IOCompletionCallback lpCompletionRoutine); [DllImport("kernel32.dll", SetLastError = true)] static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Admettez que ce code semble plus ou moins d√©cent.  De toute fa√ßon, il ne semble pas y avoir de probl√®me.  En fait, il y a un s√©rieux probl√®me.  Un finaliseur de classe peut tenter de fermer un fichier pendant sa lecture, ce qui conduit presque in√©vitablement √† une erreur.  Parce que dans ce cas, l'erreur est explicitement renvoy√©e ( <code>IntPtr == -1</code> ), nous ne le verrons pas.  Le <code>_handle</code> sera d√©fini sur z√©ro, la <code>_handle</code> suivante ne parviendra pas √† fermer le fichier et la ressource fuira.  Pour r√©soudre ce probl√®me, vous devez utiliser <code>SafeHandle</code> , <code>CriticalHandle</code> , <code>SafeBuffer</code> et leurs classes d√©riv√©es.  Outre que ces classes ont des compteurs d'utilisation en code non manag√©, ces compteurs incr√©mentent √©galement automatiquement lors du passage avec les param√®tres des m√©thodes au monde non manag√© et d√©cr√©mentent en le quittant. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce charper traduit du russe comme de la langue de l'auteur par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider √† cr√©er une version traduite de ce texte dans n'importe quelle autre langue, y compris le chinois ou l'allemand, en utilisant les versions russe et anglaise du texte comme source. <br><br>  De plus, si vous voulez dire "merci", la meilleure fa√ßon que vous pouvez choisir est de nous donner une √©toile sur github ou un r√©f√©rentiel de forking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443960/">https://habr.com/ru/post/fr443960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443950/index.html">Faites confiance, conseillez, sugg√©rez - recherchez de v√©ritables critiques de logiciels</a></li>
<li><a href="../fr443952/index.html">Internet souverain - pour notre argent</a></li>
<li><a href="../fr443954/index.html">Singularit√© technologique: le mythe moderne de la fin du monde sous le couvert de l'hypoth√®se du progr√®s</a></li>
<li><a href="../fr443956/index.html">R√©seau social en 2019: Yandex lance Aura</a></li>
<li><a href="../fr443958/index.html">Mod√®le jetable (principe de conception jetable) pt.1</a></li>
<li><a href="../fr443962/index.html">Mod√®le jetable (principe de conception jetable) pt.3</a></li>
<li><a href="../fr443964/index.html">Kolesa Conf est la plus grande conf√©rence informatique au Kazakhstan. Annonce des rapports</a></li>
<li><a href="../fr443966/index.html">Google Docs - un chat pr√©f√©r√© des √©tudiants</a></li>
<li><a href="../fr443968/index.html">Comment nous avons achet√© une maison avec des panneaux solaires et ce qui en est arriv√©</a></li>
<li><a href="../fr443972/index.html">Yandex recherchera des pirates √† l'aide d'un robot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>