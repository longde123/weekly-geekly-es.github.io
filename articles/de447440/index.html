<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíáüèº üë©üèæ üë®‚Äçüë©‚Äçüëß RBKmoney Zahlungen unter der Haube - die Logik der Zahlungsplattform ü§≥üèº üõåüèª ‚ûó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich ver√∂ffentliche weiterhin den Zyklus √ºber die Innenseiten der Zahlungsplattform RBK.money, der in diesem Beitrag begonnen hat . Heute w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RBKmoney Zahlungen unter der Haube - die Logik der Zahlungsplattform</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rbkmoney/blog/447440/"><p><img src="https://habrastorage.org/webt/ao/li/cv/aolicvi50stowouvsmwppnyc7qk.jpeg"></p><br><p>  Hallo Habr!  Ich ver√∂ffentliche weiterhin den Zyklus √ºber die Innenseiten der Zahlungsplattform RBK.money, der in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag begonnen hat</a> .  Heute werden wir √ºber das logische Verarbeitungsschema, bestimmte Microservices und ihre Beziehung zueinander sprechen, wie die Services, die die einzelnen Gesch√§ftslogiken verarbeiten, logisch getrennt sind, warum der Verarbeitungskern nichts √ºber die Anzahl Ihrer Zahlungskarten wei√ü und wie Zahlungen innerhalb der Plattform ausgef√ºhrt werden.  Au√üerdem werde ich etwas detaillierter auf das Thema eingehen, wie wir Hochverf√ºgbarkeit und Skalierung f√ºr hohe Lasten bereitstellen. </p><a name="habracut"></a><br><h2 id="obzornaya-logicheskaya-shema-i-obschie-podhody">  √úbersichtslogik und allgemeine Ans√§tze </h2><br><p>  Im Allgemeinen sieht das Schema der Grundelemente des Teils der Verarbeitung, der f√ºr Zahlungen verantwortlich ist, so aus. </p><br><p><img src="https://habrastorage.org/webt/r8/ee/bz/r8eebzud9-g1muc_xguixpokwfc.png"></p><br><p>  Logischerweise teilen wir die Verantwortungsbereiche in uns in drei Bereiche ein: </p><br><ul><li>  externe Zone, Entit√§ten im Internet, wie JS-Anwendungen unseres Zahlungsformulars (Sie geben dort Ihre Kartendaten ein), Backends unserer H√§ndlerkunden sowie die Verarbeitung von Gateways unserer Partnerbanken und Anbieter anderer Zahlungsmethoden; </li><li>  Als interne, gut zug√§ngliche Zone leben dort Microservices, die die Arbeit des Zahlungsgateways direkt bereitstellen und die Abbuchung von Geld verwalten, wobei sie in unserem System und anderen Online-Diensten ber√ºcksichtigt werden, die durch die Anforderung gekennzeichnet sind, "trotz aller Ausf√§lle in unseren DCs immer verf√ºgbar zu sein". <br><ul><li>  Es gibt einen separaten Bereich von Diensten, die direkt mit den vollst√§ndigen Daten der Karteninhaber arbeiten. F√ºr diese Dienste gelten separate Anforderungen, die vom Eisenbahnministerium festgelegt wurden und die einer obligatorischen Zertifizierung gem√§√ü den PCI-DSS-Standards unterliegen.  Wir werden im Folgenden n√§her erl√§utern, warum eine solche Trennung vorliegt. </li></ul></li><li>  die innere Zone, in der im klassischen Sinne weniger Anforderungen an die Verf√ºgbarkeit der erbrachten Dienstleistungen oder den Zeitpunkt ihrer Beantwortung gestellt werden - dies ist ein Backoffice.  Obwohl wir hier nat√ºrlich auch versuchen, das Prinzip ‚Äûimmer verf√ºgbar‚Äú sicherzustellen, geben wir uns nur weniger M√ºhe daf√ºr; </li></ul><br><p>  Innerhalb jeder Zone gibt es Microservices, die ihre Teile der Verarbeitung von Gesch√§ftslogik ausf√ºhren.  Sie empfangen RPC-Aufrufe am Eingang und generieren am Ausgang Daten, die mit eingebetteten Algorithmen verarbeitet wurden, die auch als Aufrufe anderer Mikrodienste entlang der Kette ausgef√ºhrt werden. </p><br><p>  Um die Skalierbarkeit sicherzustellen, versuchen wir, Zust√§nde an m√∂glichst wenigen Stellen zu speichern.  Statuslose Dienste im Diagramm haben keine Verbindungen zu persistenten Speichern, bzw. Stateful-Dienste sind mit ihnen verbunden.  Im Allgemeinen verwenden wir mehrere eingeschr√§nkte Dienste f√ºr die dauerhafte Speicherung von Status. F√ºr den Hauptteil der Verarbeitung sind dies Riak-KV-Cluster, f√ºr verwandte Dienste - PostgreSQL - f√ºr die asynchrone Warteschlangenverarbeitung verwenden wir Kafka. </p><br><p>  Um eine hohe Verf√ºgbarkeit sicherzustellen, stellen wir Dienste in mehreren F√§llen bereit, normalerweise von 3 bis 5. </p><br><p>  Es ist einfach, zustandslose Dienste zu skalieren. Wir erh√∂hen einfach die Anzahl der Instanzen, die wir auf verschiedenen virtuellen Maschinen ben√∂tigen. Sie sind in Consul registriert. Sie k√∂nnen √ºber das Konsolen-DNS aufgel√∂st werden und beginnen, Anrufe von anderen Diensten zu empfangen, die empfangenen Daten zu verarbeiten und weiter zu senden. </p><br><p>  Stateful Services, oder besser gesagt unsere Hauptdienste, die im Diagramm als Machinegun dargestellt sind, implementieren eine leicht zug√§ngliche Schnittstelle (die verteilte Architektur basiert auf Erlang Distribution), und die Synchronisierung √ºber Consul KV wird verwendet, um Warteschlangen und verteiltes Sperren sicherzustellen.  Dies ist eine kurze, detaillierte Beschreibung, die in einem separaten Beitrag ver√∂ffentlicht wird. </p><br><p>  Riak bietet sofort einen hoch zug√§nglichen, dauerhaften, masterlosen Speicher. Wir bereiten ihn in keiner Weise vor. Die Konfiguration ist fast voreingestellt.  Mit dem aktuellen Lastprofil haben wir 5 Knoten im Cluster, die auf separaten Hosts bereitgestellt werden.  Ein wichtiger Hinweis: Wir verwenden praktisch keine Indizes und Stichproben mit gro√üen Datenmengen, sondern arbeiten mit bestimmten Schl√ºsseln. </p><br><p>  Wo die Implementierung des KV-Schemas zu teuer ist, verwenden wir PostgeSQL-Datenbanken mit Replikation oder sogar Single-Mode-L√∂sungen, da wir im Falle eines Fehlers immer die erforderlichen Ereignisse aus dem Online-Teil √ºber Machinegun hochladen k√∂nnen. </p><br><p>  Die Farbtrennung der Mikrodienste im Diagramm gibt die Sprachen an, in denen sie geschrieben sind - hellgr√ºn - dies sind Java-Anwendungen, hellblau - Erlang. </p><br><p>  Alle Dienste arbeiten in Docker-Containern, bei denen es sich um CI-Build-Artefakte handelt und die sich in der lokalen Docker-Registrierung befinden.  Stellt Dienste f√ºr die SaltStack-Produktion bereit, deren Konfiguration sich im privaten Github-Repository befindet. </p><br><p>  Entwickler fordern unabh√§ngig √Ñnderungen an diesem Repository an, in denen sie die Anforderungen f√ºr den Dienst beschreiben. Geben Sie die gew√ºnschte Version und die gew√ºnschten Parameter an, z. B. die Gr√∂√üe des f√ºr den Container zugewiesenen Speichers, der an Umgebungsvariablen und andere Dinge √ºbertragen wird.  Nach der manuellen Best√§tigung der √Ñnderungsanforderung durch autorisierte Mitarbeiter (wir haben DevOps, Support und Informationssicherheit) rollt die CD die Containerinstanzen mit den neuen Versionen automatisch auf die Hosts der Produktumgebung. </p><br><p><img src="https://habrastorage.org/webt/31/ec/iy/31eciyvgovypqogaegextoyyuf0.jpeg"></p><br><p>  Au√üerdem schreibt jeder Dienst Protokolle in einem Format, das f√ºr Elasticsearch verst√§ndlich ist.  Protokolldateien werden vom Filebeat erfasst, der sie in den Elasticsearch-Cluster schreibt.  Trotz der Tatsache, dass Entwickler keinen Zugriff auf die Produktumgebung haben, haben sie immer die M√∂glichkeit zu debuggen und zu sehen, was mit ihren Diensten passiert. </p><br><h2 id="vzaimodeystvie-s-vneshnim-mirom">  Interaktion mit der Au√üenwelt </h2><br><p><img src="https://habrastorage.org/webt/nd/wp/lw/ndwplwol-avyp6uixovsla-otfq.jpeg"></p><br><p>  Jede √Ñnderung des Status der Plattform bei uns erfolgt ausschlie√ülich durch Aufrufe der entsprechenden Methoden √∂ffentlicher APIs.  Wir verwenden keine klassischen Webanwendungen und keine serverseitige Inhaltsgenerierung. Alles, was Sie als Benutzeroberfl√§che sehen, sind JS-Ansichten √ºber unsere √∂ffentlichen APIs.  Grunds√§tzlich kann jede Aktion auf der Plattform mit einer Kette von Curl-Aufrufen von der Konsole ausgef√ºhrt werden, die wir verwenden.  Insbesondere zum Schreiben von Integrationstests (wir haben sie in JS als Bibliothek geschrieben), die in CI w√§hrend jeder Assembly alle √∂ffentlichen Methoden √ºberpr√ºfen. </p><br><p>  Ein solcher Ansatz l√∂st auch alle Probleme der externen Integration in unsere Plattform und erm√∂glicht es Ihnen, ein einziges Protokoll sowohl f√ºr den Endbenutzer in Form einer sch√∂nen Form der Eingabe von Zahlungsdaten als auch von Host zu Host f√ºr die direkte Integration in die Verarbeitung durch Dritte unter Verwendung ausschlie√ülich der Interaktion zwischen Servern zu erhalten. </p><br><p>  Zus√§tzlich zur vollst√§ndigen Abdeckung von Integrationstests verwenden wir die Ans√§tze des Staging-Updates. In einer verteilten Architektur ist dies recht einfach, indem beispielsweise nur ein Dienst aus jeder Gruppe in einem Durchgang bereitgestellt wird, gefolgt von einer Pause und Analyse von Protokollen und Grafiken. </p><br><p>  Auf diese Weise k√∂nnen wir fast rund um die Uhr, einschlie√ülich Freitagabend, etwas bereitstellen, das ohne gro√üe Angst au√üer Betrieb ist, oder schnell zur√ºcksetzen und ein einfaches Zur√ºcksetzen mit einer √Ñnderung durchf√ºhren, bis es niemand bemerkt. </p><br><h2 id="registraciya-v-platforme-i-publichnye-api">  Plattformregistrierung und √∂ffentliche APIs </h2><br><p><img src="https://habrastorage.org/webt/tw/m4/0l/twm40lykiloaelwx8elbj6shjge.jpeg"></p><br><p>  Vor jedem Aufruf der √∂ffentlichen Methode m√ºssen wir den Client autorisieren und authentifizieren.  Damit ein Client auf der Plattform angezeigt werden kann, ben√∂tigen Sie einen Dienst, der die gesamte Interaktion mit dem Endbenutzer √ºbernimmt und Schnittstellen zum Registrieren, Eingeben und Zur√ºcksetzen von Kennw√∂rtern, zur Sicherheitskontrolle und f√ºr andere Bindungen bereitstellt. </p><br><p>  Hier haben wir kein Fahrrad erfunden, sondern einfach die Open-Source-L√∂sung von Redhat - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keycloak integriert</a> .  Bevor Sie mit uns interagieren k√∂nnen, m√ºssen Sie sich auf der Plattform registrieren. Dies geschieht tats√§chlich √ºber Keycloak. </p><br><p>  Nach erfolgreicher Authentifizierung im Dienst erh√§lt der Client eine JWT.  Wir werden es sp√§ter f√ºr die Autorisierung verwenden. Auf der Keycloak-Seite k√∂nnen Sie beliebige Felder angeben, die Rollen beschreiben, die als einfache JSON-Struktur in JWT eingebettet und mit dem privaten Schl√ºssel des Dienstes signiert werden. </p><br><p>  <em>Eine der Funktionen von JWT ist, dass diese Struktur vom privaten Schl√ºssel des Servers signiert wird. Um die Liste der Rollen und ihrer anderen Objekte zu autorisieren, m√ºssen wir nicht auf den Autorisierungsdienst zugreifen. Der Prozess ist vollst√§ndig entkoppelt.</em>  <em>CAPI-Dienste lesen beim Start den √∂ffentlichen Keycloak-Schl√ºssel und autorisieren damit Aufrufe an √∂ffentliche API-Methoden.</em> </p><br><p>  <em>Als wir das Schl√ºssel-Widerrufsschema entwickelten, ist die Geschichte getrennt und verdient einen eigenen Beitrag.</em> </p><br><p>  Wir haben das JWT erhalten und k√∂nnen es zur Authentifizierung verwenden.  Hier kommt die Gruppe der Microservices Common API ins Spiel, die in dem als CAPI und CAPI-DSS angegebenen Diagramm die folgenden Funktionen implementiert: </p><br><ul><li>  Autorisierung empfangener Nachrichten.  Vor jedem √∂ffentlichen API-Aufruf steht ein HTTP-Header Authorizaion: Bearer {JWT}.  Die Dienste der Common API-Gruppe verwenden sie, um die signierten Daten mit dem vorhandenen √∂ffentlichen Schl√ºssel des Autorisierungsdienstes zu √ºberpr√ºfen. </li><li>  Validierung der empfangenen Daten.  Da das Schema als OpenAPI-Spezifikation, auch als Swagger bezeichnet, beschrieben wird, kann die Datenvalidierung sehr einfach sein und es besteht nur eine geringe Chance, Steuerbefehle im Datenstrom zu empfangen.  Dies wirkt sich positiv auf die Sicherheit des gesamten Dienstes aus. </li><li>  √úbersetzung von Datenformaten von √∂ffentlichem REST JSON in internen bin√§ren Thrift; </li><li>  Framing der Transportbindung mit Daten wie einer eindeutigen trace_id und Weitergabe des Ereignisses weiter innerhalb der Plattform an einen Service, der die Gesch√§ftslogik verwaltet und beispielsweise wei√ü, was Zahlung ist. </li></ul><br><p>  Wir haben viele solcher Dienste, sie sind recht einfach und aus Eichenholz, speichern keine Zust√§nde. F√ºr die lineare Leistungsskalierung setzen wir sie einfach mit freien Kapazit√§ten in den Mengen ein, die wir ben√∂tigen. </p><br><h3 id="pci-dss-i-otkrytye-kartochnye-dannye">  PCI-DSS und offene Kartendaten </h3><br><p><img src="https://habrastorage.org/webt/ak/fh/x-/akfhx-regosuv_tbadtr-x2p6uo.jpeg"></p><br><p>  Wie Sie in der Abbildung sehen k√∂nnen, gibt es zwei solcher Dienstgruppen: Die Hauptgruppe, die Common API, ist f√ºr die Verarbeitung aller Datenstr√∂me verantwortlich, f√ºr die keine offenen Karteninhaberdaten vorliegen, und die zweite, die PCI-DSS Common API, die direkt mit diesen Karten funktioniert.  Im Inneren sind sie genau gleich, aber wir haben sie physisch getrennt und auf verschiedenen Eisenst√ºcken angeordnet. </p><br><p>  Dies geschieht, um die Anzahl der Speicherorte f√ºr die Speicherung und Verarbeitung von Kartendaten zu minimieren, das Risiko eines Verlusts dieser Daten und des PCI-DSS-Zertifizierungsbereichs zu verringern.  Glauben Sie mir, dies ist ein ziemlich zeitaufw√§ndiger und kostspieliger Prozess. Als Zahlungsunternehmen m√ºssen wir uns jedes Jahr einer kostenpflichtigen Zertifizierung unterziehen, um die Einhaltung der MPS-Standards zu gew√§hrleisten. Je weniger Server und Dienste daran beteiligt sind, desto schneller und einfacher ist es, diesen Prozess abzuschlie√üen.  Nun, was die Sicherheit betrifft, spiegelt sich dies am positivsten wider. </p><br><h2 id="obrabotka-platezhnyh-dannyh-i-tokenizaciya">  Abrechnung und Tokenisierung </h2><br><p><img src="https://habrastorage.org/webt/2y/ya/cm/2yyacmg2lhhzmvnbjv0azaei8gi.jpeg"></p><br><p>  Wir m√∂chten also mit der Zahlung beginnen und Geld von der Karte des Zahlers abschreiben. </p><br><p>  Stellen Sie sich vor, die Anfrage dazu kam in Form einer Kette von Aufrufen der Methoden unserer √∂ffentlichen API, die von Ihnen als Zahler initiiert wurde, nachdem Sie in den Online-Shop gegangen waren, einen Warenkorb abgeholt, auf "Kaufen" geklickt und Ihre Kartendaten in unsere Zahlung eingegeben hatten Formular und klickte auf die Schaltfl√§che "Bezahlen". </p><br><p>  <em>Wir bieten verschiedene Gesch√§ftsprozesse zum Abschreiben von Geld an. Am interessantesten ist jedoch der Prozess der Verwendung von Kreditorenbuchhaltung.</em>  <em>Auf unserer Plattform k√∂nnen Sie eine Rechnung f√ºr die Zahlung oder eine Rechnung erstellen, die ein Container f√ºr Zahlungen ist.</em> </p><br><p>  <em>Innerhalb einer Rechnung k√∂nnen Sie versuchen, sie einzeln zu bezahlen, dh Zahlungen erstellen, bis die n√§chste Zahlung erfolgreich ist.</em>  <em>Sie k√∂nnen beispielsweise versuchen, eine Rechnung mit verschiedenen Karten, Brieftaschen und anderen Zahlungsmethoden zu bezahlen.</em>  <em>Wenn auf einer der Karten kein Geld vorhanden ist, k√∂nnen Sie eine andere versuchen und so weiter.</em> </p><br><p>  <em>Dies wirkt sich positiv auf die Conversion und die Benutzererfahrung aus.</em> </p><br><h3 id="konechnyy-avtomat-invoysa">  Rechnungszustandsmaschine </h3><br><p><img src="https://habrastorage.org/webt/gh/u0/ld/ghu0ld9cimq5z13mc1blstsuycy.jpeg"></p><br><p>  Innerhalb der Plattform verwandelt sich diese Kette auf folgendem Weg in Interaktionen: </p><br><ul><li>  Vor der √úbermittlung von Inhalten an Ihren Browser hat sich unser Client-H√§ndler in unsere Plattform integriert, sich bei uns registriert und ein JWT zur Autorisierung erhalten. </li><li>  In seinem Backend hat der H√§ndler die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">createInvoice ()</a> aufgerufen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> er hat eine Rechnung f√ºr die Zahlung auf unserer Plattform erstellt.  Tats√§chlich hat das H√§ndler-Backend eine HTTP-POST-Anforderung mit folgendem Inhalt an unseren Endpunkt gesendet: </li></ul><br><pre><code class="bash hljs">curl -X POST \ https://api.rbk.money/v2/processing/invoices \ -H <span class="hljs-string"><span class="hljs-string">'Authorization: Bearer {JWT}'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json; charset=utf-8'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'X-Request-ID: 1554417367'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'cache-control: no-cache'</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{ "shopID": "TEST", "dueDate": "2019-03-28T17:41:32.569Z", "amount": 6000, "currency": "RUB", "product": "Order num 12345", "description": "Delicious meals", "cart": [ { "price": 5000, "product": "Sandwich", "quantity": 1, "taxMode": { "rate": "10%", "type": "InvoiceLineTaxVAT" } }, { "price": 1000, "product": "Cola", "quantity": 1, "taxMode": { "rate": "18%", "type": "InvoiceLineTaxVAT" } } ], "metadata": { "order_id": "Internal order num 13123298761" } }'</span></span></code> </pre> <br><p>  Die Anforderung wurde auf einer der erlang-Anwendungen der Common API-Gruppe abgewogen, die ihre G√ºltigkeit √ºberpr√ºfte, an den Bender-Dienst ging, wo sie den Idempotenzschl√ºssel erhielt, ihn an den Tift √ºbertrug und eine Anforderung an die Hellgate-Dienstgruppe sendete.  Die Hellgate-Instanz f√ºhrte Gesch√§ftspr√ºfungen durch, stellte beispielsweise sicher, dass der Eigent√ºmer dieses JWT nicht grunds√§tzlich blockiert ist, Rechnungen erstellen und im Allgemeinen mit der Plattform interagieren kann, und begann mit der Erstellung einer Rechnung. </p><br><p>  <em>Wir k√∂nnen sagen, dass Hellgate der Kern unserer Verarbeitung ist, da es mit Gesch√§ftseinheiten zusammenarbeitet und wei√ü, wie man eine Zahlung startet, wer gekickt werden muss, damit diese Zahlung zu einer echten Geldgeb√ºhr wird, wie man den Weg dieser Zahlung berechnet und wer angewiesen werden sollte, sie abzuschreiben Berechnen Sie in den Bilanzen Provisionen und andere Bindungen.</em> </p><br><p>  <em>Normalerweise speichert es auch keine Zust√§nde und ist auch leicht skalierbar.</em>  <em>Wir m√∂chten jedoch nicht die Rechnung verlieren oder eine doppelte Geb√ºhr von der Karte erhalten, wenn das Netzwerk aufgeteilt wird oder Hellgate aus irgendeinem Grund ausf√§llt.</em>  <em>Es ist notwendig, diese Daten dauerhaft zu speichern.</em> </p><br><p>  Hier kommt der dritte Microservice, n√§mlich Machinegun.  Hellgate sendet Machinegun einen Aufruf zum "Erstellen eines Automaten" mit einer Nutzlast in Form von Abfrageparametern.  Machinegun organisiert gleichzeitige Anforderungen und erstellt mit Hellgate das erste Ereignis aus den Parametern - InvoiceCreated.  Welches dann selbst und schreibt in Riak und Warteschlangen.  Danach wird eine erfolgreiche Antwort in umgekehrter Reihenfolge auf die urspr√ºngliche Anforderung in der Kette zur√ºckgegeben. </p><br><p>  <em>Kurz gesagt, Machinegun ist ein solches DBMS mit Timern √ºber jedes andere DBMS in der aktuellen Version der Plattform - √ºber Riak.</em>  <em>Es bietet eine Schnittstelle, √ºber die Sie unabh√§ngige Maschinen steuern k√∂nnen, und bietet Garantien f√ºr Idempotenz und Aufzeichnungsreihenfolge.</em>  <em>Es ist MG, das nicht zul√§sst, dass das Ereignis automatisch aus der Warteschlange geschrieben wird, wenn pl√∂tzlich mehrere HGs mit einer solchen Anfrage zu ihm kommen.</em> </p><br><p>  <em>Ein Automat ist eine eindeutige Entit√§t innerhalb der Plattform, die aus einer Kennung, einem Datensatz in Form einer Ereignisliste und einem Timer besteht.</em>  <em>Der Endzustand des Automaten wird aus der Verarbeitung aller seiner Ereignisse berechnet, die seinen √úbergang in den entsprechenden Zustand einleiten.</em>  <em>Wir verwenden diesen Ansatz, um mit Gesch√§ftseinheiten zu arbeiten und sie als endliche Zustandsmaschinen zu beschreiben.</em>  <em>Tats√§chlich sind alle von unseren H√§ndlern erstellten Rechnungen sowie die darin enthaltenen Zahlungen endliche Zustandsmaschinen mit ihrer eigenen Logik des √úbergangs zwischen Staaten.</em> </p><br><p>  <em>√úber die Schnittstelle zum Arbeiten mit Timern in Machinegun k√∂nnen Sie eine Anfrage des Formulars "Ich m√∂chte diese Maschine in 15 Jahren weiter verarbeiten" von einem anderen Dienst zusammen mit Ereignissen f√ºr die Aufzeichnung erhalten.</em>  <em>Solche anstehenden Aufgaben werden auf eingebauten Timern implementiert.</em>  <em>In der Praxis werden sie sehr h√§ufig verwendet - regelm√§√üige Anrufe bei der Bank, automatische Aktionen mit Zahlungen aufgrund langer Inaktivit√§t usw.</em> </p><br><p>  <em>Machinegun-Quellcodes sind √ºbrigens unter der Apache 2.0-Lizenz in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√∂ffentlichen Repository ge√∂ffnet</a> .</em>  <em>Wir hoffen, dass dieser Service f√ºr die Community von Nutzen sein kann.</em> </p><br><p>  <em>Eine detaillierte Beschreibung der Arbeit von Machinegun und im Allgemeinen der Vorbereitung des Vertriebssystems finden Sie in einem separaten gro√üen Beitrag, sodass ich hier nicht n√§her darauf eingehen werde.</em> </p><br><h3 id="nyuansy-avtorizacii-vneshnih-klientov">  Die Nuancen der Autorisierung externer Kunden </h3><br><p><img src="https://habrastorage.org/webt/-l/4v/zo/-l4vzorvyofnp2f4cb9xq6n3oky.jpeg"></p><br><p>  Nach einem erfolgreichen Speichervorgang gibt Hellgate die Daten an das CAPI zur√ºck und konvertiert die bin√§re Trift-Struktur in einen wundersch√∂n gestalteten JSON, der an das H√§ndler-Backend gesendet werden kann: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"invoice"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cart"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sandwich"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"taxMode"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rate"</span></span>: <span class="hljs-string"><span class="hljs-string">"10%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"InvoiceLineTaxVAT"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cola"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"taxMode"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rate"</span></span>: <span class="hljs-string"><span class="hljs-string">"18%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"InvoiceLineTaxVAT"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"createdAt"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-04-04T23:00:31.565518Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-string"><span class="hljs-string">"RUB"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Delicious meals"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dueDate"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-04-05T00:00:30.889000Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"18xtygvzFaa"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"order_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"Internal order num 13123298761"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Order num 12345"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"shopID"</span></span>: <span class="hljs-string"><span class="hljs-string">"TEST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"unpaid"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"invoiceAccessToken"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payload"</span></span>: <span class="hljs-string"><span class="hljs-string">"{JWT}"</span></span> } }</code> </pre> <br><p>  Es scheint, dass Sie Inhalte im Browser an den Zahler senden und den Zahlungsprozess starten k√∂nnen. Hier dachten wir jedoch, dass nicht alle H√§ndler bereit w√§ren, die Autorisierung auf Kundenseite unabh√§ngig zu implementieren, und haben sie daher selbst implementiert.  Der Ansatz besteht darin, dass CAPI ein weiteres JWT generiert, mit dem Sie Karten-Tokenisierungsprozesse starten, eine bestimmte Rechnung verwalten und der zur√ºckgegebenen Rechnungsstruktur hinzuf√ºgen k√∂nnen. </p><br><p>  Ein Beispiel f√ºr die in einem √§hnlichen JWT beschriebenen Rollen: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"resource_access"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"common-api"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roles"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa.payments:read"</span></span>, <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa.payments:write"</span></span>, <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa:read"</span></span>, <span class="hljs-string"><span class="hljs-string">"payment_resources:write"</span></span> ] } }</code> </pre> <br><p>  Diese JWT hat eine begrenzte Anzahl von Versuchen und die von uns konfigurierte Lebensdauer, sodass Sie sie im Browser des Zahlers ver√∂ffentlichen k√∂nnen.  Selbst wenn es abgefangen wird, kann ein Angreifer maximal die Rechnung eines anderen bezahlen oder seine Daten lesen.  Da der Zahlungsautomat nicht mit offenen Kartendaten arbeitet, kann ein Angreifer maximal eine maskierte Kartennummer vom Typ <code>4242 42** **** 4242</code> , den Zahlungsbetrag und optional einen Warenkorb sehen. </p><br><p>  Mit der erstellten Rechnung und dem Zugriffsschl√ºssel k√∂nnen Sie den Zahlungsgesch√§ftsprozess starten.  Wir geben die Rechnungs-ID und deren JWT an den Zahlerbrowser weiter und √ºbertragen die Kontrolle auf unsere JS-Anwendungen. </p><br><p>  Unsere Checkout JS-Anwendung implementiert eine Schnittstelle f√ºr die Interaktion mit Ihnen als Zahler - zeichnet ein Zahlungsdateneingabeformular, startet eine Zahlung, erh√§lt den endg√ºltigen Status, zeigt einen lustigen oder traurigen Punkt. </p><br><h3 id="tokenizaciya-i-kartochnye-dannye">  Tokenisierung und Kartendaten </h3><br><p><img src="https://habrastorage.org/webt/gq/1d/gb/gq1dgbxkq1ewsfohsytcdvnotzs.jpeg"></p><br><p>  Checkout funktioniert jedoch nicht mit Kartendaten.  Wie oben erw√§hnt, m√∂chten wir sensible Daten in Form von Karteninhaberdaten an m√∂glichst wenigen Orten speichern.  Dazu implementieren wir die Tokenisierung. </p><br><p>  Hier kommt die Tokenizer JS-Bibliothek ins Spiel.  Wenn Sie Ihre Karte in die Eingabefelder eingeben und auf "Bezahlen" klicken, werden diese Daten abgefangen und asynchron zur Verarbeitung an uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesendet,</a> indem die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">createPaymentResource () aufgerufen</a> wird. </p><br><p>  Diese Anforderung wird f√ºr einzelne CAPI-DSS-Anwendungen ausgeglichen, die die Anforderung auch nur durch √úberpr√ºfen der Rechnungs-JWT autorisieren, die Daten validieren und per tront an den Kartendatenspeicherdienst senden.  In der Abbildung wird es als CDS - Card Data Storage angezeigt. </p><br><p>  Die Hauptziele dieses Dienstes: </p><br><ul><li>  Empfangen sensibler Daten √ºber eine Eingabe, in unserem Fall - Daten Ihrer Karte; </li><li>  diese Daten mit einem Datenverschl√ºsselungsschl√ºssel verschl√ºsseln; </li><li>  einen zuf√§lligen Wert erzeugen, der als Schl√ºssel verwendet wird; </li><li>  Speichern Sie verschl√ºsselte Daten auf diesem Schl√ºssel in Ihrem Riak-Cluster. </li><li>  Senden Sie den Schl√ºssel in Form eines Zahlungsdaten-Tokens an den CAPI-DSS-Dienst zur√ºck. </li></ul><br><p>  Unterwegs l√∂st der Dienst eine Reihe wichtiger Aufgaben, z. B. das Generieren von Schl√ºsseln zum Verschl√ºsseln von Schl√ºsseln, das sichere Eingeben dieser Schl√ºssel, das erneute Verschl√ºsseln von Daten, das Steuern des L√∂schens von CVV nach der Zahlung usw. Dies geht jedoch √ºber den Rahmen dieses Beitrags hinaus. </p><br><p>  <em>Es war nicht ohne Schutz vor der M√∂glichkeit, sich in den Fu√ü zu schie√üen.</em>  <em>Es besteht eine Wahrscheinlichkeit ungleich Null, dass ein privates JWT, mit dem Anforderungen vom Backend autorisiert werden sollen, im Internet im Browser des Clients ver√∂ffentlicht wird.</em>  <em>Um dies zu verhindern, haben wir einen integrierten Schutz eingerichtet. Sie k√∂nnen die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">createPaymentResource ()</a> nur mit dem Rechnungsautorisierungsschl√ºssel aufrufen.</em>  <em>Wenn Sie versuchen, eine private JWT-Plattform zu verwenden, wird ein HTTP / 401-Fehler zur√ºckgegeben.</em> </p><br><p>  Nach Abschluss der Tokenisierungsanforderung sendet der Tokenizer das empfangene Token an Checkout zur√ºck und beendet seine Arbeit daran. </p><br><h3 id="biznes-process-platezhnogo-avtomata">  Gesch√§ftsprozess der Zahlungsmaschine </h3><br><p><img src="https://habrastorage.org/webt/ai/9s/7j/ai9s7jsxfzkuoume64zcw_chcks.png"></p><br><p>  Checkout startet den Zahlungsvorgang, indem es die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">createPayment () aufruft</a> , das Token der zuvor empfangenen Kartendaten √ºbergibt und den Vorgang des Abrufs von Ereignissen startet. Tats√§chlich wird die API-Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getInvoiceEvents ()</a> einmal pro Sekunde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgerufen</a> . </p><br><p>  Diese Anforderungen √ºber CAPI fallen in Hellgate, das mit der Implementierung eines Zahlungsgesch√§ftsprozesses beginnt, ohne Kartendaten zu verwenden: </p><br><ul><li>  Zun√§chst wechselt Hellgate zum Konfigurationsverwaltungsdienst Dominant und erh√§lt die aktuelle Version der Dom√§nenkonfiguration.  Es enth√§lt alle Regeln, nach denen diese Zahlung erfolgt, f√ºr welche Bank die Autorisierung erfolgt, welche Transaktionsgeb√ºhren erfasst werden usw. <br><ul><li>  Vom Mitgliederverwaltungsdienst, der jetzt Teil von HG ist, erf√§hrt er Daten √ºber die internen Nummern der Konten des H√§ndlers, f√ºr die die Zahlung erfolgt, wendet den Geb√ºhrenbetrag an, erstellt einen Buchungsplan und stellt ihn in den Shumway-Dienst.  Dieser Dienst ist f√ºr die Verwaltung von Informationen √ºber die Geldbewegung auf den Konten der Teilnehmer einer Transaktion bei der Zahlung verantwortlich.  Der Buchungsplan enth√§lt die Anweisung, "die m√∂gliche Bewegung von Geldern auf den Konten der Teilnehmer an der im Plan angegebenen Transaktion einzufrieren"; </li><li>  bereichert Zahlungsdaten durch Bezugnahme auf zus√§tzliche Dienste, beispielsweise in Binbase, um das Land der ausstellenden Bank, die die Karte ausgestellt hat, und deren Typ herauszufinden, z. B. ‚ÄûGold, Kredit‚Äú; </li><li>  Ruft in der Regel den Inspektorendienst an. Dies ist Antifraud, um eine Zahlungsbewertung zu erhalten und √ºber die Wahl eines Terminals zu entscheiden, das das durch die Bewertung ausgegebene Risikograd abdeckt.  Beispielsweise kann ein Terminal ohne 3D-Secure f√ºr Zahlungen mit geringem Risiko verwendet werden, und eine Zahlung, die ein schwerwiegendes Risiko erhalten hat, endet damit. </li><li>  ruft den Fehlererkennungsdienst, den Fehlerdetektor, auf und w√§hlt auf der Grundlage der von ihm empfangenen Daten den Zahlungsweg aus - den Bankprotokolladapter, der derzeit die wenigsten Fehler und die h√∂chste Wahrscheinlichkeit f√ºr eine erfolgreiche Zahlung aufweist; </li><li>  sendet eine Anfrage an den ausgew√§hlten Bankprotokolladapter, sei es der YellowBank-Adapter, in diesem Fall "autorisiere den angegebenen Betrag von diesem Token". </li></ul></li></ul><br><p>  Der Protokolladapter f√ºr das empfangene Token geht an CDS, empf√§ngt die entschl√ºsselten Kartendaten, √ºbertr√§gt sie an ein bankspezifisches Protokoll und erh√§lt im Allgemeinen eine Autorisierung - Best√§tigung von der erwerbenden Bank, dass der angegebene Betrag auf dem Konto des Zahlers eingefroren wurde. </p><br><p>  In diesem Moment erhalten Sie eine SMS mit einer Nachricht √ºber die Abbuchung von Guthaben von Ihrer Karte von Ihrer Bank, obwohl das Guthaben tats√§chlich nur auf Ihrem Konto eingefroren wurde. </p><br><p>  Der Adapter benachrichtigt HG √ºber die erfolgreiche Autorisierung, Ihr CVV-Code wird aus dem CDS-Dienst entfernt und dies ist das Ende der Interaktionsphase.  Das Management kehrt zu HG zur√ºck. </p><br><p><img src="https://habrastorage.org/webt/jv/mm/cu/jvmmcuhwjxslwo0rvu5w-lsfsyy.jpeg"></p><br><p>  Abh√§ngig von dem Aufruf von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">createPayment ()</a> , der vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">H√§ndler des</a> Zahlungsgesch√§ftsprozesses angegeben wurde, erwartet HG Aufrufe von der externen API zur Autorisierungserfassungsmethode, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> Best√§tigung des Abhebens von Geld von Ihrer Karte, oder sofort selbst, wenn der H√§ndler das Schema gew√§hlt hat einstufige Zahlung. </p><br><p>  <em>In der Regel verwenden die meisten H√§ndler eine einstufige Zahlung. Es gibt jedoch Gesch√§ftskategorien, die zum Zeitpunkt der Autorisierung den belasteten Gesamtbetrag noch nicht kennen.</em>  <em>Dies ist in der Tourismusbranche h√§ufig der Fall, wenn Sie eine Tour f√ºr einen Betrag buchen. Nach Best√§tigung der Reservierung wird der Betrag angegeben und kann von dem zu Beginn genehmigten Betrag abweichen.</em> </p><br><p>  <em>Trotz der Tatsache, dass der Best√§tigungsbetrag ausschlie√ülich gleich oder kleiner als der Autorisierungsbetrag sein kann, gibt es hier Fallstricke.</em>  <em>Stellen Sie sich vor, Sie bezahlen ein Produkt oder eine Dienstleistung mit einer Karte in einer anderen W√§hrung als der W√§hrung Ihres Bankkontos, mit dem die Karte verkn√ºpft ist.</em> </p><br><p>  <em>Zum Zeitpunkt der Autorisierung wird der auf Ihrem Konto gesperrte Betrag basierend auf dem Wechselkurs am Tag der Autorisierung gesperrt.</em>  <em>Da die Zahlung m√∂glicherweise mehrere Tage lang den Status ‚Äûgenehmigt‚Äú hat (obwohl das Eisenbahnministerium Empfehlungen f√ºr einen H√∂chstzeitraum hat und jetzt 3 Tage betr√§gt), erfolgt die Erfassung der Genehmigung zum Tagessatz.</em> </p><br><p>  <em>Sie tragen also W√§hrungsrisiken, die sowohl zu Ihren Gunsten als auch gegen Sie sein k√∂nnen, insbesondere in einer Situation hoher Volatilit√§t am Devisenmarkt.</em> </p><br><p>  Um die Autorisierung zu erfassen, erfolgt der gleiche Kommunikationsprozess mit dem Protokolladapter wie f√ºr den Empfang. Bei Erfolg wendet HG den Kontobuchungsplan in Shumway an und √ºbertr√§gt die Zahlung in den Status "Bezahlt".  In diesem Moment haben wir als Zahlungssystem finanzielle Verpflichtungen gegen√ºber den Teilnehmern der Transaktion. </p><br><p>  Es ist auch erw√§hnenswert, dass alle √Ñnderungen im Status des Rechnungsautomaten, einschlie√ülich des Zahlungsvorgangs, von Hellgate in Machinegun aufgezeichnet werden, um die Datenpersistenz sicherzustellen und die Rechnung mit neuen Ereignissen anzureichern. </p><br><h3 id="sinhronizaciya-sostoyaniy-avtomata-platezha-i-ui">  Statussynchronisation eines Zahlungsautomaten und der Benutzeroberfl√§che </h3><br><p><img src="https://habrastorage.org/webt/o7/hf/iz/o7hfizxfqdiyz_5xlxugdhc_fsq.jpeg"></p><br><p>  W√§hrend der Hintergrundzahlungsprozess innerhalb der Plattform stattfindet, gie√üt Checkout die Verarbeitung durch Anfordern von Ereignissen.  Nach Erhalt bestimmter Ereignisse zeichnet er den aktuellen Status der Zahlung in einer f√ºr eine Person verst√§ndlichen Form - zeichnet einen Preloader, zeigt den Bildschirm "Ihre Zahlung wurde erfolgreich verarbeitet" oder "Zahlung konnte nicht abgeschlossen werden" an oder leitet den Browser auf die Seite Ihrer ausstellenden Bank weiter, um das 3D-Secure-Passwort einzugeben. </p><br><p>  Wenn dies fehlschl√§gt, bietet Checkout Ihnen an, eine andere Zahlungsmethode zu w√§hlen oder es erneut zu versuchen, um eine neue Zahlung als Teil der Rechnung zu starten. </p><br><p>  Ein solches Schema mit Abfrage von Ereignissen erm√∂glicht es, den Status auch nach dem Schlie√üen der Browser-Registerkarte wiederherzustellen. Bei wiederholtem Start erh√§lt Checkout die aktuelle Liste der Ereignisse und zeichnet das aktuelle Szenario der Benutzerinteraktion, schl√§gt beispielsweise die Eingabe des 3D-Secure-Codes vor oder zeigt an, dass die Zahlung bereits erfolgreich abgeschlossen wurde. </p><br><h2 id="replikaciya-sobytiy-v-offline-zone">  Replikation von Ereignissen in der Offline-Zone </h2><br><p><img src="https://habrastorage.org/webt/ay/rm/sb/ayrmsbidsvdz2c9rxxkgge6easo.jpeg"></p><br><p>  Zusammen mit den Maschinensteuerungsschnittstellen implementiert Machinegun einen Dienst, der f√ºr den √úberlauf des Ereignisflusses zu Diensten verantwortlich ist, die f√ºr andere, weniger Online-Aufgaben der Plattform verantwortlich sind. </p><br><p>  Als Warteschlangenmakler im Finale haben wir uns f√ºr Kafka entschieden, obwohl wir diese Funktionalit√§t zuvor mit Machinegun selbst implementiert haben.  Im allgemeinen Fall handelt es sich bei diesem Dienst um die Aufrechterhaltung eines garantierten geordneten Ereignisstroms oder um die Herausgabe einer bestimmten Liste von Ereignissen auf Anfrage an andere Verbraucher. </p><br><p>  Wir haben auch zun√§chst ein Ereignis-Deduplizierungsschema implementiert, das garantiert, dass dasselbe Ereignis nicht zweimal repliziert wird. Die Belastung von Riak, die durch ein √§hnliches Ereignis generiert wurde, hat uns jedoch gezwungen, es aufzugeben - schlie√ülich ist die Indexsuche nicht das Beste KV speicherf√§hig.  Jetzt ist jeder Service-Consumer unabh√§ngig f√ºr die Ereignis-Deduplizierung verantwortlich. </p><br><p>  Im Allgemeinen endet die Replikation von Ereignissen durch Machinegun mit der Best√§tigung der Datenspeicherung in Kafka. Die Verbraucher sind bereits mit den Kafka-Themen verbunden und laden die Liste der Ereignisse herunter, die sie interessieren. </p><br><h3 id="shablon-tipichnogo-prilozheniya-offline-zony">  Typische Offline-Zonenanwendungsvorlage </h3><br><p>  Der Dudoser-Dienst ist beispielsweise daf√ºr verantwortlich, Ihnen eine E-Mail-Benachrichtigung √ºber eine erfolgreiche Zahlung zu senden.  Beim Start wird eine Liste der Ereignisse erfolgreicher Zahlungen ausgepumpt, von dort werden Informationen zu Adresse und Betrag abgerufen, in einer lokalen PostgreSQL-Instanz gespeichert und zur weiteren Verarbeitung der Gesch√§ftslogik verwendet. </p><br><p>  Alle anderen √§hnlichen Dienste arbeiten nach derselben Logik, z. B. der Magista-Dienst, der f√ºr die Suche nach Rechnungen und Zahlungen auf dem pers√∂nlichen Konto des H√§ndlers verantwortlich ist, oder der Hooker-Dienst, der asynchrone R√ºckrufe an das Backend an H√§ndler sendet, die aus dem einen oder anderen Grund keine Abrufereignisse durch Kontaktaufnahme organisieren k√∂nnen direkt an die Verarbeitungs-API. </p><br><p>  Dieser Ansatz erm√∂glicht es uns, die Verarbeitung zu entlasten, maximale Ressourcen zuzuweisen, eine hohe Geschwindigkeit und Verf√ºgbarkeit der Zahlungsverarbeitung bereitzustellen und eine hohe Conversion zu erzielen.  Schwere Anfragen wie "Gesch√§ftskunden m√∂chten Statistiken √ºber Zahlungen im letzten Jahr sehen" werden von Diensten verarbeitet, die die aktuelle Auslastung des Online-Verarbeitungsteils nicht beeinflussen und Sie als Zahler und H√§ndler daher nicht als unsere Kunden betreffen. </p><br><p>  Vielleicht h√∂ren wir damit auf, um den Beitrag nicht zu lang zu machen.  In zuk√ºnftigen Artikeln werde ich Ihnen auf jeden Fall die Nuancen der Sicherstellung der Atomizit√§t von √Ñnderungen, Garantien und Ordnungen in einem geladenen verteilten System anhand von Machinegun, Bender, CAPI und Hellgate als Beispiel erl√§utern. </p><br><p>  Nun, √ºber Salt Stack beim n√§chsten Mal <code>¬Ø\_(„ÉÑ)_/¬Ø</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447440/">https://habr.com/ru/post/de447440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447426/index.html">Wie, zu wem und warum zur Beratung gehen? Pers√∂nliche Erfahrung mit Big Data</a></li>
<li><a href="../de447430/index.html">IntelliJ IDEA 2019.1: Anpassung von Schnittstellenthemen, Wechseln von Ausdr√ºcken aus Java 12, Debuggen in Docker-Containern</a></li>
<li><a href="../de447434/index.html">Mit Liebe von Stepik: Hyperskill Bildungsplattform</a></li>
<li><a href="../de447436/index.html">Webinar "Warum brauchen wir Tester?"</a></li>
<li><a href="../de447438/index.html">Unittest und abstrakte Tests</a></li>
<li><a href="../de447442/index.html">Einf√ºhrung in den Shell-Operator: Vereinfachung der Bediener f√ºr Kubernetes</a></li>
<li><a href="../de447446/index.html">IBM Workshops: Fr√ºhling-Sommer 2019 - K√ºnstliche Intelligenz, Cloud-Entwicklung, Chat-Bots, Blockchain und andere Technologien</a></li>
<li><a href="../de447448/index.html">Intelligenz Evolution: Der Anfang</a></li>
<li><a href="../de447450/index.html">Mit Ghidra einen einfachen ‚ÄûRiss‚Äú brechen - Teil 1</a></li>
<li><a href="../de447452/index.html">Supply Chain Security: "Wenn ich ein Nationalstaat w√§re ..."</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>