<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úîÔ∏è üõë üî´ Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 4) üë©üèº‚Äçüè≠ üå∑ üë®‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Und wieder habe ich das Volumen des Artikels √ºbersch√§tzt! Ich plante, dass dies der letzte Artikel sein w√ºrde, in dem wir einen Compiler erstellen und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Car (und mehr) Indianer"><br><br>  Und wieder habe ich das Volumen des Artikels √ºbersch√§tzt!  Ich plante, dass dies der letzte Artikel sein w√ºrde, in dem wir einen Compiler erstellen und Tests durchf√ºhren werden.  Aber das Volumen stellte sich als gro√ü heraus und ich beschloss, den Artikel in zwei Teile zu teilen. <br><br>  In diesem Artikel werden wir fast alle Grundfunktionen des Compilers ausf√ºhren.  Es wird zum Leben erweckt und es wird m√∂glich sein, ziemlich seri√∂sen Code zu schreiben, zu kompilieren und auszuf√ºhren.  Und wir werden im n√§chsten Teil Tests durchf√ºhren.  (√úbrigens die vorherigen Teile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei</a> ). <br><br>  Ich schreibe zum ersten Mal in Habr√©, vielleicht ist es nicht immer in Ordnung.  Meiner Meinung nach erwiesen sich die Artikel 2, 3 als ziemlich trocken, viel Code, wenig Beschreibung.  Dieses Mal werde ich versuchen, etwas anderes zu machen und mich auf die Beschreibung der Ideen selbst konzentrieren.  Nun, der Code ... der Code, nat√ºrlich wird es!  Wer es gr√ºndlich verstehen will, wird eine solche Gelegenheit haben.  In vielen F√§llen werde ich den Code unter den Spoiler stellen.  Und nat√ºrlich k√∂nnen Sie immer die vollst√§ndige Quelle auf dem Github anzeigen. <br><br>  Der Compiler schreibt noch einige Zeit in Assembler, geht dann aber zum Fort und schreibt den Compiler weiter auf uns.  Dies wird Baron M√ºnchhausen √§hneln, der sich an den Haaren aus dem Sumpf zog.  Aber f√ºr den Anfang werde ich skizzieren, wie der Compiler auf dem Fort funktioniert.  Willkommen bei Katze! <br><a name="habracut"></a><br><h4>  Wie funktioniert der Compiler? </h4><br>  Der Speicher in der Festung besteht aus einem fortlaufenden Fragment, in dem W√∂rterbucheintr√§ge nacheinander angeordnet sind.  Nach ihrer Fertigstellung folgt ein freier Speicherbereich.  Das erste freie Byte wird durch die Variable h angezeigt.  Es gibt hier auch das h√§ufig verwendete Wort, das die Adresse des ersten freien Bytes auf dem Stapel verschiebt. Es wird sehr einfach bestimmt: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Erw√§hnenswert ist das Wort allot, das die angegebene Anzahl von Bytes durch Bewegen des Zeigers h reserviert.  Das Wort Zuteilung kann wie folgt definiert werden: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  Tats√§chlich verwendet der Compiler einen speziellen Interpreter-Modus sowie einige spezielle W√∂rter.  Mit einem Satz k√∂nnen Sie also das gesamte Prinzip des Compilers in der Festung beschreiben.  In welchem ‚Äã‚ÄãModus der Interpreter arbeitet, wird durch die Zustandsvariable bestimmt.  Wenn es Null ist, wird der Ausf√ºhrungsmodus eingestellt, andernfalls - Kompilierungsmodus.  Wir kennen den Ausf√ºhrungsmodus bereits, darin werden die W√∂rter aus dem Eingabepuffer einfach nacheinander ausgef√ºhrt.  Im Kompilierungsmodus werden sie jedoch nicht ausgef√ºhrt, sondern vom Zeiger h in den Speicher kompiliert.  Dementsprechend bewegt sich der Zeiger vorw√§rts. <br><br>  In der klassischen Festung wird das Wort "," verwendet, um einen ganzzahligen Wert zu kompilieren, das Wort "c" wird verwendet, um ein Byte zu kompilieren.  Unser System verwendet Werte unterschiedlicher Bittiefe (8, 16, 32, 64), daher werden zus√§tzlich die W√∂rter "w" und "i" verwendet.  Wir machen auch das Wort "str", das die Zeichenfolge kompiliert und zwei Werte aus dem Stapel entnimmt - die Adresse und die L√§nge der Zeichenfolge. <br><br>  Spezielle Compilerw√∂rter werden verwendet, um Kontrollstrukturen zu bilden.  Dies sind die W√∂rter if, do, loop und andere.  Diese W√∂rter werden auch im Kompilierungsmodus ausgef√ºhrt.  Beispiel: Das Wort if kompiliert bei der Ausf√ºhrung einen bedingten Verzweigungsbytebefehl (? Nbranch).  Damit das System wei√ü, welche W√∂rter im Kompilierungsmodus ausgef√ºhrt und nicht kompiliert werden m√ºssen, wird das unmittelbare Flag (Vorzeichen) verwendet.  Wir haben es bereits im Flag-Feld des W√∂rterbucheintrags.  Im Assembler-Quellcode hei√üt es f_immediate.  Verwenden Sie das Wort sofort, um dieses Flag zu setzen.  Es hat keine Parameter, das unmittelbare Flag wird beim letzten Wort im W√∂rterbuch gesetzt. <br><br>  Gehen wir jetzt von der Theorie zur Praxis! <br><br><h4>  Vorbereitung </h4><br>  Am Anfang m√ºssen wir einige einfache Bytebefehle in der Assemblersprache ausf√ºhren, die wir ben√∂tigen.  Hier sind sie: Verschieben (Kopieren des Speicherbereichs), F√ºllen (F√ºllen des Speicherbereichs), Bitoperationen (und / oder xor, Invertieren), Bitverschiebungsbefehle (rshift, lshift).  Lassen Sie uns den gleichen rpick machen (dies ist das gleiche wie pick, es funktioniert nur mit dem R√ºckgabestapel, nicht mit dem Datenstapel). <br><br><div class="spoiler">  <b class="spoiler_title">Diese Befehle sind sehr einfach, hier ist ihr Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  M√ºssen noch das Wort Wort machen.  Dies ist dasselbe wie blword, jedoch wird auf dem Stapel ein bestimmtes Trennzeichen angegeben.  Ich gebe den Code nicht an, er befindet sich in der Quelle.  Ich habe die W√∂rter blworld kopiert / eingef√ºgt und die Vergleichsbefehle ersetzt. <br><br>  Abschlie√üend machen wir das Wort syscall.  Damit ist es m√∂glich, die fehlenden Systemoperationen durchzuf√ºhren, beispielsweise mit Dateien zu arbeiten.  Eine solche L√∂sung funktioniert nicht, wenn Plattformunabh√§ngigkeit erforderlich ist.  Aber dieses System wird jetzt f√ºr Tests verwendet, also lass es vorerst so sein.  Bei Bedarf k√∂nnen alle Operationen in Bytebefehle konvertiert werden, es ist √ºberhaupt nicht schwierig.  Der Befehl syscall akzeptiert 6 Parameter f√ºr den Systemaufruf und die Rufnummer vom Stapel.  Es wird ein Parameter zur√ºckgegeben.  Die Parameterzuweisungen und der R√ºckgabewert werden durch die Systemrufnummer bestimmt. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  Und jetzt gehen wir direkt zum Compiler. <br><br><h4>  Compiler </h4><br>  Erstellen wir die Variable h, hier ist alles einfach. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Wir werden die Initialisierung in die Startzeile schreiben: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Lassen Sie uns hier das Wort machen: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Und auch W√∂rter zum Kompilieren der Werte: "allot" und "c", "w", "i", ",", "str"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Lassen Sie uns nun die Statusvariable und zwei W√∂rter erstellen, um ihren Wert zu steuern: "[" und "]".  Normalerweise werden diese W√∂rter verwendet, um zum Zeitpunkt der Kompilierung etwas auszuf√ºhren.  Daher deaktiviert das Wort "[" den Kompilierungsmodus und das Wort "]" ihn.  Nichts hindert sie jedoch daran, in anderen F√§llen verwendet zu werden, wenn der Kompilierungsmodus ein- oder ausgeschaltet werden muss.  Das Wort "[" wird unser erstes Wort mit dem unmittelbaren Zeichen sein.  Andernfalls kann der Kompilierungsmodus nicht deaktiviert werden, da er kompiliert und nicht ausgef√ºhrt wird. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Die Wende kam f√ºr das Wort $ compile.  Es wird die Adresse des W√∂rterbucheintrags vom Stapel nehmen und das angegebene Wort kompilieren.  Um ein Wort in gew√∂hnlichen Fort-Implementierungen zu kompilieren, reicht es aus, das Wort "," auf die Ausf√ºhrungsadresse anzuwenden.  Hier ist alles viel komplizierter.  Erstens gibt es zwei Arten von W√∂rtern - Bytecode und Maschinencode.  Die ersteren werden nach Byte kompiliert, die letzteren nach dem Befehl call byte.  Und zweitens - wir haben bis zu vier Varianten des Aufrufbefehls: call8, call16, call32 und call64.  Vier?  Nein!  Als ich den Compiler schrieb, f√ºgte ich diesen vier 16 weitere hinzu!  :) :) <br><br>  Wie ist das passiert?  Wir m√ºssen einen kleinen Exkurs machen. <br><br><h4>  Anrufbefehl verbessern </h4><br>  Als der Compiler anfing zu arbeiten, stellte ich fest, dass in vielen F√§llen (aber nicht in allen F√§llen) der Befehl call8 ausreicht.  Dies ist der Fall, wenn das aufgerufene Wort innerhalb von 128 Bytes liegt.  Ich dachte - und wie kann ich sicherstellen, dass dies in fast allen F√§llen passiert?  Wie f√ºge ich mehr als 256 Werte in ein Byte ein? <br>  Der erste Punkt, den ich bemerkte, war, dass in der Festung der Anruf immer in Richtung niedrigerer Adressen geht.  Dies bedeutet, dass Sie den Aufrufbefehl so wiederholen k√∂nnen, dass nur niedrigere Adressen aufgerufen werden k√∂nnen, jedoch f√ºr 256 Byte, nicht f√ºr 128. Es ist besser. <br><br>  Aber wenn Sie irgendwo ein paar Kleinigkeiten platzieren ... Es stellt sich heraus, dass dort wo ist!  Wir haben zwei Bytes: Ein Byte ist der Befehl, das zweite ist der Offset.  Nichts hindert die unteren Bits des Befehls daran, die oberen Bits des Parameters (Offset) zu platzieren.  Bei einer Byte-Maschine sieht es so aus, als g√§be es anstelle eines Aufrufbefehls mehrere.  Ja, auf diese Weise belegen wir mehrere Zellen der Byte-Befehlscodetabelle mit einem Befehl, aber manchmal lohnt es sich, dies zu tun.  Der Aufrufbefehl ist einer der am h√§ufigsten verwendeten Befehle, daher habe ich beschlossen, 4 Versatzbits in den Befehl einzuf√ºgen.  So k√∂nnen Sie in einer Entfernung von bis zu 4095 Bytes telefonieren!  Dies bedeutet, dass ein solcher Kurzaufrufbefehl fast immer verwendet wird.  Ich habe diese Befehle mit dem Code 0xA0 platziert und die folgenden Zeilen wurden in der Befehlstabelle angezeigt: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  Der erste dieser Bytebefehle ruft einfach in Richtung niedrigerer Adressen mit dem im Parameter angegebenen Versatz (bis zu 255) auf.  Der Rest f√ºgt dem Parameter den entsprechenden Offset hinzu.  bcmd_call8b1 f√ºgt 256 hinzu, bcmd_call8b2 f√ºgt 512 hinzu und so weiter.  Ich habe den ersten Aufrufbefehl separat ausgef√ºhrt, der Rest mit einem Makro. <br><br>  Erster Befehl: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Makro und Erstellen der restlichen Aufrufbefehle: <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Nun, ich habe den alten Befehl call8 √ºberarbeitet, um weiterzuleiten, da wir bereits 16 Teams haben, die einen R√ºckruf t√§tigen.  Was auch immer die Verwirrung war, ich habe es in b_call8f umbenannt: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  √úbrigens habe ich der Einfachheit halber ein Makro erstellt, das in Assembler den entsprechenden R√ºckruf innerhalb von 4095 automatisch kompiliert. Und dann musste ich nie :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  Und jetzt‚Ä¶ <br><br><h4>  Teamzusammenstellung </h4><br>  Wir erhalten also einen ziemlich komplizierten Befehlskompilierungsalgorithmus.  Wenn dies ein Bytebefehl ist, kompilieren Sie nur ein Byte (Bytebefehlscode).  Und wenn dieses Wort bereits in Bytecode geschrieben ist, m√ºssen Sie seinen Aufruf mit dem Befehl call kompilieren und einen von zwanzig ausw√§hlen.  Genauer gesagt 19, wir haben also keine Anrufweiterleitung und call8f wird nicht f√ºr das Fort verwendet. <br><br>  Die Wahl ist also diese.  Wenn der Versatz innerhalb von 0 ...- 4095 liegt, w√§hlen Sie den Befehl bcmd_call8b mit dem Code 0xA0 aus und platzieren Sie die vier h√∂chstwertigen Versatzbits in den niedrigstwertigen Bits des Befehls.  Gleichzeitig lautet der Code f√ºr einen der Befehle bcmd_call8b0 f√ºr die Byte-Maschine bcmd_call8b15. <br><br>  Wenn der R√ºckw√§rtsversatz gr√∂√üer oder gleich 4095 ist, bestimmen wir, in welcher Dimension der Versatz platziert wird, und verwenden den entsprechenden Befehl von call16 / 32/64.  Es ist zu beachten, dass der Offset f√ºr diese Teams unterschrieben ist.  Sie k√∂nnen sowohl vorw√§rts als auch r√ºckw√§rts verursachen.  Beispielsweise kann call16 eine Entfernung von 32767 in beide Richtungen anrufen. <br><br>  Hier ist die Implementierung als Ergebnis: <br><br>  <b>$ kompilieren</b> <br><br>  Kompiliert ein Wort.  Nimmt als Parameter die Adresse des W√∂rterbucheintrags des kompilierten Wortes.  Tats√§chlich √ºberpr√ºft es das Flag f_code, berechnet die Code-Adresse (cfa) und ruft compile_b oder compile_c auf (wenn das Flag gesetzt ist). <br><br>  <b>compile_c</b> <br><br>  Kompiliert einen Bytebefehl.  Das einfachste Wort hier wird auf der Festung folgenderma√üen beschrieben: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br>  Es nimmt eine Bytecode-Adresse auf dem Stapel und kompiliert seinen Aufruf. <br><br>  <b>test_bv</b> <br><br>  Es nimmt einen Offset vom Stapel (mit einem Vorzeichen) und bestimmt, welche Bittiefe verwendet werden soll (1, 2, 4 oder 8 Bytes).  Gibt den Wert 0, 1, 2 oder 3 zur√ºck. Mit diesem Wort k√∂nnen Sie anhand der Befehle call16 / 32/64 bestimmen, welches verwendet werden soll.  Dieses Wort ist n√ºtzlich beim Zusammenstellen von Zahlen (eine Auswahl aus lit8 / 16/32/64). <br><br>  √úbrigens k√∂nnen Sie das System starten und in der Fort-Konsole mit einem dieser W√∂rter ‚Äûherumspielen‚Äú.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Es nimmt einen Offset (mit einem Vorzeichen) vom Stapel und bestimmt, welcher Aufrufbefehl verwendet werden soll.  Tats√§chlich pr√ºft es, ob der Offset im Bereich von 0 ... -4095 liegt, und gibt 0 zur√ºck. In diesem Fall ruft es test_bv auf, wenn in diesem Intervall kein Treffer erfolgt. <br><br><div class="spoiler">  <b class="spoiler_title">Das ist alles, was Sie zum Kompilieren des Befehls ben√∂tigen.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Jetzt m√ºssen wir die Nummer zusammenstellen. <br><br><h4>  Zusammenstellung einer Zahl (Literal) </h4><br>  Schrieb einen ganzen Untertitel, der darauf vorbereitet war, die Zusammenstellung des Literal spezifisch zu beschreiben, aber es stellt sich heraus, dass es nichts Besonderes zu beschreiben gibt :) <br><br>  Wir haben bereits die H√§lfte der Arbeit im Wort test_bv erledigt.  Es bleibt nur noch test_bv aufzurufen und je nach Ergebnis lit8 / 16/32/64 und dann den entsprechenden Wert von 1, 2, 4 oder 8 Bytes zu kompilieren. <br><br><div class="spoiler">  <b class="spoiler_title">Dazu definieren wir das Wort compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  √Ñndern Sie den Interpreter </h4><br>  Alles ist bereit, den Befehl und die Literale zu kompilieren.  Jetzt muss es in den Interpreter eingebaut werden.  Diese √Ñnderung ist einfach.  F√ºgen Sie an der Stelle, an der der Befehl ausgef√ºhrt wurde, die Statuspr√ºfung hinzu.  Wenn state nicht null ist und das Wort nicht das unmittelbare Flag enth√§lt, m√ºssen Sie anstelle der Ausf√ºhrung $ compile aufrufen.  Und ungef√§hr das Gleiche, wenn die Nummer aus dem Eingabestream abgerufen wird.  Wenn state null ist, lassen Sie einfach die Nummer auf dem Stapel und rufen Sie compile_n auf, wenn nicht. <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist der Dolmetscher</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Jetzt sind wir einen Schritt vom Compiler entfernt ... <br><br><h4>  Definition neuer W√∂rter (Wort ":") </h4><br>  Wenn wir nun die Statusvariable auf einen Wert ungleich Null setzen, beginnt der Kompilierungsprozess.  Aber das Ergebnis wird nutzlos sein, wir k√∂nnen es weder erf√ºllen noch im Ged√§chtnis finden.  Um dies alles zu erm√∂glichen, muss das Kompilierungsergebnis in Form eines W√∂rterbuchartikels formatiert werden.  Dazu m√ºssen Sie vor dem Aktivieren des Kompilierungsmodus einen Titel f√ºr das Wort erstellen. <br><br>  Der Header sollte Flags, ein Kommunikationsfeld und einen Namen enthalten.  Hier haben wir eine vertraute Geschichte - das Kommunikationsfeld kann 1, 2, 4 oder 8 Bytes sein.  Machen wir das Wort compile_1248, das uns hilft, ein solches Kommunikationsfeld zu bilden.  Der Stapel ben√∂tigt zwei Zahlen - den Offset und den vom Befehl test_bv generierten Wert. <br><br><div class="spoiler">  <b class="spoiler_title">compile_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Machen Sie jetzt das Wort $ create.  Es wird uns mehr als einmal n√ºtzlich sein.  Sie k√∂nnen es verwenden, wenn Sie einen Titel f√ºr einen W√∂rterbucheintrag erstellen m√ºssen.  Es werden zwei Werte aus dem Stapel √ºbernommen - die Adresse des Namens des erstellten Wortes und seine L√§nge.  Nach dem Ausf√ºhren dieses Wortes wird die Adresse des erstellten W√∂rterbucheintrags auf dem Stapel angezeigt. <br><br><div class="spoiler">  <b class="spoiler_title">$ create</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  Das n√§chste Wort nimmt den Namen des neuen Wortes mit dem Wort blword aus dem Eingabestream auf und ruft $ create auf, wodurch ein neues Wort mit dem angegebenen Namen erstellt wird. <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  Und schlie√ülich machen Sie das Wort ":".  Mit create_in wird ein neues Wort erstellt und der Kompilierungsmodus festgelegt. Es wird nicht installiert.  Und wenn installiert, gibt es einen Fehler.  Das Wort ":" hat das unmittelbare Zeichen. <br><br><div class="spoiler">  <b class="spoiler_title">Wort :</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Wenn jemand in den Code schaute, dann sah er, dass dieses Wort etwas anderes tut :) <br><br>  Und hier ist 110 ??? <br><br>  Ja, dieses Wort dr√ºckt auch die Nummer 110 auf den Stapel, und deshalb.  Beim Kompilieren m√ºssen die verschiedenen Konstrukte ein einziges Ganzes sein.  Zum Beispiel nach wenn muss dann sein.  Und das mit ":" erstellte Wort sollte mit ";" enden.  Um diese Bedingungen zu √ºberpr√ºfen, legen spezielle W√∂rter des Compilers bestimmte Werte auf den Stapel und pr√ºfen, ob sie vorhanden sind.  Zum Beispiel setzt das Wort ":" den Wert 110 und das Wort ";"  pr√ºft, ob 110 oben auf dem Stapel liegt. Wenn dies nicht der Fall ist, ist dies ein Fehler.  Die Kontrollstrukturen wurden also nicht gepaart. <br><br>  Eine solche √úberpr√ºfung wird in allen solchen W√∂rtern des Compilers durchgef√ºhrt, daher werden wir ein spezielles Wort daf√ºr machen - "? Pairs".  Es werden zwei Werte vom Stapel genommen und ein Fehler ausgegeben, wenn sie nicht gleich sind. <br><br>  In solchen Worten m√ºssen Sie h√§ufig √ºberpr√ºfen, ob der Kompilierungsmodus eingestellt ist.  Lassen Sie uns das Wort "? State" daf√ºr machen. <br><br><div class="spoiler">  <b class="spoiler_title">"Paare" Zustand</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  Das ist alles!  Wir werden nichts anderes in Assembler manuell kompilieren :) <br><br>  Aber bis zum Ende ist der Compiler noch nicht geschrieben worden, so dass Sie am Anfang einige ungew√∂hnliche Methoden anwenden m√ºssen ... <br><br><h4>  Machen wir uns bereit, den erstellten Compiler mit dem erstellten Compiler zu kompilieren </h4><br>  Zu Beginn k√∂nnen Sie √ºberpr√ºfen, wie das Wort ":" funktioniert, indem Sie etwas Einfaches kompilieren.  Lassen Sie uns zum Beispiel das Wort machen: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Dieses Wort ist quadratisch.  Aber wir haben nicht das Wort ";" was zu tun?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben stattdessen das Wort exit und es wird kompiliert. </font><font style="vertical-align: inherit;">Schalten Sie dann den Kompilierungsmodus mit dem Wort "[" aus und lassen Sie den Wert 110 fallen:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es funktioniert! </font><font style="vertical-align: inherit;">Fahren wir </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fort ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir das Fort weiterhin auf dem Fort schreiben werden, m√ºssen wir uns √ºberlegen, wo sich der Quellcode des Forts befindet und wann kompiliert werden soll. </font><font style="vertical-align: inherit;">Lassen Sie uns die einfachste Option machen. </font><font style="vertical-align: inherit;">Der Quellcode der Festung wird im Assembler als Textzeichenfolge in den Quellcode des Assemblers eingef√ºgt. </font><font style="vertical-align: inherit;">Und damit er nicht zu viel Platz einnimmt, platzieren wir ihn unmittelbar nach der Adresse hier im freien Speicherbereich. </font><font style="vertical-align: inherit;">Nat√ºrlich ben√∂tigen wir diesen Bereich f√ºr die Kompilierung, aber die Geschwindigkeit des "Durchgehens" der Interpretation ist gr√∂√üer als der Bedarf an neuem Speicher. </font><font style="vertical-align: inherit;">Daher beginnt der kompilierte Code von Anfang an, die Quelle auf dem Fort zu √ºberschreiben, aber wir werden ihn nicht mehr ben√∂tigen, da wir diesen Abschnitt bereits gelesen und verwendet haben.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Anfang der Zeile lohnt es sich jedoch, ein Dutzend Leerzeichen zu platzieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies funktioniert, √§ndern wir den Startbytecode so, dass tib, #tib auf diese Zeile zeigen. </font><font style="vertical-align: inherit;">Am Ende wird beendet, um die normale Befehlszeile des Systems aufzurufen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Starten von Bytecode ist so geworden</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  Gro√üartig! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt‚Ä¶ </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompilieren Sie den Compiler mit dem Compiler </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes schreiben wir den Code in die fcode-Zeile. </font><font style="vertical-align: inherit;">Das erste, was zu tun ist, ist nat√ºrlich das Wort ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich werde einige Erkl√§rungen abgeben. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier √ºberpr√ºfen wir, ob der Kompilierungsstatus wirklich festgelegt ist und 110 auf dem Stapel liegt. Andernfalls tritt versehentlich ein Interrupt auf. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu kompilieren wir den lit-Befehl mit dem Bytecode des exit-Befehls. </font><font style="vertical-align: inherit;">Ich musste in den Ausf√ºhrungsmodus wechseln, das Wort exit finden, die Ausf√ºhrungsadresse abrufen und den Befehlscode von dort abrufen. </font><font style="vertical-align: inherit;">All dies war erforderlich, da wir das Wort noch nicht kompiliert haben. </font><font style="vertical-align: inherit;">Wenn es so w√§re, w√ºrde es ausreichen, einfach "compile exit" zu schreiben :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch wird der Befehl exit kompiliert, wenn das Wort ";" ausgef√ºhrt wird, und anschlie√üend wird der Interpretationsmodus festgelegt. </font><font style="vertical-align: inherit;">Das Wort "[" kann hier nicht verwendet werden, da es das unmittelbare Vorzeichen hat und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgef√ºhrt wird </font><font style="vertical-align: inherit;">, aber wir m√ºssen </font><font style="vertical-align: inherit;">solche Befehle in das Wort ";" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompilieren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , damit sie den Kompilierungsmodus deaktivieren.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das haben wir schon erlebt. </font><font style="vertical-align: inherit;">Das Wort exit wird kompiliert und der Kompilierungsmodus ist deaktiviert. </font><font style="vertical-align: inherit;">Alles, das Wort ";" </font><font style="vertical-align: inherit;">zusammengestellt. </font><font style="vertical-align: inherit;">Und was steht dort noch weiter geschrieben?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen das unmittelbare Flag f√ºr das neue Wort setzen. </font><font style="vertical-align: inherit;">Dies ist genau das, was die angegebene Sequenz tut, mit Ausnahme des Wortabfalls. </font><font style="vertical-align: inherit;">Das Wort drop entfernt das vergessene 110, das das Wort ":" am Anfang der Sch√∂pfung platziert hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten und versuchen es.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ist! </font><font style="vertical-align: inherit;">Dies ist das erste Wort, das unser Compiler "for real" kompiliert hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber wir haben immer noch keine Bedingungen, keine Schleifen und vieles mehr ... Beginnen wir mit einem kleinen, aber sehr notwendigen Wort, um einen Compiler zu erstellen: sofort. </font><font style="vertical-align: inherit;">Es legt das unmittelbare Attribut f√ºr das zuletzt erstellte Wort fest:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vertraute Sequenz :) Vor kurzem wurde es manuell geschrieben, dies wird nicht mehr ben√∂tigt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns nun einige kleine, aber n√ºtzliche W√∂rter machen:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex und Dezimal setzen das entsprechende Zahlensystem. </font><font style="vertical-align: inherit;">Der Rest sind Konstanten zum Erhalten der entsprechenden Zeichencodes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen auch ein Wort f√ºr das Kopieren einer Zeile mit einem Z√§hler </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: cmove over c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt werden wir uns mit Bedingungen besch√§ftigen. </font><font style="vertical-align: inherit;">Wenn ein Wort kompiliert w√ºrde, w√ºrde es im Allgemeinen so aussehen:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle diese W√∂rter am Anfang verifizieren, dass der Kompilierungsmodus eingestellt ist, und erzeugen einen Fehler, wenn dies nicht der Fall ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das if-Wort kompiliert eine bedingte Verzweigung, reserviert ein Byte f√ºr den Befehlsparameter der bedingten Verzweigung und schiebt die Adresse dieses Bytes auf den Stapel. Dann schiebt es den Steuerwert 111 auf den Stapel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wort pr√ºft dann, ob der Steuerwert 111 vorhanden ist, und schreibt dann den Versatz in die Adresse auf dem Stapel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und sofort das Wort anders machen. </font><font style="vertical-align: inherit;">Zu Beginn wird der bedingungslose Sprungbefehl kompiliert, um den else-Zweig zu umgehen. </font><font style="vertical-align: inherit;">Auf die gleiche Weise, als ob der √úbergangsversatz noch nicht bekannt w√§re, wird er einfach reserviert und seine Adresse auf den Stapel geschoben. </font><font style="vertical-align: inherit;">Nun, danach wird genau das Gleiche gemacht wie damals: Die Adresse des Catch-√úbergangs wird auf den else-Zweig gesetzt. </font><font style="vertical-align: inherit;">Etwas ist schwieriger zu beschreiben als der Code selbst :) Wenn jemand es gr√ºndlich herausfinden m√∂chte, ist es besser, die Arbeit eines solchen maximal vereinfachten Codes zu analysieren:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun programmieren wir den echten Code. </font><font style="vertical-align: inherit;">Da wir das Wort kompilieren nicht haben, wenden wir den gleichen Trick an wie beim Erstellen des Wortes ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen Sie versuchen, die Bedingung zu kompilieren. </font><font style="vertical-align: inherit;">Lassen Sie uns zum Beispiel ein Wort machen, das 1000 druckt, wenn sich 5 auf dem Stapel befinden, und 0 in anderen F√§llen:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist klar, dass ein solches Ergebnis nicht sofort funktioniert hat, es gab Fehler, es gab Debugging. </font><font style="vertical-align: inherit;">Aber am Ende haben die Bedingungen funktioniert!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein kleiner Exkurs √ºber die L√§nge der √úbergangsbefehle</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   ‚Äî    16 . <br><br>      . 16        ‚Äî    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  ‚Äî 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Bedingungen, das Leben wird einfacher :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns ein Wort sagen. "(Punkt-Zitat). Es zeigt den angegebenen Text an, wenn er ausgef√ºhrt wird. Es wird folgenderma√üen verwendet:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen dieses Wort nur im Kompilierungsmodus verwenden. </font><font style="vertical-align: inherit;">Dies wird deutlich, nachdem wir das Ger√§t dieses Wortes analysiert haben:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Wort wird im Kompilierungsmodus ausgef√ºhrt. Es dauert eine Zeichenfolge vom Eingabestream bis zu Anf√ºhrungszeichen (34 W√∂rter). Wenn die Zeile nicht abgerufen werden konnte, wird nichts ausgef√ºhrt. Hier w√§re es jedoch besser, eine Diagnose abzuleiten. Aber f√ºr die Ausgabe der Zeile ist dieses Wort genau das, was wir tun :) Wenn n√∂tig, k√∂nnen Sie dieses Wort bereits mit Diagnose neu definieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es m√∂glich war, die Zeichenfolge abzurufen, wird der Byte-Befehl (. ") Kompiliert und dann die Zeichenfolge empfangen. Dieser Byte-Befehl (gepunktetes Anf√ºhrungszeichen in Klammern) zeigt bei Ausf√ºhrung die Zeichenfolge an, die hinter dem Befehlsbyte kompiliert wurde.</font></font><br><br>  Schau es dir an. <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und zum Schluss lassen wir das Wort kompilieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist klar, dass dieses Wort im Kompilierungsmodus den Namen des n√§chsten Wortes aus dem Stream √ºbernehmen sollte. Finden Sie ihn im W√∂rterbuch. Und dann gibt es Optionen: Es kann ein Byte-Befehl oder ein in Byte-Code geschriebenes Wort sein. Diese W√∂rter m√ºssen auf unterschiedliche Weise zusammengestellt werden. Daher werden wir zwei Hilfsw√∂rter erstellen: "(compile_b)" und "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) kompiliert den Aufrufbefehl, um den Bytecode aufzurufen. Der Parameter ist ein 64-Bit-Wort - die Adresse des aufgerufenen Bytecodes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) kompiliert den Byte-Befehl. Dementsprechend ist der Parameter dieses Befehls ein Byte - der Befehlscode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, das Wort compile selbst kompiliert entweder (compile_b) oder (compile_c) mit den entsprechenden Parametern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit (compile_c),wie beim einfachsten:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz seiner Einfachheit schreiben wir zuerst ein Wort in Bytecode, der an sich Parameter hat. Deshalb werde ich kommentieren. Nach der Eingabe von (compile_c) befindet sich die R√ºcksprungadresse auf dem R√ºckgabestapel, da sie nicht banal ist. Dies ist die Adresse des n√§chsten Bytes nach dem Aufrufbefehl. Die Situation zum Zeitpunkt des Anrufs ist unten dargestellt. A0 - Aufrufbefehlscode, XX - Aufrufbefehlsparameter - Aufrufadresse (Offset) des Bytecodes des Wortes (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die R√ºcksprungadresse gibt das Byte NN an. Normalerweise gibt es den Code f√ºr das n√§chste Byte des Befehls. Aber unser Wort hat Parameter, also ist NN nur die Parameter des Wortes "(compile_c)", n√§mlich der Bytecode des kompilierten Befehls. Sie m√ºssen dieses Byte lesen und die R√ºcksprungadresse √§ndern, indem Sie sie zum n√§chsten Bytebefehl weiterleiten. Dies geschieht durch die Sequenz ‚Äûr&gt; dup c @ swap 1+&gt; r‚Äú. Diese Sequenz zieht die R√ºcksprungadresse vom R√ºckgabestapel zum regul√§ren Stapel, ruft ein Byte daraus ab, f√ºgt eins hinzu (R√ºcksprungadresse) und gibt es zur√ºck zum R√ºckgabestapel zur√ºck. Der verbleibende Befehl "c" kompiliert den aus den Parametern erhaltenen Bytebefehlscode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) ist nicht viel komplizierter:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist alles gleich, nur der 64-Bit-Parameter wird gelesen und das Wort compile_b wird verwendet, um das Wort zu kompilieren, das wir bereits f√ºr den Compiler erstellt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt kompilieren Sie das Wort. </font><font style="vertical-align: inherit;">Wie bereits erw√§hnt, liest es den Namen des Wortes, findet es und kompiliert einen der beiden vorherigen Befehle. </font><font style="vertical-align: inherit;">Ich werde es nicht kommentieren, wir haben bereits alle verwendeten Konstruktionen angewendet und zerlegt.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Word kompilieren</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um das erstellte Wort zu √ºberpr√ºfen, machen wir mit seiner Hilfe das Wort ifnot. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br>  Probieren Sie es aus! <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist in Ordnung! Und es ist Zeit, Zyklen zu machen ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel werden wir Zyklen mit einer Bedingung machen. Das Fort hat zwei M√∂glichkeiten f√ºr einen Zyklus mit einer Bedingung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Option ist beginnen ... bis. Das Wort bis entfernt den Wert vom Stapel, und wenn er nicht gleich Null ist, endet der Zyklus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Option ist beginnen ... w√§hrend ... wiederholen. In diesem Fall erfolgt die Pr√ºfung, wenn das Wort while ausgef√ºhrt wird. Die Schleife wird beendet, wenn der Wert auf dem Stapel Null ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zyklen auf der Festung werden auf die gleiche Weise wie die Bedingungen durchgef√ºhrt - unter bedingten und bedingungslosen √úberg√§ngen. Ich bringe den Code mit, Kommentare, denke ich, werden nicht ben√∂tigt.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heute sind wir mit dem Compiler fertig. </font><font style="vertical-align: inherit;">Es ist sehr wenig √ºbrig. </font><font style="vertical-align: inherit;">Von den Schl√ºsselfunktionen, die noch nicht implementiert wurden, sind nur Zyklen mit einem Z√§hler. </font><font style="vertical-align: inherit;">Es lohnt sich auch, den Befehl exit loop zu verlassen. </font><font style="vertical-align: inherit;">Wir werden es n√§chstes Mal tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Den Zyklusbefehl haben wir aber nicht erlebt! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir tun dies, indem wir die Standardwortw√∂rter schreiben. </font><font style="vertical-align: inherit;">Wir m√ºssen endlich unser W√∂rterbuch sehen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu machen wir zu Beginn das Wort link @. </font><font style="vertical-align: inherit;">Das Kommunikationsfeld wird aus dem W√∂rterbucheintrag extrahiert (Versatz zum vorherigen Eintrag). </font><font style="vertical-align: inherit;">Wie wir uns erinnern, kann das Kommunikationsfeld eine andere Gr√∂√üe haben: 1, 2, 4 oder 8 Bytes. </font><font style="vertical-align: inherit;">Dieses Wort nimmt die Adresse des W√∂rterbucheintrags auf den Stapel und gibt zwei Werte zur√ºck: die Adresse des Namensfelds und den Wert des Kommunikationsfelds.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt k√∂nnen Sie das Wort W√∂rter machen: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist es, unser Reichtum :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte alles sagen ... nein, machen wir es trotzdem m√∂glich, eine Datei mit einem Fort-Programm zum Kompilieren und Ausf√ºhren als Parameter anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen Syscall-Befehle, um die Datei zu √∂ffnen, zu schlie√üen und zu lesen. </font><font style="vertical-align: inherit;">Wir definieren die daf√ºr notwendigen Konstanten.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen Sie das Startwort _start setzen: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Wort wird aus der Datei geladen und f√ºhrt ein beliebiges Fort-Programm aus. </font><font style="vertical-align: inherit;">Genauer gesagt f√ºhrt der Interpreter alles aus, was in dieser Datei enthalten sein wird. </font><font style="vertical-align: inherit;">Und es kann zum Beispiel eine Zusammenstellung neuer W√∂rter und deren Ausf√ºhrung geben. </font><font style="vertical-align: inherit;">Der Dateiname wird beim Start durch den ersten Parameter angezeigt. </font><font style="vertical-align: inherit;">Ich werde nicht auf Details eingehen, aber die Startparameter unter Linux werden durch den Stapel geleitet. </font><font style="vertical-align: inherit;">Das Wort _start erreicht sie mit den Befehlen 0 pick (Anzahl der Parameter) und 2 pick (Zeiger auf den ersten Parameter). </font><font style="vertical-align: inherit;">Bei einem Fort-System liegen diese Werte au√üerhalb des Stapels, aber Sie k√∂nnen sie mit dem Befehl pick abrufen. </font><font style="vertical-align: inherit;">Die Dateigr√∂√üe ist auf 32 KB begrenzt, w√§hrend keine Speicherverwaltung erfolgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss am Ende noch in die fcode-Zeile geschrieben werden:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Datei test.f und schreiben Sie dort etwas auf die Festung. </font><font style="vertical-align: inherit;">Zum Beispiel der euklidische Algorithmus zum Finden des gr√∂√üten gemeinsamen Faktors:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Wir fangen an. <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Antwort ist richtig. </font><font style="vertical-align: inherit;">Das Wort wurde zusammengestellt und dann erf√ºllt. </font><font style="vertical-align: inherit;">Das Ergebnis wird angezeigt, dann wurde der Befehl bye ausgef√ºhrt. </font><font style="vertical-align: inherit;">Wenn Sie die letzten beiden Zeilen entfernen, wird das Wort NOD zum W√∂rterbuch hinzugef√ºgt und das System wechselt zur Befehlszeile. </font><font style="vertical-align: inherit;">Sie k√∂nnen bereits Programme schreiben :-)</font></font><br><br>  Das ist alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wen k√ºmmert es, Sie k√∂nnen die Quelle oder die vorgefertigte Bin√§rdatei f√ºr Linux auf x86-64 von Github herunterladen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellen werden mit einer Lizenz </font><font style="vertical-align: inherit;">geliefert. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Mach was du willst :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437466/">https://habr.com/ru/post/de437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437454/index.html">Arithmometer Felix M Bewertung</a></li>
<li><a href="../de437456/index.html">J√ºnger: √úberpr√ºfung der Snom D315- und D305-IP-Telefone</a></li>
<li><a href="../de437458/index.html">Obligatorische Registrierung durch IMEI bieten an, bezahlt zu machen</a></li>
<li><a href="../de437460/index.html">Beispiel f√ºr ein gef√§lschtes 32-GB-Flash-Laufwerk</a></li>
<li><a href="../de437464/index.html">TypeScript Preis</a></li>
<li><a href="../de437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../de437470/index.html">Ein paar einfache Worte zur Raketenabwehr</a></li>
<li><a href="../de437472/index.html">√úbergang vom B√ºro zu Udalenka: Erfahrungsaustausch und Life Hacks</a></li>
<li><a href="../de437474/index.html">Optimieren Sie die Spieleleistung mit Unity-Soundimportoptionen</a></li>
<li><a href="../de437476/index.html">Ok Yandex! Wo sind unsere Ziele?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>