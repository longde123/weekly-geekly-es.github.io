<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游붍 游뱛游낕 游 Estad칤sticas de comentarios en l칤nea de confluencia 游똁游낗 游녞游낕 游닏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="쮺칩mo recopilar estad칤sticas de comentarios de p치gina en Confluence? 

 S칤, y 쯣or qu칠 podr칤a ser necesario? 



 Porque y porque 
 En el proyecto en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estad칤sticas de comentarios en l칤nea de confluencia</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485652/">  쮺칩mo recopilar estad칤sticas de comentarios de p치gina en Confluence? <br><br>  S칤, y 쯣or qu칠 podr칤a ser necesario? <br><br><img src="https://habrastorage.org/webt/c6/7x/uo/c67xuo6sop9dd7mpzxty_i7wj7s.png"><br><a name="habracut"></a><br><h2>  Porque y porque </h2><br>  En el proyecto en el que trabaj칠, naci칩 el siguiente proceso de preparaci칩n y aprobaci칩n de requisitos: <br><br><ul><li>  La confluencia se utiliz칩 para la documentaci칩n. </li><li>  El equipo del proveedor prepar칩 descripciones de los procesos comerciales y sus pasos en forma de p치ginas separadas de acuerdo con la plantilla. </li><li>  Una vez a la semana, se entreg칩 un lote de descripciones preparadas al cliente para su revisi칩n. </li><li>  El equipo del cliente dej칩 todas las preguntas y adiciones en la p치gina correspondiente en forma de comentarios integrados. </li><li>  Y el equipo del proveedor complement칩 el contenido, respondi칩 a los comentarios, resolvi칩 preguntas para un estudio adicional. </li><li>  Si se responde la pregunta y se actualiza el contenido o se corrige la tarea de estudio, el equipo del cliente debe cerrar el comentario. </li><li>  Las preguntas sobre un lote de documentos de la semana actual deben cerrarse para cuando se transfiera el siguiente lote la pr칩xima semana. </li></ul><br>  Cada semana, los gerentes de proyecto tienen la tarea de comprender cu치nto ha funcionado el lote de documentos entregados y qu칠 se puede considerar condicionalmente listo a partir de 칠l.  Y los participantes del equipo de proveedores deben verificar peri칩dicamente el estado de los comentarios en sus documentos y trabajar a prop칩sito con el resto.  쯇ero c칩mo encontrarlos?  Puede abrir cada p치gina, busque el primer comentario con sus ojos (o con la ayuda de un <a href="https://community.atlassian.com/t5/Confluence-questions/Search-for-unresolved-inline-comments/qaq-p/971424">peque침o truco</a> ), luego haga clic en todos los comentarios, porque  el equipo del cliente no tiene prisa por cerrarlos, pensar en cada uno y buscar una respuesta. <br><br>  El lote semanal contiene 50-100 p치ginas separadas, y hacer esto con sus manos es una cantidad significativa de trabajo.  Y si a칰n intenta reunir argumentos para convencer al otro lado, se vuelve muy triste.  Y tambi칠n hay comentarios colgantes que resultan de la edici칩n inexacta de la p치gina cuando el texto fuente se elimina accidentalmente.  Tal comentario es visible en los resueltos, pero no se puede volver a abrir (puede hacerlo, si recrea un marcador invisible en el texto de la p치gina). <br><br>  La b칰squeda de herramientas no tuvo 칠xito.  Adem치s, Confluence se implementa en el lado del cliente, no puede instalar complementos, sin mencionar la compra.  Sin experiencia en desarrollo macro. <br><br>  En alg칰n momento, record칠 la <a href="https://docs.atlassian.com/ConfluenceServer/rest/7.1.0/">API REST de</a> Confluence y la experiencia previa con el uso de la <a href="https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/">API Jira</a> similar.  La b칰squeda y los experimentos con funciones de llamada desde el navegador mostraron que puede acceder a los comentarios y sus propiedades.  Luego, ten칤a que elegir una herramienta para la automatizaci칩n, y puede comenzar a resolver.  Tengo cierta experiencia creando scripts en herramientas que tienen m치s probabilidades de estar m치s cerca de administradores como Bash, Perl, JScript.  No soy desarrollador, no ten칤a ninguna herramienta familiar o familiar.  Quer칤a probar algo m치s com칰n o adecuado.  Luego descubr칤 un <a href="https://atlassian-python-api.readthedocs.io/en/latest/">contenedor para la API de Python</a> y decid칤 probarlo. <br><br><h2>  Principio general </h2><br>  El problema se formul칩 de la siguiente manera.  Necesita encontrar todas las p치ginas relacionadas con una entrega semanal espec칤fica.  Recopile comentarios sobre ellos en una lista: p치gina, enlace al comentario, autor y fecha del comentario, texto fuente en la p치gina, comentario y respuestas, autor y fecha de la 칰ltima respuesta, estado del comentario.  Adem치s, recopile estad칤sticas para cada p치gina, cu치ntos comentarios en total, cu치ntos peligros, cu치ntos abiertos.  Gu치rdelo todo en una p치gina especial de estad칤sticas. <br><br>  Puse Python, revis칠 los conceptos b치sicos para trabajar con 칠l y vamos.  Primero, crea una conexi칩n: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> atlassian <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Confluence UserLogin = <span class="hljs-string"><span class="hljs-string">'xxxxxx'</span></span> <span class="hljs-comment"><span class="hljs-comment"># input("Login: ") UserPwd = 'xxxxxx' # input("Password: ") confluenceURL = 'http://wiki.xxxxxx' confluence = Confluence( url=confluenceURL, username=UserLogin, password=UserPwd)</span></span></code> </pre> <br>  Para buscar p치ginas de un lote semanal, decid칤 usar etiquetas.  C칩mo entregarlos en masa es una tarea separada. <br><br><pre> <code class="python hljs">page_label = <span class="hljs-string"><span class="hljs-string">'week123'</span></span> cql = <span class="hljs-string"><span class="hljs-string">'space.key={} and label = "{}" and type = page '</span></span> <span class="hljs-string"><span class="hljs-string">'ORDER BY title '</span></span>.format(<span class="hljs-string"><span class="hljs-string">'YYY'</span></span>, page_label) pages = confluence.cql(cql, expand=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, start=<span class="hljs-number"><span class="hljs-number">0</span></span>, limit=<span class="hljs-number"><span class="hljs-number">200</span></span>)</code> </pre><br>  As칤 que tenemos una lista de p치ginas para verificar.  A continuaci칩n, comenzamos a procesar cada p치gina individual.  Recopilamos de sus datos los comentarios con sus par치metros.  En base a estos datos, creamos estad칤sticas sobre cu치ntos comentarios hay en la p치gina y en qu칠 condiciones.  A continuaci칩n, eliminamos el resultado de todas las p치ginas y comenzamos a formatear el resultado.  Creamos el cuerpo de la p치gina con el resultado en forma de una tabla de estad칤sticas y una lista detallada de comentarios abiertos. <br><br><div class="spoiler">  <b class="spoiler_title">Procesamiento de lista de p치ginas</b> <div class="spoiler_text"><pre> <code class="python hljs">statistics = [] open_comments = [] <span class="hljs-comment"><span class="hljs-comment">#  - ? if pages is not None: #    ? if pages['size'] &gt; 0: for page in pages['results']: print(page['title']) #       , #  page_comments = page_comments_data(page['content']['id']) #     statistics.append(page_statistics(page_comments)) #        #    . for comment in page_comments: if comment['Result'] not in ['resolved', 'nocomment']: if not (comment['Result'] == 'dangling' and comment['Author'] in excludeNames): open_comments.append(comment) #       . statistics.append(total_statistics(statistics)) #     page_id = confluence.get_page_id(space='YYY', title=page_title) #     ,    . page_body = ('&lt;p&gt;&lt;ac:structured-macro ac:name="toc" ac:schema-version="1"' '/&gt;&lt;/p&gt;' '&lt;h1&gt;Comments Statistics&lt;/h1&gt;{}' '&lt;h1&gt;Open Comments List&lt;/h1&gt;{}' ).format(create_table(statistics), create_table(open_comments)) #  if page_id is not None: status = confluence.update_page( page_id=page_id, title=page_title, body=page_body, representation='storage' )</span></span></code> </pre></div></div><br><h2>  Caracter칤sticas API </h2><br>  Ahora veamos c칩mo procesar la p치gina.  De forma predeterminada, la API solo devuelve informaci칩n b치sica, como un identificador o nombre de p치gina.  Todas las propiedades adicionales deben especificarse expl칤citamente.  Se pueden ver analizando el resultado de la llamada.  Se pueden encontrar datos adicionales en secciones o subsecciones de _expandable.  Agregamos el elemento deseado para expandir y buscar m치s hasta encontrar los datos necesarios. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de problema</b> <div class="spoiler_text"><pre> <code class="json hljs">http://wiki.xxxxxx/rest/api/content/<span class="hljs-number"><span class="hljs-number">101743895</span></span>?expand=body,children.comment { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"97517865"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"current"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"w2019-47 comments status"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"children"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"results"</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"limit"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/page"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"styled_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"storage"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"anonymous_export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"extensions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operations"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"restrictions"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/restriction/byOperation"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"history"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/history"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ancestors"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"descendants"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/descendant"</span></span>, } }</code> </pre></div></div><br>  Y tambi칠n hay una restricci칩n en el n칰mero de resultados emitidos, paginaci칩n.  Est치 configurado en el lado del servidor (API?) Y en nuestro caso es 25. Para algunas solicitudes, se puede cambiar especificando expl칤citamente, pero solo funcionar치 para el nivel superior.  Y revelando comentarios a la p치gina, de todos modos recibimos solo 25, mientras que el tama침o tambi칠n es falso.  En el ejemplo hab칤a 29 en realidad.  Logramos evitar la paginaci칩n de comentarios usando una funci칩n separada en el m칩dulo Confluence: get_page_comments con la capacidad de especificar el tama침o de la p치gina. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    import re #      XML def replace_chars2(in_text): text = re.sub(r'&amp;', '&amp;', in_text) text = re.sub(r'\'', ''', text) text = re.sub(r'&lt;', '&lt;', text) text = re.sub(r'&gt;', '&gt;', text) text = re.sub(r'"', '"', text) return text</span></span></code> </pre><br>  El siguiente escollo fue esperar en las caracter칤sticas de la preservaci칩n y emisi칩n de caracteres especiales.  El cuerpo de una p치gina o comentario se puede obtener en varias vistas: XML interno - almacenamiento, HTML intermedio sin salida de macro - vista y HTML con salida de macro - export_view.  Pero el t칤tulo de la p치gina y el texto original comentado originalSelection siempre se emiti칩 en una forma adecuada para la lectura.  Porque  en el futuro, estos datos se incluir치n en el cuerpo de la p치gina con estad칤sticas, luego algunos caracteres provocaron errores de conversi칩n.  Tuve que escribir un procedimiento de reemplazo arriba. <br><br><h2>  Comentarios de la p치gina </h2><br>  Ahora para analizar la p치gina.  Este es un procedimiento que carga una p치gina, recopila sus datos, luego extrae una lista de comentarios con respuestas y los recopila en correspondencia.  El resultado es una lista de diccionarios, donde cada elemento de la lista corresponde a un comentario con respuestas.  Y todos los atributos de este comentario se encuentran en los campos correspondientes del diccionario. <br><br><div class="spoiler">  <b class="spoiler_title">Procesamiento de una p치gina</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_comments_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page_identifier)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#,      ,  , #   , #  ,    ,    #   (). expand_text = ('body.storage,extensions.inlineProperties' ',extensions.resolution,version,children.comment' ',children.comment.version,children.comment.body.storage' ) #    .     . conf_page = confluence.get_page_by_id(page_identifier, expand='body.storage') page_title = replace_chars2(conf_page['title']) #   . link_base = conf_page['_links']['base'] page_link = link_base + conf_page['_links']['webui'] page_code = '&lt;a href="{}"&gt;{}&lt;/a&gt;'.format(page_link, page_title) #   page_comments = confluence.get_page_comments(content_id=page_identifier, start=0, limit=1000, comments = [] #    for comment in page_comments['results']: #      - . if comment['extensions']['location'] == 'footer': continue #  comment_text = comment['body']['storage']['value'] comment_result = comment['extensions']['resolution']['status'] comment_link = '&lt;a href="{}"&gt;{}&lt;/a&gt;'\ .format(link_base + comment['_links']['webui'], 'link') #  comment_link = re.sub(r'&amp;focusedCommentId=', '&amp;focusedCommentId=', comment_link) #  created_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', comment['version']['when'])) created_by = comment['version']['by']['displayName'] orig_text = replace_chars2(comment['extensions'] ['inlineProperties']['originalSelection']) #    /. thread = '&lt;b&gt;To text: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(orig_text, created_when, created_by, comment_text) last_by = '' last_when = '' #  answers = comment['children']['comment']['size'] if answers &gt; 0: for message in comment['children']['comment']['results']: #  last_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', message['version']['when'])) last_by = message['version']['by']['displayName'] #  thread += ('&lt;br/&gt;===next===&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(last_when, last_by, message['body']['storage']['value']) ) #  . row_comm = {"Page": page_code, "Comment": comment_link, "Thread": thread, "Result": comment_result, "Answers count": answers, "Creation Date": created_when, "Author": created_by, "Last Date": last_when, "Last Author": last_by} comments.append(row_comm) #   ,   , #     . if len(comments) == 0: row_comm = {"Page": page_code, "Comment": 'nolink', "Thread": 'nocomment', "Result": 'nocomment', "Answers count": 0, "Creation Date": 'never', "Author": 'nobody', "Last Date": 'never', "Last Author": 'nobody'} comments.append(row_comm) return comments</span></span></code> </pre></div></div><br><h2>  Estad칤sticas y tablas </h2><br>  Para mayor claridad en la presentaci칩n de los datos, recopilamos estad칤sticas sobre ellos y los organizamos en forma de tablas. <br><br><div class="spoiler">  <b class="spoiler_title">Procesamos estad칤sticas</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_statistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comments_data)</span></span></span><span class="hljs-function">:</span></span> open_count = <span class="hljs-number"><span class="hljs-number">0</span></span> dang_count = <span class="hljs-number"><span class="hljs-number">0</span></span> comment_count = len(comments_data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> comment_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> comment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comments_data: <span class="hljs-comment"><span class="hljs-comment">#     if comment['Result'] not in ['resolved', 'nocomment']: if comment['Result'] in ['open', 'reopened']: open_count += 1 if comment['Result'] == 'dangling' and comment['Author'] not in excludeNames: dang_count += 1 res_dict = {'Page': comments_data[0]['Page'], 'Total': comment_count, 'Resolved': comment_count - open_count - dang_count, 'Dangling': dang_count, 'Open': open_count} return res_dict #   def total_statistics(stat_data): total_comment = 0 total_resolved = 0 total_open = 0 total_dangling = 0 for statRow in stat_data: total_comment += statRow['Total'] total_resolved += statRow['Resolved'] total_open += statRow['Open'] total_dangling += statRow['Dangling'] res_dict = {'Page': 'All Pages Total', 'Type': '', 'Jira': '', 'Status': '', 'Total': total_comment, 'Resolved': total_resolved, 'Dangling': total_dangling, 'Open': total_open} return res_dict</span></span></code> </pre></div></div><br>  Para hacer los datos en forma de tablas, haremos un procedimiento m치s.  Forma el c칩digo HTML de la tabla a partir de la lista de diccionarios, como encabezados agrega una l칤nea a partir de los nombres de las teclas del diccionario y agrega una columna con n칰meros de l칤nea. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tab_data)</span></span></span><span class="hljs-function">:</span></span> tab_start = <span class="hljs-string"><span class="hljs-string">'&lt;table style="width: 100.00%;"&gt;&lt;colgroup&gt;&lt;col /&gt;'</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;col /&gt;&lt;/colgroup&gt;&lt;tbody&gt;'</span></span> tab_end = <span class="hljs-string"><span class="hljs-string">'&lt;/tbody&gt;&lt;/table&gt;'</span></span> tab_code = tab_start + <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;'</span></span> row_num = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tab_data) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;Num&lt;/th&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data[<span class="hljs-number"><span class="hljs-number">0</span></span>].keys(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;{}&lt;/th&gt;'</span></span>.format(key) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(row_num) row_num += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row.values(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(field) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> tab_code += tab_end + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tab_code</code> </pre><br>  Ahora todo est치 listo.  Despu칠s de etiquetar y ejecutar el script, obtenemos una p치gina que se ve as칤: <br><br><img src="https://habrastorage.org/webt/-1/if/af/-1ifafmgt3mqvbayphkq7opy4mq.png"><br><br><h2>  PS </h2>  Por supuesto, esto no es todo lo que result칩 al final.  Hubo un an치lisis de p치ginas y una b칰squeda de una macro con el n칰mero de tarea en Jira.  Hubo un etiquetado autom치tico por n칰meros de tarea en Jira y enlaces desde ellos a Confluence.  Hubo una comparaci칩n y verificaci칩n de las listas de entregas semanales.  Se guardaron comentarios en Excel y se recopilaron datos comunes de varios archivos semanales de Excel.  Y recientemente se han agregado los comentarios de an치lisis de Word. </div></div><p>Source: <a href="https://habr.com/ru/post/485652/">https://habr.com/ru/post/485652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485636/index.html">Los virus resistentes a CRISPR construyen refugios para proteger los genomas de las enzimas que penetran el ADN</a></li>
<li><a href="../485640/index.html">M칠todos de ocultamiento de p치ginas web</a></li>
<li><a href="../485646/index.html">Consejos 칰tiles de Python que nunca has conocido antes. Parte 2</a></li>
<li><a href="../485648/index.html">El enfoque pit칩nico de los bucles for: range () y enumerate ()</a></li>
<li><a href="../485650/index.html">T칠cnicas de reducci칩n de imagen de Docker</a></li>
<li><a href="../485660/index.html">La propia compa침칤a de protecci칩n DDoS lanz칩 ataques DDoS, admiti칩 su fundador.</a></li>
<li><a href="../485664/index.html">Crear par치metros din치micos en un trabajo de Jenkins, o c칩mo hacer que su tarea sea f치cil de usar</a></li>
<li><a href="../485672/index.html">Mejores pr치cticas de Redis, parte 1</a></li>
<li><a href="../485688/index.html">Myapp extiende vacaciones</a></li>
<li><a href="../485692/index.html">Asesoramiento del especialista de TI al cliente, o c칩mo automatizar el desorden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>