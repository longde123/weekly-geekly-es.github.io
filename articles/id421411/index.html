<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 👩🏾‍🤝‍👩🏽 🕝 Pengantar Modul Go 🔲 🕸️ ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rilis mendatang dari versi 1.11 bahasa pemrograman Go akan membawa dukungan eksperimental untuk modul - sistem manajemen ketergantungan baru untuk Go....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Modul Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  Rilis mendatang dari versi 1.11 bahasa pemrograman Go akan membawa dukungan eksperimental untuk <em>modul</em> - sistem manajemen ketergantungan baru untuk Go.  (terjemahan catatan: <a href="">rilis berlangsung</a> ) </p><br><p>  Baru-baru ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya sudah menulis posting kecil tentang ini</a> .  Sejak itu, ada sesuatu yang sedikit berubah, dan kami menjadi lebih dekat dengan rilis, jadi bagi saya tampaknya sudah tiba saatnya untuk artikel baru - mari kita tambahkan lebih banyak latihan. </p><br><p>  Jadi, inilah yang akan kita lakukan: membuat paket baru dan kemudian membuat beberapa rilis untuk melihat cara kerjanya. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Pembuatan modul </h2><br><p> Pertama, buat paket kami.  Sebut saja testmod.  Detail penting: <strong>direktori paket harus ditempatkan di <em>luar</em> <code>$GOPATH</code> , karena, di dalamnya, dukungan modul dinonaktifkan secara default</strong> .  Modul Go adalah langkah pertama menuju pengabaian total <code>$GOPATH</code> di masa depan. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Paket kami cukup sederhana: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  Paket sudah siap, tetapi belum menjadi <em>modul</em> .  Mari kita perbaiki. </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Kami memiliki file baru bernama <code>go.mod</code> di direktori paket dengan konten berikut: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Sedikit, tapi itulah yang mengubah paket kami menjadi <em>modul</em> . </p><br><p>  Sekarang kita bisa memasukkan kode ini ke dalam repositori: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Sejauh ini, siapa pun yang ingin menggunakan paket kami akan mendaftar, <code>go get</code> : </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Dan perintah ini akan membawa kode terbaru dari cabang <code>master</code> .  Opsi ini masih berfungsi, tetapi akan lebih baik jika kita tidak melakukannya lagi, karena sekarang "ada cara yang lebih baik."  Mengambil kode langsung dari cabang <code>master</code> , sebenarnya, berbahaya, karena kita tidak pernah tahu pasti bahwa pembuat paket tidak membuat perubahan yang akan “merusak” kode kita.  Untuk mengatasi masalah ini, modul Go diciptakan. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Penyimpangan kecil tentang modul versi </h2><br><p>  Modul Go diversiasikan, ditambah ada beberapa kekhususan dari masing-masing versi.  Anda harus terbiasa dengan konsep yang mendasari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi semantik</a> . </p><br><p>  Selain itu, Go menggunakan tag repositori saat mencari versi, dan beberapa versi berbeda dari yang lain: misalnya, versi 2 dan lebih banyak harus memiliki jalur impor yang berbeda dari versi 0 dan 1 (kita akan membahas ini). </p><br><p>  Secara default, Go mengunduh <em>versi</em> terbaru <em>, yang memiliki tag yang</em> tersedia di repositori. <br>  Ini adalah fitur penting, karena dapat digunakan ketika bekerja dengan cabang <code>master</code> . </p><br><p>  Bagi kami sekarang, penting bahwa ketika membuat rilis paket kami, kami perlu memberi label dengan versi di repositori. </p><br><p>  Ayo lakukan. </p><br><h2 id="delaem-svoy-pervyy-reliz">  Membuat rilis pertama Anda </h2><br><p>  Paket kami siap dan kami dapat "meluncurkan" itu ke seluruh dunia.  Kami melakukan ini menggunakan label berversi.  Biarkan nomor versi menjadi 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Perintah-perintah ini membuat tag di repositori Github saya yang menandai komit saat ini sebagai rilis 1.0.0. </p><br><p>  Go tidak bersikeras tentang ini, tetapi merupakan ide bagus untuk membuat cabang baru tambahan ("v1") yang dapat kami kirim tambalan. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Sekarang kita dapat bekerja di cabang <code>master</code> tanpa khawatir bahwa kita dapat merusak rilis kita. </p><br><h2 id="ispolzovanie-nashego-modulya">  Menggunakan modul kami </h2><br><p>  Mari kita gunakan modul yang dibuat.  Kami akan menulis program sederhana yang mengimpor paket baru kami: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Sampai sekarang, Anda akan menjalankan <code>go get github.com/robteix/testmod</code> untuk mengunduh paket, tetapi dengan modul itu menjadi lebih menarik.  Pertama, kita perlu mengaktifkan dukungan modul di program baru kita. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Seperti yang mungkin Anda harapkan, berdasarkan apa yang Anda baca sebelumnya, file <code>go.mod</code> baru muncul di direktori dengan nama modul di dalamnya: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  Situasi menjadi lebih menarik ketika kami mencoba menyusun program kami: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, perintah <code>go</code> secara otomatis menemukan dan mengunduh paket yang diimpor oleh program kami. <br>  Jika kami memeriksa file <code>go.mod</code> kami, kami akan melihat bahwa ada sesuatu yang berubah: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Dan kami mendapat file baru bernama <code>go.sum</code> , yang berisi hash dari paket untuk memeriksa versi dan file yang benar. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Membuat rilis rilis perbaikan bug </h2><br><p>  Sekarang, katakanlah kami menemukan masalah dalam paket kami: tidak ada tanda baca dalam sambutannya! <br>  Sebagian orang akan geram, karena salam ramah kita sudah tidak ramah lagi. <br>  Mari perbaiki ini dan lepaskan versi baru: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Kami membuat perubahan ini tepat di cabang <code>v1</code> , karena tidak ada hubungannya dengan apa yang akan kami lakukan selanjutnya di cabang <code>v2</code> , tetapi dalam kehidupan nyata, mungkin Anda harus membuat perubahan ini di <code>master</code> dan kemudian mendukungnya ke <code>v1</code> .  Bagaimanapun, perbaikannya harus di cabang <code>v1</code> dan kita harus menandai ini sebagai rilis baru. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Pembaruan modul </h2><br><p>  Secara default, Go tidak memperbarui modul tanpa permintaan.  "Dan itu bagus," karena kita semua ingin prediktabilitas dalam bangunan kami.  Jika modul Go akan diperbarui secara otomatis setiap kali versi baru dirilis, kami akan kembali ke "zaman kegelapan sebelum-Go1.11".  Tapi tidak, kami harus <em>memberi tahu</em> Go untuk memperbarui modul untuk kami. </p><br><p>  Dan kami akan melakukannya dengan bantuan teman lama kami - <code>go get</code> : </p><br><ul><li><p>  jalankan <code>go get -u</code> untuk menggunakan rilis <em>minor atau patch</em> terakhir (mis. perintah akan memperbarui dari 1.0.0 ke, katakanlah, 1.0.1 atau 1.1.0, jika versi seperti itu tersedia) </p><br></li><li><p>  run <code>go get -u=patch</code> untuk menggunakan versi patch terbaru (mis. paket akan diperbarui ke 1.0.1, tetapi <em>tidak</em> ke 1.1.0) </p><br></li><li><p>  jalankan <code>go get package@version</code> untuk meningkatkan ke versi tertentu (misalnya, <code>github.com/robteix/testmod@v1.0.1</code> ) </p><br></li></ul><br><p>  Tidak ada cara dalam daftar ini untuk meningkatkan ke versi <em>utama</em> terbaru.  Ada alasan bagus untuk ini, karena kita akan segera melihat. </p><br><p>  Karena program kami menggunakan versi 1.0.0 dari paket kami dan kami baru saja membuat versi 1.0.1, <em>salah</em> satu dari perintah berikut akan memperbarui kami ke 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Setelah memulai (misalkan <code>go get -u</code> ), <code>go.mod</code> kami telah berubah: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Versi utama </h2><br><p>  Menurut spesifikasi versi semantik, versi utama <em>berbeda</em> dari versi minor.  Versi besar dapat merusak kompatibilitas.  Dari sudut pandang modul Go, versi utama adalah <em>paket yang sama</em> sekali <em>berbeda</em> . </p><br><p>  Mungkin terdengar liar pada awalnya, tetapi masuk akal: dua versi perpustakaan yang tidak kompatibel satu sama lain adalah dua perpustakaan yang berbeda. </p><br><p>  Mari kita lakukan perubahan besar dalam paket kami.  Misalkan, seiring waktu, menjadi jelas bagi kami bahwa API kami terlalu sederhana, terlalu terbatas untuk kasus pengguna pengguna kami, jadi kami perlu mengubah fungsi <code>Hi()</code> untuk menerima bahasa sambutan sebagai parameter: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¡Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Program yang ada menggunakan API kami akan rusak karena mereka a) tidak lulus bahasa sebagai parameter dan b) jangan mengharapkan pengembalian kesalahan.  API baru kami tidak lagi kompatibel dengan versi 1.x, jadi penuhi versi 2.0.0. </p><br><p>  Saya sebutkan sebelumnya bahwa beberapa versi memiliki fitur, dan sekarang ini masalahnya. <br>  <strong>Versi 2 <em>atau yang lebih baru</em> harus mengubah jalur impor.</strong>  Sekarang ini adalah perpustakaan yang berbeda. </p><br><p>  Kami akan melakukan ini dengan menambahkan <em>jalur versi</em> baru ke nama modul kami. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Segala sesuatu yang lain adalah sama: push, beri label bahwa itu v2.0.0 (dan opsional sod cabang v2) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Pembaruan Versi Utama </h2><br><p>  Meskipun kami merilis versi baru yang tidak kompatibel dari perpustakaan kami, program yang ada <em>tidak rusak</em> , karena mereka terus menggunakan versi 1.0.1. <br>  <code>go get -u</code> <em>tidak akan</em> mengunduh versi 2.0.0. </p><br><p>  Tetapi pada titik tertentu, saya, sebagai pengguna perpustakaan, mungkin ingin meningkatkan ke versi 2.0.0, karena, misalnya, saya adalah salah satu dari pengguna yang membutuhkan dukungan untuk beberapa bahasa. </p><br><p>  Untuk memperbarui, saya perlu mengubah program saya sesuai: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Sekarang, ketika saya menjalankan <code>go build</code> , ia "berhenti" dan mengunduh versi 2.0.0 untuk saya.  Perhatikan bahwa meskipun jalur impor sekarang diakhiri dengan "v2", Go masih merujuk ke modul dengan nama aslinya ("testmod"). </p><br><p>  Seperti yang saya katakan, versi utama adalah paket yang berbeda.  Dua modul Go ini tidak terhubung dengan cara apa pun.  Ini artinya kita dapat memiliki dua versi yang tidak kompatibel dalam satu biner: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Dan ini menghilangkan masalah umum dengan manajemen dependensi ketika dependensi bergantung pada versi berbeda dari perpustakaan yang sama. </p><br><h2 id="navodim-poryadok">  Kami mengatur semuanya </h2><br><p>  Mari kita kembali ke versi sebelumnya, yang hanya menggunakan testmod 2.0.0 - jika kita memeriksa konten <code>go.mod</code> , kita akan melihat sesuatu: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Secara default, Go tidak menghapus dependensi dari <code>go.mod</code> hingga Anda memintanya.  Jika Anda memiliki dependensi yang tidak lagi diperlukan dan Anda ingin membersihkannya, Anda dapat menggunakan perintah <code>tidy</code> baru: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Sekarang kita hanya memiliki dependensi yang benar-benar kita gunakan. </p><br><h2 id="vendoring">  Penjual </h2><br><p>  Buka modul secara default, abaikan <code>vendor/</code> direktori.  Idenya adalah untuk secara bertahap menyingkirkan penjual <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a></sup> .  Tetapi jika kita masih ingin menambahkan dependensi "terpisah" ke kontrol versi kita, kita dapat melakukan ini: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  Tim akan membuat <code>vendor/</code> direktori di root proyek kami, yang berisi kode sumber semua dependensi. </p><br><p>  Namun, <code>go build</code> secara default masih mengabaikan isi direktori ini.  Jika Anda ingin mengumpulkan dependensi dari <code>vendor/</code> direktori, Anda harus secara eksplisit memintanya. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Saya berasumsi bahwa banyak pengembang yang ingin menggunakan vending akan menjalankan <code>go build</code> , seperti biasa, pada mesin mereka dan menggunakan <code>-mod vendor</code> pada CI mereka. </p><br><p>  Sekali lagi, modul Go beralih dari ide penjual untuk menggunakan proksi untuk modul bagi mereka yang tidak ingin bergantung secara langsung pada layanan kontrol versi hulu. </p><br><p>  Ada beberapa cara untuk memastikan bahwa <code>go</code> network tidak tersedia (misalnya, menggunakan <code>GOPROXY=off</code> ), tetapi ini adalah topik dari artikel selanjutnya. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Artikel itu mungkin terlihat rumit bagi seseorang, tetapi ini karena saya mencoba menjelaskan banyak hal sekaligus.  Kenyataannya adalah modul Go umumnya sederhana hari ini - kami, seperti biasa, mengimpor paket ke dalam kode kami, dan tim <code>go</code> mengerjakan sisanya untuk kami.  Ketergantungan dimuat secara otomatis selama perakitan. </p><br><p>  Modul-modul tersebut juga menghilangkan kebutuhan <code>$GOPATH</code> , yang merupakan batu sandungan bagi pengembang Go baru yang memiliki masalah dalam memahami mengapa mereka harus meletakkan sesuatu di direktori tertentu. </p><br><p><del>  Penjual (tidak resmi) telah ditinggalkan karena menggunakan proxy. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a></sup> <br>  Saya dapat membuat artikel terpisah tentang proksi untuk modul Go. </p><br><p>  Catatan: </p><br><p>  <sup>1</sup> Saya pikir ini ungkapan yang terlalu keras dan beberapa orang mungkin memiliki kesan penjual otomatis sedang dihapus sekarang.  Ini tidak benar.  Penjual masih bekerja, meskipun sedikit berbeda dari sebelumnya.  Rupanya, ada keinginan untuk mengganti penjual dengan sesuatu yang lebih baik, misalnya proxy (bukan fakta).  Sejauh ini, ini hanya mengejar solusi yang lebih baik.  Penjual tidak akan pergi sampai pengganti yang baik ditemukan (jika ada). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421411/">https://habr.com/ru/post/id421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421399/index.html">Analisis Pintu Belakang Outlook Turberg Cybergroup</a></li>
<li><a href="../id421401/index.html">Anatomi sistem rekomendasi. Bagian dua</a></li>
<li><a href="../id421403/index.html">Pekan Keamanan 32: Drama Fortnite-Android</a></li>
<li><a href="../id421407/index.html">Pertemuan teknis di St. Petersburg 13 September - Cara membuat perubahan besar di backend</a></li>
<li><a href="../id421409/index.html">Mengintai hal-hal: menjaga rahasia</a></li>
<li><a href="../id421413/index.html">Akses yang tepat ke metode antarmuka standar melalui refleksi di Java 8, 9, 10</a></li>
<li><a href="../id421415/index.html">Magic Leap - tempat sampah yang menyedihkan</a></li>
<li><a href="../id421417/index.html">Mesin kopi untuk pecandu kopi, atau mesin kopi mobile Wacaco</a></li>
<li><a href="../id421419/index.html">Ode untuk "membuahkan" nikel, safir yang tidak ada, dan wakil menteri Soviet: ikon OTTO SX-P1 di Jepang, Amerika Serikat dan Uni Soviet</a></li>
<li><a href="../id421421/index.html">LAppS: Setengah Juta Pesan 1KB-WebSocket per Detik dengan TLS pada Satu CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>