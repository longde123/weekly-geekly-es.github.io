<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺 🐘 🌮 Peta segi enam dalam Persatuan: siklus air, erosi, bioma, peta silindris 👈🏼 💊 📘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1-3: jala, warna, dan tinggi sel 

 Bagian 4-7: gundukan, sungai, dan jalan 

 Bagian 8-11: air, bentang alam, dan benteng 

 Bagian 12-15: men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peta segi enam dalam Persatuan: siklus air, erosi, bioma, peta silindris</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1-3: jala, warna, dan tinggi sel</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4-7: gundukan, sungai, dan jalan</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8-11: air, bentang alam, dan benteng</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12-15: menyimpan dan memuat, tekstur, jarak</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16-19: menemukan jalan, regu pemain, animasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20-23: Kabut Perang, Penelitian Peta, Generasi Prosedural</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24-27: siklus air, erosi, bioma, peta silindris</a> <br><br><h1>  Bagian 24: daerah dan erosi </h1><br><ul><li>  Tambahkan batas air di sekitar peta. </li><li>  Kami membagi peta menjadi beberapa wilayah. </li><li>  Kami menggunakan erosi untuk memotong tebing. </li><li>  Kami memindahkan tanah untuk memuluskan pertolongan. </li></ul><br>  Pada bagian sebelumnya, kami meletakkan dasar untuk pembuatan peta prosedural.  Kali ini kami akan membatasi tempat-tempat yang mungkin terjadinya tanah dan menindakinya dengan erosi. <br><br>  Tutorial ini dibuat di Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Pisahkan dan menghaluskan tanah.</i> <br><a name="habracut"></a><br><h2>  Batas peta </h2><br>  Karena kami menaikkan luas lahan secara acak, mungkin saja tanah itu menyentuh tepi peta.  Ini mungkin tidak diinginkan.  Peta terbatas air berisi penghalang alami yang mencegah pemain mendekati tepi.  Karena itu, alangkah baiknya jika kita melarang tanah naik di atas permukaan air di dekat tepi peta. <br><br><h3>  Ukuran perbatasan </h3><br>  Seberapa dekat jarak mendarat ke tepi peta?  Tidak ada jawaban yang tepat untuk pertanyaan ini, jadi kami akan membuat parameter ini dapat disesuaikan.  Kami akan menambahkan dua slider ke komponen <code>HexMapGenerator</code> , satu untuk perbatasan di sepanjang tepi sepanjang sumbu X, yang lain untuk perbatasan di sepanjang sumbu Z. Jadi kita dapat menggunakan perbatasan yang lebih luas di salah satu dimensi, atau bahkan membuat perbatasan hanya dalam satu dimensi.  Mari kita gunakan interval dari 0 hingga 10 dengan nilai default 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Peta berbatasan dengan bilah geser.</i> <br><br><h3>  Kami membatasi pusat area lahan </h3><br>  Tanpa batas, semua sel valid.  Ketika ada batas, koordinat offset minimum yang diizinkan meningkat, dan koordinat maksimum yang diijinkan berkurang.  Karena untuk menghasilkan plot kita perlu mengetahui interval yang diizinkan, mari kita lacak menggunakan empat bidang integer. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Kami menginisialisasi kendala di <code>GenerateMap</code> sebelum membuat sushi.  Kami menggunakan nilai-nilai ini sebagai parameter untuk panggilan <code>Random.Range</code> , sehingga tertinggi sebenarnya luar biasa.  Tanpa batas, mereka sama dengan jumlah sel pengukuran, oleh karena itu, tidak minus 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); … }</code> </pre> <br>  Kami tidak akan secara tegas melarang penampilan tanah di luar perbatasan, karena ini akan membuat pinggiran tajam.  Sebagai gantinya, kami hanya akan membatasi sel yang digunakan untuk memulai pembuatan plot.  Artinya, perkiraan pusat dari situs akan terbatas, tetapi bagian dari situs akan dapat melampaui area perbatasan.  Ini dapat dilakukan dengan memodifikasi <code>GetRandomCell</code> sehingga memilih sel dalam kisaran offset yang diizinkan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Perbatasan peta adalah 0 × 0, 5 × 5, 10 × 10, dan 0 × 10.</i> <br><br>  Ketika semua parameter peta diatur ke nilai standarnya, batas ukuran 5 andal akan melindungi tepi peta dari menyentuh tanah.  Namun, ini tidak dijamin.  Tanah kadang-kadang bisa mendekati tepi, dan kadang-kadang menyentuhnya di beberapa tempat. <br><br>  Kemungkinan tanah melintasi seluruh perbatasan tergantung pada ukuran perbatasan dan ukuran maksimum situs.  Tanpa ragu-ragu, bagian itu tetap segi enam.  Hexagon penuh dengan jari-jari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> r </script>  berisi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-7" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-mn" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mo" id="MJXp-Span-11" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-12"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="4803" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  sel.  Jika ada segi enam dengan jari-jari sama dengan ukuran perbatasan, maka mereka dapat melintasinya.  Hexagon penuh dengan jari-jari 5 berisi 91 sel.  Karena secara default maksimum adalah 100 sel per bagian, ini berarti bahwa tanah akan dapat meletakkan jembatan di 5 sel, terutama jika ada getaran.  Untuk mencegah hal ini terjadi, kurangi ukuran maksimum plot, atau tambah ukuran perbatasan. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana rumus untuk jumlah sel di daerah heksagonal diturunkan?</b> <div class="spoiler_text">  Dengan jari-jari 0, kita berhadapan dengan satu sel.  Itu berasal dari 1. Dengan jari-jari 1 di sekitar pusat, ada enam sel tambahan, yaitu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="1723" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Keenam sel ini dapat dianggap sebagai ujung dari enam segitiga yang menyentuh bagian tengah.  Dengan jari-jari 2, baris kedua ditambahkan ke segitiga ini, yaitu, dua sel lagi diperoleh pada segitiga, dan secara total <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mn" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 </font></font></span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-22"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="4726" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Dengan jari-jari 3, baris ketiga ditambahkan, yaitu tiga sel lagi per segitiga, dan total <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mn" id="MJXp-Span-27"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 </font></font></span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-29"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-30" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-31"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-33"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-36"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="6449" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  Dan sebagainya.  Artinya, secara umum, rumusnya seperti <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-37"><span class="MJXp-mn" id="MJXp-Span-38">6</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">j</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">a</span><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;">h</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;">(</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">i</span><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-50">1</span><span class="MJXp-msubsup" id="MJXp-Span-51"><span class="MJXp-mo" id="MJXp-Span-52" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-53" style="vertical-align: 0.5em;">r</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">i</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-57">1</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-59">6</span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">r</span><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">r</span><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-66">1</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mrow" id="MJXp-Span-69"><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-71">2</span><span class="MJXp-mo" id="MJXp-Span-72" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-74">1</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-76">3</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">r</span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">r</span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-81">1</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-84">1</span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-86">3</span><span class="MJXp-msubsup" id="MJXp-Span-87"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88" style="margin-right: 0.05em;">r</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-89" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-91">3</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">r</span><span class="MJXp-mo" id="MJXp-Span-93" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-94">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="76.889ex" height="3.312ex" viewBox="0 -950 33104.9 1426" role="img" focusable="false" style="vertical-align: -1.106ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-6A" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-75" x="1302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-6D" x="1875" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-6C" x="2753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-61" x="3052" y="0"></use><g transform="translate(3581,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="815" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-69" x="4533" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-3D" x="5156" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="6212" y="0"></use><g transform="translate(6713,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-69" x="7522" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="7867" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="8479" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="9480" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-3D" x="10258" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-36" x="11314" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="11815" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="12204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="12594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="13045" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="13435" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="14108" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="15109" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="15610" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="15999" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2F" x="16389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-32" x="16889" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="17390" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="18001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="19002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-3D" x="19780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="20837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="21337" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-28" x="21789" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="22178" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="22852" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="23853" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-29" x="24353" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="24965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="25966" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-3D" x="26744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="27800" y="0"></use><g transform="translate(28301,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="29428" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-33" x="30429" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMATHI-72" x="30929" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-2B" x="31603" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiJ88qbm13pwiykG4Ls4LVSmjDOrw#MJMAIN-31" x="32604" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> 6 (jumlah_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Untuk melihat ini lebih jelas, kita dapat mengatur ukuran perbatasan menjadi 200. Karena segi enam penuh dengan jari-jari 8 berisi 217 sel, tanah cenderung menyentuh tepi peta.  Setidaknya jika Anda menggunakan nilai ukuran batas default (5).  Jika Anda meningkatkan batas menjadi 10, kemungkinan akan sangat menurun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>Plot tanah memiliki ukuran konstan 200, batas peta adalah 5 dan 10.</i> <br><br><h3>  Pangea </h3><br>  Perhatikan bahwa saat Anda meningkatkan perbatasan peta dan mempertahankan persentase lahan yang sama, kami memaksa lahan untuk membentuk area yang lebih kecil.  Sebagai akibatnya, sebuah peta besar secara default kemungkinan besar akan menciptakan satu massa tanah besar - Pangaea superkontinen - mungkin dengan beberapa pulau kecil.  Dengan peningkatan ukuran perbatasan, kemungkinan ini meningkat, dan pada nilai-nilai tertentu kami hampir dijamin untuk mendapatkan benua super.  Namun, ketika persentase tanah terlalu besar, sebagian besar wilayah yang tersedia terisi dan sebagai hasilnya kami mendapatkan massa tanah yang hampir persegi.  Untuk mencegah hal ini terjadi, Anda perlu mengurangi persentase lahan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% sushi dengan batas kartu 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Dari mana nama Pangea berasal?</b> <div class="spoiler_text">  Itulah nama superbenua terakhir yang diketahui ada di Bumi beberapa tahun yang lalu.  Nama ini terdiri dari kata Yunani pan dan Gaia, yang berarti sesuatu seperti "semua alam" atau "semua tanah". </div></div><br><br><h3>  Kami melindungi dari kartu yang tidak mungkin </h3><br>  Kami menghasilkan jumlah lahan yang tepat hanya dengan terus menaikkan lahan sampai kami mencapai massa lahan yang diinginkan.  Ini bekerja karena cepat atau lambat kita akan menaikkan setiap sel di permukaan air.  Namun, ketika menggunakan perbatasan peta, kami tidak dapat mencapai setiap sel.  Ketika persentase tanah terlalu tinggi diperlukan, ini akan menyebabkan “upaya dan kegagalan” generator yang tak berkesudahan untuk meningkatkan lebih banyak lahan, dan itu akan menjadi terjebak dalam siklus tanpa akhir.  Dalam hal ini, aplikasi akan membeku, tetapi ini seharusnya tidak terjadi. <br><br>  Kami tidak dapat menemukan konfigurasi yang mungkin dengan andal sebelumnya, tetapi kami dapat melindungi diri dari siklus tanpa akhir.  Kami hanya akan melacak jumlah siklus yang dijalankan di <code>CreateLand</code> .  Jika ada terlalu banyak iterasi, maka kita kemungkinan besar macet dan harus berhenti. <br><br>  Untuk peta besar, seribu iterasi tampaknya dapat diterima, dan sepuluh ribu iterasi sudah tampak tidak masuk akal.  Jadi mari kita gunakan nilai ini sebagai titik terminasi. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); … } }</span></span></code> </pre> <br>  Jika kita mendapatkan peta yang rusak, maka melakukan 10.000 iterasi tidak akan memakan banyak waktu, karena banyak sel akan dengan cepat mencapai ketinggian maksimum, yang akan mencegah area baru tumbuh. <br><br>  Bahkan setelah memutus perulangan, kita masih mendapatkan peta yang benar.  Itu hanya tidak memiliki jumlah tanah yang tepat dan itu tidak akan terlihat sangat menarik.  Mari kita tampilkan pemberitahuan tentang hal ini di konsol, memberi tahu kami sisa lahan yang gagal kami habiskan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% tanah dengan batas kartu 10 tidak dapat menghabiskan seluruh jumlah.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa kartu yang gagal masih memiliki variasi?</b> <div class="spoiler_text">  Garis pantai memiliki variabilitas, karena ketika ketinggian di dalam area pembuatan menjadi terlalu tinggi, area baru tidak memungkinkan mereka untuk tumbuh ke luar.  Prinsip yang sama tidak memungkinkan plot untuk tumbuh menjadi area kecil tanah, sampai mereka mencapai ketinggian maksimum dan ternyata hilang.  Selain itu, variabilitas meningkat saat menurunkan plot. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Mempartisi kartu </h2><br>  Sekarang kita memiliki perbatasan peta, pada dasarnya kita membagi peta menjadi dua wilayah yang terpisah: wilayah perbatasan dan wilayah di mana plot dibuat.  Karena hanya wilayah penciptaan yang penting bagi kita, kita dapat mempertimbangkan kasus seperti itu sebagai situasi dengan satu wilayah.  Wilayah ini tidak mencakup seluruh peta.  Tetapi jika ini tidak mungkin, maka tidak ada yang menghalangi kita untuk membagi peta menjadi beberapa wilayah penciptaan tanah yang tidak terhubung.  Ini akan memungkinkan massa tanah terbentuk secara independen satu sama lain, menunjuk benua yang berbeda. <br><br><h3>  Wilayah Peta </h3><br>  Mari kita mulai dengan menggambarkan satu wilayah peta sebagai struct.  Ini akan mempermudah pekerjaan kami dengan beberapa daerah.  Mari kita buat struktur <code>MapRegion</code> untuk ini, yang hanya berisi bidang perbatasan wilayah.  Karena kita tidak akan menggunakan struktur ini di luar <code>HexMapGenerator</code> , kita dapat mendefinisikannya di dalam kelas ini sebagai struktur internal pribadi.  Kemudian empat bidang bilangan bulat dapat diganti dengan satu bidang <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Agar semuanya berfungsi, kita perlu menambahkan awalan <code>region.</code> ke bidang minimum-maksimum di <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Dan juga di <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Beberapa daerah </h3><br>  Untuk mendukung beberapa wilayah, ganti satu bidang <code>MapRegion</code> daftar wilayah. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  Pada titik ini, alangkah baiknya untuk menambahkan metode terpisah untuk membuat daerah.  Ini harus membuat daftar yang diinginkan atau menghapusnya jika sudah ada.  Setelah itu, dia akan menentukan satu wilayah, seperti yang kita lakukan sebelumnya, dan menambahkannya ke daftar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Kami akan memanggil metode ini di <code>GenerateMap</code> , dan kami tidak akan membuat wilayah secara langsung. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Agar <code>GetRandomCell</code> dapat bekerja dengan wilayah arbitrer, berikan parameter <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Sekarang metode <code>RaiseTerraion</code> dan <code>SinkTerrain</code> harus meneruskan wilayah terkait ke <code>GetRandomCell</code> .  Untuk melakukan ini, masing-masing dari mereka juga memerlukan parameter wilayah. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … }</code> </pre> <br>  Metode <code>CreateLand</code> harus menentukan untuk setiap wilayah untuk menaikkan atau menurunkan bagian.  Untuk menyeimbangkan tanah antar daerah, kami hanya akan berulang kali berkeliling daftar wilayah dalam siklus. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Namun, kita masih perlu membuat plot yang diturunkan merata.  Ini dapat dilakukan sambil memutuskan untuk semua wilayah apakah akan menghilangkannya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Akhirnya, untuk menggunakan persis seluruh jumlah lahan, kita harus menghentikan proses segera setelah jumlahnya mencapai nol.  Ini dapat terjadi pada setiap tahap siklus wilayah.  Oleh karena itu, kami memindahkan pemeriksaan zero-sum ke loop dalam.  Bahkan, kami hanya dapat melakukan pemeriksaan ini setelah meningkatkan lahan, karena ketika menurunkan, jumlahnya tidak pernah dihabiskan.  Jika sudah selesai, kita dapat segera keluar dari metode <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Dua daerah </h3><br>  Meskipun kami sekarang mendapat dukungan dari beberapa daerah, kami masih meminta hanya satu.  Mari kita ubah <code>CreateRegions</code> sehingga ia membagi peta menjadi dua secara vertikal.  Untuk melakukan ini, kami membagi dua nilai <code>xMax</code> dari wilayah yang ditambahkan.  Kemudian kami menggunakan nilai yang sama untuk <code>xMin</code> dan lagi menggunakan nilai asli untuk <code>xMax</code> , menggunakannya sebagai wilayah kedua. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Membuat kartu pada tahap ini tidak akan membuat perbedaan.  Meskipun kami telah mengidentifikasi dua wilayah, mereka menempati wilayah yang sama dengan satu wilayah lama.  Untuk memisahkan mereka, Anda harus meninggalkan ruang kosong di antara mereka.  Ini dapat dilakukan dengan menambahkan slider ke perbatasan wilayah, menggunakan interval dan nilai default yang sama dengan perbatasan peta. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Slider perbatasan wilayah.</i> <br><br>  Karena tanah dapat dibentuk di kedua sisi ruang antar wilayah, kemungkinan membuat jembatan tanah di tepi peta akan meningkat.  Untuk mencegah hal ini, kami menggunakan perbatasan wilayah untuk menentukan zona bebas tanah antara garis pemisah dan wilayah di mana plot dapat dimulai.  Ini berarti bahwa jarak antara wilayah tetangga adalah dua lebih besar dari ukuran perbatasan wilayah tersebut. <br><br>  Untuk menerapkan batas wilayah ini, kurangi dari <code>xMax</code> wilayah pertama dan tambahkan wilayah kedua ke <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>Peta ini dibagi secara vertikal menjadi dua wilayah.</i> <br><br>  Dengan pengaturan default, dua wilayah yang terpisah akan dibuat, namun, seperti dalam kasus dengan satu wilayah dan perbatasan peta besar, kami tidak dijamin untuk menerima tepat dua massa tanah.  Paling sering itu akan menjadi dua benua besar, mungkin dengan beberapa pulau.  Tetapi terkadang dua atau lebih pulau besar dapat dibuat di suatu wilayah.  Dan terkadang dua benua dapat dihubungkan oleh tanah genting. <br><br>  Tentu saja, kita juga dapat membagi peta secara horizontal, mengubah pendekatan untuk mengukur X dan Z. Mari kita secara acak memilih salah satu dari dua orientasi yang mungkin. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Peta secara horizontal dibagi menjadi dua wilayah.</i> <br><br>  Karena kami menggunakan peta yang luas, daerah yang lebih luas dan lebih tipis akan dibuat dengan pemisahan horizontal.  Akibatnya, daerah-daerah ini lebih cenderung membentuk beberapa massa tanah yang terbagi. <br><br><h3>  Empat daerah </h3><br>  Mari kita buat jumlah wilayah yang dapat disesuaikan, buat dukungan dari 1 hingga 4 wilayah. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Slider untuk jumlah wilayah.</i> <br><br>  Kita dapat menggunakan <code>switch</code> untuk memilih eksekusi kode wilayah yang sesuai.  Kami mulai dengan mengulangi kode satu wilayah, yang akan digunakan secara default, dan meninggalkan kode dua wilayah untuk kasus 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Apa pernyataan sakelar?</b> <div class="spoiler_text">  Ini adalah alternatif untuk menulis urutan pernyataan if-else-if-else.  switch diterapkan ke variabel, dan label digunakan untuk menunjukkan kode mana yang perlu dieksekusi.  Ada juga label <code>default</code> , yang digunakan sebagai blok yang terakhir.  Setiap opsi harus diakhiri dengan pernyataan <code>break</code> atau <code>return</code> . <br><br>  Agar blok <code>switch</code> dapat dibaca, biasanya yang terbaik adalah membuat semua case pendek, idealnya dengan satu pernyataan atau metode panggilan.  Saya tidak akan melakukan ini sebagai contoh kode wilayah, tetapi jika Anda ingin membuat daerah yang lebih menarik, saya sarankan Anda menggunakan metode terpisah.  Sebagai contoh: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Tiga daerah mirip dengan dua, hanya pertiganya digunakan alih-alih setengah.  Dalam hal ini, pembagian horizontal akan membuat daerah terlalu sempit, jadi kami membuat dukungan hanya untuk pembagian vertikal.  Perhatikan bahwa sebagai hasilnya, kami telah menggandakan area perbatasan wilayah, sehingga ruang untuk membuat bagian baru kurang dari pada kasus dua wilayah. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Tiga wilayah.</i> <br><br>  Empat wilayah dapat dibuat dengan menggabungkan pemisahan horizontal dan vertikal dan menambahkan satu wilayah ke setiap sudut peta. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Empat daerah.</i> <br><br>  Pendekatan yang digunakan di sini adalah cara paling sederhana untuk membagi peta.  Ini menghasilkan kira-kira daerah yang sama berdasarkan massa tanah, dan variabilitasnya dikontrol oleh parameter lain dari pembuatan peta.  Namun, akan selalu cukup jelas bahwa kartu itu dibagi dalam garis lurus.  Semakin banyak kontrol yang kita butuhkan, semakin sedikit organik hasilnya akan terlihat.  Karena itu, ini normal jika Anda membutuhkan wilayah yang kira-kira sama untuk permainan.  Tetapi jika Anda membutuhkan tanah yang paling bervariasi dan tidak terbatas, Anda harus membuatnya dengan bantuan satu wilayah. <br><br>  Selain itu, ada cara lain untuk membagi peta.  Kami tidak bisa dibatasi hanya untuk garis lurus.  Kami bahkan tidak harus menggunakan wilayah dengan ukuran yang sama, serta mencakup seluruh peta dengan mereka.  Kita bisa meninggalkan lubang.  Anda juga dapat mengizinkan persimpangan wilayah atau mengubah distribusi tanah antar wilayah.  Anda bahkan dapat mengatur parameter generator Anda sendiri untuk setiap wilayah (meskipun ini lebih rumit), misalnya, untuk memiliki benua besar dan kepulauan di peta. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Erosi </h2><br>  Sejauh ini, semua kartu yang kami hasilkan terlihat agak kasar dan rusak.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelegaan nyata mungkin terlihat seperti ini, tetapi seiring waktu menjadi lebih halus dan halus, bagian-bagian yang tajam menjadi kusam karena erosi. </font><font style="vertical-align: inherit;">Untuk memperbaiki peta, kita bisa menerapkan proses erosi ini. </font><font style="vertical-align: inherit;">Kami akan melakukan ini setelah membuat tanah kasar, dengan metode terpisah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persentase erosi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semakin banyak waktu berlalu, semakin banyak erosi yang muncul. </font><font style="vertical-align: inherit;">Karena itu, kami ingin erosi tidak permanen, tetapi dapat disesuaikan. </font><font style="vertical-align: inherit;">Minimal, erosi adalah nol, yang sesuai dengan peta yang dibuat sebelumnya. </font><font style="vertical-align: inherit;">Pada erosi maksimum bersifat komprehensif, yaitu, penerapan kekuatan erosi lebih lanjut tidak akan lagi mengubah medan. </font><font style="vertical-align: inherit;">Artinya, parameter erosi harus berupa persentase dari 0 hingga 100, dan secara default kami akan mengambil 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider erosi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari sel yang merusak erosi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosi membuat kelegaan lebih halus. Dalam kasus kami, satu-satunya bagian yang tajam adalah tebing. Karena itu, mereka akan menjadi target dari proses erosi. Jika ada tebing, erosi harus menguranginya sampai akhirnya berubah menjadi lereng. Kami tidak akan menghaluskan lereng, karena ini akan menyebabkan medan yang membosankan. Untuk melakukan ini, kita perlu menentukan sel mana yang berada di puncak tebing, dan menurunkan ketinggiannya. Ini akan menjadi sel yang rentan erosi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita membuat metode yang menentukan apakah sebuah sel bisa rentan terhadap erosi. </font><font style="vertical-align: inherit;">Dia menentukan ini dengan memeriksa tetangga sel sampai dia menemukan perbedaan ketinggian yang cukup besar. </font><font style="vertical-align: inherit;">Karena tebing memerlukan perbedaan setidaknya satu atau dua tingkat ketinggian, sel dapat mengalami erosi jika satu atau lebih tetangganya setidaknya dua langkah di bawahnya. </font><font style="vertical-align: inherit;">Jika tidak ada tetangga seperti itu, maka sel tidak bisa mengalami erosi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menggunakan metode ini </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengulang semua sel dan menulis semua sel yang rentan erosi ke daftar sementara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah kita mengetahui jumlah total sel rawan erosi, kita dapat menggunakan persentase erosi untuk menentukan jumlah sel rawan erosi yang tersisa. </font><font style="vertical-align: inherit;">Misalnya, jika persentasenya 50, maka kita harus erosi sel sampai setengah dari jumlah aslinya tetap. </font><font style="vertical-align: inherit;">Jika persentasenya 100, maka kita tidak akan berhenti sampai kita menghancurkan semua sel yang rentan erosi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah seharusnya kita hanya mempertimbangkan sel rawan erosi tanah?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengurangan sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan pendekatan naif dan anggaplah bahwa pengurangan sederhana pada ketinggian erosi yang dihancurkan sel akan membuatnya tidak lagi rentan terhadap erosi. </font><font style="vertical-align: inherit;">Jika ini benar, maka kita bisa mengambil sel acak dari daftar, mengurangi ketinggiannya, dan kemudian menghapusnya dari daftar. </font><font style="vertical-align: inherit;">Kami akan mengulangi operasi ini sampai kami mencapai jumlah sel yang diinginkan yang rentan terhadap erosi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencegah pencarian yang diperlukan </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami akan menimpa sel terakhir saat ini dalam daftar, dan kemudian menghapus elemen terakhir. </font><font style="vertical-align: inherit;">Kami masih tidak peduli dengan pesanan mereka.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penurunan naif dari 0% dan 100% sel rawan erosi, peta benih 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan erosi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan naif kami memungkinkan kami menerapkan erosi, tetapi tidak pada tingkat yang tepat. </font><font style="vertical-align: inherit;">Ini terjadi karena sel setelah satu penurunan ketinggian masih dapat tetap rentan terhadap erosi. </font><font style="vertical-align: inherit;">Karena itu, kami akan menghapus sel dari daftar hanya ketika tidak lagi mengalami erosi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosi 100% sambil mempertahankan sel-sel yang rentan erosi dalam daftar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kita mendapatkan erosi yang jauh lebih kuat, tetapi saat menggunakan 100% kita masih belum bisa menyingkirkan semua tebing. </font><font style="vertical-align: inherit;">Alasannya adalah bahwa setelah mengurangi ketinggian sel, salah satu tetangganya menjadi rentan terhadap erosi. </font><font style="vertical-align: inherit;">Karena itu, sebagai hasilnya, kita mungkin memiliki lebih banyak sel rawan erosi daripada aslinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menurunkan sel, kita perlu memeriksa semua tetangganya. </font><font style="vertical-align: inherit;">Jika sekarang mereka rentan terhadap erosi, tetapi mereka belum ada dalam daftar, maka Anda perlu menambahkannya di sana.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua sel yang tererosi dihilangkan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menghemat banyak tanah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang proses erosi dapat berlanjut sampai semua tebing hilang. Ini sangat mempengaruhi tanah. Sebagian besar daratan hilang dan kami mendapat jauh lebih sedikit dari persentase tanah yang dibutuhkan. Itu terjadi karena kami memindahkan tanah dari peta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosi sejati tidak menghancurkan materi. Dia mengambilnya dari satu tempat dan menempatkannya di tempat lain. Kita bisa melakukan hal yang sama. Dengan penurunan satu sel, kita harus meningkatkan salah satu tetangganya. Bahkan, satu tingkat ketinggian ditransfer ke sel yang lebih rendah. Ini menyimpan jumlah total ketinggian peta, sementara hanya menghaluskannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk merealisasikan hal ini, kita perlu memutuskan ke mana harus mentransfer produk erosi. </font><font style="vertical-align: inherit;">Ini akan menjadi target erosi kami. </font><font style="vertical-align: inherit;">Mari kita membuat metode untuk menentukan titik target sel yang akan terkikis. </font><font style="vertical-align: inherit;">Karena sel ini berisi istirahat, akan logis untuk memilih sel yang terletak di bawah istirahat ini sebagai target. </font><font style="vertical-align: inherit;">Tetapi sel yang rentan erosi dapat mengalami beberapa kali istirahat, jadi kami akan memeriksa semua tetangga dan menempatkan semua kandidat pada daftar sementara, dan kemudian kami akan memilih salah satu dari mereka secara acak.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami menentukan sel target segera setelah memilih sel erosi. </font><font style="vertical-align: inherit;">Lalu kami mengurangi dan meningkatkan ketinggian sel segera satu demi satu. </font><font style="vertical-align: inherit;">Dalam hal ini, sel target itu sendiri mungkin menjadi rentan terhadap erosi, tetapi situasi ini diselesaikan ketika kita memeriksa tetangga sel yang baru tererosi.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami menaikkan sel target, sebagian tetangga sel ini mungkin tidak lagi mengalami erosi. </font><font style="vertical-align: inherit;">Penting untuk mengelilingi mereka dan memeriksa apakah mereka rentan terhadap erosi. </font><font style="vertical-align: inherit;">Jika tidak, tetapi mereka ada dalam daftar, maka Anda harus menghapusnya dari itu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); … } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% erosi sambil mempertahankan massa tanah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosi sekarang dapat memuluskan medan jauh lebih baik, menurunkan beberapa area dan meningkatkan lainnya. </font><font style="vertical-align: inherit;">Akibatnya, massa tanah dapat meningkat dan menyempit. </font><font style="vertical-align: inherit;">Ini dapat mengubah persentase tanah beberapa persen dalam satu arah atau lainnya, tetapi penyimpangan serius jarang terjadi. </font><font style="vertical-align: inherit;">Artinya, semakin banyak erosi yang kita terapkan, semakin sedikit kontrol yang kita miliki atas persentase lahan yang dihasilkan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosi yang dipercepat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami tidak perlu benar-benar peduli tentang efektivitas algoritma erosi, kami dapat melakukan perbaikan sederhana untuk itu. </font><font style="vertical-align: inherit;">Pertama, perhatikan bahwa kami secara eksplisit memeriksa apakah sel yang kami erosi dapat terkikis. </font><font style="vertical-align: inherit;">Jika tidak, maka pada dasarnya kami menghapusnya dari daftar. </font><font style="vertical-align: inherit;">Oleh karena itu, Anda dapat melewati pemeriksaan sel ini saat melintasi tetangga sel target.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, kami perlu memeriksa tetangga sel target hanya ketika ada jeda di antara mereka, tapi sekarang ini tidak perlu. </font><font style="vertical-align: inherit;">Ini hanya terjadi ketika tetangga sekarang selangkah lebih tinggi dari sel target. </font><font style="vertical-align: inherit;">Jika demikian, maka tetangga dijamin ada dalam daftar, jadi kita tidak perlu memeriksa ini, yaitu, kita dapat melewati pencarian yang tidak perlu.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketiga, kita bisa menggunakan trik serupa ketika memeriksa tetangga sel yang rentan erosi. </font><font style="vertical-align: inherit;">Jika sekarang ada tebing di antara mereka, maka tetangga rentan terhadap erosi. </font><font style="vertical-align: inherit;">Untuk mengetahuinya, kita tidak perlu menelepon </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, kita masih perlu memeriksa apakah sel target rentan terhadap erosi, tetapi siklus yang ditunjukkan di atas tidak lagi melakukan ini. </font><font style="vertical-align: inherit;">Oleh karena itu, kami melakukan ini secara eksplisit untuk sel target.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menerapkan erosi dengan cukup cepat dan dengan persentase yang diinginkan relatif terhadap jumlah awal tebing yang dihasilkan. </font><font style="vertical-align: inherit;">Perhatikan bahwa karena kami sedikit mengubah tempat sel target ditambahkan ke daftar rawan erosi, hasilnya telah sedikit berubah dari hasil sebelum optimisasi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% dan 100% erosi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga perhatikan bahwa meskipun bentuk pantai berubah, topologi belum berubah secara mendasar. </font><font style="vertical-align: inherit;">Massa tanah biasanya tetap terhubung atau terpisah. </font><font style="vertical-align: inherit;">Hanya pulau-pulau kecil yang bisa tenggelam sepenuhnya. </font><font style="vertical-align: inherit;">Rincian bantuan dihaluskan, tetapi bentuk umumnya tetap sama. </font><font style="vertical-align: inherit;">Sendi yang sempit dapat menghilang, atau tumbuh sedikit. </font><font style="vertical-align: inherit;">Sebuah celah kecil dapat mengisi atau sedikit berkembang. </font><font style="vertical-align: inherit;">Karena itu, erosi tidak akan menyatukan wilayah yang terbelah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empat daerah yang tererosi sepenuhnya masih terpisah. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 25: Siklus Air </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menampilkan data peta mentah. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membentuk iklim sel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat simulasi parsial dari siklus air. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini kami akan menambahkan kelembaban di darat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial ini dibuat di Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan siklus air untuk menentukan bioma.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Awan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hingga saat ini, algoritma pembuatan peta hanya mengubah ketinggian sel. </font><font style="vertical-align: inherit;">Perbedaan terbesar antara sel-sel adalah apakah mereka berada di atas atau di bawah air. </font><font style="vertical-align: inherit;">Meskipun kami dapat menentukan berbagai jenis medan, ini hanyalah visualisasi ketinggian yang sederhana. </font><font style="vertical-align: inherit;">Akan lebih baik untuk menentukan jenis bantuan, mengingat iklim setempat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iklim bumi adalah sistem yang sangat kompleks. </font><font style="vertical-align: inherit;">Untungnya, kita tidak perlu membuat simulasi iklim yang realistis. </font><font style="vertical-align: inherit;">Kami akan membutuhkan sesuatu yang terlihat cukup alami. </font><font style="vertical-align: inherit;">Aspek terpenting dari iklim adalah siklus air, karena flora dan fauna membutuhkan air cair untuk bertahan hidup. </font><font style="vertical-align: inherit;">Suhu juga sangat penting, tetapi untuk saat ini, kami fokus pada air, pada dasarnya membiarkan suhu global konstan dan hanya mengubah kelembaban.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siklus air menggambarkan pergerakan air di lingkungan. </font><font style="vertical-align: inherit;">Sederhananya, kolam menguap, yang mengarah ke penciptaan awan hujan, yang lagi-lagi mengalir ke kolam. </font><font style="vertical-align: inherit;">Ada banyak aspek dalam sistem, tetapi mensimulasikan langkah-langkah ini mungkin sudah cukup untuk membuat distribusi air yang tampak alami pada peta.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisasi data </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita masuk ke simulasi ini, akan berguna untuk langsung melihat data yang relevan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami akan mengubah shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami menambahkan properti yang dapat dialihkan ke sana, yang dapat dialihkan ke mode visualisasi data, yang menampilkan data peta mentah alih-alih tekstur relief yang biasa. </font><font style="vertical-align: inherit;">Ini dapat diimplementasikan menggunakan properti float dengan atribut switchable yang mendefinisikan kata kunci. </font><font style="vertical-align: inherit;">Karena ini, itu akan muncul di inspektur materi sebagai bendera yang mengontrol definisi kata kunci. </font><font style="vertical-align: inherit;">Nama properti itu sendiri tidak penting, kami hanya tertarik pada kata kunci. </font><font style="vertical-align: inherit;">Kami menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beralih untuk menampilkan data peta. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan fungsi shader untuk mengaktifkan dukungan kata kunci.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan membuatnya menampilkan float tunggal, seperti halnya dengan sisa data bantuan. </font><font style="vertical-align: inherit;">Untuk menerapkan ini, kami akan menambahkan </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang </font><font style="vertical-align: inherit;">ke struktur </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat kata kunci ditentukan.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam program vertex, kami menggunakan saluran Z dari sel-sel ini untuk mengisi </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti yang selalu diinterpolasi antar sel.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat Anda perlu menampilkan data sel, gunakan langsung sebagai fragmen albedo, bukan warna yang biasa. </font><font style="vertical-align: inherit;">Lipat gandakan dengan grid sehingga grid tetap dihidupkan saat merender data.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk benar-benar mentransfer data ke shader. </font><font style="vertical-align: inherit;">kita perlu menambahkan </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode yang menulis sesuatu ke saluran data tekstur biru. </font><font style="vertical-align: inherit;">Data adalah nilai float tunggal terbatas pada 0-1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, keputusan ini mempengaruhi sistem penelitian. </font><font style="vertical-align: inherit;">Nilai data saluran biru 255 digunakan untuk menunjukkan bahwa visibilitas sel sedang dalam transisi. </font><font style="vertical-align: inherit;">Agar sistem ini dapat terus bekerja, kita perlu menggunakan nilai byte 254 sebagai maksimum. Perhatikan bahwa gerakan detasemen akan menghapus semua data kartu, tetapi ini cocok untuk kita, karena mereka digunakan untuk pembuatan kartu debugging.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode dengan nama yang sama dan dalam </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan mentransfer permintaan ke data shader-nya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memeriksa operasi kode, ubahlah </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menetapkan data setiap sel peta. </font><font style="vertical-align: inherit;">Mari kita memvisualisasikan ketinggian yang dikonversi dari bilangan bulat menjadi mengambang dalam interval 0-1. </font><font style="vertical-align: inherit;">Ini dilakukan dengan mengurangi ketinggian minimum dari tinggi sel, diikuti dengan membagi dengan ketinggian maksimum dikurangi minimum. </font><font style="vertical-align: inherit;">Mari kita buat floating point divisi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat beralih antara dataran normal dan visualisasi data menggunakan </font><font style="vertical-align: inherit;">kotak centang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilkan Peta Data</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aset material </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta 1208905299, dataran normal dan visualisasi ketinggian.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penciptaan iklim </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mensimulasikan iklim, kita perlu melacak data iklim. </font><font style="vertical-align: inherit;">Karena peta terdiri dari sel-sel yang terpisah, masing-masing memiliki iklim lokalnya sendiri. </font><font style="vertical-align: inherit;">Buat struktur </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menyimpan semua data yang relevan. </font><font style="vertical-align: inherit;">Tentu saja, Anda dapat menambahkan data ke sel itu sendiri, tetapi kami hanya akan menggunakannya saat membuat peta. </font><font style="vertical-align: inherit;">Karenanya, kami akan menyimpannya secara terpisah. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita dapat mendefinisikan struktur ini secara internal </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan mulai dengan hanya melacak awan, yang dapat diimplementasikan menggunakan bidang float tunggal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan daftar untuk melacak data iklim untuk semua sel. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita membutuhkan metode untuk membuat peta iklim. </font><font style="vertical-align: inherit;">Itu harus dimulai dengan membersihkan daftar zona iklim, dan kemudian menambahkan satu elemen untuk setiap sel. </font><font style="vertical-align: inherit;">Data iklim awal hanyalah nol, ini dapat dicapai dengan menggunakan konstruktor standar </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iklim harus dibuat setelah terpapar erosi tanah sebelum menetapkan jenis bantuan. </font><font style="vertical-align: inherit;">Pada kenyataannya, erosi terutama disebabkan oleh pergerakan udara dan air, yang merupakan bagian dari iklim, tetapi kami tidak akan mensimulasikan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga kita bisa melihat data cloud, bukan tinggi sel. </font><font style="vertical-align: inherit;">Awalnya, itu akan terlihat seperti kartu hitam.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengubah iklim </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah pertama dalam simulasi iklim adalah penguapan. </font><font style="vertical-align: inherit;">Berapa banyak air yang harus diuapkan? </font><font style="vertical-align: inherit;">Mari kita kontrol nilai ini menggunakan slider. </font><font style="vertical-align: inherit;">Nilai 0 berarti tidak ada evaporasi, 1 - evaporasi maksimum. </font><font style="vertical-align: inherit;">Secara default, kami menggunakan 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider penguapan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita buat metode lain khusus untuk membentuk iklim satu sel. </font><font style="vertical-align: inherit;">Kami memberikannya indeks sel sebagai parameter dan menggunakannya untuk mendapatkan sel yang sesuai dan data iklimnya. </font><font style="vertical-align: inherit;">Jika sel berada di bawah air, maka kita berhadapan dengan reservoir yang harus menguap. </font><font style="vertical-align: inherit;">Kami segera mengubah uap menjadi awan (mengabaikan titik embun dan kondensasi), jadi kami akan langsung menambahkan penguapan ke nilai awan sel. </font><font style="vertical-align: inherit;">Setelah selesai dengan ini, salin kembali data iklim ke daftar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil metode ini untuk setiap sel di </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi ini tidak cukup. </font><font style="vertical-align: inherit;">Untuk membuat simulasi yang kompleks, kita perlu membentuk iklim sel beberapa kali. </font><font style="vertical-align: inherit;">Semakin sering kita melakukan ini, semakin baik hasilnya. </font><font style="vertical-align: inherit;">Mari kita pilih nilai konstan. </font><font style="vertical-align: inherit;">Saya menggunakan 40 siklus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena sementara kita hanya meningkatkan nilai awan di atas sel yang dibanjiri air, akibatnya kita mendapatkan tanah hitam dan reservoir putih. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penguapan di atas air.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hamburan awan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awan tidak terus-menerus di satu tempat, terutama ketika semakin banyak air menguap. </font><font style="vertical-align: inherit;">Perbedaan tekanan membuat udara bergerak, yang memanifestasikan dirinya dalam bentuk angin, yang juga membuat awan bergerak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika tidak ada arah angin yang dominan, maka rata-rata awan sel secara merata akan menyebar ke segala arah, muncul di sel tetangga. </font><font style="vertical-align: inherit;">Saat membuat awan baru di siklus berikutnya, mari kita distribusikan semua awan di sel ke tetangganya. </font><font style="vertical-align: inherit;">Artinya, setiap tetangga menerima seperenam dari awan sel, setelah itu ada penurunan lokal ke nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk benar-benar menambahkan cloud ke tetangga Anda, Anda harus mengelilingi mereka dalam satu lingkaran, mendapatkan data iklim mereka, meningkatkan nilai cloud dan menyalinnya kembali ke daftar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awan yang berhamburan.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini menciptakan peta yang hampir putih, karena pada setiap siklus, sel-sel bawah laut menambah lebih banyak awan ke iklim global. Setelah siklus pertama, sel-sel tanah di sebelah air juga akan memiliki awan yang perlu disebarkan. Proses ini berlanjut hingga sebagian besar peta tertutup awan. Dalam kasus peta 1208905299 dengan parameter default, hanya bagian dalam dari massa tanah yang besar di timur laut yang benar-benar terbuka.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa kolam dapat menghasilkan awan dalam jumlah tak terbatas. </font><font style="vertical-align: inherit;">Permukaan air bukan bagian dari simulasi iklim. </font><font style="vertical-align: inherit;">Pada kenyataannya, waduk dipertahankan hanya karena air mengalir kembali ke mereka dengan laju penguapan. </font><font style="vertical-align: inherit;">Artinya, kami hanya mensimulasikan siklus air parsial. </font><font style="vertical-align: inherit;">Ini normal, tetapi kita harus memahami semakin lama simulasi berlangsung, semakin banyak air ditambahkan ke iklim. </font><font style="vertical-align: inherit;">Sejauh ini, kehilangan air hanya terjadi di tepi peta, di mana awan yang tersebar hilang karena kurangnya tetangga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat hilangnya air di bagian atas peta, terutama di sel-sel di kanan atas. </font><font style="vertical-align: inherit;">Di sel terakhir tidak ada awan sama sekali, karena itu tetap yang terakhir di mana iklim terbentuk. </font><font style="vertical-align: inherit;">Dia belum menerima awan dari tetangga.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah seharusnya iklim semua sel terbentuk secara paralel?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curah hujan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air tidak selamanya dingin. Pada titik tertentu, dia harus jatuh ke tanah lagi. Ini biasanya terjadi dalam bentuk hujan, tetapi kadang-kadang bisa berupa salju, hujan es, atau salju basah. Semua ini umumnya disebut presipitasi. Besarnya dan tingkat hilangnya awan sangat bervariasi, tetapi kami hanya menggunakan tingkat curah hujan global khusus. Nilai 0 berarti tidak ada presipitasi, nilai 1 berarti bahwa semua awan menghilang secara instan. Nilai standarnya adalah 0,25. Ini berarti bahwa dalam setiap siklus, seperempat awan akan menghilang.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider koefisien presipitasi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mensimulasikan curah hujan setelah penguapan dan sebelum hamburan awan. </font><font style="vertical-align: inherit;">Ini berarti bahwa sebagian air menguap dari reservoir segera mengendap, sehingga jumlah awan yang menyebar berkurang. </font><font style="vertical-align: inherit;">Di darat, curah hujan akan menyebabkan hilangnya awan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awan menghilang. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika kita menghancurkan 25% dari awan di setiap siklus, tanah itu lagi hampir hitam. </font><font style="vertical-align: inherit;">Awan berhasil bergerak ke pedalaman hanya beberapa langkah, setelah itu mereka menjadi tidak terlihat. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelembaban </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun curah hujan menghancurkan awan, mereka seharusnya tidak menghilangkan air dari iklim. </font><font style="vertical-align: inherit;">Setelah jatuh ke tanah, air terselamatkan, hanya dalam keadaan berbeda. </font><font style="vertical-align: inherit;">Ini bisa ada dalam banyak bentuk, yang umumnya kita anggap kelembaban.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan kelembaban </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan meningkatkan model iklim dengan melacak dua kondisi air: awan dan kelembaban. </font><font style="vertical-align: inherit;">Untuk mengimplementasikan ini, tambahkan </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bentuknya yang paling umum, penguapan adalah proses mengubah kelembaban menjadi awan, setidaknya dalam model iklim sederhana kami. </font><font style="vertical-align: inherit;">Ini berarti bahwa penguapan seharusnya tidak menjadi nilai konstan, tetapi faktor lain. </font><font style="vertical-align: inherit;">Oleh karena itu, kami melakukan penggantian nama refactoring </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sel berada di bawah air, kami hanya mengumumkan bahwa tingkat kelembaban adalah 1. Ini berarti bahwa penguapan sama dengan koefisien penguapan. </font><font style="vertical-align: inherit;">Tapi sekarang kita juga bisa mendapatkan penguapan dari sel sushi. </font><font style="vertical-align: inherit;">Dalam hal ini, kita perlu menghitung penguapan, kurangi dari kelembaban dan tambahkan hasilnya ke awan. </font><font style="vertical-align: inherit;">Setelah itu, presipitasi ditambahkan ke kelembaban.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena awan sekarang didukung oleh penguapan dari atas tanah, kita dapat memindahkannya lebih jauh ke daratan. </font><font style="vertical-align: inherit;">Sekarang sebagian besar tanah telah menjadi abu-abu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awan dengan penguapan kelembaban. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita ubah </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menampilkan kelembapan dan bukan awan, karena kita akan menggunakannya untuk menentukan jenis bantuan.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilan kelembaban. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, kelembabannya terlihat sangat mirip dengan awan (kecuali bahwa semua sel bawah air berwarna putih), tetapi itu akan segera berubah.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limpasan curah hujan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penguapan bukan satu-satunya cara agar kelembaban dapat meninggalkan sel. </font><font style="vertical-align: inherit;">Siklus air memberi tahu kita bahwa sebagian besar kelembaban yang ditambahkan ke tanah entah bagaimana berakhir di air. </font><font style="vertical-align: inherit;">Proses yang paling nyata adalah aliran air di atas tanah di bawah pengaruh gravitasi. </font><font style="vertical-align: inherit;">Kami tidak akan mensimulasikan sungai nyata, tetapi menggunakan koefisien limpasan curah hujan khusus. </font><font style="vertical-align: inherit;">Ini akan menunjukkan persentase pengeringan air ke daerah yang lebih rendah. </font><font style="vertical-align: inherit;">Mari kita default stok akan sama dengan 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepaskan slider.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak akan menghasilkan sungai?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliran air bertindak seperti hamburan awan, tetapi dengan tiga perbedaan. Pertama, tidak semua uap air dikeluarkan dari sel. Kedua, ia membawa kelembaban, bukan awan. Ketiga, turun, yaitu hanya untuk tetangga dengan ketinggian lebih rendah. Koefisien limpasan menggambarkan jumlah air yang akan mengalir keluar dari sel jika semua tetangga lebih rendah, tetapi seringkali mereka lebih sedikit. Ini berarti bahwa kita akan mengurangi kelembaban sel hanya ketika kita menemukan tetangga di bawah ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengurasan air ke ketinggian yang lebih rendah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasilnya, kami memiliki distribusi kelembaban yang lebih beragam, karena sel-sel tinggi mentransmisikan kelembabannya ke yang lebih rendah. </font><font style="vertical-align: inherit;">Kami juga melihat lebih sedikit kelembaban di sel-sel pesisir, karena mereka mengalirkan uap air ke sel-sel bawah air. </font><font style="vertical-align: inherit;">Untuk melemahkan efek ini, kita juga perlu menggunakan level air ketika menentukan apakah sel lebih rendah, yaitu, mengambil ketinggian yang terlihat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan ketinggian yang terlihat.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rembesan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air tidak hanya mengalir ke bawah, itu menyebar, merembes melalui topografi tingkat, dan diserap oleh tanah yang berdekatan dengan badan air. </font><font style="vertical-align: inherit;">Efek ini mungkin memiliki sedikit efek, tetapi berguna untuk memperlancar distribusi kelembaban, jadi mari kita tambahkan ke simulasi. </font><font style="vertical-align: inherit;">Mari kita buat dia koefisien kustom sendiri, secara default sama dengan 0,125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider kebocoran. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rembesan mirip dengan selokan, kecuali digunakan ketika tetangga memiliki ketinggian yang sama dengan sel itu sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ditambahkan sedikit kebocoran. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bayangan hujan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami telah membuat simulasi yang layak dari siklus air, itu tidak terlihat sangat menarik, karena tidak memiliki bayangan hujan, yang paling jelas menunjukkan perbedaan iklim. </font><font style="vertical-align: inherit;">Bayang-bayang hujan adalah daerah di mana ada curah hujan yang kurang signifikan dibandingkan dengan daerah tetangga. </font><font style="vertical-align: inherit;">Daerah-daerah seperti itu ada karena gunung menghalangi awan untuk menjangkau mereka. </font><font style="vertical-align: inherit;">Penciptaan mereka membutuhkan gunung yang tinggi dan arah angin yang dominan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Angin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan menambahkan arah angin dominan ke simulasi. </font><font style="vertical-align: inherit;">Meskipun arah angin dominan sangat bervariasi di permukaan Bumi, kami akan mengelola dengan arah angin global yang dapat disesuaikan. </font><font style="vertical-align: inherit;">Mari kita gunakan barat laut secara default. </font><font style="vertical-align: inherit;">Selain itu, mari kita buat kekuatan angin dapat disesuaikan dari 1 hingga 10 dengan nilai default 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arah dan kekuatan angin. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kekuatan angin dominan diekspresikan relatif terhadap dispersi total awan. </font><font style="vertical-align: inherit;">Jika kekuatan angin adalah 1, maka hamburan adalah sama di semua arah. </font><font style="vertical-align: inherit;">Ketika 2, hamburan dua lebih tinggi ke arah angin daripada di arah lain, dan seterusnya. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dengan mengubah pembagi dalam rumus cloud scatter. </font><font style="vertical-align: inherit;">Alih-alih enam, itu akan sama dengan lima ditambah tenaga angin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, arah angin menentukan arah angin bertiup. </font><font style="vertical-align: inherit;">Oleh karena itu, kita perlu menggunakan arah yang berlawanan sebagai arah utama hamburan.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat memeriksa apakah tetangga berada di arah utama hamburan. </font><font style="vertical-align: inherit;">Jika demikian, maka kita harus melipatgandakan hamburan awan dengan kekuatan angin.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angin barat laut, kekuatan 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Angin dominan menambah arah ke distribusi kelembaban di darat. </font><font style="vertical-align: inherit;">Semakin kuat angin, semakin kuat efeknya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tinggi absolut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan kedua dalam mendapatkan bayangan hujan adalah pegunungan. Kami tidak memiliki klasifikasi yang ketat tentang apa itu gunung, seperti halnya alam tidak memilikinya. Hanya ketinggian absolut yang penting. Bahkan, ketika udara bergerak di atas gunung, ia dipaksa untuk naik, didinginkan dan mungkin mengandung lebih sedikit air, yang mengarah ke presipitasi sebelum udara melewati gunung. Akibatnya, di sisi lain kita mendapat udara kering, yaitu bayangan hujan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang terpenting, semakin tinggi udara naik, semakin sedikit air yang bisa dikandungnya. </font><font style="vertical-align: inherit;">Dalam simulasi kami, kami dapat membayangkan ini sebagai pembatasan paksa dari nilai cloud maksimum untuk setiap sel. </font><font style="vertical-align: inherit;">Semakin tinggi tinggi sel yang terlihat, semakin rendah maksimum ini seharusnya. </font><font style="vertical-align: inherit;">Cara termudah untuk melakukan ini adalah dengan mengatur maksimum ke 1 dikurangi ketinggian yang terlihat, dibagi dengan ketinggian maksimum. </font><font style="vertical-align: inherit;">Tetapi pada kenyataannya, mari kita bagi dengan maksimum minus 1. Ini akan memungkinkan sebagian kecil dari awan untuk tetap melewati bahkan sel-sel tertinggi. </font><font style="vertical-align: inherit;">Kami menetapkan maksimum ini setelah menghitung curah hujan dan sebelum hamburan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika akibatnya kita mendapatkan lebih banyak awan daripada yang dapat diterima, maka kita cukup mengubah awan berlebih menjadi kelembaban. </font><font style="vertical-align: inherit;">Sebenarnya, ini adalah bagaimana kami menambahkan curah hujan tambahan, seperti yang terjadi di pegunungan nyata.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bayangan hujan yang disebabkan oleh ketinggian. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menyelesaikan simulasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kami sudah memiliki simulasi parsial yang sangat tinggi dari siklus air. </font><font style="vertical-align: inherit;">Mari kita susun sedikit, dan kemudian menerapkannya untuk menentukan jenis relief sel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komputasi paralel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti disebutkan sebelumnya di bawah spoiler, urutan pembentukan sel mempengaruhi hasil simulasi. </font><font style="vertical-align: inherit;">Idealnya, ini seharusnya tidak dan pada dasarnya kita membentuk semua sel secara paralel. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menerapkan semua perubahan pada tahap pembentukan saat ini ke daftar iklim kedua </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kosongkan dan inisialisasi daftar ini, seperti yang lainnya. </font><font style="vertical-align: inherit;">Kemudian kami akan bertukar daftar pada setiap siklus. </font><font style="vertical-align: inherit;">Dalam hal ini, simulasi akan menggunakan dua daftar secara bergantian dan menerapkan data iklim saat ini dan selanjutnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika sebuah sel memengaruhi iklim tetangganya, kita harus mengubah data iklim berikut, bukan yang saat ini. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; … nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan alih-alih menyalin data iklim berikut kembali ke daftar iklim saat ini, kami mendapatkan data iklim berikut, menambahkan kelembapan saat ini ke mereka dan menyalinnya ke daftar berikutnya. </font><font style="vertical-align: inherit;">Setelah itu, kami mereset data dalam daftar saat ini sehingga diperbarui untuk siklus berikutnya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sementara kita melakukan ini, mari kita juga mengatur tingkat kelembaban ke maksimum 1 sehingga sel-sel tanah tidak bisa lebih basah daripada di bawah air. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komputasi paralel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber kelembaban </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada kemungkinan bahwa simulasi akan menghasilkan terlalu banyak lahan kering, terutama dengan persentase lahan yang tinggi. </font><font style="vertical-align: inherit;">Untuk meningkatkan gambar, kita dapat menambahkan tingkat kelembaban awal khusus dengan nilai default 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di atas adalah slider dari kelembaban aslinya. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan nilai ini untuk kelembaban dari daftar iklim awal, tetapi tidak untuk yang berikut ini.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan kelembaban asli.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mendefinisikan bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyimpulkan dengan menggunakan kelembaban alih-alih ketinggian untuk menentukan jenis bantuan sel. </font><font style="vertical-align: inherit;">Mari kita gunakan salju untuk tanah yang benar-benar kering, untuk daerah kering kita menggunakan salju, lalu ada batu, rumput untuk cukup lembab, dan tanah untuk sel-sel jenuh air dan bawah air. </font><font style="vertical-align: inherit;">Cara termudah adalah dengan menggunakan lima interval dengan kenaikan 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bioma. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika menggunakan distribusi yang seragam, hasilnya tidak terlalu bagus, dan itu terlihat tidak wajar. </font><font style="vertical-align: inherit;">Lebih baik menggunakan ambang lainnya, misalnya 0,05, 0,12, 0,28 dan 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bioma yang dimodifikasi. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 26: bioma dan sungai </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menciptakan sungai yang berasal dari sel tinggi dengan kelembaban. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuat model suhu sederhana. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menggunakan matriks bioma untuk sel, dan kemudian mengubahnya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini, kami akan melengkapi siklus air dengan sungai dan suhu, serta memberikan bioma yang lebih menarik ke sel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial dibuat menggunakan Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panas dan air meramaikan peta.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generasi sungai </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai adalah konsekuensi dari siklus air. </font><font style="vertical-align: inherit;">Bahkan, mereka terbentuk oleh limpasan yang robek dengan bantuan erosi saluran. </font><font style="vertical-align: inherit;">Ini menyiratkan bahwa Anda dapat menambahkan sungai berdasarkan nilai drainase sel. </font><font style="vertical-align: inherit;">Namun, ini tidak menjamin bahwa kita akan mendapatkan sesuatu yang menyerupai sungai sungguhan. </font><font style="vertical-align: inherit;">Ketika kita memulai sungai, sungai harus mengalir sejauh mungkin, berpotensi melalui banyak sel. </font><font style="vertical-align: inherit;">Ini tidak konsisten dengan simulasi siklus air kami, yang memproses sel secara paralel. </font><font style="vertical-align: inherit;">Selain itu, kontrol atas jumlah sungai pada peta biasanya diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sungai sangat berbeda, kami akan membuatnya secara terpisah. </font><font style="vertical-align: inherit;">Kami menggunakan hasil simulasi siklus air untuk menentukan lokasi sungai, tetapi sungai, pada gilirannya, tidak akan mempengaruhi simulasi.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa aliran sungai terkadang salah?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         («»). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } … }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sel-sel kelembaban tinggi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada peta kami, sel mungkin atau mungkin tidak memiliki sungai. Selain itu, mereka dapat bercabang atau terhubung. Pada kenyataannya, sungai jauh lebih fleksibel, tetapi kita harus bertahan dengan perkiraan ini, yang hanya menciptakan sungai besar. Yang terpenting, kita perlu menentukan lokasi awal sebuah sungai besar, yang dipilih secara acak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sungai membutuhkan air, sumber sungai harus dalam sel dengan kelembaban tinggi. Tetapi ini tidak cukup. Sungai mengalir menuruni lereng, jadi idealnya sumbernya harus memiliki ketinggian yang besar. Semakin tinggi sel di atas permukaan air, semakin baik kandidatnya untuk peran sumber sungai. Kita dapat memvisualisasikan ini sebagai data peta dengan membagi tinggi sel dengan tinggi maksimum. Agar hasilnya diperoleh relatif terhadap ketinggian air, kami akan mengurangkannya dari kedua ketinggian sebelum membaginya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelembaban dan ketinggian. Nomor peta besar 1208905299 dengan pengaturan default.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kandidat terbaik adalah sel-sel yang memiliki kelembaban tinggi dan tinggi. Kami dapat menggabungkan kriteria ini dengan mengalikannya. Hasilnya akan menjadi nilai kebugaran atau berat untuk sumber-sumber sungai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bobot untuk sumber sungai.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealnya, kita akan menggunakan bobot ini untuk menolak pemilihan acak sel sumber. Meskipun kita dapat membuat daftar dengan bobot yang benar dan memilihnya, ini adalah pendekatan non-sepele dan memperlambat proses pembuatan. Klasifikasi signifikansi yang lebih sederhana dibagi menjadi empat tingkatan sudah cukup bagi kita. Kandidat pertama adalah bobot dengan nilai di atas 0,75. Kandidat yang baik memiliki bobot mulai 0,5. Kandidat yang memenuhi syarat lebih besar dari 0,25. Semua sel lainnya dibuang. Mari kita tunjukkan tampilannya secara grafis.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kategori bobot sumber sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan skema klasifikasi ini, kita cenderung mendapatkan sungai dengan sumber di wilayah peta tertinggi dan terbasah. </font><font style="vertical-align: inherit;">Namun demikian, kemungkinan menciptakan sungai di daerah yang relatif kering atau rendah tetap ada, yang meningkatkan variabilitas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengisi daftar sel berdasarkan kriteria ini. </font><font style="vertical-align: inherit;">Sel yang memenuhi syarat ditambahkan ke daftar ini satu kali, sel yang baik dua kali, dan kandidat utama empat kali. </font><font style="vertical-align: inherit;">Sel bawah air selalu dibuang, jadi Anda tidak bisa memeriksanya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini harus dipanggil setelah </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga data kelembaban tersedia untuk kita.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah menyelesaikan klasifikasi, Anda dapat menyingkirkan visualisasi datanya di peta. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poin Sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berapa banyak sungai yang kita butuhkan? </font><font style="vertical-align: inherit;">Parameter ini harus disesuaikan. </font><font style="vertical-align: inherit;">Karena panjang sungai bervariasi, akan lebih logis untuk mengendalikannya dengan bantuan titik-titik sungai, yang menentukan jumlah sel tanah di mana sungai harus terkandung. </font><font style="vertical-align: inherit;">Mari kita ungkapkan sebagai persentase dengan maksimum 20% dan nilai default 10%. </font><font style="vertical-align: inherit;">Seperti persentase sushi, ini adalah nilai target, bukan yang dijamin. </font><font style="vertical-align: inherit;">Akibatnya, kami mungkin memiliki terlalu sedikit kandidat atau sungai yang terlalu pendek untuk menutupi jumlah lahan yang diperlukan. </font><font style="vertical-align: inherit;">Itu sebabnya persentase maksimum tidak boleh terlalu besar.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider persen sungai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menentukan titik sungai, dinyatakan sebagai jumlah sel, kita perlu mengingat berapa banyak sel tanah yang dihasilkan </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalam, </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumlah titik sungai sekarang dapat dihitung dengan cara yang sama seperti yang kita lakukan di </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kami akan terus mengambil dan menghapus sel acak dari daftar asli, sementara kami masih memiliki poin dan sumber sel. </font><font style="vertical-align: inherit;">Dalam hal penyelesaian jumlah poin, kami akan menampilkan peringatan di konsol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kami menambahkan metode untuk membuat sungai secara langsung. </font><font style="vertical-align: inherit;">Sebagai parameter, ia membutuhkan sel awal, dan setelah selesai ia harus mengembalikan panjang sungai. </font><font style="vertical-align: inherit;">Kami mulai dengan menyimpan metode yang mengembalikan panjang nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memanggil metode ini di akhir siklus yang baru saja kami tambahkan </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, gunakan untuk mengurangi jumlah poin yang tersisa. </font><font style="vertical-align: inherit;">Kami memastikan bahwa sungai baru dibuat hanya jika sel yang dipilih tidak memiliki sungai yang mengalir melewatinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai saat ini </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adalah logis untuk membuat sungai yang mengalir ke laut atau badan air lainnya. </font><font style="vertical-align: inherit;">Ketika kita mulai dari sumber, kita segera mendapatkan panjang 1. Setelah itu, kita memilih tetangga acak dan menambah panjangnya. </font><font style="vertical-align: inherit;">Kami terus bergerak hingga mencapai sel bawah air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai acak. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasil dari pendekatan naif seperti itu, kami mendapatkan pecahan sungai yang tersebar secara acak, terutama karena penggantian sungai yang dihasilkan sebelumnya. </font><font style="vertical-align: inherit;">Ini bahkan dapat menyebabkan kesalahan, karena kami tidak memeriksa apakah tetangga benar-benar ada. </font><font style="vertical-align: inherit;">Kita perlu memeriksa semua arah dalam loop dan memastikan bahwa ada tetangga di sana. </font><font style="vertical-align: inherit;">Jika ya, maka kita tambahkan arah ini ke daftar arah aliran potensial, tetapi hanya jika sungai belum mengalir melalui tetangga ini. </font><font style="vertical-align: inherit;">Kemudian pilih nilai acak dari daftar ini.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan pendekatan baru ini, kami mungkin memiliki nol arah aliran yang tersedia. </font><font style="vertical-align: inherit;">Ketika ini terjadi, sungai tidak lagi bisa mengalir lebih jauh dan harus berakhir. </font><font style="vertical-align: inherit;">Jika saat ini panjangnya adalah 1, maka ini berarti kita tidak bisa bocor dari sel aslinya, yaitu tidak ada sungai sama sekali. </font><font style="vertical-align: inherit;">Dalam hal ini, panjang sungai adalah nol.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai yang diawetkan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lari ke bawah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita menyelamatkan sungai yang sudah dibuat, tetapi kita masih bisa mendapatkan fragmen sungai yang terisolasi. </font><font style="vertical-align: inherit;">Ini terjadi karena saat kita mengabaikan ketinggian. </font><font style="vertical-align: inherit;">Setiap kali kami memaksa sungai mengalir ke ketinggian yang lebih besar, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upaya ini terputus, yang menyebabkan pecahnya sungai. </font><font style="vertical-align: inherit;">Karena itu, kita juga perlu melewati arah yang menyebabkan sungai mengalir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai mengalir ke bawah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami menyingkirkan banyak fragmen sungai, tetapi beberapa masih tetap ada. </font><font style="vertical-align: inherit;">Mulai saat ini, menyingkirkan sungai yang paling buruk menjadi masalah penyempurnaan. </font><font style="vertical-align: inherit;">Untuk mulai dengan, sungai lebih suka mengalir turun secepat mungkin. </font><font style="vertical-align: inherit;">Mereka tidak harus memilih rute yang sesingkat mungkin, tetapi kemungkinannya besar. </font><font style="vertical-align: inherit;">Untuk mensimulasikan ini, kami akan menambahkan arah tiga kali ke daftar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari belokan tajam </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain mengalir ke bawah, air juga memiliki kelembaman. </font><font style="vertical-align: inherit;">Sebuah sungai lebih cenderung mengalir lurus atau sedikit bengkok daripada berbelok tajam secara tiba-tiba. </font><font style="vertical-align: inherit;">Kita dapat menambahkan distorsi ini dengan melacak arah terakhir sungai. </font><font style="vertical-align: inherit;">Jika arah potensial saat ini tidak menyimpang terlalu banyak dari arah ini, maka tambahkan ke daftar lagi. </font><font style="vertical-align: inherit;">Ini bukan masalah bagi sumbernya, jadi kami akan selalu menambahkannya lagi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini sangat mengurangi kemungkinan zig-zag sungai yang terlihat jelek. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih sedikit tikungan tajam.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertemuan sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkadang ternyata sungai itu mengalir tepat di sebelah sumber sungai yang sebelumnya dibuat. </font><font style="vertical-align: inherit;">Jika sumber sungai ini tidak pada ketinggian yang lebih tinggi, maka kita dapat memutuskan bahwa sungai baru mengalir ke yang lama. </font><font style="vertical-align: inherit;">Akibatnya, kami mendapatkan satu sungai yang panjang, dan bukan dua yang bersebelahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, kita akan membiarkan tetangga lewat hanya jika ada sungai yang masuk di dalamnya, atau jika itu adalah sumber sungai saat ini. </font><font style="vertical-align: inherit;">Setelah menentukan bahwa arah ini tidak naik, kami memeriksa untuk melihat apakah ada sungai keluar. </font><font style="vertical-align: inherit;">Jika ada, maka kita kembali menemukan sungai tua. </font><font style="vertical-align: inherit;">Karena ini jarang terjadi, kami tidak akan terlibat dalam memeriksa sumber tetangga lainnya dan akan segera menggabungkan sungai.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai sebelum dan sesudah pengumpulan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jaga jarak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kandidat yang baik untuk peran sumber biasanya dikelompokkan bersama, kita akan mendapatkan kelompok sungai. </font><font style="vertical-align: inherit;">Selain itu, kami mungkin memiliki sungai yang mengambil sumber tepat di sebelah waduk, menghasilkan sungai dengan panjang 1. Kami dapat mendistribusikan sumber, membuang yang bersebelahan dengan sungai atau waduk. </font><font style="vertical-align: inherit;">Kami melakukan ini dengan melewati tetangga dari sumber yang dipilih dalam satu lingkaran di dalam </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika kami menemukan tetangga yang melanggar aturan, maka sumbernya tidak cocok untuk kami dan kami harus melewatinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan meskipun sungai masih akan mengalir berdampingan, mereka cenderung menutupi area yang lebih besar. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanpa jarak dan dengan itu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mengakhiri sungai dengan danau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak semua sungai mencapai reservoir, beberapa terjebak di lembah atau tersumbat oleh sungai lain. Ini bukan masalah khusus, karena sering kali sungai sungguhan juga tampaknya menghilang. Ini bisa terjadi, misalnya, jika mereka mengalir di bawah tanah, tersebar di daerah berawa atau mengering. Sungai kami tidak dapat memvisualisasikan ini, jadi mereka berakhir begitu saja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, kami dapat mencoba meminimalkan jumlah kasus tersebut. Meskipun kita tidak dapat menyatukan sungai atau membuatnya mengalir, kita dapat membuatnya berakhir di danau, yang sering ditemukan dalam kenyataan dan terlihat bagus. Untuk ini</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menaikkan level air dalam sel jika macet. </font><font style="vertical-align: inherit;">Kemungkinan ini tergantung pada ketinggian minimum tetangga sel ini. </font><font style="vertical-align: inherit;">Oleh karena itu, untuk melacak ini ketika mempelajari tetangga, diperlukan sedikit perubahan kode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita macet, maka pertama-tama kita perlu memeriksa apakah kita masih di sumbernya. </font><font style="vertical-align: inherit;">Jika ya, maka batalkan saja sungai. </font><font style="vertical-align: inherit;">Jika tidak, kami memeriksa untuk melihat apakah semua tetangga setidaknya setinggi sel saat ini. </font><font style="vertical-align: inherit;">Jika demikian, maka kita dapat menaikkan air ke level ini. </font><font style="vertical-align: inherit;">Ini akan membuat danau dari satu sel, kecuali tinggi sel tetap pada level yang sama. </font><font style="vertical-align: inherit;">Jika demikian, maka cukup tetapkan ketinggian satu tingkat di bawah permukaan air.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ujung-ujung sungai tanpa danau dan danau. </font><font style="vertical-align: inherit;">Dalam hal ini, persentase sungai adalah 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhatikan bahwa sekarang kita mungkin memiliki sel bawah air di atas level air yang digunakan untuk menghasilkan peta. </font><font style="vertical-align: inherit;">Mereka akan menunjukkan danau di atas permukaan laut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Danau tambahan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga dapat membuat danau, bahkan jika kami tidak terjebak. </font><font style="vertical-align: inherit;">Ini dapat menyebabkan sungai mengalir masuk dan keluar dari danau. </font><font style="vertical-align: inherit;">Jika kita tidak terjebak, maka danau dapat dibuat dengan menaikkan level air lalu ketinggian sel saat ini, dan kemudian mengurangi tinggi sel. </font><font style="vertical-align: inherit;">Ini hanya berlaku ketika ketinggian minimum tetangga setidaknya sama dengan tinggi sel saat ini. </font><font style="vertical-align: inherit;">Kami melakukan ini di akhir siklus sungai dan sebelum pindah ke sel berikutnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanpa danau tambahan dan bersama mereka. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa danau indah, tetapi tanpa batas kita dapat membuat terlalu banyak danau. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita tambahkan probabilitas khusus untuk danau tambahan, dengan nilai default 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dia akan mengendalikan kemungkinan menghasilkan danau tambahan, jika memungkinkan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danau tambahan.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan membuat danau dengan lebih dari satu sel?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2>  Suhu </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air hanyalah salah satu faktor yang dapat menentukan bioma suatu sel. </font><font style="vertical-align: inherit;">Faktor penting lainnya adalah suhu. </font><font style="vertical-align: inherit;">Meskipun kita dapat mensimulasikan aliran dan difusi suhu seperti mensimulasikan air, untuk menciptakan iklim yang menarik, kita hanya perlu satu faktor kompleks. </font><font style="vertical-align: inherit;">Karena itu, mari kita menjaga suhu tetap sederhana dan mengaturnya untuk setiap sel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suhu dan garis lintang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaruh terbesar pada suhu adalah garis lintang. </font><font style="vertical-align: inherit;">Panas di khatulistiwa, dingin di kutub, dan ada transisi yang mulus di antara mereka. </font><font style="vertical-align: inherit;">Mari kita membuat metode </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan suhu sel yang diberikan. </font><font style="vertical-align: inherit;">Untuk memulai, kita cukup menggunakan koordinat Z sel dibagi dengan dimensi Z sebagai garis lintang, dan kemudian menggunakan nilai ini sebagai suhu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendefinisikan suhu </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menggunakannya sebagai data peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lintang sebagai suhu, belahan bumi selatan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapatkan peningkatan suhu linear dari bawah ke atas. </font><font style="vertical-align: inherit;">Anda dapat menggunakannya untuk mensimulasikan belahan bumi selatan, dengan kutub di bagian bawah dan khatulistiwa di bagian atas. </font><font style="vertical-align: inherit;">Tetapi kita tidak perlu menggambarkan seluruh belahan bumi. </font><font style="vertical-align: inherit;">Dengan perbedaan suhu yang lebih kecil atau tidak ada perbedaan sama sekali, kita dapat menggambarkan area yang lebih kecil. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami akan membuat suhu rendah dan tinggi dapat disesuaikan. </font><font style="vertical-align: inherit;">Kami akan mengatur suhu ini dalam kisaran 0-1, dan menggunakan nilai ekstrem sebagai nilai default.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggeser suhu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menerapkan rentang suhu menggunakan interpolasi linier, menggunakan garis lintang sebagai interpolator. </font><font style="vertical-align: inherit;">Karena kita menyatakan garis lintang sebagai nilai dari 0 hingga 1, kita dapat menggunakannya </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa suhu rendah tidak selalu lebih rendah dari tinggi. </font><font style="vertical-align: inherit;">Jika diinginkan, Anda dapat mengubahnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Belahan bumi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa mensimulasikan belahan bumi selatan, dan mungkin belahan utara, jika kita mengukur suhu terlebih dahulu. </font><font style="vertical-align: inherit;">Tetapi jauh lebih nyaman untuk menggunakan opsi konfigurasi terpisah untuk beralih antar belahan. </font><font style="vertical-align: inherit;">Mari kita membuat enumerasi dan bidang untuk itu. </font><font style="vertical-align: inherit;">Jadi, kami juga akan menambahkan opsi untuk membuat kedua belahan otak, yang berlaku secara default.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan belahan bumi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita membutuhkan belahan bumi utara, maka kita cukup membalik garis lintang, mengurangi dari 1. Untuk mensimulasikan kedua belahan bumi, kutubnya harus di bawah dan di atas peta, dan garis khatulistiwa harus di tengah. </font><font style="vertical-align: inherit;">Anda dapat melakukan ini dengan menggandakan garis lintang, sementara belahan bumi bawah akan diproses dengan benar, dan belahan bumi bagian atas akan memiliki garis lintang 1 hingga 2. Untuk memperbaikinya, kami kurangi garis lintang dari 2 saat melebihi 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua belahan otak. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa ini menciptakan kemungkinan menciptakan peta eksotis di mana khatulistiwa dingin dan kutubnya hangat.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semakin tinggi dinginnya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain garis lintang, suhu juga sangat dipengaruhi oleh ketinggian. </font><font style="vertical-align: inherit;">Rata-rata, semakin tinggi kita memanjat, semakin dingin. </font><font style="vertical-align: inherit;">Kita bisa mengubah ini menjadi faktor, seperti yang kita lakukan pada kandidat sungai. </font><font style="vertical-align: inherit;">Dalam hal ini, kami menggunakan tinggi sel. </font><font style="vertical-align: inherit;">Selain itu, indikator ini berkurang dengan ketinggian, yaitu, sama dengan 1 minus tinggi dibagi dengan maksimum relatif terhadap ketinggian air. </font><font style="vertical-align: inherit;">Agar indikator di level tertinggi tidak jatuh ke nol, kami menambah pembagi. </font><font style="vertical-align: inherit;">Kemudian gunakan indikator ini untuk mengukur suhu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinggi mempengaruhi suhu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluktuasi suhu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat membuat kesederhanaan gradien suhu kurang terlihat dengan menambahkan fluktuasi suhu acak. </font><font style="vertical-align: inherit;">Peluang kecil untuk membuatnya lebih realistis, tetapi dengan terlalu banyak fluktuasi, mereka akan terlihat sewenang-wenang. </font><font style="vertical-align: inherit;">Mari kita membuat kekuatan fluktuasi suhu dapat disesuaikan dan menyatakannya sebagai penyimpangan suhu maksimum dengan nilai default 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider fluktuasi suhu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluktuasi seperti itu harus lancar dengan sedikit perubahan lokal. </font><font style="vertical-align: inherit;">Anda dapat menggunakan tekstur derau kami untuk ini. </font><font style="vertical-align: inherit;">Kami akan memanggil </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menggunakan sebagai argumen posisi sel, diskalakan dengan 0,1. </font><font style="vertical-align: inherit;">Mari kita ambil saluran W, pusatkan dan skala dengan koefisien osilasi. </font><font style="vertical-align: inherit;">Kemudian kami menambahkan nilai ini ke suhu yang dihitung sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluktuasi suhu dengan nilai 0,1 dan 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita dapat menambahkan sedikit variabilitas pada fluktuasi pada setiap peta, memilih secara acak dari empat saluran kebisingan. </font><font style="vertical-align: inherit;">Atur saluran sekali dalam </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lalu indeks saluran warna di </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluktuasi suhu berbeda dengan gaya maksimum. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bioma </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki data tentang kelembaban dan suhu, kita dapat membuat matriks bioma. </font><font style="vertical-align: inherit;">Dengan mengindeks matriks ini, kita dapat menetapkan bioma ke semua sel, menciptakan lanskap yang lebih kompleks daripada hanya menggunakan satu dimensi data.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriks bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak model iklim, tetapi kami tidak akan menggunakannya. Kami akan membuatnya sangat sederhana, kami hanya tertarik pada logika. Kering berarti gurun (dingin atau panas), untuk itu kami menggunakan pasir. Dingin dan basah berarti salju. Panas dan lembab berarti banyak tumbuh-tumbuhan, yaitu rumput. Di antara mereka kita akan memiliki taiga atau tundra, yang akan kita sebut sebagai tekstur bumi yang keabu-abuan. Matriks 4 × 4 akan cukup untuk membuat transisi di antara bioma-bioma ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, kami menetapkan tipe ketinggian berdasarkan pada lima interval kelembaban. Kami cukup menurunkan strip terkering ke 0,05, dan menyimpan sisanya. Untuk pita suhu kami menggunakan 0,1, 0,3, 0,6 dan lebih tinggi. Untuk kenyamanan, kami akan menetapkan nilai-nilai ini dalam array statis.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami hanya menentukan jenis bantuan berdasarkan bioma, kami dapat menggunakannya untuk menentukan parameter lainnya. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita definisikan dalam </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struktur </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menggambarkan konfigurasi bioma individu. </font><font style="vertical-align: inherit;">Sejauh ini, hanya berisi indeks bump plus metode konstruktor yang sesuai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan struktur ini untuk membuat array statis yang berisi data matriks. </font><font style="vertical-align: inherit;">Kami menggunakan kelembaban sebagai koordinat X, dan suhu sebagai Y. Kami mengisi garis dengan suhu terendah dengan salju, baris kedua dengan tundra, dan dua lainnya dengan rumput. </font><font style="vertical-align: inherit;">Lalu kami mengganti kolom paling kering dengan padang pasir, mendefinisikan kembali pilihan suhu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriks bioma dengan indeks array satu dimensi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definisi bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menentukan </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sel </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">sel </font><font style="vertical-align: inherit;">dalam </font><font style="vertical-align: inherit;">bioma, kita berkeliling kisaran suhu dan kelembaban dalam siklus untuk menentukan indeks matriks yang kita butuhkan. </font><font style="vertical-align: inherit;">Kami menggunakannya untuk mendapatkan bioma yang diinginkan dan menentukan jenis topografi sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // … // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief berdasarkan matriks bioma.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengaturan bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita bisa melampaui bioma yang didefinisikan dalam matriks. Sebagai contoh, dalam matriks, semua bioma kering didefinisikan sebagai gurun pasir, tetapi tidak semua gurun kering diisi dengan pasir. Ada banyak gurun berbatu yang terlihat sangat berbeda. Karena itu, mari kita ganti beberapa sel gurun dengan batu. Kami akan melakukan ini hanya berdasarkan ketinggian: pasir berada di ketinggian rendah, dan bebatuan telanjang biasanya ditemukan di atas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan pasir berubah menjadi batu ketika ketinggian sel lebih dekat dengan ketinggian maksimum daripada ketinggian air. Ini adalah garis ketinggian gurun berbatu yang bisa kita hitung di awal </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ketika kami bertemu sel dengan pasir, dan tingginya cukup besar, kami mengubah relief bioma menjadi batu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gurun berpasir dan berbatu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan lain berdasarkan ketinggian adalah untuk memaksa sel pada ketinggian maksimum untuk berubah menjadi puncak salju, terlepas dari suhu mereka, hanya jika mereka tidak terlalu kering. </font><font style="vertical-align: inherit;">Ini akan meningkatkan kemungkinan puncak salju di dekat khatulistiwa yang panas dan lembab.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutup salju pada ketinggian maksimum.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanaman </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita membuat bioma menentukan tingkat sel tanaman. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan ke </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang tanaman dan sertakan dalam konstruktor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bioma terdingin dan terkering tidak akan ada tanaman sama sekali. </font><font style="vertical-align: inherit;">Dalam semua hal lain, semakin hangat dan basah iklim, semakin banyak tanaman. </font><font style="vertical-align: inherit;">Kolom kedua dari kelembaban hanya menerima tanaman tingkat pertama untuk baris terpanas, oleh karena itu [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">Kolom ketiga meningkatkan level satu per satu, dengan pengecualian salju, yaitu, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Dan kolom terbasah menambahnya lagi, yaitu, ternyata [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Ubah array </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan menambahkan konfigurasi instalasi ke dalamnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriks bioma dengan tingkat tanaman. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengatur tingkat tanaman untuk sel.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bioma dengan tanaman.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah tanaman sekarang terlihat berbeda?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    — (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat mengubah tingkat tanaman untuk bioma. </font><font style="vertical-align: inherit;">Pertama-tama kita perlu memastikan bahwa mereka tidak muncul di medan bersalju, yang sudah bisa kita atur. </font><font style="vertical-align: inherit;">Kedua, mari tingkatkan tanaman di sepanjang sungai, jika belum maksimal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanaman yang dimodifikasi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bioma bawah air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai saat itu, kami sepenuhnya mengabaikan sel-sel bawah air. </font><font style="vertical-align: inherit;">Mari kita tambahkan sedikit variasi pada mereka, dan kita tidak akan menggunakan tekstur bumi untuk semuanya. </font><font style="vertical-align: inherit;">Solusi sederhana berdasarkan ketinggian sudah cukup untuk membuat gambar yang lebih menarik. </font><font style="vertical-align: inherit;">Sebagai contoh, mari kita gunakan rumput untuk sel satu langkah di bawah permukaan air. </font><font style="vertical-align: inherit;">Mari kita juga menggunakan rumput untuk sel di atas permukaan air, yaitu untuk danau yang dibuat oleh sungai. </font><font style="vertical-align: inherit;">Sel dengan ketinggian negatif adalah wilayah laut dalam, jadi kami menggunakan batu untuknya. </font><font style="vertical-align: inherit;">Semua sel lainnya tetap dihaluskan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilitas bawah air.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita tambahkan beberapa detail lagi untuk sel-sel bawah laut di sepanjang pantai. Ini adalah sel dengan setidaknya satu tetangga di atas air. Jika sel seperti itu dangkal, maka kita akan membuat pantai. Dan jika di sebelah tebing, maka itu akan menjadi detail visual yang dominan, dan kami menggunakan batu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menentukan ini, kami akan memeriksa tetangga sel yang terletak satu langkah di bawah permukaan air. Mari kita hitung jumlah koneksi dengan tebing dan lereng dengan sel-sel tanah tetangga.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menggunakan informasi ini untuk mengklasifikasikan sel. </font><font style="vertical-align: inherit;">Pertama, jika lebih dari setengah tetangga adalah tanah, maka kita berurusan dengan danau atau teluk. </font><font style="vertical-align: inherit;">Untuk sel-sel ini kami menggunakan tekstur rumput. </font><font style="vertical-align: inherit;">Kalau tidak, jika kita memiliki tebing, maka kita menggunakan batu. </font><font style="vertical-align: inherit;">Kalau tidak, jika kita memiliki lereng, maka kita menggunakan pasir untuk membuat pantai. </font><font style="vertical-align: inherit;">Satu-satunya pilihan yang tersisa adalah area dangkal di lepas pantai, di mana kami masih menggunakan rumput.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilitas pantai. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai sentuhan terakhir, mari kita periksa bahwa kita tidak memiliki sel bawah air hijau dalam kisaran suhu terdingin. </font><font style="vertical-align: inherit;">Untuk sel seperti itu kita menggunakan bumi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapat kesempatan untuk membuat kartu acak yang terlihat cukup menarik dan alami, dengan banyak opsi konfigurasi. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 27: melipat kartu </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membagi kartu menjadi kolom yang dapat dipindahkan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pusatkan kartu di kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menghancurkan segalanya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian terakhir ini, kami akan menambahkan dukungan untuk meminimalkan peta, menghubungkan tepi timur dan barat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial dibuat menggunakan Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lipat membuat dunia berputar.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartu lipat </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta kami dapat digunakan untuk memodelkan area dengan ukuran berbeda, tetapi mereka selalu terbatas pada bentuk persegi panjang. Kita dapat membuat peta dari satu pulau atau seluruh benua, tetapi tidak seluruh planet. Planet-planet itu bulat, tidak memiliki batas kaku yang menghambat gerakan di permukaannya. Jika Anda terus bergerak dalam satu arah, maka cepat atau lambat Anda akan kembali ke titik awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak bisa membungkus kisi segi enam di sekitar bola, tumpang tindih seperti itu tidak mungkin. Dalam perkiraan terbaik, topologi icosahedral digunakan, di mana kedua belas sel harus pentagon. Namun, tanpa distorsi atau pengecualian, mesh dapat melilitkan silinder. Untuk melakukan ini, cukup sambungkan tepi timur dan barat peta. Dengan pengecualian dari logika pembungkus, semua yang lain tetap sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silinder adalah pendekatan bulatan yang buruk, karena kita tidak dapat memodelkan kutub. </font><font style="vertical-align: inherit;">Tapi ini tidak menghentikan para pengembang banyak game menggunakan lipatan timur ke barat untuk memodelkan peta planet. </font><font style="vertical-align: inherit;">Wilayah kutub sama sekali bukan bagian dari zona permainan.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kalau berbelok ke utara dan selatan?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua cara untuk menerapkan lipat silindris. </font><font style="vertical-align: inherit;">Yang pertama adalah untuk benar-benar membuat peta silindris dengan menekuk permukaannya dan semua yang ada di atasnya sehingga ujung timur dan barat bersentuhan. </font><font style="vertical-align: inherit;">Sekarang Anda akan bermain bukan pada permukaan datar, tetapi pada silinder nyata. </font><font style="vertical-align: inherit;">Pendekatan kedua adalah menyimpan peta datar dan menggunakan teleportasi atau duplikasi untuk runtuh. </font><font style="vertical-align: inherit;">Sebagian besar game menggunakan pendekatan kedua, jadi kami akan menerimanya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lipat opsional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebutuhan untuk menutup peta tergantung pada skalanya - lokal atau planet. </font><font style="vertical-align: inherit;">Kita dapat menggunakan dukungan keduanya dengan membuat lipat opsional. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan </font><font style="vertical-align: inherit;">saklar baru ke menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan keruntuhan diaktifkan secara default.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu peta baru dengan opsi untuk runtuh. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang untuk melacak seleksi, serta metode untuk mengubahnya. </font><font style="vertical-align: inherit;">Mari kita membuat metode ini dipanggil ketika keadaan saklar berubah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat peta baru diminta, kami meneruskan nilai opsi perkecil. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menerima argumen baru ini dan kemudian meneruskannya ke </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … grid.CreateMap(x, z, wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode&gt; HexGrid harus tahu jika kita runtuh, jadi tambahkan bidang dan </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setel. </font><font style="vertical-align: inherit;">Kelas-kelas lain harus mengubah logika mereka tergantung pada apakah grid diminimalkan, jadi kami akan membuat bidang umum. </font><font style="vertical-align: inherit;">Selain itu, ini memungkinkan Anda untuk menetapkan nilai default melalui inspektur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; … }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan sendiri </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di dua tempat. </font><font style="vertical-align: inherit;">Kita bisa menggunakan bidangnya sendiri untuk argumen runtuh.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateMap(cellCountX, cellCountZ, wrapping); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sakelar lipat kisi dinyalakan secara default.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan dan memuat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena lipat diatur untuk setiap kartu, maka harus disimpan dan dimuat. </font><font style="vertical-align: inherit;">Ini berarti Anda perlu mengubah format penyimpanan file, jadi tambah konstanta versi </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menyimpan, biarkan </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menuliskan nilai lipat boolean setelah ukuran peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memuat, kami hanya akan membacanya dengan versi file yang benar. </font><font style="vertical-align: inherit;">Jika berbeda, maka ini adalah kartu lama dan tidak boleh diminimalisir. </font><font style="vertical-align: inherit;">Simpan informasi ini dalam variabel lokal dan bandingkan dengan keadaan lipatan saat ini. </font><font style="vertical-align: inherit;">Jika berbeda, maka kita tidak dapat menggunakan kembali topologi peta yang ada dengan cara yang sama seperti ketika memuat peta dengan ukuran lain.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metrik Lipat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meminimalkan peta akan membutuhkan perubahan besar dalam logika, misalnya saat menghitung jarak. </font><font style="vertical-align: inherit;">Oleh karena itu, mereka dapat menyentuh kode yang tidak memiliki tautan langsung ke kisi. </font><font style="vertical-align: inherit;">Alih-alih meneruskan informasi ini sebagai argumen, mari tambahkan saja </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambahkan bilangan bulat statis yang berisi ukuran lipat yang cocok dengan lebar peta. </font><font style="vertical-align: inherit;">Jika lebih besar dari nol, maka kita berurusan dengan kartu yang dapat dilipat. </font><font style="vertical-align: inherit;">Untuk memverifikasi ini, tambahkan properti.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu mengatur ukuran lipat untuk setiap panggilan </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena data ini tidak akan selamat dari kompilasi ulang dalam mode Play, kami akan memasangnya </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebar sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika bekerja dengan kartu yang dapat dilipat, kita sering harus berurusan dengan posisi di sepanjang sumbu X, diukur dalam lebar sel. </font><font style="vertical-align: inherit;">Meskipun dapat digunakan untuk ini </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, akan lebih nyaman jika kita tidak menambahkan perkalian setiap saat. </font><font style="vertical-align: inherit;">Jadi mari kita tambahkan konstanta </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita sudah bisa menggunakan diameter di tiga tempat. </font><font style="vertical-align: inherit;">Pertama, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat memposisikan sel baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membatasi posisi kamera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan juga dalam </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konversi dari posisi ke koordinat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemusatan kartu </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika peta tidak runtuh, ia telah dengan jelas mendefinisikan tepi timur dan barat, dan karenanya merupakan pusat horizontal yang jelas. </font><font style="vertical-align: inherit;">Tetapi dalam kasus kartu yang dapat dilipat, semuanya berbeda. </font><font style="vertical-align: inherit;">Tidak memiliki tepi timur atau barat, atau pusat. </font><font style="vertical-align: inherit;">Sebagai alternatif, kita dapat mengasumsikan bahwa pusat adalah tempat kamera berada. </font><font style="vertical-align: inherit;">Ini akan berguna karena kami ingin peta selalu berpusat pada sudut pandang kami. </font><font style="vertical-align: inherit;">Lalu, di mana pun kita berada, kita tidak akan melihat tepi peta bagian timur atau barat.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kolom Fragmen Peta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar visualisasi peta terpusat relatif ke kamera, kita perlu mengubah penempatan elemen tergantung pada pergerakan kamera. Jika bergerak ke barat, maka kita perlu mengambil apa yang ada di tepi bagian timur dan memindahkannya ke tepi bagian barat. Hal yang sama berlaku untuk arah yang berlawanan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealnya, begitu kamera bergerak ke kolom sel tetangga, kita harus segera memindahkan kolom sel terjauh ke sisi lain. Namun, kita tidak perlu begitu tepat. Sebagai gantinya, kami dapat mentransfer seluruh fragmen peta. Ini memungkinkan kita untuk memindahkan bagian-bagian peta tanpa harus memodifikasi jerat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami memindahkan seluruh kolom fragmen pada saat yang bersamaan, mari kelompokkan mereka dengan membuat objek kolom induk untuk setiap grup. </font><font style="vertical-align: inherit;">Tambahkan array untuk objek-objek ini </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kami akan menginisialisasi </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami hanya akan menggunakannya sebagai wadah, jadi kami hanya perlu melacak tautan ke komponennya </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti dalam kasus fragmen, posisi awal mereka terletak di titik asal koordinat kotak.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang fragmen harus menjadi anak dari kolom yang sesuai, bukan kotak. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen dikelompokkan ke dalam kolom. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua fragmen sekarang menjadi anak-anak kolom, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu sudah cukup </font><font style="vertical-align: inherit;">bagi </font><font style="vertical-align: inherit;">kita untuk menghancurkan semua kolom secara langsung, bukan fragmen. </font><font style="vertical-align: inherit;">Jadi kita akan menyingkirkan fragmen putri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teleport Columns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode baru </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan posisi X sebagai parameter. </font><font style="vertical-align: inherit;">Konversi posisi ke indeks kolom, membaginya dengan lebar fragmen dalam unit Unity. </font><font style="vertical-align: inherit;">Ini akan menjadi indeks kolom di mana kamera saat ini berada, yaitu, itu akan menjadi kolom tengah peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cukup bagi kita untuk mengubah visualisasi peta hanya ketika indeks kolom pusat berubah. </font><font style="vertical-align: inherit;">Jadi mari kita lacak di lapangan. </font><font style="vertical-align: inherit;">Kami menggunakan nilai default −1 saat membuat peta sehingga peta baru selalu terpusat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita tahu indeks kolom pusat, kita dapat menentukan indeks minimum dan maksimum hanya dengan mengurangi dan menambahkan setengah jumlah kolom. Karena kami menggunakan nilai integer, dengan jumlah kolom ganjil, ini berfungsi dengan baik. Dalam kasus bilangan genap, tidak mungkin ada kolom yang berpusat sempurna, sehingga salah satu indeks akan selangkah lebih maju dari yang diperlukan. Ini menciptakan offset satu kolom ke arah tepi terjauh peta, tetapi bagi kami ini bukan masalah.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa indeks ini mungkin negatif atau lebih besar dari indeks kolom maksimum alami. </font><font style="vertical-align: inherit;">Minimum adalah nol hanya ketika kamera berada di dekat pusat alami peta. </font><font style="vertical-align: inherit;">Tugas kita adalah memindahkan kolom sehingga sesuai dengan indeks relatif ini. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan mengubah koordinat X lokal dari setiap kolom dalam loop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap kolom, kami memeriksa apakah indeks indeks minimum kurang. </font><font style="vertical-align: inherit;">Jika demikian, maka itu terlalu jauh di sebelah kiri pusat. </font><font style="vertical-align: inherit;">Dia harus berteleportasi ke sisi lain peta. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan membuat koordinat X-nya sama dengan lebar peta. </font><font style="vertical-align: inherit;">Demikian pula, jika indeks kolom lebih besar dari indeks maksimum, maka itu terlalu jauh ke kanan tengah, dan harus teleport ke sisi lain.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamera bergerak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga saat bekerja dengan kartu yang dapat dilipat, ia malah </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menelepon </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertama, buat saja metode baru itu </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplikat </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi dengan satu-satunya perbedaan: pada akhirnya, ia akan memanggil </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } … <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar kartu langsung terpusat, kami memanggil </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergerak ke kiri dan ke kanan saat memusatkan pada kamera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami masih membatasi pergerakan kamera, peta sekarang mencoba memusatkan relatif ke kamera, memindahkan kolom-kolom fragmen peta jika perlu. </font><font style="vertical-align: inherit;">Dengan peta kecil dan kamera jarak jauh, ini terlihat jelas, tetapi pada peta besar, fragmen yang diteleportasi berada di luar rentang tampilan kamera. </font><font style="vertical-align: inherit;">Jelas, hanya tepi awal timur dan barat peta yang terlihat, karena belum ada triangulasi di antara mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meruntuhkan kamera, kami menghapus batasan koordinat X-nya </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai gantinya, kami akan terus meningkatkan koordinat X dengan lebar peta saat itu di bawah nol, dan menguranginya saat itu lebih besar dari lebar peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera roll-up bergerak di sepanjang peta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tekstur Shader yang Dapat Dilipat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan pengecualian ruang triangulasi, meminimalkan kamera dalam mode permainan seharusnya tidak terlihat. Namun, ketika ini terjadi, perubahan visual terjadi di setengah dari topografi dan air. Ini terjadi karena kami menggunakan posisi di dunia untuk mencicipi tekstur ini. Teleportasi fragmen yang tajam mengubah lokasi tekstur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita bisa menyelesaikan masalah ini dengan membuat tekstur muncul di ubin yang kelipatan dari ukuran fragmen. Ukuran fragmen dihitung dari konstanta di </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi mari kita membuat shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> termasuk file </font><font style="vertical-align: inherit;">dan tempel definisi yang sesuai ke dalamnya. Skala ubin dasar dihitung dari ukuran fragmen dan jari-jari luar sel. Jika Anda menggunakan metrik lain, Anda harus memodifikasi file yang sesuai.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memberi kami skala ubin 0,00866025404. </font><font style="vertical-align: inherit;">Jika kita menggunakan kelipatan integer dari nilai ini, maka tekstur tidak akan terpengaruh oleh teleportasi fragmen. </font><font style="vertical-align: inherit;">Selain itu, tekstur di tepi timur dan barat peta akan bergabung dengan mulus setelah kami melakukan triangulasi koneksi dengan benar. </font><font style="vertical-align: inherit;">Kami menggunakan 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai skala UV di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai gantinya, kita bisa menggunakan skala ubin berlipat ganda, yaitu 0,01732050808. </font><font style="vertical-align: inherit;">Skala diperoleh sedikit kurang dari itu, dan skala tekstur telah meningkat sedikit, tetapi secara visual tidak terlihat.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk noise UV, kami menggunakan skala 0,025. </font><font style="vertical-align: inherit;">Sebagai gantinya, Anda dapat menggunakan skala ubin tiga lapis. </font><font style="vertical-align: inherit;">Ini memberi kita 0,02598076212, yang cukup dekat.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami menggunakan 0,015 untuk busa dan 0,025 untuk gelombang. </font><font style="vertical-align: inherit;">Di sini kita dapat kembali mengganti nilai-nilai ini dengan skala ubin berlipat ganda dan tiga kali lipat.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); … } … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persatuan timur dan barat </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, satu-satunya bukti visual untuk meminimalkan peta adalah celah kecil antara kolom paling timur dan paling barat. </font><font style="vertical-align: inherit;">Kesenjangan ini terjadi karena kami belum melakukan triangulasi hubungan tepi dan sudut antara sel-sel di sisi yang berlawanan dari peta tanpa melipat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruang di tepi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melipat tetangga </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan triangulasi pada koneksi timur-barat, kita perlu membuat sel-sel yang bersebelahan bersebelahan. </font><font style="vertical-align: inherit;">Sejauh ini kami tidak melakukan ini, karena </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">koneksi E - W dibuat dengan sel sebelumnya hanya jika indeksnya di X lebih besar dari nol. </font><font style="vertical-align: inherit;">Untuk menutup koneksi ini, kita perlu menghubungkan sel terakhir dari baris dengan sel pertama di baris yang sama saat melipat peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah membangun koneksi tetangga E - W, kami memperoleh triangulasi sebagian dari celah tersebut. </font><font style="vertical-align: inherit;">Sambungan tepi tidak ideal, karena distorsi disembunyikan secara tidak benar. </font><font style="vertical-align: inherit;">Kami akan mengatasinya nanti.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senyawa E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga harus menutup tautan NE - SW. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menghubungkan sel pertama dari setiap baris genap dengan sel terakhir dari baris sebelumnya. </font><font style="vertical-align: inherit;">Itu hanya sel yang sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi NE - SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, koneksi SE - NW dibuat pada akhir setiap garis ganjil di bawah yang pertama. </font><font style="vertical-align: inherit;">Sel-sel ini harus terhubung ke sel pertama dari baris sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senyawa SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lipat kebisingan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyembunyikan celah dengan sempurna, kita perlu memastikan bahwa tepi timur dan barat peta cocok dengan kebisingan yang digunakan dengan sempurna untuk mendistorsi posisi simpul. </font><font style="vertical-align: inherit;">Kita dapat menggunakan trik yang sama yang digunakan untuk shader, tetapi skala kebisingan 0,003 digunakan untuk distorsi. </font><font style="vertical-align: inherit;">Untuk memastikan ubin, Anda perlu meningkatkan skala secara signifikan, yang akan menyebabkan distorsi yang lebih kacau dari simpul. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi alternatif bukan untuk mengatasi kebisingan, tetapi untuk membuat pelemahan halus pada bagian tepi peta. </font><font style="vertical-align: inherit;">Jika Anda melakukan pelemahan halus di sepanjang lebar satu sel, maka distorsi akan membuat transisi yang mulus tanpa celah. </font><font style="vertical-align: inherit;">Kebisingan di daerah ini akan sedikit dihaluskan, dan dari jarak jauh perubahan akan tampak tajam, tetapi ini tidak begitu jelas ketika menggunakan sedikit distorsi dari simpul.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan fluktuasi suhu?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita tidak menutup kartu, maka kita dapat bertahan dengan </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu sampel. </font><font style="vertical-align: inherit;">Tetapi ketika melipat perlu menambahkan atenuasi. </font><font style="vertical-align: inherit;">Oleh karena itu, sebelum mengembalikan sampel, simpan dalam variabel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat meminimalkan, kita perlu mencampur dengan sampel kedua. </font><font style="vertical-align: inherit;">Kami akan melakukan transisi di bagian timur peta, sehingga sampel kedua harus dipindahkan ke barat.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redaman dilakukan dengan menggunakan interpolasi linier sederhana dari bagian barat ke bagian timur, melebihi lebar satu sel. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencampuran kebisingan, solusi yang tidak sempurna.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akibatnya, kami tidak mendapatkan kecocokan yang tepat, karena beberapa sel di sisi timur memiliki koordinat X negatif. Agar tidak mendekati area ini, mari kita pindahkan wilayah transisi ke barat setengah dari lebar sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenuasi yang benar.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengeditan Sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang triangulasi tampaknya benar, mari kita pastikan bahwa kita dapat mengedit semua yang ada di peta dan pada lipatan lipatan. Ternyata, dalam fragmen teleportasi, koordinatnya salah dan sikat besar dipotong oleh sebuah jahitan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuas dipangkas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk mengatasinya, kita perlu melaporkan </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lipatan. Kita dapat melakukan ini dengan mencocokkan koordinat X dalam metode konstruktor. Kita tahu bahwa koordinat aksial X diperoleh dari koordinat X offset dengan mengurangi setengah dari koordinat Z. Anda dapat menggunakan informasi ini untuk melakukan transformasi terbalik dan memeriksa apakah koordinat nol kurang dari nol. Jika demikian, maka kita memiliki koordinat di luar sisi timur peta yang terbuka. Karena di setiap arah yang kita teleport tidak lebih dari setengah peta, itu akan cukup bagi kita untuk menambahkan ukuran lipat ke X satu kali. Dan ketika koordinat offset lebih besar dari ukuran lipat, kita perlu melakukan pengurangan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kadang-kadang ketika mengedit bagian bawah atau atas peta saya mendapat kesalahan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini terjadi ketika, karena distorsi titik, kursor muncul di baris sel di luar peta. </font><font style="vertical-align: inherit;">Ini adalah bug yang terjadi karena kami tidak mencocokkan koordinat </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter vektor. </font><font style="vertical-align: inherit;">Ini dapat diperbaiki dengan menerapkan metode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan koordinat sebagai parameter yang akan melakukan pemeriksaan yang diperlukan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesisir lipat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulasi bekerja dengan baik untuk medan, tetapi sepanjang lapisan timur-barat tidak ada tepi pantai air. </font><font style="vertical-align: inherit;">Bahkan, mereka, mereka tidak runtuh. </font><font style="vertical-align: inherit;">Mereka dibalik dan direntangkan ke sisi lain peta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepi air tidak ada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini terjadi, karena ketika melakukan triangulasi air pantai, kami menggunakan posisi tetangga. </font><font style="vertical-align: inherit;">Untuk memperbaikinya, kita perlu menentukan apa yang kita hadapi, terletak di sisi lain kartu. </font><font style="vertical-align: inherit;">Untuk menyederhanakan tugas, kami akan menambahkan </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kolom sel </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">properti untuk indeks.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapkan indeks ini ke </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini sama dengan koordinat offset X dibagi dengan ukuran fragmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menentukan apa yang diminimalkan dengan membandingkan indeks kolom sel saat ini dan tetangganya. </font><font style="vertical-align: inherit;">Jika indeks kolom tetangga kurang dari satu langkah lebih sedikit, maka kita berada di sisi barat, dan tetangga di sisi timur. </font><font style="vertical-align: inherit;">Karena itu, kita perlu mengubah tetangga kita ke barat. </font><font style="vertical-align: inherit;">Sama dan berlawanan arah.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iga pantai, tapi tidak ada sudut. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami merawat tulang rusuk pantai, tetapi sejauh ini tidak berurusan dengan sudut. </font><font style="vertical-align: inherit;">Kita perlu melakukan hal yang sama dengan tetangga berikutnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pantai yang dibatasi dengan benar.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembuatan kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan untuk menghubungkan sisi timur dan barat mempengaruhi pembuatan peta. </font><font style="vertical-align: inherit;">Saat meminimalkan peta, algoritme pembangkitan juga harus diminimalkan. </font><font style="vertical-align: inherit;">Ini akan mengarah pada pembuatan peta lain, tetapi saat menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map Border X yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak nol </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> pelipatan tidak jelas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta besar 1208905299 dengan pengaturan default. Dengan melipat dan tanpa itu.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika diminimalkan tidak masuk akal untuk menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Border Peta X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tapi kita tidak bisa begitu saja menyingkirkannya, karena pada saat yang sama daerah akan bergabung. Saat meminimalisasi, kita bisa menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berubah </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mengganti dalam semua kasus </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Variabel baru ini akan sama dengan atau </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tergantung pada nilai opsi runtuh. Di bawah ini saya menunjukkan perubahan hanya untuk kasus pertama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada saat yang sama, daerah-daerah tetap terpisah, tetapi ini hanya diperlukan jika ada daerah yang berbeda di sisi timur dan barat peta. </font><font style="vertical-align: inherit;">Ada dua kasus di mana ini tidak dihormati. </font><font style="vertical-align: inherit;">Yang pertama adalah ketika kita hanya memiliki satu wilayah. </font><font style="vertical-align: inherit;">Yang kedua adalah ketika ada dua wilayah yang membagi peta secara horizontal. </font><font style="vertical-align: inherit;">Dalam kasus ini, kita dapat menetapkan </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai nol, yang akan memungkinkan massa tanah untuk melintasi lapisan timur-barat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu wilayah runtuh. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekilas, tampaknya semuanya bekerja dengan benar, tetapi sebenarnya ada celah di sepanjang jahitan. </font><font style="vertical-align: inherit;">Ini menjadi lebih terlihat jika Anda mengatur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persentase Erosi ke</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nol.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika erosi dinonaktifkan, jahitan pada relief menjadi nyata.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesenjangan terjadi karena lapisan mencegah pertumbuhan fragmen relief. Untuk menentukan apa yang ditambahkan terlebih dahulu, jarak dari sel ke pusat fragmen digunakan, dan sel-sel di sisi lain peta bisa sangat jauh, sehingga mereka hampir tidak pernah menyala. Tentu saja ini salah. Kita perlu memastikan bahwa kita </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu tentang peta yang diperkecil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghitung jarak antara </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menjumlahkan jarak absolut di sepanjang masing-masing dari tiga sumbu dan membagi dua hasilnya. Jarak sepanjang Z selalu benar, tetapi melipat di sepanjang dapat mempengaruhi jarak X dan Y. Jadi mari kita mulai dengan perhitungan X + Y yang terpisah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menentukan apakah melipat membuat jarak yang lebih pendek untuk sel arbitrer bukanlah tugas yang mudah, jadi mari kita menghitung X + Y untuk kasus di mana kita melipat koordinat lain ke sisi barat. </font><font style="vertical-align: inherit;">Jika nilainya kurang dari X + Y asli, maka gunakan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika ini tidak mengarah ke jarak yang lebih pendek, maka dimungkinkan untuk berbelok lebih pendek ke arah lain, jadi kami akan memeriksanya. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami selalu mendapatkan jarak terpendek pada peta yang dapat dilipat. </font><font style="vertical-align: inherit;">Fragmen medan tidak lagi terhalang oleh jahitan, yang memungkinkan massa daratan meringkuk.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melipat relief dengan benar tanpa erosi dan erosi. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berkeliling dunia </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah mempertimbangkan pembuatan peta dan triangulasi, sekarang mari kita beralih ke memeriksa regu, eksplorasi, dan visibilitas. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uji jahitan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kendala pertama yang kita temui ketika memindahkan skuad di seluruh dunia adalah tepi peta, yang tidak dapat dieksplorasi. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jahitan kartu tidak dapat diperiksa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel-sel di sepanjang tepi peta dibuat tidak dijelajahi untuk menyembunyikan penyelesaian peta yang tiba-tiba. </font><font style="vertical-align: inherit;">Tetapi ketika peta diminimalkan, hanya sel utara dan selatan yang harus ditandai, tetapi tidak di timur dan barat. </font><font style="vertical-align: inherit;">Ubah </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mempertimbangkan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas fitur bantuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita periksa apakah visibilitas bekerja di sepanjang jahitan. </font><font style="vertical-align: inherit;">Ini berfungsi untuk medan, tetapi tidak untuk objek medan. </font><font style="vertical-align: inherit;">Sepertinya benda yang kolaps mendapatkan visibilitas sel terakhir yang tidak kolaps.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilitas objek yang salah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini terjadi karena mode </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjepit diatur </font><font style="vertical-align: inherit;">untuk mode lipat tekstur yang digunakan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk mengatasi masalah, cukup ubah mode klemnya untuk mengulang. </font><font style="vertical-align: inherit;">Tetapi kita perlu melakukan ini hanya untuk koordinat U, jadi </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita akan mengaturnya </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terpisah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pasukan dan Kolom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah lain adalah bahwa unit belum runtuh. </font><font style="vertical-align: inherit;">Setelah memindahkan kolom di mana mereka berada, unit tetap di tempat yang sama.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit tidak ditransfer dan berada di sisi yang salah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah ini dapat diatasi dengan membuat elemen anak-anak regu kolom, seperti yang kita lakukan dengan fragmen. </font><font style="vertical-align: inherit;">Pertama, kita tidak akan lagi menjadikan mereka anak langsung dari jaringan </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena unit bergerak, mereka dapat muncul di kolom lain, yaitu, akan perlu untuk mengubah induknya. </font><font style="vertical-align: inherit;">Untuk memungkinkan ini, kami menambah </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan sebagai parameter kami meneruskannya komponen </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen anak dan indeks kolom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memanggil metode ini ketika properti diatur </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memecahkan masalah membuat unit. </font><font style="vertical-align: inherit;">Tetapi kita juga perlu membuatnya bergerak ke kolom yang diinginkan saat bergerak. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu melacak </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kolom saat ini </font><font style="vertical-align: inherit;">dalam </font><font style="vertical-align: inherit;">indeks. </font><font style="vertical-align: inherit;">Di awal metode ini, ini adalah indeks kolom sel di awal jalan, atau yang saat ini jika langkah itu terputus oleh kompilasi ulang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selama setiap iterasi langkah, kami akan memeriksa apakah indeks kolom berikutnya berbeda, dan jika demikian, maka kami akan mengubah induk dari urutan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan memungkinkan unit untuk bergerak mirip dengan fragmen. </font><font style="vertical-align: inherit;">Namun, ketika bergerak melalui jahitan kartu, unit belum runtuh. </font><font style="vertical-align: inherit;">Sebaliknya, mereka tiba-tiba mulai bergerak ke arah yang salah. </font><font style="vertical-align: inherit;">Ini terjadi terlepas dari lokasi jahitan, tetapi paling mencolok ketika mereka melompati seluruh peta.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balap kuda melintasi peta. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita bisa menggunakan pendekatan yang sama yang digunakan untuk pantai, hanya kali ini kita akan memutar kurva di mana detasemen bergerak. </font><font style="vertical-align: inherit;">Jika kolom berikutnya berbelok ke timur, maka kita akan memindahkan kurva juga ke timur, sama untuk arah lainnya. </font><font style="vertical-align: inherit;">Anda perlu mengubah titik kontrol kurva </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang juga akan mempengaruhi titik kontrol </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerakan dengan melipat.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hal terakhir yang harus dilakukan adalah mengubah giliran awal regu ketika melihat sel pertama yang akan dipindahkan. Jika sel ini berada di sisi lain dari lapisan timur-barat, unit akan melihat ke arah yang salah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat meminimalkan peta, ada dua cara untuk melihat titik yang tidak persis di utara atau selatan. Anda dapat melihat timur atau barat. Akan logis untuk melihat ke arah yang sesuai dengan jarak terdekat ke titik, karena itu juga arah gerakan, jadi mari kita gunakan </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika meminimalkan, kita akan memeriksa jarak relatif sepanjang sumbu X. Jika kurang dari setengah negatif dari lebar peta, maka kita harus melihat ke barat, yang dapat dilakukan dengan memutar titik ke barat. </font><font style="vertical-align: inherit;">Jika tidak, jika jaraknya lebih dari setengah lebar peta, maka kita harus jatuh ke timur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami memiliki peta minimal yang berfungsi penuh. </font><font style="vertical-align: inherit;">Dan ini menyimpulkan serangkaian tutorial tentang peta segi enam. </font><font style="vertical-align: inherit;">Seperti disebutkan di bagian sebelumnya, topik lain dapat dipertimbangkan, tetapi mereka tidak spesifik untuk peta segi enam. </font><font style="vertical-align: inherit;">Mungkin saya akan mempertimbangkannya di seri tutorial mendatang.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengunduh paket terakhir dan mendapatkan kesalahan belokan dalam mode Putar</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengunduh paket terakhir dan gambarnya tidak seindah di screenshot</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengunduh paket terakhir dan secara konstan menghasilkan kartu yang sama</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427567/">https://habr.com/ru/post/id427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427555/index.html">Hewan yang telah dipelajari manusia untuk dilacak menggunakan teknologi pengenalan wajah</a></li>
<li><a href="../id427557/index.html">Intisari acara TI pada bulan November (bagian satu)</a></li>
<li><a href="../id427561/index.html">Hak untuk Memperbaiki: Langkah Pertama dalam Arah yang Benar dari Motorola</a></li>
<li><a href="../id427563/index.html">Standar SNI terenkripsi diterapkan di Firefox Nightly</a></li>
<li><a href="../id427565/index.html">"Prestasi saya adalah bahwa saya biasanya kembali ke profesi" - 10 pertanyaan kepada programmer, edisi 10</a></li>
<li><a href="../id427569/index.html">Sempurnakan OpenStack di bawah beban tinggi</a></li>
<li><a href="../id427571/index.html">Persatuan R dan PostgreSQL. Kami menganalisis pekerjaan bandara, menghitung pensiun</a></li>
<li><a href="../id427573/index.html">Permen atau Kehidupan: Halloween sebagai Alasan untuk Menarik Anak Anda ke Sains</a></li>
<li><a href="../id427575/index.html">Mengapa Wi-Fi tidak akan berfungsi sesuai rencana, dan mengapa tahu telepon apa yang digunakan karyawan</a></li>
<li><a href="../id427577/index.html">Pembelajaran mesin vs analisis tanda tangan ketika mendeteksi serangan pada aplikasi web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>