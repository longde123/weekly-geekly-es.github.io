<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏫ 👐🏾 🐧 Hacker assembler kotor 6502 🐺 🐌 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini mencantumkan beberapa trik yang digunakan peserta dalam kontes pemrograman Commodore 64 kecil saya. Aturan-aturan kontes itu sederhana: bu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacker assembler kotor 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Artikel ini mencantumkan beberapa trik yang digunakan peserta dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontes pemrograman Commodore 64</a> kecil saya.  Aturan-aturan kontes itu sederhana: buat file executable C64 (PRG) yang menggambar dua baris untuk membentuk gambar di bawah ini.  Yang file-nya berukuran lebih kecil dimenangkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  Entri kompetisi diterbitkan dalam tweet terbuka dan dalam pesan pribadi yang hanya berisi byte dari file PRG dan hash MD5. <br><a name="habracut"></a><br>  Daftar peserta dengan tautan ke kode sumber: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 34 byte, pemenang) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Geir Straume</a> ( <a href="">kode</a> - 34 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 37 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 38 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 48 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 50 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 53 byte) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> - 56 byte) </li></ul><br>  (Jika saya merindukan seseorang, tolong beri tahu saya, saya akan memperbarui daftar). <br><br>  Sisa artikel ini dikhususkan untuk beberapa trik assembler yang digunakan dalam kompetisi. <br><br><h1>  Dasar-dasarnya </h1><br>  Grafik C64 bekerja secara default dalam mode penyandian karakter 40x25.  Framebuffer dalam RAM dibagi menjadi dua array: <br><br><ul><li> <code>$0400</code> (RAM Layar, 40x25 byte) <br></li><li>  <code>$d800</code> (RAM Warna, 40x25 byte) </li></ul><br>  Untuk mengatur karakter, Anda menyimpan byte ke RAM pada layar, pada <code>$0400</code> (misalnya, <code>$0400+y*40+x</code> ).  RAM warna diinisialisasi oleh biru muda secara default (warna 14): ini adalah warna yang kami gunakan untuk garis, yaitu, RAM warna dapat dibiarkan tanpa sentuhan. <br><br>  Anda mengontrol warna perbatasan dan latar belakang menggunakan register I / O memori dalam <code>$d020</code> (perbatasan) dan <code>$d021</code> (latar belakang). <br><br>  Menggambar dua garis cukup mudah jika Anda memprogram langsung kemiringan garis tetap.  Berikut ini adalah implementasi C yang menggambar garis dan menyiram isi layar ke stdout ( <code>malloc()</code> digunakan untuk membuat kode berfungsi pada PC): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Kode layar di atas adalah <code>$20</code> (kosong) dan <code>$a0</code> (diisi blok 8 × 8).  Jika Anda menjalankan, Anda akan melihat gambar ASCII dengan dua baris: <br><br><pre>  ## .................................... ##
 .. # ........................................ # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # ........................................ # ..
 ## .................................... ## </pre><br>  Hal yang sama diterapkan secara sepele dalam assembler: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Ternyata PRG berukuran cukup besar 286 bytes. <br><br>  Sebelum terjun ke optimasi, kami melakukan beberapa pengamatan. <br><br>  Pertama, kami bekerja pada C64 dengan rutin ROM di tempat.  Ada banyak rutinitas yang dapat bermanfaat.  Misalnya, membersihkan layar dengan <code>JSR $E544</code> . <br><br>  Kedua, perhitungan alamat pada prosesor 8-bit seperti 6502 bisa rumit dan memakan banyak byte.  Prosesor ini juga tidak memiliki pengali, jadi perhitungan seperti <code>y*40+i</code> biasanya mencakup sekelompok shift logis atau tabel pencarian yang juga memakan byte.  Untuk menghindari mengalikan dengan 40, yang terbaik adalah memajukan kursor layar secara bertahap: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Kami terus menambahkan kemiringan garis ke penghitung tetap <code>yf</code> , dan ketika penambahan 8-bit menetapkan flag carry, tambahkan 40. <br><br>  Berikut ini adalah pendekatan assembler tambahan: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Dengan 82 byte, itu masih lumayan besar.  Satu masalah yang jelas adalah perhitungan alamat 16-bit.  Tetapkan nilai <code>screenptr</code> untuk <code>screenptr</code> tidak langsung: <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  Kami menerjemahkan <code>screenptr</code> ke baris berikutnya dengan menambahkan 40: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Tentu saja, kode ini dapat dioptimalkan, tetapi bagaimana jika Anda menyingkirkan alamat 16-bit sama sekali?  Mari kita lihat bagaimana melakukannya. <br><br><h1>  Trik 1. Menggulir! </h1><br>  Alih-alih membangun garis pada RAM di layar, kami menggambar hanya di baris layar terakhir Y = 24 dan gulirkan seluruh layar, memanggil fungsi gulir ROM dengan <code>JSR $E8EA</code> ! <br><br>  Inilah cara xloop dioptimalkan: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  Beginilah tampilan rendering: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  Ini adalah salah satu trik favorit saya dalam program ini.  Hampir semua kontestan menemukannya sendiri. <br><br><h1>  Trik 2. Kode Modifikasi-Sendiri </h1><br>  Kode untuk menyimpan nilai piksel berakhir seperti ini: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Ini dikodekan dalam urutan 14 byte berikut: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  Menggunakan kode modifikasi sendiri (SMC), Anda dapat menulis ini dengan lebih kompak: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... yang dikodekan pada 13 byte: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Trick 3. Status operasi 'power on' </h1><br>  Itu dianggap normal dalam kompetisi untuk membuat asumsi liar tentang lingkungan kerja.  Misalnya, bahwa gambar garis adalah hal pertama yang dimulai setelah menyalakan daya C64, dan tidak ada persyaratan untuk output bersih kembali ke baris perintah BASIC.  Karena itu, semua yang Anda temukan di lingkungan awal ketika memasuki PRG dapat dan harus digunakan untuk keuntungan Anda: <br><br><ul><li>  Register A, X, Y diambil sebagai nol <br></li><li>  Semua flag CPU dihapus <br></li><li>  Konten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zeropage</a> (alamat <code>$00</code> - <code>$ff</code> ) </li></ul><br>  Dengan cara yang sama, ketika memanggil beberapa prosedur ROM KERNAL, Anda dapat mengambil keuntungan penuh dari segala efek samping: pengembalian flag CPU, nilai zeropage sementara, dll. <br><br>  Setelah optimasi pertama, mari kita cari sesuatu yang menarik dalam memori mesin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  Zeropage memang mengandung beberapa nilai berguna untuk tujuan kita: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == panjang garis - 1 <br></li><li>  <code>$22</code> : 64 / $ 40 == nilai awal untuk penghitung kemiringan garis </li></ul><br>  Ini akan menghemat beberapa byte selama inisialisasi.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Karena <code>$d5</code> berisi nilai 39, Anda dapat mengindikasikannya ke penghitung <code>x0</code> , menyingkirkan pasangan LDA / STA: <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, pemenang kontes, mengambil ekstrem dalam <a href="">kode-nya</a> .  Ingat alamat karakter terakhir dari string <code>$07C0</code> (== <code>$0400+24*40</code> ).  Nilai ini tidak ada di zeropage selama inisialisasi.  Namun, sebagai efek samping dari bagaimana rutin gulir dari ROM menggunakan nilai zeropage sementara, alamat <code>$D1-$D2</code> pada output fungsi akan berisi nilai <code>$07C0</code> .  Oleh karena itu, untuk menyimpan piksel, alih-alih <code>STA $07C0,x</code> Anda dapat menggunakan <code>STA ($D1),y</code> pengalamatan indeks tidak langsung yang lebih pendek <code>STA ($D1),y</code> untuk satu byte. <br><br><h1>  Trik 4. Unduh Optimasi </h1><br>  Biner C64 PRG tipikal berisi yang berikut ini: <br><br><ul><li>  2 byte pertama: alamat pengunduhan (biasanya <code>$0801</code> ) <br></li><li>  12 byte dari urutan boot BASIC </li></ul><br>  Urutan boot utama terlihat seperti ini (alamat <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Tanpa masuk ke detail tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tata letak memori tokenized BASIC</a> , urutan ini kurang lebih sesuai dengan '10 SYS 2061 '.  Alamat <code>2061</code> ( <code>$080D</code> ) adalah tempat program kode mesin kami yang sebenarnya berjalan ketika penerjemah BASIC mengeksekusi perintah SYS. <br><br>  Sepertinya 14 byte terlalu banyak.  Philip, Matlev dan Geir menggunakan beberapa trik rumit untuk sepenuhnya menghilangkan urutan utama.  Ini membutuhkan pemuatan PRG dengan <code>LOAD"*",8,1</code> , karena <code>LOAD"*",8</code> mengabaikan alamat pemuatan PRG (dua byte pertama) dan selalu memuat pada <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Dua metode digunakan di sini: <br><br><ul><li>  Trik tumpukan <br></li><li>  Trick Reset Awal BASIC </li></ul><br><h3>  Trik tumpukan </h3><br>  Caranya adalah dengan memasukkan ke dalam tumpukan prosesor pada <code>$01F8</code> nilai yang menunjukkan titik masuk yang diinginkan.  Ini dilakukan dengan membuat PRG yang dimulai dengan pointer 16-bit ke kode kami dan memuat PRG pada <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Segera setelah pemuat BASIC (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode setelah pembongkaran</a> ) selesai memuat dan ingin kembali ke pemanggil menggunakan <code>RTS</code> , ia kembali langsung ke PRG kami. <br><br><h3>  Trick Reset Awal BASIC </h3><br>  Ini sedikit lebih mudah untuk dijelaskan hanya dengan melihat PRG setelah pembongkaran. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  Perhatikan baris terakhir ( <code>JMP $02E6</code> ).  Instruksi JMP mulai dari <code>$0301</code> dengan alamat lompatan <code>$0302-$0303</code> . <br><br>  Ketika kode ini dimuat ke dalam memori mulai dari alamat <code>$02E6</code> , nilai <code>$02E6</code> ditulis ke alamat <code>$0302-$0303</code> .  Nah, lokasi ini memiliki arti khusus: ini berisi penunjuk ke "siklus menunggu BASIC" (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kartu memori C64</a> untuk lebih jelasnya).  Mengunduh PRG menimpanya dengan <code>$02E6</code> dan oleh karena itu, ketika penerjemah BASIC setelah reset hangat mencoba untuk pergi ke loop tunggu, itu tidak pernah memasuki loop ini, tetapi sebaliknya masuk ke dalam program rendering! <br><br><h3>  Trik lain dengan peluncuran BASIC </h3><br>  Petri menemukan <a href="">trik peluncuran BASIC lain</a> yang memungkinkan Anda memasukkan konstanta Anda sendiri di zeropage.  Dalam metode ini, Anda secara manual membuat urutan awal BASIC tokenized Anda sendiri dan menyandikan konstanta dalam nomor baris dari program BASIC.  Pada input, nomor garis BASIC, ahem, yaitu, konstanta Anda akan disimpan di alamat <code>$39-$3A</code> .  Sangat pintar! <br><br><h1>  Trik 5. Alur kontrol kustom </h1><br>  Ini adalah versi x-loop yang sedikit disederhanakan yang hanya mencetak satu baris dan kemudian menghentikan eksekusi: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Namun ada kesalahan.  Ketika kami menggambar piksel terakhir, kami TIDAK BISA menggulir layar lagi.  Dengan demikian, cabang tambahan diperlukan untuk berhenti menggulir setelah merekam piksel terakhir: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Aliran kontrol sangat mirip dengan apa yang akan dihasilkan oleh kompiler C dari program terstruktur.  Kode untuk melewati scroll terakhir memperkenalkan instruksi <code>JMP abs</code> baru yang membutuhkan 3 byte.  Panjang kondisional hanya dua byte, karena mereka menyandikan alamat lompat menggunakan operan 8-bit relatif dengan pengalamatan langsung. <br><br>  JMP untuk "melewati gulir terakhir" dapat dihindari dengan menggerakkan panggilan gulir ke atas loop dan sedikit mengubah struktur aliran kontrol.  Inilah cara Philip menerapkannya: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Ini benar-benar menghilangkan satu JMP tiga byte dan mengubah JMP yang lain menjadi cabang bersyarat dua-byte, menghemat total 4 byte. <br><br><h1>  Trik 6. Garis dengan kompresi bit </h1><br>  Beberapa elemen tidak menggunakan penghitung kemiringan garis, melainkan mengompres bit menjadi konstanta 8-bit.  Pengemasan tersebut didasarkan pada fakta bahwa posisi piksel di sepanjang garis sesuai dengan pola 8-piksel yang berulang: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Ini diterjemahkan menjadi assembler yang cukup kompak.  Namun, opsi penghitung kemiringan biasanya bahkan lebih kecil. <br><br><h3>  Pemenang </h3><br>  Ini <a href="">adalah program pemenang 34 byte kontes</a> dari Philip.  Sebagian besar trik di atas berfungsi dengan baik dalam kodenya: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Tapi mengapa tinggal 34 byte? </h3><br>  Segera setelah kontes selesai, semua orang membagikan kode dan catatan mereka - dan serangkaian diskusi berlangsung tentang bagaimana memperbaikinya lebih lanjut.  Setelah batas waktu, beberapa opsi lain disajikan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip - 33 byte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip - 32 byte</a> <br></li><li>  <a href="">Petri - 31 byte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip - 29 byte</a> </li></ul><br>  Pastikan untuk melihat - ada beberapa mutiara asli. <br><br><hr><br>  Terima kasih sudah membaca.  Dan terima kasih khusus kepada Matlev, Phil, Geir, Petri, Jamie, Ian dan David untuk partisipasi (saya harap saya tidak kehilangan siapa pun - sangat sulit untuk melacak semua menyebutkan di Twitter!) <br><br>  PS Petri menyebut kontes saya "tahunan," jadi, uh, mungkin sampai jumpa tahun depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464377/">https://habr.com/ru/post/id464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464367/index.html">Dan lain-lain 0day Eskalasi Privilege Lokal Klien Windows Steam</a></li>
<li><a href="../id464369/index.html">Blocker mana yang Anda gunakan? Hasil</a></li>
<li><a href="../id464371/index.html">/etc/resolv.conf untuk opsi Kubernetes, ndots: 5, karena ini dapat mempengaruhi kinerja aplikasi</a></li>
<li><a href="../id464373/index.html">Edge-to-edge di Android: melakukannya dengan benar</a></li>
<li><a href="../id464375/index.html">Cara kerja mesin pencari</a></li>
<li><a href="../id464381/index.html">Perjalanan ke Alaska, atau KDD'19 melalui mata seorang saksi mata</a></li>
<li><a href="../id464383/index.html">Bagaimana saya menertibkan suatu proyek di mana ada hutan langsung (pengaturan tslint, lebih cantik, dll)</a></li>
<li><a href="../id464385/index.html">Python sebagai kasus akhir C ++. Bagian 1/2</a></li>
<li><a href="../id464387/index.html">Jejak Rusia di saga video game Skandinavia, berakhir</a></li>
<li><a href="../id464391/index.html">10 laporan menarik dari konferensi peretas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>