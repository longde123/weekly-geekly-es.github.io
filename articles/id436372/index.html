<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☯️ 👩🏽‍✈️ 👼🏻 Plugin Isometrik untuk Unity3D 🤴🏻 👎🏻 🎖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah cerita tentang bagaimana menulis sebuah plugin untuk Unity Asset Store , selesaikan pemecahan masalah isometrik yang terkenal di dalam game...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugin Isometrik untuk Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436372/"><img src="https://habrastorage.org/files/032/000/6f4/0320006f472344e782f536c293e3099d.png"><br><p>  Ini adalah cerita tentang bagaimana menulis sebuah plugin untuk <strong>Unity Asset Store</strong> , selesaikan pemecahan masalah isometrik yang terkenal di dalam game, dan dapatkan sedikit uang dari itu, dan juga untuk memahami bagaimana editor Unity yang dapat dikembangkan.  Gambar, kode, grafik dan pemikiran di dalamnya. </p><a name="habracut"></a><br><h2 id="prologue">  Prolog </h2><br><p> Jadi, itu suatu malam ketika saya tahu saya tidak punya banyak hal untuk dilakukan.  Tahun yang akan datang tidak benar-benar menjanjikan dalam kehidupan profesional saya (tidak seperti yang pribadi, tetapi itu adalah cerita yang sama sekali berbeda).  Lagi pula, saya mendapat ide untuk menulis sesuatu yang menyenangkan untuk masa lalu, itu akan sangat pribadi, sesuatu sendiri, tetapi masih memiliki sedikit keuntungan komersial (saya hanya suka perasaan hangat ketika proyek Anda menarik untuk orang lain, kecuali untuk atasan Anda).  Dan semua ini berjalan seiring dengan fakta bahwa saya telah lama menunggu untuk memeriksa kemungkinan ekstensi editor Unity dan untuk melihat apakah ada gunanya dalam platform untuk menjual ekstensi mesin sendiri. </p><br><p>  Saya mencurahkan satu hari untuk mempelajari Asset Store: model, skrip, integrasi dengan berbagai layanan.  Dan pertama-tama sepertinya semuanya telah ditulis dan diintegrasikan, bahkan memiliki sejumlah opsi dengan tingkat kualitas dan detail yang berbeda, seperti halnya harga dan dukungan.  Jadi segera saya mempersempitnya menjadi: </p><br><ul><li>  hanya kode (setelah semua, saya seorang programmer) </li><li>  Hanya 2D (karena saya suka 2D dan mereka baru saja membuat dukungan out-of-the-box yang layak untuk itu di Unity) </li></ul><br><p>  Dan kemudian saya ingat berapa banyak kaktus yang saya makan dan berapa banyak tikus yang mati ketika kami membuat permainan isometrik sebelumnya.  Anda tidak akan percaya berapa banyak waktu yang telah kami habiskan untuk mencari solusi yang layak dan berapa banyak salinan yang kami pecahkan dalam upaya untuk memilah isometri ini dan menariknya.  Jadi, berjuang untuk tetap diam, saya mencari dengan kata kunci yang berbeda dan tidak terlalu banyak kata kunci dan tidak dapat menemukan apa pun kecuali tumpukan besar seni isometrik, sampai akhirnya saya memutuskan untuk membuat plugin isometrik dari awal. </p><br><h2 id="setting-the-goals">  Menetapkan tujuan </h2><br><p>  Yang pertama saya butuhkan adalah untuk menjelaskan secara singkat masalah apa yang seharusnya dipecahkan oleh plugin ini dan apa yang akan dilakukan oleh pembuat game isometrik itu.  Jadi, masalah isometri adalah sebagai berikut: </p><br><ul><li>  menyortir objek dengan keterpencilan untuk menggambarnya dengan benar </li><li>  ekstensi untuk pembuatan, penentuan posisi, dan perpindahan objek isometrik di editor </li></ul><br><p>  Jadi, dengan tujuan utama untuk versi pertama yang dirumuskan, saya menetapkan batas waktu 2-3 hari untuk versi konsep pertama.  Jadi, tidak bisa ditunda, Anda tahu, karena antusiasme adalah hal yang rapuh dan jika Anda tidak memiliki sesuatu yang siap di hari-hari pertama, ada kemungkinan besar Anda merusaknya.  Dan liburan Tahun Baru tidak begitu lama kelihatannya, bahkan di Rusia, dan saya ingin merilis versi pertama dalam waktu sepuluh hari. </p><br><h2 id="sorting">  Menyortir </h2><br><p>  Singkatnya, isometry adalah upaya yang dilakukan oleh sprite 2D agar terlihat seperti model 3D.  Itu, tentu saja, menghasilkan puluhan masalah.  Yang utama adalah bahwa sprite harus diurutkan dalam urutan di mana mereka harus ditarik untuk menghindari masalah dengan saling tumpang tindih. </p><br><img src="https://habrastorage.org/files/60f/22b/db9/60f22bdb9ed3434888232416258f4b37.png"><br><blockquote>  <em>Pada tangkapan layar, Anda dapat melihat bagaimana sprite hijau yang digambar pertama (2,1), dan kemudian yang biru (1,1)</em> </blockquote><br><img src="https://habrastorage.org/files/9ba/a39/c6c/9baa39c6cd3b4584a57bbf1be169c050.png"><br><blockquote>  <em>Tangkapan layar menunjukkan penyortiran yang salah saat sprite biru digambar pertama</em> </blockquote><p>  Dalam kasus sederhana ini penyortiran tidak akan menjadi masalah, dan akan ada opsi, misalnya: </p><br><ul><li>  mengurutkan berdasarkan posisi Y di layar, yaitu * <em>(isoX + isoY)</em> 0.5 + isoZ ** </li><li>  menggambar dari sel kisi isometrik jarak jauh dari kiri ke kanan, dari atas ke bawah <strong>[(3,3), (2,3), (3,2), (1,3), (2,2), (3, 1), ...]</strong> </li><li>  dan sejumlah cara lain yang menarik dan tidak terlalu menarik </li></ul><br><p>  Mereka semua cukup bagus, cepat dan berfungsi, tetapi hanya dalam kasus objek atau kolom bersel tunggal yang diperluas ke arah isoZ :) Bagaimanapun, saya tertarik pada solusi yang lebih umum yang akan bekerja untuk objek yang diperluas dalam arah satu koordinat, atau bahkan "pagar" yang sama sekali tidak memiliki lebar, tetapi diperluas ke arah yang sama dengan ketinggian yang diperlukan. </p><br><img src="https://habrastorage.org/files/396/376/23d/39637623d1c147478ef0223501a0d240.png"><br><blockquote>  <em>Tangkapan layar menunjukkan cara yang tepat untuk menyortir objek yang diperluas <strong>3x1</strong> dan <strong>1x3</strong> dengan "pagar" berukuran <strong>3x0</strong> dan <strong>0x3</strong></em> </blockquote><p>  Dan di situlah masalah kita dimulai dan menempatkan kita di tempat di mana kita harus memutuskan jalan ke depan: </p><br><ul><li><p>  membagi objek "bersel banyak" menjadi yang "bersel tunggal", yaitu memotongnya secara vertikal dan kemudian mengurutkan garis-garis yang muncul </p><br></li><li><p>  pikirkan metode penyortiran baru, lebih rumit dan menarik </p><br></li></ul><br><p>  Saya memilih opsi kedua, tidak memiliki keinginan khusus untuk masuk ke pemrosesan rumit dari setiap objek, menjadi pemotongan (bahkan otomatis), dan pendekatan khusus untuk logika.  Sebagai catatan, mereka menggunakan cara pertama dalam beberapa game terkenal seperti <strong>Fallout 1</strong> dan <strong>Fallout 2</strong> .  Anda benar-benar dapat melihat strip itu jika Anda masuk ke data permainan. </p><br><p>  Jadi, opsi kedua tidak menyiratkan kriteria penyortiran.  Ini berarti bahwa tidak ada nilai pra-perhitungan dengan mana Anda bisa mengurutkan objek.  Jika Anda tidak mempercayai saya (dan saya kira banyak orang yang tidak pernah bekerja dengan isometry tidak), ambil selembar kertas dan gambar benda-benda kecil berukuran <strong>2x8</strong> dan, misalnya, <strong>2x2</strong> .  Jika Anda entah bagaimana berhasil mengetahui nilai untuk perhitungan kedalaman dan pengurutannya - cukup tambahkan objek <strong>8x2</strong> dan cobalah untuk mengurutkannya di posisi yang berbeda relatif satu sama lain. </p><br><p>  Jadi, tidak ada nilai seperti itu, tetapi kita masih bisa menggunakan dependensi di antara mereka (secara kasar, yang tumpang tindih mana) untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyortiran topologis</a> .  Kita dapat menghitung dependensi objek dengan menggunakan proyeksi koordinat isometrik pada sumbu isometrik. </p><br><img src="https://habrastorage.org/files/db0/1cd/835/db01cd8359494b35aaee399e197c972e.png"><br><blockquote>  <em>Cuplikan layar memperlihatkan kubus biru memiliki ketergantungan pada kubus merah</em> </blockquote><br><img src="https://habrastorage.org/files/eb3/af1/0d0/eb3af10d0cf04c6ba48a481a0b039f3c.png"><br><blockquote>  <em>Cuplikan layar memperlihatkan kubus hijau yang memiliki ketergantungan pada kubus biru</em> </blockquote><p>  Sebuah pseudocode untuk penentuan ketergantungan untuk dua sumbu (bekerja sama dengan sumbu Z): </p><br><pre><code class="plaintext hljs">bool IsIsoObjectsDepends(IsoObject obj_a, IsoObject obj_b) { var obj_a_max_size = obj_a.position + obj_a.size; return obj_b.position.x &lt; obj_a_max_size.x &amp;&amp; obj_b.position.y &lt; obj_a_max_size.y; }</code> </pre> <br><p>  Dengan pendekatan seperti itu kami membangun dependensi antara semua objek, melewati di antara mereka secara rekursif dan menandai tampilan Z koordinat.  Metode ini cukup universal, dan yang paling penting, ini berhasil.  Anda dapat membaca deskripsi terperinci tentang algoritma ini, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Mereka juga menggunakan pendekatan semacam ini di pustaka isometrik flash populer ( <a href="">as3isolib</a> ). </p><br><p>  Dan semuanya sangat bagus kecuali bahwa kompleksitas waktu dari pendekatan ini adalah <strong>O (N ^ 2)</strong> karena kita harus membandingkan setiap objek dengan yang lainnya untuk membuat dependensi.  Saya telah meninggalkan pengoptimalan untuk versi yang lebih baru, setelah menambahkan hanya pemilahan ulang yang malas sehingga tidak ada yang akan diurutkan sampai sesuatu bergerak.  Jadi kita akan berbicara tentang pengoptimalan sedikit nanti. </p><br><h2 id="editor-extension">  Ekstensi editor </h2><br><p>  Mulai sekarang, saya memiliki tujuan-tujuan berikut: </p><br><ul><li>  pemilahan objek harus bekerja di editor (tidak hanya dalam permainan) </li><li>  pasti ada jenis lain dari Gizmos-Arrow (panah untuk memindahkan objek) </li><li>  secara opsional, akan ada keberpihakan dengan ubin ketika objek dipindahkan </li><li>  ukuran ubin akan diterapkan dan diatur di inspektur dunia isometrik secara otomatis </li><li>  Objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AABB</a> digambar sesuai dengan ukuran isometriknya </li><li>  output dari koordinat isometrik di inspektur objek, dengan mengubah mana kita akan mengubah posisi objek di dunia game </li></ul><br><p>  Dan semua tujuan ini telah tercapai.  Unity benar-benar memungkinkan untuk memperluas editornya secara signifikan.  Anda dapat menambahkan tab baru, jendela, tombol, bidang baru di pemeriksa objek.  Jika mau, Anda bahkan dapat membuat inspektur khusus untuk komponen dengan tipe persis yang Anda butuhkan.  Anda juga dapat menampilkan informasi tambahan di jendela editor (dalam kasus saya, pada objek AABB), dan mengganti gizmos objek bergerak standar juga.  Masalah pengurutan di dalam editor diselesaikan melalui tag sihir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExecuteInEditMode ini</a> , yang memungkinkan untuk menjalankan komponen objek dalam mode editor, yaitu melakukannya dengan cara yang sama seperti dalam permainan. </p><br><p>  Semua ini dilakukan, tentu saja, bukan tanpa kesulitan dan trik dari semua jenis, tetapi tidak ada masalah tunggal yang telah saya habiskan lebih dari beberapa jam (Google, forum dan komunitas yakin membantu saya untuk menyelesaikan semua masalah muncul yang tidak disebutkan dalam dokumentasi). </p><br><img src="https://habrastorage.org/files/df6/ae0/2ae/df6ae02aec294ca28d9a6ffcf1b81382.png"><br><blockquote>  <em>Cuplikan layar memperlihatkan gizmos saya untuk objek gerakan dalam dunia isometrik</em> </blockquote><br><h2 id="release">  Lepaskan </h2><br><p>  Jadi, saya menyiapkan versi pertama, mengambil tangkapan layar.  Saya bahkan menggambar ikon dan menulis deskripsi.  Sudah waktunya.  Jadi, saya menetapkan harga nominal $ 5, unggah plugin di toko dan tunggu sampai disetujui oleh Unity.  Saya tidak terlalu memikirkan harganya, karena saya belum benar-benar ingin mendapatkan uang besar.  Tujuan saya adalah untuk mengetahui apakah ada permintaan umum dan jika memang demikian, saya ingin memperkirakannya.  Saya juga ingin membantu pengembang game isometrik yang entah bagaimana akhirnya benar-benar kehilangan peluang dan tambahan. </p><br><p>  Dalam 5 hari yang agak menyakitkan (saya menghabiskan waktu yang hampir bersamaan untuk menulis versi pertama, tetapi saya tahu apa yang saya lakukan, tanpa bertanya-tanya dan berpikir berlebihan, itu memberi saya kecepatan yang lebih tinggi dibandingkan dengan orang-orang yang baru mulai bekerja dengan isometry) Saya mendapat tanggapan dari Unity yang mengatakan bahwa plugin itu disetujui dan saya sudah bisa melihatnya di toko, sama halnya dengan nol (sejauh ini) penjualannya.  Itu diperiksa di forum lokal, membangun Google Analytics ke halaman plugin di toko dan mempersiapkan diri untuk menunggu rumput tumbuh. </p><br><p>  Tidak butuh waktu lama sebelum penjualan pertama, seperti umpan balik di forum dan toko muncul.  Selama sisa hari 12 Januari, salinan plugin saya telah terjual, yang saya anggap sebagai tanda ketertarikan publik dan memutuskan untuk melanjutkan. </p><br><h2 id="optimization">  Optimasi </h2><br><p>  Jadi, saya tidak senang dengan dua hal: </p><br><ul><li>  Kompleksitas waktu penyortiran - O (N ^ 2) </li><li>  Masalah dengan pengumpulan sampah dan kinerja umum </li></ul><br><h3 id="algorithm">  Algoritma </h3><br><p>  Memiliki 100 objek dan O (N ^ 2) Saya memiliki 10.000 iterasi untuk membuat hanya untuk menemukan dependensi, dan juga saya harus melewati semuanya dan menandai layar Z untuk menyortir.  Seharusnya ada beberapa solusi untuk itu.  Jadi, saya mencoba sejumlah besar pilihan, tidak bisa tidur memikirkan masalah ini.  Ngomong-ngomong, saya tidak akan memberi tahu Anda tentang semua metode yang telah saya coba, tetapi saya akan menjelaskan metode yang saya temukan sejauh ini. </p><br><p>  Hal pertama yang pertama, tentu saja, kita hanya mengurutkan objek yang terlihat.  Maksudnya adalah kita harus selalu tahu apa yang ada dalam foto kita.  Jika ada objek baru, kita harus menambahkannya dalam proses penyortiran, dan jika salah satu yang lama hilang - abaikan saja.  Sekarang, Unity tidak memungkinkan untuk menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bounding Box objek</a> bersama-sama dengan anak-anaknya di pohon adegan.  Lewati anak-anak (setiap saat, karena mereka dapat ditambahkan dan dihapus) tidak akan bekerja - terlalu lambat.  Kami juga tidak dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OnBecameVisible</a> dan acara lainnya karena ini hanya berfungsi untuk objek induk.  Tetapi kita bisa mendapatkan semua komponen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Renderer</a> dari objek yang diperlukan dan anak-anaknya.  Tentu saja, ini kedengarannya bukan pilihan terbaik kami, tetapi saya tidak dapat menemukan cara lain, sama universal dan dapat diterima oleh kinerja. </p><br><pre> <code class="plaintext hljs">List&lt;Renderer&gt; _tmpRenderers = new List&lt;Renderer&gt;(); bool IsIsoObjectVisible(IsoObject iso_object) { iso_object.GetComponentsInChildren&lt;Renderer&gt;(_tmpRenderers); for ( var i = 0; i &lt; _tmpRenderers.Count; ++i ) { if ( _tmpRenderers[i].isVisible ) { return true; } } return false; }</code> </pre> <br><p>  <em>Ada sedikit trik menggunakan fungsi <strong>GetComponentsInChildren</strong> yang memungkinkan untuk mendapatkan komponen tanpa alokasi di buffer yang diperlukan, tidak seperti yang lain yang mengembalikan array komponen baru</em> </p><br><p>  Kedua, saya masih harus melakukan sesuatu tentang <strong>O (N ^ 2)</strong> .  Saya telah mencoba sejumlah teknik pemisahan ruang sebelum saya berhenti di kisi dua dimensi sederhana di ruang pajangan tempat saya memproyeksikan objek isometrik saya.  Setiap sektor tersebut berisi daftar objek isometrik yang melintasinya.  Jadi, idenya sederhana: jika proyeksi objek tidak disilangkan, maka tidak ada gunanya membangun ketergantungan antara objek sama sekali.  Kemudian kami melewati semua objek yang terlihat dan membangun dependensi hanya di sektor-sektor yang diperlukan, sehingga menurunkan kompleksitas waktu dari algoritma dan meningkatkan kinerja.  Kami menghitung ukuran setiap sektor sebagai rata-rata antara ukuran semua objek.  Saya menemukan hasilnya lebih dari memuaskan. </p><br><h3 id="general-performance">  Kinerja umum </h3><br><p>  Tentu saja, saya bisa menulis artikel terpisah tentang ini ... Oke, mari kita coba untuk mempersingkat ini.  Pertama, kami menguangkan komponen (kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GetComponent</a> untuk menemukannya, yang tidak cepat).  Saya merekomendasikan semua orang untuk berjaga-jaga ketika bekerja dengan apa pun yang berkaitan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaruan</a> .  Anda harus selalu ingat bahwa hal itu terjadi untuk setiap frame, jadi Anda harus benar-benar berhati-hati. Juga, ingat tentang semua fitur menarik seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator kustom ==</a> .  Ada banyak hal yang perlu diingat, tetapi pada akhirnya Anda harus tahu tentang masing-masing dari mereka di profiler bawaan.  Itu membuatnya lebih mudah untuk menghafal dan menggunakannya :) </p><br><p>  Anda juga harus benar-benar memahami rasa sakit pengumpul sampah.  Perlu kinerja yang lebih tinggi?  Kemudian lupakan segala sesuatu yang dapat mengalokasikan memori, yang dalam <strong>C #</strong> (terutama di compiler <strong>Mono</strong> lama) dapat dilakukan dengan apa saja, mulai dari <strong>foreach</strong> (!) Untuk lambda yang muncul, apalagi <strong>LINQ</strong> yang sekarang dilarang untuk Anda bahkan dalam kasus yang paling sederhana.  Pada akhirnya, bukannya <strong>C #</strong> dengan gula sintaksisnya, Anda mendapatkan kemiripan <strong>C</strong> dengan kapasitas yang konyol. </p><br><p>  Di sini saya akan memberikan beberapa tautan pada topik yang mungkin bermanfaat bagi Anda: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian3</a> . </p><br><h3 id="results">  Hasil </h3><br><p>  Saya belum pernah kenal orang yang menggunakan teknik optimasi ini, jadi saya sangat senang melihat hasilnya.  Dan jika dalam versi pertama butuh 50 objek bergerak untuk game untuk mengubahnya menjadi tampilan slide, sekarang bekerja cukup baik bahkan ketika ada 800 objek dalam sebuah bingkai: semuanya berputar dengan kecepatan tinggi dan mengurutkan ulang hanya untuk 3-6 ms yang sangat baik untuk jumlah objek dalam isometry ini.  Selain itu, setelah inisialisasi hampir tidak mengalokasikan memori untuk sebuah bingkai :) </p><br><h2 id="further-opportunities">  Peluang lebih lanjut </h2><br><p>  Setelah saya membaca umpan balik dan saran, ada beberapa fitur yang saya tambahkan di versi sebelumnya. </p><br><h3 id="2d3d-mixture">  Campuran 2D / 3D </h3><br><p>  Menggabungkan 2D dan 3D dalam game isometrik adalah peluang yang menarik yang memungkinkan untuk meminimalkan menggambar berbagai gerakan dan opsi rotasi (misalnya, model 3D karakter animasi).  Ini tidak terlalu sulit untuk dilakukan, tetapi membutuhkan integrasi dalam sistem penyortiran.  Yang Anda butuhkan adalah mendapatkan <strong>Bounding Box</strong> model dengan semua anak-anaknya, dan kemudian memindahkan model di sepanjang layar Z dengan lebar kotak. </p><br><pre> <code class="plaintext hljs">Bounds IsoObject3DBounds(IsoObject iso_object) { var bounds = new Bounds(); iso_object.GetComponentsInChildren&lt;Renderer&gt;(_tmpRenderers); if ( _tmpRenderers.Count &gt; 0 ) { bounds = _tmpRenderers[0].bounds; for ( var i = 1; i &lt; _tmpRenderers.Count; ++i ) { bounds.Encapsulate(_tmpRenderers[i].bounds); } } return bounds; }</code> </pre> <br><p>  <em>itulah contoh bagaimana Anda bisa mendapatkan <strong>Bounding Box</strong> model dengan semua anak-anaknya</em> </p><br><img src="https://habrastorage.org/files/837/b52/c02/837b52c025b6485c95ede6c77a5b4ed3.gif"><br><blockquote>  <em>dan seperti itulah rasanya ketika itu dilakukan</em> </blockquote><br><h3 id="custom-isometric-settings">  Pengaturan isometrik khusus </h3><br><p>  Itu relatif sederhana.  Saya diminta untuk memungkinkan untuk mengatur sudut isometrik, aspek rasio, ketinggian ubin.  Setelah menderita beberapa rasa sakit yang terlibat dalam matematika, Anda mendapatkan sesuatu seperti ini: </p><br><img src="https://habrastorage.org/files/02b/f56/35e/02bf5635e5df46778915d43caf2bd846.gif"><br><br><h3 id="physics">  Fisika </h3><br><p>  Dan di sini semakin menarik.  Karena isometri mensimulasikan dunia 3D, fisika juga seharusnya tiga dimensi, dengan ketinggian dan segalanya.  Saya datang dengan trik yang menarik ini.  Saya meniru semua komponen fisika, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rigidbody</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Collider</a> dan sebagainya, untuk dunia isometrik.  Menurut uraian dan pengaturan ini saya membuat salinan dunia fisik tiga dimensi yang tak terlihat menggunakan mesin itu sendiri dan <strong>PhysX bawaan</strong> .  Setelah itu saya mengambil data simulasi dihitung dan mendapatkan bacl dalam komponen duplikat untuk dunia isometrik.  Lalu saya melakukan hal yang sama untuk mensimulasikan peristiwa menabrak dan memicu. </p><br><img src="https://habrastorage.org/files/56c/c0b/199/56cc0b19987043bbb94baa257879b224.gif"><br><blockquote>  <em>Demo fisik toolset GIF</em> </blockquote><br><h2 id="epilogue-and-conclusions">  Epilog dan kesimpulan </h2><br><p>  Setelah saya menerapkan semua saran dari forum, saya memutuskan untuk menaikkan harga hingga 40 dolar, sehingga tidak akan terlihat seperti plugin murah lain dengan lima baris kode :) Saya akan sangat senang untuk menjawab pertanyaan dan dengarkan saran Anda.  Karena ini pertama kalinya saya menulis sesuatu tentang Habr, saya menyambut semua jenis kritik, terima kasih!  Dan sekarang, sesuatu yang saya simpan untuk yang terakhir, statistik penjualan bulan ini: </p><br><table border="1" width="200"><tbody><tr><th>  Bulan </th><th>  5 $ </th><th>  40 $ </th></tr><tr><td>  Januari </td><td>  12 </td><td>  0 </td></tr><tr><td>  Februari </td><td>  22 </td><td>  0 </td></tr><tr><td>  Maret </td><td>  17 </td><td>  0 </td></tr><tr><td>  April </td><td>  9 </td><td>  0 </td></tr><tr><td>  Mei </td><td>  9 </td><td>  0 </td></tr><tr><td>  Juni </td><td>  9 </td><td>  0 </td></tr><tr><td>  Juli </td><td>  7 </td><td>  4 </td></tr><tr><td>  Agustus </td><td>  0 </td><td>  4 </td></tr><tr><td>  September </td><td>  0 </td><td>  5 </td></tr></tbody></table><br><p>  Tautan halaman Unity Asset Store: Perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isometrik 2.5D</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436372/">https://habr.com/ru/post/id436372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436356/index.html">[Menarik dari belakang bukit] Bagaimana kita menghentikan ketergantungan teknologi?</a></li>
<li><a href="../id436358/index.html">Mengapa pengembang senior mengajar siswa</a></li>
<li><a href="../id436360/index.html">Gotta Go Fast: Membangun untuk Kecepatan di iOS. Bagian 1</a></li>
<li><a href="../id436364/index.html">Liveprof akan menunjukkan kapan dan mengapa kinerja aplikasi PHP Anda telah berubah</a></li>
<li><a href="../id436370/index.html">Infrastruktur Kunci Publik X509 v.3 Rantai Sertifikat Root</a></li>
<li><a href="../id436374/index.html">Tren desain UI dan UX 2019</a></li>
<li><a href="../id436376/index.html">Sekilas tentang robot semua medan EZ-Robot Roli Rover</a></li>
<li><a href="../id436378/index.html">bobaos.pub - KNX TP / UART, Raspberry Pi dan Redis</a></li>
<li><a href="../id436380/index.html">Mulai cepat dalam pencetakan 3D: printer anggaran untuk pemula atau teknologi untuk massa</a></li>
<li><a href="../id436382/index.html">Antiquities: evolusi laptop sepuluh tahun menggunakan ThinkPad X301</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>