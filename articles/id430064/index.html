<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☁️ ✋🏿 📺 C ++: sesi arkeologi spontan dan mengapa Anda tidak harus menggunakan fungsi variabel dalam gaya C 👵🏿 ➿ 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semuanya dimulai, seperti biasa, dengan kesalahan. Ini adalah pertama kalinya saya bekerja dengan Java Native Interface dan di bagian C ++ saya membun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: sesi arkeologi spontan dan mengapa Anda tidak harus menggunakan fungsi variabel dalam gaya C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Semuanya dimulai, seperti biasa, dengan kesalahan.  Ini adalah pertama kalinya saya bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Native Interface</a> dan di bagian C ++ saya membungkus fungsi yang membuat objek Java.  Fungsi ini - <code>CallVoidMethod</code> - adalah variabel, mis.  selain penunjuk ke lingkungan <abbr title="Java Native Interface">JNI</abbr> , penunjuk ke jenis objek yang akan dibuat, dan pengidentifikasi untuk metode yang disebut (dalam hal ini, konstruktor), diperlukan sejumlah argumen lain yang sewenang-wenang.  Itu logis, karena  argumen lain ini diteruskan ke metode yang disebut di sisi Jawa, dan metode dapat berbeda, dengan jumlah argumen yang berbeda dari jenis apa pun. <br><br>  Oleh karena itu, saya juga membuat variabel pembungkus saya.  Untuk meneruskan sejumlah argumen sewenang-wenang ke <code>CallVoidMethod</code> menggunakan <code>va_list</code> , karena berbeda dalam hal ini.  Ya, itulah yang dikirim <code>CallVoidMethod</code> ke <code>CallVoidMethod</code> .  Dan menjatuhkan kesalahan segmentasi dangkal JVM. <br><br>  Dalam 2 jam saya berhasil mencoba beberapa versi JVM, dari tanggal 8 hingga 11, karena: pertama, ini adalah pengalaman pertama saya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Mesin virtual Java">JVM</a> , dan dalam hal ini saya lebih mempercayai StackOverflow daripada saya, dan kedua, seseorang kemudian pada StackOverflow saya menyarankan dalam hal ini untuk menggunakan bukan OpenJDK, tetapi OracleJDK, dan bukan 8, tapi 10. Dan hanya kemudian saya akhirnya menyadari bahwa selain variabel <code>CallVoidMethod</code> ada <code>CallVoidMethodV</code> , yang mengambil sejumlah argumen melalui <code>va_list</code> . <br><br>  Yang paling tidak saya sukai dari cerita ini adalah saya tidak segera melihat perbedaan antara ellipsis (ellipsis) dan <code>va_list</code> .  Dan setelah memperhatikan, saya tidak dapat menjelaskan kepada diri saya apa perbedaan mendasar itu.  Jadi, kita perlu berurusan dengan ellipsis, dan dengan <code>va_list</code> , dan (karena kita masih berbicara tentang C ++) dengan templat variabel. <br><a name="habracut"></a><br><h3>  Bagaimana dengan elipsis dan va_list dikatakan dalam Standar </h3><br>  Standar C ++ hanya menjelaskan perbedaan antara persyaratannya dan persyaratan Standar C. Perbedaan itu sendiri akan dibahas nanti, tetapi untuk saat ini saya akan menjelaskan secara singkat apa yang dikatakan Standar C (dimulai dengan C89). <br><br><ul><li>  Anda dapat mendeklarasikan fungsi yang mengambil sejumlah argumen sembarang.  Yaitu  suatu fungsi dapat memiliki lebih banyak argumen daripada parameter.  Untuk melakukan ini, daftar parameternya harus diakhiri dengan elipsis, tetapi setidaknya satu parameter tetap <i>[C11 6.9.1 / 8]</i> juga harus ada: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  Informasi tentang jumlah dan jenis argumen yang sesuai dengan elipsis tidak diteruskan ke fungsi itu sendiri.  Yaitu  setelah parameter bernama terakhir ( <code>parm2</code> pada contoh di atas) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Untuk mengakses argumen ini, Anda harus menggunakan tipe <code>va_list</code> dideklarasikan di header <code>&lt;stdarg.h&gt;</code> dan 4 (3 sebelum standar C11) makro: <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> dan <code>va_copy</code> (dimulai dengan C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Sebagai contoh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Ya, fungsinya tidak tahu berapa banyak argumen yang dimilikinya.  Dia perlu melewati nomor ini.  Dalam hal ini, melalui argumen bernama tunggal (opsi umum lainnya adalah untuk melewati <code>NULL</code> sebagai argumen terakhir, seperti dalam <code>execl</code> , atau 0). </div></div></li><li>  Argumen yang disebutkan terakhir tidak dapat memiliki kelas penyimpanan <code>register</code> , tidak bisa berupa fungsi atau array.  Jika tidak, perilaku tidak terdefinisi <i>[C11 7.16.1.4/4]</i> . </li><li>  Selain itu, untuk argumen yang disebutkan terakhir dan untuk semua yang tidak bernama, " <i>promosi argumen default</i> " diterapkan ( <i>promosi argumen default</i> ; jika ada terjemahan yang baik dari konsep ini ke dalam bahasa Rusia, saya dengan senang hati menggunakannya).  Ini berarti bahwa jika argumen memiliki tipe <code>char</code> , <code>short</code> (dengan atau tanpa tanda) atau <code>float</code> , maka parameter yang sesuai harus diakses sebagai <code>int</code> , <code>int</code> (dengan atau tanpa tanda) atau <code>double</code> .  Jika tidak, perilaku tidak terdefinisi <i>[C11 7.16.1.1/2]</i> . </li><li>  Tentang tipe <code>va_list</code> hanya dikatakan bahwa ia dideklarasikan dalam <code>&lt;stdarg.h&gt;</code> dan lengkap (yaitu, ukuran objek jenis ini diketahui) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Mengapa  Tetapi karena! </h3><br>  Tidak banyak jenis dalam C.  Mengapa <code>va_list</code> dinyatakan dalam Standar, tetapi tidak ada yang dikatakan tentang struktur internalnya? <br><br>  Mengapa kita membutuhkan elipsis jika sejumlah argumen sembarang fungsi dapat dilewati melalui <code>va_list</code> ?  Bisa dikatakan sekarang: "sebagai gula sintaksis", tetapi 40 tahun yang lalu, saya yakin, tidak ada waktu untuk gula. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> dalam buku <i>The Standard C library</i> - 1992 - mengatakan bahwa awalnya C dibuat khusus untuk komputer PDP-11.  Dan di sana dimungkinkan untuk memilah-milah semua argumen dari fungsi menggunakan aritmatika pointer sederhana.  Masalahnya muncul dengan popularitas C dan transfer kompiler ke arsitektur lain.  Edisi pertama <i>Bahasa Pemrograman C oleh</i> <i>Brian Kernighan</i> dan Dennis Ritchie - 1978 - secara eksplisit menyatakan: <blockquote>  By the way, tidak ada cara yang dapat diterima untuk menulis fungsi portabel dari sejumlah argumen, karena  Tidak ada cara portabel untuk fungsi yang dipanggil untuk mengetahui berapa banyak argumen yang diteruskan ketika dipanggil.  ... <code>printf</code> , fungsi bahasa C paling umum dari sejumlah argumen arbitrer, ... tidak portabel dan harus diterapkan untuk setiap sistem. </blockquote>  Buku ini menjelaskan <code>printf</code> , tetapi belum memiliki <code>vprintf</code> , dan tidak menyebutkan jenis dan makro <code>va_*</code> .  Mereka muncul dalam edisi kedua Bahasa Pemrograman C (1988), dan ini adalah kelebihan komite untuk pengembangan Standar C pertama (C89, alias ANSI C).  Komite menambahkan <code>&lt;stdarg.h&gt;</code> menuju ke Standar, mengambil sebagai dasar <code>&lt;varargs.h&gt;</code> dibuat oleh Andrew Koenig untuk meningkatkan portabilitas OS UNIX.  Diputuskan untuk meninggalkan macro <code>va_*</code> sebagai macro sehingga akan lebih mudah bagi kompiler yang ada untuk mendukung Standar baru. <br><br>  Sekarang, dengan munculnya C89 dan keluarga <code>va_*</code> , telah dimungkinkan untuk membuat fungsi variabel portabel.  Dan meskipun struktur internal keluarga ini masih belum dijelaskan dengan cara apa pun, dan tidak ada persyaratan untuk itu, sudah jelas mengapa. <br><br>  Karena penasaran, Anda dapat menemukan contoh implementasi <code>&lt;stdarg.h&gt;</code> .  Misalnya, "Perpustakaan Standar C" yang sama memberikan contoh untuk <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; dari Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SystemV ABI yang</a> jauh lebih baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk AMD64</a> menggunakan tipe ini untuk <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list dari SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  Secara umum, kita dapat mengatakan bahwa tipe dan makro <code>va_*</code> menyediakan antarmuka standar untuk melintasi argumen fungsi variabel, dan implementasinya karena alasan historis tergantung pada kompiler, platform target, dan arsitektur.  Selain itu, ellipsis (mis., Fungsi variabel secara umum) muncul di C lebih awal dari <code>va_list</code> (mis., Header <code>&lt;stdarg.h&gt;</code> ).  Dan <code>va_list</code> tidak dibuat untuk menggantikan elipsis, tetapi untuk memungkinkan pengembang untuk menulis fungsi variabel portabel mereka. <br><br>  C ++ sebagian besar mempertahankan kompatibilitas ke belakang dengan C, jadi semua hal di atas berlaku untuk itu.  Tetapi ada juga fitur. <br><br><h3>  Fungsi Variabel dalam C ++ </h3><br>  Kelompok kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WG21</a> telah terlibat dalam pengembangan Standar C ++.  Pada tahun 1989, Standar C89 yang baru dibuat diambil sebagai dasar, yang secara bertahap berubah untuk menggambarkan C ++ itu sendiri.  Pada tahun 1995, proposal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">N0695 diterima</a> dari <i>John Micco</i> , di mana penulis menyarankan untuk mengubah batasan untuk macro <code>va_*</code> : <br><br><ul><li>  Karena  C ++, tidak seperti C, memungkinkan Anda untuk mendapatkan alamat <code>register</code> dari variabel, maka argumen nama terakhir dari fungsi variabel dapat memiliki kelas penyimpanan ini. <br></li><li>  Karena  tautan yang muncul di C ++ melanggar aturan fungsi variabel C yang tidak tertulis - ukuran parameter harus cocok dengan ukuran tipe yang dideklarasikan - maka argumen yang disebutkan terakhir tidak boleh berupa tautan.  Jika tidak, perilaku yang tidak jelas. <br></li><li>  Karena  di C ++ tidak ada konsep " <i>meningkatkan jenis argumen secara default</i> ", lalu frasa <br><blockquote>  Jika parameter <code>parmN</code> dideklarasikan dengan ... tipe yang tidak kompatibel dengan tipe yang dihasilkan setelah aplikasi promosi argumen default, perilaku tidak terdefinisi </blockquote>  harus diganti oleh <blockquote>  Jika parameter <code>parmN</code> dideklarasikan dengan ... tipe yang tidak kompatibel dengan tipe yang dihasilkan ketika melewati argumen yang tidak ada parameter, perilaku tidak terdefinisi </blockquote></li></ul>  Saya bahkan tidak menerjemahkan poin terakhir untuk berbagi rasa sakit saya.  Pertama, " <i>eskalasi jenis argumen default</i> " di C ++ Standard tetap <i>[C ++ 17 8.2.2 / 9]</i> .  Dan kedua, saya bingung untuk waktu yang lama tentang makna ungkapan ini, dibandingkan dengan Standar C, di mana semuanya jelas.  Hanya setelah membaca N0695 saya akhirnya mengerti: Maksud saya hal yang sama. <br><br>  Namun, ketiga perubahan diadopsi <i>[C ++ 98 18,7 / 3]</i> .  Kembali di C ++, persyaratan untuk fungsi variabel untuk memiliki setidaknya satu parameter bernama (dalam hal ini Anda tidak dapat mengakses yang lain, tetapi lebih lanjut tentang itu nanti) telah menghilang, dan daftar tipe valid argumen tanpa nama telah ditambahkan dengan pointer ke anggota kelas dan tipe <abbr title="Data lama polos">POD</abbr> . <br><br>  Standar C ++ 03 tidak membawa perubahan pada fungsi variasional.  C ++ 11 mulai mengonversi argumen tanpa nama dari tipe <code>std::nullptr_t</code> menjadi <code>void*</code> dan mengizinkan kompiler, atas kebijakan mereka, untuk mendukung tipe dengan konstruktor dan destruktor non-sepele <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 memungkinkan penggunaan fungsi dan array sebagai parameter bernama terakhir <i>[C ++ 14 18.10 / 3]</i> , dan C ++ 17 melarang penggunaan ekspansi paket parameter ( <i>ekspansi paket</i> ) dan variabel yang ditangkap oleh lambda <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  Akibatnya, C ++ menambahkan fungsi variatif ke perangkapnya.  Hanya dukungan tipe yang tidak ditentukan dengan konstruktor / destruktor non-sepele yang layak.  Di bawah ini saya akan mencoba untuk mengurangi semua fitur fungsi variabel yang tidak jelas menjadi satu daftar dan menambahkannya dengan contoh-contoh spesifik. <br><br><h3>  Cara menggunakan fungsi variabel dengan mudah dan salah </h3><br><ol><li>  Tidak benar untuk mendeklarasikan argumen yang disebutkan terakhir dengan tipe yang dipromosikan, mis.  <code>char</code> , <code>char</code> <code>signed char</code> , <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> atau <code>float</code> .  Hasil menurut Standar akan menjadi perilaku yang tidak terdefinisi. <br><br><div class="spoiler">  <b class="spoiler_title">Kode tidak valid</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  Dari semua kompiler yang saya miliki (gcc, dentang, MSVC), hanya <b>dentang</b> mengeluarkan peringatan. <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan dentang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Dan meskipun dalam semua kasus kode yang dikompilasi berperilaku dengan benar, Anda tidak harus mengandalkannya. <br><br><div class="spoiler">  <b class="spoiler_title">Itu akan benar</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Tidak benar untuk menyatakan argumen yang disebutkan terakhir sebagai referensi.  Tautan apa saja.  Standar dalam hal ini juga menjanjikan perilaku yang tidak terdefinisi. <br><br><div class="spoiler">  <b class="spoiler_title">Kode tidak valid</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> menyusun kode ini tanpa satu komentar.  <b>lang 6.0.0</b> mengeluarkan peringatan, tetapi masih menyusunnya. <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan dentang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Dalam kedua kasus, program bekerja dengan benar (beruntung, Anda tidak dapat mengandalkannya).  Tetapi <b>MSVC 19.15.26730</b> membedakan dirinya - ia menolak untuk mengkompilasi kode, karena  Argumen <code>va_start</code> tidak boleh menjadi referensi. <br><br><div class="spoiler">  <b class="spoiler_title">Kesalahan dari MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Nah, opsi yang benar terlihat, misalnya, seperti ini</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Salah meminta <code>va_arg</code> menaikkan tipe - <code>char</code> , <code>short</code> atau <code>float</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Kode tidak valid</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  Lebih menarik di sini.  <b>gcc</b> pada saat kompilasi memberikan peringatan bahwa perlu menggunakan <code>double</code> daripada <code>float</code> , dan jika kode ini masih dijalankan, program akan berakhir dengan kesalahan. <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan gcc</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  Memang, program macet dengan keluhan tentang instruksi yang tidak valid. <br>  Analisis dump menunjukkan bahwa program menerima sinyal SIGILL.  Dan itu juga menunjukkan struktur <code>va_list</code> .  Untuk 32 bit ini <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  yaitu  <code>va_list</code> hanya <code>char*</code> .  Untuk 64 bit: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  yaitu  persis apa yang dijelaskan dalam SystemV ABI AMD64. <br><br>  <b>dentang</b> pada kompilasi memperingatkan perilaku tidak terdefinisi dan juga menyarankan mengganti <code>float</code> dengan <code>double</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan dentang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Tetapi program tidak lagi crash, versi 32-bit menghasilkan: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 bit: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> menghasilkan hasil yang persis sama, hanya tanpa peringatan, bahkan dengan <code>/Wall</code> . <br><br>  Di sini dapat diasumsikan bahwa perbedaan antara 32 dan 64 bit disebabkan oleh fakta bahwa dalam kasus pertama, ABI melewati semua argumen melalui stack ke fungsi yang disebut, dan pada yang kedua, empat (Windows) atau enam (Linux) argumen pertama melalui register prosesor, sisanya melalui susun [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> ].  Tetapi tidak, jika Anda memanggil <code>foo</code> bukan dengan 4 argumen, tetapi dengan 19, dan mengeluarkannya dengan cara yang sama, hasilnya akan sama: kekacauan penuh dalam versi 32-bit, dan nol untuk semua <code>float</code> di 64-bit.  Yaitu  intinya tentu saja di ABI, tetapi tidak dalam penggunaan register untuk mengajukan argumen. <br><br><div class="spoiler">  <b class="spoiler_title">Ya, tentu saja, itu benar</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Tidak benar untuk melewatkan instance kelas dengan konstruktor nontrivial atau destruktor sebagai argumen yang tidak disebutkan namanya.  Kecuali, tentu saja, nasib kode ini menggairahkan Anda setidaknya sedikit lebih dari "kompilasi dan jalankan di sini dan sekarang." <br><br><div class="spoiler">  <b class="spoiler_title">Kode tidak valid</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Dentang lebih keras dari semua.  Dia hanya menolak untuk mengkompilasi kode ini karena argumen kedua, <code>va_arg</code> bukan tipe POD, dan memperingatkan bahwa program akan <code>va_arg</code> saat startup. <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan dentang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  Jadi, jika Anda masih mengkompilasi dengan <code>-Wno-non-pod-varargs</code> . <br><br>  <b>MSVC</b> memperingatkan bahwa penggunaan tipe dengan konstruktor non-sepele dalam hal ini tidak portabel. <br><br><div class="spoiler">  <b class="spoiler_title">Peringatan dari MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Tetapi kode mengkompilasi dan berjalan dengan benar.  Berikut ini diperoleh di konsol: <br><br><div class="spoiler">  <b class="spoiler_title">Peluncuran hasil</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Yaitu  salinan dibuat hanya pada saat memanggil <code>va_arg</code> , dan argumennya, ternyata, dilewatkan dengan referensi.  Entah bagaimana itu tidak jelas, tetapi Standar mengizinkan. <br><br>  <b>gcc 6.3.0</b> mengkompilasi tanpa satu komentar.  Outputnya sama: <br><br><div class="spoiler">  <b class="spoiler_title">Peluncuran hasil</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> juga tidak memperingatkan tentang apa pun, tetapi perilaku berubah: <br><br><div class="spoiler">  <b class="spoiler_title">Peluncuran hasil</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Yaitu  versi kompiler ini meneruskan argumen dengan nilai, dan ketika dipanggil, <code>va_arg</code> membuat salinan lain.  Akan menyenangkan untuk mencari perbedaan ini ketika beralih dari versi ke-6 ke gcc jika konstruktor / destruktor memiliki efek samping. <br><br>  Omong-omong, jika Anda secara eksplisit lulus dan meminta referensi ke kelas: <br><br><div class="spoiler">  <b class="spoiler_title">Kode salah lain</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  maka semua kompiler akan melakukan kesalahan.  Seperti yang disyaratkan oleh Standar. <br><br>  Secara umum, jika Anda benar-benar ingin, lebih baik memberikan argumen dengan pointer. <br><br><div class="spoiler">  <b class="spoiler_title">Seperti ini</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  Resolusi Kelebihan dan Fungsi Variabel </h3><br>  Di satu sisi, semuanya sederhana: mencocokkan dengan elipsis lebih buruk daripada mencocokkan dengan argumen bernama biasa, bahkan dalam kasus konversi tipe standar atau yang ditentukan pengguna. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh yang berlebihan</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Peluncuran hasil</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Tetapi ini hanya berfungsi sampai panggilan ke <code>foo</code> tanpa argumen perlu dipertimbangkan secara terpisah. <br><br><div class="spoiler">  <b class="spoiler_title">Panggil foo tanpa argumen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Output kompiler</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Semuanya sesuai dengan Standar: tidak ada argumen - tidak ada perbandingan dengan elipsis, dan ketika kelebihan diselesaikan, fungsi variatif menjadi tidak lebih buruk dari yang biasanya. <br><br><h3>  Namun kapan layak menggunakan fungsi variabel </h3><br>  Nah, fungsi variatif terkadang tidak berperilaku sangat jelas dan dalam konteks C ++ dapat dengan mudah berubah menjadi portabel yang buruk.  Ada banyak tips di Internet seperti "Jangan membuat atau menggunakan fungsi variabel C", tetapi mereka tidak akan menghapus dukungan mereka dari Standar C ++.  Jadi ada beberapa manfaat dari fitur ini?  Baik di sana. <br><br><ul><li>  Kasus yang paling umum dan jelas adalah kompatibilitas ke belakang.  Di sini saya akan menyertakan penggunaan perpustakaan C pihak ketiga (kasus saya dengan JNI) dan penyediaan API C untuk implementasi C ++. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Kegagalan Substitusi Bukan Kesalahan">SFINAE</a> .  Di sini, sangat berguna bahwa dalam C ++ fungsi variabel tidak harus memiliki nama argumen, dan ketika menyelesaikan fungsi yang kelebihan beban, fungsi variabel dianggap sebagai yang terakhir (jika ada setidaknya satu argumen).  Dan seperti fungsi lainnya, fungsi variabel hanya dapat dideklarasikan, tetapi tidak pernah dipanggil. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Meskipun dalam C ++ 14 Anda dapat melakukan sedikit berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh lain</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  Dan dalam hal ini sudah perlu untuk menonton dengan apa argumen <code>detect(...)</code> dapat dipanggil.  Saya lebih suka mengubah beberapa baris dan menggunakan alternatif modern untuk fungsi variabel, tanpa semua kekurangannya. <br></li></ul><br><h3>  Templat varian atau cara membuat fungsi dari sejumlah argumen arbitrer di C ++ modern </h3><br>  Gagasan templat variabel diajukan oleh Douglas Gregor, Jaakko Järvi dan Gary Powell pada tahun 2004, yaitu  7 tahun sebelum penerapan standar C ++ 11, di mana templat variabel ini didukung secara resmi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standar mencakup revisi ketiga proposal mereka, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejak awal, templat variabel dibuat sehingga pemrogram memiliki kesempatan untuk membuat Fungsi tipe-aman (dan portabel!) Dari sejumlah argumen yang berubah-ubah. </font><font style="vertical-align: inherit;">Tujuan lain adalah untuk menyederhanakan dukungan untuk templat kelas dengan sejumlah parameter variabel, tetapi sekarang kita hanya berbicara tentang fungsi variabel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templat variabel membawa tiga konsep baru ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter Template paket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template parameter pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - adalah template parameter, bukannya yang dimungkinkan untuk mentransfer (termasuk 0) jumlah argumen template;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket parameter fungsi ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket parameter fungsi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - karenanya, ini adalah parameter fungsi yang mengambil (termasuk 0) jumlah argumen fungsi;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan perluasan paket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekspansi paket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) adalah satu-satunya hal yang dapat dilakukan dengan paket parameter.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> —   , <code>Args ... args</code> —   ,  <code>args...</code> —    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar lengkap di mana dan bagaimana paket parameter dapat diperluas diberikan dalam Standar itu sendiri </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan dalam konteks diskusi fungsi variabel, cukup untuk mengatakan bahwa:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket parameter fungsi dapat diperluas ke daftar argumen fungsi lain</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau ke daftar inisialisasi</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau ke daftar tangkap lambda</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket parameter fungsi lain dapat diperluas dalam ekspresi konvolusi</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvolusi muncul di C ++ 14 dan bisa unary dan binary, kanan dan kiri. </font><font style="vertical-align: inherit;">Deskripsi paling lengkap, seperti biasa, ada dalam Standar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedua jenis paket parameter dapat diperluas menjadi sizeof ... operator</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam mengungkapkan paket elipsis eksplisit diperlukan untuk mendukung berbagai template ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pola</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) pengungkapan dan untuk menghindari ambiguitas ini.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Sebagai contoh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> —      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> — ,     —   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh implementasi printf menggunakan templat variabel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang telah saya sebutkan, templat variabel juga dibuat sebagai pengganti langsung untuk fungsi variabel C. Penulis templat ini sendiri mengusulkan versi yang sangat sederhana namun aman bagi jenisnya </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- salah satu fungsi variabel pertama dalam C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf on templates</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya curiga, maka pola enumerasi argumen variabel ini muncul - melalui panggilan rekursif fungsi yang kelebihan beban. </font><font style="vertical-align: inherit;">Tapi saya masih lebih suka opsi tanpa rekursi.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf pada template dan tanpa rekursi</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resolusi Kelebihan dan Fungsi Templat Variabel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika menyelesaikan, fungsi variatif ini dianggap, setelah yang lain, sebagai standar dan paling tidak terspesialisasi. </font><font style="vertical-align: inherit;">Tetapi tidak ada masalah dalam kasus panggilan tanpa argumen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang berlebihan</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peluncuran hasil</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kelebihan beban diselesaikan, fungsi templat variabel hanya dapat mem-bypass fungsi variabel C (meskipun mengapa mencampurnya?). </font><font style="vertical-align: inherit;">Kecuali - tentu saja! </font><font style="vertical-align: inherit;">- panggilan tanpa argumen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan tanpa argumen</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peluncuran hasil</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada perbandingan dengan elipsis - fungsi yang sesuai hilang, tidak ada perbandingan dengan elipsis - dan fungsi templat lebih rendah daripada yang non-templat. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catatan singkat tentang kecepatan fungsi templat variabel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahun 2008, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loïc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengajukan proposal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kepada Komite Standardisasi C ++ </font><font style="vertical-align: inherit;">, di mana ia menunjukkan dalam praktiknya bahwa fungsi templat variabel bekerja lebih lambat daripada fungsi serupa, argumennya adalah daftar inisialisasi ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Dan meskipun ini bertentangan dengan pembenaran teoretis dari penulis itu sendiri, Joli mengusulkan untuk mengimplementasikannya </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tepatnya dengan bantuan daftar inisialisasi, dan bukan dengan templat variabel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun sudah pada tahun 2009, bantahan muncul. </font><font style="vertical-align: inherit;">Dalam tes Joli, "kesalahan serius" ditemukan (tampaknya, bahkan untuk dirinya sendiri). </font><font style="vertical-align: inherit;">Tes baru (lihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) menunjukkan bahwa fungsi templat variabel masih lebih cepat, dan terkadang signifikan. </font><font style="vertical-align: inherit;">Yang tidak mengherankan sejak itu </font><font style="vertical-align: inherit;">daftar inisialisasi membuat salinan elemen-elemennya, dan untuk templat variabel Anda dapat menghitung banyak pada tahap kompilasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun demikian, dalam C ++ 11 dan standar berikutnya </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merupakan fungsi templat biasa, sejumlah argumen arbitrer yang diteruskan melalui daftar inisialisasi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ringkasan dan kesimpulan singkat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi, fungsi variabel C-style: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka tidak tahu jumlah argumen mereka atau tipenya. </font><font style="vertical-align: inherit;">Pengembang harus menggunakan bagian dari argumen ke fungsi untuk meneruskan informasi tentang sisanya.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara implisit meningkatkan jenis argumen yang tidak disebutkan namanya (dan yang terakhir disebutkan). </font><font style="vertical-align: inherit;">Jika Anda melupakannya, Anda mendapatkan perilaku yang tidak jelas.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mereka mempertahankan kompatibilitas ke belakang dengan C murni dan karena itu tidak mendukung lewat argumen dengan referensi. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum C ++ 11, argumen bukan dari </font><font style="vertical-align: inherit;">tipe </font></font><abbr title="Data lama polos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak didukung </font><font style="vertical-align: inherit;">, dan karena C ++ 11, dukungan untuk tipe non-sepele diserahkan kepada kebijaksanaan kompilator.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perilaku kode tergantung pada kompiler dan versinya. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya penggunaan fungsi variabel yang diizinkan adalah berinteraksi dengan C API dalam kode C ++. </font><font style="vertical-align: inherit;">Untuk yang lainnya, termasuk </font></font><abbr title="Kegagalan Substitusi Bukan Kesalahan"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ada fungsi templat variabel yang:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketahui jumlah dan jenis semua argumen mereka. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketik aman, jangan mengubah jenis argumen mereka. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mereka mendukung lewat argumen dalam bentuk apa pun - dengan nilai, dengan pointer, dengan referensi, dengan tautan universal. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti fungsi C ++ lainnya, tidak ada batasan pada tipe argumen. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi templat variabel dapat lebih verbose dibandingkan dengan rekanan gaya-C dan kadang-kadang bahkan membutuhkan versi non-templat sendiri yang berlebihan (traversal argumen rekursif). </font><font style="vertical-align: inherit;">Mereka lebih sulit untuk membaca dan menulis. </font><font style="vertical-align: inherit;">Tetapi semua ini lebih dari dibayar dengan tidak adanya kekurangan yang terdaftar dan adanya keuntungan yang terdaftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, kesimpulannya sederhana: fungsi variatif dalam gaya C tetap di C ++ hanya karena kompatibilitas ke belakang, dan mereka menawarkan berbagai pilihan untuk menembak kaki Anda. </font><font style="vertical-align: inherit;">Dalam C ++ modern, sangat disarankan untuk tidak menulis yang baru dan, jika mungkin, tidak menggunakan fungsi variabel C yang ada. </font><font style="vertical-align: inherit;">Fungsi templat variabel milik dunia C ++ modern dan jauh lebih aman. </font><font style="vertical-align: inherit;">Gunakan itu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sastra dan Sumber </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, Perpustakaan C Standar</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan dan Dennis M. Ritchie, Bahasa Pemrograman C, Edisi 1</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan dan Dennis M. Ritchie, Bahasa Pemrograman C, Edisi ke-2</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standar C11, konsep N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standar C ++ 98</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standar C ++ 03</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 Standar, konsep N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standar C ++ 14, konsep N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 Standar, konsep N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat mudah untuk menemukan dan mengunduh versi elektronik dari buku-buku yang disebutkan di internet. </font><font style="vertical-align: inherit;">Tapi saya tidak yakin itu legal, jadi saya tidak memberikan tautan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430064/">https://habr.com/ru/post/id430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430052/index.html">Mengapa penting bagi pengembang perangkat keras untuk melakukan cusdev berkualitas</a></li>
<li><a href="../id430054/index.html">HolyJS 2018 Moskow: siaran online gratis, pesta dan rap sains dan teknologi</a></li>
<li><a href="../id430058/index.html">Proses gelombang dalam saluran hidrolik. Dasar-dasarnya</a></li>
<li><a href="../id430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - keajaiban pemrograman</a></li>
<li><a href="../id430062/index.html">Layanan microser. Pengembangan dan pola refactoring dengan contoh-contoh Java</a></li>
<li><a href="../id430068/index.html">Urutan kepompong</a></li>
<li><a href="../id430070/index.html">Tumpukan dan antrian adalah dua paradigma buruk dan apa yang bisa dilakukan untuk itu</a></li>
<li><a href="../id430072/index.html">Server-Sisi Swift Meremehkan: Wawancara dengan Paul Hudson</a></li>
<li><a href="../id430074/index.html">Betapa aku hampir ketahuan virus mencoba menjual sepatu bot</a></li>
<li><a href="../id430076/index.html">Siaran gratis DotNext 2018 Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>