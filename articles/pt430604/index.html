<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèΩ üé≤ üßìüèø Tecnologias usadas no analisador de c√≥digo PVS-Studio para procurar erros e poss√≠veis vulnerabilidades üóª üóª üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma breve descri√ß√£o das tecnologias usadas na ferramenta PVS-Studio que podem efetivamente detectar um grande n√∫mero de padr√µes de erros e poss√≠veis v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tecnologias usadas no analisador de c√≥digo PVS-Studio para procurar erros e poss√≠veis vulnerabilidades</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Tecnologia e magia"></div><br>  Uma breve descri√ß√£o das tecnologias usadas na ferramenta PVS-Studio que podem efetivamente detectar um grande n√∫mero de padr√µes de erros e poss√≠veis vulnerabilidades.  O artigo descreve a implementa√ß√£o do analisador para c√≥digo C e C ++, no entanto, as informa√ß√µes acima tamb√©m s√£o v√°lidas para os m√≥dulos respons√°veis ‚Äã‚Äãpela an√°lise de c√≥digo C # e Java. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Existem conceitos err√¥neos de que os analisadores de c√≥digo est√°tico s√£o programas bastante simples, com base na pesquisa de padr√µes de c√≥digo usando express√µes regulares.  Isso est√° longe da verdade.  Al√©m disso, identificar a grande maioria dos erros usando express√µes regulares simplesmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o √© poss√≠vel</a> . <br><br>  O erro surgiu com base na experi√™ncia dos programadores ao trabalhar com algumas ferramentas que existiam 10 a 20 anos atr√°s.  O trabalho das ferramentas geralmente se resumia a encontrar padr√µes perigosos de c√≥digo e fun√ß√µes como <i>strcpy</i> , <i>strcat</i> , etc.  Como representante dessa classe de ferramentas, pode ser chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RATS</a> . <br><br>  Tais ferramentas, embora pudessem ser √∫teis, eram geralmente est√∫pidas e ineficazes.  √â a partir desses tempos que muitos programadores ainda t√™m mem√≥rias que os analisadores est√°ticos s√£o ferramentas muito in√∫teis que interferem mais no trabalho do que em ajud√°-lo. <br><br>  O tempo passou e os analisadores est√°ticos come√ßaram a constituir solu√ß√µes complexas que realizam an√°lises detalhadas do c√≥digo e encontram erros que permanecem no c√≥digo, mesmo ap√≥s uma cuidadosa revis√£o do c√≥digo.  Infelizmente, devido √† experi√™ncia negativa do passado, muitos programadores ainda consideram a metodologia de an√°lise est√°tica in√∫til e n√£o t√™m pressa em introduzi-la no processo de desenvolvimento. <br><br>  Neste artigo, tentarei corrigir um pouco a situa√ß√£o.  Pe√ßo aos leitores que demorem 15 minutos para se familiarizar com as tecnologias usadas no analisador de c√≥digo est√°tico PVS-Studio para detectar erros.  Talvez depois disso, voc√™ d√™ uma nova olhada nas ferramentas de an√°lise est√°tica e deseje aplic√°-las em seu trabalho. <br><br><h2>  An√°lise de fluxo de dados </h2><br>  A an√°lise do fluxo de dados permite encontrar uma variedade de erros.  Entre eles: sair dos limites de uma matriz, vazamentos de mem√≥ria, sempre condi√ß√µes verdadeiras / falsas, desreferenciar um ponteiro nulo e assim por diante. <br><br>  Al√©m disso, a an√°lise de dados pode ser usada para procurar situa√ß√µes em que dados n√£o verificados que vieram de fora do programa s√£o usados.  Um invasor pode preparar esse conjunto de dados de entrada para que o programa funcione da maneira que precisa.  Em outras palavras, ele pode usar o erro de controle de entrada insuficiente como uma vulnerabilidade.  Para procurar o uso de dados n√£o verificados no PVS-Studio, o diagn√≥stico especializado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V1010 foi</a> implementado e continua a melhorar. <br><br>  A an√°lise do fluxo de dados (An√°lise de fluxo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> ) √© calcular os poss√≠veis valores das vari√°veis ‚Äã‚Äãem v√°rios pontos de um programa de computador.  Por exemplo, se o ponteiro for desreferenciado e for sabido que neste momento pode ser zero, isso √© um erro e o analisador est√°tico o reportar√°. <br><br>  Vejamos um exemplo pr√°tico de uso da an√°lise de fluxo de dados para procurar erros.  √Ä nossa frente est√° uma fun√ß√£o do projeto Protocol Buffers (protobuf), projetada para verificar a corre√ß√£o da data. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  O analisador PVS-Studio detectou dois erros l√≥gicos na fun√ß√£o ao mesmo tempo e exibe as seguintes mensagens: <br><br><ul><li>  V547 / CWE-571 A express√£o 'time.month &lt;= kDaysInMonth [time.month] + 1' sempre √© verdadeira.  time.cc 83 </li><li>  V547 / CWE-571 A express√£o 'time.month &lt;= kDaysInMonth [time.month]' sempre √© verdadeira.  time.cc 85 </li></ul><br>  Observe a subexpress√£o ‚Äútime.month &lt;1 ||  time.month&gt; 12 ".  Se o valor do <i>m√™s</i> estiver fora do intervalo [1..12], a fun√ß√£o interromper√° o trabalho.  O analisador leva isso em considera√ß√£o e sabe que, se a segunda <i>instru√ß√£o if</i> come√ßar a ser executada, o valor do <i>m√™s</i> estar√° exatamente no intervalo [1..12].  Da mesma forma, ele conhece o leque de outras vari√°veis ‚Äã‚Äã(ano, dia etc.), mas elas n√£o s√£o interessantes para n√≥s agora. <br><br>  Agora, vamos dar uma olhada em dois operadores id√™nticos para acessar os elementos da matriz: <i>kDaysInMonth [time.month]</i> . <br><br>  A matriz √© definida estaticamente e o analisador conhece os valores de todos os seus elementos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Como os meses s√£o numerados de 1, o analisador n√£o considera 0 no in√≠cio da matriz.  Acontece que um valor no intervalo [28..31] pode ser extra√≠do da matriz. <br><br>  Dependendo se o ano √© bissexto ou n√£o, √© adicionado 1 ao n√∫mero de dias, mas isso tamb√©m n√£o √© interessante para n√≥s agora.  As compara√ß√µes s√£o importantes: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  O intervalo [1..12] (n√∫mero do m√™s) √© comparado com o n√∫mero de dias no m√™s. <br><br>  Considerando que, no primeiro caso, o m√™s √© sempre fevereiro ( <i>time.month == 2</i> ), obtemos que os seguintes intervalos s√£o comparados: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Como voc√™ pode ver, o resultado da compara√ß√£o √© sempre verdadeiro, e √© sobre isso que o analisador PVS-Studio alerta.  De fato, o c√≥digo cont√©m dois erros de digita√ß√£o id√™nticos.  O lado esquerdo da express√£o deve usar um membro da classe <i>day</i> , e n√£o um <i>m√™s</i> . <br><br>  O c√≥digo correto deve ser assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  O erro discutido aqui tamb√©m foi descrito anteriormente no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">31 de fevereiro</a> ". <br><br><h2>  Execu√ß√£o simb√≥lica </h2><br>  Na se√ß√£o anterior, consideramos um m√©todo em que o analisador calcula os poss√≠veis valores das vari√°veis.  No entanto, para encontrar alguns erros, n√£o √© necess√°rio conhecer os valores das vari√°veis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execu√ß√£o simb√≥lica</a> significa resolver equa√ß√µes em forma simb√≥lica. <br><br>  N√£o encontrei uma demonstra√ß√£o adequada em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados de erros</a> , portanto, considere um exemplo de c√≥digo sint√©tico. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  O analisador PVS-Studio gera um aviso V609 / CWE-369 Dividir por zero.  Denominador 'A - B' == 0. test.cpp 12 <br><br>  Os valores das vari√°veis <i>A</i> e <i>B s√£o</i> desconhecidos para o analisador.  Mas o analisador sabe que, no momento do c√°lculo da express√£o <i>10 / (A - B), as</i> vari√°veis <i>A</i> e <i>B</i> s√£o iguais.  Portanto, a divis√£o por 0 ocorrer√°. <br><br>  Eu disse que os valores de <i>A</i> e <i>B s√£o</i> desconhecidos.  Para o caso geral, isso √© verdade.  No entanto, se o analisador vir uma chamada de fun√ß√£o com valores espec√≠ficos dos argumentos reais, isso ser√° levado em considera√ß√£o.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  O analisador PVS-Studio alerta para divis√£o por zero: V609 CWE-628 Divida por zero.  Denominador 'X' == 0. A fun√ß√£o 'Div' processa o valor '[0..4]'.  Inspecione o primeiro argumento.  Verifique as linhas: 106, 110. consoleapplication2017.cpp 106 <br><br>  Uma mistura de tecnologias j√° funciona aqui: an√°lise de fluxo de dados, execu√ß√£o simb√≥lica e anota√ß√£o autom√°tica de m√©todo (discutiremos essa tecnologia na pr√≥xima se√ß√£o).  O analisador v√™ que a vari√°vel <i>X √©</i> usada como um divisor na fun√ß√£o <i>Div</i> .  Com base nisso, uma anota√ß√£o especial √© criada automaticamente para a fun√ß√£o <i>Div</i> .  Tamb√©m √© levado em considera√ß√£o que um intervalo de valores [0..4] √© passado para a fun√ß√£o como argumento <i>X.</i>  O analisador conclui que a divis√£o por 0 deve ocorrer. <br><br><h2>  Anota√ß√µes de m√©todo </h2><br>  Nossa equipe anotou milhares de fun√ß√µes e classes fornecidas em: <br><br><ul><li>  Winapi </li><li>  Biblioteca padr√£o C </li><li>  biblioteca de modelos padr√£o (STL), </li><li>  glibc (Biblioteca GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  e assim por diante </li></ul><br>  Todas as fun√ß√µes s√£o anotadas manualmente, o que permite definir muitas caracter√≠sticas importantes em termos de localiza√ß√£o de erros.  Por exemplo, √© especificado que o tamanho do buffer passado para a fun√ß√£o <i>fread</i> n√£o deve ser menor que o n√∫mero de bytes planejados para serem lidos no arquivo.  A rela√ß√£o entre o segundo, o terceiro argumento e o valor que a fun√ß√£o pode retornar tamb√©m √© indicada.  Tudo se parece com isso: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: marca√ß√£o de fun√ß√£o"></div><br>  Gra√ßas a esta anota√ß√£o, o c√≥digo a seguir, que usa a fun√ß√£o <i>fread</i> , revelar√° imediatamente dois erros. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Avisos do PVS-Studio: <ul><li>  V512 CWE-119 Uma chamada da fun√ß√£o 'fread' levar√° ao estouro do buffer 'buf'.  test.cpp 116 </li><li>  √â poss√≠vel satura√ß√£o da matriz V557 CWE-787.  O valor do √≠ndice 'i' pode chegar a 1000. test.cpp 117 </li></ul><br>  Primeiro, o analisador multiplicou o segundo e o terceiro argumento real e calculou que a fun√ß√£o pode ler at√© 1000 bytes de dados.  Nesse caso, o tamanho do buffer √© de apenas 100 bytes e pode exceder. <br><br>  Em segundo lugar, como a fun√ß√£o pode ler at√© 1000 bytes, o intervalo de valores poss√≠veis da vari√°vel <i>i</i> √© [0..1000].  Por conseguinte, o acesso √† matriz pode ocorrer no √≠ndice errado. <br><br>  Vejamos outro exemplo simples de erro, cuja detec√ß√£o foi poss√≠vel gra√ßas √† marca√ß√£o da fun√ß√£o <i>memset</i> .  Aqui est√° um trecho de c√≥digo do projeto CryEngine V. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  O analisador PVS-Studio encontrou um erro de digita√ß√£o: V575 A fun√ß√£o 'memset' processa elementos '0'.  Inspecione o terceiro argumento.  crythreadutil_win32.h 294 <br><br>  Confundiu o 2¬∫ e o 3¬∫ argumento da fun√ß√£o.  Como resultado, a fun√ß√£o processa 0 bytes e n√£o faz nada.  O analisador percebe essa anomalia e avisa os programadores sobre isso.  Anteriormente, j√° descrevemos esse erro no artigo "A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">t√£o esperada verifica√ß√£o do CryEngine V</a> ". <br><br>  O analisador PVS-Studio n√£o se limita √†s anota√ß√µes que definimos manualmente.  Al√©m disso, ele tenta criar anota√ß√µes de maneira independente, estudando os corpos das fun√ß√µes.  Isso permite encontrar erros de uso inadequado de fun√ß√µes.  Por exemplo, o analisador lembra que uma fun√ß√£o pode retornar nullptr.  Se o ponteiro retornado por esta fun√ß√£o for usado sem verifica√ß√£o preliminar, o analisador avisar√° sobre isso.  Um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Aviso: V522 CWE-690 Pode haver desreferencia√ß√£o de um ponteiro nulo potencial 'Get ()'.  test.cpp 129 <br><br>  <b>Nota</b>  Voc√™ pode abordar a busca pelo erro apenas examinado da maneira oposta.  N√£o se lembre de nada e sempre que uma chamada para a fun√ß√£o <i>Get</i> for encontrada, analise-a conhecendo os argumentos reais.  Teoricamente, esse algoritmo permite encontrar mais erros, mas possui complexidade exponencial.  O tempo de an√°lise do programa aumenta centenas de milhares de vezes, e consideramos essa abordagem um beco sem sa√≠da do ponto de vista pr√°tico.  No PVS-Studio, estamos desenvolvendo a dire√ß√£o da anota√ß√£o autom√°tica de fun√ß√µes. <br><br><h2>  Correspond√™ncia de padr√µes </h2><br>  √Ä primeira vista, a tecnologia correspondente a um padr√£o pode parecer uma pesquisa com express√µes regulares.  De fato, n√£o √© assim, e tudo √© muito mais complicado. <br><br>  Em primeiro lugar, como eu j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse</a> , express√µes regulares geralmente n√£o t√™m valor.  Em segundo lugar, os analisadores n√£o funcionam com linhas de texto, mas com √°rvores de sintaxe, o que permite reconhecer padr√µes de erro mais complexos e de alto n√≠vel. <br><br>  Considere dois exemplos, um mais simples e outro mais complexo.  O primeiro erro que encontrei ao verificar o c√≥digo-fonte do Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  O analisador PVS-Studio reconhece o padr√£o de erro cl√°ssico associado ao equ√≠voco de um programador sobre a prioridade das opera√ß√µes em C ++: V593 / CWE-783 Considere revisar a express√£o do tipo 'A = B! = C'.  A express√£o √© calculada da seguinte forma: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  D√™ uma olhada nesta linha: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  O programador assume que uma atribui√ß√£o √© realizada no in√≠cio e somente ent√£o uma compara√ß√£o com <i>-1</i> .  De fato, a compara√ß√£o vem primeiro.  Cl√°ssico  Este erro √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrito</a> em mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> dedicado √† verifica√ß√£o do Android (consulte o cap√≠tulo "Outros erros"). <br><br>  Agora considere uma op√ß√£o de correspond√™ncia de padr√£o de n√≠vel superior. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V597 CWE-14 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'chunkBuffer'.  A fun√ß√£o RtlSecureZeroMemory () deve ser usada para apagar os dados particulares.  sha1.cpp 189 <br><br>  A ess√™ncia do problema √© que, depois de preencher um buffer com zeros usando a fun√ß√£o <i>memset</i> , esse buffer n√£o √© usado em nenhum lugar.  Ao compilar c√≥digo com sinalizadores de otimiza√ß√£o, o compilador decidir√° que essa chamada de fun√ß√£o √© redundante e a excluir√°.  Ele tem direito a isso, pois, do ponto de vista da linguagem C ++, chamar uma fun√ß√£o n√£o tem nenhum comportamento observ√°vel no programa.  Imediatamente ap√≥s preencher o buffer <i>chunkBuffer</i> , a fun√ß√£o <i>sha1ProcessChunk</i> termina.  Como o buffer √© criado na pilha, ap√≥s sair da fun√ß√£o, ele fica indispon√≠vel para uso.  Portanto, do ponto de vista do compilador, n√£o faz sentido preench√™-lo com zeros. <br><br>  Como resultado, em algum lugar da pilha permanecer√£o dados privados, o que pode causar problemas.  Este t√≥pico √© discutido em mais detalhes no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza segura de dados particulares</a> ". <br><br>  Este √© um exemplo de correspond√™ncia de padr√£o de alto n√≠vel.  Primeiro, o analisador deve estar ciente da exist√™ncia dessa falha de seguran√ßa, classificada de acordo com a Enumera√ß√£o de Fraqueza Comum como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-14: Remo√ß√£o de C√≥digo do Compilador para Limpar Buffers</a> . <br><br>  Em segundo lugar, ele deve encontrar no c√≥digo todos os locais onde o buffer √© criado na pilha, √© limpo usando a fun√ß√£o <i>memset</i> e n√£o √© usado em nenhum outro lugar. <br><br><h2>  Conclus√£o </h2><br>  Como voc√™ pode ver, a an√°lise est√°tica √© uma metodologia muito interessante e √∫til.  Ele permite eliminar um grande n√∫mero de erros e poss√≠veis vulnerabilidades nos est√°gios iniciais (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SAST</a> ).  Se voc√™ ainda n√£o est√° completamente imbu√≠do da an√°lise est√°tica, convido voc√™ a ler nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> , onde analisamos regularmente os erros encontrados usando o PVS-Studio em v√°rios projetos.  Voc√™ simplesmente n√£o pode permanecer indiferente. <br><br>  Teremos o maior prazer em ver sua empresa entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossos clientes</a> e ajudar a tornar seus aplicativos melhores, mais confi√°veis ‚Äã‚Äãe mais seguros. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologias usadas no analisador de c√≥digo PVS-Studio para encontrar erros e poss√≠veis vulnerabilidades</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430604/">https://habr.com/ru/post/pt430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430590/index.html">Na Alemanha, desenvolveu os requisitos para roteadores dom√©sticos</a></li>
<li><a href="../pt430592/index.html">Internet do cliente em uma m√°quina virtual isolada QEMU usando encapsulamento de porta em um canal SPICE</a></li>
<li><a href="../pt430596/index.html">Como preparar uma estrat√©gia de produto? Guia do gerente de produto</a></li>
<li><a href="../pt430600/index.html">Marte - do chocolate aos rob√¥s</a></li>
<li><a href="../pt430602/index.html">Vulnerabilidades nos contratos inteligentes Etherium. Exemplos de c√≥digo</a></li>
<li><a href="../pt430606/index.html">Webinar do Grupo IB: ‚ÄúInvestiga√ß√£o Forense de Artefatos RDP no Windows‚Äù</a></li>
<li><a href="../pt430610/index.html">Como se livrar com seguran√ßa de seus dispositivos eletr√¥nicos</a></li>
<li><a href="../pt430612/index.html">Como, na d√©cada de 1980, as pessoas baixavam jogos do r√°dio</a></li>
<li><a href="../pt430614/index.html">Sexta-feira negra de 2018 no Madrobots.</a></li>
<li><a href="../pt430616/index.html">Semin√°rio "Testes e Monitoramento", 27 de novembro de Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>