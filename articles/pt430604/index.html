<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏽 🎲 🧓🏿 Tecnologias usadas no analisador de código PVS-Studio para procurar erros e possíveis vulnerabilidades 🗻 🗻 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma breve descrição das tecnologias usadas na ferramenta PVS-Studio que podem efetivamente detectar um grande número de padrões de erros e possíveis v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tecnologias usadas no analisador de código PVS-Studio para procurar erros e possíveis vulnerabilidades</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Tecnologia e magia"></div><br>  Uma breve descrição das tecnologias usadas na ferramenta PVS-Studio que podem efetivamente detectar um grande número de padrões de erros e possíveis vulnerabilidades.  O artigo descreve a implementação do analisador para código C e C ++, no entanto, as informações acima também são válidas para os módulos responsáveis ​​pela análise de código C # e Java. <br><a name="habracut"></a><br><h2>  1. Introdução </h2><br>  Existem conceitos errôneos de que os analisadores de código estático são programas bastante simples, com base na pesquisa de padrões de código usando expressões regulares.  Isso está longe da verdade.  Além disso, identificar a grande maioria dos erros usando expressões regulares simplesmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não é possível</a> . <br><br>  O erro surgiu com base na experiência dos programadores ao trabalhar com algumas ferramentas que existiam 10 a 20 anos atrás.  O trabalho das ferramentas geralmente se resumia a encontrar padrões perigosos de código e funções como <i>strcpy</i> , <i>strcat</i> , etc.  Como representante dessa classe de ferramentas, pode ser chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RATS</a> . <br><br>  Tais ferramentas, embora pudessem ser úteis, eram geralmente estúpidas e ineficazes.  É a partir desses tempos que muitos programadores ainda têm memórias que os analisadores estáticos são ferramentas muito inúteis que interferem mais no trabalho do que em ajudá-lo. <br><br>  O tempo passou e os analisadores estáticos começaram a constituir soluções complexas que realizam análises detalhadas do código e encontram erros que permanecem no código, mesmo após uma cuidadosa revisão do código.  Infelizmente, devido à experiência negativa do passado, muitos programadores ainda consideram a metodologia de análise estática inútil e não têm pressa em introduzi-la no processo de desenvolvimento. <br><br>  Neste artigo, tentarei corrigir um pouco a situação.  Peço aos leitores que demorem 15 minutos para se familiarizar com as tecnologias usadas no analisador de código estático PVS-Studio para detectar erros.  Talvez depois disso, você dê uma nova olhada nas ferramentas de análise estática e deseje aplicá-las em seu trabalho. <br><br><h2>  Análise de fluxo de dados </h2><br>  A análise do fluxo de dados permite encontrar uma variedade de erros.  Entre eles: sair dos limites de uma matriz, vazamentos de memória, sempre condições verdadeiras / falsas, desreferenciar um ponteiro nulo e assim por diante. <br><br>  Além disso, a análise de dados pode ser usada para procurar situações em que dados não verificados que vieram de fora do programa são usados.  Um invasor pode preparar esse conjunto de dados de entrada para que o programa funcione da maneira que precisa.  Em outras palavras, ele pode usar o erro de controle de entrada insuficiente como uma vulnerabilidade.  Para procurar o uso de dados não verificados no PVS-Studio, o diagnóstico especializado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V1010 foi</a> implementado e continua a melhorar. <br><br>  A análise do fluxo de dados (Análise de fluxo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> ) é calcular os possíveis valores das variáveis ​​em vários pontos de um programa de computador.  Por exemplo, se o ponteiro for desreferenciado e for sabido que neste momento pode ser zero, isso é um erro e o analisador estático o reportará. <br><br>  Vejamos um exemplo prático de uso da análise de fluxo de dados para procurar erros.  À nossa frente está uma função do projeto Protocol Buffers (protobuf), projetada para verificar a correção da data. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  O analisador PVS-Studio detectou dois erros lógicos na função ao mesmo tempo e exibe as seguintes mensagens: <br><br><ul><li>  V547 / CWE-571 A expressão 'time.month &lt;= kDaysInMonth [time.month] + 1' sempre é verdadeira.  time.cc 83 </li><li>  V547 / CWE-571 A expressão 'time.month &lt;= kDaysInMonth [time.month]' sempre é verdadeira.  time.cc 85 </li></ul><br>  Observe a subexpressão “time.month &lt;1 ||  time.month&gt; 12 ".  Se o valor do <i>mês</i> estiver fora do intervalo [1..12], a função interromperá o trabalho.  O analisador leva isso em consideração e sabe que, se a segunda <i>instrução if</i> começar a ser executada, o valor do <i>mês</i> estará exatamente no intervalo [1..12].  Da mesma forma, ele conhece o leque de outras variáveis ​​(ano, dia etc.), mas elas não são interessantes para nós agora. <br><br>  Agora, vamos dar uma olhada em dois operadores idênticos para acessar os elementos da matriz: <i>kDaysInMonth [time.month]</i> . <br><br>  A matriz é definida estaticamente e o analisador conhece os valores de todos os seus elementos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Como os meses são numerados de 1, o analisador não considera 0 no início da matriz.  Acontece que um valor no intervalo [28..31] pode ser extraído da matriz. <br><br>  Dependendo se o ano é bissexto ou não, é adicionado 1 ao número de dias, mas isso também não é interessante para nós agora.  As comparações são importantes: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  O intervalo [1..12] (número do mês) é comparado com o número de dias no mês. <br><br>  Considerando que, no primeiro caso, o mês é sempre fevereiro ( <i>time.month == 2</i> ), obtemos que os seguintes intervalos são comparados: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Como você pode ver, o resultado da comparação é sempre verdadeiro, e é sobre isso que o analisador PVS-Studio alerta.  De fato, o código contém dois erros de digitação idênticos.  O lado esquerdo da expressão deve usar um membro da classe <i>day</i> , e não um <i>mês</i> . <br><br>  O código correto deve ser assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  O erro discutido aqui também foi descrito anteriormente no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">31 de fevereiro</a> ". <br><br><h2>  Execução simbólica </h2><br>  Na seção anterior, consideramos um método em que o analisador calcula os possíveis valores das variáveis.  No entanto, para encontrar alguns erros, não é necessário conhecer os valores das variáveis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execução simbólica</a> significa resolver equações em forma simbólica. <br><br>  Não encontrei uma demonstração adequada em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados de erros</a> , portanto, considere um exemplo de código sintético. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  O analisador PVS-Studio gera um aviso V609 / CWE-369 Dividir por zero.  Denominador 'A - B' == 0. test.cpp 12 <br><br>  Os valores das variáveis <i>A</i> e <i>B são</i> desconhecidos para o analisador.  Mas o analisador sabe que, no momento do cálculo da expressão <i>10 / (A - B), as</i> variáveis <i>A</i> e <i>B</i> são iguais.  Portanto, a divisão por 0 ocorrerá. <br><br>  Eu disse que os valores de <i>A</i> e <i>B são</i> desconhecidos.  Para o caso geral, isso é verdade.  No entanto, se o analisador vir uma chamada de função com valores específicos dos argumentos reais, isso será levado em consideração.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  O analisador PVS-Studio alerta para divisão por zero: V609 CWE-628 Divida por zero.  Denominador 'X' == 0. A função 'Div' processa o valor '[0..4]'.  Inspecione o primeiro argumento.  Verifique as linhas: 106, 110. consoleapplication2017.cpp 106 <br><br>  Uma mistura de tecnologias já funciona aqui: análise de fluxo de dados, execução simbólica e anotação automática de método (discutiremos essa tecnologia na próxima seção).  O analisador vê que a variável <i>X é</i> usada como um divisor na função <i>Div</i> .  Com base nisso, uma anotação especial é criada automaticamente para a função <i>Div</i> .  Também é levado em consideração que um intervalo de valores [0..4] é passado para a função como argumento <i>X.</i>  O analisador conclui que a divisão por 0 deve ocorrer. <br><br><h2>  Anotações de método </h2><br>  Nossa equipe anotou milhares de funções e classes fornecidas em: <br><br><ul><li>  Winapi </li><li>  Biblioteca padrão C </li><li>  biblioteca de modelos padrão (STL), </li><li>  glibc (Biblioteca GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  e assim por diante </li></ul><br>  Todas as funções são anotadas manualmente, o que permite definir muitas características importantes em termos de localização de erros.  Por exemplo, é especificado que o tamanho do buffer passado para a função <i>fread</i> não deve ser menor que o número de bytes planejados para serem lidos no arquivo.  A relação entre o segundo, o terceiro argumento e o valor que a função pode retornar também é indicada.  Tudo se parece com isso: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: marcação de função"></div><br>  Graças a esta anotação, o código a seguir, que usa a função <i>fread</i> , revelará imediatamente dois erros. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Avisos do PVS-Studio: <ul><li>  V512 CWE-119 Uma chamada da função 'fread' levará ao estouro do buffer 'buf'.  test.cpp 116 </li><li>  É possível saturação da matriz V557 CWE-787.  O valor do índice 'i' pode chegar a 1000. test.cpp 117 </li></ul><br>  Primeiro, o analisador multiplicou o segundo e o terceiro argumento real e calculou que a função pode ler até 1000 bytes de dados.  Nesse caso, o tamanho do buffer é de apenas 100 bytes e pode exceder. <br><br>  Em segundo lugar, como a função pode ler até 1000 bytes, o intervalo de valores possíveis da variável <i>i</i> é [0..1000].  Por conseguinte, o acesso à matriz pode ocorrer no índice errado. <br><br>  Vejamos outro exemplo simples de erro, cuja detecção foi possível graças à marcação da função <i>memset</i> .  Aqui está um trecho de código do projeto CryEngine V. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  O analisador PVS-Studio encontrou um erro de digitação: V575 A função 'memset' processa elementos '0'.  Inspecione o terceiro argumento.  crythreadutil_win32.h 294 <br><br>  Confundiu o 2º e o 3º argumento da função.  Como resultado, a função processa 0 bytes e não faz nada.  O analisador percebe essa anomalia e avisa os programadores sobre isso.  Anteriormente, já descrevemos esse erro no artigo "A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tão esperada verificação do CryEngine V</a> ". <br><br>  O analisador PVS-Studio não se limita às anotações que definimos manualmente.  Além disso, ele tenta criar anotações de maneira independente, estudando os corpos das funções.  Isso permite encontrar erros de uso inadequado de funções.  Por exemplo, o analisador lembra que uma função pode retornar nullptr.  Se o ponteiro retornado por esta função for usado sem verificação preliminar, o analisador avisará sobre isso.  Um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Aviso: V522 CWE-690 Pode haver desreferenciação de um ponteiro nulo potencial 'Get ()'.  test.cpp 129 <br><br>  <b>Nota</b>  Você pode abordar a busca pelo erro apenas examinado da maneira oposta.  Não se lembre de nada e sempre que uma chamada para a função <i>Get</i> for encontrada, analise-a conhecendo os argumentos reais.  Teoricamente, esse algoritmo permite encontrar mais erros, mas possui complexidade exponencial.  O tempo de análise do programa aumenta centenas de milhares de vezes, e consideramos essa abordagem um beco sem saída do ponto de vista prático.  No PVS-Studio, estamos desenvolvendo a direção da anotação automática de funções. <br><br><h2>  Correspondência de padrões </h2><br>  À primeira vista, a tecnologia correspondente a um padrão pode parecer uma pesquisa com expressões regulares.  De fato, não é assim, e tudo é muito mais complicado. <br><br>  Em primeiro lugar, como eu já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse</a> , expressões regulares geralmente não têm valor.  Em segundo lugar, os analisadores não funcionam com linhas de texto, mas com árvores de sintaxe, o que permite reconhecer padrões de erro mais complexos e de alto nível. <br><br>  Considere dois exemplos, um mais simples e outro mais complexo.  O primeiro erro que encontrei ao verificar o código-fonte do Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  O analisador PVS-Studio reconhece o padrão de erro clássico associado ao equívoco de um programador sobre a prioridade das operações em C ++: V593 / CWE-783 Considere revisar a expressão do tipo 'A = B! = C'.  A expressão é calculada da seguinte forma: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Dê uma olhada nesta linha: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  O programador assume que uma atribuição é realizada no início e somente então uma comparação com <i>-1</i> .  De fato, a comparação vem primeiro.  Clássico  Este erro é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrito</a> em mais detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> dedicado à verificação do Android (consulte o capítulo "Outros erros"). <br><br>  Agora considere uma opção de correspondência de padrão de nível superior. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V597 CWE-14 O compilador pode excluir a chamada de função 'memset', usada para liberar o buffer 'chunkBuffer'.  A função RtlSecureZeroMemory () deve ser usada para apagar os dados particulares.  sha1.cpp 189 <br><br>  A essência do problema é que, depois de preencher um buffer com zeros usando a função <i>memset</i> , esse buffer não é usado em nenhum lugar.  Ao compilar código com sinalizadores de otimização, o compilador decidirá que essa chamada de função é redundante e a excluirá.  Ele tem direito a isso, pois, do ponto de vista da linguagem C ++, chamar uma função não tem nenhum comportamento observável no programa.  Imediatamente após preencher o buffer <i>chunkBuffer</i> , a função <i>sha1ProcessChunk</i> termina.  Como o buffer é criado na pilha, após sair da função, ele fica indisponível para uso.  Portanto, do ponto de vista do compilador, não faz sentido preenchê-lo com zeros. <br><br>  Como resultado, em algum lugar da pilha permanecerão dados privados, o que pode causar problemas.  Este tópico é discutido em mais detalhes no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza segura de dados particulares</a> ". <br><br>  Este é um exemplo de correspondência de padrão de alto nível.  Primeiro, o analisador deve estar ciente da existência dessa falha de segurança, classificada de acordo com a Enumeração de Fraqueza Comum como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-14: Remoção de Código do Compilador para Limpar Buffers</a> . <br><br>  Em segundo lugar, ele deve encontrar no código todos os locais onde o buffer é criado na pilha, é limpo usando a função <i>memset</i> e não é usado em nenhum outro lugar. <br><br><h2>  Conclusão </h2><br>  Como você pode ver, a análise estática é uma metodologia muito interessante e útil.  Ele permite eliminar um grande número de erros e possíveis vulnerabilidades nos estágios iniciais (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SAST</a> ).  Se você ainda não está completamente imbuído da análise estática, convido você a ler nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> , onde analisamos regularmente os erros encontrados usando o PVS-Studio em vários projetos.  Você simplesmente não pode permanecer indiferente. <br><br>  Teremos o maior prazer em ver sua empresa entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossos clientes</a> e ajudar a tornar seus aplicativos melhores, mais confiáveis ​​e mais seguros. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Se você deseja compartilhar este artigo com um público que fala inglês, use o link para a tradução: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologias usadas no analisador de código PVS-Studio para encontrar erros e possíveis vulnerabilidades</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430604/">https://habr.com/ru/post/pt430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430590/index.html">Na Alemanha, desenvolveu os requisitos para roteadores domésticos</a></li>
<li><a href="../pt430592/index.html">Internet do cliente em uma máquina virtual isolada QEMU usando encapsulamento de porta em um canal SPICE</a></li>
<li><a href="../pt430596/index.html">Como preparar uma estratégia de produto? Guia do gerente de produto</a></li>
<li><a href="../pt430600/index.html">Marte - do chocolate aos robôs</a></li>
<li><a href="../pt430602/index.html">Vulnerabilidades nos contratos inteligentes Etherium. Exemplos de código</a></li>
<li><a href="../pt430606/index.html">Webinar do Grupo IB: “Investigação Forense de Artefatos RDP no Windows”</a></li>
<li><a href="../pt430610/index.html">Como se livrar com segurança de seus dispositivos eletrônicos</a></li>
<li><a href="../pt430612/index.html">Como, na década de 1980, as pessoas baixavam jogos do rádio</a></li>
<li><a href="../pt430614/index.html">Sexta-feira negra de 2018 no Madrobots.</a></li>
<li><a href="../pt430616/index.html">Seminário "Testes e Monitoramento", 27 de novembro de Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>