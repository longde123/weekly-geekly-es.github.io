<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 😚 💨 Kompilasi Kotlin: JetBrains VS ANTLR VS JavaCC 👨🏼‍✈️ 👩🏻‍🤝‍👨🏼 🌸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seberapa cepat Kotlin mem-parsing dan apa bedanya? JavaCC atau ANTLR? Apakah kode sumber JetBrains cocok? 

 Bandingkan, berfantasi dan heran. 

 tl; ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilasi Kotlin: JetBrains VS ANTLR VS JavaCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433000/"><img src="https://habrastorage.org/webt/cv/to/y3/cvtoy3lpibs4fm_1asygxcsdgse.jpeg" width="300" align="left"><br>  Seberapa cepat Kotlin mem-parsing dan apa bedanya?  JavaCC atau ANTLR?  Apakah kode sumber JetBrains cocok? <br><br>  Bandingkan, berfantasi dan heran. <br><a name="habracut"></a><br><h1>  tl; dr </h1><br>  <i>JetBrains terlalu sulit untuk diseret, ANTLR hype tetapi tiba-tiba lambat, dan JavaCC terlalu dini untuk dihapuskan.</i> <br><br>  Parsing file Kotlin sederhana dengan tiga implementasi berbeda: <br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br><h4>  Suatu hari yang cerah ... </h4><br>  Saya memutuskan untuk membangun penerjemah di GLSL dari beberapa bahasa yang nyaman.  Idenya adalah untuk memprogram shader secara langsung dalam ide tersebut dan mendapatkan dukungan IDE "gratis" - sintaks, debug, dan tes unit.  Ternyata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat nyaman</a> . <br><br>  Sejak saat itu, gagasan untuk menggunakan Kotlin tetap ada - Anda dapat menggunakan nama vec3 di dalamnya, lebih ketat dan lebih nyaman dalam IDE.  Selain itu, ini hype.  Meskipun, dari sudut pandang manajer internal saya, ini semua adalah alasan yang tidak mencukupi, ide itu muncul berulang kali sehingga saya memutuskan untuk menyingkirkannya hanya dengan mengimplementasikannya. <br><br>  <em>Kenapa tidak Jawa?</em>  <em>Tidak ada operator yang kelebihan, jadi sintaks dari aritmatika vektor akan terlalu berbeda dari yang biasa Anda lihat di game dev</em> <br><br><h4>  Otak Jet </h4><br>  Orang-orang dari JetBrains mengunggah kode kompiler mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke github</a> .  Cara menggunakannya, Anda bisa mengintip di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Pada awalnya saya menggunakan parser mereka bersama dengan analyzer, karena untuk menerjemahkan ke bahasa lain, Anda perlu tahu apa jenis variabel itu tanpa secara eksplisit menentukan jenis <code>val x = vec3()</code> .  Di sini jenis pembaca sudah jelas, tetapi dalam AST informasi ini tidak mudah diperoleh, terutama ketika variabel lain ada di sebelah kanan, atau pemanggilan fungsi. <br><br>  Di sini saya kecewa.  Peluncuran pertama pengurai pada file primitif membutuhkan waktu 3 detik (TIGA DETIK). <br><br> <code><b>Kotlin JetBrains parser</b> <br> first call elapsed : 3254.482ms <br> min time in next 10 calls: 70.071ms <br> min time in next 100 calls: 29.973ms <br> min time in next 1000 calls: 16.655ms <br> Whole time for 1111 calls: 40.888756 seconds <br></code> <br>  Waktu seperti itu memiliki ketidaknyamanan yang jelas berikut: <br><br><ol><li>  karena ditambah tiga detik untuk meluncurkan game atau aplikasi. </li><li>  selama pengembangan, saya menggunakan kelebihan shader panas dan melihat hasilnya segera setelah mengubah kode. </li><li>  Saya sering me-restart aplikasi dan senang bahwa itu dimulai cukup cepat (satu atau dua detik). </li></ol><br>  Ditambah tiga detik untuk memanaskan parser - ini tidak bisa diterima.  Tentu saja, segera menjadi jelas bahwa selama panggilan berikutnya, waktu parsing turun menjadi 50 ms dan bahkan 20 ms, yang menghilangkan (hampir) ketidaknyamanan No. 2 dari ekspresi.  Tetapi dua lainnya tidak pergi ke mana pun.  Selain itu, 50ms per file ditambah 2500ms per 50 file (satu shader adalah 1-2 file).  Bagaimana jika itu Android?  (Di sini kita hanya berbicara tentang waktu.) <br><br>  <i>Yang perlu diperhatikan adalah karya gila JIT.</i>  <i>Waktu parsing untuk file sederhana turun dari 70ms ke 16ms.</i>  <i>Yang berarti, pertama, JIT itu sendiri menghabiskan sumber daya, dan kedua, hasil pada JVM yang berbeda bisa sangat berbeda.</i> <br><br>  Dalam upaya untuk mencari tahu dari mana angka-angka ini berasal, ada opsi - gunakan parser mereka tanpa penganalisa.  Bagaimanapun, saya hanya perlu mengatur jenis dan ini dapat dilakukan dengan relatif mudah, sedangkan analisa JetBrains melakukan sesuatu yang jauh lebih kompleks dan mengumpulkan lebih banyak informasi.  Dan kemudian waktu mulai turun setengah (tapi hampir satu setengah detik masih layak), dan waktu panggilan berikutnya sudah jauh lebih menarik - dari 8 ms dalam sepuluh pertama hingga 0,9 ms di suatu tempat dalam ribuan. <br><br>  <code><b>Kotlin JetBrains parser (without analyzer)</b></code> <code><a href="">() <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></code> <br>  <em>Saya harus mengumpulkan hanya angka-angka seperti itu.</em>  <em>Waktu peluncuran pertama adalah penting saat memuat shader pertama.</em>  <em>Ini penting, karena di sini Anda tidak dapat mengalihkan perhatian pengguna saat shader dimuat di latar belakang, ia hanya menunggu.</em>  <em>Penurunan runtime penting untuk melihat dinamika itu sendiri, cara kerja JIT, seberapa efisien kita dapat memuat shader pada aplikasi yang hangat.</em> <em><br></em> <br>  Alasan utama untuk melihat parser JetBrains terutama adalah keinginan untuk menggunakan pengetik mereka.  Tetapi karena menolak itu menjadi opsi yang dibahas, Anda dapat mencoba menggunakan parser lain.  Selain itu, non-JetBrains kemungkinan besar akan jauh lebih kecil, lebih sedikit menuntut lingkungan, lebih mudah dengan dukungan dan dimasukkannya kode dalam proyek. <br><br><h4>  ANTLR </h4><br>  Tidak ada parser di JavaCC, tetapi pada hype ANTLR, seperti yang diharapkan, ada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> ). <br><br>  Tapi yang tak terduga adalah kecepatan.  3s yang sama untuk memuat (panggilan pertama) dan 140ms fantastis untuk panggilan berikutnya.  Di sini, bukan hanya peluncuran pertama yang berlangsung lama yang tidak menyenangkan, tetapi situasinya tidak diperbaiki.  Rupanya, orang-orang dari JetBrains melakukan sihir dengan membiarkan JIT mengoptimalkan kode mereka seperti itu.  Karena ANTLR tidak dioptimalkan sama sekali dari waktu ke waktu. <br><br>  <code><b>Kotlin ANTLR parser</b></code> <code><a href="">() <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></code> <br><h4>  Javacc </h4><br>  Secara umum, kami terkejut menolak layanan ANTLR.  Parsing tidak harus selama itu!  Tidak ada ambiguitas kosmis dalam tata bahasa Kotlin, dan saya memeriksanya pada file yang hampir kosong.  Jadi, inilah saatnya untuk mengungkap JavaCC lama, menyingsingkan lengan baju Anda, dan masih "melakukannya sendiri dan bagaimana caranya." <br><br>  Kali ini jumlahnya ternyata diharapkan, meskipun dibandingkan dengan alternatif - secara tak terduga menyenangkan. <br><br>  <code><b>Kotlin JavaCC parser</b></code> <code><a href="">() <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></code> <br>  <i>Pro tiba-tiba dari parser JavaCC Anda</i> <br>  Tentu saja, alih-alih menulis parser Anda sendiri, saya ingin menggunakan solusi yang sudah jadi.  Tetapi yang sudah ada memiliki kerugian besar: <br><br>  - kinerja (jeda saat membaca shader baru tidak dapat diterima, serta tiga detik pemanasan di awal) <br>  - runtime kotlin besar, saya bahkan tidak yakin apakah mungkin untuk mengemas parser ke dalam produk akhir <br>  - Omong-omong, dalam solusi saat ini dengan Groovy masalah yang sama - runtime membentang <br><br>  Sedangkan parser JavaCC yang dihasilkan adalah <br><br>  + kecepatan luar biasa di awal dan di proses <br>  + hanya beberapa kelas parser itu sendiri <br><br><h4>  Kesimpulan </h4><br>  JetBrains terlalu sulit untuk diseret, ANTLR hype tetapi tiba-tiba lambat, dan JavaCC terlalu dini untuk dihapuskan. <br><br>  Parsing file Kotlin sederhana dengan tiga implementasi berbeda: <br><br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br>  Pada titik tertentu, saya memutuskan untuk melihat ukuran toples dengan semua dependensinya.  JetBrains bagus seperti yang diharapkan, <strike>tetapi runtime ANTLR memukau dengan ukurannya</strike> . <br>  <i>UPDATE: Awalnya, saya menulis 15MB, tetapi seperti yang disarankan dalam komentar, jika Anda menghubungkan antlr4-runtime bukan antlr4, ukuran turun ke nilai yang diharapkan.</i>  <i>Meskipun parser JavaCC itu sendiri tetap 10 kali lebih kecil dari ANTLR (jika Anda menghapus semua kode sama sekali, kecuali parser itu sendiri).</i> <br>  Ukuran tabung seperti itu penting, tentu saja, untuk ponsel.  Tetapi itu juga penting untuk desktop, karena, pada kenyataannya, itu berarti jumlah kode tambahan yang dapat mengandung bug, yang harus diindeks oleh IDE, yang, pada kenyataannya, mempengaruhi kecepatan beban pertama dan kecepatan pemanasan.  Selain itu, untuk kode kompleks, ada sedikit harapan untuk menerjemahkan ke bahasa lain. <br>  Saya tidak mendesak Anda untuk menghitung kilobyte dan saya menghargai waktu dan kenyamanan programmer, tetapi tetap ada baiknya memikirkan penghematan, karena dengan begitu proyek menjadi canggung dan sulit dipertahankan. <br><br>  <i>Beberapa Kata Tentang ANTLR dan JavaCC</i> <br><br>  Fitur serius ANTLR adalah pemisahan tata bahasa dan kode.  Akan lebih baik jika tidak harus membayar mahal.  Ya, dan ini hanya penting untuk “pengembang serial tata bahasa,” dan untuk produk akhir ini tidak begitu penting, karena bahkan tata bahasa yang ada masih harus selesai untuk menulis kode Anda.  Plus, jika kita menghemat uang dan mengambil tata bahasa "pihak ketiga" - itu mungkin tidak nyaman, masih perlu dipahami secara menyeluruh, itu akan mengubah pohon itu sendiri.  Secara umum, JavaCC, tentu saja, mencampur lalat dan irisan daging, tetapi apakah itu benar-benar penting dan apakah itu sangat buruk? <br><br>  Fitur lain dari ANTLR adalah banyak platform target.  Tapi di sini Anda dapat melihat dari sisi lain - kode dari bawah JavaCC sangat sederhana.  Dan sangat sederhana ... siaran!  Tepat dengan kode khusus Anda - setidaknya dalam C #, setidaknya dalam JS. <br><br><h4>  PS </h4><br>  Semua kode ada di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/kravchik/yast</a> <br><br>  Hasil parsing adalah pohon yang dibangun di atas YastNode (ini adalah kelas yang sangat sederhana, pada kenyataannya - peta dengan metode yang mudah digunakan dan pengidentifikasi).  Tapi YastNode sebenarnya bukan "simpul bulat dalam ruang hampa."  Kelas inilah yang saya gunakan secara aktif, berdasarkan itu saya telah mengumpulkan beberapa alat - pengetik, beberapa penerjemah dan pengoptimal / inliner. <br><br>  Parser JavaCC belum mengandung semua tata bahasa, masih ada 10 persen yang tersisa, tetapi sepertinya itu tidak dapat mempengaruhi kinerja - saya memeriksa kecepatan ketika aturan ditambahkan, dan itu tidak berubah secara nyata.  Selain itu, saya sudah melakukan lebih dari yang saya butuhkan dan hanya mencoba untuk membagikan hasil yang tidak terduga yang ditemukan dalam proses. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433000/">https://habr.com/ru/post/id433000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432990/index.html">Lampu Kayu Edison yang Diaktifkan Suara. Harga masalah $ 5</a></li>
<li><a href="../id432992/index.html">Dia memakai headphone dan mati: kita berurusan dengan kematian aneh seorang anak sekolah di Rimbau</a></li>
<li><a href="../id432994/index.html">Vivaldi 2.2 - Kuantitas Mengubah ke Kualitas</a></li>
<li><a href="../id432996/index.html">Sedikit kamus internal di CPython (dan PyPy)</a></li>
<li><a href="../id432998/index.html">Cerita natal</a></li>
<li><a href="../id433002/index.html">Ayo dirimu sendiri ... atau aturan komunikasi dalam tim</a></li>
<li><a href="../id433004/index.html">Strategi migrasi awan yang kuat untuk tips 2019: 7</a></li>
<li><a href="../id433008/index.html">Perangkat USB adalah ancaman "mendadak"</a></li>
<li><a href="../id433010/index.html">Punya ide: sistem izin untuk paket npm</a></li>
<li><a href="../id433012/index.html">Mungkin saya hanya hidup karena dia: mengapa pasien dengan apnea bergantung pada program yang ditulis oleh seorang hacker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>