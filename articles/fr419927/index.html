<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÉ üê† üöö [DotNetBook] Exceptions: Type Architecture du syst√®me üåÑ ‚ÜôÔ∏è ‚ùÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec cet article, je continue de publier une s√©rie d'articles, dont le r√©sultat sera un livre sur le travail du .NET CLR, et du .NET en g√©n√©ral. Pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Exceptions: Type Architecture du syst√®me</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419927/"><p><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  Avec cet article, je continue de publier une s√©rie d'articles, dont le r√©sultat sera un livre sur le travail du .NET CLR, et du .NET en g√©n√©ral.  Pour les liens - bienvenue au chat. </p><br><h2 id="arhitektura-isklyuchitelnoy-situacii">  Architecture d'exception </h2><br><p> L'un des probl√®mes les plus importants concernant le sujet des exceptions est probablement la cr√©ation d'une architecture d'exception dans votre application.  Cette question est int√©ressante pour plusieurs raisons.  Pour moi, l'essentiel est l'apparente simplicit√© avec laquelle il n'est pas toujours √©vident de savoir quoi faire.  Cette propri√©t√© est inh√©rente √† toutes les constructions de base qui sont utilis√©es partout: elle est <code>IEnumerable</code> , et <code>IDisposable</code> et <code>IObservable</code> et d'autres.  D'une part, ils font signe par leur simplicit√©, en s'impliquant dans leur utilisation dans diverses situations.  Et d'autre part, ils sont pleins de tourbillons et de gu√©s, d'o√π, ne sachant pas comment parfois ne pas sortir du tout.  Et, peut-√™tre qu'en regardant le futur volume, votre question a m√ªri: alors qu'est-ce que c'est dans des situations exceptionnelles? </p><br><blockquote><h3>  Remarque </h3><br>  Le chapitre publi√© sur Habr√© n'est pas mis √† jour et, probablement, est un peu d√©pass√©.  Et par cons√©quent, veuillez vous tourner vers l'original pour un texte plus r√©cent: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livre CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub, table des mati√®res</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livre CLR: <a href="">GitHub, chapitre</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Version 0.5.2 livres, PDF: <a href="">version GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Mais pour en arriver √† des conclusions concernant la construction de l'architecture des classes de situations exceptionnelles, nous devons accumuler avec vous une certaine exp√©rience concernant leur classement.  Apr√®s tout, apr√®s avoir compris ce que nous allons traiter, comment et dans quelles situations le programmeur doit choisir le type d'erreur et dans lequel - faire le choix concernant la capture ou le saut d'exceptions, vous pouvez comprendre comment vous pouvez construire un syst√®me de type de telle mani√®re qu'il devienne √©vident pour votre code.  Par cons√©quent, nous essaierons de classer les situations exceptionnelles (non pas les types d'exceptions elles-m√™mes, mais pr√©cis√©ment les situations) selon divers crit√®res. </p><br><h3 id="po-teoreticheskoy-vozmozhnosti-perehvata-proektiruemogo-isklyucheniya">  Selon la possibilit√© th√©orique de rattraper l'exception projet√©e </h3><br><p>  En termes d'interception th√©orique, les exceptions peuvent facilement √™tre divis√©es en deux types: celles qui intercepteront avec pr√©cision et celles qui sont tr√®s susceptibles d'intercepter.  Pourquoi <em>avec un degr√© de probabilit√© √©lev√©</em> ?  Parce qu'il y aura toujours quelqu'un qui tentera d'intercepter, bien que cela n'ait pas d√ª √™tre compl√®tement fait. </p><br><p>  R√©v√©lons d'abord les caract√©ristiques du premier groupe: les exceptions qui devraient et vont se bloquer. </p><br><p>  Lorsque nous introduisons une exception de ce type, d'une part, nous informons le sous-syst√®me externe que nous sommes dans une position o√π d'autres actions au sein de nos donn√©es n'ont pas de sens.  D'un autre c√¥t√©, nous voulons dire que rien de global n'a √©t√© bris√© et si nous sommes supprim√©s, rien ne changera, et donc cette exception peut √™tre facilement intercept√©e pour am√©liorer la situation.  Cette propri√©t√© est tr√®s importante: elle d√©termine la criticit√© de l'erreur et la conviction que si vous interceptez l'exception et effacez simplement les ressources, vous pouvez ex√©cuter le code en toute s√©curit√©. </p><br><p>  Le deuxi√®me groupe, aussi √©trange que cela puisse para√Ætre, est responsable des exceptions qui n'ont pas besoin d'√™tre d√©tect√©es.  Ils ne peuvent √™tre utilis√©s que pour √©crire dans le journal des erreurs, mais pas pour corriger la situation.  L'exemple le plus simple est les exceptions de groupe <code>ArgumentException</code> et <code>NullReferenceException</code> .  En effet, dans une situation normale, vous ne devez pas, par exemple, intercepter l'exception <code>ArgumentNullException</code> car la source du probl√®me ici sera vous, et personne d'autre.  Si vous interceptez cette exception, vous supposez que vous avez fait une erreur et donn√© la m√©thode que vous ne pouviez pas lui donner: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  Dans cette m√©thode, nous essayons d'attraper une <code>ArgumentNullException</code> .  Mais √† mon avis, son interception semble tr√®s √©trange: jeter les bons arguments √† la m√©thode est enti√®rement notre pr√©occupation.  Il ne serait pas correct de r√©agir apr√®s coup: dans une telle situation, la chose la plus correcte qui puisse √™tre faite est de v√©rifier les donn√©es transmises √† l'avance, avant d'appeler la m√©thode, ou mieux encore, de construire le code de telle mani√®re que la r√©ception de param√®tres incorrects ne soit tout simplement pas possible. </p><br><p>  Un autre groupe est l'√©limination des erreurs fatales.  Si un certain cache est cass√© et que le fonctionnement du sous-syst√®me ne sera en aucun cas correct?  Il s'agit alors d'une erreur fatale et le code le plus proche de la pile ne sera pas garanti pour l'intercepter: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } catch (CacheCorreptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  Et que <code>CacheCorreptedException</code> soit une exception signifiant que "le cache sur le disque dur n'est pas coh√©rent".  Ensuite, il s'av√®re que si la cause d'une telle erreur est fatale pour le sous-syst√®me de mise en cache (par exemple, il n'y a pas d'autorisations sur le fichier de cache), alors le code suppl√©mentaire s'il ne peut pas recr√©er le cache avec la commande <code>RecreateCache</code> , et donc le fait d'attraper cette exception est une erreur en soi. </p><br><h3 id="po-fakticheskomu-perehvatu-isklyuchitelnoy-situacii">  Sur l'interception effective d'une exception </h3><br><p>  Une autre question qui arr√™te notre fuite de pens√©e dans les algorithmes de programmation est la compr√©hension: cela vaut-il la peine d'attraper ces exceptions ou d'autres ou vaut-il quelqu'un qui comprend de les laisser les traverser.  En traduisant dans le langage des termes, la question que nous devons r√©soudre est de distinguer les domaines de responsabilit√©.  Regardons le code suivant: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Laquelle des deux strat√©gies propos√©es est la plus correcte?  Le domaine de responsabilit√© est tr√®s important.  Initialement, il peut sembler que, puisque le travail de <code>WildInvestment</code> et sa coh√©rence d√©pendent enti√®rement de <code>WildStrategy</code> , si <code>WildInvestment</code> ignore simplement cette exception, il passera √† un niveau sup√©rieur et il n'y a pas besoin de faire autre chose.  Cependant, veuillez noter qu'il existe un probl√®me purement architectural: la m√©thode <code>Main</code> intercepte une exception d'une couche architecturale en invoquant une m√©thode architecturale diff√©rente.  √Ä quoi ressemble-t-il en termes d'utilisation?  Oui, en g√©n√©ral, cela ressemble √† ceci: </p><br><ul><li>  le souci de cette exception a √©t√© tout simplement d√©pass√© par nous; </li><li>  l'utilisateur de cette classe n'est pas s√ªr que cette exception soit lev√©e √† travers un certain nombre de m√©thodes devant nous sp√©cifiquement </li><li>  nous commen√ßons √† dessiner des d√©pendances inutiles, dont nous nous sommes d√©barrass√©s, provoquant une couche interm√©diaire. </li></ul><br><p>  Cependant, une autre conclusion d√©coule de cette conclusion: nous devons d√©finir la <code>catch</code> dans la m√©thode <code>DoSomethingWild</code> .  Et cela est quelque peu √©trange pour nous: <code>WildInvestment</code> semble √™tre tr√®s d√©pendant de quelqu'un.  C'est-√†-dire  si <code>PlayRussianRoulette</code> ne pouvait pas fonctionner, alors <code>DoSomethingWild</code> aussi: il n'a pas de code retour, mais il doit jouer √† la roulette.  Que faire dans une situation aussi d√©sesp√©r√©e?  La r√©ponse est en fait simple: √©tant dans une autre couche, <code>DoSomethingWild</code> devrait <code>DoSomethingWild</code> sa propre exception, qui fait r√©f√©rence √† cette couche et envelopper l'original comme source d'origine du probl√®me - dans <code>InnerException</code> : </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Passant l'exception √† une autre, nous transf√©rons essentiellement les probl√®mes d'une couche d'application √† une autre, ce qui rend son travail plus pr√©visible du point de vue de l'utilisateur de cette classe: la m√©thode <code>Main</code> . </p><br><h3 id="po-voprosam-pereispolzovaniya">  Pour les probl√®mes de r√©utilisation </h3><br><p>  Tr√®s souvent, nous sommes confront√©s √† une t√¢che difficile: d'une part, nous sommes trop paresseux pour cr√©er un nouveau type d'exception, et lorsque nous d√©cidons, il n'est pas toujours clair de quoi pousser: quel type prendre comme base comme base.  Mais ce sont pr√©cis√©ment ces d√©cisions qui d√©terminent toute l'architecture des situations exceptionnelles.  Passons en revue les solutions populaires et tirons quelques conclusions. </p><br><p>  Lorsque vous choisissez le type d'exceptions, vous pouvez essayer de prendre une solution d√©j√† existante: trouver une exception avec une signification similaire dans le nom et l'utiliser.  Par exemple, si on nous a donn√© une entit√© via un param√®tre qui ne nous convient pas, nous pouvons <code>InvalidArgumentException</code> une <code>InvalidArgumentException</code> , indiquant la cause de l'erreur dans Message.  Ce sc√©nario semble bon, surtout si l'on consid√®re que <code>InvalidArgumentException</code> fait partie du groupe d'exceptions qui ne sont pas soumises √† une capture obligatoire.  Mais choisir <code>InvalidDataException</code> sera mauvais si vous travaillez avec des donn√©es.  Tout simplement parce que ce type se trouve dans la zone <code>System.IO</code> , et ce n'est gu√®re ce que vous faites.  C'est-√†-dire  il s'av√®re que trouver le type existant parce que faire paresseusement le v√¥tre sera presque toujours la mauvaise approche.  Il n'y a presque aucune exception cr√©√©e pour le cercle g√©n√©ral des t√¢ches.  Presque tous sont cr√©√©s pour des situations sp√©cifiques et leur r√©utilisation sera une violation flagrante de l'architecture des situations exceptionnelles.  De plus, apr√®s avoir re√ßu une exception d'un certain type (par exemple, le m√™me <code>System.IO.InvalidDataException</code> ), l'utilisateur sera confus: d'une part, il verra la source du probl√®me dans <code>System.IO</code> comme un espace de noms d'exception, et de l'autre, un espace de noms compl√®tement diff√©rent pour le point de lancement.  De plus, en pensant aux r√®gles pour lever cette exception, il ira √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">referencesource.microsoft.com</a> et trouvera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tous les endroits o√π il est lev√©</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  Et il comprendra que <del>  juste quelqu'un a les mains tordues </del>  le choix du type d'exception le d√©routait, car la m√©thode qui lan√ßait l'exception n'√©tait pas impliqu√©e dans la compression. </p><br><p>  De plus, afin de simplifier la r√©utilisation, vous pouvez simplement prendre et cr√©er une seule exception en d√©clarant un champ <code>ErrorCode</code> avec un code d'erreur et vivre heureux pour toujours.  Il semblerait: une bonne solution.  Jetez la m√™me exception partout, d√©finissez le code, interceptez un seul <code>catch</code> augmentant ainsi la stabilit√© de l'application: et il n'y a plus rien √† faire.  Cependant, veuillez ne pas √™tre d'accord avec cette position.  En agissant de cette mani√®re tout au long de l'application, d'une part, bien s√ªr, vous simplifiez la vie.  Mais d'un autre c√¥t√©, vous vous d√©barrassez de la possibilit√© d'attraper un sous-groupe d'exceptions, uni par une caract√©ristique commune.  Comment cela se fait, par exemple, avec <code>ArgumentException</code> , qui sous lui-m√™me combine tout un groupe d'exceptions par h√©ritage.  Le deuxi√®me inconv√©nient grave est des feuilles de code trop grandes et illisibles qui organiseront le filtrage par code d'erreur.  Mais si vous prenez une situation diff√©rente: lorsque la finalisation de l'erreur ne devrait pas √™tre importante pour l'utilisateur final, l'introduction d'un type g√©n√©ralisant plus un code d'erreur semble d√©j√† une application beaucoup plus correcte: </p><br><pre> <code class="plaintext hljs">public class ParserException : Exception { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Le code qui prot√®ge l'appel de l'analyseur est presque toujours indiff√©rent pour quelle raison l'analyse a √©t√© bloqu√©e: le fait d'erreur lui-m√™me est important pour lui.  Cependant, si cela devient n√©anmoins important, l'utilisateur pourra toujours extraire le code d'erreur de la <code>ErrorCode</code> .  Pour ce faire, il n'est pas du tout n√©cessaire de rechercher les mots n√©cessaires par sous-cha√Æne dans <code>Message</code> . </p><br><p>  Si vous commencez par ignorer les probl√®mes de r√©utilisation, vous pouvez cr√©er un type d'exception pour chaque situation.  D'une part, cela semble logique: un type d'erreur est un type d'exception.  Cependant, ici, comme dans tout, l'essentiel n'est pas d'en faire trop: avoir des op√©rations exceptionnelles sur chaque point de sortie, vous causez des probl√®mes d'interception: le code de la m√©thode appelante sera surcharg√© de blocs <code>catch</code> .  Apr√®s tout, il doit g√©rer tous les types d'exceptions que vous souhaitez lui accorder.  Un autre inconv√©nient est purement architectural.  Si vous n'utilisez pas l'h√©ritage, vous d√©sorientez l'utilisateur de ces exceptions: il peut y avoir beaucoup de points communs entre elles et vous devez les intercepter individuellement. </p><br><p>  N√©anmoins, il existe de bons sc√©narios pour introduire des types particuliers pour des situations sp√©cifiques.  Par exemple, lorsqu'une panne se produit non pas pour l'entit√© dans son ensemble, mais pour une m√©thode sp√©cifique.  Ensuite, ce type devrait √™tre dans la hi√©rarchie d'h√©ritage dans un tel endroit afin qu'il ne soit pas pens√© √† l'intercepter avec autre chose: par exemple, le s√©lectionner via une branche d'h√©ritage distincte. </p><br><p>  De plus, si vous combinez ces deux approches, vous pouvez obtenir une bo√Æte √† outils tr√®s puissante pour travailler avec un groupe d'erreurs: vous pouvez introduire un type abstrait g√©n√©ralisant √† partir duquel h√©riter des situations particuli√®res sp√©cifiques.  La classe de base (notre type g√©n√©ralisant) doit √™tre √©quip√©e d'une propri√©t√© abstraite qui stocke le code d'erreur, et les h√©ritiers remplaceront cette propri√©t√© pour sp√©cifier ce code d'erreur: </p><br><pre> <code class="plaintext hljs">public abstract class ParserException : Exception { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Quelles sont les merveilleuses propri√©t√©s que nous obtenons avec cette approche? </p><br><ul><li>  d'une part, nous avons retenu la capture d'une exception par le type de base; </li><li>  d'autre part, en faisant exception au type de base, il √©tait encore possible de d√©couvrir une situation sp√©cifique; </li><li>  et en plus de tout, il est possible d'intercepter pour un type sp√©cifique, et non pour un type basique, sans utiliser la structure plate des classes. </li></ul><br><p>  Pour moi, c'est une option tr√®s pratique. </p><br><h3 id="po-otnosheniyu-k-edinoy-gruppe-povedencheskih-situaciy">  Par rapport √† un seul groupe de situations comportementales </h3><br><p>  Quelles conclusions peut-on tirer sur la base du raisonnement d√©crit pr√©c√©demment?  Essayons de les formuler: </p><br><p>  Pour commencer, d√©cidons de ce que l'on entend par situations.  Lorsque nous parlons de classes et d'objets, nous sommes principalement habitu√©s √† des entit√©s op√©rationnelles avec un √©tat interne sur lequel nous pouvons effectuer des actions.  Il s'av√®re que ce faisant, nous avons trouv√© le premier type de situation comportementale: les actions sur une certaine entit√©.  De plus, si vous regardez le graphique des objets comme de l'ext√©rieur, vous remarquerez qu'il est logiquement combin√© en groupes fonctionnels: le premier traite de la mise en cache, le second des bases de donn√©es, le troisi√®me effectue des calculs math√©matiques.  Les couches peuvent passer par tous ces groupes fonctionnels: une couche de journalisation de divers √©tats internes, la journalisation des processus, la trace des appels de m√©thode.  Les couches peuvent √™tre plus englobantes: combinant plusieurs groupes fonctionnels.  Par exemple, une couche mod√®le, une couche contr√¥leur, une couche pr√©sentation.  Ces groupes peuvent √™tre dans la m√™me assembl√©e, ou dans des groupes compl√®tement diff√©rents, mais chacun d'eux peut cr√©er ses propres situations exceptionnelles. </p><br><p>  Il s'av√®re que si vous argumentez de cette mani√®re, vous pouvez cr√©er une hi√©rarchie de types de situations exceptionnelles, bas√©e sur le type appartenant √† un groupe ou une couche particulier, cr√©ant ainsi la possibilit√© de d√©tecter des exceptions au code pour une navigation s√©mantique facile dans cette hi√©rarchie de types. </p><br><p>  Regardons le code: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  √Ä quoi √ßa ressemble?  Quant √† moi, les espaces de noms sont une excellente opportunit√© pour regrouper naturellement les types d'exceptions en fonction de leurs situations comportementales: tout ce qui appartient √† certains groupes devrait √™tre l√†, y compris les exceptions.  De plus, lorsque vous recevez une certaine exception, en plus du nom de son type, vous verrez son espace de noms, qui d√©terminera clairement son affiliation.  Vous vous souvenez du mauvais exemple de r√©utilisation du type <code>InvalidDataException</code> qui est r√©ellement d√©fini dans l'espace de noms <code>System.IO</code> ?  Son appartenance √† cet espace de noms signifie qu'en substance une exception de ce type peut √™tre lev√©e √† partir des classes situ√©es dans l'espace de noms <code>System.IO</code> ou dans un espace plus imbriqu√©.  Mais l'exception elle-m√™me a √©t√© rejet√©e d'un endroit compl√®tement diff√©rent, d√©routant le chercheur du probl√®me qui s'est pos√©.  En concentrant les types d'exception sur les m√™mes espaces de noms que les types lan√ßant ces exceptions, vous gardez l'architecture de type coh√©rente d'une part et, d'autre part, facilitez au d√©veloppeur final la compr√©hension des raisons de ce qui s'est produit. </p><br><p>  Quelle est la deuxi√®me fa√ßon de regrouper au niveau du code?  H√©ritage: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerExceptionBase(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  De plus, si dans le cas d'entit√©s d'application ordinaires, l'h√©ritage signifie l'h√©ritage de comportements et de donn√©es, combinant des types en appartenant √† un <em>seul groupe d'entit√©s</em> , alors dans le cas d'exceptions, l'h√©ritage signifie appartenir √† un <em>seul groupe de situations</em> , car l'essence de l'exception n'est pas l'essence, mais la probl√©matique. </p><br><p>  En combinant les deux m√©thodes de regroupement, nous pouvons tirer quelques conclusions: </p><br><ul><li>  √† l'int√©rieur de l'assembly ( <code>Assembly</code> ) doit √™tre pr√©sent le type de base d'exceptions que cet assembly l√®ve.  Ce type d'exception doit se trouver dans l'espace de noms racine de l'assembly.  Ce sera la premi√®re couche du regroupement; </li><li>  Plus √† l'int√©rieur de l'assemblage lui-m√™me, il peut y avoir un ou plusieurs espaces de noms diff√©rents.  Chacun d'eux divise l'assemblage en quelques zones fonctionnelles, d√©finissant ainsi les groupes de situations qui se pr√©sentent dans cet assemblage.  Il peut s'agir de zones de contr√¥leurs, d'entit√©s de base de donn√©es, d'algorithmes de traitement de donn√©es et autres.  Pour nous, ces espaces de noms sont un regroupement de types par affiliation fonctionnelle, et du point de vue des exceptions, un regroupement par zones probl√©matiques d'un m√™me assemblage; </li><li>  l'h√©ritage des exceptions ne peut aller que de types dans le m√™me espace de noms ou dans la racine.  Cela garantit une compr√©hension sans ambigu√Øt√© de la situation par l'utilisateur final et l'absence d'interception des exceptions <em>laiss√©es</em> lors de l'interception selon le type de base. :     <code>global::Finiki.Logistics.OhMyException</code> ,  <code>catch(global::Legacy.LoggerExeption exception)</code> ,      : </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something wrong in parser } catch (FinancialPipeExceptionBase exception) { // Something else wrong. Looks critical because we don't know real reason }</code> </pre><br><p> ,   :        , ,   ,       <code>XmlParserServiceException</code> . ,   ,      ,  <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> ,       :    <code>XmlParserService</code>    ,       .          ,               <code>catch</code>      :          . </p><br><p>     ? </p><br><ul><li>        .     .     ‚Äî      ,       : , -, UI.  C'est-√†-dire     ; </li><li>        ,   :      ,      <code>catch</code> ; </li><li>       ‚Äì      .        ; </li><li>             ,       .      :       ,         , ,  . ,   -    :        ,   ‚Äî  ,  , ,        ; </li><li>         </li><li>       ,      :     ; </li><li>           ,  Mixed Mode c ErrorCode. </li></ul><br><h3 id="po-istochniku-oshibki">    </h3><br><p>             . ,     ,     : </p><br><ul><li>  unsafe ,    .      :         ,      (,   )     ; </li><li>     ,   ,      , ..       .        ,             ,     .  ,       ,       .            ‚Äî        ‚Äî  <code>InnerExcepton</code> .            ‚Äî          ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre propre code qui a √©t√© entr√© au hasard dans un √©tat non coh√©rent. </font><font style="vertical-align: inherit;">L'analyse du texte est un bon exemple. </font><font style="vertical-align: inherit;">Il n'y a pas de d√©pendances externes, il n'y a pas de retrait </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais il y a une erreur d'analyse.</font></font></li></ul><br><blockquote><h3>  Lien vers le livre entier </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Livre CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Livres de la version 0.5.0, PDF: <a href="">version GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419927/">https://habr.com/ru/post/fr419927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419917/index.html">R√©seaux de neurones: impl√©mentation de la t√¢che sur les champignons sur Tensor Flow et Python</a></li>
<li><a href="../fr419919/index.html">Contr√¥le de version dans SQL Server</a></li>
<li><a href="../fr419921/index.html">Comment supprimer 10 millions de paquets par seconde</a></li>
<li><a href="../fr419923/index.html">Mon travail temporaire, les montres de la carte m√®re</a></li>
<li><a href="../fr419925/index.html">Contr√¥le de version de fichiers individuels √† l'aide de GitHub Gist</a></li>
<li><a href="../fr419929/index.html">[DotNetBook] √âv√©nements d'exception et comment obtenir StackOverflow et ExecutionEngineException √† partir de z√©ro</a></li>
<li><a href="../fr419931/index.html">[DotNetBook] L'heure des histoires divertissantes: des situations exceptionnellement exceptionnelles</a></li>
<li><a href="../fr419933/index.html">Comment faire des recherches d'utilisateurs sur Github en utilisant Angular</a></li>
<li><a href="../fr419935/index.html">Exactement une fois n'est PAS exactement la m√™me: analyse d'article</a></li>
<li><a href="../fr419939/index.html">Comment j'ai rendu la navigation dans React Native pas si terrible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>