<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¼ğŸ¼ ğŸ‘¨ğŸ¾â€ğŸ’» ğŸ’€ Membuat Pixel Nebula Menggunakan Noise dan Median Cut ğŸ§‘ğŸ» ğŸš¤ ğŸ™ˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin nebula di game saya The Last Boundary . Mereka terlihat luar biasa dan ruang tanpa mereka bukanlah ruang, tetapi hanya piksel putih yang te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat Pixel Nebula Menggunakan Noise dan Median Cut</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Saya ingin nebula di game saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Last Boundary</a> .  Mereka terlihat luar biasa dan ruang tanpa mereka bukanlah ruang, tetapi hanya piksel putih yang tersebar di latar belakang.  Tapi karena saya membuat game dengan gaya "pixel art", saya perlu membuat perpustakaan noise saya menghasilkan gambar pixelated. <br><br>  Berikut ini beberapa contohnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Lebih banyak contoh</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  Dalam contoh warna tunggal, 8 warna digunakan, dan yang lain, 16 warna.  Pada artikel ini, saya akan berbicara tentang bagaimana saya membuat nebula pixelated untuk The Last Boundary. <br><a name="habracut"></a><br>  Ketika kami bekerja dengan pustaka suara, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LibNoise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peduli</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> gunakan (atau tulis sendiri), nilainya biasanya didistribusikan dalam kisaran dari <code>-1</code> hingga <code>1</code> .  Secara teoritis lebih mungkin bahwa noise 2D akan berada dalam kisaran dari <code>-0.7</code> hingga <code>0.7</code> , tetapi beberapa implementasi skala hasilnya, menerjemahkannya ke dalam interval dari <code>-1</code> ke <code>1</code> .  Untuk bekerja dengan tekstur 2D, biasanya dikonversi ke interval dari <code>0</code> ke <code>1</code> , dan kemudian <code>RGB(255,255,255)</code> dalam kisaran dari <code>RGB(0,0,0)</code> ke <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Perlin noise dihasilkan dari koordinat <code>x,y</code> dari setiap piksel yang diskalakan ke <code>0.3f</code></i> <br><br>  Kemudian Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gerakan Brownian fraksional</a> untuk memberikan kesan kemegahan awan pada gambar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>Perlin noise menjadi sasaran gerakan Brown fraksional dengan <code>8</code> oktaf, frekuensi <code>0.01</code> , keteraturan <code>0.5</code> dan lacunaritas <code>2.0</code> .</i> <br><br><blockquote>  Saya perhatikan bahwa ada banyak implementasi salah Perlin noise, simplex noise, dan fraksional Brownian motion (fBm) di Internet.  Tampaknya ada banyak kebingungan tentang apa itu apa.  Pastikan Anda menggunakan implementasi yang benar, karena jika Anda ingin membuat rantai yang dijelaskan di atas, maka dalam kasus implementasi yang salah, Anda mungkin tidak mendapatkan hasil yang diperlukan. </blockquote><br>  Mari kita bayangkan bahwa kita ingin menciptakan efek asap, yaitu solusi seperti itu cocok untuk kita.  Tapi permainan pixel art kami akan terlihat aneh jika sejumlah warna baru muncul di dalamnya dari <code>RGB(0,0,0)</code> ke <code>RGB(255,255,255)</code> .  Tiba-tiba, 255 nilai abu-abu baru akan muncul dalam permainan. <br><br>  Kita perlu mengubahnya menjadi sejumlah warna.  Itu yang akan kita lakukan nanti.  Sementara itu ... <br><br><h2>  Hasilkan nebula acak </h2><br>  Saya ulangi untuk tutorial yang sudah jadi tentang membuat nebula acak, tetapi menambahkan beberapa langkah saya dan menerapkan pustaka suara saya sendiri.  Saya menulisnya beberapa tahun yang lalu karena saya ingin mendapatkan pemahaman yang baik tentang kebisingan Perlin dan bagaimana Anda dapat menggunakannya bersama dengan konsep lain untuk membuat tekstur dan sejenisnya. <br><br>  Mungkin Anda dapat mengulangi setelah saya langkah demi langkah atau Anda harus membuat tambahan pada kode yang akan mempengaruhi kebisingan Anda.  Saya akan menjelaskan semuanya kecuali generasi kebisingan awal dan fBm sehingga Anda dapat menulis kode sendiri;  Saya pikir dapat diasumsikan bahwa Anda sudah memiliki kemampuan untuk menghasilkan noise dan fBm. <br><br>  Untuk memulai, saya akan menunjukkan hasil pembuatan nebula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Hasil jadi</i> <br><br>  Penting untuk dicatat bahwa itu belum pixelated.  Ini memiliki berbagai macam warna dengan langit berbintang pixelated.  Nebula yang akan kita pixelate nanti. <br><br>  Hal pertama yang harus dilakukan adalah menghasilkan lima tekstur berbeda: Merah, Hijau, Biru, Alpha dan Topeng.  Tekstur Merah, Hijau, dan Biru diperlukan untuk saluran warna akhir yang sesuai.  Bahkan, saya hanya menghasilkan satu atau dua saluran warna, karena ternyata menggunakan ketiganya menghasilkan nebula yang sangat berwarna yang terlihat jelek.  Setiap warna tunggal atau kombinasi dua warna akan berhasil. <br><br>  Saluran Alpha penting karena tergantung padanya apakah bintang-bintang yang lebih rendah akan bersinar melalui nebula.  Saya akan menggambarkan ini dengan menampilkan saluran alpha dari contoh yang ditunjukkan di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Saluran alpha siap dari contoh kita</i> <br><br>  Semakin putih area, semakin dekat nilainya ke <code>1.0</code> , yang memberi kita nilai alpha <code>255</code> .  Semakin gelap area, semakin transparan.  Jika Anda melihat contoh, Anda dapat melihat bahwa area hitam sesuai dengan area di mana langit berbintang terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Contoh langit berbintang</i> <br><br>  Ini bukan bintang yang sama seperti pada contoh, karena mereka dihasilkan secara acak di setiap tangkapan layar.  Saya harap ini tidak mencegah Anda dari memahami bagaimana nebula dihasilkan. <br><br>  Pustaka derau saya terdiri dari beberapa modul, mengikuti contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lib Noise</a> .  Segala sesuatu di perpustakaan ini adalah "modul" yang dapat dirantai bersama.  Beberapa modul menghasilkan nilai baru (Modul Perlin, Nilai Konstan), yang lain menghubungkannya (Multiply, Tambah), dan beberapa hanya melakukan operasi pada nilai (Lerp, Clamp). <br><br><h3>  Saluran warna </h3><br>  Tidak masalah jika kita bekerja dengan satu, dua atau tiga warna - saluran Merah, Hijau dan Biru dihasilkan dengan cara yang sama;  Saya hanya menggunakan nilai seed yang berbeda untuk mereka.  Nilai seed saya tergantung pada waktu sistem saat ini. <br><br>  Di bawah mereka semua disajikan dalam skala abu-abu, tetapi secara teoritis mereka hanyalah nilai untuk salah satu dari tiga saluran.  Grayscale ada di sini hanya untuk menggambarkan hasilnya. <br><br><h4>  1. Kebisingan Perlin </h4><br>  Seperti di atas, kebisingan Perlin akan menjadi titik awal.  Jika mau, Anda bisa menggunakan simplex noise, sepertinya implementasi 2D-nya bukan milik Ken Perlin, tapi saya bisa saja salah.  Dari sudut pandang matematika, noise simplex menggunakan lebih sedikit instruksi, sehingga generasi nebula yang sama akan lebih cepat.  Karena ia menggunakan simpleks alih-alih kisi-kisi, ia menciptakan suara yang sedikit lebih indah, tetapi kami tidak akan banyak menggunakannya, jadi ini tidak terlalu penting. <br><br>  Kode sebenarnya tidak ditunjukkan di bawah ini, karena dalam sumber nyata nilai <code>x,y</code> diubah oleh fBm pada langkah 3. Ini hanya koordinat <code>x,y</code> dari gambar yang dikalikan dengan faktor penskalaan statis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Perlin noise dihasilkan dari koordinat <code>x,y</code> dari setiap piksel yang diskalakan ke <code>0.3f</code> .</i>  <i>Yaitu</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Nilai yang dibuat oleh noise Perlin kira-kira berkisar antara <code>-1</code> hingga <code>1</code> , jadi untuk membuat gambar skala abu-abu seperti ditunjukkan di atas, kami mengonversinya ke interval dari <code>0</code> hingga <code>1</code> .  Saya menguji cakupan nilai sehingga konversi menghasilkan kontras terbesar (nilai terendah sesuai dengan <code>0</code> , terbesar - <code>1</code> ). <br><br><h4>  2. Multiplikasi </h4><br>  Modul selanjutnya yang digunakan mengalikan kebisingan yang dihasilkan dengan <code>5</code> .  Ini bisa dianggap penyesuaian kontras.  Nilai negatif lebih gelap, nilai positif lebih ringan. <br><br>  Saya tidak punya apa-apa untuk ditampilkan di sini, karena dalam proses mengubah nilai dari interval dari <code>-5</code> ke <code>5</code> ke interval dari <code>0</code> ke <code>1</code> hasilnya tidak berubah. <br><br><h4>  3. Gerakan Brown Pecahan (fBM) </h4><br>  Tahap ini mengubah suara menjadi apa yang oleh banyak orang dianggap sebagai "efek kebisingan" nyata.  Di sini kita mengeksekusi oktaf dari sampel yang semakin kecil dari fungsi noise (dalam kasus kami, fungsinya adalah <code>perlin(x,y)</code> ) untuk menambahkan fluffiness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>Gerakan Pecahan Brown dari kebisingan Perlin ditunjukkan di atas.</i>  <i><code>8</code> oktaf, frekuensi <code>.01f</code> , keteraturan <code>.5f</code> dan <code>2.5f</code></i> <br><br>  Anda sudah bisa melihat asal sesuatu yang menarik.  Gambar yang ditunjukkan di atas tidak dihasilkan oleh penskalaan koordinat <code>x,y</code> dari piksel, fBM melakukan ini.  Sekali lagi, nilai-nilai ini secara terbalik dikonversi ke interval dari <code>0</code> ke <code>1</code> ke interval yang mungkin dari <code>-5</code> ke <code>5</code> . <br><br><h4>  4. Pembatasan (Penjepit) </h4><br>  Sekarang saya akan membatasi nilai ke kisaran <code>-1</code> hingga <code>1</code> .  Apa pun di luar interval ini akan sepenuhnya dibuang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>FBm yang sama, terbatas pada <code>-1</code> hingga <code>1</code></i> <br><br>  Tugas operasi ini adalah untuk mengkonversi nilai ke interval yang lebih pendek sambil menciptakan gradien yang lebih tajam dan meningkatkan area dalam warna putih atau hitam penuh.  Area kosong atau kosong ini penting untuk efek nebula, yang akan kita bahas nanti.  Jika kita tidak dikalikan <code>5</code> pada awalnya, maka penjepit tidak akan mengubah apa pun. <br><br><h4>  5. Tambahkan 1 </h4><br>  Sekarang kita mengambil nilai dari klem dan menambahkan 1. Untuk itu, dengan demikian, kita mentransfer nilai ke interval dari <code>0</code> ke <code>2</code> .  Setelah konversi, hasilnya akan terlihat sama seperti sebelumnya. <br><br><h4>  6. Bagi dengan 2 </h4><br>  Anda mungkin tahu apa yang akan terjadi ketika saya membagi hasilnya dengan <code>2</code> (kalikan dengan <code>.5</code> ).  Pada gambar, tidak ada yang akan berubah lagi. <br><br>  Langkah 5 dan 6 mengonversi nilai ke rentang dari <code>0</code> hingga <code>1</code> . <br><br><h4>  7. Buat tekstur distorsi </h4><br>  Langkah selanjutnya adalah membuat tekstur distorsi.  Saya akan melakukan ini dengan Perlin noise (dengan nilai seed baru)&gt; kalikan dengan 4&gt; jalankan fBm.  Dalam hal ini, fBm menggunakan <code>5</code> oktaf, frekuensi <code>0.025</code> , keteraturan <code>0.5</code> dan lacunaritas <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Tekstur distorsi</i> <br><br>  Tekstur ini diperlukan untuk membuat detail lebih banyak daripada pada tekstur nebula yang ada.  Nebula adalah awan bergelombang yang agak besar, dan tekstur ini akan membuat sedikit perubahan padanya.  Melalui itu, sifat grid dari suara Perlin akan mulai muncul. <br><br><h4>  8. Mengimbangi tekstur warna menggunakan tekstur offset </h4><br>  Selanjutnya saya akan mengambil dua tekstur ini dan menggunakan satu untuk mengimbangi koordinat yang lain dengan faktor.  Dalam kasus kami, kombinasi terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Hasil bias</i> <br><br>  Tekstur distorsi digunakan untuk mengubah koordinat <code>x,y</code> kita cari dalam data noise sumber. <br><br>  Ingat bahwa gambar yang ditunjukkan di atas hanya untuk tujuan ilustrasi.  Pada setiap tahap, kami sebenarnya hanya memiliki fungsi noise.  Kami memberikan nilai <code>x,y</code> , dan mengembalikan angka.  Pada tahap tertentu, interval angka ini mungkin berbeda, tetapi di atas kami mengonversinya kembali menjadi skala abu-abu untuk membuat gambar.  Gambar dibuat dengan menggunakan setiap koordinat <code>x,y</code> dari gambar sebagai <code>x,y</code> , yang ditransmisikan oleh fungsi noise. <br><br>  Yaitu, ketika kita mengatakan: <br><br><blockquote>  Beri saya nilai untuk piksel sudut kiri atas dengan X = 0 dan Y = 0 </blockquote><br>  fungsi mengembalikan kita nomor.  Jika kita meminta Perlin untuk ini, kita tahu bahwa itu akan antara <code>-1</code> dan <code>1</code> , jika, seperti di atas, kita menerapkan penjepit, penjumlahan dan perkalian, kita mendapatkan nilai antara <code>0</code> dan <code>1</code> . <br><br>  Setelah memahami ini, kita belajar bahwa fungsi gangguan distorsi menciptakan nilai dalam kisaran dari <code>-1</code> hingga <code>1</code> .  Karena itu, untuk melakukan bias ketika kita mengatakan: <br><br><blockquote>  Beri saya nilai untuk piksel di sudut kiri atas dengan piksel X = 0 dan Y = 0 </blockquote><br>  modul offset pertama-tama meminta fungsi offset untuk koordinat <code>x,y</code> .  Hasil ini adalah antara <code>-1</code> dan <code>1</code> (seperti di atas).  Kemudian dikalikan dengan <code>40</code> (ini adalah <em>koefisien yang</em> saya pilih).  Hasilnya akan menjadi nilai antara <code>-40</code> dan <code>40</code> . <br><br>  Kemudian kita mengambil nilai ini dan menambahkannya ke koordinat ke <code>x,y</code> yang kita cari, dan menggunakan hasil ini untuk mencari tekstur warna.  Kami memotong nilai negatif dengan clamp ke 0, karena tidak mungkin untuk mencari koordinat <code>x,y</code> negatif dalam fungsi noise (setidaknya di perpustakaan noise saya). <br><br>  Secara umum, ini terlihat seperti ini: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  Saya harap Anda mengerti ini.  Faktanya, kita tidak melihat <code>x,y</code> kita berada, tetapi pada offset.  Dan karena <em>besarnya</em> juga merupakan gradien yang halus, ia dengan lancar bergeser. <br><br>  Ada cara lain untuk melakukan offset.  Perpustakaan kebisingan saya memiliki modul yang menciptakan perpindahan spiral.  Dapat digunakan untuk menggambar tekstur, secara bertahap menurun ke beberapa titik.  <a href="">Berikut ini sebuah contoh</a> . <br><br>  Itu saja.  Kami mengulangi operasi di atas tiga kali, menggunakan nilai seed baru untuk setiap saluran warna.  Anda dapat membuat satu atau dua saluran.  Saya tidak berpikir layak membuat yang ketiga. <br><br><h3>  Saluran alfa </h3><br>  Saluran alfa dibuat dengan cara yang sama seperti saluran warna: <br><br><ol><li>  Kami mulai dengan suara Perlin </li><li>  Kalikan dengan <code>5</code> </li><li>  fBM dengan <code>8</code> oktaf, frekuensi <code>0.005</code> , keteraturan <code>0.5</code> dan lacunaritas <code>2.5</code> </li><li>  Kami membatasi hasil menggunakan Clamp ke interval dari <code>-1</code> ke <code>1</code> , tambahkan <code>1</code> , bagi dengan <code>2</code> (mis., Kami menggeser interval dari <code>-1</code> ke <code>1</code> ke interval dari <code>0</code> ke <code>1</code> . </li><li>  Kami menggeser hasilnya dengan jumlah kecil ke arah negatif.  Saya mengimbangi dengan <code>0.4</code> .  Berkat ini, semuanya menjadi sedikit lebih gelap. </li><li>  Kami membatasi hasil pada interval dari <code>0</code> hingga <code>1</code> .  Karena kami memindahkan semuanya, membuatnya sedikit lebih gelap, pada kenyataannya, kami menciptakan lebih banyak area dengan <code>0</code> , dan beberapa area masuk ke nilai negatif. </li></ol><br>  Hasilnya adalah tekstur saluran alpha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Tekstur alfa</i> <br><br>  Seperti yang saya katakan, area hitam akan transparan, dan area putih akan buram. <br><br><h3>  Topeng saluran </h3><br>  Ini adalah tekstur terakhir yang digunakan untuk membuat bayangan overlay di atas segalanya.  Itu dimulai seperti semua tekstur lainnya: <br><br><ol><li>  Perlin kebisingan </li><li>  Kalikan dengan <code>5</code> </li><li>  Kami melakukan fBm, <code>5</code> oktaf, frekuensi <code>0.01</code> , keteraturan <code>0.1</code> , lacunaritas <code>0.1</code> .  Keteraturan adalah kecil, sehingga awannya kurang padat </li><li>  Lakukan pergeseran interval dari <code>-1</code> ke <code>1</code> ke interval dari <code>0</code> ke <code>1</code> </li></ol><br>  Tapi kami membuat dua tekstur seperti itu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Topeng a</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>Topeng B</i> <br><br>  Kami memaparkan dua tekstur ini ke apa yang saya sebut modul <em>Pilih</em> .  Bahkan, kami menggunakan nilai dari modul A atau modul B. Pilihannya tergantung pada nilai modul C. Ini membutuhkan dua nilai lebih - <em>Pilih Point</em> dan <em>Falloff</em> . <br><br>  Jika nilai pada titik <code>x,y</code> modul C lebih besar dari atau sama dengan <code>SelectPoint</code> , maka kami menggunakan nilai pada titik <code>x,y</code> modul B. Jika nilainya kurang dari atau sama dengan <code>SelectPoint - Falloff</code> , maka kami menggunakan nilai pada <code>x,y</code> modul A. <br><br>  Jika berada di antara <code>SelectPoint - Falloff</code> dan <code>SelectPoint</code> , maka kami melakukan interpolasi linier antara nilai <code>x,y</code> dari modul A dan modul B. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  Dalam kasus kami, modul A adalah modul <em>Konstan</em> dengan nilai <code>0</code> .  Modul B adalah tekstur pertama dari mask A, dan <em>Selector</em> (modul C) adalah mask kedua dari B. <code>SelectPoint</code> akan menjadi <code>0.4</code> , dan <code>Falloff</code> akan menjadi <code>0.1</code> .  Sebagai hasilnya, kita mendapatkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>Topeng pamungkas</i> <br><br>  Dengan menambah atau mengurangi <code>SelectPoint</code> , kami mengurangi atau menambah jumlah hitam dalam topeng.  Dengan menambah atau mengurangi <code>falloff</code> , kami menambah atau mengurangi tepi lunak topeng.  Alih-alih salah satu topeng, saya bisa menggunakan modul <em>Constant</em> dengan nilai <code>1</code> , tapi saya ingin menambahkan sedikit keacakan ke area "membuka kedok". <br><br><h3>  Campur saluran warna dan topeng </h3><br>  Sekarang kita perlu menerapkan masker ke masing-masing saluran warna.  Ini dilakukan dengan menggunakan modul <em>Blending</em> .  Ini menggabungkan persentase nilai dari dua modul sehingga jumlah nilai adalah 100%. <br><br>  Yaitu, kita dapat mengambil 50% dari nilai dalam <code>x,y</code> modul A dan 50% dari nilai dalam <code>x,y</code> modul B. Atau 75% dan 25%, dll.  Persentase yang kita ambil dari masing-masing modul tergantung pada modul lain - modul C. Jika nilai dalam <code>x,y</code> modul C adalah <code>0</code> , maka kita akan mengambil 100% dari modul A dan 0% dari modul B. Jika itu adalah <code>1</code> , maka kita mengambil nilai terbalik. <br><br>  Gabungkan untuk setiap tekstur warna. <br><br><ul><li>  Modul A - Nilai Konstan 0 </li><li>  Modul B adalah saluran warna yang telah kita lihat </li><li>  Modul C - mask hasil </li></ul><br>  Ini berarti bahwa noise saluran warna akan ditampilkan hanya di mana topeng memiliki nilai di atas <code>0</code> (area lebih dekat ke putih), dan besarnya visibilitas mereka tergantung pada nilai topeng. <br><br>  Inilah hasil untuk contoh kita: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Hasil akhir</i> <br><br>  Bandingkan ini dengan aslinya sebelum menerapkan pencampuran dengan masker. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Sebelum dicampur dengan masker</i> <br><br>  Mungkin contoh ini tidak terlalu jelas, tetapi karena kebetulan sulit untuk secara khusus memilih contoh yang baik.  Efek topeng adalah membuat area yang lebih gelap.  Tentu saja, Anda dapat menyesuaikan topeng agar lebih jelas. <br><br>  Penting di sini bahwa topeng yang sama diterapkan ke seluruh saluran warna, yaitu area yang sama muncul dalam bayangan. <br><br><h3>  Kami menggabungkan semuanya bersama </h3><br>  Contoh selesai awal kami: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Contoh siap</i> <br><br>  Ini menggunakan saluran Merah, Hijau, dan Alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Saluran merah</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Saluran hijau</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Saluran alfa</i> <br><br>  Dan kemudian kita hanya meletakkannya di atas langit berbintang kita. <br><br>  Semuanya sekarang terlihat cukup bagus, tetapi tidak terlalu cocok untuk game pixel art.  Kita perlu mengurangi jumlah warna ... <br><br><h2>  Median dipotong </h2><br>  Bagian artikel ini dapat diterapkan untuk apa saja.  Katakanlah Anda menghasilkan tekstur marmer dan ingin mengurangi jumlah warna.  Di sinilah algoritma median cut berguna.  Kami akan menggunakannya untuk mengurangi jumlah warna dalam nebula yang ditunjukkan di atas. <br><br>  Ini terjadi <em>sebelum</em> ditumpangkan di langit berbintang.  Jumlah warna sepenuhnya berubah-ubah. <br><br>  Algoritma Median Cut seperti yang dijelaskan dalam Wikipedia: <br><br><blockquote>  Misalkan kita memiliki gambar dengan jumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">piksel</a> sembarang dan kami ingin menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">palet</a> 16 warna.  Masukkan semua piksel dalam gambar (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nilai RGB-nya</a> ) di tempat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampah</a> .  Cari tahu saluran warna mana (merah, hijau atau biru) di antara semua piksel dalam keranjang yang memiliki rentang nilai terbesar, lalu urutkan piksel sesuai dengan nilai saluran ini.  Misalnya, jika saluran biru memiliki rentang nilai terbesar, maka piksel dengan nilai RGB (32, 8, 16) lebih kecil daripada piksel dengan nilai RGB (1, 2, 24), karena 16 &lt;24. Setelah menyortir keranjang, tempatkan bagian atas piksel tersebut ke dalam keranjang baru.  (Langkah ini memberi nama pada algoritma median cut; keranjang dibagi dua oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">median dari</a> daftar piksel.) Ulangi proses untuk kedua keranjang, yang akan memberi kita 4 keranjang, kemudian ulangi untuk semua 4 keranjang, dapatkan 8 keranjang, kemudian ulangi untuk 8 keranjang, kita dapatkan 16 keranjang.  Kami rata-rata piksel di masing-masing keranjang dan mendapatkan palet 16 warna.  Karena jumlah keranjang berlipat ganda pada setiap iterasi, algoritma hanya dapat menghasilkan palet seperti itu, jumlah warna yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekuatan dua</a> .  Misalnya, untuk menghasilkan palet 12-warna, Anda harus terlebih dahulu membuat palet 16-warna, dan kemudian menggabungkan beberapa warna. <br><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Penjelasan ini bagi saya agak buruk dan tidak terlalu berguna.  Saat mengimplementasikan algoritme, gambar yang jelek dihasilkan dengan cara ini.  Saya menerapkannya dengan beberapa perubahan: <br><br><ol><li>  Kami menyimpan <code>boxes</code> kontainer bersama dengan nilai yang menunjukkan interval (lebih lanjut tentang ini di bawah ini).  <code>box</code> hanya menyimpan sejumlah piksel dinamis dari gambar asli. </li><li>  Tambahkan semua piksel dari gambar asli sebagai <code></code> pertama dan gunakan interval <code>0</code> </li><li>  Sementara jumlah total <code></code> kurang dari jumlah warna yang diperlukan, kami melanjutkan langkah-langkah berikut. </li><li>  Jika nilai interval adalah <code>0</code> , maka untuk setiap kotak saat ini kami menentukan saluran warna utama dari <code>box</code> ini, dan kemudian mengurutkan piksel dalam <code>box</code> ini dengan warna ini.   â€”    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    â€” .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami mencapai jumlah kotak sama dengan jumlah warna yang diinginkan, kami cukup rata-rata semua piksel di setiap kotak untuk menentukan elemen palet yang paling cocok dengan warna-warna ini. </font><font style="vertical-align: inherit;">Saya hanya menggunakan jarak Euclidean, tetapi ada solusi persepsi yang dapat melakukan ini dengan lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah gambar yang akan menjelaskan semuanya dengan lebih jelas. </font><font style="vertical-align: inherit;">Untuk demonstrasi, saya hanya menggunakan RGB, karena alpha sulit ditampilkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita terapkan metode ini pada contoh gambar kita. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asli</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Median Potong hingga 16 warna</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya menemukan bahwa ketika menggunakan dua saluran warna, efek yang baik diperoleh dengan 16 warna. Namun perlu diingat bahwa di sini kita menggunakan saluran alfa, yang juga terlibat dalam menghitung jarak antar warna. Jadi jika Anda tidak peduli dengan transparansi, maka Anda dapat menggunakan lebih sedikit warna. Karena potongan median saya, tidak seperti contoh Wikipedia, dapat menggunakan jumlah warna sewenang-wenang (dan bukan hanya kekuatan dua warna), Anda dapat menyesuaikannya agar sesuai dengan kebutuhan Anda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari 16 hingga 2 warna.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memilih warna dari masing-masing warna </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cukup dengan rata-rata semua nilai. </font><font style="vertical-align: inherit;">Namun, ini bukan satu-satunya cara. </font><font style="vertical-align: inherit;">Anda mungkin telah memperhatikan bahwa hasil kami dibandingkan dengan aslinya tidak terlalu cerah. </font><font style="vertical-align: inherit;">Jika Anda membutuhkannya, maka Anda dapat memberikan preferensi dalam interval atas, menambah bobot pada definisi interval. </font><font style="vertical-align: inherit;">Atau Anda dapat dengan mudah memilih 1, 2 atau 3 warna paling terang dalam gambar dan menambahkannya ke palet. </font><font style="vertical-align: inherit;">Karena itu, jika Anda membutuhkan 16 warna, buat palet 13 warna dan tambahkan warna-warna cerah secara manual.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Palet dengan tiga warna paling cerah.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang semuanya terlihat cukup bagus, tetapi gambarnya terlalu jerawatan. </font><font style="vertical-align: inherit;">Ini memiliki area besar dengan warna yang sama. </font><font style="vertical-align: inherit;">Sekarang kita perlu memuluskannya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dithering </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak perlu memberi tahu Anda apa itu dithering, karena Anda sudah bekerja dengan pixel art. </font><font style="vertical-align: inherit;">Jadi, untuk mendapatkan gambar yang lebih halus, kita akan menggunakan salah satu algoritma dithering, yang sangat banyak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menerapkan algoritma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dithering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sederhana </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Floyd-Steinberg</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tidak ada kejutan yang tidak menyenangkan. </font><font style="vertical-align: inherit;">Namun, efeknya cukup kuat. </font><font style="vertical-align: inherit;">Ini contoh kita lagi:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asli</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lalu kami memotong palet menjadi 16 warna:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai-nilai dipetakan ke palet 16-warna.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang dithering diikuti oleh konversi ke palet:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil jadi dengan dithering</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464203/">https://habr.com/ru/post/id464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464189/index.html">Cara membuat proyek open source</a></li>
<li><a href="../id464191/index.html">Cara mengatasi masalah situs agregator menggunakan proxy penduduk</a></li>
<li><a href="../id464193/index.html">Mikrofon terbuka dari DevOps Deflope, cerita tentang infrastruktur Skyeng dan Nvidia dan tidak hanya</a></li>
<li><a href="../id464195/index.html">Kisah sukses permainan Hari Terakhir di Bumi dari studio Volgograd Kefir</a></li>
<li><a href="../id464197/index.html">Apa yang akan terjadi pada TechTrain, dan mengapa saya harus pergi ke sana?</a></li>
<li><a href="../id464205/index.html">Bagaimana AI dan ilmu saraf bergerak maju satu sama lain</a></li>
<li><a href="../id464207/index.html">Dari Homo sapiens sapiens hingga Homo rentan terhadap ilmu Homo, atau Adult Security Awareness</a></li>
<li><a href="../id464209/index.html">Gutenberg Editor, cara membuat editor dan huruf-huruf nyaman</a></li>
<li><a href="../id464217/index.html">Cara memvisualisasikan suara di web: pilihan materi tematik dan ceramah video dengan teori dan praktik</a></li>
<li><a href="../id464219/index.html">Toolkit timlid dari email ke papan kanban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>