<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∫ üôé üë©‚Äçüë©‚Äçüëß‚Äçüë¶ Seluruh kebenaran tentang RTOS. Artikel # 15. Partisi Memori: Layanan dan Struktur Data üåßÔ∏è üêøÔ∏è üï¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, kami terus meninjau bagian memori RTOS. 

 Nucleus RTOS memiliki tiga panggilan API yang menyediakan fungsi utilitas yang terkait d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 15. Partisi Memori: Layanan dan Struktur Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426477/"><img src="https://habrastorage.org/webt/3t/wd/au/3twdaubgcbrqlkg0al5lttnqs-y.jpeg"><br><br>  Dalam artikel ini, kami terus meninjau bagian memori RTOS. <br><br>  Nucleus RTOS memiliki tiga panggilan API yang menyediakan fungsi utilitas yang terkait dengan kumpulan partisi memori: mengembalikan informasi tentang kumpulan partisi, mengembalikan jumlah kumpulan partisi dalam suatu aplikasi, dan mengembalikan pointer ke semua kumpulan partisi dalam suatu aplikasi.  Dua tantangan pertama diimplementasikan dalam Nucleus SE. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h2>  Mengambil Informasi Partition Pool </h2><br>  Panggilan layanan ini menyediakan informasi parsial tentang kumpulan partisi.  Implementasi Nucleus SE berbeda dari Nucleus RTOS karena ia mengembalikan lebih sedikit informasi karena penamaan objek dan permintaan jeda tidak didukung, dan tugas tidak dapat dijeda. <br><br><h3>  Memanggil Partition Pool Information dalam Nucleus RTOS </h3><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Partition_Pool_Information (NU_PARTITION_POOL * pool, CHAR * nama, VOID ** start_address, TANDA TANDA * pool_size, TANDA TANDA * partisi_size, TANDA TANDA * tersedia, TANDA TANGAN * dialokasikan, OPSI * suspend_type, tugas pertama yang ditandai ** menunggu tugas pertama; menunggu tanpa tugas ** menunggu tugas pertama;</b> <br><br>  Parameter: <br><br>  <b>pool</b> - pointer ke pool partisi tentang informasi mana yang diminta; <br>  <b>name</b> - pointer ke area tujuan 8 karakter untuk nama pool partisi;  termasuk tempat untuk mengakhiri nol; <br>  <b>start_address</b> - pointer ke variabel yang menerima pointer ke awal area data pool partisi; <br>  <b>pool_size</b> - pointer ke variabel yang menerima ukuran pool partisi (dalam byte); <br>  <b>partition_size</b> - penunjuk ke variabel yang mendapatkan ukuran partisi dalam kumpulan yang diberikan; <br>  <b>available</b> - pointer ke variabel yang menerima jumlah partisi yang saat ini tersedia di kumpulan ini; <br>  <b>dialokasikan</b> - pointer ke variabel yang menerima jumlah partisi yang saat ini digunakan dalam kumpulan yang diberikan; <br>  <b>suspend_type</b> - pointer ke variabel untuk mendapatkan jenis penangguhan tugas;  jenis suspensi yang valid: <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - pointer ke variabel yang menerima jumlah tugas yang ditangguhkan dalam kumpulan partisi yang diberikan; <br>  <b>first_task</b> - penunjuk ke penunjuk tugas di mana penunjuk dari tugas yang ditangguhkan pertama berada. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_POOL</b> - penunjuk yang tidak valid ke kumpulan partisi. <br><br><h3>  Memanggil Partition Pool Information dalam Nucleus SE </h3><br>  Prototipe panggilan: <br><br>  <b>STATUS NUSE_Partition_Pool_Information (kumpulan NUSE_PARTITION_POOL, ADDR * start_address, U32 * pool_size, U16 * partisi_size, U8 * tersedia, U8 * dialokasikan, U8 * tugas_ menunggu, NUSE_TASK * first_task)</b> <br><br>  Parameter: <br><br>  <b>pool</b> - indeks pool partisi tentang informasi mana yang diminta; <br>  <b>start_address</b> - pointer ke variabel yang menerima pointer ke awal area data pool partisi; <br>  <b>pool_size</b> - pointer ke variabel yang menerima ukuran pool partisi (dalam byte); <br>  <b>partition_size</b> - penunjuk ke variabel yang mendapatkan ukuran partisi dalam kumpulan yang diberikan; <br>  <b>available</b> - pointer ke variabel yang menerima jumlah partisi yang saat ini tersedia di kumpulan ini; <br>  <b>dialokasikan</b> - pointer ke variabel yang menerima jumlah partisi yang saat ini digunakan dalam kumpulan yang diberikan; <br>  <b>task_waiting</b> - pointer ke variabel yang menerima jumlah tugas yang ditangguhkan di kumpulan partisi ini (jika penangguhan tugas dinonaktifkan, 0 dikembalikan); <br>  <b>first_task</b> - pointer ke variabel tipe <b>NUSE_TASK</b> , yang menerima indeks tugas yang ditangguhkan pertama (jika penangguhan tugas dinonaktifkan, 0 dikembalikan). <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_POOL</b> - indeks kumpulan partisi tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - satu atau lebih dari pointer yang dikirimkan tidak valid. <br><br><h3>  Menerapkan Pengambilan Informasi dan Pengumpulan Partisi di Nucleus SE </h3><br>  Menerapkan panggilan API semacam itu mudah dilakukan: <br><br><img src="https://habrastorage.org/webt/ia/82/sj/ia82sj807l4yuaio-mvf-ypjivm.jpeg"><br><br>  Fungsi mengembalikan status kumpulan partisi.  Kemudian, jika pemblokiran panggilan API diaktifkan, jumlah tugas yang tertunda dan indeks yang pertama akan dikembalikan (jika tidak, parameter ini diatur ke 0). <br><br><h2>  Mendapatkan jumlah kumpulan partisi </h2><br>  Panggilan ini mengembalikan informasi tentang jumlah kumpulan partisi yang dikonfigurasi dalam aplikasi.  Sementara dalam Nucleus RTOS angka ini berubah dari waktu ke waktu dan nilai kembali akan mewakili jumlah kolam saat ini, dalam Nucleus SE nilai kembali ditetapkan selama perakitan dan tetap tidak berubah. <br><br><h3>  Tantangan mendapatkan jumlah kumpulan partisi di Nucleus RTOS </h3><br>  Panggilan tersebut mendukung fungsionalitas inti dari Nucleus RTOS API. <br><br>  Prototipe panggilan: <br><br>  <b>NU_Established_Partition_Pools (VOID) UNSIGNED;</b> <br><br>  Parameter: <br><br>  Tidak ada. <br><br>  Nilai pengembalian: <br><br>  Jumlah kumpulan partisi yang dibuat dalam aplikasi. <br><br><h3>  Tantangan mendapatkan jumlah kumpulan partisi di Nucleus SE </h3><br>  Panggilan utilitas ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan: <br><br>  <b>U8 NUSE_Partition_Pool_Count (batal);</b> <br><br>  Parameter: <br><br>  Tidak ada <br><br>  Nilai pengembalian: <br><br>  Jumlah kumpulan partisi yang dibuat dalam aplikasi. <br><br><h3>  Implementasi </h3><br>  Implementasi panggilan API ini sangat sederhana: nilai <b>#define</b> dari simbol <b>NUSE_PARTITION_POOL_NUMBER dikembalikan</b> . <br><br><h2>  Struktur data </h2><br>  Seperti semua objek Nucleus SE lainnya, kumpulan partisi menggunakan susunan struktur dalam ROM dan RAM, jumlah yang tergantung pada jumlah kumpulan yang ditentukan dalam pengaturan. <br><br>  Saya sangat merekomendasikan kode aplikasi mengakses struktur data seperti itu melalui fungsi API, dan tidak secara langsung.  Ini menghindari ketidakcocokan dengan versi Nucleus SE di masa depan dan efek samping yang tidak diinginkan, dan juga menyederhanakan porting aplikasi ke Nucleus RTOS.  Berikut ini adalah uraian terperinci tentang struktur data untuk memfasilitasi pemahaman kode panggilan layanan dan debugging. <br><br><h3>  Struktur data kernel ditempatkan dalam RAM </h3><br>  Struktur data ini meliputi: <br><br>  <b>NUSE_Partition_Pool_Partition_Used []</b> - larik tipe <b>U8</b> , memiliki satu entri untuk setiap kumpulan partisi yang dikonfigurasi, berisi penghitung kumpulan kumpulan yang saat ini digunakan; <br>  <b>NUSE_Partition_Pool_Blocking_Count []</b> - larik tipe <b>U8 yang</b> berisi penghitung tugas yang diblokir di setiap kumpulan partisi.  Array ini ada jika memblokir panggilan API dimungkinkan. <br><br>  Struktur data tersebut diinisialisasi ke nol menggunakan <b>NUSE_Init_ Partition_Pool ()</b> saat memulai Nucleus SE.  Ini logis karena membuat setiap partisi di setiap kumpulan tidak digunakan (gratis).  Artikel berikut akan memberikan deskripsi lengkap tentang prosedur memulai di Nucleus SE. <br><br>  Berikut ini adalah deskripsi struktur data dalam file <b>nuse_init.c</b> . <br><br><img src="https://habrastorage.org/webt/vi/3x/sx/vi3xsxmbwdzkwgfge9ws_dsvups.jpeg"><br><br><h3>  Data pengguna RAM </h3><br>  Pengguna perlu mengalokasikan area dalam RAM untuk menyimpan data untuk setiap kumpulan partisi.  Jumlah ruang dalam RAM harus sesuai dengan volume partisi yang dikonfigurasi (lihat "Data dalam ROM" di bawah) dengan byte tambahan untuk setiap partisi di kumpulan.  Setiap bagian dari area data didahului oleh satu byte status. <br><br><h3>  Data ROM </h3><br>  Ini termasuk: <br><br>  <b>NUSE_Partition_Pool_Data_Address []</b> - larik jenis <b>ADDR</b> , dengan satu entri untuk setiap kumpulan partisi yang dikonfigurasi, berisi alamat awal dari area penyimpanan data; <br>  <b>NUSE_Partition_Pool_Partition_Number []</b> - larik tipe <b>U8</b> dengan satu entri untuk setiap kumpulan partisi yang dikonfigurasi, berisi informasi tentang jumlah partisi di kumpulan; <br>  <b>NUSE_Partition_Pool_Partition_Size []</b> - larik tipe <b>U16</b> dengan satu entri untuk setiap kumpulan partisi yang dikonfigurasi, berisi ukuran partisi untuk kumpulan. <br><br>  Struktur data tersebut dideklarasikan dan diinisialisasi (secara statis) di <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/zt/67/lq/zt67lqadvkdzmuvazbj0mmlhp8a.jpeg"><br><br><h3>  Jejak data untuk kumpulan partisi </h3><br>  Seperti semua objek inti dalam Nucleus SE, jumlah memori yang diperlukan untuk kumpulan partisi dapat diprediksi. <br><br>  Ukuran ROM (dalam byte) untuk semua kumpulan partisi aplikasi dapat dihitung sebagai berikut: <br><br>  <b>NUSE_PARTITION_POOL_NUMBER * (sizeof (ADDR) + 2)</b> <br><br>  Jumlah data kernel dalam RAM untuk semua kumpulan partisi aplikasi ketika pemblokiran panggilan API diaktifkan hanya membutuhkan 2 byte per kumpulan partisi, dan ketika pemblokiran tidak diaktifkan, dibutuhkan 1 byte. <br><br>  Jumlah memori untuk menyimpan data pengguna dalam RAM bervariasi untuk setiap kumpulan partisi, meskipun, seperti yang telah disebutkan, untuk kumpulan dengan indeks n dapat dihitung sebagai: <br><br>  <b>NUSE_Partition_Pool_Partition_Number [n] *</b> <br>  <b>(NUSE_Partition_Pool_Partition_Size [n] + 1)</b> <br><br><h2>  Panggilan API yang belum direalisasi </h2><br>  Tiga panggilan API untuk kumpulan partisi yang diterapkan di Nucleus RTOS tidak didukung di Nucleus SE. <br><br><h3>  Buat Partition Pool </h3><br>  Panggilan API ini menciptakan kumpulan partisi.  Nucleus SE tidak membutuhkannya karena tugas dibuat secara statis. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Create_Partition_Pool (NU_PARTITION_POOL * pool, CHAR * nama, VOID * start_address, pool_size TANDA, partisi_size UNSIGNED, partisi_size UNSIGNED, OPTION suspend_type);</b> <br><br>  Parameter: <br><br>  <b>pool</b> - pointer ke unit <b>pool</b> control yang ditentukan pengguna;  digunakan sebagai pegangan ke kumpulan partisi dalam panggilan API lainnya; <br>  <b>name</b> - pointer ke nama pool partisi, string 7-karakter dengan nol penghentian; <br>  <b>start_address</b> - menetapkan alamat mulai untuk area memori kumpulan partisi; <br>  <b>pool_size</b> - jumlah total memori dalam byte; <br>  <b>partisi_size</b> - jumlah memori dalam byte untuk setiap partisi dalam kumpulan.  Selain itu, sejumlah kecil memori tambahan dialokasikan terkait dengan setiap bagian, yang diwujudkan berkat dua pointer data yang digunakan. <br>  <b>suspend_type</b> - menentukan bagaimana tugas ditangguhkan di kumpulan partisi;  Opsi parameter yang valid adalah <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> . <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - menunjukkan keberhasilan penyelesaian panggilan; <br>  <b>NU_INVALID_POOL</b> - menunjukkan nilai nol unit kontrol kumpulan partisi ( <b>NULL</b> ); <br>  <b>NU_INVALID_MEMORY</b> - menunjukkan nilai nol area memori yang ditentukan oleh <b>alamat start_</b> ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - menunjukkan bahwa ukuran partisi 0 atau lebih besar dari memori yang dialokasikan untuk partisi; <br>  <b>NU_INVALID_SUSPEND</b> - nilai <b>suspend_type</b> tidak valid. <br><br><h3>  Menghapus Kolam Partisi </h3><br>  Panggilan API ini menghapus kumpulan partisi yang dibuat sebelumnya.  Nucleus SE tidak memerlukannya karena objek dibuat secara statis dan tidak dapat dihapus. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Delete_Partition_Pool (NU_PARTITION_POOL * kumpulan);</b> <br><br>  Parameter: <br><br>  <b>pool</b> - pointer ke unit kontrol pool partisi; <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - menunjukkan keberhasilan penyelesaian panggilan; <br>  <b>NU_INVALID_POOL</b> - menunjukkan nilai yang tidak valid untuk penunjuk kumpulan partisi; <br><br><h3>  Pointer Pool Pointer </h3><br>  Panggilan API ini membuat daftar pointer berurutan untuk semua kumpulan partisi dalam sistem.  Nucleus SE tidak memerlukan ini karena objek diidentifikasi oleh indeks, bukan pointer. <br><br>  Prototipe panggilan: <br><br>  <b>NU_Partition_Pool_Pointers UNSIGNED (NU_PARTITION_POOL ** pointer_list, maksimum_pointers UNSIGNED);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_PARTITION_POOL</b> ;  array diisi dengan pointer ke kumpulan yang terkonfigurasi dalam sistem; <br>  <b>maximum_pointers</b> - jumlah maksimum pointer yang dapat ditempatkan dalam array. <br><br>  Nilai pengembalian: <br><br>  Jumlah <b>NU_PARTITION_POOL</b> pointer ditempatkan dalam array. <br><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Ketika mengembangkan Nucleus SE, salah satu tugas utama adalah untuk memastikan kompatibilitas kode tingkat tinggi dengan Nucleus RTOS.  Kolam partisi tidak terkecuali, dan, dari sudut pandang pengembang, mereka diimplementasikan dalam banyak cara yang sama seperti di RTOS Inti.  Beberapa bidang ketidakcocokan yang ada dapat diterima, meskipun perlu dipertimbangkan bahwa kode akhir lebih mudah dipahami dan lebih efisien dalam hal memori.  Namun, panggilan Nucleus RTOS API dapat digunakan hampir secara langsung sebagai panggilan Nucleus SE.  Di masa depan, sebuah artikel direncanakan dengan informasi tentang penggunaan Nucleus SE oleh pengguna Nucleus RTOS. <br><br><h3>  Pengidentifikasi Objek </h3><br>  Dalam Nucleus RTOS, semua objek dijelaskan oleh struktur data (unit kontrol) dari tipe tertentu.  Penunjuk ke blok kontrol ini digunakan sebagai pengidentifikasi untuk kumpulan partisi.  Saya memutuskan bahwa Nucleus SE memerlukan pendekatan yang berbeda untuk penggunaan memori yang lebih efisien.  Semua objek kernel dijelaskan oleh beberapa tabel dalam RAM dan / atau ROM.  Ukuran tabel ini ditentukan oleh jumlah jenis yang dapat dikonfigurasi dari semua objek.  Pengidentifikasi untuk objek tertentu adalah indeks dalam tabel ini.  Oleh karena itu, saya menentukan <b>NUSE_PARTITION_POOL menjadi</b> setara dengan <b>U8</b> , setelah itu variabel (bukan pointer) dari tipe ini berfungsi sebagai pengidentifikasi tugas.  Ketidakcocokan sedikit ini mudah diketahui jika kode porting dari atau ke Nucleus RTOS.  Pengidentifikasi objek biasanya disimpan dan dikirim tidak berubah. <br><br>  Nucleus RTOS juga mendukung kumpulan partisi penamaan.  Nama-nama ini hanya digunakan untuk debugging.  Saya mengecualikan mereka dari Nucleus SE untuk menghemat memori. <br><br><h3>  Jumlah bagian dan volumenya </h3><br>  Dalam Nucleus RTOS, kumpulan partisi dikonfigurasikan berdasarkan total volume kumpulan dan volume partisi (yang membawa 2 pointer lebih banyak).  Parameter ini didefinisikan sebagai TANDA TANGAN (sekitar 32 bit).  Dalam Nucleus SE, kumpulan partisi dikonfigurasikan berdasarkan ukuran partisi (untuk yang byte tambahan telah ditambahkan) dan jumlah total partisi.  Parameter-parameter ini masing-masing didefinisikan sebagai U16 dan U8. <br><br><h3>  Panggilan API yang belum direalisasi </h3><br>  Nucleus RTOS mendukung 7 panggilan untuk bekerja dengan kumpulan partisi, 3 di antaranya tidak diimplementasikan di Nucleus SE.  Rincian lebih lanjut tentang tantangan ini dan alasan pengecualian mereka diuraikan di atas. <br><br>  Artikel selanjutnya adalah tentang sinyal. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426477/">https://habr.com/ru/post/id426477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426465/index.html">‚ÄúKami mengubah medan‚Äù - IT menuju ke lokasi konstruksi yang besar</a></li>
<li><a href="../id426469/index.html">Telegram sebagai standar perusahaan</a></li>
<li><a href="../id426471/index.html">Bagaimana data spyware bocor</a></li>
<li><a href="../id426473/index.html">Arsitektur redux. Ya atau tidak</a></li>
<li><a href="../id426475/index.html">Miya - asisten dari smartphone</a></li>
<li><a href="../id426479/index.html">Bangku tes buatan sendiri untuk motherboard</a></li>
<li><a href="../id426481/index.html">Hexagon Maps in Unity: Path Finder, Pemain Regu, Animasi</a></li>
<li><a href="../id426483/index.html">Seseorang yang menyusul Tesla. Agar lebih menguntungkan</a></li>
<li><a href="../id426485/index.html">Tes Qt 5 Ketiga dengan PVS-Studio</a></li>
<li><a href="../id426487/index.html">Tes otomatisasi dari awal. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>