<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöà üíí ‚òîÔ∏è Automatisiertes Programmverwaltungsmodell üßôüèΩ üë©üèæ‚Äçüç≥ ‚õèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Einleitung 
 In [1] wurde eine Antwort auf die Frage gegeben, was als automatisches Programmieren (AP) zu betrachten ist, das Modell einer Finite-S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisiertes Programmverwaltungsmodell</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1. Einleitung </h3><br>  In [1] wurde eine Antwort auf die Frage gegeben, was als automatisches Programmieren (AP) zu betrachten ist, das Modell einer Finite-State-Maschine (SC) wurde jedoch nicht im Detail als Steuerungsmodell f√ºr automatische Programme beschrieben.  Es ist klar, dass ein reiner abstrakter Automat f√ºr diese Rolle nicht geeignet ist, weil  begrenzt durch die Anzahl der Kan√§le.  Das Strukturmodell des Automaten sowie die ihm entsprechende Theorie der Strukturautomaten lassen jedoch noch keine Antwort auf die Wahl des Automatenmodells zu. <br><br>  Das Problem beginnt mit der Tatsache, dass es unter den vielen Arbeiten zur Theorie der endlichen Automaten (TCA) nur wenige gibt, die das Modell eines strukturellen endlichen Automaten (SCA) definieren.  Man kann zwar verstehen, dass ein struktureller Automat ein [strukturelles] Diagramm elementarer Automaten (Funktionselemente) ist, das ein Modell eines abstrakten Automaten [2] implementiert.  Man erinnere sich, dass gem√§√ü der Theorie alles damit beginnt, ein Ger√§temodell in Form eines abstrakten Automaten zu erstellen, und dann besteht die Aufgabe darin, eine digitale Schaltung zu synthetisieren, die es implementiert [3]. <br><br>  Das Programmieren sieht auf den ersten Blick wie eine Synthese digitaler Schaltkreise aus.  Aber nur am Anfang.  Erstens beginnt hier und da alles mit einem Algorithmus.  Zweitens haben die strukturellen Probleme der Organisation und Implementierung digitaler Schaltungen und der Programmierung viel gemeinsam, insbesondere im Zusammenhang mit der parallelen Programmierung.  Aber wir werden das Thema Parallelit√§t separat diskutieren.  In der Zwischenzeit besteht unsere Aufgabe darin, das Modell einer Finite-State-Maschine auszuw√§hlen und / oder zu modifizieren, was f√ºr Programmierer, die mit verschiedenen Softwaretools verw√∂hnt sind, verst√§ndlich, praktisch und angenehm w√§re. <br><br>  Die Frage ist nat√ºrlich sofort logisch - warum ein weiteres und eher ungew√∂hnliches ‚Äûautomatisches Toolkit‚Äú?  Wir werden versuchen, diese Frage zu beantworten, indem wir ein Modell der [verschachtelten] automatischen Steuerung definieren und dabei auch die Vorteile im Vergleich zum √ºblichen Programmiermodell ber√ºcksichtigen. <br><a name="habracut"></a><br><h3>  2. Definition des Steuerungsmodells von Automatikprogrammen </h3><br>  Im Verlauf der Evolution hat die Programmierpraxis bestimmte Anforderungen an das Programmverwaltungsmodell gestellt.  Es muss anerkannt werden, dass das Modell einer klassischen Finite-State-Maschine ihnen eher wenig entspricht.  Und wenn die Aufgabe darin besteht, Automaten in der Programmierung zu verwenden, muss diese angepasst werden.  Es ist w√ºnschenswert, dies im Rahmen der Automatentheorie zu tun.  Die Hauptanspr√ºche an den bestehenden AP reduzieren sich auf die Tatsache, dass diese Bedingung verletzt wird. <br><br>  <i>Definition 1.</i> Wir bezeichnen die <i>disjunktive Normalform endlicher Automaten (DNFA) als</i> vollst√§ndig definierte endliche Automaten, deren √úberg√§nge durch elementare Konjunktionen logischer Variablen gekennzeichnet sind. <br><br>  Das DNA-Modell basiert auf formalen Modellen vollst√§ndig (vollst√§ndig) definierter <i>Automaten mit einem abstrakten Zustand</i> [4] und <i>logischen Automaten</i> [5]. <br><br>  <i>Definition 2.</i> Wir nennen die <i>disjunktive Form eines endlichen Automaten (DFA) einen</i> Automaten in Form eines DFA, der nur <i>resultierende √úberg√§nge enth√§lt</i> . <br><br>  Die mit Ausgangssignalen gekennzeichneten √úberg√§nge und √úberg√§nge mit einem Strich anstelle der Ausgangssignale, die den aktuellen Zustand des Automaten √§ndern, werden als effektive √úberg√§nge klassifiziert.  √úberg√§nge, die nicht in der Beschreibung des disjunktiven Automaten enthalten sind, stellen eine <i>Hinzuf√ºgung des DKA (DDA)</i> zu dem vollst√§ndig definierten DFA-Automaten dar.  Eine solche Addition ist ein Automat, der aus isolierten Zust√§nden mit √úberg√§ngen in Form von Schleifen und mit Strichen anstelle der Ausgangssignale besteht. <br><br><h3>  3. Das Speichermodell f√ºr das Berechnungsmodell AP </h3><br>  Das Vorhandensein vieler Ein- und Ausg√§nge des DFA legt die Parallelit√§t der damit verbundenen Software-Operatoren / Funktionen fest.  F√ºr die korrekte Implementierung ist ein Speichermodell vom Typ CREW (Concurrent Read Exclusive - Write) erforderlich [6].  Innerhalb seines Rahmens ist das Lesen aktueller Datenwerte seitens der Menge aller Funktionen (Pr√§dikate und Aktionen) erlaubt, und nur eine von ihnen darf <i>allgemeine Daten</i> f√ºr parallel ausf√ºhrbare Aktionen √§ndern. <br><br>  Das automatische Steuerungsmodell beschr√§nkt im Gegensatz zum Multi-Thread-Rechenmodell die Ausf√ºhrung der Operatoren / Funktionen des automatischen Programms eindeutig auf die Grenzen eines diskreten Zeitzyklus.  In einer solchen Situation k√∂nnen √Ñnderungen des Speichers durch Aktionen, die im aktuellen Taktzyklus ausgef√ºhrt werden, in den <i>"Schattenspeicher" geschrieben werden</i> , so dass er nach Abschluss und vor dem Start des n√§chsten diskreten Taktzyklus seine neuen Werte annimmt. <br><br>  Die Interaktion von Automatenprogrammierern mit dem Speicher wird als <i>Schattenspeichermodell bezeichnet</i> .  Dieses Modell ist ein wesentlicher Bestandteil des allgemeinen Modells der automatischen Programmierung.  Es stellt die Richtigkeit des Parallelbetriebs der AP-Bediener sicher und vereinfacht die Programmierung von Parallelprozessen. <br><br>  Im Rahmen des Speichermodells werden komplexe und wenig zuverl√§ssige Mechanismen zur Multithread-Synchronisation der Prozesse eigentlich nicht ben√∂tigt (Details siehe [7]).  Aufgrund der √Ñquivalenz von Automaten und <i>Algorithmenschemata (GAW)</i> [8] schr√§nkt das automatische Programmiermodell die Anwendung jedoch nicht ein. <br><br><h3>  4. Verschachtelte und Tr√§gheitsmodelle von Automaten </h3><br>  Die Aufgabe, ein Modell des logischen Elements der Verz√∂gerung zu erstellen, das weiter als Beispiel gew√§hlt wurde, demonstriert einerseits die Probleme des klassischen Automatenmodells und spiegelt andererseits die Eigenschaften des DFA-Modells wider, das algorithmische Probleme mit visuelleren und bequemeren Mitteln l√∂st.  Das eingef√ºhrte Modell verschachtelter Automaten erzeugt eine Unterklasse von Automatenmodellen, im Folgenden als <i>Inertialautomaten bezeichnet</i> , und eine entsprechende Unterklasse von <i>Inertialalgorithmen</i> . <br><br>  Es sei also die Aufgabe, ein diskretes Modell eines Verz√∂gerungslogikelements zu erstellen, das die √úbertragung eines bin√§ren Eingangssignals implementiert.  Dar√ºber hinaus fallen die Zeiten ihrer Verz√∂gerungen t01 bzw. t10 zum Einheits- und Nullzustand im allgemeinen Fall nicht zusammen. <br><br>  Das einfachste Modell einer <i>einzelnen Verz√∂gerung</i> in Form eines mehligen Automaten ist in Abb. 1 dargestellt.  1 (siehe zum Vergleich das Verz√∂gerungsmodell in [2]).  Seine Verz√∂gerungen werden durch einen einzelnen diskreten Taktzyklus bestimmt.  Komplexere Modelle von <i>Transportverz√∂gerungen</i> (Einzelheiten zu den Verz√∂gerungsarten siehe [9]) in Form eines Miley-Automaten bzw. eines kombinierten Miley-Moore-Modells sind in Abb. 1 dargestellt.  2a und fig.  2b. <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="Bild"><br>  Abb.  1. Einheitsverz√∂gerungsmodell in Form eines Meilenautomaten <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="Bild"><br>  Abb.  2. Das Transportversp√§tungsmodell von Miles (a) und Miles-Moore (b) <br><br>  Das Eingangssignal x3 (wir erinnern uns, dass es im automatischen Programm dem Pr√§dikat [1] entspricht) nimmt einen wahren Wert an, wenn der Wert des Taktz√§hlers gleich dem Wert der Variablen t gleich der Verz√∂gerung t01 oder t10 ist.  Der Wert der Variablen t wird den Signalen y3 und y4 zugeordnet (im Programm die gleichnamigen Aktionsfunktionen wie die Ausgangssignale).  Die Signale y1, y2 setzen den Wert der Variablen, die die Modellausgabe darstellt.  Das Signal y5 erh√∂ht den Taktz√§hler, der durch das Signal y6 zur√ºckgesetzt wird. <br><br>  <i>Bemerkung 2. Die internen Zust√§nde des Modells in Abb.</i>  <i>In 1 ist es zweckm√§√üig, einen Ausgabezustand eines Elements zuzuordnen.</i>  <i>Dadurch k√∂nnen wir nicht nur die Operatoren y1 und y2, sondern auch die Ausgabevariable selbst ausschlie√üen.</i> <i><br></i> <br>  Die Implementierung der Einbettung von Automaten √§hnlich wie beim Aufrufen von Unterprogrammen bildet die Technologie der modularen Automatisierungsprogrammierung.  Gleichzeitig ist dies auf Software-Ebene im Gegensatz zu √§hnlichen Versuchen auf Hardware-Ebene (siehe [10] zum Vergleich) viel einfacher.  Dazu m√ºssen Sie den Programmaufruf des verschachtelten Automaten einf√ºgen, und dann organisiert der Kern der Implementierung von Automaten wie ein normaler Prozessor die R√ºckkehr der Steuerung zur aktuellen Ebene der Verschachtelung. <br><br>  <i>Definition 3. Verschachtelte Automaten</i> werden Automaten mit einem Endzustand genannt, dessen √úbergang den Vorgang der R√ºckkehr zur vorherigen Ebene (Rang) der Verschachtelung startet. <br><br>  Die korrekte Implementierung der Verschachtelung von Automaten schr√§nkt die Prozedur f√ºr deren Erstellung ein.  Erstens kann ein verschachtelter Automat nur untergeordnet sein.  Dar√ºber hinaus kann ein Top-Level-Automat mit Ausnahme von Rang Null auch ein verschachtelter Automat sein.  Zweitens kann bei jedem √úbergang <b>nur ein</b> verschachtelter Automat erstellt werden.  Der Mechanismus verschachtelter Automaten schafft auch die Grundlage f√ºr die Implementierung rekursiver Algorithmen, die auf automatischer Steuerung basieren. <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="Bild"><br>  Abb.  3. Verz√∂gerungsmodell in Form verschachtelter Automaten <br><br>  Fig. 3 zeigt das Verz√∂gerungsmodell, wobei Fig. 3a das Modell der oberen Ebene darstellt, und Fig. 3b und Fig. 3b das Verz√∂gerungsmodell.  3c - Varianten verschachtelter Automaten f√ºr Transport- und <i>Tr√§gheitsverz√∂gerungen</i> (Einzelheiten zu Verz√∂gerungsarten siehe [8]).  Gleichzeitig sind dies Beispiele f√ºr zwei Arten von verschachtelten Automaten - <i>gew√∂hnliche</i> und <i>Tr√§gheit</i> .  Der Typ eines verschachtelten Automaten wird durch den Namen seiner Endzust√§nde definiert: Ein Zustand mit dem Namen "00" bestimmt den √ºblichen Austritt aus dem verschachtelten Automaten, und ein Zustand mit dem Namen "XX" √§ndert den aktuellen Zustand des Automaten der obersten Ebene nicht. <br><br>  Eine wichtige Erkl√§rung f√ºr das Verst√§ndnis des Tr√§gheitsverz√∂gerungsalgorithmus.  Der Wert des Pr√§dikats x1 h√§ngt daf√ºr (siehe Fig. 3c) von dem √úbergang ab, auf dem der eingebettete Automat erzeugt wird.  Mit anderen Worten, das Pr√§dikat im Zustand "0" steuert die Beibehaltung von "Null" am Eingang und im Zustand "1" im Gegensatz zu "Einheiten".  Wenn der Wert am Eingang Null ist, m√ºssen Sie den wahren Wert zur√ºckgeben.  Wenn ferner die Stabilit√§t des Eingangs verletzt wird (der Wert x1 ist falsch) und die Verz√∂gerungszeit nicht abgelaufen ist (der Wert x3 ist falsch), wird der Austritt aus der eingebetteten Maschine durch den Tr√§gheitszustand realisiert (siehe Fig. 3c). <br><br>  <i>Definition 4.</i> Automaten, einschlie√ülich des Aufrufs verschachtelter Automaten mit einem endg√ºltigen Tr√§gheitszustand, werden als <i>Tr√§gheitsautomaten bezeichnet</i> . <br><br>  In dem Modell in Fig. 3a erzeugt die Aktion z1 (das Symbol z ist f√ºr die Namen von Aktionen ausgew√§hlt, die einen Aufruf eines verschachtelten Automaten enthalten) einen verschachtelten Automaten, wenn ein Verz√∂gerungswert definiert ist.  Als Teil dieser Aktion wird der spezifizierte Verz√∂gerungstyp bestimmt, in √úbereinstimmung mit dem eine der verschachtelten Automaten erzeugt wird, wie in Fig. 3b oder Fig. 4 gezeigt.  3c. <br><br>  Auf der obersten Ebene der Hierarchie stimmt die Ansicht des Automaten in Fig. 3a in der Struktur vollst√§ndig mit dem Modell in Fig. 1 √ºberein und unterscheidet sich nur durch das Vorhandensein von Aktionen auf den √úberg√§ngen.  Verz√∂gerungen mit verschachtelten Automaten haben eine einfachere Form als das einstufige Modell in Abb. 2.  Ein verschachtelter Automat kann auch als eine Art "Bibliotheksautomat" betrachtet werden, der von jedem anderen Automaten aufgerufen werden kann. <br><br><h3>  3. Programmierung der Objektautomaten </h3><br>  Das automatische Steuerungsmodell verf√ºgt neben der grafischen Form auch √ºber eine einfache tabellarische Form - eine √úbergangstabelle (TP), die in C ++ effektiv interpretiert werden kann.  Innerhalb seines Rahmens kann ein separates Automatenprogramm (oder ein Teil davon) und dementsprechend dessen Definition in Form einer Programmschaltung S durch eine Klasse dargestellt werden.  In diesem Fall entsprechen die Speichermodelle den Eigenschaften der Klasse, die Menge der Operationen den Methoden der Klasse und die automatische Steuerung in Form eines TP beschreibt das Verhalten der Klasse.  Die Einf√ºhrung der Kontrolle in die Klasse erm√∂glicht es uns, √ºber aktive Objekte, oft auch Agenten genannt, usw. zu sprechen. <br><br>  Viele Objekte mit Verhalten in Form einer Automatensteuerung formalisieren das Konzept eines <i>Objektautomaten-Parallelprogramms</i> .  In diesem Fall kann das Modell eines beliebigen parallelen Programms durch ein Programmdiagramm dargestellt werden, in dem die Steuerung C in Form eines Automatennetzwerks dargestellt wird, wobei Komponentenautomaten das Verhalten aktiver Objekte beschreiben, der Speicher M durch eine Kombination von Eigenschaften von Objekten dargestellt wird und viele Operatoren A durch eine Kombination von Methoden von Programmobjekten dargestellt werden. <br><br>  In der VKPA-Umgebung wird die Rolle der automatisierten Programmiersprache der C ++ - Sprache zugewiesen.  In ‚Äûautomatischem C ++‚Äú sind Objekte mit Aktivit√§t / Verhalten ausgestattet und k√∂nnen Parallelit√§t beschreiben und implementieren, sowohl auf der Ebene der Methoden einzelner Objekte als auch auf der Ebene der Beschreibung der Parallelit√§t vieler Objekte. <br><br>  Bestehende Objektimplementierungen von AP sind ziemlich kompliziert.  In VKPa basiert die Objektimplementierung auf der Interpretation von Automaten und der dedizierten Steuerung des Programms.  Im Gegensatz zur direkten Implementierung von Automaten, wie sie beispielsweise in der SWITH-Technologie verwendet werden, entf√§llt hierdurch die Konvertierung eines Automatenmodells in ein Flussdiagrammmodell.  Der in VKPa verwendete Interpretationsalgorithmus √§hnelt der Methode zur Interpretation von Entscheidungstabellen von E. Hamby [12]. <br><br>  Sofern nicht anders angegeben, werden wir das Konzept eines Automatenprogramms weiter mit dem Konzept eines <i>Automatenobjekts (AO)</i> im Sinne von OOP verkn√ºpfen, wobei wir jedoch das oben eingef√ºhrte Konzept eines Objektautomaten-Parallelprogramms ber√ºcksichtigen.  Aus diesem Grund werden die Operatoren und der Speicher des AP durch die Methoden und Eigenschaften der aktiven Objekte bestimmt.  Automatenobjekte unterscheiden sich von gew√∂hnlichen Objekten durch das Vorhandensein von Verhalten, das durch das Zustandsmaschinenmodell bestimmt wird. <br><br><h3>  4. Schlussfolgerungen </h3><br>  Das Erstellen eines Modells verschachtelter Automaten ist ein Schritt in Richtung eines qualitativen Wandels in der Programmiertechnologie.  Das beschriebene Inertialmodell des Automaten √§hnelt dem Konzept historischer Zust√§nde in der UML.  Das √ºbliche Einbetten von Automaten hat eine analoge Programmierung, das "Inertial Embedding" hat es nicht, weil  In einem Programm k√∂nnen Sie nicht zu einem Befehl zur√ºckkehren, der einem Unterprogrammaufruf vorausgeht.  Und dies sind Elemente eines qualitativen Unterschieds zwischen automatischer Programmierung und gew√∂hnlicher Programmierung. <br><br>  Nat√ºrlich k√∂nnen Sie den Schattenspeicher in die gew√∂hnliche Programmierung einf√ºhren und die Parallelit√§t von Funktionen bezeichnen.  Aber im Rahmen des Automatenmodells hat all dies eine organische Form, sowohl in Bezug auf die Beschreibung als auch in Bezug auf die Leistung.  Alles wird durch die nat√ºrliche Parallelit√§t des Modells bestimmt.  Das Blockdiagrammmodell verf√ºgt nicht √ºber solche Funktionen. <br><br>  Aktive Objekte erweitern auch die Programmierm√∂glichkeiten.  Der ‚ÄûObjekt-Wrapper‚Äú wirkt sich jedoch qualitativ auf die automatische Programmierung aus und vereinfacht die Prozeduren zum Aufrufen und Implementieren verschachtelter Automaten.  Die Verwendung von [lokalen] Klasseneigenschaften erm√∂glicht es Ihnen, nicht nur Einbettungsalgorithmen, sondern auch beliebige rekursive Algorithmen zu implementieren. <br><br><div class="spoiler">  <b class="spoiler_title">Referenzliste</b> <div class="spoiler_text">  1. Turing-Maschine als Modell von automatischen Programmen.  [Elektronische Ressource], Zugriffsmodus: <a href="https://habr.com/ru/post/481998/">habr.com/de/post/481998</a> , kostenlos.  Yaz.  Russisch  (Datum der Behandlung 07.01.2020). <br>  2. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Einf√ºhrung in die Theorie der Automaten - M .: Wissenschaft.  Ch.  ed.  Phys.-Math.  Lit. 1985 .-- 320 p. <br>  3. GLUSHKOV V.M.  Synthese digitaler Maschinen.  M .: Fizmatgiz, 1962. <br>  4. ZAKREVSKY A.D.  Logische Synthese von Kaskadenschemata.  - M .: Wissenschaft.  Ch.  ed.  Phys.-Mat.  Lit. 1981. - 416 p. <br>  5. KUZNETSOV O.P.  Graphen logischer Automaten und ihrer Transformationen // Automation and Telemechanics.  - 1975. - Nr. 9.‚Äì S. 149-158. <br>  6. Kormen T., Leiserson Ch., Rivest R. Algorithmen: Konstruktion und Analyse - M .: MCCMO, 2001. - 960 p. <br>  7. Buch G., RAMBO J., Jacobson I. UML.  Benutzerhandbuch.  Zweite Auflage.  IT Academy: Moskau, 2007 .-- 493 p. <br>  8. BARANOV S.I.  Synthese der Firmware  - L.: Energy, 1979.- 232s. <br>  9. ARMSTRONG J.R.  Modellierung digitaler Systeme in der VHDL-Sprache: Aus dem Englischen / M .: Mir, 1992. - 175 p. <br>  10. HAMBARTSUMYAN A.A., ZAPOLSKYH E.N.  √úber einen Ansatz zur tempor√§ren Zerlegung von Automaten.  Ich, Avtomat.  und Telemech., 1981, Ausgabe 2, 135-144 <br>  11. SHALYTO A. A. Das Paradigma der automatischen Programmierung.  Wissenschaftliches und technisches Bulletin der Staatlichen Universit√§t f√ºr Informationstechnologien, Mechanik und Optik St. Petersburg.  Vol.  53. Automatisierte Programmierung.  2008, p.  3-23. <br>  12. HAMBI E. Programmieren von Entscheidungstabellen.  M .: Mir, 1976 .-- 86 p. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484588/">https://habr.com/ru/post/de484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484578/index.html">Service Level-Ziele - Google Experience (√úbersetzung des Google SRE-Buchkapitels)</a></li>
<li><a href="../de484580/index.html">Was Sie √ºber Simulatoren f√ºr das Ged√§chtnis wissen m√ºssen</a></li>
<li><a href="../de484582/index.html">ASP.NET MVC - Entity Framework, MySQL und Verwenden von Dependency Resolver zum Ausw√§hlen eines Repositorys</a></li>
<li><a href="../de484584/index.html">Warum brauchen wir einen Manager in einem IT-Projekt und was passiert, wenn dies nicht der Fall ist?</a></li>
<li><a href="../de484586/index.html">Arbeiten Sie mit IPv6 in PHP</a></li>
<li><a href="../de484590/index.html">Damit sich die Jungs nicht sch√§men zu zeigen</a></li>
<li><a href="../de484592/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 398 (13. - 19. Januar 2020)</a></li>
<li><a href="../de484596/index.html">Blazor Client Side Online Store: Teil 1 - Autorisierung oidc (oauth2) + Identity Server4</a></li>
<li><a href="../de484600/index.html">Microsoft Ignite The Tour Prague - Technische Konferenz</a></li>
<li><a href="../de484602/index.html">Buch ‚ÄûEntwicklung mobiler Anwendungen in C # f√ºr iOS und Android‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>