<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§•ğŸ¼ ğŸ›ƒ ğŸ‘µ ExpÃ©rience personnelle: passer du dÃ©veloppement C de bas niveau Ã  la programmation Java ğŸ˜ ğŸ¤¹ğŸ½ ğŸ’Š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article reflÃ¨te l'expÃ©rience personnelle de l'auteur, un programmeur de microcontrÃ´leurs passionnÃ©, qui, aprÃ¨s de nombreuses annÃ©es d'expÃ©rience dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ExpÃ©rience personnelle: passer du dÃ©veloppement C de bas niveau Ã  la programmation Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  L'article reflÃ¨te l'expÃ©rience personnelle de l'auteur, un programmeur de microcontrÃ´leurs passionnÃ©, qui, aprÃ¨s de nombreuses annÃ©es d'expÃ©rience dans le dÃ©veloppement de microcontrÃ´leurs en C (et un peu en C ++), a eu l'occasion de participer Ã  un projet Java majeur pour dÃ©velopper des logiciels pour les dÃ©codeurs TV fonctionnant sous Android.  Au cours de ce projet, j'ai pu collecter des notes sur les diffÃ©rences intÃ©ressantes entre les langages Java et C / C ++, Ã©valuer diffÃ©rentes approches d'Ã©criture de programmes.  L'article ne prÃ©tend pas Ãªtre une rÃ©fÃ©rence, il n'examine pas l'efficacitÃ© et la productivitÃ© des programmes Java.  Il s'agit plutÃ´t d'un recueil d'observations personnelles.  Sauf indication contraire, il s'agit d'une version Java SE 7. <br><a name="habracut"></a><br><h2>  DiffÃ©rences de syntaxe et constructions de contrÃ´le </h2><br>  En bref - les diffÃ©rences sont minimes, la syntaxe est trÃ¨s similaire.  Les blocs de code sont Ã©galement formÃ©s par une paire d'accolades {}.  Les rÃ¨gles de compilation des identifiants sont les mÃªmes que pour C / C ++.  La liste des mots clÃ©s est presque la mÃªme qu'en C / C ++.  Types de donnÃ©es intÃ©grÃ©s - similaires Ã  ceux de C / C ++.  Tableaux - tous sont Ã©galement dÃ©clarÃ©s Ã  l'aide de crochets. <br><br>  Le contrÃ´le construit if-else, while, do-while, for, switch sont Ã©galement presque complÃ¨tement identiques.  Il est Ã  noter qu'en Java il y avait des labels familiers aux programmeurs C (ceux qui sont utilisÃ©s avec le mot-clÃ© goto et dont l'utilisation est fortement dÃ©conseillÃ©e).  Cependant, Java a exclu la possibilitÃ© de passer Ã  une Ã©tiquette en utilisant goto.  Les Ã©tiquettes ne doivent Ãªtre utilisÃ©es que pour quitter les boucles imbriquÃ©es: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Pour amÃ©liorer la lisibilitÃ© des programmes en Java, une opportunitÃ© intÃ©ressante a Ã©tÃ© ajoutÃ©e pour sÃ©parer les chiffres des nombres longs avec un trait de soulignement: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  ExtÃ©rieurement, un programme Java n'est pas trÃ¨s diffÃ©rent d'un programme C familier. La principale diffÃ©rence visuelle est que Java n'autorise pas les fonctions, variables, dÃ©finitions de nouveaux types (structures), constantes, etc., qui sont "librement" situÃ©es dans le fichier source.  Java est un langage orientÃ© objet, donc toutes les entitÃ©s de programme doivent appartenir Ã  une classe.  Une autre diffÃ©rence importante est l'absence d'un prÃ©processeur.  Ces deux diffÃ©rences sont dÃ©crites plus en dÃ©tail ci-dessous. <br><br><h2>  Approche objet en langage C </h2><br>  Lorsque nous Ã©crivons de gros programmes en C, nous devons essentiellement travailler avec des objets.  Le rÃ´le de l'objet ici est jouÃ© par une structure qui dÃ©crit une certaine essence du Â«monde rÃ©elÂ»: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   â€“ Â«Â» struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Il existe Ã©galement en C des mÃ©thodes de traitement des "objets" - structures - fonctions.  Cependant, les fonctions ne sont pas essentiellement fusionnÃ©es avec les donnÃ©es.  Oui, ils sont gÃ©nÃ©ralement placÃ©s dans un seul fichier, mais Ã  chaque fois il est nÃ©cessaire de passer un pointeur sur l'objet Ã  traiter dans la fonction "typique": <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Vous ne pouvez utiliser Â«l'objetÂ» qu'aprÃ¨s avoir allouÃ© de la mÃ©moire pour le stocker: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  Dans un programme C, une fonction est gÃ©nÃ©ralement dÃ©finie qui est responsable de l'initialisation de Â«l'objetÂ» avant sa premiÃ¨re utilisation: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Ensuite, le cycle de vie d'un Â«objetÂ» en C est gÃ©nÃ©ralement le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Maintenant, nous listons les erreurs d'exÃ©cution possibles qui peuvent Ãªtre faites par le programmeur dans le cycle de vie de Â«l'objetÂ»: <br><br><ol><li>  Oubliez d'allouer de la mÃ©moire pour "l'objet" </li><li>  SpÃ©cifiez la mauvaise quantitÃ© de mÃ©moire allouÃ©e </li><li>  Oubliez d'initialiser "l'objet" </li><li>  Oubliez de libÃ©rer de la mÃ©moire aprÃ¨s avoir utilisÃ© l'objet </li></ol><br>  Il peut Ãªtre extrÃªmement difficile de dÃ©tecter de telles erreurs, car elles ne sont pas dÃ©tectÃ©es par le compilateur et apparaissent pendant le fonctionnement du programme.  De plus, leur effet peut Ãªtre trÃ¨s divers et affecter d'autres variables et Â«objetsÂ» du programme. <br><br><h2>  Approche des objets Java </h2><br>  Face Ã  OOP - programmation orientÃ©e objet, vous avez probablement entendu parler d'une des baleines OOP - encapsulation.  En Java, contrairement Ã  C, les donnÃ©es et les mÃ©thodes pour les traiter sont combinÃ©es ensemble et sont de Â«vraisÂ» objets.  En termes de POO, cela s'appelle l'encapsulation.  Une classe est une description d'un objet, l'analogue le plus proche d'une classe en C est de dÃ©finir un nouveau type en utilisant la structure typedef.  En termes Java, les fonctions qui appartiennent Ã  une classe sont appelÃ©es mÃ©thodes. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  L'idÃ©ologie du langage Java est basÃ©e sur l'Ã©noncÃ© Â«tout est un objetÂ».  Par consÃ©quent, il n'est pas surprenant que Java interdise la crÃ©ation de mÃ©thodes (fonctions) et de champs de donnÃ©es (variables) sÃ©parÃ©ment de la classe.  MÃªme la mÃ©thode main () familiÃ¨re, Ã  partir de laquelle le programme dÃ©marre, doit appartenir Ã  l'une des classes. <br><br>  Une dÃ©finition de classe en Java est analogue Ã  une dÃ©claration de structure en C. En dÃ©crivant une classe, vous ne crÃ©ez rien en mÃ©moire.  Un objet de cette classe apparaÃ®t lors de sa crÃ©ation par le nouvel opÃ©rateur.  La crÃ©ation d'un objet en Java est un analogue de l'allocation de mÃ©moire dans le langage C, mais, contrairement Ã  ce dernier, une mÃ©thode spÃ©ciale est automatiquement appelÃ©e lors de la crÃ©ation de l'objet - le constructeur de l'objet.  Le constructeur joue le rÃ´le de l'initialisation initiale de l'objet - un analogue de la fonction init () discutÃ©e prÃ©cÃ©demment.  Le nom du constructeur doit correspondre au nom de la classe.  Le constructeur ne peut pas retourner de valeur. <br><br>  Le cycle de vie d'un objet dans un programme Java est le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Notez que le nombre d'erreurs possibles dans un programme Java est beaucoup plus petit que dans un programme C. Oui, vous pouvez toujours oublier de crÃ©er un objet avant la premiÃ¨re utilisation (ce qui, cependant, conduira Ã  une exception NullPointerException facilement dÃ©boguÃ©e), mais comme pour les autres erreurs inhÃ©rentes Programmes C, la situation est en train de changer fondamentalement: <br><br><ol><li>  Il n'y a pas d'opÃ©rateur sizeof () en Java.  Le compilateur Java calcule lui-mÃªme la quantitÃ© de mÃ©moire pour stocker l'objet.  Par consÃ©quent, il n'est pas possible de spÃ©cifier la mauvaise taille de la sÃ©lection. </li><li>  L'initialisation de l'objet a lieu au moment de la crÃ©ation.  Il est impossible d'oublier l'initialisation. </li><li>  La mÃ©moire occupÃ©e par l'objet n'a pas besoin d'Ãªtre libÃ©rÃ©e; le garbage collector fait ce travail.  Il est impossible d'oublier de supprimer un objet aprÃ¨s utilisation - il y a moins de risque d'effet de Â«fuite de mÃ©moireÂ». </li></ol><br>  Ainsi, tout en Java est un objet d'une classe ou d'une autre.  Les exceptions sont des primitives qui ont Ã©tÃ© ajoutÃ©es au langage pour amÃ©liorer les performances et la consommation de mÃ©moire.  Vous trouverez plus d'informations sur les primitives ci-dessous. <br><br><h2>  MÃ©moire et collecteur d'ordures </h2><br>  Java conserve les concepts familiers de tas et de pile pour C / C ++, un programmeur.  Lors de la crÃ©ation d'un objet avec le nouvel opÃ©rateur, la mÃ©moire pour stocker l'objet est empruntÃ©e au tas.  Cependant, un lien vers un objet (un lien est un analogue d'un pointeur), si l'objet crÃ©Ã© ne fait pas partie d'un autre objet, est placÃ© sur la pile.  Sur le tas sont stockÃ©s les "corps" des objets, et sur la pile sont des variables locales: rÃ©fÃ©rences aux objets et types primitifs.  Si le segment de mÃ©moire existe pendant l'exÃ©cution du programme et est disponible pour tous les threads du programme, la pile appartient Ã  la mÃ©thode et n'existe que pendant son exÃ©cution et est Ã©galement inaccessible aux autres threads du programme. <br><br>  Java est inutile et plus encore - vous ne pouvez pas libÃ©rer manuellement la mÃ©moire occupÃ©e par un objet.  Ce travail est effectuÃ© par le garbage collector en mode automatique.  Le runtime contrÃ´le s'il est possible d'atteindre chaque objet du tas Ã  partir de l'emplacement actuel du programme en suivant les liens d'objet Ã  objet.  Sinon, un tel objet est reconnu comme Â«poubelleÂ» et devient un candidat Ã  la suppression. <br><br>  Il est important de noter que la suppression elle-mÃªme ne se produit pas au moment oÃ¹ l'objet Â«n'est plus nÃ©cessaireÂ» - le garbage collector dÃ©cide de la suppression, et la suppression peut Ãªtre retardÃ©e autant que souhaitÃ©, jusqu'Ã  la fin du programme. <br><br>  Bien sÃ»r, le travail du garbage collector nÃ©cessite une surcharge du processeur.  Mais en retour, il soulage le programmeur d'un gros mal de tÃªte liÃ© Ã  la nÃ©cessitÃ© de libÃ©rer de la mÃ©moire aprÃ¨s la fin de l'utilisation des "objets".  En fait, nous Â«prenonsÂ» la mÃ©moire quand nous en avons besoin et nous l'utilisons, sans penser que nous devons la libÃ©rer aprÃ¨s nous-mÃªmes. <br><br>  En parlant de variables locales, rappelons l'approche de Java pour leur initialisation.  Si en C / C ++ une variable locale non initialisÃ©e contient une valeur alÃ©atoire, alors le compilateur Java ne permettra tout simplement pas de la laisser non initialisÃ©e: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Liens - Pointeurs de remplacement </h2><br>  Java n'a pas de pointeurs; par consÃ©quent, un programmeur Java n'a pas la possibilitÃ© de faire l'une des nombreuses erreurs qui se produisent lors de l'utilisation des pointeurs.  Lorsque vous crÃ©ez un objet, vous obtenez un lien vers cet objet: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity â€“  . Entity entity = new Entity();</span></span></code> </pre><br>  En C, le programmeur avait le choix: comment passer, disons, une structure Ã  une fonction.  Vous pouvez passer par valeur: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    â€“   : //    . void process(Data *data);</span></span></code> </pre> <br>  Le passage par la valeur garantissait que la fonction ne modifierait pas les donnÃ©es de la structure, mais Ã©tait inefficace en termes de performances - au moment oÃ¹ la fonction a Ã©tÃ© appelÃ©e, une copie de la structure a Ã©tÃ© crÃ©Ã©e.  Passer par un pointeur est beaucoup plus efficace: en fait, l'adresse en mÃ©moire oÃ¹ se trouve la structure a Ã©tÃ© transmise Ã  la fonction. <br><br>  En Java, il n'y avait qu'une seule faÃ§on de passer un objet Ã  une mÃ©thode - par rÃ©fÃ©rence.  Passer par rÃ©fÃ©rence en Java est analogue Ã  passer par un pointeur en C: <br><ul><li>  la copie (clonage) de la mÃ©moire ne se produit pas, </li><li>  en fait, l'adresse de la localisation de cet objet est transmise. </li></ul><br>  Cependant, contrairement au pointeur du langage C, un lien Java ne peut pas Ãªtre incrÃ©mentÃ© / dÃ©crÃ©mentÃ©.  Â«ExÃ©cuterÂ» les Ã©lÃ©ments d'un tableau Ã  l'aide d'un lien vers celui-ci en Java ne fonctionnera pas.  Tout ce qui peut Ãªtre fait avec un lien est de lui donner une valeur diffÃ©rente. <br><br>  Bien sÃ»r, l'absence de pointeurs en tant que tels rÃ©duit le nombre d'erreurs possibles, cependant, l'analogue du pointeur nul reste dans la langue - une rÃ©fÃ©rence nulle dÃ©signÃ©e par le mot-clÃ© null. <br><br>  Une rÃ©fÃ©rence nulle est un casse-tÃªte pour un programmeur Java, comme  force la rÃ©fÃ©rence d'objet Ã  Ãªtre vÃ©rifiÃ©e pour null avant de l'utiliser ou Ã  gÃ©rer les exceptions NullPointerException.  Si cela n'est pas fait, le programme se bloquera. <br><br>  Ainsi, tous les objets en Java sont transmis via des liens.  Les types de donnÃ©es primitifs (int, long, char ...) sont passÃ©s par valeur (plus d'informations sur les primitives sont donnÃ©es ci-dessous). <br><br><h2>  FonctionnalitÃ©s de Java Link </h2><br>  L'accÃ¨s Ã  n'importe quel objet du programme se fait via un lien - cela a clairement un effet positif sur les performances, mais cela peut surprendre un dÃ©butant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Arguments de mÃ©thode et valeurs de retour - tout est transmis via le lien.  En plus des avantages, il y a un inconvÃ©nient par rapport aux langages C / C ++, oÃ¹ nous pouvons explicitement interdire aux fonctions de changer la valeur transmise via un pointeur Ã  l'aide d'un qualificatif const: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Autrement dit, le langage C vous permet de suivre cette erreur au stade de la compilation.  Java a Ã©galement le mot clÃ© const, mais il est rÃ©servÃ© pour les futures versions et n'est actuellement pas utilisÃ© du tout.  Dans une certaine mesure, le mot clÃ© final est appelÃ© Ã  remplir son rÃ´le.  Cependant, il ne protÃ¨ge pas l'objet transmis Ã  la mÃ©thode contre les modifications: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  Le fait est que le mot-clÃ© final dans ce cas est appliquÃ© au lien, et non Ã  l'objet vers lequel le lien pointe.  Si final est appliquÃ© Ã  la primitive, le compilateur se comporte comme prÃ©vu: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Les liens Java sont trÃ¨s similaires aux liens du langage C ++. <br><br><h2>  Primitives Java </h2><br>  Chaque objet Java, en plus des champs de donnÃ©es, contient des informations de support.  Si nous voulons fonctionner, par exemple, dans des octets sÃ©parÃ©s et que chaque octet est reprÃ©sentÃ© par un objet, alors dans le cas d'un tableau d'octets, la surcharge de mÃ©moire peut plusieurs fois dÃ©passer la taille utilisable. <br>  Afin que Java reste suffisamment efficace dans les cas dÃ©crits ci-dessus, la prise en charge des types primitifs - primitifs - a Ã©tÃ© ajoutÃ©e au langage. <br><table><tbody><tr><th>  Primitif </th><th>  Afficher </th><th>  Profondeur de bits </th><th>  Analogue possible en C </th></tr><tr><td>  octet </td><td rowspan="5">  Entier </td><td>  8 </td><td>  char </td></tr><tr><td>  court </td><td>  16 </td><td>  court </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (long) </td></tr><tr><td>  longue </td><td>  64 </td><td>  longue </td></tr><tr><td>  flotter </td><td>  NumÃ©ros Ã  virgule flottante </td><td>  32 </td><td>  flotter </td></tr><tr><td>  double </td><td></td><td>  64 </td><td>  double </td></tr><tr><td>  boolÃ©en </td><td>  Logique </td><td>  - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Toutes les primitives ont leurs analogues dans le langage C. Cependant, la norme C ne dÃ©termine pas la taille exacte des types entiers, mais la plage de valeurs que ce type peut stocker est fixe.  Souvent, le programmeur veut garantir la mÃªme profondeur de bits pour diffÃ©rentes machines, ce qui conduit Ã  l'apparition de types comme uint32_t dans le programme, bien que toutes les fonctions de bibliothÃ¨que nÃ©cessitent juste des arguments de type int. <br>  Ce fait ne peut Ãªtre attribuÃ© aux avantages de la langue. <br><br>  Les primitives d'entier Java, contrairement Ã  C, ont des profondeurs de bits fixes.  Ainsi, vous n'avez pas Ã  vous soucier de la profondeur de bits rÃ©elle de la machine sur laquelle le programme Java s'exÃ©cute, ainsi que de l'ordre des octets ("rÃ©seau" ou "Intel").  Ce fait permet de rÃ©aliser le principe Â«il est Ã©crit une fois - il se rÃ©alise partoutÂ». <br><br>  De plus, en Java, toutes les primitives entiÃ¨res sont signÃ©es (le langage n'a pas le mot-clÃ© non signÃ©).  Cela Ã©limine la difficultÃ© d'utiliser des variables signÃ©es et non signÃ©es dans une seule expression inhÃ©rente Ã  C. <br><br>  En conclusion, l'ordre des octets dans les primitives multi-octets en Java est fixe (octet bas Ã  adresse basse, Little-endian, ordre inverse). <br><br>  Les inconvÃ©nients de l'implÃ©mentation d'opÃ©rations avec des primitives en Java incluent le fait qu'ici, comme dans le programme C / C ++, le dÃ©bordement de la grille de bits peut se produire, sans exception: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Ainsi, les donnÃ©es en Java sont reprÃ©sentÃ©es par deux types d'entitÃ©s: les objets et les primitives.  Les primitifs violent le concept de Â«tout est un objetÂ», mais dans certaines situations, ils sont trop efficaces pour ne pas les utiliser. <br><br><h2>  HÃ©ritage </h2><br>  L'hÃ©ritage est une autre baleine OOP dont vous avez probablement entendu parler.  Si vous rÃ©pondez briÃ¨vement Ã  la question Â«pourquoi l'hÃ©ritage est-il nÃ©cessaire du toutÂ», alors la rÃ©ponse sera Â«rÃ©utilisation du codeÂ». <br><br>  Supposons que vous programmiez en C et que vous ayez une Â«classeÂ» bien Ã©crite et dÃ©boguÃ©e - une structure et des fonctions pour le traiter.  Ensuite, le besoin se fait sentir de crÃ©er une Â«classeÂ» similaire, mais avec des fonctionnalitÃ©s amÃ©liorÃ©es, et la Â«classeÂ» de base est toujours nÃ©cessaire.  Dans le cas du langage C, vous n'avez qu'une seule faÃ§on de rÃ©soudre ce problÃ¨me: la composition.  Il s'agit de crÃ©er une nouvelle structure Ã©tendue - "classe", qui devrait contenir un pointeur sur la structure de base "classe": <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Java en tant que langage orientÃ© objet vous permet d'Ã©tendre les fonctionnalitÃ©s des classes existantes en utilisant le mÃ©canisme d'hÃ©ritage: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Il convient de noter que Java n'interdit en aucun cas l'utilisation de la composition comme un moyen d'Ã©tendre les fonctionnalitÃ©s de classes dÃ©jÃ  Ã©crites.  De plus, dans de nombreuses situations, la composition est prÃ©fÃ©rable Ã  l'hÃ©ritage. <br><br>  GrÃ¢ce Ã  l'hÃ©ritage, les classes en Java sont organisÃ©es dans une structure hiÃ©rarchique, chaque classe a nÃ©cessairement un et un seul Â«parentÂ» et peut avoir n'importe quel nombre Â«d'enfantsÂ».  Contrairement Ã  C ++, une classe en Java ne peut pas hÃ©riter de plusieurs parents (cela rÃ©sout le problÃ¨me de "l'hÃ©ritage diamant"). <br><br>  Pendant l'hÃ©ritage, la classe dÃ©rivÃ©e obtient Ã  son emplacement tous les champs et mÃ©thodes publics et protÃ©gÃ©s de sa classe de base, ainsi que la classe de base de sa classe de base, et ainsi de suite dans la hiÃ©rarchie d'hÃ©ritage. <br><br>  Au sommet de la hiÃ©rarchie d'hÃ©ritage se trouve le progÃ©niteur commun de toutes les classes Java - la classe Object, la seule qui n'a pas de parent. <br><br><h2>  Identification de type dynamique </h2><br>  L'un des points clÃ©s du langage Java est la prise en charge de l'identification de type dynamique (RTTI).  En termes simples, RTTI vous permet de remplacer un objet d'une classe dÃ©rivÃ©e oÃ¹ une rÃ©fÃ©rence Ã  la base est requise: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Ayant un lien Ã  l'exÃ©cution, vous pouvez dÃ©terminer le vrai type de l'objet auquel le lien se rÃ©fÃ¨re - en utilisant l'opÃ©rateur instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Substitutions de mÃ©thode </h2><br>  RedÃ©finir une mÃ©thode ou une fonction signifie remplacer son corps au stade de l'exÃ©cution du programme.  Les programmeurs C sont conscients de la capacitÃ© d'un langage Ã  modifier le comportement d'une fonction pendant l'exÃ©cution du programme.  Il s'agit d'utiliser des pointeurs de fonction.  Par exemple, vous pouvez inclure un pointeur vers une fonction dans la structure de la structure et attribuer diverses fonctions au pointeur pour modifier l'algorithme de traitement des donnÃ©es de cette structure: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  En Java, comme dans d'autres langages OOP, les mÃ©thodes de substitution sont inextricablement liÃ©es Ã  l'hÃ©ritage.  Une classe dÃ©rivÃ©e accÃ¨de aux mÃ©thodes publiques et protÃ©gÃ©es de la classe de base.  Outre le fait qu'il puisse les appeler, vous pouvez changer le comportement d'une des mÃ©thodes de la classe de base sans changer sa signature.  Pour ce faire, il suffit de dÃ©finir une mÃ©thode avec exactement la mÃªme signature dans la classe dÃ©rivÃ©e: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Il est trÃ¨s important que la signature (nom de la mÃ©thode, valeur de retour, arguments) corresponde exactement.  Si le nom de la mÃ©thode correspond et que les arguments diffÃ¨rent, la mÃ©thode est surchargÃ©e, plus d'informations sur ce qui suit. <br><br><h2>  Polymorphisme </h2><br>  Comme l'encapsulation et l'hÃ©ritage, la troisiÃ¨me baleine OOP - le polymorphisme - a Ã©galement une sorte d'analogue dans le langage C orientÃ© vers la procÃ©dure. <br><br>  Supposons que nous ayons plusieurs "classes" de structures avec lesquelles vous souhaitez effectuer le mÃªme type d'action, et que la fonction qui exÃ©cute cette action doit Ãªtre universelle - doit "pouvoir" fonctionner avec n'importe quelle "classe" comme argument.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une solution possible est la suivante: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solution semble lourde, mais le but est atteint - la fonction universelle commonFunc () accepte l '"objet" de n'importe quelle "classe" comme argument. </font><font style="vertical-align: inherit;">Une condition prÃ©alable est qu'une structure de Â«classeÂ» dans le premier champ doit contenir un identifiant par lequel la Â«classeÂ» rÃ©elle de l'objet est dÃ©terminÃ©e. </font><font style="vertical-align: inherit;">Une telle solution est possible grÃ¢ce Ã  l'utilisation de l'argument de type Â«void *Â». </font><font style="vertical-align: inherit;">Cependant, un pointeur de n'importe quel type peut Ãªtre transmis Ã  une telle fonction, par exemple, "int *". </font><font style="vertical-align: inherit;">Cela ne provoquera pas d'erreurs de compilation, mais au moment de l'exÃ©cution, le programme se comportera de maniÃ¨re imprÃ©visible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant Ã  quoi ressemble le polymorphisme en Java (cependant, comme dans tout autre langage OOP). </font><font style="vertical-align: inherit;">Supposons que nous ayons de nombreuses classes qui devraient Ãªtre traitÃ©es de la mÃªme maniÃ¨re par une mÃ©thode. </font><font style="vertical-align: inherit;">Contrairement Ã  la solution pour le langage C prÃ©sentÃ©e ci-dessus, cette mÃ©thode polymorphe DOIT Ãªtre incluse dans toutes les classes de l'ensemble donnÃ©, et toutes ses versions DOIVENT avoir la mÃªme signature.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, vous devez forcer le compilateur Ã  appeler exactement la version de la mÃ©thode qui appartient Ã  la classe correspondante. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-Ã -dire que la mÃ©thode executor (), qui peut Ãªtre n'importe oÃ¹ dans le programme, doit pouvoir travailler avec n'importe quelle classe de l'ensemble (A, B ou C). </font><font style="vertical-align: inherit;">Nous devons en quelque sorte Â«direÂ» au compilateur que _set_of_class_ dÃ©signe nos nombreuses classes. </font><font style="vertical-align: inherit;">Ici, l'hÃ©ritage est utile - il est nÃ©cessaire de faire toutes les classes Ã  partir des dÃ©rivÃ©s d'ensemble de certaines classes de base, qui contiendront une mÃ©thode polymorphe:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, toute classe hÃ©ritiÃ¨re de Base (grÃ¢ce Ã  l'identification de type dynamique) peut lui Ãªtre passÃ©e en argument: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon l'objet de classe qui est passÃ© en argument, une mÃ©thode appartenant Ã  cette classe sera appelÃ©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot-clÃ© abstrait vous permet d'exclure le corps de la mÃ©thode (rendez-le abstrait, en termes de POO). </font><font style="vertical-align: inherit;">En fait, nous disons au compilateur que cette mÃ©thode doit Ãªtre surchargÃ©e dans les classes qui en dÃ©rivent. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, une erreur de compilation se produit. </font><font style="vertical-align: inherit;">Une classe contenant au moins une mÃ©thode abstraite est Ã©galement appelÃ©e abstraite. </font><font style="vertical-align: inherit;">Le compilateur nÃ©cessite Ã©galement de marquer ces classes avec le mot clÃ© abstract.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Structure de projet Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, tous les fichiers source ont l'extension * .java. </font><font style="vertical-align: inherit;">Les fichiers d'en-tÃªte * .h et les prototypes de fonctions ou de classes sont manquants. </font><font style="vertical-align: inherit;">Chaque fichier source Java doit contenir au moins une classe. </font><font style="vertical-align: inherit;">Le nom de la classe est d'usage Ã  Ã©crire, en commenÃ§ant par une majuscule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs fichiers avec du code source peuvent Ãªtre combinÃ©s dans un package. </font><font style="vertical-align: inherit;">Pour ce faire, les conditions suivantes doivent Ãªtre remplies:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les fichiers avec le code source doivent se trouver dans le mÃªme rÃ©pertoire du systÃ¨me de fichiers. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le nom de ce rÃ©pertoire doit correspondre au nom du package. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au dÃ©but de chaque fichier source, le package auquel appartient ce fichier doit Ãªtre indiquÃ©, par exemple: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir l'unicitÃ© des noms de packages dans le monde, il est proposÃ© d'utiliser le nom de domaine "inversÃ©" de la sociÃ©tÃ©. </font><font style="vertical-align: inherit;">Cependant, ce n'est pas une exigence et tous les noms peuvent Ãªtre utilisÃ©s dans le projet local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est Ã©galement recommandÃ© de spÃ©cifier des noms de package en minuscules. </font><font style="vertical-align: inherit;">Ils peuvent donc Ãªtre facilement distinguÃ©s des noms de classe.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dissimulation de la mise en Å“uvre </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre aspect de l'encapsulation est la sÃ©paration de l'interface et de la mise en Å“uvre. Si l'interface est accessible aux parties externes du programme (externes au module ou Ã  la classe), l'implÃ©mentation est masquÃ©e. Dans la littÃ©rature, une analogie de boÃ®te noire est souvent tracÃ©e lorsque l'implÃ©mentation interne n'est Â«pas visibleÂ» de l'extÃ©rieur, mais ce qui est introduit dans l'entrÃ©e de la boÃ®te et ce qu'elle donne est Â«visibleÂ». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C, le masquage des implÃ©mentations est effectuÃ© Ã  l'intÃ©rieur d'un module, marquant les fonctions qui ne devraient pas Ãªtre visibles de l'extÃ©rieur avec le mot-clÃ© statique. Les prototypes des fonctions qui composent l'interface du module sont placÃ©s dans le fichier d'en-tÃªte. Un module en C signifie une paire: un fichier source avec l'extension * .c et un en-tÃªte avec l'extension * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java possÃ¨de Ã©galement le mot-clÃ© statique, mais il n'affecte pas la Â«visibilitÃ©Â» de la mÃ©thode ou du champ de l'extÃ©rieur. </font><font style="vertical-align: inherit;">Pour contrÃ´ler la Â«visibilitÃ©Â», il existe 3 modificateurs d'accÃ¨s: privÃ©, protÃ©gÃ©, public. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les champs et mÃ©thodes d'une classe marquÃ©e comme privÃ©e ne sont disponibles qu'Ã  l'intÃ©rieur. </font><font style="vertical-align: inherit;">Les champs et mÃ©thodes protÃ©gÃ©s sont Ã©galement accessibles aux descendants de classe. </font><font style="vertical-align: inherit;">Le modificateur public signifie que l'Ã©lÃ©ment marquÃ© est accessible de l'extÃ©rieur de la classe, c'est-Ã -dire qu'il fait partie de l'interface. </font><font style="vertical-align: inherit;">Il est Ã©galement possible qu'il n'y ait pas de modificateur, dans ce cas, l'accÃ¨s Ã  l'Ã©lÃ©ment class est limitÃ© par le package dans lequel se trouve la classe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'Ã©criture d'une classe, il est recommandÃ© de marquer initialement tous les champs de la classe comme privÃ©s et d'Ã©tendre les droits d'accÃ¨s si nÃ©cessaire.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surcharge de mÃ©thode </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'une des caractÃ©ristiques gÃªnantes de la bibliothÃ¨que standard C est la prÃ©sence de tout un zoo de fonctions qui exÃ©cutent essentiellement la mÃªme chose, mais diffÃ¨rent dans le type d'argument, par exemple: fabs (), fabsf (), fabsl () - fonctions permettant d'obtenir la valeur absolue pour double, float et long types doubles respectivement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (ainsi que C ++) prend en charge un mÃ©canisme de surcharge de mÃ©thode - il peut y avoir plusieurs mÃ©thodes dans une classe avec un nom complÃ¨tement identique, mais diffÃ©rant par le type et le nombre d'arguments. </font><font style="vertical-align: inherit;">Par le nombre d'arguments et leur type, le compilateur choisira la version nÃ©cessaire de la mÃ©thode elle-mÃªme - elle est trÃ¨s pratique et amÃ©liore la lisibilitÃ© du programme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, contrairement Ã  C ++, les opÃ©rateurs ne peuvent pas Ãªtre surchargÃ©s. </font><font style="vertical-align: inherit;">L'exception est les opÃ©rateurs "+" et "+ =", qui sont initialement surchargÃ©s pour les chaÃ®nes String.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CaractÃ¨res et chaÃ®nes en Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En C, vous devez travailler avec des chaÃ®nes null-terminal reprÃ©sentÃ©es par des pointeurs vers le premier caractÃ¨re: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces lignes doivent se terminer par un caractÃ¨re nul. </font><font style="vertical-align: inherit;">Si elle est accidentellement "effacÃ©e", une chaÃ®ne sera considÃ©rÃ©e comme une sÃ©quence d'octets en mÃ©moire jusqu'au premier caractÃ¨re nul. </font><font style="vertical-align: inherit;">Autrement dit, si d'autres variables de programme sont placÃ©es dans la mÃ©moire aprÃ¨s la ligne, puis aprÃ¨s avoir modifiÃ© une telle ligne endommagÃ©e, leurs valeurs peuvent (et trÃ¨s probablement) seront dÃ©formÃ©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sÃ»r, un programmeur C n'est pas obligÃ© d'utiliser des chaÃ®nes null-terminal classiques, mais applique une implÃ©mentation tierce, mais ici, il faut garder Ã  l'esprit que toutes les fonctions de la bibliothÃ¨que standard nÃ©cessitent des chaÃ®nes null-terminal comme arguments. </font><font style="vertical-align: inherit;">De plus, la norme C ne dÃ©finit pas l'encodage utilisÃ©, ce point doit Ã©galement Ãªtre contrÃ´lÃ© par le programmeur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, le type de caractÃ¨re primitif (ainsi que l'encapsuleur de caractÃ¨res, Ã  propos des encapsuleurs ci-dessous) reprÃ©sentent un seul caractÃ¨re selon la norme Unicode. Le codage UTF-16 est utilisÃ©, respectivement, un caractÃ¨re occupe 2 octets en mÃ©moire, ce qui vous permet de coder presque tous les caractÃ¨res des langues actuellement utilisÃ©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les caractÃ¨res peuvent Ãªtre spÃ©cifiÃ©s par leur Unicode:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'Unicode d'un caractÃ¨re dÃ©passe le maximum de 216 pour char, alors un tel caractÃ¨re doit Ãªtre reprÃ©sentÃ© par int. Dans la chaÃ®ne, il occupera 2 caractÃ¨res de 16 bits, mais lÃ  encore, les caractÃ¨res avec un code supÃ©rieur Ã  216 sont extrÃªmement rarement utilisÃ©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chaÃ®nes Java sont implÃ©mentÃ©es par la classe String intÃ©grÃ©e et stockent des caractÃ¨res char 16 bits. La classe String contient tout ou presque tout ce qui peut Ãªtre nÃ©cessaire pour travailler avec des chaÃ®nes. Il n'est pas nÃ©cessaire de penser au fait que la ligne doit nÃ©cessairement se terminer par zÃ©ro, ici il est impossible "d'effacer" imperceptiblement ce caractÃ¨re de terminaison zÃ©ro ou d'accÃ©der Ã  la mÃ©moire au-delÃ  de la ligne. En gÃ©nÃ©ral, lorsqu'il travaille avec des chaÃ®nes en Java, le programmeur ne pense pas Ã  la faÃ§on dont la chaÃ®ne est stockÃ©e en mÃ©moire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme mentionnÃ© ci-dessus, Java n'autorise pas la surcharge d'opÃ©rateur (comme en C ++), cependant la classe String est une exception - seulement pour elle les opÃ©rateurs de fusion de ligne "+" et "+ =" sont initialement surchargÃ©s. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est Ã  noter que les chaÃ®nes en Java sont immuables - une fois crÃ©Ã©es, elles ne permettent pas leur modification. </font><font style="vertical-align: inherit;">Lorsque nous essayons de changer la ligne, par exemple, comme ceci:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, la chaÃ®ne d'origine ne change pas rÃ©ellement. </font><font style="vertical-align: inherit;">Au lieu de cela, une copie modifiÃ©e de la chaÃ®ne d'origine est crÃ©Ã©e, qui Ã  son tour est Ã©galement immuable:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, chaque modification d'une chaÃ®ne entraÃ®ne en rÃ©alitÃ© la crÃ©ation d'un nouvel objet (en fait, en cas de fusion de chaÃ®nes, le compilateur peut optimiser le code et utiliser la classe StringBuilder, qui sera discutÃ©e plus loin). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il arrive que le programme doive souvent changer la mÃªme ligne. </font><font style="vertical-align: inherit;">Dans de tels cas, afin d'optimiser la vitesse du programme et la consommation de mÃ©moire, vous pouvez empÃªcher la crÃ©ation de nouveaux objets de ligne. </font><font style="vertical-align: inherit;">Ã€ ces fins, la classe StringBuilder doit Ãªtre utilisÃ©e:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SÃ©parÃ©ment, il convient de mentionner la comparaison des chaÃ®nes. </font><font style="vertical-align: inherit;">Une erreur typique d'un programmeur Java novice consiste Ã  comparer des chaÃ®nes en utilisant l'opÃ©rateur "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code ne contient pas formellement d'erreurs au stade de la compilation ni d'erreurs d'exÃ©cution, mais il fonctionne diffÃ©remment de ce Ã  quoi on pourrait s'attendre. </font><font style="vertical-align: inherit;">Puisque tous les objets et chaÃ®nes, y compris en Java, sont reprÃ©sentÃ©s par des liens, la comparaison avec l'opÃ©rateur "==" donne une comparaison des liens, pas des valeurs des objets. </font><font style="vertical-align: inherit;">Autrement dit, le rÃ©sultat ne sera vrai que si 2 liens font vraiment rÃ©fÃ©rence Ã  la mÃªme ligne. </font><font style="vertical-align: inherit;">Si les chaÃ®nes sont des objets diffÃ©rents en mÃ©moire et que vous devez comparer leur contenu, vous devez utiliser la mÃ©thode equals ():</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La chose la plus surprenante est que dans certains cas, la comparaison Ã  l'aide de l'opÃ©rateur Â«==Â» fonctionne correctement: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, someString et anotherString font rÃ©fÃ©rence au mÃªme objet en mÃ©moire. </font><font style="vertical-align: inherit;">Le compilateur place les mÃªmes littÃ©raux de chaÃ®ne dans le pool de chaÃ®nes - le soi-disant internement se produit. </font><font style="vertical-align: inherit;">Ensuite, chaque fois que le mÃªme littÃ©ral de chaÃ®ne apparaÃ®t dans le programme, un lien vers la chaÃ®ne du pool est utilisÃ©. </font><font style="vertical-align: inherit;">L'internement de chaÃ®nes est prÃ©cisÃ©ment possible en raison de la propriÃ©tÃ© d'immuabilitÃ© des chaÃ®nes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que la comparaison du contenu des chaÃ®nes ne soit autorisÃ©e que par la mÃ©thode equals (), en Java, il est possible d'utiliser correctement les chaÃ®nes dans les constructions Ã  commutateur (Ã  partir de Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curieusement, tout objet Java peut Ãªtre converti en chaÃ®ne. </font><font style="vertical-align: inherit;">La mÃ©thode toString () correspondante est dÃ©finie dans la classe de base pour toutes les classes de la classe Object.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Approche de gestion des erreurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la programmation en C, vous pouvez proposer l'approche de gestion des erreurs suivante. Chaque fonction d'une bibliothÃ¨que renvoie un type int. Si la fonction rÃ©ussit, ce rÃ©sultat est 0. Si le rÃ©sultat est diffÃ©rent de zÃ©ro, cela indique une erreur. Le plus souvent, le code d'erreur est transmis via la valeur renvoyÃ©e par la fonction. Ã‰tant donnÃ© que la fonction ne peut renvoyer qu'une seule valeur et qu'elle est dÃ©jÃ  occupÃ©e par le code d'erreur, le rÃ©sultat rÃ©el de la fonction doit Ãªtre renvoyÃ© via l'argument sous la forme d'un pointeur, par exemple, comme ceci:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par ailleurs, c'est l'un des cas oÃ¹ dans un programme C, il devient nÃ©cessaire d'utiliser un pointeur vers un pointeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, ils utilisent une approche diffÃ©rente. La fonction ne renvoie pas de code d'erreur, mais directement le rÃ©sultat de son exÃ©cution, gÃ©nÃ©ralement sous la forme d'un pointeur. Une situation d'erreur est indiquÃ©e par un pointeur nul. Ensuite, la bibliothÃ¨que contient gÃ©nÃ©ralement une fonction distincte qui renvoie le code de la derniÃ¨re erreur:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une maniÃ¨re ou d'une autre, lors de la programmation en C, le code qui fait le travail Â«utileÂ» et le code responsable du traitement des erreurs s'entrelacent, ce qui ne rend Ã©videmment pas le programme facile Ã  lire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, si vous le souhaitez, vous pouvez utiliser les approches dÃ©crites ci-dessus, mais ici, vous pouvez appliquer une maniÃ¨re complÃ¨tement diffÃ©rente de traiter les erreurs - la gestion des exceptions (cependant, comme en C ++). L'avantage de la gestion des exceptions est que dans ce cas, le code Â«utileÂ» et le code responsable de la gestion des erreurs et des imprÃ©vus sont logiquement sÃ©parÃ©s les uns des autres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est rÃ©alisÃ© en utilisant des constructions try-catch: le code Â«utileÂ» est placÃ© dans la section try et le code de gestion des erreurs est placÃ© dans la section catch.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe des situations oÃ¹ il n'est pas possible de traiter correctement l'erreur au lieu de son occurrence. </font><font style="vertical-align: inherit;">Dans de tels cas, une indication est placÃ©e dans la signature de mÃ©thode que la mÃ©thode peut provoquer ce type d'exception:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, l'appel Ã  cette mÃ©thode doit nÃ©cessairement Ãªtre encadrÃ© dans un bloc try-catch, ou la mÃ©thode appelante doit Ã©galement Ãªtre marquÃ©e pour pouvoir lever cette exception. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absence de prÃ©processeur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle que soit la commoditÃ© du prÃ©processeur familier aux programmeurs C / C ++, il est absent du langage Java. </font><font style="vertical-align: inherit;">Les dÃ©veloppeurs Java ont probablement dÃ©cidÃ© qu'il n'Ã©tait utilisÃ© que pour garantir la portabilitÃ© des programmes, et comme Java s'exÃ©cute partout (presque), aucun prÃ©processeur n'est nÃ©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez compenser l'absence d'un prÃ©processeur Ã  l'aide d'un champ indicateur statique et vÃ©rifier sa valeur dans le programme, si nÃ©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de l'organisation des tests, il est possible d'utiliser des annotations en conjonction avec la rÃ©flexion (rÃ©flexion).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un tableau est Ã©galement un objet. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec des tableaux en C, la sortie d'index au-delÃ  des limites du tableau est une erreur trÃ¨s insidieuse. </font><font style="vertical-align: inherit;">Le compilateur ne le signalera en aucune faÃ§on, et pendant l'exÃ©cution le programme ne sera pas arrÃªtÃ© avec le message correspondant:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TrÃ¨s probablement, le programme continuera son exÃ©cution, mais la valeur de la variable qui se trouvait aprÃ¨s le tableau matriciel dans l'exemple ci-dessus sera dÃ©formÃ©e. Le dÃ©bogage de ce type d'erreur peut ne pas Ãªtre facile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, le programmeur est protÃ©gÃ© contre ce type d'erreurs difficiles Ã  diagnostiquer. Lorsque vous essayez d'aller au-delÃ  des limites du tableau, une ArrayIndexOutOfBoundsException est levÃ©e. Si l'exception catch n'a pas Ã©tÃ© programmÃ©e Ã  l'aide de la construction try-catch, le programme se bloque et un message correspondant est envoyÃ© au flux d'erreur standard indiquant le fichier avec le code source et le numÃ©ro de ligne oÃ¹ le tableau a Ã©tÃ© dÃ©passÃ©. Autrement dit, le diagnostic de ces erreurs devient une question triviale.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce comportement du programme Java est rendu possible car le tableau en Java est reprÃ©sentÃ© par un objet. </font><font style="vertical-align: inherit;">Le tableau Java ne peut pas Ãªtre redimensionnÃ©; sa taille est codÃ©e en dur au moment oÃ¹ la mÃ©moire est allouÃ©e. </font><font style="vertical-align: inherit;">Au moment de l'exÃ©cution, obtenir la taille de la matrice est aussi simple que de dÃ©cortiquer des poires:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de tableaux multidimensionnels, alors, par rapport au langage C, Java offre une opportunitÃ© intÃ©ressante d'organiser des tableaux "Ladder". </font><font style="vertical-align: inherit;">Dans le cas d'un tableau Ã  deux dimensions, la taille de chaque ligne individuelle peut diffÃ©rer des autres:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme en C, les Ã©lÃ©ments du tableau sont situÃ©s en mÃ©moire un par un, donc l'accÃ¨s au tableau est considÃ©rÃ© comme le plus efficace. Si vous devez effectuer des opÃ©rations d'insertion / suppression d'Ã©lÃ©ments ou crÃ©er des structures de donnÃ©es plus complexes, vous devez utiliser des collections, telles qu'un ensemble (Set), une liste (List), une carte (Map). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison du manque de pointeurs et de l'impossibilitÃ© d'incrÃ©menter les liens, l'accÃ¨s aux Ã©lÃ©ments du tableau est possible Ã  l'aide d'index.</font></font><br><br><h2>  Les collections </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souvent, la fonctionnalitÃ© des tableaux n'est pas suffisante - vous devez alors utiliser des structures de donnÃ©es dynamiques. Ã‰tant donnÃ© que la bibliothÃ¨que C standard ne contient pas d'implÃ©mentation prÃªte Ã  l'emploi de structures de donnÃ©es dynamiques, vous devez utiliser l'implÃ©mentation dans des codes source ou sous forme de bibliothÃ¨ques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrairement Ã  C, la bibliothÃ¨que Java standard contient un riche ensemble d'implÃ©mentations de structures de donnÃ©es dynamiques ou de collections, exprimÃ©es en termes de Java. Toutes les collections sont divisÃ©es en 3 grandes classes: listes, ensembles et cartes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes - tableaux dynamiques - vous permettent d'ajouter / supprimer des Ã©lÃ©ments. Beaucoup n'assurent pas l'ordre des Ã©lÃ©ments ajoutÃ©s, mais garantissent qu'il n'y a pas d'Ã©lÃ©ments en double. Les cartes ou les tableaux associatifs fonctionnent avec des paires clÃ©-valeur, et la valeur clÃ© est unique - il ne peut pas y avoir 2 paires avec les mÃªmes clÃ©s dans la carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les listes, les ensembles et les cartes, il existe de nombreuses implÃ©mentations, chacune Ã©tant optimisÃ©e pour une opÃ©ration spÃ©cifique. Par exemple, les listes sont implÃ©mentÃ©es par les classes ArrayList et LinkedList, ArrayList offrant de meilleures performances lors de l'accÃ¨s Ã  un Ã©lÃ©ment arbitraire, et LinkedList est plus efficace lors de l'insertion / suppression d'Ã©lÃ©ments au milieu de la liste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seuls les objets Java complets peuvent Ãªtre stockÃ©s dans des collections (en fait, des rÃ©fÃ©rences Ã  des objets), il est donc impossible de crÃ©er directement une collection de primitives (int, char, byte, etc.). </font><font style="vertical-align: inherit;">Dans ce cas, les classes wrapper appropriÃ©es doivent Ãªtre utilisÃ©es:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitif </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cours d'emballage </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> octet </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Octet </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> court </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Court </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Personnage </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entier </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> longue </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Long </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flotter </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flotter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> double </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Double </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> boolÃ©en </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BoolÃ©en </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heureusement, lors de la programmation en Java, il n'est pas nÃ©cessaire de suivre la coÃ¯ncidence exacte du type primitif et de son "wrapper". </font><font style="vertical-align: inherit;">Si la mÃ©thode reÃ§oit un argument, par exemple, de type Integer, alors il peut Ãªtre passÃ© le type int. </font><font style="vertical-align: inherit;">Et vice versa, lorsque le type int est requis, vous pouvez utiliser Integer en toute sÃ©curitÃ©. </font><font style="vertical-align: inherit;">Cela a Ã©tÃ© rendu possible grÃ¢ce au mÃ©canisme intÃ©grÃ© Java pour l'emballage / le dÃ©ballage des primitives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les moments dÃ©sagrÃ©ables, il convient de mentionner que la bibliothÃ¨que Java standard contient d'anciennes classes de collection qui ont Ã©tÃ© implÃ©mentÃ©es sans succÃ¨s dans les premiÃ¨res versions de Java et qui ne doivent pas Ãªtre utilisÃ©es dans de nouveaux programmes. </font><font style="vertical-align: inherit;">Ce sont les classes Enumeration, Vector, Stack, Dictionary, Hashtable, Properties.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GÃ©nÃ©ralisations </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les collections sont couramment utilisÃ©es comme types de donnÃ©es gÃ©nÃ©riques. </font><font style="vertical-align: inherit;">L'essence des gÃ©nÃ©ralisations dans ce cas est que nous spÃ©cifions le type principal de la collection, par exemple, ArrayList, et entre crochets spÃ©cifions le type de paramÃ¨tre, qui dans ce cas dÃ©termine le type d'Ã©lÃ©ments stockÃ©s dans la liste:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela permet au compilateur de suivre la tentative d'ajout d'un objet d'un type autre que le paramÃ¨tre de type spÃ©cifiÃ©: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il est trÃ¨s important que le paramÃ¨tre-type soit effacÃ© lors de l'exÃ©cution du programme, et il n'y a pas de diffÃ©rence entre, par exemple, un objet de la classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et objet de classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par consÃ©quent, il n'y a aucun moyen de dÃ©couvrir le type d'Ã©lÃ©ments de collection pendant l'exÃ©cution du programme: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une solution partielle peut Ãªtre l'approche suivante: prendre le premier Ã©lÃ©ment de la collection et dÃ©terminer son type: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cette approche ne fonctionnera pas si la liste est vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã€ cet Ã©gard, les gÃ©nÃ©ralisations Java sont nettement infÃ©rieures aux gÃ©nÃ©ralisations C ++. </font><font style="vertical-align: inherit;">Les gÃ©nÃ©ralisations Java servent en fait Ã  Â«couperÂ» certaines des erreurs potentielles au stade de la compilation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ItÃ©rer sur tous les Ã©lÃ©ments d'un tableau ou d'une collection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de la programmation en C, vous devez souvent parcourir tous les Ã©lÃ©ments du tableau: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour faire une erreur ici, c'est plus simple, il suffit de spÃ©cifier la mauvaise taille du tableau SIZE ou de mettre "&lt;=" au lieu de "&lt;". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, en plus de la forme Â«habituelleÂ» de l'instruction for, il existe une forme pour itÃ©rer sur tous les Ã©lÃ©ments d'un tableau ou d'une collection (souvent appelÃ©e foreach dans d'autres langages):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous garantissons d'itÃ©rer sur tous les Ã©lÃ©ments de la liste, les erreurs inhÃ©rentes Ã  la forme Â«habituelleÂ» de l'instruction for sont Ã©liminÃ©es. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collections diverses </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ã‰tant donnÃ© que tous les objets sont hÃ©ritÃ©s de l'objet racine, Java a une opportunitÃ© intÃ©ressante de crÃ©er des listes avec diffÃ©rents types rÃ©els d'Ã©lÃ©ments: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transferts </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En comparant C / C ++ et Java, il est impossible de ne pas remarquer combien d'Ã©numÃ©rations plus fonctionnelles sont implÃ©mentÃ©es en Java. </font><font style="vertical-align: inherit;">Ici, l'Ã©numÃ©ration est une classe Ã  part entiÃ¨re, et les Ã©lÃ©ments d'Ã©numÃ©ration sont des objets de cette classe. </font><font style="vertical-align: inherit;">Cela permet Ã  un Ã©lÃ©ment d'Ã©numÃ©ration de mettre plusieurs champs de tout type en correspondance:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tant que classe Ã  part entiÃ¨re, une Ã©numÃ©ration peut avoir des mÃ©thodes et, Ã  l'aide d'un constructeur privÃ©, vous pouvez dÃ©finir les valeurs de champ des Ã©lÃ©ments d'Ã©numÃ©ration individuels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une occasion rÃ©guliÃ¨re d'obtenir une reprÃ©sentation sous forme de chaÃ®ne d'un Ã©lÃ©ment d'Ã©numÃ©ration, un numÃ©ro de sÃ©rie, ainsi qu'un tableau de tous les Ã©lÃ©ments:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et vice versa - par la reprÃ©sentation sous forme de chaÃ®ne, vous pouvez obtenir un Ã©lÃ©ment d'Ã©numÃ©ration, et Ã©galement appeler ses mÃ©thodes: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naturellement, les Ã©numÃ©rations peuvent Ãªtre utilisÃ©es dans les constructions de casse de commutation. </font></font><br><br><h2>  Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sÃ»r, les langages C et Java sont conÃ§us pour rÃ©soudre des problÃ¨mes complÃ¨tement diffÃ©rents. Mais, si l'on compare nÃ©anmoins le processus de dÃ©veloppement logiciel dans ces deux langages, alors, selon les impressions subjectives de l'auteur, le langage Java surpasse significativement C dans la commoditÃ© et la rapiditÃ© d'Ã©criture des programmes. L'environnement de dÃ©veloppement (IDE) joue un rÃ´le important dans la commoditÃ©. L'auteur a travaillÃ© avec IntelliJ IDEA IDE. Lors de la programmation en Java, vous nâ€™avez pas constamment Ã  Â«avoir peurÂ» de faire une erreur - souvent lâ€™environnement de dÃ©veloppement vous dira ce qui doit Ãªtre corrigÃ©, et parfois il le fera pour vous. Si une erreur d'exÃ©cution s'est produite, le type d'erreur et le lieu de son occurrence dans le code source sont toujours indiquÃ©s dans le journal - la lutte contre de telles erreurs devient triviale. Un programmeur C n'a pas besoin de faire des efforts inhumains pour passer Ã  Java, et tout cela parce que la syntaxe du langage a lÃ©gÃ¨rement changÃ©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si cette expÃ©rience sera intÃ©ressante pour les lecteurs, dans le prochain article, nous parlerons de l'expÃ©rience d'utilisation du mÃ©canisme JNI (exÃ©cution de code C / C ++ natif Ã  partir d'une application Java). </font><font style="vertical-align: inherit;">Le mÃ©canisme JNI est indispensable lorsque vous souhaitez contrÃ´ler la rÃ©solution d'Ã©cran, le module Bluetooth et dans d'autres cas lorsque les capacitÃ©s des services et gestionnaires Android ne sont pas suffisantes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412775/">https://habr.com/ru/post/fr412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412763/index.html">Utilisation de la carte de rechargement Firefly-RK3288 avec le SoC RockChip RK3288 Capteur thermique numÃ©rique Microchip I2C - MCP9808</a></li>
<li><a href="../fr412765/index.html">Introduction au nouveau systÃ¨me de cartes de tuiles Unity</a></li>
<li><a href="../fr412767/index.html">Examen de la confÃ©rence CMG Impact 2016</a></li>
<li><a href="../fr412769/index.html">J'ai fait PWA et l'ai mis dans trois app stores. Et voici ce que j'ai dÃ©couvert</a></li>
<li><a href="../fr412773/index.html">Astro-aÃ©rospatiale de Minsk</a></li>
<li><a href="../fr412777/index.html">Chefs-d'Å“uvre de la construction de colonnes du monde: QUAD 11L - les meilleures Â«Ã©tagÃ¨resÂ» du deux milliÃ¨me</a></li>
<li><a href="../fr412779/index.html">SSLH: cache SSH / HTTPS / OpenVPN / Telegram derriÃ¨re un seul port 443</a></li>
<li><a href="../fr412781/index.html">Un fan de NES a permis de lancer des jeux SNES sur la console</a></li>
<li><a href="../fr412783/index.html">Installation du proxy MTProto Telegram Ã  partir de la source sur Centos 7</a></li>
<li><a href="../fr412785/index.html">Master of Management et Freelancer. L'histoire en trois parties</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>