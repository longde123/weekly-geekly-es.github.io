<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏼 🛃 👵 Expérience personnelle: passer du développement C de bas niveau à la programmation Java 😝 🤹🏽 💊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article reflète l'expérience personnelle de l'auteur, un programmeur de microcontrôleurs passionné, qui, après de nombreuses années d'expérience dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Expérience personnelle: passer du développement C de bas niveau à la programmation Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  L'article reflète l'expérience personnelle de l'auteur, un programmeur de microcontrôleurs passionné, qui, après de nombreuses années d'expérience dans le développement de microcontrôleurs en C (et un peu en C ++), a eu l'occasion de participer à un projet Java majeur pour développer des logiciels pour les décodeurs TV fonctionnant sous Android.  Au cours de ce projet, j'ai pu collecter des notes sur les différences intéressantes entre les langages Java et C / C ++, évaluer différentes approches d'écriture de programmes.  L'article ne prétend pas être une référence, il n'examine pas l'efficacité et la productivité des programmes Java.  Il s'agit plutôt d'un recueil d'observations personnelles.  Sauf indication contraire, il s'agit d'une version Java SE 7. <br><a name="habracut"></a><br><h2>  Différences de syntaxe et constructions de contrôle </h2><br>  En bref - les différences sont minimes, la syntaxe est très similaire.  Les blocs de code sont également formés par une paire d'accolades {}.  Les règles de compilation des identifiants sont les mêmes que pour C / C ++.  La liste des mots clés est presque la même qu'en C / C ++.  Types de données intégrés - similaires à ceux de C / C ++.  Tableaux - tous sont également déclarés à l'aide de crochets. <br><br>  Le contrôle construit if-else, while, do-while, for, switch sont également presque complètement identiques.  Il est à noter qu'en Java il y avait des labels familiers aux programmeurs C (ceux qui sont utilisés avec le mot-clé goto et dont l'utilisation est fortement déconseillée).  Cependant, Java a exclu la possibilité de passer à une étiquette en utilisant goto.  Les étiquettes ne doivent être utilisées que pour quitter les boucles imbriquées: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Pour améliorer la lisibilité des programmes en Java, une opportunité intéressante a été ajoutée pour séparer les chiffres des nombres longs avec un trait de soulignement: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Extérieurement, un programme Java n'est pas très différent d'un programme C familier. La principale différence visuelle est que Java n'autorise pas les fonctions, variables, définitions de nouveaux types (structures), constantes, etc., qui sont "librement" situées dans le fichier source.  Java est un langage orienté objet, donc toutes les entités de programme doivent appartenir à une classe.  Une autre différence importante est l'absence d'un préprocesseur.  Ces deux différences sont décrites plus en détail ci-dessous. <br><br><h2>  Approche objet en langage C </h2><br>  Lorsque nous écrivons de gros programmes en C, nous devons essentiellement travailler avec des objets.  Le rôle de l'objet ici est joué par une structure qui décrit une certaine essence du «monde réel»: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   – «» struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Il existe également en C des méthodes de traitement des "objets" - structures - fonctions.  Cependant, les fonctions ne sont pas essentiellement fusionnées avec les données.  Oui, ils sont généralement placés dans un seul fichier, mais à chaque fois il est nécessaire de passer un pointeur sur l'objet à traiter dans la fonction "typique": <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Vous ne pouvez utiliser «l'objet» qu'après avoir alloué de la mémoire pour le stocker: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  Dans un programme C, une fonction est généralement définie qui est responsable de l'initialisation de «l'objet» avant sa première utilisation: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Ensuite, le cycle de vie d'un «objet» en C est généralement le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Maintenant, nous listons les erreurs d'exécution possibles qui peuvent être faites par le programmeur dans le cycle de vie de «l'objet»: <br><br><ol><li>  Oubliez d'allouer de la mémoire pour "l'objet" </li><li>  Spécifiez la mauvaise quantité de mémoire allouée </li><li>  Oubliez d'initialiser "l'objet" </li><li>  Oubliez de libérer de la mémoire après avoir utilisé l'objet </li></ol><br>  Il peut être extrêmement difficile de détecter de telles erreurs, car elles ne sont pas détectées par le compilateur et apparaissent pendant le fonctionnement du programme.  De plus, leur effet peut être très divers et affecter d'autres variables et «objets» du programme. <br><br><h2>  Approche des objets Java </h2><br>  Face à OOP - programmation orientée objet, vous avez probablement entendu parler d'une des baleines OOP - encapsulation.  En Java, contrairement à C, les données et les méthodes pour les traiter sont combinées ensemble et sont de «vrais» objets.  En termes de POO, cela s'appelle l'encapsulation.  Une classe est une description d'un objet, l'analogue le plus proche d'une classe en C est de définir un nouveau type en utilisant la structure typedef.  En termes Java, les fonctions qui appartiennent à une classe sont appelées méthodes. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  L'idéologie du langage Java est basée sur l'énoncé «tout est un objet».  Par conséquent, il n'est pas surprenant que Java interdise la création de méthodes (fonctions) et de champs de données (variables) séparément de la classe.  Même la méthode main () familière, à partir de laquelle le programme démarre, doit appartenir à l'une des classes. <br><br>  Une définition de classe en Java est analogue à une déclaration de structure en C. En décrivant une classe, vous ne créez rien en mémoire.  Un objet de cette classe apparaît lors de sa création par le nouvel opérateur.  La création d'un objet en Java est un analogue de l'allocation de mémoire dans le langage C, mais, contrairement à ce dernier, une méthode spéciale est automatiquement appelée lors de la création de l'objet - le constructeur de l'objet.  Le constructeur joue le rôle de l'initialisation initiale de l'objet - un analogue de la fonction init () discutée précédemment.  Le nom du constructeur doit correspondre au nom de la classe.  Le constructeur ne peut pas retourner de valeur. <br><br>  Le cycle de vie d'un objet dans un programme Java est le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Notez que le nombre d'erreurs possibles dans un programme Java est beaucoup plus petit que dans un programme C. Oui, vous pouvez toujours oublier de créer un objet avant la première utilisation (ce qui, cependant, conduira à une exception NullPointerException facilement déboguée), mais comme pour les autres erreurs inhérentes Programmes C, la situation est en train de changer fondamentalement: <br><br><ol><li>  Il n'y a pas d'opérateur sizeof () en Java.  Le compilateur Java calcule lui-même la quantité de mémoire pour stocker l'objet.  Par conséquent, il n'est pas possible de spécifier la mauvaise taille de la sélection. </li><li>  L'initialisation de l'objet a lieu au moment de la création.  Il est impossible d'oublier l'initialisation. </li><li>  La mémoire occupée par l'objet n'a pas besoin d'être libérée; le garbage collector fait ce travail.  Il est impossible d'oublier de supprimer un objet après utilisation - il y a moins de risque d'effet de «fuite de mémoire». </li></ol><br>  Ainsi, tout en Java est un objet d'une classe ou d'une autre.  Les exceptions sont des primitives qui ont été ajoutées au langage pour améliorer les performances et la consommation de mémoire.  Vous trouverez plus d'informations sur les primitives ci-dessous. <br><br><h2>  Mémoire et collecteur d'ordures </h2><br>  Java conserve les concepts familiers de tas et de pile pour C / C ++, un programmeur.  Lors de la création d'un objet avec le nouvel opérateur, la mémoire pour stocker l'objet est empruntée au tas.  Cependant, un lien vers un objet (un lien est un analogue d'un pointeur), si l'objet créé ne fait pas partie d'un autre objet, est placé sur la pile.  Sur le tas sont stockés les "corps" des objets, et sur la pile sont des variables locales: références aux objets et types primitifs.  Si le segment de mémoire existe pendant l'exécution du programme et est disponible pour tous les threads du programme, la pile appartient à la méthode et n'existe que pendant son exécution et est également inaccessible aux autres threads du programme. <br><br>  Java est inutile et plus encore - vous ne pouvez pas libérer manuellement la mémoire occupée par un objet.  Ce travail est effectué par le garbage collector en mode automatique.  Le runtime contrôle s'il est possible d'atteindre chaque objet du tas à partir de l'emplacement actuel du programme en suivant les liens d'objet à objet.  Sinon, un tel objet est reconnu comme «poubelle» et devient un candidat à la suppression. <br><br>  Il est important de noter que la suppression elle-même ne se produit pas au moment où l'objet «n'est plus nécessaire» - le garbage collector décide de la suppression, et la suppression peut être retardée autant que souhaité, jusqu'à la fin du programme. <br><br>  Bien sûr, le travail du garbage collector nécessite une surcharge du processeur.  Mais en retour, il soulage le programmeur d'un gros mal de tête lié à la nécessité de libérer de la mémoire après la fin de l'utilisation des "objets".  En fait, nous «prenons» la mémoire quand nous en avons besoin et nous l'utilisons, sans penser que nous devons la libérer après nous-mêmes. <br><br>  En parlant de variables locales, rappelons l'approche de Java pour leur initialisation.  Si en C / C ++ une variable locale non initialisée contient une valeur aléatoire, alors le compilateur Java ne permettra tout simplement pas de la laisser non initialisée: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Liens - Pointeurs de remplacement </h2><br>  Java n'a pas de pointeurs; par conséquent, un programmeur Java n'a pas la possibilité de faire l'une des nombreuses erreurs qui se produisent lors de l'utilisation des pointeurs.  Lorsque vous créez un objet, vous obtenez un lien vers cet objet: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity –  . Entity entity = new Entity();</span></span></code> </pre><br>  En C, le programmeur avait le choix: comment passer, disons, une structure à une fonction.  Vous pouvez passer par valeur: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    –   : //    . void process(Data *data);</span></span></code> </pre> <br>  Le passage par la valeur garantissait que la fonction ne modifierait pas les données de la structure, mais était inefficace en termes de performances - au moment où la fonction a été appelée, une copie de la structure a été créée.  Passer par un pointeur est beaucoup plus efficace: en fait, l'adresse en mémoire où se trouve la structure a été transmise à la fonction. <br><br>  En Java, il n'y avait qu'une seule façon de passer un objet à une méthode - par référence.  Passer par référence en Java est analogue à passer par un pointeur en C: <br><ul><li>  la copie (clonage) de la mémoire ne se produit pas, </li><li>  en fait, l'adresse de la localisation de cet objet est transmise. </li></ul><br>  Cependant, contrairement au pointeur du langage C, un lien Java ne peut pas être incrémenté / décrémenté.  «Exécuter» les éléments d'un tableau à l'aide d'un lien vers celui-ci en Java ne fonctionnera pas.  Tout ce qui peut être fait avec un lien est de lui donner une valeur différente. <br><br>  Bien sûr, l'absence de pointeurs en tant que tels réduit le nombre d'erreurs possibles, cependant, l'analogue du pointeur nul reste dans la langue - une référence nulle désignée par le mot-clé null. <br><br>  Une référence nulle est un casse-tête pour un programmeur Java, comme  force la référence d'objet à être vérifiée pour null avant de l'utiliser ou à gérer les exceptions NullPointerException.  Si cela n'est pas fait, le programme se bloquera. <br><br>  Ainsi, tous les objets en Java sont transmis via des liens.  Les types de données primitifs (int, long, char ...) sont passés par valeur (plus d'informations sur les primitives sont données ci-dessous). <br><br><h2>  Fonctionnalités de Java Link </h2><br>  L'accès à n'importe quel objet du programme se fait via un lien - cela a clairement un effet positif sur les performances, mais cela peut surprendre un débutant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Arguments de méthode et valeurs de retour - tout est transmis via le lien.  En plus des avantages, il y a un inconvénient par rapport aux langages C / C ++, où nous pouvons explicitement interdire aux fonctions de changer la valeur transmise via un pointeur à l'aide d'un qualificatif const: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Autrement dit, le langage C vous permet de suivre cette erreur au stade de la compilation.  Java a également le mot clé const, mais il est réservé pour les futures versions et n'est actuellement pas utilisé du tout.  Dans une certaine mesure, le mot clé final est appelé à remplir son rôle.  Cependant, il ne protège pas l'objet transmis à la méthode contre les modifications: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  Le fait est que le mot-clé final dans ce cas est appliqué au lien, et non à l'objet vers lequel le lien pointe.  Si final est appliqué à la primitive, le compilateur se comporte comme prévu: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Les liens Java sont très similaires aux liens du langage C ++. <br><br><h2>  Primitives Java </h2><br>  Chaque objet Java, en plus des champs de données, contient des informations de support.  Si nous voulons fonctionner, par exemple, dans des octets séparés et que chaque octet est représenté par un objet, alors dans le cas d'un tableau d'octets, la surcharge de mémoire peut plusieurs fois dépasser la taille utilisable. <br>  Afin que Java reste suffisamment efficace dans les cas décrits ci-dessus, la prise en charge des types primitifs - primitifs - a été ajoutée au langage. <br><table><tbody><tr><th>  Primitif </th><th>  Afficher </th><th>  Profondeur de bits </th><th>  Analogue possible en C </th></tr><tr><td>  octet </td><td rowspan="5">  Entier </td><td>  8 </td><td>  char </td></tr><tr><td>  court </td><td>  16 </td><td>  court </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (long) </td></tr><tr><td>  longue </td><td>  64 </td><td>  longue </td></tr><tr><td>  flotter </td><td>  Numéros à virgule flottante </td><td>  32 </td><td>  flotter </td></tr><tr><td>  double </td><td></td><td>  64 </td><td>  double </td></tr><tr><td>  booléen </td><td>  Logique </td><td>  - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Toutes les primitives ont leurs analogues dans le langage C. Cependant, la norme C ne détermine pas la taille exacte des types entiers, mais la plage de valeurs que ce type peut stocker est fixe.  Souvent, le programmeur veut garantir la même profondeur de bits pour différentes machines, ce qui conduit à l'apparition de types comme uint32_t dans le programme, bien que toutes les fonctions de bibliothèque nécessitent juste des arguments de type int. <br>  Ce fait ne peut être attribué aux avantages de la langue. <br><br>  Les primitives d'entier Java, contrairement à C, ont des profondeurs de bits fixes.  Ainsi, vous n'avez pas à vous soucier de la profondeur de bits réelle de la machine sur laquelle le programme Java s'exécute, ainsi que de l'ordre des octets ("réseau" ou "Intel").  Ce fait permet de réaliser le principe «il est écrit une fois - il se réalise partout». <br><br>  De plus, en Java, toutes les primitives entières sont signées (le langage n'a pas le mot-clé non signé).  Cela élimine la difficulté d'utiliser des variables signées et non signées dans une seule expression inhérente à C. <br><br>  En conclusion, l'ordre des octets dans les primitives multi-octets en Java est fixe (octet bas à adresse basse, Little-endian, ordre inverse). <br><br>  Les inconvénients de l'implémentation d'opérations avec des primitives en Java incluent le fait qu'ici, comme dans le programme C / C ++, le débordement de la grille de bits peut se produire, sans exception: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Ainsi, les données en Java sont représentées par deux types d'entités: les objets et les primitives.  Les primitifs violent le concept de «tout est un objet», mais dans certaines situations, ils sont trop efficaces pour ne pas les utiliser. <br><br><h2>  Héritage </h2><br>  L'héritage est une autre baleine OOP dont vous avez probablement entendu parler.  Si vous répondez brièvement à la question «pourquoi l'héritage est-il nécessaire du tout», alors la réponse sera «réutilisation du code». <br><br>  Supposons que vous programmiez en C et que vous ayez une «classe» bien écrite et déboguée - une structure et des fonctions pour le traiter.  Ensuite, le besoin se fait sentir de créer une «classe» similaire, mais avec des fonctionnalités améliorées, et la «classe» de base est toujours nécessaire.  Dans le cas du langage C, vous n'avez qu'une seule façon de résoudre ce problème: la composition.  Il s'agit de créer une nouvelle structure étendue - "classe", qui devrait contenir un pointeur sur la structure de base "classe": <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Java en tant que langage orienté objet vous permet d'étendre les fonctionnalités des classes existantes en utilisant le mécanisme d'héritage: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Il convient de noter que Java n'interdit en aucun cas l'utilisation de la composition comme un moyen d'étendre les fonctionnalités de classes déjà écrites.  De plus, dans de nombreuses situations, la composition est préférable à l'héritage. <br><br>  Grâce à l'héritage, les classes en Java sont organisées dans une structure hiérarchique, chaque classe a nécessairement un et un seul «parent» et peut avoir n'importe quel nombre «d'enfants».  Contrairement à C ++, une classe en Java ne peut pas hériter de plusieurs parents (cela résout le problème de "l'héritage diamant"). <br><br>  Pendant l'héritage, la classe dérivée obtient à son emplacement tous les champs et méthodes publics et protégés de sa classe de base, ainsi que la classe de base de sa classe de base, et ainsi de suite dans la hiérarchie d'héritage. <br><br>  Au sommet de la hiérarchie d'héritage se trouve le progéniteur commun de toutes les classes Java - la classe Object, la seule qui n'a pas de parent. <br><br><h2>  Identification de type dynamique </h2><br>  L'un des points clés du langage Java est la prise en charge de l'identification de type dynamique (RTTI).  En termes simples, RTTI vous permet de remplacer un objet d'une classe dérivée où une référence à la base est requise: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Ayant un lien à l'exécution, vous pouvez déterminer le vrai type de l'objet auquel le lien se réfère - en utilisant l'opérateur instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Substitutions de méthode </h2><br>  Redéfinir une méthode ou une fonction signifie remplacer son corps au stade de l'exécution du programme.  Les programmeurs C sont conscients de la capacité d'un langage à modifier le comportement d'une fonction pendant l'exécution du programme.  Il s'agit d'utiliser des pointeurs de fonction.  Par exemple, vous pouvez inclure un pointeur vers une fonction dans la structure de la structure et attribuer diverses fonctions au pointeur pour modifier l'algorithme de traitement des données de cette structure: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  En Java, comme dans d'autres langages OOP, les méthodes de substitution sont inextricablement liées à l'héritage.  Une classe dérivée accède aux méthodes publiques et protégées de la classe de base.  Outre le fait qu'il puisse les appeler, vous pouvez changer le comportement d'une des méthodes de la classe de base sans changer sa signature.  Pour ce faire, il suffit de définir une méthode avec exactement la même signature dans la classe dérivée: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Il est très important que la signature (nom de la méthode, valeur de retour, arguments) corresponde exactement.  Si le nom de la méthode correspond et que les arguments diffèrent, la méthode est surchargée, plus d'informations sur ce qui suit. <br><br><h2>  Polymorphisme </h2><br>  Comme l'encapsulation et l'héritage, la troisième baleine OOP - le polymorphisme - a également une sorte d'analogue dans le langage C orienté vers la procédure. <br><br>  Supposons que nous ayons plusieurs "classes" de structures avec lesquelles vous souhaitez effectuer le même type d'action, et que la fonction qui exécute cette action doit être universelle - doit "pouvoir" fonctionner avec n'importe quelle "classe" comme argument.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une solution possible est la suivante: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solution semble lourde, mais le but est atteint - la fonction universelle commonFunc () accepte l '"objet" de n'importe quelle "classe" comme argument. </font><font style="vertical-align: inherit;">Une condition préalable est qu'une structure de «classe» dans le premier champ doit contenir un identifiant par lequel la «classe» réelle de l'objet est déterminée. </font><font style="vertical-align: inherit;">Une telle solution est possible grâce à l'utilisation de l'argument de type «void *». </font><font style="vertical-align: inherit;">Cependant, un pointeur de n'importe quel type peut être transmis à une telle fonction, par exemple, "int *". </font><font style="vertical-align: inherit;">Cela ne provoquera pas d'erreurs de compilation, mais au moment de l'exécution, le programme se comportera de manière imprévisible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant à quoi ressemble le polymorphisme en Java (cependant, comme dans tout autre langage OOP). </font><font style="vertical-align: inherit;">Supposons que nous ayons de nombreuses classes qui devraient être traitées de la même manière par une méthode. </font><font style="vertical-align: inherit;">Contrairement à la solution pour le langage C présentée ci-dessus, cette méthode polymorphe DOIT être incluse dans toutes les classes de l'ensemble donné, et toutes ses versions DOIVENT avoir la même signature.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, vous devez forcer le compilateur à appeler exactement la version de la méthode qui appartient à la classe correspondante. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-à-dire que la méthode executor (), qui peut être n'importe où dans le programme, doit pouvoir travailler avec n'importe quelle classe de l'ensemble (A, B ou C). </font><font style="vertical-align: inherit;">Nous devons en quelque sorte «dire» au compilateur que _set_of_class_ désigne nos nombreuses classes. </font><font style="vertical-align: inherit;">Ici, l'héritage est utile - il est nécessaire de faire toutes les classes à partir des dérivés d'ensemble de certaines classes de base, qui contiendront une méthode polymorphe:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, toute classe héritière de Base (grâce à l'identification de type dynamique) peut lui être passée en argument: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon l'objet de classe qui est passé en argument, une méthode appartenant à cette classe sera appelée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot-clé abstrait vous permet d'exclure le corps de la méthode (rendez-le abstrait, en termes de POO). </font><font style="vertical-align: inherit;">En fait, nous disons au compilateur que cette méthode doit être surchargée dans les classes qui en dérivent. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, une erreur de compilation se produit. </font><font style="vertical-align: inherit;">Une classe contenant au moins une méthode abstraite est également appelée abstraite. </font><font style="vertical-align: inherit;">Le compilateur nécessite également de marquer ces classes avec le mot clé abstract.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Structure de projet Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, tous les fichiers source ont l'extension * .java. </font><font style="vertical-align: inherit;">Les fichiers d'en-tête * .h et les prototypes de fonctions ou de classes sont manquants. </font><font style="vertical-align: inherit;">Chaque fichier source Java doit contenir au moins une classe. </font><font style="vertical-align: inherit;">Le nom de la classe est d'usage à écrire, en commençant par une majuscule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs fichiers avec du code source peuvent être combinés dans un package. </font><font style="vertical-align: inherit;">Pour ce faire, les conditions suivantes doivent être remplies:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les fichiers avec le code source doivent se trouver dans le même répertoire du système de fichiers. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le nom de ce répertoire doit correspondre au nom du package. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au début de chaque fichier source, le package auquel appartient ce fichier doit être indiqué, par exemple: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir l'unicité des noms de packages dans le monde, il est proposé d'utiliser le nom de domaine "inversé" de la société. </font><font style="vertical-align: inherit;">Cependant, ce n'est pas une exigence et tous les noms peuvent être utilisés dans le projet local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est également recommandé de spécifier des noms de package en minuscules. </font><font style="vertical-align: inherit;">Ils peuvent donc être facilement distingués des noms de classe.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dissimulation de la mise en œuvre </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre aspect de l'encapsulation est la séparation de l'interface et de la mise en œuvre. Si l'interface est accessible aux parties externes du programme (externes au module ou à la classe), l'implémentation est masquée. Dans la littérature, une analogie de boîte noire est souvent tracée lorsque l'implémentation interne n'est «pas visible» de l'extérieur, mais ce qui est introduit dans l'entrée de la boîte et ce qu'elle donne est «visible». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C, le masquage des implémentations est effectué à l'intérieur d'un module, marquant les fonctions qui ne devraient pas être visibles de l'extérieur avec le mot-clé statique. Les prototypes des fonctions qui composent l'interface du module sont placés dans le fichier d'en-tête. Un module en C signifie une paire: un fichier source avec l'extension * .c et un en-tête avec l'extension * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java possède également le mot-clé statique, mais il n'affecte pas la «visibilité» de la méthode ou du champ de l'extérieur. </font><font style="vertical-align: inherit;">Pour contrôler la «visibilité», il existe 3 modificateurs d'accès: privé, protégé, public. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les champs et méthodes d'une classe marquée comme privée ne sont disponibles qu'à l'intérieur. </font><font style="vertical-align: inherit;">Les champs et méthodes protégés sont également accessibles aux descendants de classe. </font><font style="vertical-align: inherit;">Le modificateur public signifie que l'élément marqué est accessible de l'extérieur de la classe, c'est-à-dire qu'il fait partie de l'interface. </font><font style="vertical-align: inherit;">Il est également possible qu'il n'y ait pas de modificateur, dans ce cas, l'accès à l'élément class est limité par le package dans lequel se trouve la classe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'écriture d'une classe, il est recommandé de marquer initialement tous les champs de la classe comme privés et d'étendre les droits d'accès si nécessaire.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surcharge de méthode </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'une des caractéristiques gênantes de la bibliothèque standard C est la présence de tout un zoo de fonctions qui exécutent essentiellement la même chose, mais diffèrent dans le type d'argument, par exemple: fabs (), fabsf (), fabsl () - fonctions permettant d'obtenir la valeur absolue pour double, float et long types doubles respectivement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (ainsi que C ++) prend en charge un mécanisme de surcharge de méthode - il peut y avoir plusieurs méthodes dans une classe avec un nom complètement identique, mais différant par le type et le nombre d'arguments. </font><font style="vertical-align: inherit;">Par le nombre d'arguments et leur type, le compilateur choisira la version nécessaire de la méthode elle-même - elle est très pratique et améliore la lisibilité du programme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, contrairement à C ++, les opérateurs ne peuvent pas être surchargés. </font><font style="vertical-align: inherit;">L'exception est les opérateurs "+" et "+ =", qui sont initialement surchargés pour les chaînes String.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caractères et chaînes en Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En C, vous devez travailler avec des chaînes null-terminal représentées par des pointeurs vers le premier caractère: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces lignes doivent se terminer par un caractère nul. </font><font style="vertical-align: inherit;">Si elle est accidentellement "effacée", une chaîne sera considérée comme une séquence d'octets en mémoire jusqu'au premier caractère nul. </font><font style="vertical-align: inherit;">Autrement dit, si d'autres variables de programme sont placées dans la mémoire après la ligne, puis après avoir modifié une telle ligne endommagée, leurs valeurs peuvent (et très probablement) seront déformées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, un programmeur C n'est pas obligé d'utiliser des chaînes null-terminal classiques, mais applique une implémentation tierce, mais ici, il faut garder à l'esprit que toutes les fonctions de la bibliothèque standard nécessitent des chaînes null-terminal comme arguments. </font><font style="vertical-align: inherit;">De plus, la norme C ne définit pas l'encodage utilisé, ce point doit également être contrôlé par le programmeur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, le type de caractère primitif (ainsi que l'encapsuleur de caractères, à propos des encapsuleurs ci-dessous) représentent un seul caractère selon la norme Unicode. Le codage UTF-16 est utilisé, respectivement, un caractère occupe 2 octets en mémoire, ce qui vous permet de coder presque tous les caractères des langues actuellement utilisées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les caractères peuvent être spécifiés par leur Unicode:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'Unicode d'un caractère dépasse le maximum de 216 pour char, alors un tel caractère doit être représenté par int. Dans la chaîne, il occupera 2 caractères de 16 bits, mais là encore, les caractères avec un code supérieur à 216 sont extrêmement rarement utilisés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chaînes Java sont implémentées par la classe String intégrée et stockent des caractères char 16 bits. La classe String contient tout ou presque tout ce qui peut être nécessaire pour travailler avec des chaînes. Il n'est pas nécessaire de penser au fait que la ligne doit nécessairement se terminer par zéro, ici il est impossible "d'effacer" imperceptiblement ce caractère de terminaison zéro ou d'accéder à la mémoire au-delà de la ligne. En général, lorsqu'il travaille avec des chaînes en Java, le programmeur ne pense pas à la façon dont la chaîne est stockée en mémoire.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme mentionné ci-dessus, Java n'autorise pas la surcharge d'opérateur (comme en C ++), cependant la classe String est une exception - seulement pour elle les opérateurs de fusion de ligne "+" et "+ =" sont initialement surchargés. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est à noter que les chaînes en Java sont immuables - une fois créées, elles ne permettent pas leur modification. </font><font style="vertical-align: inherit;">Lorsque nous essayons de changer la ligne, par exemple, comme ceci:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, la chaîne d'origine ne change pas réellement. </font><font style="vertical-align: inherit;">Au lieu de cela, une copie modifiée de la chaîne d'origine est créée, qui à son tour est également immuable:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, chaque modification d'une chaîne entraîne en réalité la création d'un nouvel objet (en fait, en cas de fusion de chaînes, le compilateur peut optimiser le code et utiliser la classe StringBuilder, qui sera discutée plus loin). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il arrive que le programme doive souvent changer la même ligne. </font><font style="vertical-align: inherit;">Dans de tels cas, afin d'optimiser la vitesse du programme et la consommation de mémoire, vous pouvez empêcher la création de nouveaux objets de ligne. </font><font style="vertical-align: inherit;">À ces fins, la classe StringBuilder doit être utilisée:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Séparément, il convient de mentionner la comparaison des chaînes. </font><font style="vertical-align: inherit;">Une erreur typique d'un programmeur Java novice consiste à comparer des chaînes en utilisant l'opérateur "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code ne contient pas formellement d'erreurs au stade de la compilation ni d'erreurs d'exécution, mais il fonctionne différemment de ce à quoi on pourrait s'attendre. </font><font style="vertical-align: inherit;">Puisque tous les objets et chaînes, y compris en Java, sont représentés par des liens, la comparaison avec l'opérateur "==" donne une comparaison des liens, pas des valeurs des objets. </font><font style="vertical-align: inherit;">Autrement dit, le résultat ne sera vrai que si 2 liens font vraiment référence à la même ligne. </font><font style="vertical-align: inherit;">Si les chaînes sont des objets différents en mémoire et que vous devez comparer leur contenu, vous devez utiliser la méthode equals ():</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La chose la plus surprenante est que dans certains cas, la comparaison à l'aide de l'opérateur «==» fonctionne correctement: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, someString et anotherString font référence au même objet en mémoire. </font><font style="vertical-align: inherit;">Le compilateur place les mêmes littéraux de chaîne dans le pool de chaînes - le soi-disant internement se produit. </font><font style="vertical-align: inherit;">Ensuite, chaque fois que le même littéral de chaîne apparaît dans le programme, un lien vers la chaîne du pool est utilisé. </font><font style="vertical-align: inherit;">L'internement de chaînes est précisément possible en raison de la propriété d'immuabilité des chaînes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que la comparaison du contenu des chaînes ne soit autorisée que par la méthode equals (), en Java, il est possible d'utiliser correctement les chaînes dans les constructions à commutateur (à partir de Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curieusement, tout objet Java peut être converti en chaîne. </font><font style="vertical-align: inherit;">La méthode toString () correspondante est définie dans la classe de base pour toutes les classes de la classe Object.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Approche de gestion des erreurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la programmation en C, vous pouvez proposer l'approche de gestion des erreurs suivante. Chaque fonction d'une bibliothèque renvoie un type int. Si la fonction réussit, ce résultat est 0. Si le résultat est différent de zéro, cela indique une erreur. Le plus souvent, le code d'erreur est transmis via la valeur renvoyée par la fonction. Étant donné que la fonction ne peut renvoyer qu'une seule valeur et qu'elle est déjà occupée par le code d'erreur, le résultat réel de la fonction doit être renvoyé via l'argument sous la forme d'un pointeur, par exemple, comme ceci:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par ailleurs, c'est l'un des cas où dans un programme C, il devient nécessaire d'utiliser un pointeur vers un pointeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, ils utilisent une approche différente. La fonction ne renvoie pas de code d'erreur, mais directement le résultat de son exécution, généralement sous la forme d'un pointeur. Une situation d'erreur est indiquée par un pointeur nul. Ensuite, la bibliothèque contient généralement une fonction distincte qui renvoie le code de la dernière erreur:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une manière ou d'une autre, lors de la programmation en C, le code qui fait le travail «utile» et le code responsable du traitement des erreurs s'entrelacent, ce qui ne rend évidemment pas le programme facile à lire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, si vous le souhaitez, vous pouvez utiliser les approches décrites ci-dessus, mais ici, vous pouvez appliquer une manière complètement différente de traiter les erreurs - la gestion des exceptions (cependant, comme en C ++). L'avantage de la gestion des exceptions est que dans ce cas, le code «utile» et le code responsable de la gestion des erreurs et des imprévus sont logiquement séparés les uns des autres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est réalisé en utilisant des constructions try-catch: le code «utile» est placé dans la section try et le code de gestion des erreurs est placé dans la section catch.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe des situations où il n'est pas possible de traiter correctement l'erreur au lieu de son occurrence. </font><font style="vertical-align: inherit;">Dans de tels cas, une indication est placée dans la signature de méthode que la méthode peut provoquer ce type d'exception:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, l'appel à cette méthode doit nécessairement être encadré dans un bloc try-catch, ou la méthode appelante doit également être marquée pour pouvoir lever cette exception. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absence de préprocesseur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle que soit la commodité du préprocesseur familier aux programmeurs C / C ++, il est absent du langage Java. </font><font style="vertical-align: inherit;">Les développeurs Java ont probablement décidé qu'il n'était utilisé que pour garantir la portabilité des programmes, et comme Java s'exécute partout (presque), aucun préprocesseur n'est nécessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez compenser l'absence d'un préprocesseur à l'aide d'un champ indicateur statique et vérifier sa valeur dans le programme, si nécessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de l'organisation des tests, il est possible d'utiliser des annotations en conjonction avec la réflexion (réflexion).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un tableau est également un objet. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec des tableaux en C, la sortie d'index au-delà des limites du tableau est une erreur très insidieuse. </font><font style="vertical-align: inherit;">Le compilateur ne le signalera en aucune façon, et pendant l'exécution le programme ne sera pas arrêté avec le message correspondant:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Très probablement, le programme continuera son exécution, mais la valeur de la variable qui se trouvait après le tableau matriciel dans l'exemple ci-dessus sera déformée. Le débogage de ce type d'erreur peut ne pas être facile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, le programmeur est protégé contre ce type d'erreurs difficiles à diagnostiquer. Lorsque vous essayez d'aller au-delà des limites du tableau, une ArrayIndexOutOfBoundsException est levée. Si l'exception catch n'a pas été programmée à l'aide de la construction try-catch, le programme se bloque et un message correspondant est envoyé au flux d'erreur standard indiquant le fichier avec le code source et le numéro de ligne où le tableau a été dépassé. Autrement dit, le diagnostic de ces erreurs devient une question triviale.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce comportement du programme Java est rendu possible car le tableau en Java est représenté par un objet. </font><font style="vertical-align: inherit;">Le tableau Java ne peut pas être redimensionné; sa taille est codée en dur au moment où la mémoire est allouée. </font><font style="vertical-align: inherit;">Au moment de l'exécution, obtenir la taille de la matrice est aussi simple que de décortiquer des poires:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de tableaux multidimensionnels, alors, par rapport au langage C, Java offre une opportunité intéressante d'organiser des tableaux "Ladder". </font><font style="vertical-align: inherit;">Dans le cas d'un tableau à deux dimensions, la taille de chaque ligne individuelle peut différer des autres:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme en C, les éléments du tableau sont situés en mémoire un par un, donc l'accès au tableau est considéré comme le plus efficace. Si vous devez effectuer des opérations d'insertion / suppression d'éléments ou créer des structures de données plus complexes, vous devez utiliser des collections, telles qu'un ensemble (Set), une liste (List), une carte (Map). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison du manque de pointeurs et de l'impossibilité d'incrémenter les liens, l'accès aux éléments du tableau est possible à l'aide d'index.</font></font><br><br><h2>  Les collections </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souvent, la fonctionnalité des tableaux n'est pas suffisante - vous devez alors utiliser des structures de données dynamiques. Étant donné que la bibliothèque C standard ne contient pas d'implémentation prête à l'emploi de structures de données dynamiques, vous devez utiliser l'implémentation dans des codes source ou sous forme de bibliothèques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrairement à C, la bibliothèque Java standard contient un riche ensemble d'implémentations de structures de données dynamiques ou de collections, exprimées en termes de Java. Toutes les collections sont divisées en 3 grandes classes: listes, ensembles et cartes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes - tableaux dynamiques - vous permettent d'ajouter / supprimer des éléments. Beaucoup n'assurent pas l'ordre des éléments ajoutés, mais garantissent qu'il n'y a pas d'éléments en double. Les cartes ou les tableaux associatifs fonctionnent avec des paires clé-valeur, et la valeur clé est unique - il ne peut pas y avoir 2 paires avec les mêmes clés dans la carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les listes, les ensembles et les cartes, il existe de nombreuses implémentations, chacune étant optimisée pour une opération spécifique. Par exemple, les listes sont implémentées par les classes ArrayList et LinkedList, ArrayList offrant de meilleures performances lors de l'accès à un élément arbitraire, et LinkedList est plus efficace lors de l'insertion / suppression d'éléments au milieu de la liste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seuls les objets Java complets peuvent être stockés dans des collections (en fait, des références à des objets), il est donc impossible de créer directement une collection de primitives (int, char, byte, etc.). </font><font style="vertical-align: inherit;">Dans ce cas, les classes wrapper appropriées doivent être utilisées:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitif </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cours d'emballage </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> octet </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Octet </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> court </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Court </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Personnage </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entier </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> longue </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Long </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flotter </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flotter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> double </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Double </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> booléen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Booléen </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heureusement, lors de la programmation en Java, il n'est pas nécessaire de suivre la coïncidence exacte du type primitif et de son "wrapper". </font><font style="vertical-align: inherit;">Si la méthode reçoit un argument, par exemple, de type Integer, alors il peut être passé le type int. </font><font style="vertical-align: inherit;">Et vice versa, lorsque le type int est requis, vous pouvez utiliser Integer en toute sécurité. </font><font style="vertical-align: inherit;">Cela a été rendu possible grâce au mécanisme intégré Java pour l'emballage / le déballage des primitives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les moments désagréables, il convient de mentionner que la bibliothèque Java standard contient d'anciennes classes de collection qui ont été implémentées sans succès dans les premières versions de Java et qui ne doivent pas être utilisées dans de nouveaux programmes. </font><font style="vertical-align: inherit;">Ce sont les classes Enumeration, Vector, Stack, Dictionary, Hashtable, Properties.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Généralisations </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les collections sont couramment utilisées comme types de données génériques. </font><font style="vertical-align: inherit;">L'essence des généralisations dans ce cas est que nous spécifions le type principal de la collection, par exemple, ArrayList, et entre crochets spécifions le type de paramètre, qui dans ce cas détermine le type d'éléments stockés dans la liste:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela permet au compilateur de suivre la tentative d'ajout d'un objet d'un type autre que le paramètre de type spécifié: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il est très important que le paramètre-type soit effacé lors de l'exécution du programme, et il n'y a pas de différence entre, par exemple, un objet de la classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et objet de classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par conséquent, il n'y a aucun moyen de découvrir le type d'éléments de collection pendant l'exécution du programme: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une solution partielle peut être l'approche suivante: prendre le premier élément de la collection et déterminer son type: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cette approche ne fonctionnera pas si la liste est vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À cet égard, les généralisations Java sont nettement inférieures aux généralisations C ++. </font><font style="vertical-align: inherit;">Les généralisations Java servent en fait à «couper» certaines des erreurs potentielles au stade de la compilation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itérer sur tous les éléments d'un tableau ou d'une collection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de la programmation en C, vous devez souvent parcourir tous les éléments du tableau: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour faire une erreur ici, c'est plus simple, il suffit de spécifier la mauvaise taille du tableau SIZE ou de mettre "&lt;=" au lieu de "&lt;". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, en plus de la forme «habituelle» de l'instruction for, il existe une forme pour itérer sur tous les éléments d'un tableau ou d'une collection (souvent appelée foreach dans d'autres langages):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous garantissons d'itérer sur tous les éléments de la liste, les erreurs inhérentes à la forme «habituelle» de l'instruction for sont éliminées. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collections diverses </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Étant donné que tous les objets sont hérités de l'objet racine, Java a une opportunité intéressante de créer des listes avec différents types réels d'éléments: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transferts </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En comparant C / C ++ et Java, il est impossible de ne pas remarquer combien d'énumérations plus fonctionnelles sont implémentées en Java. </font><font style="vertical-align: inherit;">Ici, l'énumération est une classe à part entière, et les éléments d'énumération sont des objets de cette classe. </font><font style="vertical-align: inherit;">Cela permet à un élément d'énumération de mettre plusieurs champs de tout type en correspondance:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tant que classe à part entière, une énumération peut avoir des méthodes et, à l'aide d'un constructeur privé, vous pouvez définir les valeurs de champ des éléments d'énumération individuels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une occasion régulière d'obtenir une représentation sous forme de chaîne d'un élément d'énumération, un numéro de série, ainsi qu'un tableau de tous les éléments:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et vice versa - par la représentation sous forme de chaîne, vous pouvez obtenir un élément d'énumération, et également appeler ses méthodes: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naturellement, les énumérations peuvent être utilisées dans les constructions de casse de commutation. </font></font><br><br><h2>  Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, les langages C et Java sont conçus pour résoudre des problèmes complètement différents. Mais, si l'on compare néanmoins le processus de développement logiciel dans ces deux langages, alors, selon les impressions subjectives de l'auteur, le langage Java surpasse significativement C dans la commodité et la rapidité d'écriture des programmes. L'environnement de développement (IDE) joue un rôle important dans la commodité. L'auteur a travaillé avec IntelliJ IDEA IDE. Lors de la programmation en Java, vous n’avez pas constamment à «avoir peur» de faire une erreur - souvent l’environnement de développement vous dira ce qui doit être corrigé, et parfois il le fera pour vous. Si une erreur d'exécution s'est produite, le type d'erreur et le lieu de son occurrence dans le code source sont toujours indiqués dans le journal - la lutte contre de telles erreurs devient triviale. Un programmeur C n'a pas besoin de faire des efforts inhumains pour passer à Java, et tout cela parce que la syntaxe du langage a légèrement changé.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si cette expérience sera intéressante pour les lecteurs, dans le prochain article, nous parlerons de l'expérience d'utilisation du mécanisme JNI (exécution de code C / C ++ natif à partir d'une application Java). </font><font style="vertical-align: inherit;">Le mécanisme JNI est indispensable lorsque vous souhaitez contrôler la résolution d'écran, le module Bluetooth et dans d'autres cas lorsque les capacités des services et gestionnaires Android ne sont pas suffisantes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412775/">https://habr.com/ru/post/fr412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412763/index.html">Utilisation de la carte de rechargement Firefly-RK3288 avec le SoC RockChip RK3288 Capteur thermique numérique Microchip I2C - MCP9808</a></li>
<li><a href="../fr412765/index.html">Introduction au nouveau système de cartes de tuiles Unity</a></li>
<li><a href="../fr412767/index.html">Examen de la conférence CMG Impact 2016</a></li>
<li><a href="../fr412769/index.html">J'ai fait PWA et l'ai mis dans trois app stores. Et voici ce que j'ai découvert</a></li>
<li><a href="../fr412773/index.html">Astro-aérospatiale de Minsk</a></li>
<li><a href="../fr412777/index.html">Chefs-d'œuvre de la construction de colonnes du monde: QUAD 11L - les meilleures «étagères» du deux millième</a></li>
<li><a href="../fr412779/index.html">SSLH: cache SSH / HTTPS / OpenVPN / Telegram derrière un seul port 443</a></li>
<li><a href="../fr412781/index.html">Un fan de NES a permis de lancer des jeux SNES sur la console</a></li>
<li><a href="../fr412783/index.html">Installation du proxy MTProto Telegram à partir de la source sur Centos 7</a></li>
<li><a href="../fr412785/index.html">Master of Management et Freelancer. L'histoire en trois parties</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>