<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèø ‚ôçÔ∏è üë®üèΩ‚Äçüíª Si su proyecto es "Teatro", use actores ü§Ωüèº üõÄüèº üêâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay una historia sobre una experiencia de usar Actor Model en un proyecto interesante de desarrollar un sistema de control autom√°tico para un teatro. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Si su proyecto es "Teatro", use actores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452464/"><p>  Hay una historia sobre una experiencia de usar Actor Model en un proyecto interesante de desarrollar un sistema de control autom√°tico para un teatro.  A continuaci√≥n les contar√© mis impresiones, no m√°s que eso. </p><a name="habracut"></a><br><p> No hace mucho tiempo particip√© en una tarea emocionante: la modernizaci√≥n del sistema de control autom√°tico (ACS) para los polipastos, pero de hecho fue el desarrollo de un nuevo ACS. </p><br><p>  Un teatro moderno (especialmente si es grande) es una organizaci√≥n muy compleja.  Hay muchas personas, varios mecanismos y sistemas.  Uno de estos sistemas es ACS para el manejo de levantar y establecer el paisaje.  Actuaciones modernas, como √≥peras y ballets, utilizan cada vez m√°s medios t√©cnicos a√±o tras a√±o.  El escenario es utilizado activamente por los directores del espect√°culo e incluso juega su propio papel importante.  Fue fascinante descubrir lo que sucede detr√°s de las cortinas porque los espectadores comunes solo pueden ver acciones en la escena. </p><br><p>  Pero este es un art√≠culo t√©cnico, y quiero compartir mi experiencia de usar el Modelo de actor para escribir un sistema de control.  Y comparta mis impresiones sobre el uso de uno de los marcos de actores para C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> . </p><br><p>  ¬øPor qu√© elegimos este marco?  Lo hemos estado mirando durante mucho tiempo.  Hay muchos art√≠culos en ruso, y tiene una documentaci√≥n maravillosa y muchos ejemplos.  El proyecto parece maduro.  Una breve mirada a los ejemplos ha demostrado que los desarrolladores de SObjectizer usan los mismos t√©rminos (estados, temporizadores, eventos, etc.) y no esper√°bamos grandes problemas para estudiarlo y usarlo.  Y otro factor importante: el equipo de SObjectizer es √∫til y siempre est√° listo para ayudarnos.  Entonces decidimos intentarlo. </p><br><h1 id="what-were-doing">  Que estamos haciendo </h1><br><p>  Hablemos sobre el objetivo de nuestro proyecto.  El sistema de polipastos de listones tiene 62 listones (tubos de metal).  Cada list√≥n es tan largo como toda la etapa.  Se suspenden en cuerdas en paralelo con espacios de 30-40 cm, comenzando desde el borde frontal del escenario.  Cada list√≥n se puede subir o bajar.  Algunos de ellos se utilizan en un espect√°culo para decorar.  El escenario se fija en el list√≥n y se mueve hacia arriba / abajo durante la actuaci√≥n.  Los comandos de los operadores inician el movimiento.  Un sistema de "contrapeso de la cuerda del motor" es similar a uno utilizado en ascensores en edificios residenciales.  Los motores se colocan fuera del escenario, para que los espectadores no los vean.  Todos los motores se dividen en 8 grupos, y cada grupo tiene 3 convertidores de frecuencia (FC).  Como m√°ximo se pueden usar tres motores al mismo tiempo en un grupo, cada uno de ellos est√° conectado a un FC separado.  Entonces, tenemos un sistema de 62 motores y 24 FC, y tenemos que controlar este sistema. </p><br><p>  Nuestra tarea era desarrollar una interfaz hombre-m√°quina (HMI) para controlar este sistema e implementar algoritmos de control.  El sistema incluye tres estaciones de control.  Dos de ellos se colocan justo por encima del escenario, y uno est√° en la sala de m√°quinas (un electricista de servicio utiliza esta estaci√≥n).  Tambi√©n hay bloques de control con controladores en la sala de m√°quinas.  Estos controladores realizan comandos de control, modulan el ancho de pulso (PWM), encienden o apagan los motores, controlan la posici√≥n de los listones.  Dos estaciones de control sobre el escenario tienen pantallas, unidades de sistema y trackballs como dispositivos se√±aladores.  Las estaciones de control est√°n conectadas a trav√©s de Ethernet.  Cada estaci√≥n de control est√° conectada con bloques de control por el canal RS485.  Ambas estaciones sobre el escenario se pueden usar para controlar el sistema al mismo tiempo, pero solo una estaci√≥n puede estar activa.  La estaci√≥n activa es seleccionada por un operador;  la segunda estaci√≥n ser√° pasiva;  la estaci√≥n pasiva tiene su canal RS485 deshabilitado. </p><br><h1 id="why-actors">  ¬øPor qu√© actores? </h1><br><p>  Desde el punto de vista de los algoritmos, el sistema est√° construido sobre eventos.  Datos de sensores, acciones del operador, caducidad de temporizadores ... Todos estos son ejemplos de eventos.  El modelo de actor funciona bien para tales algoritmos: los actores manejan los eventos entrantes y forman algunas acciones salientes dependiendo de su estado actual.  Estas mec√°nicas est√°n disponibles en SObjectizer reci√©n listas para usar. </p><br><p>  Los principios b√°sicos para tales sistemas son: los actores interact√∫an a trav√©s de mensajes asincr√≥nicos, los actores tienen estados y cambian de un estado a otro, solo se manejan los mensajes que son significativos para el estado actual. </p><br><p>  Es interesante que los actores est√©n desconectados de los hilos de trabajo en SObjectizer.  Significa que puede implementar y depurar a sus actores primero y solo luego decidir qu√© hilo de trabajo se usar√° para cada actor.  Hay "Despachadores" que implementan varias pol√≠ticas relacionadas con hilos.  Por ejemplo, hay un despachador que proporciona un hilo de trabajo separado para cada actor;  hay un despachador de grupo de subprocesos que proporciona un grupo de subprocesos de trabajo de tama√±o fijo;  Hay un despachador que ejecuta todos los actores en el mismo hilo. </p><br><p>  La presencia de despachadores proporciona una forma muy flexible de ajustar un sistema de actores para nuestras necesidades.  Podemos agrupar algunos actores para trabajar en el mismo contexto.  Podemos cambiar el tipo de despachador con solo una l√≠nea de c√≥digo.  Los desarrolladores de SObjectizer dicen que escribir un despachador personalizado no es una tarea compleja.  Pero no hab√≠a necesidad de escribir nuestro propio despachador en este proyecto;  todo lo que necesit√°bamos se encontr√≥ en SObjectizer. </p><br><p>  Otra caracter√≠stica interesante son las cooperaciones de actores.  Una cooperaci√≥n es un grupo de actores que puede existir si y solo si todos los actores han comenzado con √©xito.  La cooperaci√≥n no puede iniciarse si al menos uno de sus actores no ha podido comenzar.  Parece que hay una analog√≠a entre las cooperaciones de SObjectizer y las vainas de Kubernetes, pero tambi√©n parece que las cooperaciones de SObjectizer han aparecido antes ... </p><br><p>  Cuando se crea un actor, se agrega a la cooperaci√≥n (la cooperaci√≥n puede contener solo un actor) y est√° vinculado a alg√∫n despachador.  Es f√°cil crear cooperaciones y actores din√°micamente y los desarrolladores de SObjectizer dicen que es una operaci√≥n bastante barata. </p><br><p>  Todos los actores interact√∫an entre s√≠ a trav√©s de "cuadros de mensaje" (mbox).  Es otro concepto de SObjectizer interesante y poderoso.  Proporciona una forma flexible de procesamiento de mensajes. </p><br><p>  Al principio, puede haber m√°s de un receptor de mensajes detr√°s de un mbox.  Es bastante √∫til.  Por ejemplo, puede haber un mbox que utilizan los sensores para publicar nuevos datos.  Los actores pueden crear suscripciones para ese mbox, y los actores suscritos recibir√°n los datos que deseen.  Esto permite trabajar de manera "Publicar / Suscribir". </p><br><p>  En segundo lugar, los desarrolladores de SObjectizer han previsto la posibilidad de crear mbox personalizados.  Es relativamente f√°cil crear un mbox personalizado con procesamiento especial de mensajes entrantes (como filtrar o distribuir entre varios suscriptores en funci√≥n del contenido del mensaje). </p><br><p>  Tambi√©n hay un mbox personal para cada actor y los actores pueden pasar una referencia a ese mbox en mensajes a otros actores (que permite responder directamente a un actor espec√≠fico). </p><br><p>  En nuestro proyecto dividimos todos los objetos controlados en ocho grupos (un grupo para cada cuadro de control).  Se crearon tres subprocesos de trabajo para cada grupo (se debe a que solo tres motores pueden funcionar al mismo tiempo).  Nos permiti√≥ tener independencia entre grupos de motores.  Tambi√©n permiti√≥ trabajar de forma as√≠ncrona con motores dentro de cada grupo. </p><br><p>  Es necesario mencionar que SObjectizer-5 no tiene mecanismos para la interacci√≥n entre procesos o redes.  Esta es una decisi√≥n consciente de los desarrolladores de SObjectizer;  quer√≠an hacer SObjectizer lo m√°s ligero posible.  Adem√°s, el soporte transparente para redes hab√≠a existido en algunas versiones anteriores de SObjectizer pero fue eliminado.  No nos molest√≥ porque un mecanismo para la red depende en gran medida de una tarea, los protocolos utilizados y otras condiciones.  No existe una soluci√≥n universal √∫nica para todos los casos. </p><br><p>  En nuestro caso, utilizamos nuestra antigua biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libuniset2</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunicaciones</a> de red e interproceso.  Como resultado, libuniset2 admite comunicaciones con sensores y bloques de control, y SObjectizer admite actores e interacciones entre actores dentro de un solo proceso. </p><br><p>  Como dije anteriormente, hay 62 motores.  Cada motor se puede conectar a un FC (convertidor de frecuencia);  se puede especificar una coordenada de destino para el list√≥n correspondiente;  Tambi√©n se puede especificar la velocidad del movimiento del list√≥n.  Y adem√°s de eso, cada motor tiene los siguientes estados: </p><br><ul><li>  listo para trabajar </li><li>  conectado </li><li>  trabajando </li><li>  mal funcionamiento </li><li>  conexi√≥n (un estado de transici√≥n); </li><li>  desconexi√≥n (un estado de transici√≥n); </li></ul><br><p> Cada motor est√° representado en el sistema por un actor que implementa la transici√≥n entre estados, manejando datos de sensores y emitiendo comandos.  No es dif√≠cil crear un actor en SObjectizer: simplemente herede su clase del tipo <code>so_5::agent_t</code> .  El primer argumento del constructor del actor debe ser de tipo <code>context_t</code> , todos los dem√°s argumentos pueden definirse como lo desee un desarrollador. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  No mostrar√© la descripci√≥n detallada de clases y m√©todos porque no es un tutorial.  Solo quiero mostrar lo f√°cil que se puede hacer todo en SObjectizer (literalmente en unas pocas l√≠neas).  Perm√≠tame recordarle que SObjectizer tiene una excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> y muchos ejemplos. </p><br><h1 id="what-is-the-state-of-an-actor-what-are-we-talking-about">  ¬øCu√°l es el "estado" de un actor?  De que estamos hablando </h1><br><p>  El uso de estados y la transici√≥n entre ellos es un "tema nativo" para los sistemas de control.  Este concepto es muy bueno para el manejo de eventos.  Este concepto es compatible con SObjectizer a nivel de API.  Los estados se declaran dentro de la clase del actor: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre> <br><p>  y luego los controladores de eventos se definen para cada estado.  A veces es necesario hacer algo al entrar o salir de un estado.  Esto tambi√©n es compatible con SObjectizer a trav√©s de controladores on_enter / on_exit.  Parece que los desarrolladores de SObjectizer tienen experiencia en el desarrollo de sistemas de control. </p><br><h1 id="event-handlers">  Controladores de eventos </h1><br><p>  Un controlador de eventos es un lugar donde se implementa la l√≥gica de su aplicaci√≥n.  Como dije anteriormente, se crea una suscripci√≥n para un mbox particular y un estado espec√≠fico.  Si un actor no tiene estados especificados expl√≠citamente, se encuentra en un "estado_de_determinado" especial. </p><br><p>  Se pueden definir diferentes controladores para el mismo evento en diferentes estados.  Si no define un controlador para alg√∫n evento, este evento ser√° ignorado (un actor no lo sabr√°). </p><br><p>  Hay una sintaxis simple para definir controladores de eventos.  Usted especifica un m√©todo y no es necesario especificar tipos adicionales o par√°metros de plantilla.  Por ejemplo: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Es un ejemplo de suscripci√≥n en eventos desde un mbox espec√≠fico en el estado st_base.  Vale la pena mencionar que st_base es un estado base para algunos otros estados y que la suscripci√≥n ser√° heredada por los estados derivados.  Este enfoque permite deshacerse de copiar y pegar para controladores de eventos similares en diferentes estados.  Pero el controlador de eventos heredado puede redefinirse para un estado particular o un evento puede deshabilitarse por completo ("suprimirse"). </p><br><p>  Otra forma de definir manejadores de eventos es usar funciones lambda.  Es una forma muy conveniente porque los controladores de eventos a menudo contienen solo una o dos l√≠neas de c√≥digo: un env√≠o de algo a alg√∫n lugar o un cambio de estado: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Esa sintaxis parece compleja al principio, pero se vuelve familiar justo despu√©s de un par de d√≠as de codificaci√≥n activa e incluso comienza a gustarle.  Es porque toda la l√≥gica de alg√∫n actor puede ser concisa y ubicarse en una sola pantalla.  En el ejemplo que se muestra arriba, hay transiciones de st_disconnected a st_off o st_protection.  Este c√≥digo es f√°cil de leer. </p><br><p>  Por cierto, para casos sencillos, donde solo es necesaria una transici√≥n de estado, hay una sintaxis especial: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre> <br><h1 id="the-control">  El control </h1><br><p>  ¬øC√≥mo se organiza el control?  Como se mencion√≥ anteriormente, hay dos estaciones de control para controlar el movimiento de los listones.  Cada estaci√≥n de control tiene una pantalla, un dispositivo se√±alador (trackball) y un programador de velocidad (y no contamos con una computadora dentro de la estaci√≥n y algunos accesorios adicionales). </p><br><p>  Hay dos modos de control: manual y "modo de escenario".  El "modo de escenario" se discutir√° m√°s adelante, y ahora hablemos del modo manual.  En este modo, un operador selecciona un list√≥n, lo prepara para el movimiento (conecta el motor a un FC), establece la marca de objetivo para el list√≥n y cuando la velocidad se establece por encima de cero, el list√≥n comienza a moverse. </p><br><p>  El ajustador de velocidad es un accesorio f√≠sico en forma de "potenci√≥metro con mango", pero tambi√©n se muestra uno virtual en la pantalla de la estaci√≥n.  Cuanto m√°s se gira, mayor es la velocidad de movimiento.  La velocidad m√°xima est√° limitada a 1,5 metros por segundo.  El setter de velocidad es uno para todos los listones.  Significa que todos los listones seleccionados se mueven a la misma velocidad.  Los listones pueden moverse en direcciones opuestas (depende de la selecci√≥n del operador).  Es evidente que es dif√≠cil para un humano controlar m√°s que unos pocos listones.  Debido a eso, solo peque√±os grupos de listones se manejan en el modo manual.  Los operadores pueden controlar listones desde dos estaciones de control al mismo tiempo.  Por lo tanto, hay un configurador de velocidad separado para cada estaci√≥n. </p><br><p>  Desde el punto de vista de la implementaci√≥n, no existe una l√≥gica espec√≠fica en el modo manual.  Un comando "conectar motor" va desde la interfaz gr√°fica, se transforma en un mensaje correspondiente a un actor y luego ese actor lo maneja.  El actor pasa del estado "apagado" a "conectado", y luego al estado "conectado".  Suceden cosas similares con los comandos para colocar un list√≥n y establecer la velocidad de movimiento.  Todos estos comandos se pasan a un actor en forma de mensajes.  Pero vale la pena mencionar que "interfaz gr√°fica" y "proceso de control" son procesos separados y libuniset2 se utiliza para IPC. </p><br><h1 id="the-scenario-mode-are-there-actors-again">  El modo Escenario (¬øhay actores nuevamente?) </h1><br><p>  En la pr√°ctica, el modo manual se usa solo para casos muy simples o durante los ensayos.  El modo de control principal es el "modo de escenario".  En ese modo, cada list√≥n se mueve a una posici√≥n espec√≠fica con una velocidad particular de acuerdo con la configuraci√≥n del escenario.  Dos comandos simples est√°n disponibles para un operador en ese modo: </p><br><ul><li>  prepare (se est√° conectando un grupo de motores a FC); </li><li>  ir (comienza el movimiento del grupo). </li></ul><br><p>  Todo el escenario se divide en "agendas".  Una "agenda" describe un movimiento √∫nico de un grupo de listones.  Significa que una "agenda" incluye algunos listones y contiene destinos de destino y velocidades para ellos.  En realidad, un escenario consiste en actos, los actos consisten en im√°genes, la imagen consiste en agendas y la agenda consiste en objetivos para listones.  Pero desde el punto de vista del control, eso no importa, porque solo las agendas contienen los par√°metros precisos del movimiento del list√≥n. </p><br><p>  El modelo de actor se adapta perfectamente a ese caso.  Hemos desarrollado un "jugador de escenario" que genera un grupo de actores especiales y los inicia.  Hemos desarrollado dos tipos de actores: actores ejecutores (controlan el movimiento de los listones) y actores coordinadores (distribuyen tareas entre los ejecutores).  Los ejecutores se crean a pedido: cuando no hay ejecutores libres, se crear√° un nuevo ejecutor.  El coordinador gestiona el grupo de ejecutores disponibles.  Como resultado, el control se ve m√°s o menos as√≠: </p><br><ul><li>  un operador carga un escenario; </li><li>  "lo desplaza" hasta la agenda requerida; </li><li>  presiona el bot√≥n "preparar" en el momento apropiado.  En ese momento se env√≠a un mensaje a un coordinador.  Este mensaje contiene datos para cada list√≥n de la agenda; </li><li>  el coordinador revisa su grupo de ejecutores y distribuye tareas entre los ejecutores libres (se crean nuevos ejecutores, si es necesario); </li><li>  cada ejecutor recibe una tarea y realiza acciones de preparaci√≥n (conecta un motor a un FC, luego espera el comando "ir"); </li><li>  el operador presiona el bot√≥n "ir" en el momento apropiado; </li><li>  el comando "ir" va al coordinador y distribuye el comando entre todos los ejecutores que est√°n actualmente en uso. </li></ul><br><p>  Hay algunos par√°metros adicionales en las agendas.  Como "iniciar el movimiento solo despu√©s de N segundos de retraso" o "iniciar el movimiento solo despu√©s de un comando adicional de un operador".  Debido a eso, la lista de estados para un ejecutor es bastante larga: "listo para el pr√≥ximo comando", "listo para el movimiento", "demora del movimiento", "en espera del comando del operador", "en movimiento", "completado", "fracaso". </p><br><p>  Cuando un list√≥n ha alcanzado con √©xito la marca de destino (o hay una falla), el ejecutor informa al coordinador sobre la finalizaci√≥n de la tarea.  El coordinador responde con un comando para apagar el motor (si el list√≥n ya no participa en la agenda) o env√≠a una nueva tarea al ejecutor.  El ejecutor apaga el motor y cambia al estado de "espera" o comienza a procesar el nuevo comando. </p><br><p>  Debido a que SObjectizer tiene una API bastante reflexiva y conveniente para trabajar con estados, el c√≥digo de implementaci√≥n result√≥ ser bastante conciso.  Por ejemplo, un retraso antes del movimiento se describe con solo una l√≠nea de c√≥digo: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre> <br><p>  El m√©todo <code>time_limit</code> especifica la cantidad de tiempo para permanecer en el estado y qu√© estado debe activarse en ese momento ( <code>st_moving</code> en ese ejemplo). </p><br><h1 id="protection-actors">  Actores de protecci√≥n </h1><br><p>  Ciertamente, pueden ocurrir fallas.  Hay requisitos para manejar correctamente estas fallas.  Los actores tambi√©n se usan para tales tareas.  Veamos algunos ejemplos: </p><br><ul><li>  protecci√≥n contra sobrecorriente; </li><li>  protecci√≥n contra el mal funcionamiento del sensor; </li><li>  protecci√≥n contra el movimiento en la direcci√≥n opuesta (puede suceder si hay algo mal con los sensores o actuadores); </li><li>  protecci√≥n contra movimientos espont√°neos (sin comando); </li><li>  control de ejecuci√≥n del comando (se debe verificar el movimiento de un list√≥n). </li></ul><br><p>  Podemos ver que todos esos casos son autosuficientes, pero deben controlarse juntos, al mismo tiempo.  Significa que cualquier falla puede suceder.  Pero cada verificaci√≥n tiene su l√≥gica: a veces es necesario verificar un tiempo de espera, a veces es necesario analizar algunos valores anteriores de un sensor.  Por eso, la protecci√≥n se implementa en forma de peque√±os actores.  Estos actores se agregan a la cooperaci√≥n con el actor principal que implementa la l√≥gica de control.  Este enfoque permite agregar f√°cilmente nuevos casos de protecci√≥n: simplemente agregue otro actor protector a la cooperaci√≥n.  El c√≥digo de dicho actor suele ser conciso y f√°cil de entender, ya que implementa una sola funci√≥n. </p><br><p>  Los actores protectores tambi√©n tienen varios estados.  Por lo general, se encienden cuando se enciende un motor o cuando un list√≥n comienza su movimiento.  Cuando un protector detecta una falla / mal funcionamiento, publica una notificaci√≥n (con el c√≥digo de protecci√≥n y algunos detalles adicionales dentro).  El actor principal reacciona a esa notificaci√≥n y realiza las acciones necesarias (como apagar el motor y cambiar al estado protegido). </p><br><h1 id="as-the-conclusion">  Como conclusi√≥n ... </h1><br><p>  ... este art√≠culo no es un gran avance, por supuesto.  El modelo de actor se est√° utilizando en m√∫ltiples sistemas diferentes durante mucho tiempo.  Pero fue mi primera experiencia de usar el modelo de actor para construir un sistema de control autom√°tico en un proyecto bastante peque√±o.  Y esta experiencia result√≥ ser bastante exitosa.  Espero haber demostrado que los actores se ajustan bien a los algoritmos de control: hay lugares para actores literalmente en todas partes. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hab√≠amos</a> implementado algo similar en proyectos anteriores (me refiero a estados, intercambio de mensajes, gesti√≥n de hilos de trabajo, etc.), pero no era un enfoque unificado.  Al usar SObjectizer obtuvimos una herramienta peque√±a y liviana que resuelve muchos problemas.  Ya no necesitamos usar (expl√≠citamente) mecanismos de sincronizaci√≥n de bajo nivel (como mutexes), no hay administraci√≥n de subprocesos manual, no hay m√°s gr√°ficos de estado escritos a mano.  Todo esto lo proporciona el marco, conectado l√≥gicamente y expresado en forma de API conveniente, pero no pierde el control de los detalles.  Fue una experiencia emocionante.  Si a√∫n tiene dudas, le recomiendo que eche un vistazo al Modelo de actor y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> en particular.  Deja emociones positivas. </p><br><p>  ¬°El modelo de actor realmente funciona!  Especialmente en el teatro. </p><br><p>  Art√≠culo original en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruso</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452464/">https://habr.com/ru/post/452464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452454/index.html">Iniciar sesi√≥n en Azure DevOps con sus credenciales de GitHub</a></li>
<li><a href="../452456/index.html">Microsoft Kaizala permite a Indian Railways conectar a sus tres millones de empleados con servicios de salud</a></li>
<li><a href="../452458/index.html">Watch Dogs en la vida real, o vulnerabilidades serias en ACS</a></li>
<li><a href="../452460/index.html">Introduciendo Windows Terminal</a></li>
<li><a href="../452462/index.html">Acerca de OOP</a></li>
<li><a href="../452466/index.html">Teclado braille</a></li>
<li><a href="../452468/index.html">‚ÄúSi necesitas matar a alguien, entonces llegaste a la direcci√≥n‚Äù</a></li>
<li><a href="../452474/index.html">An√°lisis de wavelet. Parte 2</a></li>
<li><a href="../452478/index.html">Creaci√≥n de tablas en el sistema de dise√±o de Figma e implementaci√≥n en Storybook (React)</a></li>
<li><a href="../452480/index.html">Phoenix LiveView: cuando ya no necesita JavaScript *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>