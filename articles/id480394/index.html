<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ» ğŸ¤œ ğŸ‘ŒğŸ¿ Entri akuntansi duplikat dalam database relasional ğŸ¦ ğŸ‘¨ğŸ¼â€ğŸ­ ğŸ‘ŠğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari seorang penerjemah : selama bekerja di fintech Nigeria saya harus membuat satu sistem pembayaran dari awal. Pada saat itu, saya tidak benar-benar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entri akuntansi duplikat dalam database relasional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480394/"><p>  <em><b>Dari seorang penerjemah</b> : selama bekerja di <a href="https://habr.com/ru/post/346514/">fintech Nigeria</a> saya harus membuat satu sistem pembayaran dari awal.</em>  <em>Pada saat itu, saya tidak benar-benar mengerti apa-apa tentang akuntansi, bagaimana lebih baik menyimpan pembayaran dan saldo.</em>  <em>Tetapi ada kecurigaan bahwa opsi primitif dengan satu digit saldo di akun pengguna terlalu sederhana untuk dibenarkan.</em> </p><br><p>  <em>Artikel ini membantu saya memahami dan menghindari banyak masalah dalam hal ini.</em>  <em>Pada saat yang sama, informasi tentang topik "bagaimana membuat sistem pembayaran Anda sendiri" cukup kecil, dan tidak mudah bagi seorang programmer untuk memahami buku-buku tentang akuntansi (dan sangat membosankan).</em>  <em>Saya berharap materi ini akan bermanfaat bagi mereka yang hanya akan melakukan sesuatu seperti ini.</em> </p><br><p>  <em>Segera saya minta maaf atas kemungkinan ketidakakuratan dalam hal keuangan berbahasa Rusia - saya masih seorang programmer, bukan seorang akuntan, dan saya tidak akrab dengan terminologi Rusia di bidang ini.</em> </p><br><h3 id="vvedenie">  Pendahuluan </h3><br><p>  Banyak sistem komputer yang menggunakan basis data relasional menyimpan beberapa jenis informasi keuangan tentang saldo dan transaksi.  Selain itu, desain dan pengembangan database seperti itu sering menimbulkan pertanyaan tentang bagaimana menyimpan informasi ini.  Biasanya pilihannya adalah antara "rekaman sederhana" yang murah dan "rekaman ganda" yang lebih rumit. </p><br><p><img src="https://habrastorage.org/webt/jm/gv/sg/jmgvsgsfjrriyu-vzj-mdzacmvy.jpeg"><br>  <em>Luca Pacioli, penulis buku tertua (abad ke-15) yang masih hidup yang menjelaskan prinsip-prinsip entri ganda</em> </p><br><p>  Dalam sistem "catatan sederhana", nilai numerik direkam hanya sekali.  Dalam sistem entri ganda, setiap nilai dicatat dua kali sebagai kredit (nilai positif) dan sebagai debit (nilai negatif).  Ada seperangkat aturan yang menentukan hubungan antara nilai-nilai ini.  Aturan-aturan ini akan dengan mudah dijelaskan kepada Anda oleh akuntan berpengalaman mana pun, meskipun ia mungkin tidak membayangkan bagaimana mereka dapat diwakili dalam database relasional. </p><br><p>  Aturan dasarnya adalah sebagai berikut: </p><a name="habracut"></a><br><ol><li>  Setiap entri dalam sistem harus seimbang, mis.  jumlah semua nilai dalam satu operasi harus memberikan nol. </li><li>  Jumlah semua nilai dalam keseluruhan sistem pada waktu tertentu harus memberikan nol (aturan yang disebut "saldo percobaan"). </li><li>  Nilai yang sudah dimasukkan ke dalam basis data tidak dapat diedit atau dihapus.  Jika diperlukan koreksi, operasi pertama-tama harus dibatalkan oleh operasi lain dengan tanda yang berlawanan, dan kemudian diulangi dengan nilai yang benar.  Ini memungkinkan Anda untuk menerapkan jejak audit yang andal (log lengkap dari semua transaksi, seringkali diperlukan selama inspeksi). </li></ol><br><h3 id="primenimost-dvoynoy-buhgalterii">  Penerapan Pembukuan Berganda </h3><br><p>  Pada awal proyek, harga rendah dari rekaman sederhana selalu menggoda, dan biaya implementasi dan kompleksitas dari perekaman ganda penuh tampaknya tidak perlu.  Namun, dalam kenyataannya, sering menggunakan rekaman sederhana adalah tabungan yang salah. </p><br><p>  Jika informasi akuntansi dalam sistem TI hanya menyalin catatan kertas yang ada disimpan di luar database yang sedang dikembangkan, maka catatan sederhana masih memiliki hak untuk hidup.  Namun, jika setidaknya salah satu fakta tentang sistem yang tercantum di bawah ini benar, maka entri ganda harus digunakan sejak awal: </p><br><ol><li>  Jika pernah audit informasi akuntansi diperlukan </li><li>  Jika informasi dalam sistem adalah satu-satunya sumber informasi tentang properti </li><li>  Jika informasi menyangkut benda bernilai tinggi </li><li>  Jika sistem ini direncanakan akan dikembangkan secara serius di masa depan </li></ol><br><h3 id="primer-dvoynoy-zapisi">  Contoh entri ganda </h3><br><p>  Gagasan kunci dari double-entry adalah keberadaan akun "buku kas" khusus ( <em>sekitar. Terjemahan: Saya tidak menemukan cara untuk menyebutnya dalam bahasa Rusia, adakah yang bisa memberi tahu saya?</em> ).  Akun ini berisi catatan yang dibuat ketika barang berharga (seperti uang) disimpan atau ditarik dari sistem akuntansi kami.  Dengan demikian, saldo saat ini dari akun ini mencerminkan jumlah total nilai dalam sistem. </p><br><p>  Berikut ini adalah contoh sederhana dengan dua akun, "buku kas" dan "Smith." </p><br><p>  (a) Â£ 300 dimasukkan ke dalam sistem dan disetorkan ke akun Smith.  Pinjaman sebesar Â£ 300 dibuat di akun Smith (kredit di sebelah kanan, debit di sebelah kiri).  Untuk meratakan jumlah ini, debit sebesar Â£ 300 dibuat di akun buku kas. </p><br><p><img src="https://habrastorage.org/webt/wk/ic/px/wkicpxkfio9jnzpj22rujmftpww.gif"></p><br><p>  (B) Smith kemudian menyimpulkan Â£ 50 dari sistem.  Kami membuat debit untuk jumlah ini di akun Smith dan kredit di buku kas. </p><br><p><img src="https://habrastorage.org/webt/ne/ns/c8/nensc8s2cbhjyh9wbpnakjl1dze.gif"></p><br><p>  (c) Tambahkan akun Pattel lain dan transfer 100 Â£ kepadanya dari Smith.  Untuk melakukan ini, kita perlu membuat debit untuk jumlah ini dengan Smith dan pinjaman dengan Pattel. </p><br><p>  (d) Sebagai sentuhan akhir, biarkan Pattel sekarang menarik Â£ 60 dari sistem.  Kami membuat debit di akunnya dan kredit di buku Cash. </p><br><p><img src="https://habrastorage.org/webt/sf/h_/fc/sfh_fcvhtlljtfbssjhysasppdm.gif"></p><br><p>  Sebagai hasil dari semua operasi ini, kita dapat menghitung bahwa total saldo Smith adalah 150 Â£, Pattela 40 Â£, dan dalam Buku Tunai -190 Â£, jumlah negatif dari saldo semua akun lainnya.  Berdasarkan aturan dan operasi sederhana ini di masa mendatang, Anda dapat membangun sistem kontrol nilai yang sangat komprehensif. </p><br><h3 id="model-dannyh">  Model data </h3><br><p>  Struktur model data sederhana yang dapat digunakan untuk mewakili semua informasi ini: </p><br><p><img src="https://habrastorage.org/webt/w7/o8/rr/w7o8rrkhg_ovqkwls1kczhyd0se.gif"></p><br><p>  Tabel POSTING berisi entri ganda sendiri.  Menyimpan semua angka dalam satu tabel sangat menyederhanakan semua perhitungan.  Penghitung yang meningkat secara monoton harus digunakan sebagai kunci utama.  Nilai harus masuk berturut-turut, dalam hal ini, dengan angka Anda selalu dapat memastikan bahwa tidak ada catatan yang telah dihapus.  Tabel BATCH dan JURNAL digunakan untuk mengontrol dan memasukkan data ke dalam tabel POSTING ini. </p><br><p>  Setiap entri dalam tabel JURNAL mewakili transaksi (dari perspektif bisnis) yang menghasilkan entri ganda.  Transaksi semacam itu adalah unit kerja yang selesai atau proses bisnis.  Entah semua catatan POSTING yang terkait dengan catatan JURNAL harus diselesaikan dengan sukses, atau tidak satupun.  Jumlah semua catatan POSTING dalam satu transaksi harus nol.  Setiap operasi transfer dari contoh di atas diwakili oleh entri di tabel JURNAL </p><br><p>  Entri dalam tabel BATCH dibuat untuk kenyamanan entri data.  Ini digunakan untuk mengelompokkan catatan JURNAL ke dalam paket yang mudah digunakan, misalnya, serangkaian cek untuk masuk ke sistem, semacam proses bisnis global, seperti membebankan bunga kepada semua pengguna sekaligus, dll. </p><br><p>  Tabel ACCOUNT menyimpan data pada pemilik nilai dalam sistem. </p><br><p>  Tabel ASSET TYPE berisi informasi tentang jenis nilai yang digunakan dalam sistem.  Dengan menambahkan jenis nilai ke kunci utama dari tabel POSTING, Anda dapat membuat sistem yang beroperasi pada beberapa jenis nilai sekaligus (misalnya, memproses beberapa mata uang). </p><br><p>  Berikut ini cara database tersebut mencari contoh di atas dalam bentuk yang paling sederhana: </p><br><p><img src="https://habrastorage.org/webt/lb/jg/gd/lbjggdyjidzxk9f-kcode7t-63m.png"></p><br><p>  Saldo kolom Jumlah dalam tabel POSTING selalu nol setelah penyelesaian transaksi dari JURNAL (perangkat lunak harus memastikan bahwa tidak ada catatan transaksi tidak lengkap dalam database). </p><br><p>  Jumlah operasi untuk akun Buku Kas memberikan -190, yang sama dengan jumlah saldo Smith dan Pattel dengan tanda kebalikannya. </p><br><p>  Untuk menunjukkan operasi multi-mata uang, jenis nilai baru telah ditambahkan.  Jika Smith ingin menukar 20 pound untuk dolar pada tingkat 1 untuk 1,5, transaksi akan dilakukan melalui Buku Kas dengan cara ini: </p><br><p><img src="https://habrastorage.org/webt/5n/ba/kj/5nbakjfpvja2lvyvujou-zkqjfo.png"></p><br><h3 id="raschetnye-periody">  Periode penagihan </h3><br><p>  Model yang kami peroleh tampak hebat, tetapi dalam kenyataannya akan pecah dengan sangat cepat di bawah beban tinggi karena fakta bahwa kami tidak dapat menghapus apa pun dan dipaksa untuk terus-menerus menceritakan peningkatan jumlah catatan dalam POSTING. </p><br><p>  Sebagian besar sistem akuntansi memiliki konsep periode penagihan - biasanya sebulan, tiga bulan, atau setahun.  Periode seperti itu menunjukkan titik yang nyaman untuk membagi aliran data.  Biasanya titik yang nyaman adalah akhir tahun, kalender atau keuangan. </p><br><p>  Kami dapat menambahkan kolom dengan indikator periode ke tabel POSTING dan ke kunci utamanya, memecah data menjadi kelompok-kelompok yang dapat diproses secara mandiri.  Jika dalam contoh di atas beberapa catatan jatuh pada periode penagihan baru, saldo akun akan diteruskan sebagai berikut. </p><br><p>  Pertama, saldo periode sebelumnya akan dihapus. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4e5/6a8/1b74e56a803a9de9b549c11e34d34dd7.png" alt="gambar"></p><br><p>  Dan kemudian mereka akan dipindahkan ke periode baru </p><br><p><img src="https://habrastorage.org/webt/1w/fo/xv/1wfoxv4wlpwkibojtct8ybgz8bs.png"></p><br><p>  Setelah waktu tertentu, semua catatan pada periode TAHUN 1 dapat dikirim ke arsip dan dihapus dari sistem tanpa kehilangan integritasnya. </p><br><h3 id="agregirovanie-tranzakciy">  Agregasi transaksi </h3><br><p>  Beberapa operasi dalam sistem akuntansi dapat memengaruhi banyak, atau bahkan semua, pengguna sekaligus.  Misalnya, pembayaran bunga untuk semua pengguna dalam bentuk bagian dari saldo mereka saat ini. </p><br><p>  Operasi tersebut dapat diproses sebagai bagian dari satu transaksi tunggal dalam tabel JURNAL dan Anda dapat menggabungkan semua operasi dengan Buku Kas ke dalam satu catatan umum dalam tabel POSTING (alih-alih membuat operasi terpisah untuk setiap akun).  Ini akan memungkinkan Anda untuk mematuhi semua aturan akuntansi di atas dan pada saat yang sama mengurangi separuh jumlah catatan dalam database.  Dengan menggunakan pendekatan ini, akhir tahun dalam database akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/fy/ou/pe/fyoupeludonzc1ar2qdyvzlss0m.png"></p><br><h3 id="paketnaya-obrabotka">  Pemrosesan batch </h3><br><p>  Pemrosesan batch sering digunakan untuk menyederhanakan entri data ke dalam sistem akuntansi. </p><br><p>  Secara historis, pemrosesan cek telah bekerja seperti ini.  Akuntan itu diberi paket sepuluh cek, jumlah paket dan jumlah total semua cek.  Pada tahap pertama, cek dimasukkan ke dalam sistem dalam bentuk entri "tidak sah".  Dalam hal ini, melalui tabel BATCH, jumlah dan jumlah totalnya diperiksa, dan hanya jika mereka cocok dengan nilai yang benar pengguna diizinkan untuk melakukan paket.  Setelah ini selesai, paket dikirim ke karyawan lain yang memeriksa validitasnya dan kemudian "memberi wewenang" jika semuanya dimasukkan dengan benar. </p><br><p>  Proses ini disebut "pembuat / pemeriksa" dan dapat digunakan untuk memasukkan data yang relevan ke dalam sistem. </p><br><p>  Dalam hal ini, catatan "tidak sah" dalam tabel terpisah dari set utama catatan ganda dalam tabel POSTING akan benar.  Anda juga dapat memiliki sejumlah tabel tersebut untuk berbagai proses bisnis.  Sebagai contoh, dalam kasus cek di mana uang dimasukkan atau ditarik dari sistem, akuntan hanya perlu memeriksa satu akun.  Sejak yang kedua, Buku Tunai, dalam operasi seperti itu selalu tersirat secara implisit.  Dalam hal ini, dalam tabel PERIKSA, hanya satu kolom dengan akun yang dapat ditiadakan, sedangkan dalam tabel FUND TRANSFER hipotetis, dua kolom akan diperlukan: "pengirim" dan "penerima". </p><br><p>  Di sinilah kesalahpahaman dasar tentang prinsip-prinsip rekaman ganda muncul.  Kebanyakan orang dalam kehidupan biasa hanya menemukan buku-buku akuntansi kertas sederhana.  Dalam buku kertas semacam itu, misalnya, untuk menghitung keuangan klub minat tertentu, Anda hanya perlu satu entri untuk setiap operasi.  Namun, itu masih memiliki entri ganda implisit, karena selalu ada akun Buku Kas implisit (dalam hal ini, ini adalah klub), karena semua arus kas selalu berupa input (pembayaran biaya oleh peserta) atau penarikan uang dari sistem (pengeluaran klub). </p><br><p>  Alasan kedua untuk kesalahpahaman adalah bahwa dalam laporan akun pribadi, uang yang disimpan dalam akun akan dianggap sebagai "pinjaman", karena seseorang pada dasarnya meminjamkan ke bank yang menerima uangnya.  Meskipun jika orang ini menyimpan buku besarnya, entri ini akan dicatat di dalamnya sebagai "debit" - karena bank berutang uang ini kepada kliennya.  Uang ini ditarik dari "sistem pembayaran" pengguna dan dimasukkan ke dalam sistem bank. </p><br><h3 id="arhitektura-programmnoy-chasti">  Arsitektur Perangkat Lunak </h3><br><p>  Perangkat lunak yang mengimplementasikan sistem akuntansi double-entry seperti itu paling baik dikembangkan menggunakan OOP dan pendekatan berjenjang.  Levelnya adalah sebagai berikut: </p><br><ol><li>  Antarmuka eksternal </li><li>  Logika bisnis </li><li>  Bekerja dengan DB </li></ol><br><p>  Tentu saja, arsitektur sistem akan tergantung pada apa tepatnya yang harus dilakukan sistem ini, namun, kita dapat mengasumsikan kehadiran modul berikut di dalamnya: </p><br><p>  PostEntry: modul yang mengontrol penciptaan entri ganda dalam tabel POSTING.  Dia bertanggung jawab untuk memasukkan catatan, menetapkan ID dan stempel waktu.  Modul tidak dapat menghapus atau mengubah catatan dan tidak ada modul lain yang menghapus atau memodifikasi catatan ini, kecuali untuk penghapusan catatan arsip lama untuk periode penagihan yang sudah tidak relevan.  Tabel POSTING harus hanya-baca untuk semua modul lainnya. </p><br><p>  MakeDeposit, MakeWithdrawal, MakeTransfer: modul-modul ini menerapkan logika bisnis dasar untuk operasi transfer dana.  Mereka akan menggunakan modul PostEntry untuk memasukkan hasilnya ke dalam database. </p><br><p>  ChequeEntry dan ChequeAuthorisation, ReceiveBACS ( <em>catatan: BACS adalah sistem pembayaran antar bank</em> ): modul-modul ini akan menghubungkan sistem dengan dunia luar dan menyediakan antarmuka tingkat tinggi.  Mereka akan menggunakan modul lapisan bisnis untuk melakukan fungsinya.  Dalam hal ini, Anda dapat menjamin pemrosesan yang benar terlepas dari metode entri data, karena baik ChequeEntry dan ReceiveBACS akan bekerja melalui MakeDeposit yang sama </p><br><p>  Metodologi ini untuk memisahkan lapisan dapat diterapkan pada tingkat yang lebih besar atau lebih kecil, tergantung pada kompleksitas sistem dan kemurnian yang diinginkan menggunakan prinsip-prinsip desain objek.  Pada saat yang sama, mungkin masuk akal, misalnya, untuk mengizinkan modul pembuatan laporan (misalnya TestTrialBalance) untuk secara langsung mengakses database dari tingkat antarmuka - alih-alih membuat modul perantara pada lapisan bisnis dan basis data. </p><br><p><img src="https://habrastorage.org/webt/us/s7/yk/uss7ykm8aquutbkj2_jtjp8jrly.gif"></p><br><h3 id="probnyy-balans">  Neraca percobaan </h3><br><p>  "Neraca percobaan" - cara utama untuk memverifikasi integritas sistem akuntansi.  Jika semua entri dimasukkan ke dalam sistem sesuai dengan aturan entri ganda dan tidak ada kesalahan, maka jumlah semua entri harus nol.  Kemungkinan beberapa kesalahan terpisah akan bertambah dan memberikan total nol pada basis yang tidak valid biasanya sangat kecil sehingga diabaikan. </p><br><p>  Cara terbaik untuk memeriksa adalah gerakan yang konsisten dari tingkat atas ke bawah.  Cek masuk akal dalam urutan ini: </p><br><ol><li>  Jumlah dari semua nilai di kolom POSTING.Amount <br>  Jika kesalahan ditemukan (nilainya tidak nol), maka: </li><li>  Jumlah semua nilai POSTING. Jumlah, tetapi dihitung secara terpisah untuk berbagai jenis nilai dan periode penyelesaian <br>  Pada tahap ini, itu harus menjadi lebih jelas di bagian mana dari sistem terjadi kesalahan. </li><li>  Memeriksa masing-masing operasi dalam tabel JURNAL.  Karena jumlah semua POSTING. Akun dalam setiap transaksi dari tabel JURNAL juga harus memberikan nol, maka Anda dapat melacak transaksi bermasalah yang spesifik. </li></ol><br><h3 id="tipy-zapisey-v-journal">  Jenis posting JURNAL </h3><br><p>  Tabel JURNAL berisi representasi sederhana dari entitas, yang bagaimanapun sering terbukti lebih kompleks dan terlibat dalam berbagai hubungan. </p><br><p>  Terkadang masuk akal untuk membagi satu tabel menjadi beberapa tabel.  Misalnya, pada MATERIALIZED dan DEMATERIALIZED, yang mungkin memiliki kumpulan kolom yang berbeda, misalnya, entitas material mungkin memerlukan data di lokasi mereka saat ini. </p><br><p>  Atau, dalam satu tabel, subtipe nilai yang berbeda, seperti mata uang atau sekuritas, dapat disimpan, setiap subtipe dapat memiliki set properti dan atributnya sendiri. </p><br><p>  Entitas yang memiliki sub- dan supertipe dapat diorganisasikan dalam database dengan satu dari empat cara (ini adalah situasi yang cukup standar untuk database apa pun): </p><br><ol><li>  Satu tabel besar umum dengan banyak kolom opsional untuk atribut subtipe </li><li>  Tabel terpisah untuk setiap subtipe, dengan duplikasi semua kolom umum </li><li>  Pisahkan entitas sehingga supertipe disimpan dalam tabel terpisah dan bergabung dengan tabel lain yang hanya berisi kolom subtipe-spesifik </li><li>  Sama seperti pada 3, tetapi dengan duplikasi kolom supertipe dalam tabel subtipe </li></ol><br><p>  Masing-masing dari empat opsi memiliki pro dan kontra.  Dari sudut pandang entri-ganda, penting untuk memiliki tabel bersama untuk entri POSTING.  Opsi 1 lebih cocok untuk sistem akuntansi sederhana (seperti dalam contoh dalam artikel ini, di mana satu-satunya perbedaan dalam jenis nilai ditentukan oleh kolom JURNAL. Jenis).  Opsi 3 mungkin lebih cocok untuk sistem kompleks yang bekerja dengan berbagai nilai yang sangat berbeda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480394/">https://habr.com/ru/post/id480394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480378/index.html">14 proyek sumber terbuka untuk memompa keterampilan Ilmu Data (mudah, normal, sulit)</a></li>
<li><a href="../id480386/index.html">Auto-backup peralatan jaringan dan penyimpanannya dalam sistem kontrol versi</a></li>
<li><a href="../id480388/index.html">Konferensi HACKTIVITY 2012. Teori Big Bang: Evolusi Pentesting dalam Peningkatan Keamanan. Bagian 1</a></li>
<li><a href="../id480390/index.html">ONYX BOOX Livingstone - pembaca format populer dalam desain yang tidak biasa</a></li>
<li><a href="../id480392/index.html">Konferensi HACKTIVITY 2012. Teori Big Bang: Evolusi Pentesting dalam Peningkatan Keamanan. Bagian 2</a></li>
<li><a href="../id480396/index.html">Kami membuat aplikasi desktop asli lintas platform di Angular</a></li>
<li><a href="../id480398/index.html">9 tips JavaScript yang sangat berguna</a></li>
<li><a href="../id480400/index.html">Apakah Kubernetes Linux baru? Wawancara dengan Pavel Selivanov</a></li>
<li><a href="../id480402/index.html">Bagaimana pÌ¶Ğµ AndroidÑ€ TĞ²Ì¶Ñ‹Ì¶Ğ¹Ì¶ mitap Android kedua dari Tinkoff</a></li>
<li><a href="../id480404/index.html">Mikrotik dan Linux. Rutin dan Otomasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>