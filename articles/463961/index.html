<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêµ üôèüèø ‚èØÔ∏è Mapeador propio o un poco sobre ExpressionTrees üëàüèæ üåù ‚è´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy hablaremos sobre c√≥mo escribir su AutoMapper . S√≠, realmente me gustar√≠a contarte sobre esto, pero no puedo. El hecho es que tales soluciones son ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapeador propio o un poco sobre ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="imagen"><br><br>  Hoy hablaremos sobre c√≥mo escribir su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AutoMapper</a> .  S√≠, realmente me gustar√≠a contarte sobre esto, pero no puedo.  El hecho es que tales soluciones son muy grandes, tienen un historial de prueba y error, y tambi√©n han recorrido un largo camino hacia la aplicaci√≥n.  Solo puedo dar una comprensi√≥n de c√≥mo funciona esto, dar un punto de partida para aquellos que deseen comprender el mecanismo de trabajo de los "mapeadores".  Incluso se podr√≠a decir que escribiremos nuestra bicicleta. <br><a name="habracut"></a><br><h3>  Descargo de responsabilidad </h3><br>  Te recuerdo una vez m√°s: escribiremos un mapeador primitivo.  Si de repente decide modificarlo y usarlo en el producto, no lo haga.  Tome una soluci√≥n preparada que conozca la pila de problemas en esta √°rea tem√°tica y <i>ya sepa c√≥mo</i> resolverlos.  Hay varias razones m√°s o menos significativas para escribir y usar su mapeador de bicicletas: <br><br><ul><li>  Necesita alguna personalizaci√≥n especial. </li><li> Necesita el m√°ximo rendimiento en sus condiciones y est√° listo para llenar conos. </li><li>  Desea comprender c√≥mo funciona el mapeador. </li><li>  Simplemente te gusta andar en bicicleta. </li></ul><br><h3>  ¬øQu√© se llama la palabra "mapeador"? </h3><br>  Este es el subsistema responsable de tomar un objeto y convertirlo (copiar sus valores) a otro.  Una tarea t√≠pica es convertir un DTO en un objeto de capa empresarial.  El mapeador m√°s primitivo "corre" a trav√©s de las propiedades del origen de datos y las compara con las propiedades del tipo de datos que se generar√°n.  Despu√©s de la coincidencia, los valores se extraen de la fuente y se escriben en el objeto, que ser√° el resultado de la conversi√≥n.  En alg√∫n punto del camino, lo m√°s probable es que a√∫n sea necesario crear este mismo "resultado". <br><br>  Para el consumidor, mapper es un servicio que proporciona la siguiente interfaz: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Destaco: esta es la interfaz m√°s primitiva, que, desde mi punto de vista, es conveniente para la explicaci√≥n.  En realidad, probablemente trataremos con un mapeador m√°s espec√≠fico (IMapper &lt;TIn, TOut&gt;) o con una fachada m√°s general (IMapper), que seleccionar√° un mapeador espec√≠fico para los tipos especificados de objetos de entrada-salida. <br><br><h3>  Implementaci√≥n ingenua </h3><br>  Nota: incluso la implementaci√≥n ingenua de mapper requiere conocimientos b√°sicos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflection</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExpressionTrees</a> .  Si no ha seguido los enlaces o no ha escuchado nada sobre estas tecnolog√≠as, h√°galo, l√©alo.  Prometo que el mundo nunca ser√° igual. <br><br>  Sin embargo, estamos escribiendo su propio mapeador.  Para comenzar, obtengamos todas las propiedades ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PropertyInfo</a> ) del tipo de datos que se generar√°n (en adelante, lo llamar√© <b>TOut</b> ).  Esto es bastante simple: conocemos el tipo, ya que estamos escribiendo la implementaci√≥n de una clase gen√©rica parametrizada con el tipo TOut.  Luego, usando una instancia de la clase Type, obtenemos todas sus propiedades. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Al obtener propiedades, omito las caracter√≠sticas.  Por ejemplo, algunos de ellos pueden estar sin una funci√≥n de establecimiento, algunos pueden estar marcados como ignorados por el atributo, algunos pueden tener acceso especial.  Estamos considerando la opci√≥n m√°s simple. <br><br>  Vamos m√°s all√°  Ser√≠a bueno poder crear una instancia de tipo TOut, es decir, el mismo objeto en el que "mapeamos" el objeto entrante.  En C #, hay varias formas de hacer esto.  Por ejemplo, podemos hacer esto: System.Activator.CreateInstance ().  O incluso solo un nuevo TOut (), pero para esto necesita crear una restricci√≥n para TOut, que no querr√≠a hacer en la interfaz generalizada.  Sin embargo, ambos sabemos algo sobre ExpressionTrees, lo que significa que podemos hacerlo as√≠: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Por qu√©  Debido a que sabemos que una instancia de la clase Type puede proporcionar informaci√≥n sobre los constructores que tiene, esto es muy conveniente para los casos en que decidimos desarrollar nuestro mapeador para pasarle cualquier dato al constructor.  Adem√°s, aprendimos un poco m√°s sobre ExpressionTrees, es decir, permiten que la placa cree y compile c√≥digo, que luego se puede reutilizar.  En este caso, es una funci√≥n que realmente se parece a () =&gt; new TOut (). <br><br>  Ahora necesita escribir el m√©todo principal del mapeador, que copiar√° los valores.  Seguiremos el camino m√°s simple: revise las propiedades del objeto que nos lleg√≥ en la entrada y busque las propiedades con el mismo nombre entre las propiedades del objeto saliente.  Si se encuentra, copie, si no, contin√∫e. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Por lo tanto, hemos formado completamente la clase <a href="">BasicMapper</a> .  Puedes familiarizarte con sus pruebas <a href="">aqu√≠</a> .  Tenga en cuenta que la fuente puede ser un objeto de cualquier tipo en particular o un objeto an√≥nimo. <br><br><h3>  Rendimiento y boxeo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La reflexi√≥n es</a> genial, pero lenta.  Adem√°s, su uso frecuente aumenta el tr√°fico de memoria, lo que significa que carga el GC, lo que significa que ralentiza la aplicaci√≥n a√∫n m√°s.  Por ejemplo, acabamos de utilizar los m√©todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PropertyInfo.SetValue</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PropertyInfo.GetValue</a> .  El m√©todo GetValue devuelve un objeto en el que se ajusta un cierto valor (boxeo).  Esto significa que recibimos una asignaci√≥n desde cero. <br><br>  Los mapeadores generalmente se encuentran donde necesitas convertir un objeto en otro ... No, no uno, sino muchos objetos.  Por ejemplo, cuando tomamos algo de la base de datos.  En este lugar, me gustar√≠a ver un rendimiento normal y no perder memoria en una operaci√≥n primaria. <br><br>  Que podemos hacer  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExpressionTrees</a> nos ayudar√° de nuevo.  El hecho es que .NET le permite crear y compilar c√≥digo "sobre la marcha": lo describimos en la representaci√≥n de objetos, decimos qu√© y d√≥nde lo usaremos ... y lo compilamos.  Casi no hay magia. <br><br><h3>  Mapeador compilado </h3><br>  De hecho, todo es relativamente simple: ya hicimos nuevo con Expression.New (ConstructorInfo).  Probablemente haya notado que el nuevo m√©todo est√°tico se llama exactamente igual que el operador.  El hecho es que casi toda la sintaxis de C # se refleja en forma de m√©todos est√°ticos de la clase Expression.  Si falta algo, significa que est√° buscando el llamado  "Az√∫car sint√°ctico". <br><br>  Aqu√≠ hay algunas operaciones que usaremos en nuestro mapeador: <br><br><ul><li>  Declaraci√≥n de variables: expresi√≥n.Variable (tipo, cadena).  El argumento Tipo indica qu√© tipo de variable se crear√°, y cadena es el nombre de la variable. </li><li>  Asignaci√≥n - Expression.Assign (Expression, Expression).  El primer argumento es lo que asignamos, y el segundo argumento es lo que asignamos. </li><li>  El acceso a la propiedad de un objeto es Expression.Property (Expression, PropertyInfo).  Expression es el propietario de la propiedad, y PropertyInfo es la representaci√≥n del objeto de la propiedad obtenida a trav√©s de Reflection. </li></ul><br>  Con este conocimiento, podemos crear variables, acceder a las propiedades de los objetos y asignar valores a las propiedades de los objetos.  Lo m√°s probable es que tambi√©n comprendamos que ExpressionTree debe compilarse en un delegado de la forma <b>Func &lt;object, TOut&gt;</b> .  El plan es este: obtenemos una variable que contiene los datos de entrada, creamos una instancia de tipo TOut y creamos expresiones que asignan una propiedad a otra. <br><br>  Desafortunadamente, el c√≥digo no es muy compacto, por lo que le sugiero que eche un vistazo a la implementaci√≥n de <a href="">CompiledMapper de</a> inmediato.  Traje aqu√≠ solo puntos clave. <br><br>  Primero, creamos una representaci√≥n de objeto del par√°metro de nuestra funci√≥n.  Como toma un objeto como entrada, el objeto ser√° un par√°metro. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  A continuaci√≥n, creamos dos variables y una lista de expresiones en la que agregaremos secuencialmente expresiones de asignaci√≥n.  El orden es importante, porque as√≠ es como se ejecutar√°n los comandos cuando llamamos al m√©todo compilado.  Por ejemplo, no podemos asignar un valor a una variable que a√∫n no se ha declarado. <br><br>  Adem√°s, de la misma manera que en el caso de la implementaci√≥n ingenua, revisamos la lista de propiedades de tipo e intentamos unirlas por nombre.  Sin embargo, en lugar de asignar valores inmediatamente, creamos expresiones para extraer valores y asignar valores para cada propiedad asociada. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Un punto importante: despu√©s de haber creado todas las operaciones de asignaci√≥n, debemos devolver el resultado de la funci√≥n.  Para hacer esto, la √∫ltima expresi√≥n en la lista debe ser Expresi√≥n, que contiene la instancia de la clase que creamos.  Dej√© un comentario al lado de esta l√≠nea.  ¬øPor qu√© el comportamiento correspondiente a la palabra clave return en ExpressionTree se ve as√≠?  Me temo que este es un tema aparte.  Ahora sugiero que sea f√°cil de recordar. <br><br>  Bueno, al final, tenemos que compilar todas las expresiones que construimos.  ¬øQu√© nos interesa aqu√≠?  La variable cuerpo contiene el "cuerpo" de la funci√≥n.  Las "funciones normales" tienen un cuerpo, ¬øverdad?  Bueno, lo encerramos entre llaves.  Entonces, Expression.Block es exactamente eso.  Dado que las llaves tambi√©n son un alcance, debemos pasar all√≠ las variables que se utilizar√°n all√≠, en nuestro caso sourceInstance y outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  En la salida, obtenemos Func &lt;objeto, TOut&gt;, es decir  Una funci√≥n que puede convertir datos de un objeto a otro.  ¬øPor qu√© tantas dificultades, preguntas?  Le recuerdo que, en primer lugar, quer√≠amos evitar el boxeo al copiar valores ValueType, y en segundo lugar, quer√≠amos abandonar los m√©todos PropertyInfo.GetValue y PropertyInfo.SetValue, ya que son algo lentos. <br><br>  ¬øPor qu√© no boxear?  Debido a que el ExpressionTree compilado es un IL real, y para el tiempo de ejecuci√≥n, se parece (casi) a su c√≥digo.  ¬øPor qu√© el "mapeador compilado" es m√°s r√°pido?  De nuevo: porque es simplemente IL.  Por cierto, podemos confirmar f√°cilmente la velocidad utilizando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BenchmarkDotNet</a> , y el punto de referencia en s√≠ se puede ver <a href="">aqu√≠</a> . <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th><th>  Asignado </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1,291.6 us </td><td>  3.3173 nosotros </td><td>  3.1030 nosotros </td><td>  1.00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11,987.0 us </td><td>  33.8389 nosotros </td><td>  28.2570 us </td><td>  9.28 </td><td>  3437,5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341.3 nosotros </td><td>  2.8230 nosotros </td><td>  2.6407 nosotros </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  En la columna Ratio, el "mapeador compilado" (CompiledMapper) mostr√≥ un resultado muy bueno, incluso en comparaci√≥n con AutoMapper (es la l√≠nea de base, es decir, 1).  Sin embargo, no nos regocijemos: AutoMapper tiene capacidades significativamente mayores en comparaci√≥n con nuestra bicicleta.  Con esta placa solo quer√≠a mostrar que ExpressionTrees es mucho m√°s r√°pido que el "enfoque cl√°sico de reflexi√≥n". <br><br><h3>  Resumen </h3><br>  Espero haber podido demostrar que escribir su mapeador es bastante simple.  Reflection and ExpressionTrees son herramientas muy poderosas que los desarrolladores usan para resolver muchas tareas diferentes.  Inyecci√≥n de dependencias, serializaci√≥n / deserializaci√≥n, repositorios CRUD, creaci√≥n de consultas SQL, uso de otros lenguajes como scripts para aplicaciones .NET: todo esto se realiza mediante Reflection, Reflection.Emit y ExpressionTrees. <br><br>  ¬øQu√© pasa con el mapeador?  Mapper es un gran ejemplo donde puedes aprender todo esto. <br><br>  PD: Si quisieras m√°s ExpressionTrees, te sugiero leer sobre c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacer tu convertidor JSON</a> usando esta tecnolog√≠a. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/463961/">https://habr.com/ru/post/463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../463943/index.html">Las desventuras del unicornio negro</a></li>
<li><a href="../463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../463953/index.html">Implementaci√≥n del patr√≥n de dise√±o de comandos en Unity</a></li>
<li><a href="../463955/index.html">¬øC√≥mo desarrollar un concepto para cambiar la plataforma IP? Instrucciones de uso</a></li>
<li><a href="../463957/index.html">C√≥mo implementar una lista de entrevistas enlazadas individualmente</a></li>
<li><a href="../463963/index.html">Reconocimiento facial en un sitio de construcci√≥n</a></li>
<li><a href="../463965/index.html">Aplicaci√≥n de composici√≥n tipogr√°fica en LaTeX</a></li>
<li><a href="../463969/index.html">Presupuesto familiar de Telegram</a></li>
<li><a href="../463971/index.html">Notas de Pentester: Casos de caza</a></li>
<li><a href="../463975/index.html">Entorno moderno para reaccionar aplicaciones nativas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>