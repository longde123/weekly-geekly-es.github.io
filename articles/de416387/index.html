<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶å üôÇ üöµüèΩ Shrimp: Skalieren und teilen Sie HTTP-Bilder in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio ü¶Ç üë®‚Äçüî¨ üëµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 Unser kleines Team entwickelt zwei OpenSource-Tools f√ºr C ++ - Entwickler - das SObjectizer- Actor-Framework und den eingebetteten RESTinio-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shrimp: Skalieren und teilen Sie HTTP-Bilder in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416387/"><img src="https://habrastorage.org/webt/c8/es/x7/c8esx7a-blzv0brvoyng2drgdeq.jpeg"><br><br><h1>  Vorwort </h1><br>  Unser kleines Team entwickelt zwei OpenSource-Tools f√ºr C ++ - Entwickler - das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer-</a> Actor-Framework und den eingebetteten RESTinio-HTTP-Server.  Wir sto√üen jedoch regelm√§√üig auf einige nicht triviale Fragen: <br><br><ul><li>  Welche Funktionen m√ºssen der Bibliothek hinzugef√ºgt werden und welche m√ºssen √ºber Bord gelassen werden? </li><li>  Wie kann man die "ideologisch korrekten" Arten der Nutzung der Bibliothek klar demonstrieren? </li></ul><br>  Es ist gut, wenn die Antworten auf solche Fragen w√§hrend der Verwendung unserer Entwicklungen in realen Projekten erscheinen, wenn Entwickler mit ihren Beschwerden oder ihrer Wunschliste zu uns kommen.  Aufgrund der Befriedigung der Benutzerw√ºnsche f√ºllen wir unsere Tools mit Funktionen, die vom Leben selbst vorgegeben werden und nicht ‚Äûaus dem Finger gesaugt‚Äú werden. <br><br>  Die Informationen erreichen uns jedoch weit entfernt von allen Problemen und Schwierigkeiten, mit denen Benutzer konfrontiert sind.  Und wir k√∂nnen die erhaltenen Informationen und insbesondere die Codebeispiele nicht immer in unseren √∂ffentlichen Materialien verwenden. <br><br>  Daher denken wir uns manchmal kleine Probleme aus und l√∂sen diese, die wir von Entwicklern von Tools zu Benutzern machen m√ºssen.  Dies erm√∂glicht es uns, unsere eigenen Werkzeuge mit anderen Augen zu betrachten und selbst zu verstehen, was gut ist, was nicht gut ist, was fehlt und was zu viel ist. <br><br>  Heute wollen wir nur eine solche "kleine" Aufgabe erz√§hlen, bei der SObjectizer und RESTinio nat√ºrlich zusammengekommen sind. <br><br><h1>  Skalierung und Verteilung von Bildern.  Warum genau das? </h1><br>  Als kleine Demo-Aufgabe haben wir uns f√ºr einen HTTP-Server entschieden, der auf Anfrage skalierte Bilder verteilt.  Sie legen die Bilder in einem Verzeichnis ab, starten den HTTP-Server und fordern das Formular an: <br><a name="habracut"></a><br><pre><code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  und im Gegenzug erhalten Sie ein Bild, das auf der langen Seite auf 1920 Pixel skaliert ist. <br><br>  Die Wahl fiel auf diese Aufgabe, da sie die Szenarien perfekt demonstriert, f√ºr die wir einmal mit der Entwicklung von RESTinio begonnen haben: In C oder C ++ gibt es einen lang laufenden und debuggten Code, an den Sie eine HTTP-Eingabe anh√§ngen und auf eingehende Anforderungen reagieren m√ºssen.  Gleichzeitig, was wichtig ist, kann die Anwendungsverarbeitung der Anforderung betr√§chtliche Zeit in Anspruch nehmen, und daher ist es unrentabel, den Anwendungscode direkt im E / A-Kontext abzurufen.  Der HTTP-Server sollte asynchron sein: Akzeptieren und analysieren Sie die HTTP-Anforderung, geben Sie die analysierte Anforderung irgendwo f√ºr die weitere Anwendungsverarbeitung, fahren Sie mit der Bearbeitung der n√§chsten HTTP-Anforderung fort und kehren Sie zur R√ºckgabe der Antwort auf die HTTP-Anforderung zur√ºck, wenn diese Antwort von jemandem vorbereitet wurde. <br><br>  Genau dies geschieht bei der Verarbeitung von Anforderungen zum Skalieren von Bildern.  Ein HTTP-Server kann seine direkte Arbeit (d. H. Lesen von Daten, Analysieren einer HTTP-Anforderung) in einem Bruchteil einer Millisekunde ausf√ºhren.  Das Skalieren eines Bildes kann jedoch zehn, Hunderte oder sogar Tausende von Millisekunden dauern. <br><br>  Und da das Skalieren eines Bildes viel Zeit in Anspruch nehmen kann, m√ºssen Sie sicherstellen, dass der HTTP-Server w√§hrend der Skalierung des Bildes weiterarbeiten kann.  Dazu m√ºssen wir die Arbeit des HTTP-Servers verteilen und Bilder auf verschiedene Arbeitskontexte skalieren.  Im einfachen Fall handelt es sich dabei um unterschiedliche Arbeitsthreads.  Nun, da wir in Multi-Core-Prozessoren leben, werden wir mehrere Arbeitsthreads haben.  Einige von ihnen bedienen HTTP-Anfragen, andere arbeiten mit Bildern. <br><br>  Es stellt sich heraus, dass wir zum Verteilen skalierbarer Bilder √ºber HTTP den lang geschriebenen, funktionierenden C / C ++ - Code (in diesem Fall ImageMagic ++) wiederverwenden, HTTP-Anforderungen asynchron bedienen und die Anwendungsverarbeitung von Anforderungen in mehreren Workflows durchf√ºhren m√ºssen.  Eine hervorragende Aufgabe f√ºr RESTinio und SObjectizer, wie es uns schien. <br><br>  Und wir haben beschlossen, unser Demo-Projekt Shrimp zu nennen. <br><br><h1>  Shrimps wie es ist </h1><br><h2>  Was macht Shrimp? </h2><br>  Shrimp wird als Konsolenanwendung ausgef√ºhrt, √∂ffnet und √ºberwacht den angegebenen Port, empf√§ngt und verarbeitet HTTP-GET-Anforderungen des Formulars: <br><br><pre> <code class="hljs xml">/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span> /<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span>?op=resize&amp;<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">side</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Wo: <br><br><ul><li>  Bild ist der Name der zu skalierenden Bilddatei.  Zum Beispiel my_picture oder DSCF0069; </li><li>  ext ist eine der von Shrimps unterst√ºtzten Erweiterungen (jpg, jpeg, png oder gif); </li><li>  Seite ist eine Angabe der Seite, f√ºr die die Gr√∂√üe eingestellt ist.  Es kann entweder einen Breitenwert haben. In diesem Fall wird das Bild so skaliert, dass die resultierende Breite dem angegebenen Wert entspricht. Die H√∂he des Bildes wird automatisch ausgew√§hlt, w√§hrend das Seitenverh√§ltnis beibehalten wird.  Oder der Wert der H√∂he, in diesem Fall erfolgt die Skalierung in der H√∂he.  Entweder max, in diesem Fall ist die lange Seite begrenzt, und Garnelen selbst bestimmen, ob die lange Seite H√∂he oder Breite hat; </li><li>  value ist die Gr√∂√üe, bei der die Skalierung erfolgt. </li></ul><br>  Wenn in der URL nur der Dateiname angegeben ist, ohne dass die Gr√∂√üe ge√§ndert werden muss, gibt shrimp in der Antwort einfach das Originalbild zur√ºck.  Wenn der Gr√∂√üen√§nderungsvorgang angegeben ist, √§ndert Shrimp die Gr√∂√üe des angeforderten Bildes und gibt die skalierte Version an. <br><br>  Gleichzeitig speichert Shrimps einen Cache mit skalierten Bildern im Speicher.  Wenn ein Bild wiederholt mit denselben Gr√∂√üen√§nderungsparametern angefordert wird, die sich bereits im Cache befinden, wird der Wert aus dem Cache zur√ºckgegeben.  Befindet sich kein Bild im Cache, wird das Bild von der Festplatte gelesen, skaliert, im Cache gespeichert und als Antwort zur√ºckgegeben. <br><br>  Der Cache wird regelm√§√üig geleert.  Bilder, die seit dem letzten Zugriff mehr als eine Stunde im Cache gelebt haben, werden aus dem Cache verschoben.  Au√üerdem werden die √§ltesten Bilder aus dem Cache geworfen, wenn der Cache seine maximale Gr√∂√üe √ºberschreitet (in einem Demo-Projekt sind es 100 MB). <br><br>  Wir haben eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> vorbereitet, auf der jeder mit Garnelen experimentieren kann: <br><br><img src="https://habrastorage.org/webt/uv/vr/-q/uvvr-qtt1xovbi_k-ieoyrpvq-y.jpeg"><br><br>  Auf dieser Seite k√∂nnen Sie die Bildgr√∂√üe einstellen und auf "Gr√∂√üe √§ndern" klicken.  Zwei Anfragen werden mit denselben Parametern an den Shrimp-Server gesendet.  H√∂chstwahrscheinlich ist die erste Anforderung eindeutig (d. H. Es gibt noch keinen Cache mit solchen Gr√∂√üen√§nderungsparametern im Cache), sodass die erste Anforderung einige Zeit ben√∂tigt, um das Bild tats√§chlich zu skalieren.  Und die zweite Anforderung findet h√∂chstwahrscheinlich das bereits skalierte Bild im Cache und gibt es sofort weiter. <br><br>  Es kann beurteilt werden, ob ein Bild aus dem Cache stammt oder ob es wirklich durch den Text unter dem Bild skaliert wurde.  Der Text ‚ÄûTransformiert (114,0 ms)‚Äú zeigt beispielsweise an, dass das Bild skaliert wurde und der Zoomvorgang 114 Millisekunden dauerte. <br><br><h2>  Wie macht Shrimp das? </h2><br>  Shrimp ist eine Multithread-Anwendung, die drei Gruppen von Arbeitsthreads ausf√ºhrt: <br><br><ol><li>  Der Pool von Arbeitsthreads, auf denen der HTTP-Server ausgef√ºhrt wird.  In diesem Pool werden neue Verbindungen bereitgestellt, eingehende Anforderungen empfangen und analysiert, Antworten generiert und gesendet.  Der HTTP-Server wird √ºber die RESTinio-Bibliothek implementiert. </li><li>  Ein separater Arbeitsthread, auf dem der SObjectizer-Agent transform_manager ausgef√ºhrt wird.  Dieser Agent verarbeitet vom HTTP-Server empfangene Anforderungen und verwaltet einen Cache mit skalierten Bildern. </li><li>  Der Thread-Pool, in dem SObjectizer-Agenten Transformatoren arbeiten.  Sie f√ºhren die eigentliche Skalierung von Bildern mit ImageMagic ++ durch. </li></ol><br>  Es stellt sich folgendes Arbeitsschema heraus: <br><br><img src="https://habrastorage.org/webt/ns/ov/sj/nsovsjushv0zxasu_cq3ur0dy6m.png"><br><br>  Der HTTP-Server akzeptiert die eingehende Anforderung, analysiert sie und √ºberpr√ºft die Richtigkeit.  Wenn f√ºr diese Anforderung kein Gr√∂√üen√§nderungsvorgang erforderlich ist, verarbeitet der HTTP-Server selbst die Anforderung √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sendedateivorgang</a> .  Wenn f√ºr die Anforderung eine Gr√∂√üen√§nderungsoperation erforderlich ist, wird die Anforderung asynchron an den transform_manager-Agenten gesendet. <br><br>  Der transform_manager-Agent empf√§ngt Anforderungen vom HTTP-Server und pr√ºft, ob bereits skalierte Bilder im Cache vorhanden sind.  Befindet sich ein Bild im Cache, generiert transform_manager sofort eine Antwort f√ºr den HTTP-Server.  Wenn kein Bild vorhanden ist, sendet transform_manager eine Anforderung zum Skalieren des Bildes an einen der Transformatoragenten.  Wenn das Skalierungsergebnis vom Transformator stammt, wird das Ergebnis im Cache gespeichert und eine Antwort f√ºr den HTTP-Server generiert. <br><br>  Der Transformator-Agent empf√§ngt Anforderungen von transform_manager, verarbeitet sie und gibt das Ergebnis der Transformation an den transform_manager-Agenten zur√ºck. <br><br><h2>  Was hat Shrimp unter der Haube? </h2><br>  Der in diesem Artikel beschriebene Quellcode f√ºr die minimalste Version von Shrimps befindet sich in diesem Repository: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp-Demo auf BitBucket</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> . <br><br>  Es gibt viel Code, obwohl der Code in dieser Version von Shrimps gr√∂√ütenteils ziemlich trivial ist.  Es ist jedoch sinnvoll, sich auf einige Aspekte der Implementierung zu konzentrieren. <br><br><h3>  Verwenden von C ++ 17 und den neuesten Compilerversionen </h3><br>  Bei der Implementierung von Shrimp haben wir uns f√ºr C ++ 17 und die neuesten Versionen von Compilern entschieden, insbesondere GCC 7.3 und 8.1.  Das Projekt ist stark forschend.  Daher ist die praktische Bekanntschaft von C ++ 17 im Rahmen eines solchen Projekts nat√ºrlich und zul√§ssig.  W√§hrend wir uns in allt√§glicheren Entwicklungen hier und jetzt auf praktische industrielle Anwendungen konzentrieren, m√ºssen wir auf ziemlich alte Compiler zur√ºckblicken und vielleicht C ++ 14 oder sogar nur eine Teilmenge von C ++ 11 verwenden. <br><br>  Ich muss sagen, dass C ++ 17 einen guten Eindruck macht.  Es scheint, dass wir nicht so viele Innovationen aus dem siebzehnten Standard im Shrimp-Code verwendet haben, aber sie hatten einen positiven Effekt: das Attribut [[nodiscard]], std :: optional / std :: variante / std :: filesystem direkt ‚Äú out of the box ‚Äúund nicht aufgrund externer Abh√§ngigkeiten, strukturierte Bindung, wenn constexpr, die F√§higkeit, Besucher f√ºr Lambdas f√ºr std :: visit zusammenzustellen ... Individuell sind dies alles Kleinigkeiten, aber zusammen erzeugen sie einen starken kumulativen Effekt. <br><br>  Das erste n√ºtzliche Ergebnis, das wir bei der Entwicklung von Shrimps erhalten haben: C ++ 17 ist es wert, darauf umzusteigen. <br><br><h3>  HTTP-Server mit RESTinio-Tools </h3><br>  Der vielleicht einfachste Teil von Shrimps war der HTTP-Server und der HTTP-GET-Anforderungshandler ( <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.hpp</a> und <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.cpp</a> ). <br><br><h4>  Eingehende Anfragen empfangen und versenden </h4><br>  Im Wesentlichen konzentriert sich die gesamte Grundlogik des Shrimp-HTTP-Servers auf diese Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_transform_op_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">app_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; app_params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_get( <span class="hljs-string"><span class="hljs-string">R"(/:path(.*)\.:ext(.{3,4}))"</span></span>, restinio::path2regex::<span class="hljs-keyword"><span class="hljs-keyword">options_t</span></span>{}.strict( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ), [req_handler_mbox, &amp;app_params]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;header().path() ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> opt_image_format = image_format_from_extension( params[ <span class="hljs-string"><span class="hljs-string">"ext"</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !opt_image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().query().empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ), *opt_image_format ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">"resize"</span></span> != restinio::value_or( qp, <span class="hljs-string"><span class="hljs-string">"op"</span></span>sv, <span class="hljs-string"><span class="hljs-string">""</span></span>sv ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } handle_resize_op_request( req_handler_mbox, *opt_image_format, qp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Diese Funktion bereitet den HTTP-GET-Anforderungshandler mithilfe des RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressJS-Routers vor</a> .  Wenn der HTTP-Server eine GET-Anforderung empf√§ngt, deren URL unter den angegebenen regul√§ren Ausdruck f√§llt, wird die angegebene Lambda-Funktion aufgerufen. <br><br>  Diese Lambda-Funktion f√ºhrt einige einfache √úberpr√ºfungen der Richtigkeit der Anforderung durch. Im Wesentlichen handelt es sich jedoch um eine einfache Auswahl: Wenn die Gr√∂√üen√§nderung nicht festgelegt ist, wird das angeforderte Bild in seiner urspr√ºnglichen Form mithilfe einer effektiven System-Sendedatei zur√ºckgegeben.  Wenn der Gr√∂√üen√§nderungsmodus festgelegt ist, wird eine Nachricht generiert und an den transform_manager-Agenten gesendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_resize_op_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; req_handler_mbox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_string_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; qp, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ try_to_handle_request( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> op_params = transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span>::make( restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"width"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"height"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) ); transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_constraints_t</span></span>{}.check( op_params ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image_path{ req-&gt;header().path() }; so_5::send&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt;&gt;( req_handler_mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image_path), image_format, op_params ); }, req ); }</code> </pre> <br>  Es stellt sich heraus, dass der HTTP-Server, nachdem er die Gr√∂√üen√§nderungsanforderung akzeptiert hat, sie √ºber eine asynchrone Nachricht an den transform_manager-Agenten weiterleitet und weiterhin andere Anforderungen bearbeitet. <br><br><h4>  Dateifreigabe mit sendfile </h4><br>  Wenn der HTTP-Server eine Anforderung f√ºr das Originalbild ohne den Gr√∂√üen√§nderungsvorgang erkennt, sendet der Server dieses Bild sofort √ºber den Sendedateivorgang.  Der damit verbundene Hauptcode lautet wie folgt (der vollst√§ndige Code f√ºr diese Funktion befindet sich <a href="">im Repository</a> ): <br><br><pre> <code class="cpp hljs">[[nodiscard]] restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handling_status_t</span></span> serve_as_regular_file( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; root_dir, restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> full_path = make_full_path( root_dir, req-&gt;header().path() ); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sf = restinio::sendfile( full_path ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_common_header_fields_for_image_resp( file_stat.st_mtim.tv_sec, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( image_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( http_header::<span class="hljs-keyword"><span class="hljs-keyword">image_src_t</span></span>::sendfile ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( sf ) ) .done(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); }</code> </pre> <br>  Der entscheidende Punkt hierbei ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">restinio :: sendfile () aufzurufen</a> und dann den von dieser Funktion zur√ºckgegebenen Wert an set_body () zu √ºbergeben. <br><br>  Die Funktion restinio :: sendfile () erstellt einen Datei-Upload-Vorgang mithilfe der System-API.  Wenn diese Operation an set_body () √ºbergeben wird, versteht RESTinio, dass der Inhalt der in restinio :: sendfile () angegebenen Datei f√ºr den Hauptteil der HTTP-Antwort verwendet wird.  Anschlie√üend wird der Inhalt dieser Datei mithilfe der System-API in den TCP-Socket geschrieben. <br><br><h3>  Implementieren des Image-Cache </h3><br>  Der transform_manager-Agent speichert den Cache konvertierter Bilder, in dem die Bilder nach der Skalierung platziert werden.  Dieser Cache ist ein einfacher selbst erstellter Container, der auf zwei Arten Zugriff auf seinen Inhalt bietet: <br><br><ol><li>  Durch Suchen nach einem Element per Schl√ºssel (√§hnlich wie dies in den Standardcontainern std :: map und std :: unordered_map geschieht). </li><li>  Durch Zugriff auf das √§lteste Cache-Element. </li></ol><br>  Die erste Zugriffsmethode wird verwendet, wenn die Verf√ºgbarkeit des Bildes im Cache √ºberpr√ºft werden muss.  Das zweite ist, wenn wir die √§ltesten Bilder aus dem Cache l√∂schen. <br><br>  Wir haben nicht begonnen, im Internet nach etwas zu suchen, das f√ºr diese Zwecke bereit ist.  Wahrscheinlich w√§re Boost.MultiIndex hier durchaus geeignet.  Aber ich wollte Boost nicht nur wegen MultiIndex ziehen, also haben wir <a href="">unsere triviale Implementierung</a> buchst√§blich auf meinen Knien gemacht.  Es scheint zu funktionieren;) <br><br><h3>  Warteschlange ausstehender Anforderungen in transform_manager </h3><br>  Der transform_manager-Agent <a href="">erwies sich</a> trotz seiner recht anst√§ndigen Gr√∂√üe (eine <a href="">HPP-Datei mit</a> ca. 250 Zeilen und eine <a href="">CPP-Datei mit</a> ca. 270 Zeilen) in unserer einfachsten Implementierung von Shrimp unserer Meinung nach als eher trivial. <br><br>  Eines der Dinge, die einen wesentlichen Beitrag zur Komplexit√§t und Menge des Agentencodes leisten, ist das Vorhandensein nicht nur eines Caches transformierter Bilder in transform_manager, sondern auch von Warteschlangen ausstehender Anforderungen. <br><br>  Wir haben eine begrenzte Anzahl von Transformatoragenten (im Prinzip sollte ihre Anzahl ungef√§hr der Anzahl der verf√ºgbaren Prozessorkerne entsprechen).  Wenn mehr Anfragen gleichzeitig eingehen als freie Transformatoren, k√∂nnen wir entweder sofort negativ auf die Anfrage reagieren oder die Anfrage in die Warteschlange stellen.  Und nehmen Sie es dann aus der Warteschlange, wenn ein freier Transformator erscheint. <br><br>  In Shrimps verwenden wir eine Warteschlange mit Warteanfragen, die wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request_t</span></span></span><span class="hljs-class"> {</span></span> transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> m_key; <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; m_cmd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point m_stored_at; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point stored_at ) : m_key{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key) } , m_cmd{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) } , m_stored_at{ stored_at } {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> m_pending_requests; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_pending_requests{ <span class="hljs-number"><span class="hljs-number">64u</span></span> };</code> </pre> <br>  Nach Eingang der Anfrage stellen wir sie in die Warteschlange, um den Zeitpunkt des Eingangs der Anfrage festzulegen.  Anschlie√üend √ºberpr√ºfen wir regelm√§√üig, ob das Zeitlimit f√ºr diese Anforderung abgelaufen ist.  Grunds√§tzlich kann es vorkommen, dass ein B√ºndel ‚Äûschwerer‚Äú Anfragen fr√ºher eingetroffen ist, deren Bearbeitung zu lange gedauert hat.  Es ist falsch, endlos auf das Erscheinen eines freien Transformators zu warten. Es ist besser, nach einiger Zeit eine negative Antwort an den Client zu senden, was bedeutet, dass der Dienst jetzt √ºberlastet ist. <br><br>  Es gibt auch eine Gr√∂√üenbeschr√§nkung f√ºr die Warteschlange ausstehender Anforderungen.  Wenn die Warteschlange bereits ihre maximale Gr√∂√üe erreicht hat, lehnen wir die Verarbeitung der Anforderung sofort ab und teilen dem Client mit, dass wir √ºberlastet sind. <br><br>  Es gibt einen wichtigen Punkt im Zusammenhang mit der Warteschlange ausstehender Anfragen, auf den wir uns im Abschluss des Artikels konzentrieren werden. <br><br><h4>  Geben Sie sobj_shptr_t ein und verwenden Sie Nachrichteninstanzen erneut </h4><br>  Beim Bestimmen des Typs der Warteschlange wartender Anforderungen sowie bei den Signaturen einiger Methoden von transform_manager k√∂nnen Sie die Verwendung des Typs sobj_shptr_t sehen.  Es ist sinnvoll, genauer darauf einzugehen, um welchen Typ es sich handelt und warum er verwendet wird. <br><br>  Unter dem Strich empf√§ngt transform_manager eine Anfrage vom HTTP-Server als resize_request_t-Nachricht: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_http_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_image; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_image_format; transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>( restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> http_req, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format, transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_http_req{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(http_req) } , m_image{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image) } , m_image_format{ image_format } , m_params{ params } {} };</code> </pre> <br>  und wir m√ºssen etwas tun, um diese Informationen in der Warteschlange wartender Anfragen zu speichern.  Sie k√∂nnen beispielsweise eine neue Instanz von resize_request_t erstellen und die Werte aus der empfangenen Nachricht in diese verschieben. <br><br>  Und Sie k√∂nnen sich daran erinnern, dass die Nachricht selbst in SObjectizer ein dynamisch erstelltes Objekt ist.  Und kein einfaches Objekt, sondern mit einem Linkz√§hler im Inneren.  Und dass es in SObjectizer einen speziellen Typ eines intelligenten Zeigers f√ºr solche Objekte gibt - intrusive_ptr_t. <br><br>  Das hei√üt,  Wir k√∂nnen keine Kopie von resize_request_t f√ºr die Warteschlange wartender Anforderungen erstellen, aber wir k√∂nnen einfach einen intelligenten Zeiger auf eine vorhandene Instanz von resize_request_t in diese Warteschlange stellen.  Was wir tun  Und um nicht √ºberall den eher exotischen Namen so_5 :: intrusive_ptr_t zu schreiben, geben wir unseren Alias ‚Äã‚Äãein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;T&gt;;</code> </pre><br><h3>  Asynchrone Antworten auf Clients </h3><br>  Wir haben gesagt, dass HTTP-Anfragen asynchron verarbeitet werden.  Und wir haben oben gezeigt, wie der HTTP-Server eine Anfrage mit einer asynchronen Nachricht an den transform_manager-Agenten sendet.  Aber was passiert mit Antworten auf HTTP-Anfragen? <br><br>  Antworten werden auch asynchron bereitgestellt.  Im Code transform_manager sehen Sie beispielsweise Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_failed_resize( <span class="hljs-keyword"><span class="hljs-keyword">failed_resize_t</span></span> &amp; <span class="hljs-comment"><span class="hljs-comment">/*result*/</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req) ); }</code> </pre> <br>  Dieser Code generiert eine negative Antwort auf die HTTP-Anforderung, wenn das Bild aus irgendeinem Grund nicht skaliert werden konnte.  Die Antwort wird in der Hilfsfunktion do_404_response generiert, deren Code wie folgt dargestellt werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_404_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response( <span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span> ); resp.append_header( restinio::<span class="hljs-keyword"><span class="hljs-keyword">http_field_t</span></span>::server, <span class="hljs-string"><span class="hljs-string">"Shrimp draft server"</span></span> ); resp.append_header_date_field(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().should_keep_alive() ) resp.connection_keep_alive(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.connection_close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.done(); }</code> </pre> <br>  Der erste wichtige Punkt bei do_404_response () ist, dass diese Funktion im Arbeitskontext des transform_manager-Agenten und nicht im Arbeitskontext des HTTP-Servers aufgerufen wird. <br><br>  Der zweite wichtige Punkt ist der Aufruf der Methode done () f√ºr das vollst√§ndig geformte bzw. Objekt.  Alle asynchrone Magie mit einer HTTP-Antwort geschieht hier.  Die Methode done () verwendet alle in bzw. vorbereiteten Informationen und sendet sie asynchron an den HTTP-Server.  Das hei√üt,  Eine R√ºckgabe von do_404_response () erfolgt unmittelbar nachdem der Inhalt des resp-Objekts vom HTTP-Server in die Warteschlange gestellt wurde. <br><br>  Der HTTP-Server in seinem Arbeitskontext erkennt das Vorhandensein einer neuen HTTP-Antwort und f√ºhrt die erforderlichen Aktionen aus, um die Antwort an den entsprechenden Client zu senden. <br><br><h3>  Geben Sie datasizable_blob_t ein </h3><br>  Ein weiterer kleiner Punkt, der zur Kl√§rung sinnvoll ist, da er wahrscheinlich unverst√§ndlich ist, ohne die Feinheiten von RESTinio zu verstehen.  Wir sprechen √ºber das Vorhandensein eines seltsamen Typs von datizizeable_blob_t, der auf den ersten Blick wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datasizable_blob_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">datasizable_blob_t</span></span> &gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.data(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.length(); } Magick::Blob m_blob; <span class="hljs-comment"><span class="hljs-comment">//! Value for `Last-Modified` http header field. const std::time_t m_last_modified_at{ std::time( nullptr ) }; };</span></span></code> </pre> <br>  Um zu erkl√§ren, warum dieser Typ ben√∂tigt wird, m√ºssen Sie zeigen, wie eine HTTP-Antwort mit einem transformierten Bild gebildet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve_transformed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">datasizable_blob_shared_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blob, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> img_format, http_header::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_src_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">header_fields_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header_fields )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response(); set_common_header_fields_for_image_resp( blob-&gt;m_last_modified_at, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( img_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( image_src ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( blob ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; hf : header_fields ) { resp.append_header( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_name ), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_value ) ); } resp.done(); }</code> </pre> <br>  Wir achten auf den Aufruf von set_body (): Ein intelligenter Zeiger auf die Instanz datasizable_blob_t wird direkt dorthin gesendet.  Warum? <br><br>  Tatsache ist, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio verschiedene Optionen zum Bilden des K√∂rpers einer HTTP-Antwort unterst√ºtzt</a> .  Am einfachsten ist es, eine Instanz vom Typ std :: string an set_body () zu √ºbergeben, und RESTinio speichert den Wert dieser Zeichenfolge im resp-Objekt. <br><br>  Es gibt jedoch Situationen, in denen der Wert f√ºr set_body () in mehreren Antworten gleichzeitig wiederverwendet werden sollte.  Bei Garnelen geschieht dies beispielsweise, wenn Garnelen mehrere identische Anforderungen f√ºr die Transformation desselben Bildes erhalten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall ist es unrentabel, in jede Antwort denselben Wert zu kopieren. </font><font style="vertical-align: inherit;">Daher gibt es in RESTinio eine set_body () -Variante des Formulars:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; body)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall wird dem Typ T jedoch eine wichtige Einschr√§nkung auferlegt: Er muss die Methoden public data () und size () enthalten, die erforderlich sind, damit RESTinio auf den Inhalt der Antwort zugreifen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das skalierte Bild in Shrimps wird als Magick :: Blob-Objekt gespeichert. </font><font style="vertical-align: inherit;">Es gibt eine Datenmethode im Magic :: Blob-Typ, aber keine size () -Methode, sondern eine length () -Methode. </font><font style="vertical-align: inherit;">Daher brauchten wir die Wrapper-Klasse datasizable_blob_t, die RESTinio die notwendige Schnittstelle f√ºr den Zugriff auf den Wert von Magick :: Blob bietet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Periodische Nachrichten in transform_manager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der transform_manager-Agent muss von Zeit zu Zeit verschiedene Dinge tun: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ziehen Sie Bilder, die sich zu lange im Cache befinden, aus dem Cache. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steuern Sie die Zeit, die Anforderungen in der Warteschlange der freien Transformatoren verbringen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der transform_manager-Agent f√ºhrt diese Aktionen √ºber regelm√§√üige Nachrichten aus. </font><font style="vertical-align: inherit;">Es sieht wie folgt aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst werden die Arten von Signalen bestimmt, die als periodische Nachrichten verwendet werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear_cache_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_pending_requests_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann wird der Agent abonniert, einschlie√ülich dieser Signale: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_define_agent() { so_subscribe_self() .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_request ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_result ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt; ) {...} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt; ) {...}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank des Abonnements ruft SObjectizer den gew√ºnschten Handler auf, wenn der Agent das entsprechende Signal empf√§ngt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es bleibt nur, um regelm√§√üige Nachrichten auszuf√ºhren, wenn der Agent startet:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_evt_start() { m_clear_cache_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, clear_cache_period, clear_cache_period ); m_check_pending_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, check_pending_period, check_pending_period ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der entscheidende Punkt hierbei ist das Speichern von timer_id, die von den Funktionen send_periodic () zur√ºckgegeben werden. </font><font style="vertical-align: inherit;">Schlie√ülich wird ein periodisches Signal nur kommen, solange seine timer_id aktiv ist. </font><font style="vertical-align: inherit;">Wenn der R√ºckgabewert von send_periodic () nicht gespeichert wird, wird das Senden einer periodischen Nachricht sofort abgebrochen. </font><font style="vertical-align: inherit;">Daher weist die Klasse a_transform_manager_t die folgenden Attribute auf:</font></font><br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_clear_cache_timer; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_check_pending_timer;</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ende des ersten Teils </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heute haben wir dem Leser die einfachste und minimalistischste Implementierung von Garnelen vorgestellt. Diese Implementierung reicht aus, um zu zeigen, wie RESTinio und SObjectizer zusammen f√ºr etwas verwendet werden k√∂nnen, das mehr oder weniger einer echten Aufgabe √§hnelt, als einer einfachen HelloWorld. Aber es hat eine Reihe schwerwiegender M√§ngel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise wird im transform_manager-Agenten eine bestimmte √úberpr√ºfung der Eindeutigkeit der Anforderung durchgef√ºhrt. Dies funktioniert jedoch nur, wenn sich das transformierte Bild bereits im Cache befindet. Befindet sich noch kein Bild im Cache und gleichzeitig kommen zwei identische Anforderungen f√ºr dasselbe Bild, werden beide Anforderungen zur Verarbeitung gesendet. Was ist nicht gut Es w√§re richtig, nur einen von ihnen zu verarbeiten und den zweiten zu verschieben, bis die Verarbeitung des ersten abgeschlossen ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine derart erweiterte Kontrolle √ºber die Eindeutigkeit von Anforderungen w√ºrde zu einem viel komplexeren und umfangreicheren transform_manager-Code f√ºhren. Daher haben wir nicht sofort damit begonnen, sondern beschlossen, den evolution√§ren Weg zu gehen - von einfach bis komplex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einfachste Version von Garnelen ist eine ‚ÄûBlack Box‚Äú, die keine Anzeichen ihrer Arbeit zeigt. Was sowohl beim Testen als auch w√§hrend des Betriebs nicht sehr praktisch ist. Daher sollten Garnelen in guter Weise auch die Protokollierung hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden versuchen, diese und einige andere M√§ngel der allerersten Version von Shrimps in zuk√ºnftigen Versionen zu beseitigen und sie in zuk√ºnftigen Artikeln zu beschreiben. Also bleibt dran.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn jemand Fragen zur Logik von Shrimps, RESTinio oder SObjectizer hat, beantworten wir diese gerne in den Kommentaren. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist Shrimp selbst ein Demo-Projekt. Wenn jedoch jemand an seiner Funktionalit√§t interessiert ist und neben dem Gr√∂√üen√§nderungsvorgang noch etwas anderes in Shrimp sehen m√∂chte, lassen Sie es uns wissen. Gerne h√∂ren wir uns konstruktive Ideen an .</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416387/">https://habr.com/ru/post/de416387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416375/index.html">JavaScript-Grundlagen f√ºr Anf√§nger</a></li>
<li><a href="../de416377/index.html">Wir werden zu Assistenten in der Programmierung. Teil 1</a></li>
<li><a href="../de416379/index.html">Neurobugurt. Wie wir dem neuronalen Netzwerk beigebracht haben, Meme ein Jahr fr√ºher als Stanford zu erfinden</a></li>
<li><a href="../de416381/index.html">Bericht des Club of Rome 2018, Kapitel 3.13: Philanthropie, Investition, Crowdsourcing und Blockchain</a></li>
<li><a href="../de416385/index.html">Wenn die Korrelation zu 100% herauskommt, hat sich irgendwo ein Fehler eingeschlichen: die Praktikumserfahrung bei der Rambler Group</a></li>
<li><a href="../de416391/index.html">Optimierung der Platzierung virtueller Maschinen auf Servern</a></li>
<li><a href="../de416393/index.html">IIDF-Konferenz: Unternehmen sind nicht gegen Startups</a></li>
<li><a href="../de416397/index.html">Wir automatisieren UI-Tests von Android-Anwendungen mithilfe des Seitenobjektmusters</a></li>
<li><a href="../de416399/index.html">Wie wir Bewertungen von mobilen Apps mithilfe von maschinellem Lernen analysiert haben</a></li>
<li><a href="../de416401/index.html">Blender: 3D-Modell eines Chips zur Verbindung mit der KiCad-Bibliothek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>