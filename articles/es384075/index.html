<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåá üëåüèº üë®‚Äçüè≠ Nota de calibraci√≥n del sensor de posici√≥n inicial üëßüèΩ üòç üñêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algunos sensores de aceleraci√≥n requieren calibraci√≥n cero adicional despu√©s del montaje en la placa. Cuando vi varias fuentes con la calibraci√≥n de s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nota de calibraci√≥n del sensor de posici√≥n inicial</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384075/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos sensores de aceleraci√≥n requieren calibraci√≥n cero adicional despu√©s del montaje en la placa. </font><font style="vertical-align: inherit;">Cuando vi varias fuentes con la calibraci√≥n de sensores de aceleraci√≥n, donde el componente G se tuvo en cuenta simplemente restando el valor = 9.8 m / s2 del eje Z, surgi√≥ la idea de escribir esta nota.</font></font><br>
<br>
<img src="https://habrastorage.org/files/b4d/dcb/c3b/b4ddcbc3ba4d4e2dbd467eeab056db2d.jpg"><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructura de publicaci√≥n</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Declaraci√≥n del problema y m√©todo de soluci√≥n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo conseguir los puntos?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo calcular el centro de la pelota?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo acelerar la b√∫squeda del centro de la pelota?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øDe qu√© otra manera acelerar la b√∫squeda del centro de la pelota?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre errores de medici√≥n</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></li>
</ul><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°l es el problema? Los sensores MEMS despu√©s de la instalaci√≥n en la placa sufren deformaciones menores que afectan:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posici√≥n cero;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escala de valores medidos;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La perpendicularidad de los ejes entre s√≠.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y si la escala y la perpendicularidad se violan no tan notablemente, entonces la posici√≥n de cero se enreda de manera tangible. Por ejemplo, si traduce el valor t√≠pico del desplazamiento cero para el aceler√≥metro del sensor MPU9250 a m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces esto se obtiene en la regi√≥n de 0.2 m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, el sensor est√° parado, pero muestra aceleraci√≥n, y despu√©s de 5 segundos obtenemos una velocidad de 1 m / s. Por un lado, todos los datos del sensor siempre se pasan a trav√©s de alg√∫n tipo de filtro (por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Pero, por otro lado, ¬øpor qu√© el filtro debe compensar constantemente este sesgo? Despu√©s de todo, el sensor mostrar√° movimiento donde no est√°. Esto reduce la precisi√≥n del resultado. Con todo, necesita encontrar el valor de compensaci√≥n una vez y luego restar este valor de sus lecturas durante la operaci√≥n del sensor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n m√°s simple para encontrar el valor de la compensaci√≥n de cero, que viene inmediatamente a la mente, es crear las condiciones bajo las cuales el sensor debe mostrar cero con precisi√≥n. ¬°El valor registrado en el sensor es el valor del desplazamiento cero! ¬øEntonces? Pero no, la gravedad est√° actuando constantemente sobre el aceler√≥metro. Para evitarlo, se necesitar√° ingravidez (lanzar no funcionar√°). El campo magn√©tico de la Tierra act√∫a en la br√∫jula y su rotaci√≥n en el giroscopio. Entonces, si no tienes una nave espacial personal, tendr√°s que encontrar algo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda soluci√≥n que viene a la mente de inmediato es colocar el sensor (o m√°s bien su eje) en una posici√≥n en la que sepamos exactamente qu√© debe mostrar el sensor. La diferencia entre lo que muestra el sensor y lo que deber√≠a mostrar, ¬°y habr√° un desplazamiento cero! ¬øEntonces? Por ejemplo, sabemos que si el aceler√≥metro se coloca en un nivel con el horizonte, entonces, en teor√≠a, el vector de aceleraci√≥n gravitacional se dirigir√° exactamente a lo largo del eje Z del sensor. La magnitud del vector de aceleraci√≥n que conocemos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, hay un problema. </font><font style="vertical-align: inherit;">Consiste en el hecho de que no podemos establecer con precisi√≥n el eje del sensor a un nivel con el horizonte. </font><font style="vertical-align: inherit;">El hecho es que la superficie en la que confiaremos no es paralela a la placa de circuito impreso. </font><font style="vertical-align: inherit;">Eso, a su vez, no es paralelo al sitio en el que se encuentra el sensor. </font><font style="vertical-align: inherit;">El sensor en s√≠ no se encuentra exactamente en su sitio y los ejes dentro del sensor no son paralelos al cuerpo del sensor. </font><font style="vertical-align: inherit;">El error al establecer el eje en relaci√≥n con el horizonte en 1 grado da una proyecci√≥n de tama√±o comparable al valor del desplazamiento cero en s√≠, que queremos encontrar. </font><font style="vertical-align: inherit;">En el caso de un magnet√≥metro, tampoco sabemos a d√≥nde se dirige el vector de campo magn√©tico. </font><font style="vertical-align: inherit;">En teor√≠a, hacia el norte. </font><font style="vertical-align: inherit;">Pero en la pr√°ctica, el campo magn√©tico de la Tierra en s√≠ es heterog√©neo en intensidad y direcci√≥n. </font><font style="vertical-align: inherit;">Adem√°s, los objetos met√°licos cercanos hacen sus ajustes.</font></font><br>
<img src="https://habrastorage.org/files/62a/4e5/7e2/62a4e57e29a24a389b1fddf12a652219.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Declaraci√≥n del problema y m√©todo de soluci√≥n.</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tarea es la siguiente: necesitamos determinar el vector de desplazamiento cero usando las lecturas del sensor, que siempre registrar√°n el vector de desplazamiento + vector de influencia externa constante (aceleraci√≥n gravitacional, rotaci√≥n de la Tierra, campo magn√©tico de la Tierra), la magnitud y direcci√≥n de la cual no sabemos (en el caso del aceler√≥metro conocemos el valor, pero nuevamente la escala del sensor puede no ser igual a 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma de resolver. </font><font style="vertical-align: inherit;">Este art√≠culo propone determinar el vector de desplazamiento de la siguiente manera. </font><font style="vertical-align: inherit;">Tomamos y giramos el sensor en todos los sentidos y registramos las lecturas del sensor. </font><font style="vertical-align: inherit;">Despu√©s de N mediciones, los valores tomados del sensor y ubicados en el gr√°fico ser√°n una bola, cuyo radio es la magnitud del impacto externo, y el centro es el desplazamiento cero exacto deseado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo conseguir los puntos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para facilitar el procedimiento de medici√≥n en s√≠, puede escribir un programa simple. </font><font style="vertical-align: inherit;">Debe registrar los sensores cuando el dispositivo est√° parado. </font><font style="vertical-align: inherit;">Solo necesitamos girar el dispositivo a la posici√≥n deseada. </font><font style="vertical-align: inherit;">Para determinar un estado estacionario, tambi√©n es adecuado un aceler√≥metro no calibrado: simplemente tome la diferencia entre el valor actual y el anterior. </font><font style="vertical-align: inherit;">Y si hay m√°s ruido, entonces arreglamos el movimiento. </font><font style="vertical-align: inherit;">Mi umbral se obtiene en la regi√≥n de 0.07G. </font><font style="vertical-align: inherit;">Si lo sostiene con las manos, resultar√° m√°s de este valor. </font><font style="vertical-align: inherit;">Utilic√© cinta adhesiva para fijar la posici√≥n. </font><font style="vertical-align: inherit;">Si todav√≠a no funciona, verifique si hay un refrigerador, un ventilador o algo similar cerca.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo puede estar en c√≥digo?</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">//       </span>
<span class="hljs-keyword">static</span> TSumSensorsData 	g_sens_data[<span class="hljs-number">2</span>];
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span>   	g_sens_data_sum_cnt[<span class="hljs-number">2</span>];
<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span>		g_sens_data_num;<font></font>
<font></font>
<span class="hljs-comment">//  - ,     </span>
<span class="hljs-function">IS_INTERRUPT <span class="hljs-keyword">void</span> <span class="hljs-title">on_dma_raw_ready_calibrate_step1</span><span class="hljs-params">()</span>
</span>{<font></font>
	SensorRawBuffer *raw = sensor_get_raw_buffer();<font></font>
	g_sens_data[g_sens_data_num].acc_x += swap_i16(raw-&gt;accell_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_y += swap_i16(raw-&gt;accell_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_z += swap_i16(raw-&gt;accell_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_x += swap_i16(raw-&gt;gyro_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_y += swap_i16(raw-&gt;gyro_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_z += swap_i16(raw-&gt;gyro_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].mag_x += raw-&gt;mag_x_raw * g_mag_calibrate.kx;<font></font>
	g_sens_data[g_sens_data_num].mag_y += raw-&gt;mag_y_raw * g_mag_calibrate.ky;<font></font>
	g_sens_data[g_sens_data_num].mag_z += raw-&gt;mag_z_raw * g_mag_calibrate.kz;<font></font>
	g_sens_data_sum_cnt[g_sens_data_num]++;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   main</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sensors_calibrate_program</span><span class="hljs-params">(FlashROM *flash_ptr)</span>
</span>{
	<span class="hljs-keyword">double</span> calibrate_result_error[<span class="hljs-number">3</span>];<font></font>
	TVector16 calibrate_result[<span class="hljs-number">3</span>];
	<span class="hljs-keyword">int32_t</span> radius[ACCEL_NO_MOTION_DETECT_COUNT];
	<span class="hljs-keyword">uint8_t</span> raw_is_deleted[ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	TVector16 raw[<span class="hljs-number">3</span>][ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	<font></font>
        . . .<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	g_sens_data_sum_cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
	g_sens_data_num = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_y = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_z = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int8_t</span> low_motion_cnt = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">while</span>(low_motion_cnt &lt; ACCEL_NO_MOTION_DETECT_COUNT)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (g_sens_data_sum_cnt[g_sens_data_num] &gt;= ACCEL_NO_MOTION_DETECT_SAMPLES)<font></font>
		{<font></font>
			<span class="hljs-keyword">uint8_t</span> new_data_num = (g_sens_data_num + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>;<font></font>
			g_sens_data[new_data_num].acc_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data_sum_cnt[new_data_num] = <span class="hljs-number">0</span>;<font></font>
<font></font>
			<span class="hljs-keyword">uint8_t</span> old_data_num = g_sens_data_num;<font></font>
			g_sens_data_num = new_data_num; <span class="hljs-comment">//           </span>
			<span class="hljs-comment">// ( -    ,   )</span><font></font>
<font></font>
			<span class="hljs-comment">//     -  </span>
			<span class="hljs-keyword">int16_t</span> avg_x = g_sens_data[old_data_num].acc_x / g_sens_data_sum_cnt[old_data_num];
			<span class="hljs-keyword">int16_t</span> avg_y = g_sens_data[old_data_num].acc_y / g_sens_data_sum_cnt[old_data_num];
			<span class="hljs-keyword">int16_t</span> avg_z = g_sens_data[old_data_num].acc_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
			<span class="hljs-comment">//      </span>
			<span class="hljs-keyword">int16_t</span> dx = avg_x - prev_avg_x;
			<span class="hljs-keyword">int16_t</span> dy = avg_y - prev_avg_y;
			<span class="hljs-keyword">int16_t</span> dz = avg_z - prev_avg_z;<font></font>
			prev_avg_x = avg_x;<font></font>
			prev_avg_y = avg_y;<font></font>
			prev_avg_z = avg_z;<font></font>
<font></font>
			<span class="hljs-comment">//     </span>
			<span class="hljs-keyword">if</span> ((abs_i16(dx) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dy) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dz) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE))<font></font>
			{<font></font>
				<span class="hljs-comment">//    </span><font></font>
				raw[RAW_ACC][low_motion_cnt].x = avg_x;<font></font>
				raw[RAW_ACC][low_motion_cnt].y = avg_y;<font></font>
				raw[RAW_ACC][low_motion_cnt].z = avg_z;<font></font>
				raw[RAW_GYRO][low_motion_cnt].x = g_sens_data[old_data_num].gyro_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].y = g_sens_data[old_data_num].gyro_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].z = g_sens_data[old_data_num].gyro_z / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].x = g_sens_data[old_data_num].mag_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].y = g_sens_data[old_data_num].mag_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].z = g_sens_data[old_data_num].mag_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
				low_motion_cnt++;<font></font>
<font></font>
				<span class="hljs-comment">//   </span><font></font>
				beep();<font></font>
<font></font>
				<span class="hljs-comment">//     2   ,     -   </span>
				<span class="hljs-comment">//  -  </span>
				<span class="hljs-comment">//      </span>
				delay_ms(<span class="hljs-number">2000</span>);<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener la bola en el gr√°fico, debe girar el dispositivo con el sensor de acuerdo con un determinado esquema. </font><font style="vertical-align: inherit;">Para estos fines, el globo es muy adecuado, ya que tiene un marcado. </font><font style="vertical-align: inherit;">Puede pensar que necesita esculpir en todo el mundo. </font><font style="vertical-align: inherit;">Pero esto no es as√≠.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de resultado incorrecto</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/files/3b4/db9/bdf/3b4db9bdff434974b8616d24153755a1.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es necesario esculpir el sensor no en toda la superficie del globo, sino en un meridiano. </font><font style="vertical-align: inherit;">Supongamos que tomamos siete puntos en el meridiano (el primero y el √∫ltimo en los polos norte y sur). </font><font style="vertical-align: inherit;">En cada punto del meridiano, conectamos su dispositivo al globo y a√∫n giramos el dispositivo alrededor de su eje con un cierto paso, por ejemplo, 30-35 grados. </font><font style="vertical-align: inherit;">Resulta que si gira 12 veces alrededor de su eje, en 7 puntos en total se obtienen 84 mediciones. </font></font><br>
<br>
<img src="https://habrastorage.org/files/dfb/5df/1e5/dfb5df1e5107458e8560d939b6a5cd9a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La belleza del m√©todo es que todo se puede hacer "en la rodilla". </font><font style="vertical-align: inherit;">La precisi√≥n de posicionamiento no juega un papel especial, solo necesita girar de acuerdo con el esquema para que el vector de influencia externa en el gr√°fico atraiga una bola. </font><font style="vertical-align: inherit;">El correcto se parece a esto: vea la figura (el centro est√° marcado con una marca).</font></font><br>
<br>
<img src="https://habrastorage.org/files/2d4/8e8/3a3/2d48e83a3c784bdb8736b86e4b3f6d87.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo calcular el centro de la pelota?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una tarea interesante y tiene varias soluciones. Puede parecer que para buscar el centro, es suficiente tomar el promedio aritm√©tico de las coordenadas de los puntos obtenidos. Sin embargo, esto no es as√≠: los puntos se pueden ubicar de manera desigual en la pelota (ver. Fig.). </font></font><br>
<br>
<img src="https://habrastorage.org/files/eda/0cd/9d2/eda0cd9d222e401ca3898d108182fbd8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ecuaci√≥n de la pelota se ve as√≠: (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde X, Y, Z son las coordenadas del punto que se encuentra en la pelota. A, B, C son las coordenadas del centro en los ejes x, y y z, respectivamente. R es el radio de la pelota. Puede construir un sistema de ecuaciones e intentar resolver este sistema de manera m√°s simple utilizando alg√∫n m√©todo. O simplemente puede buscar el centro (esto es como un m√©todo de aproximaciones sucesivas). El significado del m√©todo es simple: el valor de error (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> debe tender a cero. Esto significa que la suma de estas cantidades para todos los puntos de la esfera tambi√©n deber√≠a tender a cero. Sabiendo esto, podemos elegir los valores A, B y C para los cuales el error para todos los puntos ser√° m√≠nimo. El √°rea de b√∫squeda est√° limitada por el tama√±o de la pelota (cubo condicional). Es decir, debemos colocar secuencialmente el centro de la pelota en todos los puntos del cubo y calcular el error. Donde hay un error m√≠nimo, ah√≠ est√° el centro. </font></font><br>
<br>
<img src="https://habrastorage.org/files/d53/d46/4d5/d53d464d57c0411790594a6df5a45ca1.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como R, necesitamos tomar el valor te√≥rico del vector de influencia externa, para el aceler√≥metro, esta es la aceleraci√≥n de la gravedad, para la br√∫jula, esta es la magnitud promedio del campo magn√©tico de la Tierra, para el giroscopio, la velocidad de rotaci√≥n de la Tierra. Por supuesto, en la f√≥rmula debe haber valores de una dimensi√≥n (unidades convencionales del sensor o m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, grados / s, etc.). </font><font style="vertical-align: inherit;">Es m√°s conveniente convertir a unidades arbitrarias del sensor correspondiente.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo calcular un cierto valor en las unidades est√°ndar del sensor?</font></font></b><div class="spoiler_text">   =  *   / (   ‚Äî   )<br>
:      16-      ¬±2g        ?: <br>
9,8 /<sup>2</sup> * 65536 / (2g + 2g) = 9,8 /<sup>2</sup> * 65536 / (2 * 9,8 /<sup>2</sup> + 2 * 9,8 /<sup>2</sup>) = 16384 . . .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, si conoce el radio de la pelota exactamente, entonces puede calcular el centro solo por su "cu√±a". </font><font style="vertical-align: inherit;">Es decir, en puntos que se encuentran solo en un pedazo de la superficie de la pelota. </font><font style="vertical-align: inherit;">Pero este no es nuestro caso.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo acelerar la b√∫squeda del centro de la pelota?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es necesario buscar el centro no en todo el cubo (las dimensiones de la pelota), sino a lo largo de la l√≠nea, cuyo comienzo es arbitrario, cada punto siguiente est√° m√°s cerca del centro real y el final est√° en el centro. </font><font style="vertical-align: inherit;">Supongamos que comenzamos desde el punto (0; 0; 0) ... Siempre nos movemos con un paso constante. </font><font style="vertical-align: inherit;">Por lo tanto, si imaginamos un conjunto de cubos de 3x3x3, donde cada cara es igual al tama√±o del paso y tambi√©n imaginamos que la posici√≥n actual es el cubo del medio, entonces tenemos 9 + 8 + 9 opciones donde colocar el siguiente punto. </font><font style="vertical-align: inherit;">Solo tenemos que estar en cada punto, para calcular en cu√°l de los 26 puntos vecinos el error ser√° menor. </font><font style="vertical-align: inherit;">Si resulta que el error es menor en el punto actual, y no en uno de los vecinos, significa que est√° en el centro y la b√∫squeda ha terminado.</font></font><br>
<br>
<img src="https://habrastorage.org/files/ba5/4dd/8d4/ba54dd8d423e4323a643cb4653361f1a.bmp"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo puede estar en c√≥digo?</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double
<span class="hljs-keyword">Dim</span> x, y, z As Double
<span class="hljs-keyword">Dim</span> sigma As Double
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )
<span class="hljs-keyword">Next</span>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
<font></font>
. . .<font></font>
A = <span class="hljs-number">0</span>
B = <span class="hljs-number">0</span>
C = <span class="hljs-number">0</span><font></font>
<font></font>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span>
   min_sigma = <span class="hljs-number">0</span>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
                sigma = get_err(A + ai, B + bi, C + ci, <span class="hljs-number">16384</span>)
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Next</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span><font></font>
    <font></font>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
        <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
    <font></font>
    A = A + ai_min<font></font>
    B = B + bi_min<font></font>
    C = C + ci_min<font></font>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øDe qu√© otra manera acelerar la b√∫squeda del centro de la pelota?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesita buscar con paso variable. </font><font style="vertical-align: inherit;">Primero buscamos el centro en grandes pasos. </font><font style="vertical-align: inherit;">Encontramos el centro, reducimos el paso y desde all√≠ comenzamos a buscar m√°s. </font><font style="vertical-align: inherit;">Y as√≠ sucesivamente, hasta que obtenga el resultado de la precisi√≥n necesaria.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo puede estar en c√≥digo?</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double
<span class="hljs-keyword">Dim</span> x, y, z As Double
<span class="hljs-keyword">Dim</span> sigma As Double
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )
<span class="hljs-keyword">Next</span>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
. . .<font></font>
A = <span class="hljs-number">0</span>
B = <span class="hljs-number">0</span>
C = <span class="hljs-number">0</span>
<span class="hljs-keyword">step</span> = <span class="hljs-number">1000</span>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span>
   min_sigma = <span class="hljs-number">0</span>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
                sigma = get_err(A + ai * <span class="hljs-keyword">step</span>, B + bi * <span class="hljs-keyword">step</span>, C + ci * <span class="hljs-keyword">step</span>, <span class="hljs-number">16384</span>)
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Next</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>        
        <span class="hljs-keyword">step</span> = <span class="hljs-keyword">step</span> / <span class="hljs-number">10</span>
        <span class="hljs-keyword">If</span> <span class="hljs-keyword">step</span> &lt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">Then</span>
            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span>
        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
    <span class="hljs-keyword">Else</span>
    A = A + ai_min * <span class="hljs-keyword">step</span>
    B = B + bi_min * <span class="hljs-keyword">step</span>
    C = C + ci_min * <span class="hljs-keyword">step</span>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre errores de medici√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante las mediciones, puede haber situaciones en las que, por alguna raz√≥n, el resultado de la medici√≥n puede estar mucho m√°s lejos de la superficie de la pelota. O podr√≠a ser muchos puntos. O, en general, el resultado de las mediciones puede no ser una pelota, sino un "huevo" o una "aeronave". En este caso, por supuesto, debe repetir todas las mediciones, identificando las posibles causas de errores. Por ejemplo, para un magnet√≥metro puede ser un perno o un clavo en una mesa y est√° tomando medidas directamente sobre √©l. Y cuanto m√°s bajo baje el sensor a lo largo del meridiano, m√°s fuerte ser√° el metal afectar√° el resultado. Por lo tanto, es necesario determinar el umbral del valor de error permitido. Para no rehacer las mediciones debido a varios puntos claramente err√≥neos, puede aplicar un filtro. El principio del filtro es muy simple: despu√©s de calcular el centro por primera vez, clasifique los puntos por el nivel de error en cada uno de ellos.Algunos de los puntos con el mayor error simplemente se pueden descartar (por ejemplo, 10%). Luego debe repetir la b√∫squeda del centro.</font></font><br>
<img src="https://habrastorage.org/files/e22/c6f/b13/e22c6fb1385e4d678aabf7f1d879bc02.png"> <img src="https://habrastorage.org/files/569/40f/d17/56940fd17eef42cba93f590606bbe9e7.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m√©todo tiene bastante buena precisi√≥n. </font><font style="vertical-align: inherit;">El m√©todo le permite hacerlo con medios simples improvisados ‚Äã‚Äã(pelota, banco, etc.). </font><font style="vertical-align: inherit;">Funciona lo suficientemente r√°pido. </font><font style="vertical-align: inherit;">C√≥digo simple </font><font style="vertical-align: inherit;">Muchos sensores tienen registros especiales donde puede escribir el valor encontrado, y el sensor lo restar√° sobre la marcha. </font><font style="vertical-align: inherit;">Dichos registros suelen tener el prefijo "TRIM", como en el MPU9260, o "OFFSET", como en el LSM303. </font><font style="vertical-align: inherit;">Pero el conocido LIS302DL no tiene tales registros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No olvides poner un signo m√°s si te gust√≥. </font><font style="vertical-align: inherit;">Escriba en los comentarios sus m√©todos para calibrar sensores.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es384075/">https://habr.com/ru/post/es384075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es384063/index.html">C√≥mo no gastar algunos gigabytes de tr√°fico sin ser notado por usted mismo si no desea actualizar a Windows 10</a></li>
<li><a href="../es384067/index.html">Mozilla pospone el plazo de firma de la extensi√≥n de Firefox hasta el 26 de enero</a></li>
<li><a href="../es384069/index.html">Investigaci√≥n: ¬øLos ejercicios deportivos ayudan al agotamiento?</a></li>
<li><a href="../es384071/index.html">Sony Pictures consider√≥ comprar BitTorrent en 2006</a></li>
<li><a href="../es384073/index.html">El oc√©ano subterr√°neo de magma explica la actividad volc√°nica en Io</a></li>
<li><a href="../es384079/index.html">–®–∏—Ä–æ–∫–∞—è –ø–∞–Ω–æ—Ä–∞–º–∞ –≥–æ—Ä—ã –®–∞—Ä–ø–∞</a></li>
<li><a href="../es384081/index.html">Fotos del espacio para la semana (07/09/13/09)</a></li>
<li><a href="../es384083/index.html">Guerra de los mundos de Stephen Hawking. ¬øCu√°les son los extraterrestres peligrosos para los terr√≠colas?</a></li>
<li><a href="../es384085/index.html">SpaceX public√≥ una foto del interior de la nave espacial Crew Dragon</a></li>
<li><a href="../es384087/index.html">El Tesla Model S P85D rompe el sistema de calificaci√≥n de informes del consumidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>