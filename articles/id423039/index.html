<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏿 ☀️ 🧘🏾 Kami melakukan otentikasi web melalui blockchain 💖 🚨 🐂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya baru-baru ini berpartisipasi dalam Ethereum hackathon, dan hari ini saya ingin berbicara tentang proyek EtherAuth, yang dengannya tim MixBytes me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami melakukan otentikasi web melalui blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423039/"><p><img src="https://habrastorage.org/webt/0f/l6/qv/0fl6qv7pesmgkex2kvefrj6cw0s.jpeg"></p><br><p>  Saya baru-baru ini berpartisipasi dalam Ethereum hackathon, dan hari ini saya ingin berbicara tentang proyek EtherAuth, yang dengannya tim MixBytes menempati posisi ketiga.  EtherAuth adalah upaya untuk membuat versi terdesentralisasi dari login situs menggunakan akun eksternal.  Sebagai tombol, masuk melalui Facebook, hanya tanpa Facebook. </p><a name="habracut"></a><br><h1 id="problema-i-puti-resheniya">  Masalah dan solusi </h1><br><p>  Jika Anda ingin membuat area tertutup untuk pengguna di situs web Anda, Anda harus memilih: mengembangkan sistem Anda sendiri untuk mengidentifikasi, mengautentikasi, dan mengotorisasi pengguna, atau menggunakan solusi yang sudah jadi.  Solusi turnkey berarti bahwa pengguna Anda sudah memiliki akun di beberapa sistem (Facebook, Google, Yahoo, Outlook, atau bahkan hanya email).  Dan Anda menggunakan mekanisme yang sesuai (paling sering protokol OAuth 2.0) untuk memastikan bahwa seseorang yang mencoba masuk ke situs Anda menggunakan ID pengguna eksternal adalah pengguna ini. </p><br><p>  Opsi terakhir lebih mudah diterapkan, tetapi ada risiko bagi pengguna: jika terjadi sesuatu pada akun utamanya (misalnya, Facebook akan memblokir akun tanpa memberikan alasan), ia juga akan kehilangan akses ke informasinya di situs Anda. <br>  Selain itu, jika sebagai pengguna saya ingin masuk ke situs yang belum saya percayai, saya dihadapkan pada kebutuhan untuk memberikan situs ini akses ke informasi pribadi saya, seperti email atau usia.  Jika situs hanya mendukung masuk dengan akun eksternal, saya benar-benar harus membuat pilihan: menolak untuk menggunakan situs atau mengorbankan anonimitas saya. </p><br><p>  Sebagian besar pengguna akhirnya mengorbankan anonimitas dengan kata-kata "jadi apa yang buruk bisa terjadi, saya tidak perlu menyembunyikannya."  Sayangnya, sebagian besar serangan yang menargetkan pengguna yang tidak siap dan berakhir dengan kehilangan uang dimulai dengan kata-kata yang serupa.  "Apa yang mengerikan bisa terjadi jika saya mengirim kode dari SMS ke karyawan bank?"  "Hal buruk apa yang bisa terjadi jika saya mengirim karyawan dukungan teknis header permintaan?"  Jawaban untuk pertanyaan ini paling sering ditemukan ketika tidak ada yang bisa dilakukan. </p><br><p>  Bagaimana Ethereum dapat membantu di sini?  Kami sudah menyadari bahwa ada tiga masalah utama: </p><br><ol><li>  Pengguna tidak wajib mempercayai situs yang ia kunjungi dan ingin menghindari kebocoran informasi pribadi. </li><li>  Situs ini ingin menggunakan sistem otentikasi eksternal untuk menghindari penyimpanan data pengguna dan biaya keamanan terkait. </li><li>  Sistem eksternal yang ada yang menyediakan situs dengan kemampuan untuk mengotentikasi pengguna membawa bahaya sensor.  Setiap akun dapat diblokir kapan saja tanpa penjelasan dan kadang-kadang tanpa kemungkinan pemulihan. </li></ol><br><p>  Kita dapat menggunakan jaringan Ethereum daripada sistem eksternal dan hanya menyimpan set data yang diperlukan di dalamnya.  Kita harus berhati-hati untuk tidak menyimpan informasi rahasia dalam domain publik, tetapi karena dompet apa pun di jaringan Ethereum sebenarnya adalah sepasang kunci yang kuat secara kriptografis, di mana kunci publik menentukan alamat dompet dan kunci pribadi tidak pernah dikirimkan melalui jaringan dan hanya diketahui oleh pemiliknya, kami kita dapat menggunakan enkripsi asimetris untuk mengotentikasi pengguna. </p><br><p>  Dalam kasus paling sederhana, Anda dapat menggunakan alamat dompet Ethereum sebagai ID pengguna.  Tapi di sini muncul masalah: jika terjadi kebocoran kunci, pengguna kehilangan akses ke sistem selamanya.  Lebih tepatnya, sejak saat kunci rahasia pengguna diketahui oleh penyerang atau secara tidak sengaja jatuh ke akses publik, kami tidak dapat menggunakan kunci semacam itu untuk otentikasi. </p><br><h1 id="realizaciya">  Implementasi </h1><br><p>  Dalam solusi kami, saya menulis kontrak pintar EtherAuth sederhana untuk menyimpan ID pengguna dan alamat dompet yang terkait.  ID pengguna hanya berupa string UTF-8 yang berukuran antara 2 dan 32 byte.  Itu diciptakan sekali oleh pengguna sendiri dan kemudian digunakan untuk masuk ke situs apa pun yang mendukung EtherAuth.  Hari ini saya akan menambahkan batasan pada karakter yang mungkin termasuk dalam string, meninggalkan kemungkinan menggunakan karakter Latin dan angka Arab (himpunan bagian dari pengkodean ASCII 7-bit) untuk membatasi kemampuan untuk membuat login yang mirip secara lahiriah. </p><br><p>  Saat membuat akun di EtherAuth, sepasang kunci diatur: kunci otorisasi (authAddr) dan kunci untuk memulihkan akses (recoveryKey).  Nama recoveryKey tidak sepenuhnya berhasil, karena alamat ini digunakan untuk mengelola akun, dan bukan hanya untuk pemulihan.  Saat membuat, kedua alamat sama dengan alamat dompet atas nama transaksi yang dikirim.  Tetapi pengguna yang peduli dengan keselamatannya harus membuat kunci kontrol terpisah dan menyimpannya di tempat yang tidak dapat diakses melalui jaringan.  Saya bahkan akan menyimpannya di atas kertas di brankas dalam bentuk 12 kata mnemonik, yang memungkinkan, jika perlu, membuat ulang beberapa kunci. </p><br><p>  Juga bijaksana untuk menggunakan alamat dompet yang terpisah untuk otentikasi, memisahkannya dari alamat dompet tempat semua Ether Anda disimpan.  Hubungan authKey dengan alamat dompet yang membuat akun masih dapat dilacak dengan menganalisis urutan transaksi dari kontrak pintar.  Sekarang Anda tidak dapat menetapkan authKey dan recoveryKey yang terpisah saat membuat akun.  Namun, jika Anda menyaring kontrak pintar ke arah ini, alamat yang membuat akun tidak harus dikaitkan dengan pemilik akun, yang akan memungkinkan semua orang untuk melindungi anonimitas mereka. </p><br><p>  Untuk interaksi pengguna dengan kontrak pintar, kami membuat halaman web terpisah.  Anda dapat membuat akun di sana, mengubah kuncinya, atau menghapusnya.  Agar berfungsi, pengguna perlu menginstal plugin browser MetaMask.  Jika Anda sudah aktif menggunakan jaringan Ethereum, kemungkinan besar Anda telah menginstal plugin ini, yaitu mayoritas pengguna yang ingin memasuki situs melalui Ethereum tidak akan menemui hambatan tambahan di jalurnya. </p><br><p>  Proses otentikasi pengguna umum menggunakan EtherAuth terlihat seperti ini: </p><br><ul><li>  Situs (backend) berubah menjadi kontrak pintar dan menerima alamat Ethereum pengguna; </li><li>  Situs (backend) menghasilkan dan mengingat beberapa pesan dan meminta pengguna untuk menandatangani pesan ini menggunakan alamat authKey; </li><li>  Pengguna, yang berada di situs (frontend), menandatangani pesan menggunakan plugin MetaMask dan mengirimkannya ke backend; </li><li>  Situs (backend) memverifikasi tanda tangan, dan jika semuanya beres, itu akan mengaktifkan sesi pengguna sesuai dengan logika yang dipilih. </li></ul><br><p>  Dalam solusi kami untuk hackathon, untuk kesederhanaan, kami menggabungkan bagian backend dan frontend, kami mendapat satu frontend besar.  Dalam kehidupan nyata, verifikasi otentikasi harus dilakukan di lingkungan yang tidak dikontrol oleh pengguna, yaitu, bukan di browser, tetapi di server. </p><br><p>  Dari masalah yang kami temui, kami dapat mencatat verifikasi tanda tangan di bagian frontend.  Tidak ada dukungan untuk kurva eliptik di browser, jadi saya harus menambahkan fungsi ke kontrak pintar yang mengembalikan hasil ecrecover dari pesan dan belajar cara menyampaikan parameter ke sana dengan benar (mendapatkannya dari pesan yang ditandatangani oleh MetaMask). </p><br><p>  Sebagai hasilnya, dalam dua hari kami menerima konsep pembuktian otentikasi terdesentralisasi menggunakan jaringan Ethereum dan plugin MetaMask.  Kami memahami cara memperbaiki sistem ini untuk menambahkan anonimitas kepada pengguna.  Pengguna dapat memulihkan akses jika terjadi kebocoran kunci primernya (tetapi tidak jika terjadi kebocoran kunci pemulihan).  Sistem desentralisasi tidak tunduk pada sensor struktur besar seperti Google atau Facebook.  Jika sensor diperlukan, situs harus melakukannya sendiri, tetapi dapat melakukan ini hanya dalam kerangka sistemnya sendiri, tanpa mempengaruhi akses pengguna ke sistem lain.  Jaringan Ethereum tidak melakukan transaksi dengan sangat cepat (saat membuat akun, pengguna mungkin harus menunggu beberapa menit), tetapi dimungkinkan untuk mendapatkan data dan memverifikasi otentikasi pengguna dengan sangat cepat.  Solusi ini berskala baik, karena ada banyak node dengan data, dan siapa pun dapat menambahkan satu lagi kapan saja.  Kompleksitas penerapan solusi semacam itu untuk pemilik situs tidak lebih tinggi dari kompleksitas penerapan dukungan untuk OAuth 2.0. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Tentu saja, saat ini pengguna yang menggunakan jaringan Ethereum dapat diabaikan dibandingkan dengan jumlah pengguna Facebook.  Namun, popularitas teknologi blockchain sedang tumbuh, dan saya percaya bahwa di masa mendatang akan ada semakin banyak pengguna seperti itu, yang berarti akan mungkin untuk menggunakan otentikasi terdesentralisasi dalam sistem industri. </p><br><h1 id="ssylki">  Referensi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423039/">https://habr.com/ru/post/id423039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423025/index.html">Bagaimana program kas menghemat analitik?</a></li>
<li><a href="../id423027/index.html">Transceiver Optik FTDI-POF</a></li>
<li><a href="../id423029/index.html">Laporan Club Club 2018, Bab 3.2: “Alternatif Pengembangan”</a></li>
<li><a href="../id423033/index.html">Mereka terlalu banyak bicara tentang CRM: berurusan dengan gosip</a></li>
<li><a href="../id423035/index.html">Bidang unggahan file yang layak kita terima</a></li>
<li><a href="../id423041/index.html">CD-ROM Super NES Cerita Aneh</a></li>
<li><a href="../id423043/index.html">Karena kerentanan dalam sistem perlindungan kendaraan listrik Tesla, sebuah mobil dapat dicuri dalam beberapa detik</a></li>
<li><a href="../id423045/index.html">Printer 3D mana yang harus dipilih? Ulasan Video 3Dtool</a></li>
<li><a href="../id423047/index.html">Kami memesan sistem TI untuk uang yang masuk akal</a></li>
<li><a href="../id423049/index.html">Proses Pembelajaran di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>