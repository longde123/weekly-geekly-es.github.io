<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÖ üßòüèΩ üßñüèΩ Exchange Sorts ü§πüèæ üë¶üèª üç†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous d√©crivez en quelques phrases sur quel principe les √©changes de tri fonctionnent, alors: 



1. Les √©l√©ments du tableau sont compar√©s par paire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exchange Sorts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414653/"><div style="text-align:center;"><img width="700" height="312" src="https://habrastorage.org/webt/cf/xj/x_/cfxjx_qzr1qqhjmwvqz8eyygnxm.png"></div><br><br>  Si vous d√©crivez en quelques phrases sur quel principe les √©changes de tri fonctionnent, alors: <br><br><ol><li>  Les √©l√©ments du tableau sont compar√©s par paires </li><li>  Si l'√©l√©ment de gauche <sup>* est</sup> plus grand que l'√©l√©ment de droite, les √©l√©ments sont √©chang√©s </li><li>  R√©p√©tez les √©tapes 1-2 jusqu'√† ce que le tableau soit tri√© </li></ol><br>  <sup><em>* - l'√©l√©ment de gauche signifie cet √©l√©ment de la paire compar√©e, qui est plus proche du bord gauche du tableau.</em></sup>  <sup><em>En cons√©quence, l'√©l√©ment de droite est plus proche du bord droit.</em></sup> <br><a name="habracut"></a><br>  Je m'excuse imm√©diatement d'avoir r√©p√©t√© du mat√©riel bien connu, il est peu probable qu'au moins un des algorithmes de l'article soit une r√©v√©lation pour vous.  A propos de ces tris sur Habr√©, il a d√©j√† √©t√© √©crit plusieurs fois (dont moi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> ) et demande pourquoi revenir sur ce sujet?  Mais depuis que j'ai d√©cid√© d'√©crire une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie coh√©rente d'articles sur tous les tris dans le monde</a> , je dois passer par les m√©thodes d'√©change m√™me dans la version express.  Lorsque l'on consid√®re les classes suivantes, il y aura d√©j√† de nombreux nouveaux algorithmes (et peu de gens le savent) qui m√©ritent des articles int√©ressants distincts. <br><br>  Traditionnellement, les ¬´√©changeurs¬ª incluent des triages dans lesquels les √©l√©ments changent (pseudo) al√©atoirement (bogosort, bozosort, permsort, etc.).  Cependant, je ne les ai pas inclus dans cette classe, car ils manquent de comparaisons.  Il y aura un article s√©par√© sur ces triages, o√π nous philosophons beaucoup sur la th√©orie des probabilit√©s, la combinatoire et la mort thermique de l'Univers. <br><br><h1>  Silly Sort :: Sort Stooge </h1><br><img width="342" height="96" src="https://habrastorage.org/web/eb5/6f6/820/eb56f6820b904324a5df67714e2c8866.gif"><br><br><ol><li>  Comparez (et modifiez si n√©cessaire) les √©l√©ments aux extr√©mit√©s du sous-tableau. </li><li>  Nous prenons les deux tiers du sous-tableau depuis son d√©but et appliquons l'algorithme g√©n√©ral √† ces 2/3 de mani√®re r√©cursive. </li><li>  Nous prenons les deux tiers du sous-tableau de sa fin et appliquons l'algorithme g√©n√©ral √† ces 2/3 de mani√®re r√©cursive. </li><li>  Et encore une fois, nous prenons les deux tiers du sous-tableau depuis son d√©but et appliquons l'algorithme g√©n√©ral √† ces 2/3 de mani√®re r√©cursive. </li></ol><br>  Initialement, un sous-tableau est un tableau entier.  Et puis la r√©cursion divise le sous-tableau parent en 2/3, fait des comparaisons / √©changes aux extr√©mit√©s des segments fragment√©s, et finalement arrange tout. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j = None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: j = len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &lt; data[i]: data[i], data[j] = data[j], data[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j - i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: t = (j - i + <span class="hljs-number"><span class="hljs-number">1</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> stooge_rec(data, i, j - t) stooge_rec(data, i + t, j) stooge_rec(data, i, j - t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stooge_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Il a l'air schizophr√®ne, mais il est n√©anmoins 100% correct. <br><br><h1>  Tri lent :: Tri lent </h1><br><img width="342" height="96" src="https://habrastorage.org/web/f31/348/4f5/f313484f5bd44ea09b50e899e3d90548.gif"><br><br>  Et ici, nous observons le mysticisme r√©cursif: <br><br><ol><li>  Si le sous-tableau se compose d'un √©l√©ment, alors nous terminons la r√©cursivit√©. </li><li>  Si un sous-tableau se compose de deux √©l√©ments ou plus, divisez-le en deux. </li><li>  Nous appliquons l'algorithme r√©cursivement √† la moiti√© gauche. </li><li>  Nous appliquons l'algorithme r√©cursivement √† la moiti√© droite. </li><li>  Les √©l√©ments situ√©s aux extr√©mit√©s du sous-tableau sont compar√©s (et modifi√©s si n√©cessaire). </li><li>  Nous appliquons r√©cursivement l'algorithme √† un sous-tableau sans le dernier √©l√©ment. </li></ol><br><br>  Initialement, un sous-tableau est l'ensemble du tableau.  Et la r√©cursivit√© continuera de r√©duire de moiti√©, de comparer et de changer jusqu'√† ce qu'elle trie tout. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i, j)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data m = (i + j) // <span class="hljs-number"><span class="hljs-number">2</span></span> slow_rec(data, i, m) slow_rec(data, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[m] &gt; data[j]: data[m], data[j] = data[j], data[m] slow_rec(data, i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slow_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Cela ressemble √† un non-sens, mais le tableau est ordonn√©. <br><br><h3>  Pourquoi StoogeSort et SlowSort fonctionnent-ils correctement? </h3><br>  Un lecteur curieux posera une question raisonnable: pourquoi ces deux algorithmes fonctionnent-ils m√™me?  Ils semblent simples, mais il n'est pas tr√®s √©vident que vous puissiez trier quelque chose comme √ßa. <br><br>  Jetons d'abord un ≈ìil au tri lent.  Le dernier point de cet algorithme sugg√®re que les efforts r√©cursifs de tri lent ne visent qu'√† placer le plus grand √©l√©ment du sous-tableau dans la position la plus √† droite.  Ceci est particuli√®rement visible si vous appliquez l'algorithme √† un tableau en ordre inverse: <br><br><img width="342" height="96" src="https://habrastorage.org/webt/lk/mx/nu/lkmxnutci_ufoymes6b4rksoqua.gif"><br><br>  On voit clairement qu'√† tous les niveaux de r√©cursivit√©, les maxima migrent rapidement vers la droite.  Ensuite, ces maxima, l√† o√π ils sont l√† o√π ils sont n√©cessaires, sont d√©sactiv√©s du jeu: l'algorithme s'appelle lui-m√™me - mais sans le dernier √©l√©ment. <br><br>  Dans le genre Stooge, une magie similaire se produit: <br><br><img width="672" height="454" src="https://habrastorage.org/webt/d-/pd/vj/d-pdvj8zcvmnlywcedlhkmhyfku.png"><br><br>  En fait, l'accent est √©galement mis sur le maximum d'√©l√©ments.  Seul le tri lent les d√©place vers la fin un par un, et le tri Stooge pousse un tiers des √©l√©ments du sous-tableau (le plus grand d'entre eux) pousse dans le tiers le plus √† droite de l'espace cellulaire. <br><br>  Nous nous tournons vers les algorithmes, o√π tout est d√©j√† assez √©vident. <br><br><h1>  Tri stupide :: Tri stupide </h1><br><img width="336" height="109" src="https://habrastorage.org/webt/sz/i3/hh/szi3hhaimi67d84kjaivphl4a9q.gif"><br><br>  Tri tr√®s soign√©.  Il va du d√©but du tableau √† la fin et compare les √©l√©ments voisins.  Si deux √©l√©ments voisins devaient √™tre √©chang√©s, alors, juste au cas o√π, le tri reviendrait au tout d√©but du tableau et recommencerait √† nouveau. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stupid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; data[i]: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Tri Gnome :: Tri Gnome </h1><br><img width="570" height="95" src="https://habrastorage.org/web/2af/c2a/b73/2afc2ab738d54ca1b65a0bbcac9eaa19.gif"><br><br>  Presque la m√™me chose, mais le tri pendant l'√©change ne revient pas au tout d√©but du tableau, mais ne fait qu'un pas en arri√®re.  Il s'av√®re que cela suffit pour tout r√©gler. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Tri optimis√© des nains </h3><br><img width="570" height="95" src="https://habrastorage.org/web/37c/91c/9fc/37c91c9fcffd4b1a9d1f225171bbdc64.gif"><br><br>  Mais vous pouvez √©conomiser non seulement sur la retraite, mais aussi lorsque vous avancez.  Avec plusieurs √©changes cons√©cutifs, vous devez prendre autant de recul.  Et puis il faut revenir en arri√®re (comparer en cours de route les √©l√©ments d√©j√† ordonn√©s les uns par rapport aux autres).  Si vous vous souvenez de la position √† partir de laquelle les √©changes ont commenc√©, vous pouvez imm√©diatement sauter √† cette position lorsque les √©changes sont termin√©s. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, j, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span>: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Tri des bulles :: Tri des bulles </h1><br><img width="570" height="95" src="https://habrastorage.org/web/b68/67d/5b7/b6867d5b7d064421b5f7b1f6fae6d058.gif"><br><br>  Contrairement au tri stupide et gnome, lors de l'√©change d'√©l√©ments dans la bulle, aucun retour ne se produit - il continue d'avancer.  Atteignant la fin, le plus grand √©l√©ment du tableau est d√©plac√© √† la toute fin. <br><br>  Ensuite, le processus de tri r√©p√®te √† nouveau l'ensemble du processus, ce qui fait que le deuxi√®me √©l√©ment de l'anciennet√© se trouve √† la derni√®re mais √† une seule place.  √Ä l'it√©ration suivante, le troisi√®me √©l√©ment le plus grand est le troisi√®me √† partir de la fin, etc. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> changed: changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Tri optimis√© des bulles </h3><br><img width="570" height="95" src="https://habrastorage.org/web/ca0/9e7/20f/ca09e720f56c417bbbb8204aa8c35a7d.gif"><br><br>  Vous pouvez en profiter un peu dans les all√©es au d√©but du tableau.  Dans le processus, les premiers √©l√©ments sont temporairement ordonn√©s les uns par rapport aux autres (cette partie tri√©e change constamment de taille - elle diminue, elle augmente).  Ceci est facilement corrig√© et avec une nouvelle it√©ration, vous pouvez simplement sauter par-dessus un groupe de ces √©l√©ments. <br>  <sub><em>(J'ajouterai ici l'impl√©mentation test√©e en Python. Je n'ai pas eu le temps de la pr√©parer.)</em></sub> <br><br><br><h1>  Tri Shaker :: Tri Shaker <br>  (Tri cocktail :: Tri cocktail) </h1><br><img width="570" height="95" src="https://habrastorage.org/web/616/739/0f8/6167390f8005452e8dbcbeeacb5c95fc.gif"><br><br>  Une sorte de bulle.  Au premier passage, comme d'habitude - poussez le maximum jusqu'√† la fin.  Ensuite, nous nous retournons brusquement et poussons le minimum au d√©but.  Les zones marginales tri√©es du tableau augmentent en taille apr√®s chaque it√©ration. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> up = range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (up, reversed(up)): swapped = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] swapped = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> swapped: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Tri pair-impair :: Tri pair-impair </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yn/9t/oy/yn9toy8yjzuud4azxdffcb-6mwm.gif"><br><br>  Encore une fois, it√©rations sur la comparaison par paire d'√©l√©ments voisins lors du d√©placement de gauche √† droite.  Tout d'abord, nous comparons les paires dans lesquelles le premier √©l√©ment est impair en comptage, et le second est pair (c'est-√†-dire les premier et deuxi√®me, troisi√®me et quatri√®me, cinqui√®me et sixi√®me, etc.).  Et puis vice versa - pair + impair (deuxi√®me et troisi√®me, quatri√®me et cinqui√®me, sixi√®me et septi√®me, etc.).  Dans ce cas, de nombreux grands √©l√©ments du tableau √† une m√™me it√©ration font un pas en avant (dans la bulle, le plus grand pour l'it√©ration atteint la fin, mais le reste des assez gros reste presque en place). <br><br>  Soit dit en passant, il s'agissait √† l'origine d'un tri parall√®le avec une complexit√© O (n).  Il sera n√©cessaire d'impl√©menter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AlgoLab</a> dans la section "Tri parall√®le". <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd_even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> n = len(data) isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isSorted == <span class="hljs-number"><span class="hljs-number">0</span></span>: isSorted = <span class="hljs-number"><span class="hljs-number">1</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Tri par peigne :: Tri par peigne </h1><br><img width="570" height="95" src="https://habrastorage.org/web/52f/41b/2fb/52f41b2fbd024cf8b9dfdba8d0dbd239.gif"><br><br>  La modification la plus r√©ussie de la bulle.  L'algorithme de vitesse est en concurrence avec un tri rapide. <br><br>  Dans toutes les variantes pr√©c√©dentes, nous avons compar√© les voisins.  Et ici, tout d'abord, on consid√®re des paires d'√©l√©ments qui sont √† une distance maximale les unes des autres.  √Ä chaque nouvelle it√©ration, cette distance se r√©tr√©cit uniform√©ment. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> gap = len(data) swaps = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> gap &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swaps: gap = max(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(gap / <span class="hljs-number"><span class="hljs-number">1.25</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># minimum gap is 1 swaps = False for i in range(len(data) - gap): j = i + gap if data[i] &gt; data[j]: data[i], data[j] = data[j], data[i] swaps = True return data</span></span></code> </pre> <br><br><h1>  Tri rapide :: Tri rapide </h1><br><img width="684" height="95" src="https://habrastorage.org/webt/b1/xb/ve/b1xbvefydxsfynp91mnxaxluvfe.gif"><br><br>  Eh bien, l'algorithme d'√©change le plus avanc√©. <br><br><ol><li>  Divisez le tableau en deux.  L'√©l√©ment du milieu est la r√©f√©rence. </li><li>  Nous nous d√©pla√ßons du bord gauche du tableau vers la droite, jusqu'√† ce que nous trouvions un √©l√©ment plus grand que celui de r√©f√©rence. </li><li>  Nous nous d√©pla√ßons du bord droit du tableau vers la gauche jusqu'√† ce que nous trouvions un √©l√©ment plus petit que celui de r√©f√©rence. </li><li>  Nous √©changeons les deux √©l√©ments trouv√©s aux points 2 et 3. </li><li>  Nous continuons d'ex√©cuter les points 2-3-4 jusqu'√† ce qu'une r√©union ait lieu √† la suite du mouvement mutuel. </li><li>  Au point de rencontre, le r√©seau est divis√© en deux parties.  Pour chaque partie, nous appliquons r√©cursivement un algorithme de tri rapide. </li></ol><br>  Pourquoi √ßa marche?  √Ä gauche du point de rencontre se trouvent des √©l√©ments plus petits ou √©gaux √† celui de r√©f√©rence.  √Ä droite du point de rencontre se trouvent des √©l√©ments sup√©rieurs ou √©gaux √† la r√©f√©rence.  En d'autres termes, tout √©l√©ment du c√¥t√© gauche est inf√©rieur ou √©gal √† tout √©l√©ment du c√¥t√© droit.  Par cons√©quent, au point de rencontre, le tableau peut √™tre divis√© en deux sous-r√©seaux en toute s√©curit√© et trier chaque sous-r√©seau de mani√®re similaire de mani√®re r√©cursive. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> less = [] pivotList = [] more = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivot = data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; pivot: less.append(i) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i &gt; pivot: more.append(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivotList.append(i) less = quick(less) more = quick(more) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> less + pivotList + more</code> </pre> <br><br><h1>  K-sort :: K-sort </h1><br>  Sur Habr√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une traduction de l'</a> un des articles est publi√©e, qui rend compte de la modification de QuickSort, qui surpasse le tri pyramidal de 7 millions d'√©l√©ments.  Soit dit en passant, c'est en soi une r√©alisation douteuse, car le tri pyramidal classique ne bat pas les records de performance.  En particulier, sa complexit√© asymptotique n'atteint en aucun cas O (n) (une caract√©ristique de cet algorithme). <br><br>  Mais la chose est diff√©rente.  Selon le pseudo-code de l'auteur (et √©videmment incorrect), il n'est g√©n√©ralement pas possible de comprendre quelle est, en fait, l'id√©e principale de l'algorithme.  Personnellement, j'ai eu l'impression que les auteurs sont des escrocs qui ont agi selon cette m√©thode: <br><ol><li>  Nous d√©clarons l'invention d'un algorithme de super-tri. </li><li>  Nous renfor√ßons la d√©claration avec un pseudo-code non fonctionnel et incompr√©hensible (comme, intelligent et si clair, mais les imb√©ciles ne peuvent toujours pas comprendre). </li><li>  Nous pr√©sentons des graphiques et des tableaux qui d√©montreraient la vitesse pratique de l'algorithme sur les m√©gadonn√©es.  En raison du manque de code r√©ellement fonctionnel, personne ne pourra toujours v√©rifier ou r√©futer ces calculs statistiques. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Nous publions des non-sens</a> sur Arxiv.org sous le couvert d'un article scientifique. </li><li>  PROFIT !!! </li></ol><br>  Peut-√™tre que je parle en vain aux gens et qu'en fait l'algorithme fonctionne?  Quelqu'un peut-il expliquer le fonctionnement de k-sort? <br><br>  <strong>UPD</strong>  <strong>Mes accusations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">massives</a> de tri des auteurs de fraude se sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">av√©r√©es</a> sans fondement :) L'utilisateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">jetsys a</a> compris le pseudo-code de l'algorithme, a √©crit une version de travail en PHP et me l'a envoy√© dans des messages priv√©s:</strong> <br><br><div class="spoiler">  <b class="spoiler_title">K-sort en PHP</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a,$left,$right)</span></span></span></span>{ $ke=$a[$left]; $i=$left; $j=$right+<span class="hljs-number"><span class="hljs-number">1</span></span>; $k=$p=$left+<span class="hljs-number"><span class="hljs-number">1</span></span>; $temp=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j-$i&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($ke&lt;=$a[$p]){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($p!=$j) &amp;&amp; ($j!=($right+<span class="hljs-number"><span class="hljs-number">1</span></span>))){ $a[$j]=$a[$p]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($j==($right+<span class="hljs-number"><span class="hljs-number">1</span></span>)){ $temp=$a[$p]; } $j--; $p=$j; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a[$i]=$a[$p]; $i++; $k++; $p=$k; } } $a[$i]=$ke; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($temp) $a[$i+<span class="hljs-number"><span class="hljs-number">1</span></span>]=$temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($left&lt;($i<span class="hljs-number"><span class="hljs-number">-1</span></span>)) _ksort($a,$left,$i<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($right&gt;($i+<span class="hljs-number"><span class="hljs-number">1</span></span>)) _ksort($a,$i+<span class="hljs-number"><span class="hljs-number">1</span></span>,$right); }</code> </pre> </div></div><br><br><h2>  Annonce </h2><br>  Ce n'√©tait qu'une th√©orie, il est temps de passer √† la pratique.  L'article suivant teste les √©changes de tri sur diff√©rents ensembles de donn√©es.  Nous d√©couvrirons: <br><br><ul><li>  Quel tri est le pire - idiot, terne ou terne? </li><li>  Les optimisations et les modifications apport√©es au tri des bulles sont-elles vraiment utiles? </li><li>  Dans quelles conditions les algorithmes lents sont-ils facilement rapides en vitesse de QuickSort? </li></ul><br><br>  Et lorsque nous trouvons les r√©ponses √† ces questions les plus importantes, nous pouvons commencer √† √©tudier la classe suivante - les types d'insertion. <br><br><h1>  Les r√©f√©rences </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application Excel AlgoLab</a> , avec laquelle vous pouvez visualiser √©tape par √©tape la visualisation de ces (et pas seulement de ces) sortes. <br><br>  <b>Wiki /</b> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Stupide</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Stooge</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Lent</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Nain</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Gnome</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Bulle</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Bulle</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Shaker</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Shaker</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Impair</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Pair</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Peigne</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Peigne</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Rapide</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Rapide</a></nobr> <br><br><h3>  Articles de la s√©rie </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application Excel AlgoLab.xlsm</a> </li><li>  <b>Exchange Sorts</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comparaison de tri Exchange</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri d'insertion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par s√©lection</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusionner les tris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par distribution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri hybride</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414653/">https://habr.com/ru/post/fr414653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414639/index.html">Services de piratage sur le dark Internet</a></li>
<li><a href="../fr414641/index.html">Apprivoiser XBRL: Notes d'analyste</a></li>
<li><a href="../fr414643/index.html">Codage de la boutique: les gagnants du hackathon M.SMART</a></li>
<li><a href="../fr414645/index.html">ONETRAK - bracelets intelligents et plus</a></li>
<li><a href="../fr414651/index.html">Scanner 3D Shining 3D Einscan SE. Pr√©sentation du scanner 3D</a></li>
<li><a href="../fr414655/index.html">Routeur virtuel DD-WRT x86 sur VirtualBox</a></li>
<li><a href="../fr414657/index.html">Protocole AMF3 dangereux</a></li>
<li><a href="../fr414661/index.html">Le lanceur Soyouz-5SL fonctionnera avec des moteurs de style sovi√©tique</a></li>
<li><a href="../fr414663/index.html">√âpuisement professionnel: un mot aux experts</a></li>
<li><a href="../fr414667/index.html">[Th√®me mini fan] Table des championnats de la FIFA dans le terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>