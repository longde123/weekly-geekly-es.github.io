<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ğŸ½ ğŸ¤šğŸ» ğŸ‘– Pengembangan kelas antarmuka di C ++ ğŸŒ³ ğŸ‘¨ğŸ»â€âœˆï¸ ğŸš‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kelas antarmuka sangat banyak digunakan dalam program C ++. Namun, sayangnya, sering terjadi kesalahan saat mengimplementasikan solusi berdasarkan kel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan kelas antarmuka di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>Kelas antarmuka sangat banyak digunakan dalam program C ++.</i>  <i>Namun, sayangnya, sering terjadi kesalahan saat mengimplementasikan solusi berdasarkan kelas antarmuka.</i>  <i>Artikel ini menjelaskan cara mendesain kelas antarmuka dengan benar, beberapa opsi dipertimbangkan.</i>  <i>Penggunaan pointer cerdas dijelaskan secara rinci.</i>  <i>Contoh implementasi kelas pengecualian dan templat kelas koleksi berdasarkan kelas antarmuka diberikan.</i> </p><hr><br><a name="habracut"></a><br><h1>  Daftar isi </h1><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Fungsi anggota khusus, membuat dan menghapus objek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi Anggota Khusus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat dan menghapus objek - detail dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tingkat akses destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buat dan hapus dalam satu modul</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghapusan polimorfik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghapusan dengan deklarasi kelas yang tidak lengkap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Murni fungsi virtual dan kelas abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi virtual murni</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Destructor virtual murni</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Kelas antarmuka</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penciptaan Obyek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hapus objek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan operator hapus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan fungsi virtual khusus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan fungsi eksternal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hapus otomatis menggunakan smart pointer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsi lain untuk mengelola masa instance dari kelas implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salin semantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konstruktor kelas antarmuka</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi dua arah</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pointer pintar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi anggota yang konstan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antarmuka COM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas antarmuka dan pustaka</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Contoh kelas antarmuka dan implementasinya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas antarmuka</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk pintar standar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan Sisi Klien</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan Sisi Implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi kelas dasar alternatif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Pengecualian dan koleksi diimplementasikan menggunakan kelas antarmuka</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.1 Pengecualian</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.2 Koleksi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Kelas antarmuka dan kelas pembungkus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Ringkasan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Pendahuluan </h1><br><p>  Kelas antarmuka adalah kelas yang tidak memiliki data dan sebagian besar terdiri dari fungsi virtual murni.  Solusi ini memungkinkan Anda untuk benar-benar memisahkan implementasi dari antarmuka - klien menggunakan kelas antarmuka - di tempat lain kelas turunan dibuat di mana fungsi virtual murni didefinisikan ulang dan fungsi pabrik didefinisikan.  Detail implementasi sepenuhnya tersembunyi dari klien.  Dengan cara ini, enkapsulasi benar diimplementasikan, yang tidak mungkin dengan kelas biasa.  Anda dapat membaca tentang kelas antarmuka dari Scott Meyers [Meyers2].  Kelas antarmuka juga disebut kelas protokol. </p><br><p>  Menggunakan kelas antarmuka memungkinkan Anda untuk melemahkan ketergantungan antara berbagai bagian proyek, yang menyederhanakan pengembangan tim dan mengurangi waktu kompilasi / perakitan.  Kelas antarmuka membuatnya lebih mudah untuk mengimplementasikan solusi dinamis dan fleksibel ketika modul dimuat secara selektif saat runtime.  Menggunakan kelas antarmuka sebagai perpustakaan antarmuka (API) (SDK) menyederhanakan solusi masalah kompatibilitas biner. </p><br><p>  Kelas antarmuka digunakan cukup luas, dengan bantuan mereka mengimplementasikan antarmuka (API) perpustakaan (SDK), antarmuka plug-in (plugin) dan banyak lagi.  Banyak pola Gang of Four [GoF] secara alami diimplementasikan menggunakan kelas antarmuka.  Kelas antarmuka termasuk antarmuka COM.  Namun, sayangnya, sering terjadi kesalahan saat mengimplementasikan solusi berdasarkan kelas antarmuka.  Mari kita coba memperjelas masalah ini. </p><br><a name="id-1"></a><br><h1>  1. Fungsi anggota khusus, membuat dan menghapus objek </h1><br><p>  Bagian ini menjelaskan secara singkat sejumlah fitur C ++ yang perlu Anda ketahui untuk memahami sepenuhnya solusi yang ditawarkan untuk kelas antarmuka. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Fungsi Anggota Khusus </h2><br><p>  Jika programmer tidak mendefinisikan fungsi anggota kelas dari daftar berikut - konstruktor default, copy constructor, operator penugasan copy, destructor - maka kompiler dapat melakukan ini untuknya.  C ++ 11 menambahkan move constructor dan operator penugasan move ke daftar ini.  Fungsi anggota ini disebut fungsi anggota khusus.  Mereka dihasilkan hanya jika digunakan, dan kondisi tambahan khusus untuk setiap fungsi terpenuhi.  Kami menarik perhatian pada fakta bahwa penggunaan ini ternyata cukup tersembunyi (misalnya, ketika menerapkan warisan).  Jika fungsi yang diperlukan tidak dapat dibuat, kesalahan dihasilkan.  (Dengan pengecualian operasi relokasi, mereka digantikan oleh operasi penyalinan.) Fungsi anggota yang dihasilkan oleh kompilator bersifat publik dan dapat di-embed. </p><br><p>  Fungsi anggota khusus tidak diwariskan, jika fungsi anggota khusus diperlukan di kelas turunan, kompiler akan selalu mencoba untuk menghasilkannya, keberadaan fungsi anggota terkait yang didefinisikan di kelas dasar oleh pemrogram tidak memengaruhi hal ini. </p><br><p> Programmer dapat melarang pembuatan fungsi anggota khusus, dalam C ++ 11 perlu menggunakan konstruk <code>"=delete"</code> ketika mendeklarasikan, dalam C ++ 98 mendeklarasikan fungsi anggota terkait pribadi dan tidak mendefinisikan.  Dalam pewarisan kelas, larangan menghasilkan fungsi anggota khusus yang dibuat di kelas dasar berlaku untuk semua kelas turunan. </p><br><p>  Jika pemrogram merasa nyaman dengan fungsi anggota yang dihasilkan oleh kompiler, maka dalam C ++ 11 ia dapat menunjukkan ini secara eksplisit, dan tidak hanya menjatuhkan deklarasi.  Untuk melakukan ini, Anda harus menggunakan konstruksi <code>"=default"</code> ketika mendeklarasikan, sementara kode lebih baik dibaca dan fitur tambahan yang terkait dengan manajemen tingkat akses muncul. </p><br><p>  Detail tentang fungsi anggota khusus dapat ditemukan di [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Membuat dan menghapus objek - detail dasar </h2><br><p>  Membuat dan menghapus objek menggunakan operator <code>new/delete</code> adalah operasi dua-dalam-satu yang khas.  Saat memanggil <code>new</code> , memori pertama dialokasikan untuk objek.  Jika seleksi berhasil, konstruktor dipanggil.  Jika konstruktor melempar pengecualian, maka memori yang dialokasikan dibebaskan.  Ketika operator <code>delete</code> dipanggil, semuanya terjadi dalam urutan terbalik: pertama, destruktor dipanggil, lalu memori dibebaskan.  Destruktor seharusnya tidak melempar pengecualian. </p><br><p>  Jika operator <code>new</code> digunakan untuk membuat array objek, maka memori pertama dialokasikan untuk seluruh array.  Jika seleksi berhasil, maka konstruktor default dipanggil untuk setiap elemen array mulai dari nol.  Jika ada konstruktor yang melempar pengecualian, maka untuk semua elemen array yang dibuat, destruktor dipanggil dalam urutan terbalik dari panggilan konstruktor, maka memori yang dialokasikan akan dibebaskan.  Untuk menghapus array, Anda harus memanggil operator <code>delete[]</code> (disebut operator <code>delete</code> untuk array), dan untuk semua elemen array, destructor disebut dalam urutan terbalik dari konstruktor, kemudian memori yang dialokasikan dibebaskan. </p><br><p>  Perhatian!  Anda harus memanggil bentuk yang benar dari operator <code>delete</code> , tergantung pada apakah satu objek atau array dihapus.  Aturan ini harus dipatuhi dengan ketat, jika tidak Anda bisa mendapatkan perilaku yang tidak terdefinisi, yaitu, apa pun bisa terjadi: kebocoran memori, kerusakan, dll.  Lihat [Meyers2] untuk detailnya. </p><br><p>  Fungsi alokasi memori standar <code>std::bad_alloc</code> memenuhi permintaan melempar pengecualian tipe <code>std::bad_alloc</code> . </p><br><p>  Aman untuk menerapkan segala bentuk operator <code>delete</code> ke pointer nol. </p><br><p>  Dalam uraian di atas, satu klarifikasi diperlukan.  Untuk yang disebut tipe sepele (tipe bawaan, struktur gaya C), konstruktor mungkin tidak dipanggil, dan destruktor tidak melakukan apa pun dalam hal apa pun.  Lihat juga bagian 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Tingkat akses destruktor </h2><br><p>  Ketika operator <code>delete</code> diterapkan ke pointer ke kelas, destruktor kelas itu harus tersedia di titik panggilan <code>delete</code> .  (Ada beberapa pengecualian untuk aturan ini, dibahas di Bagian 1.6.) Dengan demikian, dengan membuat destruktor aman atau tertutup, programmer melarang penggunaan operator <code>delete</code> mana destruktor tidak tersedia.  Ingatlah bahwa jika tidak ada destruktor didefinisikan di kelas, kompiler akan melakukan ini sendiri, dan destruktor ini akan terbuka (lihat bagian 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  Buat dan hapus dalam satu modul </h2><br><p>  Jika operator <code>new</code> membuat objek, maka operator <code>delete</code> harus dalam modul yang sama untuk <code>delete</code> .  Secara kiasan, "letakkan di mana Anda membawanya."  Aturan ini terkenal, lihat, misalnya, [Sutter / Alexandrescu].  Jika aturan ini dilanggar, â€œketidakcocokanâ€ fungsi mengalokasikan dan membebaskan memori dapat terjadi, yang, sebagai suatu peraturan, mengarah pada penghentian program yang tidak normal. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Penghapusan polimorfik </h2><br><p>  Jika Anda mendesain hierarki kelas polimorfik yang instansnya dihapus menggunakan operator <code>delete</code> , maka harus ada destruktor virtual terbuka di kelas dasar, ini memastikan bahwa destruktor tipe objek yang sebenarnya dipanggil ketika operator <code>delete</code> diterapkan pada pointer ke kelas dasar.  Jika aturan ini dilanggar, panggilan ke destruktor kelas dasar dapat terjadi, yang dapat menyebabkan kebocoran sumber daya. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Menghapus ketika deklarasi kelas tidak lengkap </h2><br><p>  Omnivora dari operator <code>delete</code> dapat menciptakan masalah tertentu, dapat diterapkan pada pointer bertipe <code>void*</code> atau ke pointer ke kelas yang memiliki deklarasi tidak lengkap (preemptive).  Dalam hal ini, kesalahan tidak terjadi, hanya panggilan ke destruktor dilewati, hanya fungsi untuk membebaskan memori yang dipanggil.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Kode ini mengkompilasi bahkan jika deklarasi kelas <code>X</code> penuh tidak tersedia di peer panggilan <code>delete</code> .  Benar, saat mengkompilasi (Visual Studio) peringatan dikeluarkan: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  Jika ada implementasi <code>X</code> dan <code>CreateX()</code> , maka kode tersebut <code>CreateX()</code> , jika <code>CreateX()</code> mengembalikan pointer ke objek yang dibuat oleh operator <code>new</code> , maka panggilan <code>Foo()</code> berhasil dieksekusi, destructor tidak dipanggil.  Jelas bahwa ini dapat menyebabkan sumber daya terkuras, jadi sekali lagi tentang perlunya berhati-hati tentang peringatan. </p><br><p>  Situasi ini tidak terlalu mengada-ada, ia dapat dengan mudah muncul ketika menggunakan kelas-kelas seperti smart pointer atau kelas deskriptor.  Scott Meyers menangani masalah ini di [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Murni fungsi virtual dan kelas abstrak </h1><br><p>  Konsep kelas antarmuka didasarkan pada konsep C ++ seperti fungsi virtual murni dan kelas abstrak. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Fungsi virtual murni </h2><br><p>  Fungsi virtual yang dideklarasikan menggunakan konstruk <code>"=0"</code> disebut virtual murni. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  Tidak seperti fungsi virtual biasa, fungsi virtual murni tidak dapat didefinisikan (dengan pengecualian destruktor, lihat bagian 2.3), tetapi harus didefinisikan ulang di salah satu kelas turunan. </p><br><p>  Fungsi virtual murni dapat didefinisikan.  Emblem Sutter menawarkan beberapa kegunaan yang bermanfaat untuk fitur ini [Bidik]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Kelas abstrak </h2><br><p>  Kelas abstrak adalah kelas yang memiliki setidaknya satu fungsi virtual murni.  Kelas yang diturunkan dari kelas abstrak dan tidak menimpa setidaknya satu fungsi virtual murni juga akan abstrak.  Standar C ++ melarang membuat instance dari kelas abstrak, Anda hanya dapat membuat instance turunan dari kelas non-abstrak.  Dengan demikian, kelas abstrak dibuat untuk digunakan sebagai kelas dasar.  Dengan demikian, jika konstruktor didefinisikan dalam kelas abstrak, maka tidak masuk akal untuk membuatnya terbuka, itu harus dilindungi. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Destructor virtual murni </h2><br><p>  Dalam beberapa kasus, disarankan untuk membuat destruktor virtual murni.  Tetapi solusi ini memiliki dua fitur. </p><br><ol><li>  Destructor murni virtual harus didefinisikan.  (Definisi default biasanya digunakan, yaitu, menggunakan konstruksi <code>"=default"</code> .) Destructor kelas turunan memanggil destruktor kelas dasar di sepanjang seluruh rantai pewarisan dan, oleh karena itu, antrian dijamin untuk mencapai root - sebuah destruktor murni virtual. </li><li>  Jika programmer belum mendefinisikan ulang destruktor virtual murni di kelas turunan, kompiler akan melakukannya untuknya (lihat bagian 1.1).  Dengan demikian, kelas yang berasal dari kelas abstrak dengan destruktor virtual murni dapat kehilangan abstraknya tanpa secara eksplisit menimpa destruktor. </li></ol><br><p>  Contoh menggunakan destruktor virtual murni dapat ditemukan di bagian 4.4. </p><br><a name="id-3"></a><br><h1>  3. Kelas antarmuka </h1><br><p>  Kelas antarmuka adalah kelas abstrak yang tidak memiliki data dan sebagian besar terdiri dari fungsi virtual murni.  Kelas semacam itu dapat memiliki fungsi virtual biasa (bukan murni virtual), misalnya, sebuah destruktor.  Mungkin juga ada fungsi anggota statis, seperti fungsi pabrik. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implementasi </h2><br><p>  Implementasi kelas antarmuka akan disebut kelas turunan di mana fungsi virtual murni didefinisikan ulang.  Mungkin ada beberapa implementasi dari kelas antarmuka yang sama, dan dua skema dimungkinkan: horisontal, ketika beberapa kelas berbeda mewarisi kelas antarmuka yang sama, dan vertikal, ketika kelas antarmuka adalah akar dari hierarki polimorfik.  Tentu saja, mungkin ada hibrida. </p><br><p>  Poin kunci dari konsep kelas antarmuka adalah pemisahan lengkap antarmuka dari implementasi - klien hanya bekerja dengan kelas antarmuka, implementasi tidak tersedia untuk itu. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Penciptaan Obyek </h2><br><p>  Tidak dapat diaksesnya kelas implementasi menyebabkan masalah tertentu saat membuat objek.  Klien harus membuat turunan dari kelas implementasi dan mendapatkan pointer ke kelas antarmuka di mana objek akan diakses.  Karena kelas implementasi tidak tersedia, Anda tidak dapat menggunakan konstruktor, oleh karena itu, fungsi pabrik digunakan, yang didefinisikan pada sisi implementasi.  Fungsi ini biasanya membuat objek menggunakan operator <code>new</code> dan mengembalikan pointer ke objek yang dibuat, dilemparkan ke pointer ke kelas antarmuka.  Fungsi pabrik dapat menjadi anggota statis dari kelas antarmuka, tetapi ini tidak perlu, misalnya, dapat menjadi anggota kelas pabrik khusus (yang, pada gilirannya, dapat dengan sendirinya menjadi kelas antarmuka) atau fungsi bebas.  Fungsi pabrik tidak dapat mengembalikan pointer mentah ke kelas antarmuka, tetapi yang cerdas.  Opsi ini dibahas di bagian 3.3.4 dan 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Hapus objek </h2><br><p>  Menghapus objek adalah operasi yang sangat kritis.  Kesalahan menghasilkan kebocoran memori atau penghapusan ganda, yang biasanya menyebabkan crash program.  Di bawah masalah ini dianggap sedetail mungkin, dengan banyak perhatian diberikan pada pencegahan tindakan pelanggan yang salah. </p><br><p>  Ada empat opsi utama: </p><br><ol><li>  Menggunakan operator <code>delete</code> . </li><li>  Menggunakan fungsi virtual khusus. </li><li>  Menggunakan fungsi eksternal. </li><li>  Hapus otomatis menggunakan smart pointer. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1.  Menggunakan operator <code>delete</code> <br></h3><br><p>  Untuk melakukan ini, Anda harus memiliki destruktor virtual terbuka di kelas antarmuka.  Dalam hal ini, operator <code>delete</code> , menyerukan pointer ke kelas antarmuka di sisi klien, menyediakan panggilan ke destruktor dari kelas implementasi.  Opsi ini mungkin berfungsi, tetapi sulit untuk mengenalinya sebagai berhasil.  Kami mendapat panggilan dari operator <code>new</code> dan <code>delete</code> di sisi yang berbeda dari "penghalang", <code>new</code> di sisi implementasi, <code>delete</code> di sisi klien.  Dan jika implementasi kelas antarmuka dilakukan dalam modul terpisah (yang merupakan hal yang cukup umum), maka kita mendapatkan pelanggaran aturan dari bagian 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Menggunakan fungsi virtual khusus </h3><br><p>  Lebih progresif adalah pilihan lain: kelas antarmuka harus memiliki fungsi virtual khusus yang menghapus objek.  Fungsi seperti itu, pada akhirnya, turun ke memanggil <code>delete this</code> , tetapi ini sudah terjadi di sisi implementasi.  Fungsi seperti itu dapat dipanggil dengan berbagai cara, misalnya, <code>Delete()</code> , tetapi opsi lain juga digunakan: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , <code>Close()</code> , dll.  Selain mengikuti aturan di bagian 1.4, opsi ini memiliki beberapa keunggulan tambahan. </p><br><ol><li>  Memungkinkan Anda menggunakan fungsi alokasi / deallokasi memori yang ditentukan pengguna untuk kelas implementasi. </li><li>  Memungkinkan Anda menerapkan skema yang lebih kompleks untuk mengontrol masa pakai objek implementasi, misalnya, menggunakan penghitung referensi. </li></ol><br><p>  Dalam perwujudan ini, upaya untuk menghapus objek menggunakan operator <code>delete</code> dapat dikompilasi dan bahkan dilakukan, tetapi ini adalah kesalahan.  Untuk mencegahnya di kelas antarmuka, cukup memiliki destructor yang kosong atau murni virtual (lihat bagian 1.3).  Perhatikan bahwa penggunaan operator <code>delete</code> bisa sangat tertutup, misalnya, pointer cerdas standar menggunakan operator hapus untuk menghapus objek secara default dan kode yang sesuai sangat terkubur dalam implementasinya.  Destructor yang dilindungi memungkinkan Anda untuk mendeteksi semua upaya tersebut pada tahap kompilasi. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3.  Menggunakan fungsi eksternal </h3><br><p>  Opsi ini dapat menarik simetri tertentu prosedur untuk membuat dan menghapus objek, tetapi pada kenyataannya tidak memiliki kelebihan dibandingkan versi sebelumnya, tetapi ada banyak masalah tambahan.  Opsi ini tidak direkomendasikan untuk digunakan dan tidak dipertimbangkan di masa mendatang. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4.  Hapus otomatis menggunakan smart pointer </h3><br><p>  Dalam hal ini, fungsi pabrik tidak mengembalikan pointer mentah ke kelas antarmuka, tetapi pointer pintar yang sesuai.  Pointer pintar ini dibuat di sisi implementasi dan merangkum objek penghapusan, yang secara otomatis menghapus objek implementasi ketika pointer pintar (atau salinan terakhirnya) keluar dari ruang lingkup di sisi klien.  Dalam hal ini, fungsi virtual khusus untuk menghapus objek implementasi mungkin tidak diperlukan, tetapi destruktor yang dilindungi masih diperlukan, perlu untuk mencegah penggunaan yang salah dari operator <code>delete</code> .  (Benar, harus dicatat bahwa kemungkinan kesalahan seperti itu terasa berkurang.) Pilihan ini dibahas lebih rinci dalam Bagian 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Opsi lain untuk mengelola masa instance dari kelas implementasi </h2><br><p>  Dalam beberapa kasus, klien dapat menerima pointer ke kelas antarmuka, tetapi tidak memilikinya.  Manajemen seumur hidup objek implementasi sepenuhnya di sisi implementasi.  Sebagai contoh, suatu objek dapat menjadi objek tunggal statis (solusi ini khas untuk pabrik).  Contoh lain terkait dengan interaksi dua arah, lihat bagian 3.7.  Klien tidak boleh menghapus objek seperti itu, tetapi destruktor yang dilindungi untuk kelas antarmuka seperti itu diperlukan, perlu untuk mencegah penggunaan yang salah dari operator <code>delete</code> . </p><br><a name="id-3-5"></a><br><h2>  3.5.  Salin semantik </h2><br><p>  Untuk kelas antarmuka, membuat salinan objek implementasi menggunakan copy constructor tidak dimungkinkan, jadi jika menyalin diperlukan, maka kelas harus memiliki fungsi virtual yang membuat salinan objek implementasi dan mengembalikan pointer ke kelas antarmuka.  Fungsi seperti ini sering disebut konstruktor virtual, dan nama tradisionalnya adalah <code>Clone()</code> atau <code>Duplicate()</code> . </p><br><p>  Menggunakan operator penugasan salinan tidak dilarang, tetapi tidak dapat dianggap sebagai ide yang baik.  Operator penugasan salinan selalu dipasangkan, harus dipasangkan dengan konstruktor salin.  Operator yang dihasilkan oleh kompiler default tidak ada artinya, ia tidak melakukan apa-apa.  Secara teoritis, Anda dapat mendeklarasikan operator penugasan murni virtual, diikuti dengan mengesampingkan, tetapi penugasan virtual bukan praktik yang disarankan; rincian dapat ditemukan di [Meyers1].  Selain itu, penugasan terlihat sangat tidak wajar: akses ke objek dari kelas implementasi biasanya dilakukan melalui pointer ke kelas antarmuka, sehingga penugasan akan terlihat seperti ini: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  Operator penugasan sebaiknya dilarang, dan jika perlu, semantik tersebut memiliki fungsi virtual yang sesuai di kelas antarmuka. </p><br><p>  Ada dua cara untuk melarang penugasan. </p><br><ol><li>  Nyatakan operator tugas yang dihapus ( <code>=delete</code> ).  Jika kelas antarmuka membentuk hierarki, maka ini cukup untuk dilakukan di kelas dasar.  Kerugian dari metode ini adalah bahwa hal itu mempengaruhi kelas implementasi, larangan juga berlaku untuk itu. </li><li>  Nyatakan pernyataan tugas yang dilindungi dengan definisi default ( <code>=default</code> ).  Ini tidak mempengaruhi kelas implementasi, tetapi dalam kasus hirarki kelas antarmuka, pengumuman seperti itu harus dibuat di setiap kelas. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Konstruktor kelas antarmuka </h2><br><p>  Seringkali, konstruktor dari kelas antarmuka tidak dideklarasikan.  Dalam hal ini, kompiler menghasilkan konstruktor default yang diperlukan untuk mengimplementasikan warisan (lihat bagian 1.1).  Konstruktor ini terbuka, meskipun cukup aman.  Jika dalam kelas antarmuka konstruktor penyalinan dinyatakan dihapus ( <code>=delete</code> ), maka pembangkitan oleh kompilator konstruktor ditekan secara default, dan konstruktor tersebut harus dinyatakan secara eksplisit.  Wajar untuk membuatnya aman dengan definisi default ( <code>=default</code> ).  Pada prinsipnya, deklarasi konstruktor yang dilindungi seperti itu selalu dapat dilakukan.  Contohnya ada di bagian 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Interaksi dua arah </h2><br><p>  Kelas antarmuka nyaman untuk menggunakan komunikasi dua arah.  Jika beberapa modul dapat diakses melalui kelas antarmuka, maka klien juga dapat membuat implementasi dari beberapa kelas antarmuka dan meneruskan pointer ke mereka dalam modul.  Melalui petunjuk ini, modul dapat menerima layanan dari klien dan juga mengirimkan data atau pemberitahuan ke klien. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Pointer pintar </h2><br><p>  Karena akses ke objek dari kelas implementasi biasanya dilakukan melalui pointer, wajar untuk menggunakan pointer pintar untuk mengontrol masa hidup mereka.  Tetapi harus diingat bahwa jika opsi kedua untuk menghapus objek digunakan, maka dengan smart pointer standar perlu untuk mentransfer pengguna deleter (tipe) atau instance dari tipe ini.  Jika ini tidak dilakukan, maka penunjuk pintar akan menggunakan operator hapus untuk menghapus objek, dan kode tidak akan dikompilasi (terima kasih kepada destruktor yang dilindungi).  Pointer pintar standar (termasuk penggunaan penghilang kustom) dibahas secara rinci dalam [Josuttis], [Meyers3].  Contoh menggunakan penghapus khusus dapat ditemukan di bagian 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2> 3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2> 3.10. COM- </h2><br><p> COM-    ,     ,  COM â€”      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2> 3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> â€”  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> â€”  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> â€”  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     â€” -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4.     </h2><br><p>    C#  Java  C++    Â«Â»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       â€” .NET â€”  , â€”          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. Metode desain berorientasi objek. </font><font style="vertical-align: inherit;">Pola desain: Per. </font><font style="vertical-align: inherit;">dari bahasa inggris </font><font style="vertical-align: inherit;">- St. Petersburg: Peter, 2001.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. C ++ Perpustakaan Standar: Panduan Referensi, edisi kedua: Per. </font><font style="vertical-align: inherit;">dari bahasa inggris </font><font style="vertical-align: inherit;">- M.: LLC â€œSaya. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dewhurst] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dewhurst, Stefan K. Slippery menempatkan C ++. </font><font style="vertical-align: inherit;">Cara menghindari masalah saat merancang dan menyusun program Anda:: Per. </font><font style="vertical-align: inherit;">dari bahasa inggris </font><font style="vertical-align: inherit;">- M .: DMK Press, 2012.</font></font></p><br><p> [Meyers1] <br> , .    C++. 35        .: .  . â€” .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  . â€” .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  . â€” .:  Â«.. Â», 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . â€” :  Â«.. Â», 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  . â€” .:  Â«.. Â», 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427281/">https://habr.com/ru/post/id427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427271/index.html">Sejarah dan pengalaman menggunakan terjemahan mesin. Kuliah Yandex</a></li>
<li><a href="../id427273/index.html">Bisakah kecerdasan buatan meninggalkan bandar tanpa bekerja?</a></li>
<li><a href="../id427275/index.html">Arsitektur Informasi Internet Bagian 3</a></li>
<li><a href="../id427277/index.html">Pola difraksi ditemukan dalam distribusi bilangan prima, mirip dengan quasicrystals</a></li>
<li><a href="../id427279/index.html">CoLaboratory: Android Night #Apple</a></li>
<li><a href="../id427283/index.html">Seberapa tinggi ketersediaan di Kubernetes dipastikan</a></li>
<li><a href="../id427285/index.html">Sekolah di dasar-dasar sirkuit digital: Novosibirsk - Ok, Krasnoyarsk - bersiap-siap</a></li>
<li><a href="../id427289/index.html">Pemodelan Geologi 3D, Penebangan dan Technaton dari Aramco Innovations</a></li>
<li><a href="../id427291/index.html">Perkecil lalu lintas di Formulir Web ASP.NET, div yang dapat diklik, dan polling server berkala</a></li>
<li><a href="../id427293/index.html">Pola Desain JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>