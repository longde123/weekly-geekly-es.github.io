<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔼 👎 👩🏾‍💼 Analyse des performances des serveurs WSGI: deuxième partie 💇🏽 💙 🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est une traduction de l'article de Kevin Goldberg «Une analyse des performances des serveurs Python WSGI: partie 2» dzone.com/articles/a-p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des performances des serveurs WSGI: deuxième partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427217/">  <i>Cet article est une traduction de l'article de Kevin Goldberg «Une analyse des performances des serveurs Python WSGI: partie 2» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dzone.com/articles/a-performance-analysis-of-python-wsgi-servers-part</a> avec quelques ajouts du traducteur.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eee/5ee/9d4/eee5ee9d43f8a092b0c299c5e12bd661.jpg" alt="image"><br><br><h2>  Présentation </h2><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de</a> cette série, vous avez rencontré <b>WSGI</b> et les six serveurs les plus populaires selon l'auteur de <b>WSGI</b> .  Dans cette partie, vous verrez le résultat de l'analyse des performances de ces serveurs.  À cet effet, un bac à sable de test spécial a été créé. <br><a name="habracut"></a><br><h2>  Concurrents </h2><br>  En raison de contraintes de temps, la recherche a été limitée à six serveurs WSGI.  Toutes les instructions de démarrage de ce projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont hébergées sur GitHub</a> .  Peut-être qu'avec le temps, le projet s'élargira et des analyses de performances pour d'autres serveurs WSGI seront présentées.  Mais pour l'instant, nous parlerons de six serveurs: <br><br><ol><li>  <b>Bjoern se</b> décrit comme un «serveur WSGI ultra-rapide» et se vante d'être «le serveur WSGI le plus rapide, le plus petit et le plus léger».  Nous avons créé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petite application</a> qui utilise la plupart des paramètres de bibliothèque par défaut. </li><li>  <b>CherryPy</b> est un framework et un serveur WSGI extrêmement populaires et stables.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petit script a été</a> utilisé pour servir notre exemple d'application via <b>CherryPy</b> . </li><li>  <b>Gunicorn a</b> été inspiré par le serveur Ruby's <b>Unicorn</b> (d'où son nom).  Il affirme modestement qu'il est "simplement implémenté, facile à utiliser et assez rapide".  Contrairement à <b>Bjoern</b> et <b>CherryPy</b> , <b>Gunicorn</b> est un serveur autonome.  Nous l'avons créé à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette commande</a> .  Le paramètre "WORKER_COUNT" a été défini sur deux fois le nombre de cœurs de processeur disponibles, plus un.  Cela a été fait sur la base des recommandations de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation Gunicorn</a> . </li><li>  <b>Meinheld</b> est un serveur Web hautes performances compatible WSGI qui prétend être léger.  Sur la base de l'exemple montré sur le site du serveur, nous avons créé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre application</a> . </li><li>  <b>mod_wsgi a été</b> créé par le même créateur que <b>mod_python</b> .  Comme <b>mod_python</b> , il n'est disponible que pour Apache.  Cependant, il inclut un outil appelé <b>"mod_wsgi express"</b> qui crée la plus petite instance Apache possible.  Nous avons configuré et utilisé <b>mod_wsgi express</b> avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette commande</a> .  Pour correspondre à <b>Gunicorn</b> , nous avons réglé <b>mod_wsgi</b> pour créer deux fois plus de travailleurs que de cœurs de processeur. </li><li>  <b>uWSGI</b> est un serveur d'applications complet.  En règle générale, <b>uWSGI est</b> associé à un serveur proxy (par exemple: Nginx).  Cependant, afin de mieux évaluer les performances de chaque serveur, nous avons essayé de n'utiliser que des serveurs nus et avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créé deux travailleurs</a> pour chaque cœur de processeur disponible. </li></ol><br><h2>  Benchmark </h2><br>  Pour rendre le test aussi objectif que possible, un conteneur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker a</a> été créé pour isoler le serveur testé du reste du système.  En outre, l'utilisation du conteneur Docker a garanti que chaque lancement recommence à zéro. <br><br><h3>  Serveur: </h3><br><ul><li>  Isolé dans un conteneur docker. </li><li>  2 cœurs de processeur alloués. </li><li>  La RAM du conteneur était limitée à 512 Mo. </li></ul><br><h3>  Test: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wrk</a> , un outil de benchmarking HTTP moderne, a effectué des tests. </li><li>  Les serveurs ont été testés dans un ordre aléatoire avec une augmentation du nombre de connexions simultanées de l'ordre de 100 à 10 000. </li><li>  <b>wrk</b> était limité à deux cœurs de processeur non utilisés par Docker. </li><li>  Chaque test a duré 30 secondes et a été répété 4 fois. </li></ul><br><h3>  Métrique: </h3><br><ul><li>  <b>Wrk</b> a fourni le nombre moyen de demandes persistantes, d'erreurs et de retards. </li><li>  Intégrée à Docker, la surveillance a montré les niveaux d'utilisation du processeur et de la RAM. </li><li>  Les valeurs les plus élevées et les plus basses ont été rejetées et les valeurs restantes ont été moyennées. </li><li>  Pour les curieux, nous avons envoyé le script complet à <a href="">GitHub</a> . </li></ul><br><h2>  Résultats </h2><br>  Tous les indicateurs de performance initiaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont été inclus dans le référentiel du projet</a> , et un <a href="">fichier CSV</a> résumé <a href="">a</a> également <a href="">été</a> fourni.  De plus, pour la visualisation, des graphiques ont été créés dans l'environnement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google-doc</a> . <br><br><h3>  RPS par rapport au nombre de connexions simultanées </h3><br>  Ce graphique montre le nombre moyen de demandes simultanées;  Plus le nombre est élevé, mieux c'est. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e09/5b5/cc4/e095b5cc4e7e7455183ddd0a50d64250.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a5/666/b22/6a5666b22ae59edff617647a06bfa7b4.png" alt="image"><br><br><ul><li>  Bjoern: Un gagnant clair. </li><li>  CherryPy: Bien qu'il soit écrit en pur Python, il était le meilleur interprète. </li><li>  Meinheld: Excellentes performances compte tenu des ressources limitées des conteneurs. </li><li>  mod_wsgi: Pas le plus rapide, mais les performances étaient cohérentes et adéquates. </li><li>  Gunicorn: Bonnes performances à faibles charges, mais il y a un combat avec un grand nombre de connexions. </li><li>  uWSGI: Frustré avec de mauvais résultats. </li></ul><br>  <b>VAINQUEUR: Bjoern</b> <br><br><h4>  Bjoern </h4><br>  Par le nombre de demandes constantes, <b>Bjoern</b> est clairement le gagnant.  Cependant, étant donné que les chiffres sont beaucoup plus élevés que ceux des concurrents, nous sommes un peu sceptiques.  Nous ne sommes pas sûrs que <b>Bjoern soit</b> vraiment incroyablement rapide.  Au début, nous avons testé les serveurs par ordre alphabétique et nous pensions que <b>Bjoern</b> avait un avantage injuste.  Cependant, même après le démarrage des serveurs dans un ordre de serveur aléatoire et un nouveau test, le résultat reste le même. <br><br><h4>  uWSGI </h4><br>  Nous avons été déçus par les faibles résultats de l' <b>uWSGI</b> .  Nous nous attendions à ce qu'il soit en tête.  Lors des tests, nous avons remarqué que les journaux <b>uWSGI</b> s'imprimaient à l'écran, et nous avons initialement expliqué le manque de performances avec le travail supplémentaire effectué par le serveur.  Cependant, même après que l' <b>option</b> « <b>--disable-logging</b> » a été ajoutée, <b>uWSGI</b> est toujours le serveur le plus lent. <br><br>  Comme mentionné dans le manuel <b>uWSGI</b> , il s'interface généralement avec un serveur proxy tel que Nginx.  Cependant, nous ne sommes pas sûrs que cela puisse expliquer une si grande différence. <br><br><h3>  Retard </h3><br>  Le délai est le temps écoulé entre la demande et sa réponse.  Les nombres inférieurs sont meilleurs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/5c2/6b0/e035c26b0593b256add7d8ce564913ae.png" alt="image"><br><br><ul><li>  CherryPy: Bien géré la charge. </li><li>  Bjoern: Latence généralement faible, mais fonctionne mieux avec moins de connexions simultanées. </li><li>  Gunicorn: bon et cohérent. </li><li>  mod_wsgi: performances moyennes, même avec un grand nombre de connexions simultanées. </li><li>  Meinheld: Performance globale acceptable. </li><li>  uWSGI: uWSGI est à nouveau à la dernière place. </li></ul><br>  <b>GAGNANT: CherryPy</b> <br><br><h3>  Utilisation de la RAM </h3><br>  Cette métrique montre les besoins en mémoire et la «légèreté» de chaque serveur.  Les nombres inférieurs sont meilleurs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a38/138/59b/a3813859b6d73db89c186759941add94.png" alt="image"><br><br><ul><li>  Bjoern: Extrêmement léger.  Il utilise seulement 9 Mo de RAM pour traiter 10 000 requêtes simultanées. </li><li>  Meinheld: Identique à <b>Bjoern</b> . </li><li>  Gunicorn: adapte habilement les charges élevées avec une consommation de mémoire à peine perceptible. </li><li>  CherryPy: Initialement, il avait besoin d'une petite quantité de RAM, mais son utilisation a augmenté rapidement avec l'augmentation de la charge. </li><li>  mod_wsgi: Aux niveaux inférieurs, c'était l'un des plus intenses en mémoire, mais il est resté assez cohérent. </li><li>  uWSGI: Évidemment, la version que nous testons a des problèmes avec la quantité de mémoire consommée. </li></ul><br>  <b>GAGNANTS: Bjoern et Meinheld</b> <br><br><h3>  Nombre d'erreurs </h3><br>  Une erreur se produit lorsque le serveur se bloque, est interrompu ou que la demande expire.  Le plus bas sera le mieux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/282/e05/371/282e0537118fd5d98f4284ed084bd427.png" alt="image"><br><br>  Pour chaque serveur, nous avons calculé le ratio du ratio total du nombre de requêtes sur le nombre d'erreurs: <br><br><ul><li>  CherryPy: taux d'erreur autour de 0, même avec un nombre élevé de connexions. </li><li>  Bjoern: Des erreurs se sont produites, mais cela a été compensé par le nombre de demandes traitées. </li><li>  mod_wsgi: Fonctionne bien avec un taux d'erreur acceptable de 6%. </li><li>  Gunicorn: Fonctionne avec un taux d'erreur de 9%. </li><li>  uWSGI: Compte tenu du faible nombre de demandes traitées, il s'est retrouvé avec un taux d'erreur de 34%. </li><li>  Meinheld: est tombé à des charges plus élevées, provoquant plus de 10 000 erreurs lors du test le plus exigeant. </li></ul><br>  <b>GAGNANT: CherryPy</b> <br><br><h3>  Utilisation du processeur </h3><br>  Une utilisation élevée du processeur n'est ni bonne ni mauvaise si le serveur fonctionne bien.  Cependant, cela fournit des informations intéressantes sur le serveur.  Étant donné que deux cœurs de processeur ont été utilisés, l'utilisation maximale possible est de 200%. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73c/cf7/87f/73ccf787f03745d453ceaa5f4310a921.png" alt="image"><br><br><ul><li>  Bjoern: un serveur à thread unique, comme en témoigne son utilisation cohérente de 100% CPU. </li><li>  CherryPy: multithread, mais bloqué à 150%.  Cela peut être dû à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Python GIL</a> . </li><li>  Gunicorn: utilise plusieurs processus avec une utilisation complète des ressources CPU à des niveaux inférieurs. </li><li>  Meinheld: un serveur à thread unique utilisant des ressources CPU comme Bjoern. </li><li>  mod_wsgi: un serveur multi-thread utilisant tous les cœurs de CPU à travers toutes les mesures </li><li>  uWSGI: très faible utilisation du CPU.  La consommation du processeur ne dépasse pas 50%.  Ceci est une preuve que uWSGI n'est pas configuré correctement. </li></ul><br>  <b>GAGNANT: Non, car il s'agit plus d'une observation de comportement que d'une comparaison de performances.</b> <br><br><h2>  Conclusion </h2><br>  Pour résumer!  Voici quelques idées générales que vous pouvez tirer des résultats de chaque serveur: <br><br><ul><li>  Bjoern: se justifie comme un «serveur WSGI ultra-rapide et ultra-léger». </li><li>  CherryPy: hautes performances, faible consommation de mémoire et faibles taux d'erreur.  Pas mal pour du pur Python. </li><li>  Gunicorn: Un bon serveur pour des charges moyennes. </li><li>  Meinheld: Fonctionne bien et nécessite un minimum de ressources.  Cependant, aux prises avec des charges plus élevées. </li><li>  mod_wsgi: S'intègre à Apache et fonctionne très bien. </li><li>  uWSGI: Très déçu.  Soit nous avons configuré <b>uWSGI de</b> manière incorrecte, soit la version que nous avons installée contient des erreurs de base. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427217/">https://habr.com/ru/post/fr427217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427205/index.html">Habrakvest en l'honneur du 20e anniversaire du groupe Mail.Ru: gagnants et réponses</a></li>
<li><a href="../fr427207/index.html">Les employés de Rockstar se lèvent pour l'entreprise après avoir critiqué les semaines de travail de 100 heures</a></li>
<li><a href="../fr427209/index.html">GeoPuzzle - faites le monde morceau par morceau</a></li>
<li><a href="../fr427211/index.html">Electron est un flash pour ordinateur de bureau</a></li>
<li><a href="../fr427215/index.html">Les microservices doivent grandir, pas commencer par eux</a></li>
<li><a href="../fr427219/index.html">Messagerie différée non bloquante inutile dans MPI: analyse légère et tutoriel pour ceux qui sont un peu "dans le sujet"</a></li>
<li><a href="../fr427221/index.html">Ce que j'ai réalisé sur le chemin de mon rêve d'intelligence artificielle</a></li>
<li><a href="../fr427223/index.html">Quelle est la responsabilité du développeur principal</a></li>
<li><a href="../fr427225/index.html">Sortie d'Oracle Database 18c XE</a></li>
<li><a href="../fr427227/index.html">Comment nous avons créé un jeu de société avec télécommande - Partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>