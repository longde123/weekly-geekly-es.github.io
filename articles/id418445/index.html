<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏢 👩🏾‍🎨 🚰 Django Channels - jawaban untuk web modern 🚩 🤰🏾 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di dunia Django, add-on Saluran Django mulai populer. Perpustakaan ini harus membawa ke Django pemrograman jaringan asinkron yang telah kita tunggu-tu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Django Channels - jawaban untuk web modern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418445/">  Di dunia Django, add-on Saluran Django mulai populer.  Perpustakaan ini harus membawa ke Django pemrograman jaringan asinkron yang telah kita tunggu-tunggu.  <strong>Artyom Malyshev</strong> di Moscow Python Conf 2017 menjelaskan bagaimana versi pertama perpustakaan melakukannya (sekarang penulis sudah zip channel2), mengapa ia melakukannya dan melakukannya sama sekali. <br><br>  Pertama-tama, Zen Zen mengatakan bahwa solusi apa pun harus menjadi satu-satunya.  Oleh karena itu, <strong>dalam Python setidaknya ada tiga masing-masing</strong> .  Sudah ada banyak kerangka kerja jaringan yang tidak sinkron: <br><br><ul><li>  Bengkok <br></li><li>  Eventlet <br></li><li>  Gevent <br></li><li>  Tornado; <br></li><li>  Asyncio <br></li></ul><br>  Tampaknya, mengapa menulis perpustakaan lain dan apakah itu perlu sama sekali. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ij0PiSlYBu0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong><em>Tentang pembicara:</em></strong> Artyom Malyshev adalah pengembang Python independen.  Dia terlibat dalam pengembangan sistem terdistribusi, berbicara di konferensi tentang Python.  Artyom dapat ditemukan dengan nama panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">PROOFIT404</a> di Github dan di jejaring sosial. <br><a name="habracut"></a><br>  <strong>Django sinkron dengan definisi</strong> .  Jika kita berbicara tentang ORM, maka secara sinkron mengakses database selama akses atribut, ketika kita menulis, misalnya, post.author.username, tidak ada biaya. <br><br>  Selain itu, Django adalah kerangka kerja WSGI. <br><br><h2>  WSGI <br></h2><br>  WSGI adalah antarmuka sinkron untuk bekerja dengan server web. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(environ, callback)</span></span></span><span class="hljs-function"> :</span></span> status, headers = <span class="hljs-string"><span class="hljs-string">'200 OK'</span></span>, [] callback (status, headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Hello world!\n'</span></span>]</code> </pre> <br>  Fitur utamanya adalah kami memiliki fungsi yang mengambil argumen dan segera mengembalikan nilai.  Itu semua yang bisa diharapkan oleh server web dari kami.  <strong>Tidak sinkron dan tidak berbau</strong> . <br><br>  Ini sudah lama dilakukan, pada tahun 2003, ketika web itu sederhana, pengguna membaca semua jenis berita di Internet, dan masuk ke buku tamu.  Cukup menerima permintaan dan memprosesnya.  Berikan jawaban dan lupakan bahwa pengguna ini sama sekali. <br><img src="https://habrastorage.org/webt/-a/3e/ly/-a3elynsjri1d0qbc73yl256qbo.jpeg"><br><br>  Tetapi, untuk sesaat, sekarang bukan tahun 2003, jadi pengguna menginginkan lebih banyak dari kami. <br><img src="https://habrastorage.org/webt/-j/fp/nz/-jfpnzpcfn0w2hpbvmcejswxnaw.jpeg"><br>  Mereka ingin aplikasi web yang kaya, konten langsung, mereka ingin aplikasi bekerja dengan baik di desktop, di laptop, di puncak lainnya, di jam.  Yang paling penting, <strong>pengguna tidak ingin menekan F5</strong> , karena, misalnya, tablet tidak memiliki tombol seperti itu. <br><br><img src="https://habrastorage.org/webt/bq/gi/ql/bqgiql6zzob87g74yngfmwvkehs.jpeg"><br><br>  Browser web secara alami datang untuk menemui kami - mereka menambahkan protokol baru dan fitur baru.  Jika Anda dan saya hanya mengembangkan frontend, maka kami hanya akan mengambil browser sebagai platform dan menggunakan fitur intinya, karena siap untuk memberikannya kepada kami. <br><br>  <strong>Tapi, untuk programmer backend, semuanya telah banyak berubah</strong> .  Soket web, HTTP2, dan sejenisnya merupakan masalah besar dalam hal arsitektur, karena keduanya merupakan koneksi jangka panjang dengan status yang perlu ditangani. <br><img src="https://habrastorage.org/webt/g1/pn/gi/g1pngi6z8op3aesfec2rtiodv4q.jpeg"><br><br>  Ini adalah masalah yang coba diselesaikan oleh Saluran Django untuk Django.  Pustaka ini dirancang untuk memberi Anda kemampuan menangani koneksi, meninggalkan Django Core yang biasa kami gunakan untuk tidak berubah sama sekali. <br><br>  Dia menjadi orang yang luar biasa oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Andrew Godwin</strong></a> , pemilik aksen bahasa Inggris yang mengerikan yang berbicara dengan sangat cepat.  Anda harus mengetahuinya dengan hal-hal seperti Migrasi Django Selatan dan Django yang sudah lama terlupakan, yang datang kepada kami dari versi 1.7.  Sejak ia memperbaiki migrasi untuk Django, ia mulai memperbaiki soket web dan HTTP2. <br><br>  Bagaimana dia melakukannya?  Sekali waktu, gambar berikut muncul di Internet: kotak kosong, panah, tulisan "Arsitektur yang baik" - Anda memasukkan teknologi favorit Anda ke dalam kotak kecil ini, Anda mendapatkan situs web yang berskala baik. <br><br><img src="https://habrastorage.org/webt/r1/rz/z9/r1rzz99ck74ggy5uy8vnn7kebks.jpeg"><br><br>  Andrew Godwin memasuki server di kotak-kotak ini, yang berdiri di depan dan menerima permintaan apa pun, baik itu asinkron, sinkron, e-mail, apa pun.  Di antara mereka ada yang disebut Channel Layer, yang menyimpan pesan yang diterima dalam format yang dapat diakses oleh kumpulan pekerja yang sinkron.  Segera setelah koneksi asinkron mengirim sesuatu kepada kami, kami merekamnya di Channel Layer, dan kemudian pekerja sinkron dapat mengambilnya dari sana dan memprosesnya dengan cara yang sama seperti Tampilan Django atau hal lainnya, secara sinkron.  Segera setelah kode sinkron mengirim respons kembali ke Kanal Lapisan, server asinkron akan memberikannya, mengalirkannya, melakukan apa pun yang diperlukan.  Jadi, abstraksi dilakukan. <br><br>  Ini menyiratkan beberapa implementasi, dan dalam produksi diusulkan untuk menggunakan <strong>Twisted sebagai server asinkron</strong> yang mengimplementasikan frontend untuk Django, dan <strong>Redis</strong> , yang akan menjadi saluran komunikasi yang sama antara Django sinkron dan Twink asinkron. <br><br><blockquote>  Berita baiknya: untuk menggunakan Saluran Django, Anda tidak perlu tahu Twisted atau Redis sama sekali - ini semua detail implementasi.  DevOps Anda akan mengetahui hal ini, atau Anda akan bertemu ketika Anda memperbaiki produksi yang jatuh pukul tiga pagi. </blockquote><br><h2>  ASGI </h2><br>  Abstraksi adalah protokol yang disebut ASGI.  Ini adalah antarmuka standar yang terletak di antara antarmuka jaringan, server, apakah itu protokol sinkron atau asinkron dan aplikasi Anda.  Konsep utamanya adalah saluran. <br><br><h3>  Saluran </h3><br>  Saluran adalah antrian pertama masuk pertama keluar pesan yang memiliki seumur hidup.  Pesan-pesan ini dapat dikirimkan nol atau sekali, dan hanya dapat diterima oleh satu Konsumen. <br><br><h3>  Konsumen </h3><br>  Di Konsumen, Anda hanya menulis kode Anda. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.reply_channel.send ( { <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], } )</code> </pre><br>  Fungsi yang menerima pesan mungkin mengirim beberapa respons, atau mungkin tidak mengirim respons sama sekali.  Sangat mirip dengan tampilan, satu-satunya perbedaan adalah bahwa tidak ada fungsi kembali, sehingga kita dapat berbicara tentang berapa banyak jawaban yang kita kembali dari fungsi. <br><br>  Kami menambahkan fungsi ini ke perutean, misalnya, menggantungnya untuk menerima pesan di soket web. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ws_message channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> ws_message), }</code> </pre><br>  Kami menulis ini dalam pengaturan Django, sama seperti database akan ditentukan. <br><br><pre> <code class="python hljs">CHANNEL_LAYERS = { <span class="hljs-string"><span class="hljs-string">'default'</span></span>: { <span class="hljs-string"><span class="hljs-string">'BACKEND'</span></span>: <span class="hljs-string"><span class="hljs-string">'asgiref.inmemory'</span></span>, <span class="hljs-string"><span class="hljs-string">'ROUTING'</span></span>: <span class="hljs-string"><span class="hljs-string">'myproject.routing'</span></span>, }, }</code> </pre><br>  Sebuah proyek dapat memiliki beberapa Lapisan Saluran, sama seperti ada beberapa basis data.  Hal ini sangat mirip dengan router db jika seseorang menggunakannya. <br><br>  Selanjutnya, kita mendefinisikan aplikasi ASGI kita.  Ini menyinkronkan bagaimana Twisted dimulai dan bagaimana pekerja yang disinkronkan mulai - mereka semua membutuhkan aplikasi ini. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.asgi <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_channel_layer os.environ.setdefault( <span class="hljs-string"><span class="hljs-string">'DJANGO_SETTINGS_MODULE'</span></span>, <span class="hljs-string"><span class="hljs-string">'myproject.settings'</span></span>, ) channel_layer = get_channel_layer()</code> </pre><br>  Setelah itu, sebarkan kode: jalankan gunicorn, kirimkan permintaan HTTP secara standar, secara sinkron, dengan tampilan, seperti yang biasa Anda lakukan.  Kami memulai server asinkron, yang akan menjadi bagian depan di depan Django sinkron kami, dan pekerja yang akan memproses pesan. <br><br><pre> <code class="python hljs">$ gunicorn myproject.wsgi $ daphne myproject.asgi:channel_layer $ django-admin runworker</code> </pre><br><h3>  Balas saluran </h3><br>  Seperti yang telah kita lihat, pesan memiliki konsep seperti saluran Balas.  Mengapa ini dibutuhkan? <br><br>  Saluran satu arah, masing-masing menerima WebSocket, WebSocket terhubung, putuskan WebSocket - ini adalah saluran umum ke sistem untuk pesan yang masuk.  Saluran Balas adalah saluran yang terikat erat dengan koneksi pengguna.  Dengan demikian, pesan memiliki saluran input dan output.  Pasangan ini memungkinkan Anda mengidentifikasi dari siapa pesan ini berasal. <br><img src="https://habrastorage.org/webt/rp/_k/wm/rp_kwmeuccjs2bunsar-hoei9au.jpeg"><br><br><h3>  Grup </h3><br>  Grup adalah kumpulan saluran.  Jika kami mengirim pesan ke grup, maka secara otomatis dikirim ke semua saluran grup ini.  Ini nyaman karena tidak ada yang suka menulis untuk loop.  Plus, implementasi grup biasanya dilakukan dengan menggunakan fungsi asli layer Channel, jadi ini lebih cepat daripada hanya mengirim pesan satu per satu. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Group <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).add (message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_disconnect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).discard(message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>). Send ({ <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], })</code> </pre><br>  Grup juga ditambahkan ke perutean. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span> , ws_connect), route (<span class="hljs-string"><span class="hljs-string">'websocket.disconnect'</span></span> , ws_disconnect), route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> , ws_message), ]</code> </pre><br>  Dan segera setelah saluran ditambahkan ke grup, balasan akan masuk ke semua pengguna yang terhubung ke situs kami, dan bukan hanya jawaban gema untuk diri kami sendiri. <br><br><h3>  Konsumen umum </h3><br>  Apa yang saya sukai Django adalah deklaratif.  Demikian pula, ada Konsumen deklaratif. <br><br>  Basis Konsumen adalah yang mendasar, hanya dapat memetakan saluran yang Anda tetapkan pada beberapa metode dan menyebutnya. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BaseConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseConsumer)</span></span></span><span class="hljs-class"> :</span></span> method_mapping = { <span class="hljs-string"><span class="hljs-string">'channel.name.here'</span></span>: <span class="hljs-string"><span class="hljs-string">'method_name'</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method_name</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Ada sejumlah besar konsumen yang telah ditentukan sebelumnya dengan perilaku yang sengaja diperbesar, seperti WebSocket Consumer, yang menentukan sebelumnya bahwa ia akan menangani koneksi WebSocket, menerima WebSocket, putuskan WebSocket.  Anda dapat segera mengindikasikan di grup mana untuk menambahkan saluran balasan, dan segera setelah Anda menggunakan self.send, dia akan mengerti apakah akan mengirim ini ke grup atau ke satu pengguna. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text=None, bytes=None)</span></span></span><span class="hljs-function"> :</span></span> self.send (text=text, bytes=bytes)</code> </pre><br>  Ada juga opsi konsumen WebSocket dengan JSON, yaitu, bukan teks, bukan byte, tetapi JSON yang sudah diuraikan akan datang untuk menerima, yang nyaman. <br><br>  Dalam perutean, ditambahkan dengan cara yang sama melalui route_class.  Myapp diambil dalam route_class, yang ditentukan dari konsumen, semua saluran diambil dari sana dan semua saluran yang ditentukan dalam myapp dialihkan.  Tulis lebih sedikit dengan cara ini. <br><br><h2>  Routing </h2><br>  Mari kita bicara secara rinci tentang perutean dan apa yang disediakannya bagi kita. <br><br>  Pertama, ini adalah filter. <br><br><pre> <code class="python hljs">// app.js S = new WebSocket (<span class="hljs-string"><span class="hljs-string">'ws://localhost:8000/chat/'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># routing.py route('websocket.connect', ws_connect, path=r'^/chat/$')</span></span></code> </pre><br>  Ini bisa menjadi jalur yang datang kepada kami dari koneksi soket web URI, atau metode permintaan http.  Ini bisa berupa bidang pesan apa saja dari saluran, misalnya, untuk email: teks, isi, salinan karbon, apa pun.  Jumlah argumen kata kunci untuk rute adalah arbitrer. <br><br>  Routing memungkinkan Anda membuat rute bersarang.  Jika beberapa konsumen ditentukan oleh beberapa karakteristik umum, mudah untuk mengelompokkan mereka dan menambahkan semua orang ke rute sekaligus. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route, include blog_routes = [ route ( <span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span>, blog, path = <span class="hljs-string"><span class="hljs-string">r'^/stream/'</span></span>) , ] routing = [ include (blog_routes, path= <span class="hljs-string"><span class="hljs-string">r'^/blog'</span></span> ), ]</code> </pre><br><h2>  Multiplexing </h2><br>  Jika kita membuka beberapa soket web, masing-masing memiliki URI yang berbeda, dan kita dapat menggantung beberapa penangannya.  Tapi jujur, membuka beberapa koneksi hanya untuk melakukan sesuatu yang indah di backend tidak terlihat seperti pendekatan teknik. <br><br>  Oleh karena itu, dimungkinkan untuk memanggil beberapa penangan pada satu soket web.  Kami mendefinisikan WebsocketDemultiplexer yang beroperasi pada konsep streaming dalam satu soket web.  Melalui aliran ini, itu akan mengarahkan pesan Anda ke saluran lain. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketDemultiplexer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demultiplexer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketDemultiplexer)</span></span></span><span class="hljs-class"> :</span></span> mapping = { <span class="hljs-string"><span class="hljs-string">'intval'</span></span>: <span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, }</code> </pre><br>  Dalam routing, multiplexer ditambahkan dengan cara yang sama seperti pada route_class konsumen deklaratif lainnya. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route_class, route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Demultiplexer, ws_message channel_routing = [ route_class (Demultiplexer, path=<span class="hljs-string"><span class="hljs-string">'^/binding/'</span></span>) , route (<span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, ws_message ) , ]</code> </pre><br>  Argumen stream ditambahkan ke pesan sehingga multiplexer dapat mencari tahu di mana harus meletakkan pesan yang diberikan.  Argumen payload berisi semua yang masuk ke saluran setelah multiplexer memprosesnya. <br><br>  Sangat penting untuk dicatat bahwa di Channel Layer, pesan akan mendapatkan <strong>dua kali</strong> : sebelum multiplexer dan setelah multiplexer.  Dengan demikian, segera setelah Anda mulai menggunakan multiplexer, Anda secara otomatis menambahkan latensi ke permintaan Anda. <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"stream"</span></span> : <span class="hljs-string"><span class="hljs-string">"intval"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span> : { … } }</code> </pre><br><h2>  Sesi </h2><br>  Setiap saluran memiliki sesi sendiri.  Ini adalah hal yang sangat nyaman, misalnya, untuk menyimpan keadaan antara panggilan ke penangan.  Anda dapat mengelompokkannya berdasarkan saluran balasan, karena ini adalah pengidentifikasi milik pengguna.  Sesi disimpan di mesin yang sama dengan sesi http biasa.  Untuk alasan yang jelas, cookie yang ditandatangani tidak didukung, cookie itu tidak ada di soket web. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> channel_session @channel_session <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> room=message.content [<span class="hljs-string"><span class="hljs-string">'path'</span></span>] message.channel_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room Croup (<span class="hljs-string"><span class="hljs-string">'chat-%s'</span></span> % room).add ( message.reply_channel )</code> </pre><br>  Selama koneksi, Anda bisa mendapatkan sesi http dan menggunakannya di konsumen Anda.  Sebagai bagian dari proses negosiasi, mengatur koneksi soket web, cookie dikirimkan kepada pengguna.  Dengan demikian, oleh karena itu, Anda bisa mendapatkan sesi pengguna, dapatkan objek pengguna yang sebelumnya Anda gunakan di Django, sama seperti jika Anda bekerja dengan view. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> http_session_user @http_session_user <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.http_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message.user.username : …</code> </pre><br><h2>  Urutan pesan </h2><br>  Saluran dapat memecahkan masalah yang sangat penting.  Jika kami membuat koneksi ke soket web dan segera mengirim, ini mengarah pada fakta bahwa dua peristiwa - WebSocket terhubung dan WebSocket menerima - sangat dekat waktu.  Sangat mungkin bahwa konsumen untuk soket web ini akan berjalan secara paralel.  Debugging ini akan sangat menyenangkan. <br><br>  Saluran Django memungkinkan Anda memasukkan kunci dari dua jenis: <br><br><ol><li>  <strong>Kunci</strong> <strong>mudah</strong> .  Dengan menggunakan mekanisme sesi, kami menjamin bahwa sampai konsumen diproses untuk menerima pesan, kami tidak akan memproses pesan apa pun di soket web.  Setelah koneksi dibuat, urutannya arbitrer, eksekusi paralel dimungkinkan. </li><li>  <strong>Hard</strong> <strong>lock</strong> - hanya satu konsumen pengguna tertentu yang berjalan pada satu waktu.  Ini overhead untuk sinkronisasi, karena menggunakan mesin sesi lambat.  Namun demikian, ada peluang seperti itu. </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> http_user = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> slight_ordering = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> strict_ordering = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>]</code> </pre><br>  Untuk menulis ini, ada dekorator yang sama yang kita lihat sebelumnya di sesi http, sesi saluran.  Di konsumen deklaratif, Anda cukup menulis atribut, segera setelah Anda menulisnya, ini akan secara otomatis berlaku untuk semua metode konsumen ini. <br><br><h2>  Pengikatan data </h2><br>  Pada suatu waktu, Meteor menjadi terkenal karena pengikatan data. <br><br>  Kami membuka dua browser, pergi ke halaman yang sama, dan di salah satu dari mereka kami klik pada scroll bar.  Pada saat yang sama, di browser kedua, di halaman ini, bilah gulir mengubah nilainya.  Ini keren. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerValueBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketBinding)</span></span></span><span class="hljs-class"> :</span></span> model = IntegerValue stream = intval<span class="hljs-string"><span class="hljs-string">' fields= ['</span></span>name<span class="hljs-string"><span class="hljs-string">', '</span></span>value<span class="hljs-string"><span class="hljs-string">'] def group_names (self, instance, action ) : return ['</span></span>intval-updates<span class="hljs-string"><span class="hljs-string">'] def has_permission (self, user, action, pk) : return True</span></span></code> </pre><br>  Django sekarang melakukan hal yang sama. <br><br>  Ini diimplementasikan menggunakan kait yang disediakan oleh <strong>Sinyal Django</strong> .  Jika penjilidan didefinisikan untuk model, semua koneksi yang ada dalam grup untuk instance model ini akan diberitahukan tentang setiap peristiwa.  Kami membuat model, mengubah model, menghapusnya - semua ini akan menjadi peringatan.  Pemberitahuan terjadi pada bidang yang ditunjukkan: nilai bidang ini telah berubah - payload sedang dibentuk, dikirim melalui soket web.  Ini nyaman. <br><br>  Penting untuk dipahami bahwa jika dalam contoh kita, kita terus-menerus mengklik bilah gulir, maka pesan akan terus-menerus pergi dan model akan disimpan.  Ini akan bekerja sampai beban tertentu, kemudian semuanya bersandar pada pangkalan. <br><br><h2>  Lapisan redis </h2><br>  Mari kita bicara sedikit lebih banyak tentang bagaimana mengatur Layer Channel untuk produksi diatur - Redis. <br><br>  Ini diatur dengan baik: <br><br><ul><li>  bekerja dengan koneksi sinkron di tingkat pekerja; </li><li>  sangat ramah untuk Twisted, tidak melambat, di mana itu sangat diperlukan, yaitu di server front-end Anda; </li><li>  MSGPACK digunakan untuk membuat serialisasi pesan di dalam Redis, yang mengurangi jejak pada setiap pesan; </li><li>  Anda dapat mendistribusikan beban ke beberapa instance Redis, itu akan secara otomatis dikocok menggunakan algoritma hash yang konsisten.  Dengan demikian, satu titik kegagalan hilang. </li></ul><br>  Saluran hanyalah daftar id dari Redis.  By id adalah nilai dari pesan tertentu.  Ini dilakukan agar Anda dapat mengontrol kehidupan setiap pesan dan saluran secara terpisah.  Pada prinsipnya, ini logis. <br><br><pre> <code class="python hljs">&gt;&gt; SET <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">" \x81\xa4text\xachello"</span></span> &gt;&gt; RPUSH <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">"60"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"61"</span></span></code> </pre><br>  Grup diimplementasikan dengan set yang diurutkan.  Distribusi ke grup dilakukan di dalam skrip Lua - ini sangat cepat. <br><br><pre> <code class="python hljs">&gt;&gt; type group:chat zset &gt;&gt; ZRANGE group:chat <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> WITHSCORES <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1476199781.8159261"</span></span></code> </pre><br><h2>  Masalah </h2><br>  Mari kita lihat masalah apa yang dimiliki pendekatan ini. <br><br><h3>  Panggilan balik neraka </h3><br>  Masalah pertama adalah panggilan balik neraka yang baru ditemukan.  Sangat penting untuk memahami bahwa sebagian besar masalah dengan saluran yang akan Anda temui akan bergaya: argumen datang ke konsumen yang tidak ia harapkan.  Dari mana mereka berasal, yang menempatkan mereka di Redis - semua ini adalah tugas investigasi yang meragukan.  Sistem pendistribusian debugging umumnya untuk yang berkemauan keras.  AsyncIO memecahkan masalah ini. <br><br><h3>  Seledri </h3><br>  Di Internet, mereka menulis bahwa Saluran Django adalah pengganti Celery. <br><img src="https://habrastorage.org/webt/x9/be/j8/x9bej8oul6vevk2r8e12q9-i_ia.jpeg"><br>  Saya punya berita buruk untuk Anda - tidak, bukan itu. <br><br>  Dalam saluran: <br><br><ul><li>  jangan coba lagi, Anda tidak bisa menunda eksekusi penangan; <br></li><li>  tanpa kanvas - hanya panggilan balik.  Selery juga menyediakan grup, rantai, akor favorit saya, yang, setelah mengeksekusi grup secara paralel, menyebabkan panggilan balik lain dengan sinkronisasi.  Semua ini tidak ada dalam saluran; </li><li>  tidak ada pengaturan waktu kedatangan pesan, beberapa sistem tanpa ini tidak mungkin dirancang. </li></ul><br><blockquote>  Saya melihat masa depan sebagai dukungan resmi untuk menggunakan saluran dan seledri bersama, dengan biaya minimal, dengan sedikit usaha.  Tapi Saluran Django bukan pengganti untuk Seledri. <br></blockquote><br><h2>  Django untuk web modern </h2><br>  Saluran Django adalah Django untuk web modern.  Ini adalah Django yang sama yang kita semua gunakan: sinkron, deklaratif, dengan banyak baterai.  Saluran Django hanya ditambah satu baterai.  Anda selalu perlu memahami di mana menggunakannya dan apakah itu layak dilakukan.  Jika Django tidak diperlukan dalam proyek, maka Saluran juga tidak diperlukan di sana.  Mereka hanya berguna dalam proyek-proyek di mana Django dibenarkan. <br><br><blockquote>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a></strong> <br><br>  Sebuah konferensi profesional untuk pengembang Python menuju ke tingkat yang baru - <strong>pada 22 dan 23 Oktober</strong> 2018 kami akan mengumpulkan 600 programmer Python terbaik di Rusia, menyajikan laporan yang paling menarik dan, tentu saja, menciptakan lingkungan untuk jaringan dalam tradisi terbaik komunitas Python Moskow dengan dukungan tim Ontiko. <br><br>  Kami mengundang para ahli untuk membuat laporan.  Panitia program sudah bekerja dan menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> hingga 7 September. <br><br>  Untuk peserta, program brainstorming online sedang dilakukan.  Anda dapat menambahkan topik yang hilang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumen</a> atau pengeras suara ini segera yang pidatonya menarik bagi Anda.  Dokumen akan diperbarui, pada kenyataannya, sepanjang waktu Anda dapat mengikuti pembentukan program. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418445/">https://habr.com/ru/post/id418445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418433/index.html">4 Agustus Peter Pencarian sepeda pertama untuk programmer</a></li>
<li><a href="../id418437/index.html">Tim Oc untuk menyelamatkan</a></li>
<li><a href="../id418439/index.html">Dasar-dasar Aplikasi Web Progresif</a></li>
<li><a href="../id418441/index.html">Dasar-dasar eskalasi hak istimewa Windows</a></li>
<li><a href="../id418443/index.html">GObject: enkapsulasi, instantiasi, introspeksi</a></li>
<li><a href="../id418447/index.html">Mengapa Moscow Python Conf sekarang ++</a></li>
<li><a href="../id418449/index.html">Modul Biner untuk Python</a></li>
<li><a href="../id418451/index.html">Pelajaran pencetakan 3D. Dukungan efektif dan perubahan ketinggian lapisan dalam praktik dari 3Dtool</a></li>
<li><a href="../id418453/index.html">Pengamatan GRAVITY selanjutnya memvalidasi relativitas umum</a></li>
<li><a href="../id418455/index.html">Buka webinar "Spesialis yang memimpin: pengalaman pertama dan kesalahan"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>