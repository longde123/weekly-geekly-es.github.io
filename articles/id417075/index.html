<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‡ğŸ¼ ğŸ‘µğŸ½ â†–ï¸ API Cat CSS ğŸ© ğŸ‘˜ ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menurut penulis materi, terjemahan yang kami terbitkan hari ini, CSS Paint API adalah teknologi yang sangat menarik. Selain itu, kita berbicara tidak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Cat CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417075/">  Menurut penulis materi, terjemahan yang kami terbitkan hari ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSS Paint API</a> adalah teknologi yang sangat menarik.  Selain itu, kita berbicara tidak hanya tentang kemampuannya saat ini, tetapi juga tentang fenomena yang disajikan kepadanya, dan bahwa penampilannya menandai awal dari perubahan yang sangat luar biasa di dunia CSS.  Di sini kita akan berbicara tentang API Paint CSS dan alasan kemunculannya, dan berbicara tentang cara menggunakannya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/6c/1q/yu/6c1qyuo29pmcjmojwwou8qb034g.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu API Cat CSS?</font> </h2><br>  API yang dimaksud hanyalah sebagian kecil dari rangkaian spesifikasi baru yang sedang dikembangkan sebagai bagian dari proyek CSS Houdini.  Menjelaskan secara singkat proyek ini, intinya bermuara pada kenyataan bahwa ia memberi pengembang akses tingkat rendah ke mekanisme CSS internal. <br><br>  CSS Paint API memungkinkan Anda untuk memanggil fungsi <code>paint()</code> dalam situasi di mana, dalam kondisi normal, pekerjaan akan dilakukan, misalnya, dengan nilai tertentu yang menjelaskan beberapa jenis gambar.  Contoh umum dari ini adalah properti <code>background-image</code> , ketika bekerja dengan mana Anda dapat menggunakan fungsi <code>url()</code> untuk mengirimkan tautan ke file gambar sistem: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'assets/myimage.jpg'</span></span>); }</code> </pre> <br>  CSS Paint API memungkinkan Anda untuk memanggil, alih-alih fungsi yang serupa, fungsi <code>paint()</code> , dan meneruskannya worklet yang disebut, dijelaskan oleh JavaScript.  Vorklet dapat dianggap sebagai bagian dari kode yang memungkinkan pengembang untuk menggambar hampir semua yang diinginkan secara terprogram.  Dan, karena kita berbicara tentang JavaScript, gambar dapat dibuat dinamis.  Dengan sendirinya, API ini sangat mirip dengan HTML5 Canvas API, dan sekarang kita akan berbicara tentang cara kerjanya. <br><br><h2>  <font color="#3AC1EF">Fitur CSS Paint API</font> </h2><br>  Jika sekarang Anda memiliki perasaan bahwa semua ini terdengar bagus, tetapi terlihat rumit, dan Anda berpikir bahwa Anda cukup nyaman menggunakan gambar biasa, perlu diingat bahwa gambar biasa tidak kehilangan relevansinya dengan munculnya teknologi baru.  Menggunakan mereka, seperti yang selalu mereka lakukan, sangat normal.  Fakta bahwa sesuatu yang baru telah muncul di cakrawala, dan mungkin menjanjikan, tidak berarti bahwa setiap orang harus segera menggunakan yang baru ini untuk menyelesaikan semua masalah yang ada.  Namun, gambar biasa bersifat statis.  API baru menarik dengan ide membuat gambar dinamis. <br><br>  Mari kita berpikir tentang fungsi CSS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">linear-gradient</a> .  Masalahnya sangat kuat.  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> sebagai contoh.  Tetapi dapatkah Anda bayangkan betapa lebih mudahnya untuk mencapai efek yang sama yang dibentuk oleh lapisan yang tumpang tindih jika Anda tidak harus menggunakan banyak gambar latar belakang?  Namun, ini bukan satu-satunya poin.  Jika Anda mempelajari API Paint CSS, Anda dapat mengetahui bagaimana gambar tersebut dibuat selama eksekusi program, dan ini bisa sangat berguna (sebenarnya, inilah yang kami rencanakan untuk dilakukan di sini). <br><br>  Bagaimana dengan fungsi CSS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerucut-gradien</a> ?  Bisa dikatakan, itu belum didukung oleh browser tanpa polyfill.  Menggunakan API baru memungkinkan Anda untuk membuat gradien berbentuk kerucut, menyesuaikan parameternya, yang tidak terlalu berbeda dari apa yang ada dalam spesifikasi.  Semua ini berarti bahwa dalam praktiknya, menggunakan API baru, Anda dapat membuat polyfill asli Anda sendiri.  Dan ini luar biasa. <br><br>  Perlu diingat bahwa semua ini adalah bagian dari kelompok fitur yang lebih besar yang dikenal sebagai CSS Houdini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inilah yang</a> dikatakan dokumentasi proyek tentang hal itu: "Tujuan Satuan Tugas CSS-TAG Houdini (CSS Houdini) adalah untuk bersama-sama mengembangkan mekanisme yang memecahkan misteri dari teknologi penataan laman web dan membangun tata letak mereka." <br><br>  Kedengarannya bagus, bukan?  Dan, pada kenyataannya, mekanisme baru ini bertujuan memungkinkan pengembang untuk memperluas fungsionalitas CSS itu sendiri, memberi mereka alat styling yang lebih baik, dukungan lintas browser dan kemampuan untuk membuat polyfill. <br><br>  Proses standardisasi teknologi baru mungkin memakan waktu.  Pertama, saran dibuat untuk fitur CSS baru.  Berikutnya - spesifikasi ditulis, proses lain terjadi.  Akibatnya, pembuat browser menerapkan spesifikasi baru.  Dan, karena pengembang sering tidak sabar untuk mulai menggunakan fitur-fitur baru sesegera mungkin, mereka harus mempertimbangkan fakta bahwa browser lama mungkin tidak mendukung inovasi, dan bahwa jika beberapa spesifikasi belum sepenuhnya diimplementasikan, mungkin, dalam prosesnya pengembangan, serius berubah.  Mungkin tidak ada yang perlu dibicarakan tentang nuansa khas implementasi berbagai teknologi di berbagai browser.  Proyek Houdini dapat melangkah cukup jauh dalam mengurangi masalah-masalah ini, memungkinkan kami untuk mengembangkan fungsionalitas browser kami sendiri, menggunakannya dan dengan tenang menunggu produsen browser untuk mengimplementasikan fitur-fitur tertentu.  Berikut adalah beberapa materi tentang topik ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yang pertama</a> didedikasikan untuk kekuatan Houdini, dan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> adalah menggunakan kemampuan proyek ini untuk membuat animasi yang kompleks. <br><br><h2>  <font color="#3AC1EF">Dukungan untuk CSS Paint API oleh browser</font> </h2><br>  Bisakah saya menggunakan API API CSS hari ini?  Kami dapat memberikan jawaban positif untuk pertanyaan ini, meskipun harus dicatat bahwa jauh dari semua browser mendukung teknologi ini.  Untuk mendapatkan informasi dukungan untuk API ini, Anda dapat menggunakan sumber daya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caniuse.com</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55a/42a/4ea/55a42a4ea1ccc056652c9a7b463f8097.png"></div><br>  <i><font color="#999999">Dukungan untuk API Paint CSS oleh berbagai browser (Juli 2018)</font></i> <br><br>  Seperti yang Anda lihat, API ini hanya mendukung Chrome sejauh ini.  Tapi bagaimanapun juga, mari kita bicara tentang cara menggunakannya.  Kami akan membahas konstruksi perangkat lunak yang diperlukan untuk membuat API baru berfungsi.  Ini termasuk fitur CSS baru dan beberapa mekanisme JavaScript yang cukup baru.  Contoh kita akan dibagi menjadi tiga langkah. <br><br><h2>  <font color="#3AC1EF">Langkah # 1: CSS</font> </h2><br>  Ingatlah bahwa untuk membuat gambar menggunakan CSS Paint API, widget adalah fragmen kode JS.  Karena itu, sebagai permulaan, kita perlu memberi nama worklet dan menyebutnya dalam CSS.  <code>awesomePattern</code> saja <code>awesomePattern</code> .  Akibatnya, CSS akan terlihat seperti ini: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'fallback.png'</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern); };</code> </pre> <br>  Persiapan awal telah selesai, tetapi sampai sisa contoh kita siap, semua ini tidak akan berhasil. <br><br><h2>  <font color="#3AC1EF">Langkah # 2: JavaScript</font> </h2><br>  Sekarang kita perlu menggambarkan worklet menggunakan JS.  Di sini diperlihatkan bagaimana, dalam skrip utama, skrip lain dimuat yang mengimplementasikan fungsi yang kita butuhkan. <br><br><pre> <code class="hljs cs">CSS.paintWorklet.addModule(<span class="hljs-string"><span class="hljs-string">'patternWorklet.js'</span></span>);</code> </pre> <br>  Pada tahap ini, sekali lagi, tidak ada yang terjadi, karena yang paling menarik disembunyikan dalam file <code>patternWorklet.js</code> . <br><br>  Dalam file <code>patternWorklet.js</code> kita perlu mendaftarkan kelas vorklet: <br><br><pre> <code class="hljs lisp">registerPaint('awesomePattern', Shape)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Di sini kita memanggil fungsi <code>registerPaint()</code> dan memberikan apa yang kita anggap sebagai worklet, dalam hal ini <code>awesomePattern</code> .  Selain itu, kami meneruskan fungsi ini tautan ke kelas yang akan kami tulis, dalam hal ini, <code>Shape</code> .  Perintah ini harus ditambahkan setelah deklarasi kelas terkait.  Saat mendeklarasikan dan menggunakan kelas, Anda tidak bisa mengandalkan sesuatu seperti mekanisme untuk meningkatkan deklarasi fungsi.  Sebelum Anda dapat menggunakan kelas, Anda harus mendeklarasikannya. <br><br>  Selanjutnya, kita akan menggunakan sintaks untuk mendeklarasikan kelas ECMAScript 2015 dan menulis kelas yang akan menggambar gambar latar belakang.  Karena kelas ini sekarang terdaftar sebagai kelas kelas pekerja, kita dapat menggunakan beberapa mekanisme khusus di dalamnya yang akan tersedia secara otomatis di dalamnya. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc( 200, 200, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath(); } }</span></span></code> </pre> <br>  Callback <code>paint()</code> memiliki parameter <code>ctx</code> , <code>geom</code> dan <code>properties</code> .  Parameter <code>ctx</code> sama dengan konteks rendering 2D yang dapat diperoleh dari elemen <code>&lt;canvas&gt;</code> .  Yah, hampir sama.  Faktanya adalah <code>&lt;canvas&gt;</code> memungkinkan Anda membaca data piksel, tetapi CSS Paint API tidak mengizinkannya.  Terlepas dari perbedaannya, menggunakan <code>ctx</code> , kita dapat menggunakan metode output grafik yang sama yang digunakan saat bekerja dengan elemen <code>&lt;canvas&gt;</code> .  Dalam contoh ini, menggunakan fungsi <code>arc()</code> , kita menggambar sebuah lingkaran. <br><br>  Dua nilai pertama yang diteruskan ke fungsi <code>arc()</code> adalah koordinat X dan Y dari pusat lingkaran, dalam piksel, relatif terhadap titik asal yang terletak di sudut kiri atas elemen.  Namun, saya ingin lingkaran berada di tengah elemen.  Untuk mengatasi masalah ini, parameter <code>geom</code> berguna bagi kami.  Ini memberikan akses ke objek <code>PaintSize</code> , yang merupakan deskripsi pengaturan gambar.  Secara khusus, merujuk padanya, kita dapat membaca parameter <code>width</code> dan <code>height</code> , dan inilah yang kita butuhkan untuk memusatkan lingkaran. <br><br>  Akibatnya, kita sampai pada kode ini: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {     let x = geom.width/2;   let y = geom.height/2;   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath();   } } registerPaint('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awesomePattern'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  Anda dapat melihat versi contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodePen</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berfungsi</a> .  Sebenarnya, inilah yang dihasilkan oleh kode ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/18e/992/0f218e9927aa75625eb0ae0ae0ec8e4e.png"></div><br>  <i><font color="#999999">Lingkaran dibuat dengan API Cat CSS</font></i> <br><br>  Semua ini bagus, tetapi contoh kita sangat sederhana.  Mari, alih-alih lingkaran yang biasa, gambarlah sesuatu yang lebih menarik.  Misalnya - seperti logo situs web asterisk - css-tricks.com. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/26e/5a7/a1f26e5a7d56b1d3d98717c890deabbf.png"></div><br>  <i><font color="#999999">Asterisk dibuat dengan API Cat CSS</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> proyek CodePen yang memungkinkan Anda melakukan ini. <br><br>  Saat Anda melihat kode JS untuk proyek ini, perhatikan metode <code>drawStar()</code> dan banyak fungsi yang digunakan saat bekerja dengan elemen <code>&lt;canvas&gt;</code> . <br><br><h2>  <font color="#3AC1EF">Langkah # 3: Properti CSS Kustom</font> </h2><br>  Menggunakan teknologi baru, kita bisa melangkah lebih jauh dari menggambar lingkaran dan bintang.  Kita dapat melihat fitur kuat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti CSS khusus</a> (variabel).  Ngomong-ngomong, mereka sendiri sangat menarik.  Dalam kasus kami, mereka ternyata sangat berguna. <br><br>  Misalkan kita ingin dapat mengubah ukuran atau warna dari logo yang dibuat sebelumnya.  Parameter ini dapat ditempatkan dalam kode CSS dalam bentuk properti khusus, dan kemudian menggunakannya dalam program melalui parameter ketiga, diteruskan ke callback <code>paint()</code> .  Ini tentang parameter <code>properties</code> . <br><br>  Kami menambahkan properti <code>--star-scale</code> ke kode-CSS kami, yang bertujuan mengendalikan ukuran gambar, dan properti <code>--star-scale</code> <code>--star-color</code> , yang digunakan untuk mengatur perubahan warna logo secara langsung di CSS.  Inilah yang kami dapatkan: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--star-scale</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--star-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsla</span></span>(200, 50%, 50%, 1); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern) };</code> </pre> <br>  Sekarang kembali ke kelas workcloth.  Di sini kita perlu berinteraksi dengan properti pengguna yang dijelaskan di atas.  Ini dilakukan dengan menggunakan metode <code>inputProperties</code> , yang memberi kita akses ke semua properti CSS dan nilai yang diberikannya. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--star-scale'</span></span>,<span class="hljs-string"><span class="hljs-string">'--star-color'</span></span>]; }</code> </pre> <br>  Sekarang Anda dapat bekerja dengannya dalam metode <code>paint()</code> : <br><br><pre> <code class="hljs lisp">const size = parseInt(<span class="hljs-name"><span class="hljs-name">properties</span></span>.get('--shape-size').toString())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Secara alami, nilai yang diperoleh dapat digunakan dalam kode yang bertanggung jawab untuk pembentukan gambar.  Ini mengarah pada fakta bahwa jika kita, dalam kode CSS, mengubah nilai properti <code>--star-scale</code> atau <code>--start-color</code> , ini akan segera mempengaruhi bagaimana gambar akan terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/7a0/676/7d27a06764d4888bcb66dc2a6d8d17b3.gif" alt="gambar"></div><br>  <i><font color="#999999">Pengaruh properti CSS khusus pada gambar jadi</font></i> <br><br>  Fungsi ini diimplementasikan dalam proyek CodePen yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sama dengan</a> yang kami sebutkan di atas. <br><br>  Ngomong-ngomong, perlu dicatat bahwa ketika menggunakan API baru, semua properti CSS biasa yang terkait dengan pengaturan latar belakang elemen, seperti <code>background-size</code> <code>background-repeat</code> dan <code>background-repeat</code> , akan bekerja dengan cara yang sama seperti sebelumnya.  Mereka tidak kehilangan relevansi. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  CSS Paint API adalah teknologi yang sangat kuat yang kemampuannya tidak terbatas untuk membuat gambar latar belakang. <br><br>  Bayangkan bahwa elemen tersebut harus memiliki perbatasan khusus, misalnya, yang tidak sepenuhnya terlihat, atau ganda.  Mungkin untuk mencapai efek seperti itu, Anda biasanya menggunakan pseudo-elements <code>::before</code> atau <code>::after</code> , atau mungkin <code>box-shadow</code> dikonfigurasi secara khusus.  Borders (dan banyak lagi) dapat diimplementasikan menggunakan CSS Paint API dan properti <code>border-image</code> . <br><br>  CSS Paint API menyatukan banyak fitur hebat, seperti widget, kelas ECMAScript 2015, dan fitur <code>&lt;canvas&gt;</code> .  Selain itu, ia menyediakan pengembang dengan perangkat lunak manajemen gambar berbasis JavaScript.  Misalnya, menggunakan mekanisme acara, Anda dapat mengatur pembaruan properti khusus, yang berarti gambar itu sendiri, seperti, misalnya, dilakukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di mana acara <code>click</code> memulai proses memperbarui properti di fungsi <code>requestAnimationFrame</code> , yang memungkinkan Anda membuat animasi setiap kali pengguna mengklik tombol.  Selain itu, bahkan koordinat kursor mouse ketika Anda mengklik diperhitungkan. <br><br>  Pada pandangan pertama, semua ini mungkin tampak sedikit membingungkan, tetapi mari kita lihat beberapa bagian lain dari proyek Houdini yang mungkin kita temui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Layout CSS</a> memungkinkan pengembang untuk melakukan sesuatu seperti <code>display: layout('myCustomLayout')</code> .  Contoh tipikal adalah pembuatan tata letak gaya batu Anda sendiri, tetapi jangkauan penggunaan fitur ini jauh lebih luas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Properti CSS dan Nilai API</a> memungkinkan Anda untuk mengatur jenis properti khusus. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Worklet Animasi CSS mendorong</a> operasi pemrosesan animasi di luar aliran utama, yang seharusnya diterjemahkan menjadi animasi yang sangat halus. </li></ul><br>  Akibatnya, kita dapat mengatakan bahwa, secara harfiah di depan mata kita, ada kemunculan teknologi yang membuka banyak peluang baru bagi pengembang web.  Proses standardisasi dan implementasi mereka di browser tidak begitu cepat, tetapi mereka, sangat mungkin, akan memiliki dampak luar biasa pada segala sesuatu yang berkaitan dengan styling halaman web. <br><br>  <b>Pembaca yang budiman!</b>  Bagian mana dari aplikasi API API CSS yang menurut Anda paling menarik? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/cp/zf/te/cpzfteyh2kzlthzniyap-5t1h6c.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417075/">https://habr.com/ru/post/id417075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417063/index.html">Jaringan saraf untuk yang terkecil</a></li>
<li><a href="../id417065/index.html">Splunk How-to, atau How dan Where to Learn Splunk</a></li>
<li><a href="../id417069/index.html">Sekali lagi tentang OpenSSL</a></li>
<li><a href="../id417071/index.html">Jumat PHP: Webinar Skillbox Gratis</a></li>
<li><a href="../id417073/index.html">Hari Pengembang Seluler Uber</a></li>
<li><a href="../id417079/index.html">Package Manager untuk Kubernetes - Helm: Past, Present, Future</a></li>
<li><a href="../id417081/index.html">Utara, akan, berharap, negara tanpa batas, atau Bagaimana proyek dibuat dalam kondisi Siberia yang parah</a></li>
<li><a href="../id417083/index.html">Banyak sekali Piala Dunia 2018</a></li>
<li><a href="../id417085/index.html">Browser membisukan suara dalam aplikasi WebRTC Anda. Hentikan apa?</a></li>
<li><a href="../id417087/index.html">HPE Digitize 2018: acara dan siaran langsung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>