<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèª üíü üì¨ Arbeiten mit R√ºckrufen in React üë©üèæ‚Äç‚öïÔ∏è üÖ±Ô∏è ‚ö´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="W√§hrend meiner Arbeit stie√ü ich regelm√§√üig auf die Tatsache, dass Entwickler nicht immer klar verstehen, wie der Mechanismus f√ºr die √úbertragung von D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit R√ºckrufen in React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/439138/"><p>  W√§hrend meiner Arbeit stie√ü ich regelm√§√üig auf die Tatsache, dass Entwickler nicht immer klar verstehen, wie der Mechanismus f√ºr die √úbertragung von Daten √ºber Requisiten, insbesondere R√ºckrufe, funktioniert und warum ihre PureComponents so oft aktualisiert werden. </p><br><p>  In diesem Artikel erfahren Sie daher, wie R√ºckrufe an React √ºbergeben werden, und erl√§utern auch die Funktionen von Ereignishandlern. <a name="habracut"></a></p><br><h3 id="tldr">  TL; DR </h3><br><ol><li>  Beeintr√§chtigen Sie nicht JSX und die Gesch√§ftslogik - dies erschwert die Wahrnehmung des Codes. </li><li>  Bei kleinen Optimierungen werden Cache-Handler-Funktionen in Form von classProperties f√ºr Klassen oder mit useCallback f√ºr Funktionen verwendet - dann werden reine Komponenten nicht st√§ndig gerendert.  Insbesondere das Caching von R√ºckrufen kann n√ºtzlich sein, damit bei der √úbergabe an die PureComponent keine unn√∂tigen Aktualisierungszyklen auftreten. </li><li>  Vergessen Sie nicht, dass Sie im R√ºckruf kein echtes Ereignis erhalten, sondern ein synthetisches Ereignis.  Wenn Sie die aktuelle Funktion verlassen, k√∂nnen Sie nicht auf die Felder dieses Ereignisses zugreifen.  Zwischenspeichern Sie die Felder, die Sie ben√∂tigen, wenn Sie asynchrone Abschl√ºsse haben. </li></ol><br><h3 id="chast-1-event-handlers-keshirovanie-i-vospriyatie-koda">  Teil 1. Event-Handler, Caching und Code-Wahrnehmung </h3><br><p>  React bietet eine recht bequeme M√∂glichkeit, Ereignishandler f√ºr HTML-Elemente hinzuzuf√ºgen. </p><br><p>  Dies ist eines der grundlegenden Dinge, die Entwickler kennenlernen m√ºssen, wenn sie mit dem Schreiben in React beginnen: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> console.log('Hello world!')}&gt;Click me</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  Einfach genug?  Aus diesem Code wird sofort klar, was passiert, wenn der Benutzer auf die Schaltfl√§che klickt. </p><br><p>  Aber was ist, wenn der Code im Handler immer mehr wird? </p><br><p>  Angenommen, wir klicken auf die Schaltfl√§che, um alle zu laden und herauszufiltern, die nicht zu einem bestimmten Team geh√∂ren ( <code>user.team === 'search-team'</code> ), und sortieren sie dann nach Alter. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">users</span></span>: [] }; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; &lt;ul&gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/li&gt; ))} &lt;/u</span></span></span></span><span class="hljs-function"><span class="hljs-params">l&gt; &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> .fetch(<span class="hljs-string"><span class="hljs-string">'/usersList'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> result.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = data .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.team === <span class="hljs-string"><span class="hljs-string">'search-team'</span></span>) .sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &gt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &lt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">users</span></span>: users, }); }); }} &gt; Load users &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } }</code> </pre> <br><p>  Dieser Code ist ziemlich schwer herauszufinden.  Der Gesch√§ftslogikcode wird mit dem Layout gemischt, das der Benutzer sieht. </p><br><p>  Der einfachste Weg, dies loszuwerden: Bringen Sie die Funktion auf die Ebene der Klassenmethoden: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers() { <span class="hljs-comment"><span class="hljs-comment">//    } render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={() =&gt; this.fetchUsers()}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Hier haben wir die Gesch√§ftslogik von JSX-Code in ein separates Feld in unserer Klasse verschoben.  Um dies innerhalb der Funktion zug√§nglich zu machen, haben wir den R√ºckruf folgenderma√üen definiert: <code>onClick={() =&gt; this.fetchUsers()}</code> </p><br><p>  Wenn wir eine Klasse beschreiben, k√∂nnen wir au√üerdem ein Feld als Pfeilfunktion deklarieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    }; render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={this.fetchUsers}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Dadurch k√∂nnen wir den R√ºckruf als <code>onClick={this.fetchUsers}</code> </p><br><p>  <strong>Was ist der Unterschied zwischen diesen beiden Methoden?</strong> </p><br><p>  <code>onClick={this.fetchUsers}</code> - Hier wird bei jedem Aufruf der <code>onClick={this.fetchUsers}</code> in Requisiten immer derselbe Link an die <code>button</code> gesendet. </p><br><p>  Im Fall von <code>onClick={() =&gt; this.fetchUsers()}</code> initialisiert JavaScript bei jedem <code>onClick={() =&gt; this.fetchUsers()}</code> der <code>onClick={() =&gt; this.fetchUsers()}</code> eine neue Funktion <code>() =&gt; this.fetchUsers()</code> und setzt sie auf <code>onClick</code> prop.  Dies bedeutet, dass <code>nextProp.onClick</code> und <code>prop.onClick</code> auf die <code>button</code> in diesem Fall immer nicht gleich sind. Selbst wenn die Komponente als sauber markiert ist, wird sie gerendert. </p><br><p>  <strong>Was bedroht dies mit der Entwicklung?</strong> </p><br><p>  In den meisten F√§llen werden Sie visuell keinen Leistungsabfall bemerken, da sich das von der Komponente generierte virtuelle DOM nicht vom vorherigen unterscheidet und es keine √Ñnderungen in Ihrem DOM gibt. </p><br><p>  Wenn Sie jedoch gro√üe Listen von Komponenten oder Tabellen rendern, werden Sie bei einer gro√üen Datenmenge "Bremsen" bemerken. </p><br><p>  <strong>Warum ist es wichtig zu verstehen, wie eine Funktion auf den R√ºckruf √ºbertragen wird?</strong> </p><br><p>  Oft kann man auf Twitter oder auf Stackoverflow auf solche Tipps sto√üen: </p><br><p>  "Wenn Sie Leistungsprobleme mit React-Anwendungen haben, versuchen Sie, die Vererbung von Component durch PureComponent zu ersetzen. Denken Sie auch daran, dass Sie f√ºr Component immer shouldComponentUpdate definieren k√∂nnen, um unn√∂tige Aktualisierungsschleifen zu vermeiden." </p><br><p>  Wenn wir eine Komponente als Pure definieren, bedeutet dies, dass sie bereits √ºber eine <code>shouldComponentUpdate</code> Funktion verf√ºgt, die flatEqual zwischen Requisiten und nextProps ausf√ºhrt. </p><br><p>  Wenn wir jedes Mal eine neue R√ºckruffunktion an eine solche Komponente √ºbergeben, verlieren wir alle Vorteile und Optimierungen von <code>PureComponent</code> . </p><br><p>  Schauen wir uns ein Beispiel an. <br>  Erstellen Sie eine Eingabekomponente, die auch Informationen dar√ºber anzeigt, wie oft sie aktualisiert wurde: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ renderedCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; render() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderedCount++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Input component was rerendered {this.renderedCount} times</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Erstellen wir zwei Komponenten, die die Eingabe intern rendern: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Und der zweite: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> this.onChange(e)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Sie k√∂nnen das Beispiel hier mit Ihren H√§nden ausprobieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/2vwz6kjjkr</a> <br>  Dieses Beispiel zeigt, wie Sie alle Vorteile von PureComponent verlieren k√∂nnen, wenn Sie jedes Mal eine neue R√ºckruffunktion an PureComponent √ºbergeben. </p><br><h3 id="chast-2-ispolzovanie-event-handlers-v-komponentah-funkciyah">  Teil 2. Verwenden von Ereignishandlern in Funktionskomponenten </h3><br><p>  In der neuen Version von React (16.8) wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Hooks-</a> Mechanismus angek√ºndigt, mit dem Sie vollwertige Funktionskomponenten mit einem klaren Lebenszyklus schreiben k√∂nnen, der fast alle Benutzerf√§lle abdecken kann, die bisher nur Klassen abdeckten. </p><br><p>  Wir modifizieren das Beispiel mit der Input-Komponente so, dass alle Komponenten durch eine Funktion dargestellt werden und arbeiten mit React-Hooks. </p><br><p>  Die Eingabe muss Informationen dar√ºber in sich speichern, wie oft sie ge√§ndert wurde.  Wenn wir in unserer Instanz ein Feld verwendet haben, auf das der Zugriff dadurch implementiert wurde, k√∂nnen wir im Fall einer Funktion keine Variable dadurch deklarieren. <br>  React bietet einen useRef-Hook, mit dem ein Verweis auf das HtmlElement im DOM-Baum gespeichert werden kann. Er ist jedoch auch interessant, da er f√ºr regul√§re Daten verwendet werden kann, die unsere Komponente ben√∂tigt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); }</code> </pre> <br><p>  Die Komponente muss au√üerdem "sauber" sein, dh sie wird nur aktualisiert, wenn sich die an die Komponente √ºbergebenen Requisiten ge√§ndert haben. <br>  Daf√ºr gibt es verschiedene Bibliotheken, die HOC bereitstellen. Es ist jedoch besser, die bereits in React integrierte Memofunktion zu verwenden, da sie schneller und effizienter arbeitet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef, memo } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> memo(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); });</code> </pre> <br><p>  Die Eingabekomponente ist fertig, jetzt schreiben wir die Komponenten A und B neu. <br>  Im Fall von Komponente B ist dies einfach zu tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setValue(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Hier haben wir den <code>useState</code> Hook verwendet, mit dem Sie den Status der Komponente speichern und damit arbeiten k√∂nnen, falls die Komponente durch eine Funktion dargestellt wird. </p><br><p>  Wie k√∂nnen wir die R√ºckruffunktion zwischenspeichern?  Wir k√∂nnen es nicht aus der Komponente entfernen, da es in diesem Fall verschiedenen Instanzen der Komponente gemeinsam ist. <br>  F√ºr solche Aufgaben verf√ºgt React √ºber eine Reihe von Caching- und Memoizing-Hooks, von denen <code>useCallback</code> f√ºr <code>useCallback</code> am besten geeignet <code>useCallback</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://reactjs.org/docs/hooks-reference.html</a> </p><br><p>  F√ºgen Sie diesen Haken zu Komponente <code>A</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState, useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> setValue(e.target.value), []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Wir haben die Funktion zwischengespeichert, was bedeutet, dass die Eingabekomponente nicht jedes Mal aktualisiert wird. </p><br><p>  <strong>Wie funktioniert <code>useCallback</code> hook?</strong> </p><br><p>  Dieser Hook gibt eine zwischengespeicherte Funktion zur√ºck (d. H. Der Link √§ndert sich nicht von Render zu Render). <br>  Zus√§tzlich zu der zwischenzuspeichernden Funktion wird ein zweites Argument an sie √ºbergeben - ein leeres Array. <br>  Mit diesem Array k√∂nnen Sie beim √Ñndern eine Liste von Feldern √ºbertragen, die Sie zum √Ñndern der Funktion ben√∂tigen, d. H.  einen neuen Link zur√ºckgeben. </p><br><p>  Den Unterschied zwischen der √ºblichen Methode zum √úbertragen einer Funktion auf einen R√ºckruf und <code>useCallback</code> hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/0y7wm3pp1w</a> </p><br><p>  <strong>Warum brauchen wir ein Array?</strong> </p><br><p>  Angenommen, wir m√ºssen eine Funktion, die von einem bestimmten Wert abh√§ngt, durch einen Abschluss zwischenspeichern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./styles.css'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ a, text }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClick = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> alert(a), [ <span class="hljs-comment"><span class="hljs-comment">/*a*/</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{text}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>); ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Click</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">me</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{1}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement);</span></span></code> </pre> <br><p>  Hier h√§ngt die App-Komponente von Prop <code>a</code> .  Wenn Sie das Beispiel ausf√ºhren, funktioniert alles ordnungsgem√§√ü, bis wir es am Ende hinzuf√ºgen: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Next</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement), 5000);</span></span></code> </pre> <br><p>  Nachdem das Timeout ausgel√∂st wurde, wird beim Klicken auf die Schaltfl√§che in Alarm <code>1</code> angezeigt.  Dies geschieht, weil wir die vorherige Funktion gespeichert haben, die <code>a</code> Variable geschlossen hat.  Und da <code>a</code> eine Variable ist, die in unserem Fall ein Werttyp ist und der Werttyp unver√§nderlich ist, haben wir diesen Fehler erhalten.  Wenn wir den Kommentar <code>/*a*/</code> entfernen, funktioniert der Code korrekt.  Wenn Sie beim zweiten Rendern reagieren, wird √ºberpr√ºft, ob die im Array √ºbergebenen Daten unterschiedlich sind, und es wird eine neue Funktion zur√ºckgegeben. </p><br><p>  Sie k√∂nnen dieses Beispiel hier selbst ausprobieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/6vo8jny1ln</a> </p><br><p>  React bietet viele Funktionen, mit denen Sie Daten speichern k√∂nnen, z. B. <code>useRef</code> , <code>useCallback</code> und <code>useMemo</code> . <br>  Wenn letzteres zum Speichern des Funktionswerts ben√∂tigt wird und sie <code>useRef</code> sehr √§hnlich <code>useRef</code> , k√∂nnen Sie mit <code>useRef</code> nicht nur Verweise auf DOM-Elemente zwischenspeichern, sondern auch als <code>useRef</code> fungieren. </p><br><p>  Auf den ersten Blick k√∂nnen damit Funktionen zwischengespeichert werden, da <code>useRef</code> auch Daten zwischen separaten Komponentenaktualisierungen zwischenspeichert. <br>  Die Verwendung von <code>useRef</code> zum Zwischenspeichern von Funktionen ist jedoch unerw√ºnscht.  Wenn unsere Funktion Closure verwendet, kann sich in jedem Rendering der Closed-Wert √§ndern, und unsere zwischengespeicherte Funktion funktioniert mit dem alten Wert.  Dies bedeutet, dass wir die Funktionsaktualisierungslogik schreiben oder einfach <code>useCallback</code> verwenden <code>useCallback</code> , in dem sie aufgrund des Abh√§ngigkeitsmechanismus implementiert ist. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/p70pprpvvx</a> hier k√∂nnen Sie die Speicherung von Funktionen mit dem richtigen <code>useCallback</code> , mit dem falschen und mit <code>useRef</code> . </p><br><h3 id="chast-3-syntetic-events">  Teil 3. Syntetische Ereignisse </h3><br><p>  Wir haben bereits herausgefunden, wie man Ereignishandler verwendet und wie man mit Schlie√üungen in R√ºckrufen richtig arbeitet, aber in React gibt es einen weiteren sehr wichtigen Unterschied, wenn man mit ihnen arbeitet: </p><br><p>  Hinweis: Jetzt ist die <code>Input</code> , mit der wir oben gearbeitet haben, absolut synchron. In einigen F√§llen kann es jedoch erforderlich sein, dass der R√ºckruf je nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entprellungs-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drosselungsmuster</a> verz√∂gert erfolgt.  So ist beispielsweise das Entprellen sehr praktisch f√ºr die Eingabe von Suchzeichenfolgen. Die Suche wird nur ausgef√ºhrt, wenn der Benutzer keine Zeichen mehr eingibt. </p><br><p>  Erstellen Sie eine Komponente, die intern eine Status√§nderung verursacht: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(e.target.value); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Dieser Code funktioniert nicht.  Tatsache ist, dass Reagieren innerhalb von Proxy-Ereignissen und das sogenannte synthetische Ereignis in unseren onChange-R√ºckruf gelangt, der nach dem "L√∂schen" unserer Funktion "gel√∂scht" wird (die Felder werden mit null markiert).  Aus Leistungsgr√ºnden verwendet React dies, um ein einzelnes Objekt zu verwenden, anstatt jedes Mal ein neues zu erstellen. </p><br><p>  Wenn wir wie in diesem Beispiel einen Wert annehmen m√ºssen, reicht es aus, die erforderlichen Felder zwischenzuspeichern, bevor die Funktion beendet wird: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pendingValue</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; // </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cached</span></span></span><span class="hljs-function">! </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(pendingValue); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Ein Beispiel finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/oj6p8opq0z</a> </p><br><p>  In sehr seltenen F√§llen muss die gesamte Instanz des Ereignisses beibehalten werden.  Dazu k√∂nnen Sie <code>event.persist()</code> aufrufen, das entfernt wird <br>  Diese Instanz des synthetischen Ereignisses aus dem Ereignispool der Reaktionsereignisse. </p><br><h3 id="zaklyuchenie">  Fazit: </h3><br><p>  Reaktionsereignishandler sind sehr praktisch, da sie: </p><br><ol><li>  Abonnieren und Abbestellen automatisieren (mit Unmount-Komponente); </li><li>  Vereinfachen Sie die Wahrnehmung des Codes. Die meisten Abonnements lassen sich leicht in JSX-Code verfolgen. </li></ol><br><p>  Gleichzeitig k√∂nnen bei der Entwicklung von Anwendungen einige Schwierigkeiten auftreten: </p><br><ol><li>  √úberschreiben von R√ºckrufen in Requisiten; </li><li>  Synthetische Ereignisse, die nach Ausf√ºhrung der aktuellen Funktion gel√∂scht werden. </li></ol><br><p>  Das √úberschreiben von R√ºckrufen ist normalerweise nicht erkennbar, da sich vDOM nicht √§ndert. Beachten Sie jedoch, dass Sie beim Einf√ºhren von Optimierungen, Ersetzen von Komponenten durch Pure durch Vererbung von <code>PureComponent</code> oder Verwenden von <code>memo</code> <code>PureComponent</code> sollten, diese zwischenzuspeichern, da sonst die Vorteile der Einf√ºhrung von PureComponents oder Memo nicht erkennbar sind.  Zum Zwischenspeichern k√∂nnen Sie entweder classProperties (bei der Arbeit mit einer Klasse) oder den <code>useCallback</code> Hook (bei der Arbeit mit Funktionen) verwenden. </p><br><p>  Wenn Sie f√ºr einen korrekten asynchronen Betrieb Daten von einem Ereignis ben√∂tigen, m√ºssen Sie auch die ben√∂tigten Felder zwischenspeichern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439138/">https://habr.com/ru/post/de439138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439124/index.html">Wenn die Software mit √∂ffentlichen Geldern erstellt wird, muss der Code offen sein</a></li>
<li><a href="../de439128/index.html">So organisieren Sie die Arbeit der Qualit√§tssicherung. Ein praktischer Weg</a></li>
<li><a href="../de439130/index.html">13 Markttrends f√ºr Cybersicherheit und Informationssicherheit 2019-2020</a></li>
<li><a href="../de439132/index.html">Unvergessliches Alter</a></li>
<li><a href="../de439136/index.html">Was ist der Unterschied zwischen 4G und 5G?</a></li>
<li><a href="../de439140/index.html">Wichtiger Beitrag zu Profileinladungen</a></li>
<li><a href="../de439142/index.html">Reifegradmodelle entwerfen</a></li>
<li><a href="../de439148/index.html">Arbeiten Sie mit nRF51822 mit ST-Link und Clion + OpenOCD</a></li>
<li><a href="../de439150/index.html">Wer sollte die Transaktionskosten bezahlen?</a></li>
<li><a href="../de439152/index.html">IT-Geh√§lter in der zweiten Jahresh√§lfte 2018: Laut Gehaltsrechner "My Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>