<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏻 💟 📬 Arbeiten mit Rückrufen in React 👩🏾‍⚕️ 🅱️ ⚫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während meiner Arbeit stieß ich regelmäßig auf die Tatsache, dass Entwickler nicht immer klar verstehen, wie der Mechanismus für die Übertragung von D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit Rückrufen in React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/439138/"><p>  Während meiner Arbeit stieß ich regelmäßig auf die Tatsache, dass Entwickler nicht immer klar verstehen, wie der Mechanismus für die Übertragung von Daten über Requisiten, insbesondere Rückrufe, funktioniert und warum ihre PureComponents so oft aktualisiert werden. </p><br><p>  In diesem Artikel erfahren Sie daher, wie Rückrufe an React übergeben werden, und erläutern auch die Funktionen von Ereignishandlern. <a name="habracut"></a></p><br><h3 id="tldr">  TL; DR </h3><br><ol><li>  Beeinträchtigen Sie nicht JSX und die Geschäftslogik - dies erschwert die Wahrnehmung des Codes. </li><li>  Bei kleinen Optimierungen werden Cache-Handler-Funktionen in Form von classProperties für Klassen oder mit useCallback für Funktionen verwendet - dann werden reine Komponenten nicht ständig gerendert.  Insbesondere das Caching von Rückrufen kann nützlich sein, damit bei der Übergabe an die PureComponent keine unnötigen Aktualisierungszyklen auftreten. </li><li>  Vergessen Sie nicht, dass Sie im Rückruf kein echtes Ereignis erhalten, sondern ein synthetisches Ereignis.  Wenn Sie die aktuelle Funktion verlassen, können Sie nicht auf die Felder dieses Ereignisses zugreifen.  Zwischenspeichern Sie die Felder, die Sie benötigen, wenn Sie asynchrone Abschlüsse haben. </li></ol><br><h3 id="chast-1-event-handlers-keshirovanie-i-vospriyatie-koda">  Teil 1. Event-Handler, Caching und Code-Wahrnehmung </h3><br><p>  React bietet eine recht bequeme Möglichkeit, Ereignishandler für HTML-Elemente hinzuzufügen. </p><br><p>  Dies ist eines der grundlegenden Dinge, die Entwickler kennenlernen müssen, wenn sie mit dem Schreiben in React beginnen: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> console.log('Hello world!')}&gt;Click me</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  Einfach genug?  Aus diesem Code wird sofort klar, was passiert, wenn der Benutzer auf die Schaltfläche klickt. </p><br><p>  Aber was ist, wenn der Code im Handler immer mehr wird? </p><br><p>  Angenommen, wir klicken auf die Schaltfläche, um alle zu laden und herauszufiltern, die nicht zu einem bestimmten Team gehören ( <code>user.team === 'search-team'</code> ), und sortieren sie dann nach Alter. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">users</span></span>: [] }; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; &lt;ul&gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/li&gt; ))} &lt;/u</span></span></span></span><span class="hljs-function"><span class="hljs-params">l&gt; &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> .fetch(<span class="hljs-string"><span class="hljs-string">'/usersList'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> result.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = data .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.team === <span class="hljs-string"><span class="hljs-string">'search-team'</span></span>) .sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &gt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &lt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">users</span></span>: users, }); }); }} &gt; Load users &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } }</code> </pre> <br><p>  Dieser Code ist ziemlich schwer herauszufinden.  Der Geschäftslogikcode wird mit dem Layout gemischt, das der Benutzer sieht. </p><br><p>  Der einfachste Weg, dies loszuwerden: Bringen Sie die Funktion auf die Ebene der Klassenmethoden: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers() { <span class="hljs-comment"><span class="hljs-comment">//    } render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={() =&gt; this.fetchUsers()}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Hier haben wir die Geschäftslogik von JSX-Code in ein separates Feld in unserer Klasse verschoben.  Um dies innerhalb der Funktion zugänglich zu machen, haben wir den Rückruf folgendermaßen definiert: <code>onClick={() =&gt; this.fetchUsers()}</code> </p><br><p>  Wenn wir eine Klasse beschreiben, können wir außerdem ein Feld als Pfeilfunktion deklarieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    }; render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={this.fetchUsers}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Dadurch können wir den Rückruf als <code>onClick={this.fetchUsers}</code> </p><br><p>  <strong>Was ist der Unterschied zwischen diesen beiden Methoden?</strong> </p><br><p>  <code>onClick={this.fetchUsers}</code> - Hier wird bei jedem Aufruf der <code>onClick={this.fetchUsers}</code> in Requisiten immer derselbe Link an die <code>button</code> gesendet. </p><br><p>  Im Fall von <code>onClick={() =&gt; this.fetchUsers()}</code> initialisiert JavaScript bei jedem <code>onClick={() =&gt; this.fetchUsers()}</code> der <code>onClick={() =&gt; this.fetchUsers()}</code> eine neue Funktion <code>() =&gt; this.fetchUsers()</code> und setzt sie auf <code>onClick</code> prop.  Dies bedeutet, dass <code>nextProp.onClick</code> und <code>prop.onClick</code> auf die <code>button</code> in diesem Fall immer nicht gleich sind. Selbst wenn die Komponente als sauber markiert ist, wird sie gerendert. </p><br><p>  <strong>Was bedroht dies mit der Entwicklung?</strong> </p><br><p>  In den meisten Fällen werden Sie visuell keinen Leistungsabfall bemerken, da sich das von der Komponente generierte virtuelle DOM nicht vom vorherigen unterscheidet und es keine Änderungen in Ihrem DOM gibt. </p><br><p>  Wenn Sie jedoch große Listen von Komponenten oder Tabellen rendern, werden Sie bei einer großen Datenmenge "Bremsen" bemerken. </p><br><p>  <strong>Warum ist es wichtig zu verstehen, wie eine Funktion auf den Rückruf übertragen wird?</strong> </p><br><p>  Oft kann man auf Twitter oder auf Stackoverflow auf solche Tipps stoßen: </p><br><p>  "Wenn Sie Leistungsprobleme mit React-Anwendungen haben, versuchen Sie, die Vererbung von Component durch PureComponent zu ersetzen. Denken Sie auch daran, dass Sie für Component immer shouldComponentUpdate definieren können, um unnötige Aktualisierungsschleifen zu vermeiden." </p><br><p>  Wenn wir eine Komponente als Pure definieren, bedeutet dies, dass sie bereits über eine <code>shouldComponentUpdate</code> Funktion verfügt, die flatEqual zwischen Requisiten und nextProps ausführt. </p><br><p>  Wenn wir jedes Mal eine neue Rückruffunktion an eine solche Komponente übergeben, verlieren wir alle Vorteile und Optimierungen von <code>PureComponent</code> . </p><br><p>  Schauen wir uns ein Beispiel an. <br>  Erstellen Sie eine Eingabekomponente, die auch Informationen darüber anzeigt, wie oft sie aktualisiert wurde: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ renderedCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; render() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderedCount++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Input component was rerendered {this.renderedCount} times</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Erstellen wir zwei Komponenten, die die Eingabe intern rendern: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Und der zweite: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> this.onChange(e)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Sie können das Beispiel hier mit Ihren Händen ausprobieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/2vwz6kjjkr</a> <br>  Dieses Beispiel zeigt, wie Sie alle Vorteile von PureComponent verlieren können, wenn Sie jedes Mal eine neue Rückruffunktion an PureComponent übergeben. </p><br><h3 id="chast-2-ispolzovanie-event-handlers-v-komponentah-funkciyah">  Teil 2. Verwenden von Ereignishandlern in Funktionskomponenten </h3><br><p>  In der neuen Version von React (16.8) wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Hooks-</a> Mechanismus angekündigt, mit dem Sie vollwertige Funktionskomponenten mit einem klaren Lebenszyklus schreiben können, der fast alle Benutzerfälle abdecken kann, die bisher nur Klassen abdeckten. </p><br><p>  Wir modifizieren das Beispiel mit der Input-Komponente so, dass alle Komponenten durch eine Funktion dargestellt werden und arbeiten mit React-Hooks. </p><br><p>  Die Eingabe muss Informationen darüber in sich speichern, wie oft sie geändert wurde.  Wenn wir in unserer Instanz ein Feld verwendet haben, auf das der Zugriff dadurch implementiert wurde, können wir im Fall einer Funktion keine Variable dadurch deklarieren. <br>  React bietet einen useRef-Hook, mit dem ein Verweis auf das HtmlElement im DOM-Baum gespeichert werden kann. Er ist jedoch auch interessant, da er für reguläre Daten verwendet werden kann, die unsere Komponente benötigt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); }</code> </pre> <br><p>  Die Komponente muss außerdem "sauber" sein, dh sie wird nur aktualisiert, wenn sich die an die Komponente übergebenen Requisiten geändert haben. <br>  Dafür gibt es verschiedene Bibliotheken, die HOC bereitstellen. Es ist jedoch besser, die bereits in React integrierte Memofunktion zu verwenden, da sie schneller und effizienter arbeitet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef, memo } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> memo(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); });</code> </pre> <br><p>  Die Eingabekomponente ist fertig, jetzt schreiben wir die Komponenten A und B neu. <br>  Im Fall von Komponente B ist dies einfach zu tun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setValue(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Hier haben wir den <code>useState</code> Hook verwendet, mit dem Sie den Status der Komponente speichern und damit arbeiten können, falls die Komponente durch eine Funktion dargestellt wird. </p><br><p>  Wie können wir die Rückruffunktion zwischenspeichern?  Wir können es nicht aus der Komponente entfernen, da es in diesem Fall verschiedenen Instanzen der Komponente gemeinsam ist. <br>  Für solche Aufgaben verfügt React über eine Reihe von Caching- und Memoizing-Hooks, von denen <code>useCallback</code> für <code>useCallback</code> am besten geeignet <code>useCallback</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://reactjs.org/docs/hooks-reference.html</a> </p><br><p>  Fügen Sie diesen Haken zu Komponente <code>A</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState, useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> setValue(e.target.value), []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Wir haben die Funktion zwischengespeichert, was bedeutet, dass die Eingabekomponente nicht jedes Mal aktualisiert wird. </p><br><p>  <strong>Wie funktioniert <code>useCallback</code> hook?</strong> </p><br><p>  Dieser Hook gibt eine zwischengespeicherte Funktion zurück (d. H. Der Link ändert sich nicht von Render zu Render). <br>  Zusätzlich zu der zwischenzuspeichernden Funktion wird ein zweites Argument an sie übergeben - ein leeres Array. <br>  Mit diesem Array können Sie beim Ändern eine Liste von Feldern übertragen, die Sie zum Ändern der Funktion benötigen, d. H.  einen neuen Link zurückgeben. </p><br><p>  Den Unterschied zwischen der üblichen Methode zum Übertragen einer Funktion auf einen Rückruf und <code>useCallback</code> hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/0y7wm3pp1w</a> </p><br><p>  <strong>Warum brauchen wir ein Array?</strong> </p><br><p>  Angenommen, wir müssen eine Funktion, die von einem bestimmten Wert abhängt, durch einen Abschluss zwischenspeichern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./styles.css'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ a, text }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClick = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> alert(a), [ <span class="hljs-comment"><span class="hljs-comment">/*a*/</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{text}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>); ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Click</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">me</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{1}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement);</span></span></code> </pre> <br><p>  Hier hängt die App-Komponente von Prop <code>a</code> .  Wenn Sie das Beispiel ausführen, funktioniert alles ordnungsgemäß, bis wir es am Ende hinzufügen: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Next</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement), 5000);</span></span></code> </pre> <br><p>  Nachdem das Timeout ausgelöst wurde, wird beim Klicken auf die Schaltfläche in Alarm <code>1</code> angezeigt.  Dies geschieht, weil wir die vorherige Funktion gespeichert haben, die <code>a</code> Variable geschlossen hat.  Und da <code>a</code> eine Variable ist, die in unserem Fall ein Werttyp ist und der Werttyp unveränderlich ist, haben wir diesen Fehler erhalten.  Wenn wir den Kommentar <code>/*a*/</code> entfernen, funktioniert der Code korrekt.  Wenn Sie beim zweiten Rendern reagieren, wird überprüft, ob die im Array übergebenen Daten unterschiedlich sind, und es wird eine neue Funktion zurückgegeben. </p><br><p>  Sie können dieses Beispiel hier selbst ausprobieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/6vo8jny1ln</a> </p><br><p>  React bietet viele Funktionen, mit denen Sie Daten speichern können, z. B. <code>useRef</code> , <code>useCallback</code> und <code>useMemo</code> . <br>  Wenn letzteres zum Speichern des Funktionswerts benötigt wird und sie <code>useRef</code> sehr ähnlich <code>useRef</code> , können Sie mit <code>useRef</code> nicht nur Verweise auf DOM-Elemente zwischenspeichern, sondern auch als <code>useRef</code> fungieren. </p><br><p>  Auf den ersten Blick können damit Funktionen zwischengespeichert werden, da <code>useRef</code> auch Daten zwischen separaten Komponentenaktualisierungen zwischenspeichert. <br>  Die Verwendung von <code>useRef</code> zum Zwischenspeichern von Funktionen ist jedoch unerwünscht.  Wenn unsere Funktion Closure verwendet, kann sich in jedem Rendering der Closed-Wert ändern, und unsere zwischengespeicherte Funktion funktioniert mit dem alten Wert.  Dies bedeutet, dass wir die Funktionsaktualisierungslogik schreiben oder einfach <code>useCallback</code> verwenden <code>useCallback</code> , in dem sie aufgrund des Abhängigkeitsmechanismus implementiert ist. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/p70pprpvvx</a> hier können Sie die Speicherung von Funktionen mit dem richtigen <code>useCallback</code> , mit dem falschen und mit <code>useRef</code> . </p><br><h3 id="chast-3-syntetic-events">  Teil 3. Syntetische Ereignisse </h3><br><p>  Wir haben bereits herausgefunden, wie man Ereignishandler verwendet und wie man mit Schließungen in Rückrufen richtig arbeitet, aber in React gibt es einen weiteren sehr wichtigen Unterschied, wenn man mit ihnen arbeitet: </p><br><p>  Hinweis: Jetzt ist die <code>Input</code> , mit der wir oben gearbeitet haben, absolut synchron. In einigen Fällen kann es jedoch erforderlich sein, dass der Rückruf je nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entprellungs-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drosselungsmuster</a> verzögert erfolgt.  So ist beispielsweise das Entprellen sehr praktisch für die Eingabe von Suchzeichenfolgen. Die Suche wird nur ausgeführt, wenn der Benutzer keine Zeichen mehr eingibt. </p><br><p>  Erstellen Sie eine Komponente, die intern eine Statusänderung verursacht: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(e.target.value); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Dieser Code funktioniert nicht.  Tatsache ist, dass Reagieren innerhalb von Proxy-Ereignissen und das sogenannte synthetische Ereignis in unseren onChange-Rückruf gelangt, der nach dem "Löschen" unserer Funktion "gelöscht" wird (die Felder werden mit null markiert).  Aus Leistungsgründen verwendet React dies, um ein einzelnes Objekt zu verwenden, anstatt jedes Mal ein neues zu erstellen. </p><br><p>  Wenn wir wie in diesem Beispiel einen Wert annehmen müssen, reicht es aus, die erforderlichen Felder zwischenzuspeichern, bevor die Funktion beendet wird: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pendingValue</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; // </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cached</span></span></span><span class="hljs-function">! </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(pendingValue); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Ein Beispiel finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/oj6p8opq0z</a> </p><br><p>  In sehr seltenen Fällen muss die gesamte Instanz des Ereignisses beibehalten werden.  Dazu können Sie <code>event.persist()</code> aufrufen, das entfernt wird <br>  Diese Instanz des synthetischen Ereignisses aus dem Ereignispool der Reaktionsereignisse. </p><br><h3 id="zaklyuchenie">  Fazit: </h3><br><p>  Reaktionsereignishandler sind sehr praktisch, da sie: </p><br><ol><li>  Abonnieren und Abbestellen automatisieren (mit Unmount-Komponente); </li><li>  Vereinfachen Sie die Wahrnehmung des Codes. Die meisten Abonnements lassen sich leicht in JSX-Code verfolgen. </li></ol><br><p>  Gleichzeitig können bei der Entwicklung von Anwendungen einige Schwierigkeiten auftreten: </p><br><ol><li>  Überschreiben von Rückrufen in Requisiten; </li><li>  Synthetische Ereignisse, die nach Ausführung der aktuellen Funktion gelöscht werden. </li></ol><br><p>  Das Überschreiben von Rückrufen ist normalerweise nicht erkennbar, da sich vDOM nicht ändert. Beachten Sie jedoch, dass Sie beim Einführen von Optimierungen, Ersetzen von Komponenten durch Pure durch Vererbung von <code>PureComponent</code> oder Verwenden von <code>memo</code> <code>PureComponent</code> sollten, diese zwischenzuspeichern, da sonst die Vorteile der Einführung von PureComponents oder Memo nicht erkennbar sind.  Zum Zwischenspeichern können Sie entweder classProperties (bei der Arbeit mit einer Klasse) oder den <code>useCallback</code> Hook (bei der Arbeit mit Funktionen) verwenden. </p><br><p>  Wenn Sie für einen korrekten asynchronen Betrieb Daten von einem Ereignis benötigen, müssen Sie auch die benötigten Felder zwischenspeichern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439138/">https://habr.com/ru/post/de439138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439124/index.html">Wenn die Software mit öffentlichen Geldern erstellt wird, muss der Code offen sein</a></li>
<li><a href="../de439128/index.html">So organisieren Sie die Arbeit der Qualitätssicherung. Ein praktischer Weg</a></li>
<li><a href="../de439130/index.html">13 Markttrends für Cybersicherheit und Informationssicherheit 2019-2020</a></li>
<li><a href="../de439132/index.html">Unvergessliches Alter</a></li>
<li><a href="../de439136/index.html">Was ist der Unterschied zwischen 4G und 5G?</a></li>
<li><a href="../de439140/index.html">Wichtiger Beitrag zu Profileinladungen</a></li>
<li><a href="../de439142/index.html">Reifegradmodelle entwerfen</a></li>
<li><a href="../de439148/index.html">Arbeiten Sie mit nRF51822 mit ST-Link und Clion + OpenOCD</a></li>
<li><a href="../de439150/index.html">Wer sollte die Transaktionskosten bezahlen?</a></li>
<li><a href="../de439152/index.html">IT-Gehälter in der zweiten Jahreshälfte 2018: Laut Gehaltsrechner "My Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>