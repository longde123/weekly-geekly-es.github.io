<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèª üêí üßó Les dangers des designers üë®‚Äçüë©‚Äçüëß‚Äçüë¶ üë®üèø‚Äçü§ù‚Äçüë®üèæ üë®üèº‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Les dangers des constructeurs" d'Aleksey Kladov. 


 Un de mes articles pr√©f√©r√©s sur le bl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les dangers des designers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460831/"><p>  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article "Les dangers des constructeurs" d'Aleksey Kladov. </p><br><p>  Un de mes articles pr√©f√©r√©s sur le blog de Rust est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Things Rust Shipped Without de Graydon Hoare</a> .  Pour moi, l'absence de toute caract√©ristique de la langue qui peut tirer dans la jambe est g√©n√©ralement plus importante que l'expressivit√©.  Dans cet essai l√©g√®rement philosophique, je veux parler de ma caract√©ristique particuli√®rement pr√©f√©r√©e qui manque √† Rust - √† propos des constructeurs. </p><br><h1 id="chto-takoe-konstruktor">  Qu'est-ce qu'un constructeur? </h1><br><p>  Les constructeurs sont couramment utilis√©s dans les langages OO.  La t√¢che du constructeur est d'initialiser compl√®tement l'objet avant que le reste du monde ne le voie.  √Ä premi√®re vue, cela semble √™tre une tr√®s bonne id√©e: </p><br><ol><li>  Vous <strong>d√©finissez les invariants</strong> dans le constructeur. </li><li>  Chaque m√©thode prend en charge la <strong>conservation des</strong> invariants. </li><li>  Ensemble, ces deux propri√©t√©s signifient que vous pouvez consid√©rer les objets comme des invariants et non comme des √©tats internes sp√©cifiques. </li></ol><br><p>  Le constructeur joue ici le r√¥le d'une base d'induction, √©tant le seul moyen de cr√©er un nouvel objet. </p><br><p>  Malheureusement, il y a un trou dans ces arguments: le designer lui-m√™me observe l'objet dans un √©tat inachev√©, ce qui cr√©e de nombreux probl√®mes. <a name="habracut"></a></p><br><h1 id="znachenie-this">  Cette valeur </h1><br><p>  Lorsque le constructeur initialise l'objet, il commence par un √©tat vide.  Mais comment d√©finissez-vous cet √©tat vide pour un objet arbitraire? </p><br><p>  La fa√ßon la plus simple de proc√©der consiste √† d√©finir tous les champs √† leurs valeurs par d√©faut: false pour bool, 0 pour nombres, null pour tous les liens.  Mais cette approche n√©cessite que tous les types aient des valeurs par d√©faut et introduit le fameux null dans le langage.  C'est le chemin emprunt√© par Java: au d√©but de la cr√©ation de l'objet, tous les champs sont 0 ou null. </p><br><p>  Avec cette approche, il sera tr√®s difficile de se d√©barrasser de null par la suite.  Un bon exemple √† apprendre est Kotlin.  Kotlin utilise des types non nullables par d√©faut, mais il est oblig√© de travailler avec la s√©mantique JVM pr√©existante.  La conception de la langue cache bien ce fait et est bien applicable dans la pratique, mais elle est <strong>intenable</strong> .  En d'autres termes, en utilisant des constructeurs, il est possible de contourner les v√©rifications nulles dans Kotlin. </p><br><p>  La principale caract√©ristique de Kotlin est l'encouragement √† la cr√©ation de soi-disant ¬´constructeurs primaires¬ª qui d√©clarent <strong>simultan√©ment</strong> un champ et lui attribuent une valeur avant l'ex√©cution de tout code personnalis√©: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Autre option: si le champ n'est pas d√©clar√© dans le constructeur, le programmeur doit l'initialiser imm√©diatement: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Tenter d'utiliser un champ avant l'initialisation est statiquement refus√©: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  Mais avec un peu de cr√©ativit√©, tout le monde peut contourner ces contr√¥les.  Par exemple, un appel de m√©thode convient √† ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Saisir √©galement cela avec un lambda (qui est cr√©√© dans Kotlin comme suit: {args -&gt; body}) convient √©galement: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Des exemples comme ceux-ci semblent irr√©alistes dans la r√©alit√© (et ce l'est), mais j'ai trouv√© des erreurs similaires dans le code r√©el (r√®gle de probabilit√© de Kolmogorov 0-1 dans le d√©veloppement de logiciels: dans une base de donn√©es suffisamment grande, tout morceau de code est presque garanti d'exister, du moins sinon interdit statiquement par le compilateur; dans ce cas, il n'existe certainement pas). </p><br><p>  La raison pour laquelle Kotlin peut exister avec cet √©chec est la m√™me que pour les tableaux covariants Java: les v√©rifications se produisent toujours pendant l'ex√©cution.  Au final, je ne voudrais pas compliquer le syst√®me de type Kotlin afin de rendre les cas ci-dessus incorrects au stade de la compilation: compte tenu des limitations existantes (s√©mantique JVM), le rapport prix / b√©n√©fice des validations en runtime est bien meilleur que celui des validations statiques. </p><br><p>  Mais que se passe-t-il si la langue n'a pas de valeur par d√©faut raisonnable pour chaque type?  Par exemple, en C ++, o√π les types d√©finis par l'utilisateur ne sont pas n√©cessairement des r√©f√©rences, vous ne pouvez pas simplement attribuer null √† chaque champ et dire que cela fonctionnera!  Au lieu de cela, C ++ utilise une syntaxe sp√©ciale pour d√©finir les valeurs initiales des champs: listes d'initialisation: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Comme il s'agit d'une syntaxe sp√©ciale, le reste du langage ne fonctionne pas parfaitement.  Par exemple, il est difficile de placer des op√©rations arbitraires dans les listes d'initialisation, car C ++ n'est pas un langage orient√© expression (ce qui est normal en soi).  Pour travailler avec les exceptions qui se produisent dans les listes d'initialisation, vous devez utiliser une autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction obscure de la langue</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  M√©thodes d'appel √† partir du constructeur </h1><br><p>  Comme le montrent les exemples de Kotlin, tout se brise en puces d√®s que nous essayons d'appeler une m√©thode √† partir du constructeur.  Fondamentalement, les m√©thodes s'attendent √† ce que l'objet accessible par ce biais soit d√©j√† enti√®rement construit et correct (coh√©rent avec les invariants).  Mais dans Kotlin ou Java, rien ne vous emp√™che d'appeler des m√©thodes du constructeur, et de cette fa√ßon nous pouvons accidentellement op√©rer sur un objet semi-construit.  Le concepteur promet d'√©tablir des invariants, mais en m√™me temps, c'est l'endroit le plus facile pour leur √©ventuelle violation. </p><br><p>  Des choses particuli√®rement √©tranges se produisent lorsque le constructeur de la classe de base appelle une m√©thode substitu√©e dans une classe d√©riv√©e: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Pensez-y: le code d'une classe arbitraire est ex√©cut√© <strong>avant d'</strong> appeler son constructeur!  Un code C ++ similaire conduira √† des r√©sultats encore plus int√©ressants.  Au lieu d'appeler la fonction de la classe d√©riv√©e, la fonction de la classe de base sera appel√©e.  Cela n'a pas beaucoup de sens car la classe d√©riv√©e n'a pas encore √©t√© initialis√©e (rappelez-vous, nous ne pouvons pas simplement dire que tous les champs sont nuls).  Cependant, si la fonction de la classe de base est enti√®rement virtuelle, son appel conduira √† UB. </p><br><h1 id="signatura-konstruktora">  Signature du designer </h1><br><p>  La violation des invariants n'est pas le seul probl√®me pour les concepteurs.  Ils ont une signature avec un nom fixe (vide) et un type de retour (la classe elle-m√™me).  Cela rend les surcharges de conception difficiles √† comprendre pour les utilisateurs. </p><br><blockquote>  Question de renvoi: √† quoi correspond std :: vector &lt;int&gt; xs (92, 2)? <br><br>  a.  Vecteur de deux longueurs 92 <br><br>  b.  [92, 92] <br><br>  c.  [92, 2] </blockquote><p>  Des probl√®mes avec la valeur de retour surviennent, en r√®gle g√©n√©rale, lorsqu'il est impossible de cr√©er un objet.  Vous ne pouvez pas simplement renvoyer Result &lt;MyClass, io :: Error&gt; ou null du constructeur! </p><br><p>  Ceci est souvent utilis√© comme argument en faveur du fait que l'utilisation de C ++ sans exception est difficile, et que l'utilisation de constructeurs vous oblige √©galement √† utiliser des exceptions.  Cependant, je ne pense pas que cet argument soit correct: les m√©thodes d'usine r√©solvent ces deux probl√®mes, car elles peuvent avoir des noms arbitraires et renvoyer des types arbitraires.  Je crois que le mod√®le suivant peut parfois √™tre utile dans les langues OO: </p><br><ul><li><p>  Cr√©ez un constructeur <strong>priv√©</strong> qui prend les valeurs de tous les champs comme arguments et les affecte simplement.  Ainsi, un tel constructeur fonctionnerait comme une structure litt√©rale dans Rust.  Il peut √©galement rechercher des invariants, mais il ne doit rien faire d'autre avec des arguments ou des champs. </p><br></li><li><p>  des m√©thodes de fabrique publique sont fournies pour l'API publique avec des noms et des types de retour appropri√©s. </p><br></li></ul><br><p>  Un probl√®me similaire avec les constructeurs est qu'ils sont sp√©cifiques et ne peuvent donc pas √™tre g√©n√©ralis√©s.  En C ++, ¬´il y a un constructeur par d√©faut¬ª ou ¬´il y a un constructeur de copie¬ª ne peut pas √™tre exprim√© plus simplement que ¬´certaines <em>syntaxes</em> fonctionnent¬ª.  Comparez cela √† Rust, o√π ces concepts ont des signatures appropri√©es: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  La vie sans designers </h1><br><p>  Rust n'a qu'une seule fa√ßon de cr√©er une structure: fournir des valeurs pour tous les champs.  Les fonctions d'usine, telles que la nouvelle g√©n√©ralement accept√©e, jouent le r√¥le de constructeurs, mais, surtout, elles ne vous permettent d'appeler aucune m√©thode tant que vous n'avez pas au moins une instance plus ou moins correcte de la structure. </p><br><p>  L'inconv√©nient de cette approche est que tout code peut cr√©er une structure, il n'y a donc pas un seul endroit, tel qu'un constructeur, pour maintenir les invariants.  En pratique, cela est facilement r√©solu par la confidentialit√©: si les champs de la structure sont priv√©s, cette structure ne peut √™tre cr√©√©e que dans le m√™me module.  Au sein d' <em>un m√™me</em> module, il n'est pas difficile d'adh√©rer √† l'accord "toutes les m√©thodes de cr√©ation d'une structure doivent utiliser la nouvelle m√©thode".  Vous pouvez m√™me imaginer une extension de langage qui vous permet de marquer certaines fonctions avec l'attribut # [constructeur], de sorte que la syntaxe litt√©rale de la structure n'est disponible que dans les fonctions marqu√©es.  Mais, encore une fois, des m√©canismes linguistiques suppl√©mentaires me semblent redondants: suivre <strong>les</strong> conventions <strong>locales</strong> n√©cessite peu d'efforts. </p><br><blockquote>  Personnellement, je pense que ce compromis est exactement le m√™me pour la programmation des contrats en g√©n√©ral.  Les contrats comme ¬´non nul¬ª ou ¬´valeur positive¬ª sont mieux encod√©s en types.  Pour les invariants complexes, √©crire simplement assert! (Self.validate ()) dans chaque m√©thode n'est pas si difficile.  Entre ces deux mod√®les, il y a peu de place pour les conditions # [pre] et # [post] impl√©ment√©es au niveau de la langue ou bas√©es sur des macros. </blockquote><br><h1 id="a-chto-naschet-swift">  Et Swift? </h1><br><p>  Swift est un autre langage int√©ressant qui m√©rite un regard sur les m√©canismes de conception.  Comme Kotlin, Swift est un langage sans danger.  Contrairement √† Kotlin, les contr√¥les nuls de Swift sont plus forts, donc le langage utilise des astuces int√©ressantes pour att√©nuer les dommages caus√©s par les constructeurs. </p><br><p>  <em>Tout d'abord</em> , Swift utilise des arguments nomm√©s, et cela aide un peu avec ¬´tous les constructeurs ont le m√™me nom¬ª.  En particulier, deux constructeurs avec les m√™mes types de param√®tres ne sont pas un probl√®me: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Deuxi√®mement</em> , pour r√©soudre le probl√®me "le constructeur appelle la m√©thode virtuelle de la classe de l'objet qui n'a pas encore √©t√© enti√®rement cr√©√©" Swift utilise un protocole d'initialisation en deux phases bien pens√©.  Bien qu'il n'y ait pas de syntaxe sp√©ciale pour les listes d'initialisation, le compilateur v√©rifie statiquement que le corps du constructeur a la forme correcte et s√ªre.  Par exemple, l'appel de m√©thodes n'est possible qu'apr√®s l'initialisation de tous les champs de la classe et de ses descendants. </p><br><p>  <em>Troisi√®mement</em> , au niveau du langage, il existe un support pour les constructeurs, dont l'appel peut √©chouer.  Le constructeur peut √™tre d√©sign√© comme nullable, ce qui rend le r√©sultat de l'appel de la classe une option.  Le constructeur peut √©galement avoir un modificateur throws, qui fonctionne mieux avec la s√©mantique de l'initialisation en deux phases dans Swift qu'avec la syntaxe des listes d'initialisation en C ++. </p><br><p>  Swift parvient √† fermer tous les trous des constructeurs dont je me plaignais.  Cependant, cela a un prix: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre d'initialisation est l'</a> un des plus importants du livre Swift. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  Quand les constructeurs sont vraiment n√©cessaires </h1><br><p>  Contre toute attente, je peux trouver au moins deux raisons pour lesquelles les constructeurs ne peuvent pas √™tre remplac√©s par des litt√©raux de structure, comme dans Rust. </p><br><p>  <em>Premi√®rement</em> , l'h√©ritage, √† un degr√© ou √† un autre, oblige le langage √† avoir des constructeurs.  Vous pouvez imaginer une extension de la syntaxe des structures avec prise en charge des classes de base: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  Mais cela ne fonctionnera pas dans une disposition d'objet typique d'un langage OO avec un h√©ritage simple!  En r√®gle g√©n√©rale, un objet commence par un titre suivi de champs de classe, de la base au plus d√©riv√©.  Ainsi, le pr√©fixe de l'objet de la classe d√©riv√©e est l'objet correct de la classe de base.  Cependant, pour qu'une telle mise en page fonctionne, le concepteur doit allouer de la m√©moire √† l'ensemble de l'objet √† la fois.  Il ne peut pas simplement allouer de la m√©moire uniquement pour la classe de base, puis attacher des champs d√©riv√©s.  Mais une telle allocation de m√©moire en morceaux est n√©cessaire si nous voulons utiliser la syntaxe pour cr√©er une structure o√π nous pourrions sp√©cifier une valeur pour la classe de base. </p><br><p>  <em>Deuxi√®mement</em> , contrairement √† la syntaxe litt√©rale de la structure, les concepteurs ont un ABI qui fonctionne bien avec le placement de sous-objets objet en m√©moire (ABI convivial pour le placement).  Le constructeur travaille avec un pointeur sur celui-ci, qui pointe vers la zone de m√©moire que le nouvel objet doit occuper.  Plus important encore, un constructeur peut facilement passer un pointeur vers des constructeurs de sous-objets, permettant ainsi la cr√©ation d'arbres de valeurs complexes "en place".  En revanche, dans Rust, la construction de structures comprend s√©mantiquement quelques copies, et nous esp√©rons ici la gr√¢ce de l'optimiseur.  Ce n'est pas un hasard si Rust n'a pas encore de proposition de travail accept√©e concernant le placement des sous-objets en m√©moire! </p><br><p>  Upd 1: correction d'une faute de frappe.  Remplac√© le "litt√©ral d'√©criture" par "litt√©ral de structure". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460831/">https://habr.com/ru/post/fr460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460819/index.html">WorldSkills: avis du participant de l'Olympiade</a></li>
<li><a href="../fr460821/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 307 (du 15 au 21 juillet)</a></li>
<li><a href="../fr460823/index.html">√âv√©nements num√©riques √† Moscou du 22 juillet au 28 juillet</a></li>
<li><a href="../fr460825/index.html">Introduction √† Screen Capture API - Scannez les codes QR dans un navigateur</a></li>
<li><a href="../fr460827/index.html">Probl√®me PGP</a></li>
<li><a href="../fr460833/index.html">Physique et √©conomie. Diff√©rence gnos√©ologique et sa manifestation en informatique</a></li>
<li><a href="../fr460837/index.html">Manuel du podcast pour d√©butants</a></li>
<li><a href="../fr460839/index.html">Lancer Predator - R√©f√©rentiels de donn√©es pr√©compil√©s</a></li>
<li><a href="../fr460841/index.html">TOP-23 applications d'apprentissage des langues</a></li>
<li><a href="../fr460843/index.html">Pr√©sentation du nouveau concepteur de flux d'appels 3CX et du g√©n√©rateur de mod√®les CRM 3CX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>