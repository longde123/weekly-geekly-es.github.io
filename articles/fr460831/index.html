<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏻 🐒 🧗 Les dangers des designers 👨‍👩‍👧‍👦 👨🏿‍🤝‍👨🏾 👨🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Les dangers des constructeurs" d'Aleksey Kladov. 


 Un de mes articles préférés sur le bl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les dangers des designers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460831/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article "Les dangers des constructeurs" d'Aleksey Kladov. </p><br><p>  Un de mes articles préférés sur le blog de Rust est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Things Rust Shipped Without de Graydon Hoare</a> .  Pour moi, l'absence de toute caractéristique de la langue qui peut tirer dans la jambe est généralement plus importante que l'expressivité.  Dans cet essai légèrement philosophique, je veux parler de ma caractéristique particulièrement préférée qui manque à Rust - à propos des constructeurs. </p><br><h1 id="chto-takoe-konstruktor">  Qu'est-ce qu'un constructeur? </h1><br><p>  Les constructeurs sont couramment utilisés dans les langages OO.  La tâche du constructeur est d'initialiser complètement l'objet avant que le reste du monde ne le voie.  À première vue, cela semble être une très bonne idée: </p><br><ol><li>  Vous <strong>définissez les invariants</strong> dans le constructeur. </li><li>  Chaque méthode prend en charge la <strong>conservation des</strong> invariants. </li><li>  Ensemble, ces deux propriétés signifient que vous pouvez considérer les objets comme des invariants et non comme des états internes spécifiques. </li></ol><br><p>  Le constructeur joue ici le rôle d'une base d'induction, étant le seul moyen de créer un nouvel objet. </p><br><p>  Malheureusement, il y a un trou dans ces arguments: le designer lui-même observe l'objet dans un état inachevé, ce qui crée de nombreux problèmes. <a name="habracut"></a></p><br><h1 id="znachenie-this">  Cette valeur </h1><br><p>  Lorsque le constructeur initialise l'objet, il commence par un état vide.  Mais comment définissez-vous cet état vide pour un objet arbitraire? </p><br><p>  La façon la plus simple de procéder consiste à définir tous les champs à leurs valeurs par défaut: false pour bool, 0 pour nombres, null pour tous les liens.  Mais cette approche nécessite que tous les types aient des valeurs par défaut et introduit le fameux null dans le langage.  C'est le chemin emprunté par Java: au début de la création de l'objet, tous les champs sont 0 ou null. </p><br><p>  Avec cette approche, il sera très difficile de se débarrasser de null par la suite.  Un bon exemple à apprendre est Kotlin.  Kotlin utilise des types non nullables par défaut, mais il est obligé de travailler avec la sémantique JVM préexistante.  La conception de la langue cache bien ce fait et est bien applicable dans la pratique, mais elle est <strong>intenable</strong> .  En d'autres termes, en utilisant des constructeurs, il est possible de contourner les vérifications nulles dans Kotlin. </p><br><p>  La principale caractéristique de Kotlin est l'encouragement à la création de soi-disant «constructeurs primaires» qui déclarent <strong>simultanément</strong> un champ et lui attribuent une valeur avant l'exécution de tout code personnalisé: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Autre option: si le champ n'est pas déclaré dans le constructeur, le programmeur doit l'initialiser immédiatement: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Tenter d'utiliser un champ avant l'initialisation est statiquement refusé: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  Mais avec un peu de créativité, tout le monde peut contourner ces contrôles.  Par exemple, un appel de méthode convient à ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Saisir également cela avec un lambda (qui est créé dans Kotlin comme suit: {args -&gt; body}) convient également: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Des exemples comme ceux-ci semblent irréalistes dans la réalité (et ce l'est), mais j'ai trouvé des erreurs similaires dans le code réel (règle de probabilité de Kolmogorov 0-1 dans le développement de logiciels: dans une base de données suffisamment grande, tout morceau de code est presque garanti d'exister, du moins sinon interdit statiquement par le compilateur; dans ce cas, il n'existe certainement pas). </p><br><p>  La raison pour laquelle Kotlin peut exister avec cet échec est la même que pour les tableaux covariants Java: les vérifications se produisent toujours pendant l'exécution.  Au final, je ne voudrais pas compliquer le système de type Kotlin afin de rendre les cas ci-dessus incorrects au stade de la compilation: compte tenu des limitations existantes (sémantique JVM), le rapport prix / bénéfice des validations en runtime est bien meilleur que celui des validations statiques. </p><br><p>  Mais que se passe-t-il si la langue n'a pas de valeur par défaut raisonnable pour chaque type?  Par exemple, en C ++, où les types définis par l'utilisateur ne sont pas nécessairement des références, vous ne pouvez pas simplement attribuer null à chaque champ et dire que cela fonctionnera!  Au lieu de cela, C ++ utilise une syntaxe spéciale pour définir les valeurs initiales des champs: listes d'initialisation: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Comme il s'agit d'une syntaxe spéciale, le reste du langage ne fonctionne pas parfaitement.  Par exemple, il est difficile de placer des opérations arbitraires dans les listes d'initialisation, car C ++ n'est pas un langage orienté expression (ce qui est normal en soi).  Pour travailler avec les exceptions qui se produisent dans les listes d'initialisation, vous devez utiliser une autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction obscure de la langue</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  Méthodes d'appel à partir du constructeur </h1><br><p>  Comme le montrent les exemples de Kotlin, tout se brise en puces dès que nous essayons d'appeler une méthode à partir du constructeur.  Fondamentalement, les méthodes s'attendent à ce que l'objet accessible par ce biais soit déjà entièrement construit et correct (cohérent avec les invariants).  Mais dans Kotlin ou Java, rien ne vous empêche d'appeler des méthodes du constructeur, et de cette façon nous pouvons accidentellement opérer sur un objet semi-construit.  Le concepteur promet d'établir des invariants, mais en même temps, c'est l'endroit le plus facile pour leur éventuelle violation. </p><br><p>  Des choses particulièrement étranges se produisent lorsque le constructeur de la classe de base appelle une méthode substituée dans une classe dérivée: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Pensez-y: le code d'une classe arbitraire est exécuté <strong>avant d'</strong> appeler son constructeur!  Un code C ++ similaire conduira à des résultats encore plus intéressants.  Au lieu d'appeler la fonction de la classe dérivée, la fonction de la classe de base sera appelée.  Cela n'a pas beaucoup de sens car la classe dérivée n'a pas encore été initialisée (rappelez-vous, nous ne pouvons pas simplement dire que tous les champs sont nuls).  Cependant, si la fonction de la classe de base est entièrement virtuelle, son appel conduira à UB. </p><br><h1 id="signatura-konstruktora">  Signature du designer </h1><br><p>  La violation des invariants n'est pas le seul problème pour les concepteurs.  Ils ont une signature avec un nom fixe (vide) et un type de retour (la classe elle-même).  Cela rend les surcharges de conception difficiles à comprendre pour les utilisateurs. </p><br><blockquote>  Question de renvoi: à quoi correspond std :: vector &lt;int&gt; xs (92, 2)? <br><br>  a.  Vecteur de deux longueurs 92 <br><br>  b.  [92, 92] <br><br>  c.  [92, 2] </blockquote><p>  Des problèmes avec la valeur de retour surviennent, en règle générale, lorsqu'il est impossible de créer un objet.  Vous ne pouvez pas simplement renvoyer Result &lt;MyClass, io :: Error&gt; ou null du constructeur! </p><br><p>  Ceci est souvent utilisé comme argument en faveur du fait que l'utilisation de C ++ sans exception est difficile, et que l'utilisation de constructeurs vous oblige également à utiliser des exceptions.  Cependant, je ne pense pas que cet argument soit correct: les méthodes d'usine résolvent ces deux problèmes, car elles peuvent avoir des noms arbitraires et renvoyer des types arbitraires.  Je crois que le modèle suivant peut parfois être utile dans les langues OO: </p><br><ul><li><p>  Créez un constructeur <strong>privé</strong> qui prend les valeurs de tous les champs comme arguments et les affecte simplement.  Ainsi, un tel constructeur fonctionnerait comme une structure littérale dans Rust.  Il peut également rechercher des invariants, mais il ne doit rien faire d'autre avec des arguments ou des champs. </p><br></li><li><p>  des méthodes de fabrique publique sont fournies pour l'API publique avec des noms et des types de retour appropriés. </p><br></li></ul><br><p>  Un problème similaire avec les constructeurs est qu'ils sont spécifiques et ne peuvent donc pas être généralisés.  En C ++, «il y a un constructeur par défaut» ou «il y a un constructeur de copie» ne peut pas être exprimé plus simplement que «certaines <em>syntaxes</em> fonctionnent».  Comparez cela à Rust, où ces concepts ont des signatures appropriées: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  La vie sans designers </h1><br><p>  Rust n'a qu'une seule façon de créer une structure: fournir des valeurs pour tous les champs.  Les fonctions d'usine, telles que la nouvelle généralement acceptée, jouent le rôle de constructeurs, mais, surtout, elles ne vous permettent d'appeler aucune méthode tant que vous n'avez pas au moins une instance plus ou moins correcte de la structure. </p><br><p>  L'inconvénient de cette approche est que tout code peut créer une structure, il n'y a donc pas un seul endroit, tel qu'un constructeur, pour maintenir les invariants.  En pratique, cela est facilement résolu par la confidentialité: si les champs de la structure sont privés, cette structure ne peut être créée que dans le même module.  Au sein d' <em>un même</em> module, il n'est pas difficile d'adhérer à l'accord "toutes les méthodes de création d'une structure doivent utiliser la nouvelle méthode".  Vous pouvez même imaginer une extension de langage qui vous permet de marquer certaines fonctions avec l'attribut # [constructeur], de sorte que la syntaxe littérale de la structure n'est disponible que dans les fonctions marquées.  Mais, encore une fois, des mécanismes linguistiques supplémentaires me semblent redondants: suivre <strong>les</strong> conventions <strong>locales</strong> nécessite peu d'efforts. </p><br><blockquote>  Personnellement, je pense que ce compromis est exactement le même pour la programmation des contrats en général.  Les contrats comme «non nul» ou «valeur positive» sont mieux encodés en types.  Pour les invariants complexes, écrire simplement assert! (Self.validate ()) dans chaque méthode n'est pas si difficile.  Entre ces deux modèles, il y a peu de place pour les conditions # [pre] et # [post] implémentées au niveau de la langue ou basées sur des macros. </blockquote><br><h1 id="a-chto-naschet-swift">  Et Swift? </h1><br><p>  Swift est un autre langage intéressant qui mérite un regard sur les mécanismes de conception.  Comme Kotlin, Swift est un langage sans danger.  Contrairement à Kotlin, les contrôles nuls de Swift sont plus forts, donc le langage utilise des astuces intéressantes pour atténuer les dommages causés par les constructeurs. </p><br><p>  <em>Tout d'abord</em> , Swift utilise des arguments nommés, et cela aide un peu avec «tous les constructeurs ont le même nom».  En particulier, deux constructeurs avec les mêmes types de paramètres ne sont pas un problème: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Deuxièmement</em> , pour résoudre le problème "le constructeur appelle la méthode virtuelle de la classe de l'objet qui n'a pas encore été entièrement créé" Swift utilise un protocole d'initialisation en deux phases bien pensé.  Bien qu'il n'y ait pas de syntaxe spéciale pour les listes d'initialisation, le compilateur vérifie statiquement que le corps du constructeur a la forme correcte et sûre.  Par exemple, l'appel de méthodes n'est possible qu'après l'initialisation de tous les champs de la classe et de ses descendants. </p><br><p>  <em>Troisièmement</em> , au niveau du langage, il existe un support pour les constructeurs, dont l'appel peut échouer.  Le constructeur peut être désigné comme nullable, ce qui rend le résultat de l'appel de la classe une option.  Le constructeur peut également avoir un modificateur throws, qui fonctionne mieux avec la sémantique de l'initialisation en deux phases dans Swift qu'avec la syntaxe des listes d'initialisation en C ++. </p><br><p>  Swift parvient à fermer tous les trous des constructeurs dont je me plaignais.  Cependant, cela a un prix: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre d'initialisation est l'</a> un des plus importants du livre Swift. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  Quand les constructeurs sont vraiment nécessaires </h1><br><p>  Contre toute attente, je peux trouver au moins deux raisons pour lesquelles les constructeurs ne peuvent pas être remplacés par des littéraux de structure, comme dans Rust. </p><br><p>  <em>Premièrement</em> , l'héritage, à un degré ou à un autre, oblige le langage à avoir des constructeurs.  Vous pouvez imaginer une extension de la syntaxe des structures avec prise en charge des classes de base: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  Mais cela ne fonctionnera pas dans une disposition d'objet typique d'un langage OO avec un héritage simple!  En règle générale, un objet commence par un titre suivi de champs de classe, de la base au plus dérivé.  Ainsi, le préfixe de l'objet de la classe dérivée est l'objet correct de la classe de base.  Cependant, pour qu'une telle mise en page fonctionne, le concepteur doit allouer de la mémoire à l'ensemble de l'objet à la fois.  Il ne peut pas simplement allouer de la mémoire uniquement pour la classe de base, puis attacher des champs dérivés.  Mais une telle allocation de mémoire en morceaux est nécessaire si nous voulons utiliser la syntaxe pour créer une structure où nous pourrions spécifier une valeur pour la classe de base. </p><br><p>  <em>Deuxièmement</em> , contrairement à la syntaxe littérale de la structure, les concepteurs ont un ABI qui fonctionne bien avec le placement de sous-objets objet en mémoire (ABI convivial pour le placement).  Le constructeur travaille avec un pointeur sur celui-ci, qui pointe vers la zone de mémoire que le nouvel objet doit occuper.  Plus important encore, un constructeur peut facilement passer un pointeur vers des constructeurs de sous-objets, permettant ainsi la création d'arbres de valeurs complexes "en place".  En revanche, dans Rust, la construction de structures comprend sémantiquement quelques copies, et nous espérons ici la grâce de l'optimiseur.  Ce n'est pas un hasard si Rust n'a pas encore de proposition de travail acceptée concernant le placement des sous-objets en mémoire! </p><br><p>  Upd 1: correction d'une faute de frappe.  Remplacé le "littéral d'écriture" par "littéral de structure". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460831/">https://habr.com/ru/post/fr460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460819/index.html">WorldSkills: avis du participant de l'Olympiade</a></li>
<li><a href="../fr460821/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 307 (du 15 au 21 juillet)</a></li>
<li><a href="../fr460823/index.html">Événements numériques à Moscou du 22 juillet au 28 juillet</a></li>
<li><a href="../fr460825/index.html">Introduction à Screen Capture API - Scannez les codes QR dans un navigateur</a></li>
<li><a href="../fr460827/index.html">Problème PGP</a></li>
<li><a href="../fr460833/index.html">Physique et économie. Différence gnoséologique et sa manifestation en informatique</a></li>
<li><a href="../fr460837/index.html">Manuel du podcast pour débutants</a></li>
<li><a href="../fr460839/index.html">Lancer Predator - Référentiels de données précompilés</a></li>
<li><a href="../fr460841/index.html">TOP-23 applications d'apprentissage des langues</a></li>
<li><a href="../fr460843/index.html">Présentation du nouveau concepteur de flux d'appels 3CX et du générateur de modèles CRM 3CX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>