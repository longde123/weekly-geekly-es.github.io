<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💼 ☠️ 🎽 Unter der Haube von React. Wir schreiben unsere Implementierung von Grund auf neu 👨🏿‍🎤 🧗 👨🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dieser Artikelserie erstellen wir unsere eigene React-Implementierung von Grund auf neu. Am Ende haben Sie ein Verständnis dafür, wie React funktio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unter der Haube von React. Wir schreiben unsere Implementierung von Grund auf neu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458916/">  In dieser Artikelserie erstellen wir unsere eigene React-Implementierung von Grund auf neu.  Am Ende haben Sie ein Verständnis dafür, wie React funktioniert, welche Methoden des Komponentenlebenszyklus aufgerufen werden und warum.  Der Artikel richtet sich an diejenigen, die React bereits verwendet haben und mehr über sein Gerät erfahren möchten, oder an Neugierige. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/ea8/66a/9d8ea866a9fac6aadd47eb3d51026f61.jpg" alt="Bild"><br><a name="habracut"></a><br>  Dieser Artikel ist eine Übersetzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React Internals, Teil 1: Grundlegendes Rendering</a> <br><br><h2>  Dies ist tatsächlich der erste von fünf Artikeln </h2><br><ol><li>  Grundlagen des Renderns &lt;- wir sind hier </li><li>  ComponentWillMount und componentDidMount </li><li>  Update </li><li>  setState </li><li>  Transaktionen </li></ol><br><blockquote>  Material wurde erstellt, als React 15.3 relevant war, insbesondere die Verwendung von ReactDOM und Stack Reconciler.  Reaktion 16 und höher hat einige Änderungen.  Dieses Material bleibt jedoch relevant, da es eine allgemeine Vorstellung davon gibt, was „unter der Haube“ geschieht. <br></blockquote><h2>  Teil 1. Grundlagen des Renderns </h2><br><h3>  Elemente und Komponenten </h3><br>  In React gibt es drei Arten von Entitäten: ein natives DOM-Element, ein virtuelles React-Element und eine Komponente. <br><br><h4>  Native DOM-Elemente </h4><br>  Dies sind die DOM-Elemente, mit denen der Browser die Webseite erstellt, z. B. div, span, h1.  React erstellt sie durch Aufrufen von document.createElement () und interagiert mit der Seite mithilfe browserbasierter DOM-API-Methoden wie element.insertBefore (), element.nodeValue und anderen. <br><br><h4>  Virtuelles Reaktionselement </h4><br>  Ein virtuelles React-Element (oft einfach als „Element“ bezeichnet) ist ein Javascript-Objekt, das die erforderlichen Eigenschaften enthält, um ein natives DOM-Element oder einen Baum solcher Elemente zu erstellen oder zu aktualisieren.  Basierend auf dem virtuellen React-Element werden native DOM-Elemente wie div, span, h1 und andere erstellt.  Wir können sagen, dass ein virtuelles React-Element eine Instanz einer benutzerdefinierten zusammengesetzten Komponente ist, mehr dazu weiter unten. <br><br><h4>  Komponente </h4><br>  Komponente ist ein ziemlich allgemeiner Begriff in React.  Komponenten sind Entitäten, mit denen React verschiedene Manipulationen durchführt.  Unterschiedliche Komponenten dienen unterschiedlichen Zwecken.  Beispielsweise ist die ReactDomComponent aus der ReactDom-Bibliothek für die Bindung zwischen React-Elementen und ihren entsprechenden nativen DOM-Elementen verantwortlich. <br><br><h4>  Benutzerdefinierte zusammengesetzte Komponenten </h4><br>  Höchstwahrscheinlich sind Sie bereits auf diese Art von Komponente gestoßen.  Wenn Sie React.createClass () aufrufen oder ES6-Klassen verwenden, indem Sie React.Component erweitern, erstellen Sie eine benutzerdefinierte zusammengesetzte Komponente.  Eine solche Komponente verfügt über Lebenszyklusmethoden wie componentWillMount, shouldComponentUpdate und andere.  Wir können sie neu definieren, um eine Art Logik hinzuzufügen.  Darüber hinaus werden andere Methoden erstellt, z. B. mountComponent, receiveComponent.  Diese Methoden werden von React nur für interne Zwecke verwendet, wir interagieren in keiner Weise mit ihnen. <br><br><div class="spoiler">  <b class="spoiler_title">ZanudaMode = on</b> <div class="spoiler_text">  Tatsächlich sind vom Benutzer erstellte Komponenten zunächst nicht vollständig.  React verpackt sie in einen ReactCompositeComponentWrapper, der unseren Komponenten alle Lebenszyklusmethoden hinzufügt, wonach React sie verwalten kann (Einfügen, Aktualisieren usw.). <br></div></div><br><h3>  Deklarativ reagieren </h3><br>  Wenn es um benutzerdefinierte Komponenten geht, besteht unsere Aufgabe darin, die Klassen dieser Komponenten zu definieren, aber wir instanziieren diese Klassen nicht.  React erstellt sie bei Bedarf. <br><br>  Außerdem erstellen wir keine expliziten Elemente mit einem imperativen Stil, sondern schreiben mit JSX in einem deklarativen Stil: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Dieser Code mit JSX-Markup wird vom Compiler in Folgendes übersetzt: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } }</code> </pre> <br>  Das heißt, es wird im Wesentlichen zu einem zwingenden Konstrukt zum Erstellen eines Elements durch einen expliziten Aufruf von React.createElement ().  Diese Konstruktion befindet sich jedoch in der render () -Methode, die wir nicht explizit aufrufen. React ruft diese Methode bei Bedarf selbst auf.  React wahrzunehmen ist daher genauso deklarativ: Wir beschreiben, was wir empfangen möchten, und React bestimmt, wie es geht. <br><br><h3>  Schreiben Sie Ihre kleine Reaktion </h3><br>  Nachdem wir die erforderliche technische Basis erhalten haben, werden wir beginnen, unsere eigene React-Implementierung zu erstellen.  Dies wird eine sehr vereinfachte Version sein, nennen wir es Feact. <br><br>  Angenommen, wir möchten eine einfache Feact-Anwendung erstellen, deren Code folgendermaßen aussehen würde: <br><br><pre> <code class="javascript hljs">Feact.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello world</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>));</code> </pre> <br>  Lassen Sie uns zunächst über JSX abschweifen.  Dies ist genau ein „Rückzug“, da das JSX-Parsing ein separates großes Thema ist, das wir im Rahmen unserer Feact-Implementierung weglassen werden.  Wenn wir uns mit verarbeitetem JSX befassen würden, würden wir den folgenden Code sehen: <br><br><pre> <code class="javascript hljs">Feact.render( Feact.createElement(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>) );</code> </pre> <br>  Das heißt, wir verwenden Feact.createElement anstelle von JSX.  Also implementieren wir diese Methode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement(type, props, children) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = { type, <span class="hljs-attr"><span class="hljs-attr">props</span></span>: props || {} }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) { element.props.children = children; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } };</code> </pre> <br>  Das zurückgegebene Element ist ein einfaches Objekt, das darstellt, was wir rendern möchten. <br><br><h3>  Was macht Feact.render ()? </h3><br>  Durch Aufrufen von Feact.render () übergeben wir zwei Parameter: Was wir rendern möchten und wo.  Dies ist der Ausgangspunkt jeder React-Anwendung.  Schreiben wir eine Implementierung der render () -Methode für Feact: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement() { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } };</code> </pre> <br>  Nach Abschluss von render () erhalten wir eine fertige Webseite.  DOM-Elemente werden von FeactDOMComponent erstellt.  Schreiben wir die Implementierung: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactDOMComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props.children; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> textNode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._hostNode = domElement; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domElement; } }</code> </pre> <br>  Die mountComponent-Methode erstellt ein DOM-Element und speichert es in this._hostNode.  Wir werden es jetzt nicht verwenden, aber wir werden in den folgenden Teilen darauf zurückkommen. <br><br>  Die aktuelle Version der Anwendung kann in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geige</a> angezeigt werden. <br><br>  Buchstäblich 40 Codezeilen reichten aus, um eine primitive Implementierung von React durchzuführen.  Es ist unwahrscheinlich, dass die von uns geschaffene Funktion die Welt erobert, aber sie spiegelt gut die Essenz dessen wider, was unter der Haube von React geschieht. <br><br><h3>  Benutzerdefinierte Komponenten hinzufügen </h3><br>  Unser Feact sollte nicht nur HTML-Elemente (div, span usw.) rendern können, sondern auch benutzerdefinierte zusammengesetzte Komponenten: <br><blockquote>  Die zuvor beschriebene Feact.createElement () -Methode ist derzeit in Ordnung, daher werde ich sie in der Codeliste nicht wiederholen. <br></blockquote><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createClass(spec) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; } Constructor.prototype.render = spec.render; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Constructor; }, render(element, container) { <span class="hljs-comment"><span class="hljs-comment">//      //   , //    } }; const MyTitle = Feact.createClass({ render() { return Feact.createElement('h1', null, this.props.message); } }; Feact.render({ Feact.createElement(MyTitle, { message: 'hey there Feact' }), document.getElementById('root') );</span></span></code> </pre> <br>  Wenn JSX verfügbar wäre, würde der Aufruf der render () -Methode folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">Feact.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTitle</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"hey there Feact"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root') );</span></span></code> </pre> <br>  Wir haben die benutzerdefinierte Komponentenklasse an createElement übergeben.  Ein virtuelles React-Element kann entweder ein reguläres DOM-Element oder eine benutzerdefinierte Komponente darstellen.  Wir werden sie wie folgt unterscheiden: Wenn wir einen Zeichenfolgentyp übergeben, ist dies ein DOM-Element;  Wenn es sich um eine Funktion handelt, repräsentiert dieses Element eine benutzerdefinierte Komponente. <br><br><h3>  Verbesserung von Feact.render () </h3><br>  Wenn Sie sich den Code im Moment genau ansehen, werden Sie feststellen, dass Feact.render () keine benutzerdefinierten Komponenten verarbeiten kann.  Lassen Sie uns das beheben: <br><br><pre> <code class="javascript hljs">Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domComponentInstance.mountComponent(container); } }</code> </pre> <br>  Wir haben einen Wrapper für das übergebene Element erstellt.  Innerhalb des Wrappers erstellen wir eine Instanz der Benutzerkomponentenklasse und rufen deren componentInstance.render () -Methode auf.  Das Ergebnis dieser Methode kann an FeactDOMComponent übergeben werden, wo die entsprechenden DOM-Elemente erstellt werden. <br><br>  Jetzt können wir benutzerdefinierte Komponenten erstellen und rendern.  Feact erstellt DOM-Knoten basierend auf benutzerdefinierten Komponenten und ändert sie abhängig von den Eigenschaften (Requisiten) unserer benutzerdefinierten Komponenten.  Dies ist eine signifikante Verbesserung unserer Funktion. <br><blockquote>  Beachten Sie, dass der FeactCompositeComponentWrapper die FeactDOMComponent direkt erstellt.  Eine so enge Beziehung ist schlecht.  Wir werden das später beheben.  Wenn React dieselbe enge Verbindung hätte, könnten nur Webanwendungen erstellt werden.  Durch Hinzufügen einer zusätzlichen Ebene Mit ReactCompositeComponentWrapper können Sie die React-Logik für die Verwaltung virtueller Elemente und die endgültige Anzeige nativer Elemente trennen. So können Sie React nicht nur beim Erstellen von Webanwendungen verwenden, sondern beispielsweise auch React Native für Mobilgeräte. <br></blockquote><h3>  Benutzerdefinierte Komponentenerweiterung </h3><br>  Erstellte benutzerdefinierte Komponenten können nur native DOM-Elemente zurückgeben. Wenn wir versuchen, andere benutzerdefinierte Komponenten zurückzugeben, wird eine Fehlermeldung angezeigt.  Korrigieren Sie diesen Fehler.  Stellen Sie sich vor, wir möchten den folgenden Code fehlerfrei ausführen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyMessage = Feact.createClass({ render() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.asTitle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(MyTitle, { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(<span class="hljs-string"><span class="hljs-string">'p'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); } } }</code> </pre><br>  Die render () -Methode einer benutzerdefinierten Komponente kann entweder ein natives DOM-Element oder eine andere benutzerdefinierte Komponente zurückgeben.  Wenn die asTitle-Eigenschaft true ist, gibt der FeactCompositeComponentWrapper die benutzerdefinierte Komponente für die FeactDOMComponent zurück, in der der Fehler auftritt.  Fix FeactCompositeComponentWrapper: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> element.type === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { element = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> element.type(element.props)).render(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); domComponentInstance.mountComponent(container); } }</code> </pre><br>  In Wahrheit haben wir jetzt eine Krücke gebaut, um den aktuellen Bedürfnissen gerecht zu werden.  Ein Aufruf der Rendermethode gibt untergeordnete Komponenten zurück, bis ein natives DOM-Element zurückgegeben wird.  Dies ist schlecht, da solche untergeordneten Komponenten nicht am Lebenszyklus teilnehmen.  In diesem Fall können wir beispielsweise den Aufruf von componentWillMount nicht implementieren.  Wir werden das später beheben. <br><br><h3>  Und wieder reparieren wir Feact.render () </h3><br>  Die erste Version von Feact.render () konnte nur native DOM-Elemente verarbeiten.  Jetzt werden nur benutzerdefinierte Komponenten ohne native Unterstützung korrekt verarbeitet.  Es ist notwendig, beide Fälle zu behandeln.  Sie können eine Factory schreiben, die abhängig von der Art des übergebenen Elements eine Komponente erstellt. React hat jedoch einen anderen Weg gewählt: Wickeln Sie einfach alle eingehenden Komponenten in eine andere Komponente ein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TopLevelWrapper = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; }; TopLevelWrapper.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapperElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createElement(TopLevelWrapper, element); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(wrapperElement); <span class="hljs-comment"><span class="hljs-comment">//   } };</span></span></code> </pre><br>  TopLevelWrapper ist im Wesentlichen eine benutzerdefinierte Komponente.  Sie kann auch durch Aufrufen von Feact.createClass () definiert werden.  Die Render-Methode gibt einfach das übergebene Element zurück.  Jetzt wird jedes Element in TopLevelWrapper eingeschlossen, und FeactCompositeComponentWrapper erhält immer eine benutzerdefinierte Komponente als Eingabe. <br><br><h3>  Abschluss des ersten Teils </h3><br>  Wir haben Feact implementiert, mit dem Komponenten gerendert werden können.  Der generierte Code zeigt die Grundkonzepte des Renderns.  Reales Rendern in React ist viel komplizierter und umfasst Ereignisse, Fokus, Bildlauf, Leistung usw. <br><br>  Die letzte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geige des</a> ersten Teils. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458916/">https://habr.com/ru/post/de458916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458906/index.html">[Jekaterinburg, Ankündigung] Flutteron - ein Workshop zur Entwicklung von Flutter</a></li>
<li><a href="../de458908/index.html">Scannen von Dokumenten über das Netzwerk</a></li>
<li><a href="../de458910/index.html">Benchmarking von PostgreSQL mit großen Linux-Seiten</a></li>
<li><a href="../de458912/index.html">Mit Imapsync nach Zimbra migrieren</a></li>
<li><a href="../de458914/index.html">Was (nicht) Sie wissen müssen, um Spiele auf Unity zu erstellen</a></li>
<li><a href="../de458918/index.html">Was Sie aus dem Design von Hyper-Casual-Spielen lernen können</a></li>
<li><a href="../de458920/index.html">Konferenz für DevOps-Fans</a></li>
<li><a href="../de458922/index.html">So wechseln Sie von ESXi zu KVM / LXD und verlieren nicht den Verstand</a></li>
<li><a href="../de458924/index.html">Unfälle helfen Ihnen beim Lernen</a></li>
<li><a href="../de458926/index.html">Die Tragödie kommt nicht allein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>