<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ”¬ ğŸ’ªğŸ¾ ğŸ‘¨ğŸ¼â€âš•ï¸ Beralih ke Next.js dan mempercepat pemuatan beranda manifold.co 7,5 kali â£ï¸ ğŸ‘¸ğŸ» ğŸ‘©ğŸ»â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan terjemahan cerita tentang bagaimana transisi dari React Boilerplate ke Next.js , sebuah kerangka kerja untuk mengembangkan a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beralih ke Next.js dan mempercepat pemuatan beranda manifold.co 7,5 kali</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442654/">  Hari ini kami menerbitkan terjemahan cerita tentang bagaimana transisi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React Boilerplate</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Next.js</a> , sebuah kerangka kerja untuk mengembangkan aplikasi web progresif berdasarkan React, telah mempercepat pemuatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beranda</a> situs proyek manifold.co 7,5 kali.  Tidak ada perubahan lain yang dilakukan pada proyek, dan transisi ini, secara umum, ternyata sama sekali tidak terlihat oleh bagian lain dari sistem.  Apa yang ternyata pada akhirnya ternyata lebih baik dari yang diharapkan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ci/bc/g5/cibcg5cgvkbkyimgtleiv21hmgy.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ikhtisar Hasil</font> </h2><br>  Bahkan, kita dapat mengatakan bahwa transisi ke Next.js memberi kita sesuatu seperti "peningkatan produktivitas proyek yang muncul entah dari mana".  Beginilah tampilan waktu proyek ketika menggunakan berbagai sumber daya perangkat keras dan koneksi jaringan. <br><table><tbody><tr><td>  Koneksi <br></td><td width="130">  CPU <br></td><td width="130">  Ke detik <br></td><td width="130">  Setelah beberapa detik <br></td><td width="130">  % Peningkatan <br></td></tr><tr><td>  Cepat (200 Mbps) <br></td><td>  Cepat <br></td><td>  1.5 <br></td><td>  0,2 <br></td><td>  750 <br></td></tr><tr><td>  Sedang (3G) <br></td><td>  Cepat <br></td><td>  5.6 <br></td><td>  1.1 <br></td><td>  500 <br></td></tr><tr><td>  Sedang (3G) <br></td><td>  Sedang <br></td><td>  7.5 <br></td><td>  1.3 <br></td><td>  570 <br></td></tr><tr><td>  Lambat (koneksi 3G lambat) <br></td><td>  Sedang <br></td><td>  22 <br></td><td>  4 <br></td><td>  550 <br></td></tr></tbody></table><br>  Saat menggunakan koneksi cepat dan perangkat dengan prosesor cepat, waktu muat situs turun dari 1,5 detik.  hingga 0,2 s., yaitu, indikator ini meningkat 7,5 kali.  Pada koneksi berkualitas menengah dan pada perangkat dengan kinerja rata-rata, waktu muat situs turun dari 7,5 detik.  hingga 1,3 dtk <br><br><h2>  <font color="#3AC1EF">Apa yang terjadi setelah pengguna mengklik URL?</font> </h2><br>  Untuk memahami fitur-fitur dari pekerjaan aplikasi web progresif (Progressive Web App, PWA), pertama-tama Anda perlu mencari tahu apa yang terjadi antara saat ketika pengguna mengklik URL (di alamat situs kami) dan saat ketika ia melihat sesuatu. di jendela browser (dalam hal ini, aplikasi Bereaksi kami). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c6/f9b/060/8c6f9b060a4fd4ff13cd525b62c98477.jpg"></div><br>  <i><font color="#999999">Tahapan Aplikasi</font></i> <br><br>  Pertimbangkan 5 tahapan bekerja dengan aplikasi, diagram yang diberikan di atas. <br><br><ol><li>  Pengguna pergi ke URL, sistem mengetahui alamat server menggunakan DNS dan mengakses server.  Semua ini dilakukan dengan sangat cepat, biasanya memakan waktu kurang dari 100 milidetik, tetapi langkah ini membutuhkan waktu, itulah sebabnya disebutkan di sini. </li><li>  Sekarang server mengembalikan kode HTML halaman, tetapi halaman di browser tetap kosong sampai sumber daya yang diperlukan untuk tampilan dimuat (kecuali sumber daya dimuat secara tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinkron</a> ).  Sebenarnya, lebih banyak tindakan yang terjadi pada tahap ini daripada yang ditunjukkan dalam diagram, tetapi tinjauan bersama dari semua proses ini juga akan cocok untuk kita. </li><li> Setelah memuat kode HTML dan sumber daya yang paling penting, browser mulai menampilkan apa yang dapat ditampilkannya, terus memuat yang lainnya (gambar, misalnya) di latar belakang.  Pernahkah Anda bertanya-tanya mengapa gambar kadang-kadang tiba-tiba "muncul" pada halaman jelas lebih cepat dari yang diperlukan, dan kadang-kadang memuat terlalu lama?  Inilah mengapa ini terjadi.  Pendekatan ini memungkinkan Anda membuat halaman selesai dengan cepat. </li><li>  Kode JavaScript dapat diuraikan dan dieksekusi hanya setelah dimuat.  Bergantung pada ukuran kode JS yang digunakan pada halaman (dan ini mungkin, untuk aplikasi Bereaksi khas, cukup besar jika kode tersebut dikemas dalam satu file) mungkin perlu beberapa detik atau bahkan lebih (perhatikan bahwa JS kode tidak perlu, untuk mulai mengeksekusi, tunggu pemuatan semua sumber daya lainnya, meskipun pada diagram terlihat persis seperti itu). </li><li>  Dalam kasus aplikasi Bereaksi, momen sekarang datang ketika kode memodifikasi DOM, yang menyebabkan browser untuk menggambar kembali halaman yang sudah ditampilkan.  Kemudian siklus pemuatan sumber daya lain dimulai.  Waktu yang dibutuhkan langkah ini akan tergantung pada kompleksitas halaman. </li></ol><br><h2>  <font color="#3AC1EF">Semakin cepat, semakin baik.</font> </h2><br>  Karena aplikasi web progresif mengambil kode Bereaksi dan menghasilkan kode HTML dan CSS statis, ini berarti bahwa pengguna melihat aplikasi Bereaksi sudah pada langkah 3 dari skema di atas, dan bukan pada langkah 5. Dalam pengujian kami, ini membutuhkan 0,2-4 detik , yang tergantung pada kecepatan koneksi pengguna ke Internet dan perangkatnya.  Ini jauh lebih baik daripada 1,5-22 detik sebelumnya.  Aplikasi web progresif adalah cara yang andal untuk mengirimkan aplikasi Bereaksi lebih cepat kepada pengguna. <br><br>  Alasan bahwa aplikasi web progresif dan kerangka kerja terkait seperti Next.js masih belum begitu populer adalah karena, secara tradisional, kerangka kerja JS tidak terlalu berhasil dalam menghasilkan kode HTML statis.  Hari ini, semuanya telah banyak berubah karena fakta bahwa kerangka kerja seperti React, Vue dan Angular, dan lainnya, memiliki dukungan yang sangat baik untuk rendering sisi server.  Namun, untuk menggunakan alat-alat ini, Anda masih membutuhkan pemahaman yang mendalam tentang fitur-fitur karya bundler dan alat untuk membangun proyek.  Bekerja dengan semua ini bukan tanpa masalah. <br><br>  Munculnya kerangka kerja PWA baru-baru ini seperti Next.js dan Gatsby (keduanya muncul pada akhir 2016 - awal 2017) adalah langkah serius menuju adopsi PWA yang luas karena hambatan masuk yang lebih rendah dan karena fakta bahwa kerangka kerja tersebut menggunakan tugas tersebut sebagai tugas yang sederhana dan menyenangkan. <br><br>  Meskipun tidak setiap aplikasi dapat ditransfer ke Next.js, untuk banyak aplikasi Bereaksi transisi ini berarti "kinerja entah dari mana" yang kita bicarakan di sini, ditambah dengan penggunaan sumber daya jaringan yang bahkan lebih efisien. <br><br><h2>  <font color="#3AC1EF">Seberapa sulitkah untuk bermigrasi ke Next.js?</font> </h2><br>  Secara umum, dapat dicatat bahwa menerjemahkan beranda kami ke Next.js tidak terlalu sulit.  Namun, kami menemui beberapa kesulitan yang disebabkan oleh fitur arsitektur aplikasi kami. <br><br><h3>  <font color="#3AC1EF">â– Menolak React Router</font> </h3><br>  Kami harus meninggalkan router React karena Next.js memiliki router bawaannya sendiri, yang lebih baik dikombinasikan dengan optimisasi mengenai pemisahan kode yang dilakukan di atas arsitektur PWA.  Ini memungkinkan router ini untuk menyediakan pemuatan halaman yang jauh lebih cepat daripada yang Anda harapkan dari router sisi klien mana pun. <br><br>  Router Next.js adalah sedikit router React berkecepatan tinggi, tetapi masih bukan router React. <br><br>  Dalam praktiknya, karena kami tidak memanfaatkan fitur-fitur canggih yang ditawarkan router React, transisi ke router Next.js bagi kami adalah dengan hanya mengganti komponen router React standar dengan komponen Next.js yang sesuai: <br><br><pre><code class="plaintext hljs">/*   ( React) */ &lt;Link to="/my/page"&gt;  A link &lt;/Link&gt; /*   ( Next.js) */ &lt;Link href="/my/page" passHref&gt;  &lt;a&gt;    A link  &lt;/a&gt; &lt;/Link&gt;</code> </pre> <br>  Secara umum, semuanya ternyata tidak terlalu buruk.  Kami harus mengubah nama properti dan menambahkan tag untuk keperluan rendering server.  Karena kami juga menggunakan pustaka <code>styled-components</code> , ternyata dalam sebagian besar kasus kami perlu menambahkan properti <code>passHref</code> untuk memastikan bahwa sistem berperilaku sedemikian rupa sehingga <code>href</code> selalu menunjuk ke tag yang dihasilkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/5dd/e79/d7c5dde797101c30c2cf0e6507e07881.png"></div><br>  <i><font color="#999999">Permintaan Jaringan untuk manifold.co</font></i> <br><br>  Untuk melihat dengan optimalisasi router Next.js dengan mata kepala Anda sendiri, buka tab Network dari alat pengembang browser dengan melihat halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manifold.co</a> dan klik pada beberapa tautan.  Gambar sebelumnya menunjukkan hasil mengklik tautan <code>/services</code> .  Seperti yang Anda lihat, ini mengarah pada eksekusi permintaan untuk memuat <code>services.js</code> alih-alih mengeksekusi permintaan biasa. <br><br>  Saya tidak hanya berbicara tentang perutean sisi klien, router Bereaksi juga cocok untuk menyelesaikan masalah ini.  Saya sedang berbicara tentang bagian nyata dari kode JavaScript yang telah diekstraksi dari sisa kode dan dimuat berdasarkan permintaan.  Ini dilakukan dengan menggunakan Next.js. standar  Dan ini jauh lebih baik daripada yang kita miliki sebelumnya.  Yaitu, kita berbicara tentang paket besar kode JS dengan ukuran 1,7 MB, yang klien, sebelum dia bisa melihat sesuatu, harus mengunduh dan memproses. <br><br>  Meskipun solusi yang disajikan di sini tidak sempurna, itu jauh lebih dekat daripada yang sebelumnya dengan gagasan bahwa pengguna hanya mengunduh kode untuk halaman yang mereka lihat. <br><br><h3>  <font color="#3AC1EF">â– Fitur menggunakan Redux</font> </h3><br>  Melanjutkan topik kesulitan yang terkait dengan transisi ke Next.js, dapat dicatat bahwa semua optimasi menarik yang dilakukan Next.js terhadap aplikasi memiliki dampak tertentu pada aplikasi ini.  Yaitu, karena Next.js melakukan pemisahan kode tingkat halaman, itu mencegah pengembang mengakses komponen <code>React</code> root atau metode <code>render()</code> dari perpustakaan <code>react-dom</code> .  Jika Anda telah terlibat dalam mengonfigurasi Redux, maka Anda dapat mencatat bahwa semua ini memberi tahu kami bahwa untuk operasi normal dengan Redux kita perlu menyelesaikan masalah, yaitu bahwa tidak jelas di mana tepatnya mencari Redux. <br><br>  Next.js menyediakan komponen tingkat tinggi khusus, <code>withRedux</code> , yang <code>withRedux</code> sebagai pembungkus untuk semua komponen tingkat atas pada setiap halaman: <br><br><pre> <code class="plaintext hljs">export default withRedux(HomePage);</code> </pre> <br>  Meskipun semua ini tidak terlalu buruk, tetapi jika Anda memerlukan metode <code>createStore()</code> , seperti ketika menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redux-reducer-injectors</a> , harap Anda perlu waktu ekstra untuk men-debug pembungkus (dan omong-omong, jangan pernah mencoba gunakan sesuatu seperti <code>redux-reducer-injectors</code> ). <br><br>  Selain itu, karena fakta bahwa Redux sekarang menjadi "kotak hitam", menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Immutable</a> dengan itu menjadi bermasalah.  Meskipun fakta bahwa Immutable akan bekerja dengan Redux tampaknya cukup jelas, saya mengalami masalah.  Jadi, baik tingkat atas tidak berubah ( <code>get is not a function</code> kesalahan <code>get is not a function</code> ), atau komponen pembungkus mencoba menggunakan notasi titik untuk bekerja dengan objek JS bukannya metode <code>.get()</code> ( <code>Can't get catalog of undefined</code> kesalahan yang <code>Can't get catalog of undefined</code> ).  Untuk men-debug masalah ini, saya harus merujuk ke kode sumber.  Bagaimanapun, Next.js memaksa pengembang untuk menggunakan mekanisme sendiri karena suatu alasan. <br><br>  Secara umum, dapat dicatat bahwa masalah utama yang terkait dengan Next.js adalah sangat sedikit dalam kerangka kerja ini yang terdokumentasi dengan baik.  Ada banyak contoh dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dengan dasar di mana Anda dapat membuat sesuatu sendiri, tetapi jika di antara mereka tidak ada yang mencerminkan fitur-fitur proyek Anda, Anda hanya bisa berharap keberuntungan. <br><br><h3>  <font color="#3AC1EF">â– Ambil penolakan</font> </h3><br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka react-inlinesvg</a> , yang menawarkan opsi gaya untuk gambar SVG tertanam dan caching permintaan.  Tapi di sini kami punya satu masalah: ketika melakukan rendering server, tidak ada yang namanya permintaan XHR (setidaknya tidak dalam arti URL yang dihasilkan oleh Webpack, seperti yang Anda harapkan).  Upaya untuk mengeksekusi permintaan tersebut mengganggu rendering server. <br><br>  Meskipun ada perpustakaan lain untuk bekerja dengan data SVG tertanam yang mendukung SSR, saya memutuskan untuk meninggalkan fitur ini, karena file SVG masih jarang digunakan.  Saya menggantinya dengan gambar biasa, <code>&lt;img&gt;</code> , jika saya tidak perlu penataan saat menampilkan gambar yang sesuai, atau saya menyematkannya ke dalam kode dalam bentuk React JSX.  Mungkin, semuanya menjadi lebih baik, karena ilustrasi JSX sekarang mengenai browser ketika halaman pertama kali dimuat dan bundel JS yang dikirim ke klien memiliki 1 perpustakaan lebih sedikit. <br><br>  Jika Anda perlu menggunakan mekanisme pemuatan data (saya membutuhkan fitur ini untuk pustaka lain), maka Anda dapat mengonfigurasi ini menggunakan <code>next.config.js</code> , menggunakan <code>whatwg-fetch</code> dan <code>node-fetch</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     plugins: config.plugins.concat([       new webpack.ProvidePlugin(         config.isServer           ? {}           : { fetch: 'imports-loader?this=&gt;global!exports-loader?global.fetch!whatwg-fetch' }       ),     ]),   resolve: Object.assign(config.resolve, {     alias: Object.assign(       config.resolve.alias,       config.isServer ? {} : { fetch: 'node-fetch' }     ),   }), }), };</code> </pre> <br><h3>  <font color="#3AC1EF">â– JS klien dan server</font> </h3><br>  Fitur terakhir Next.js, yang ingin saya sebutkan di sini, adalah bahwa kerangka kerja ini diluncurkan dua kali - sekali untuk server, dan sekali lagi untuk klien.  Ini sedikit mengaburkan garis antara sisi klien JavaScript dan kode Node.js dalam basis kode yang sama, menyebabkan kesalahan yang tidak biasa seperti <code>fs is undefined</code> ketika mencoba memanfaatkan fitur Node.js pada klien. <br><br>  Akibatnya, kita harus membuat konstruksi seperti itu di <code>next.js.config</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     node: config.isServer ? undefined : { fs: 'empty' },   }), };</code> </pre> <br>  Bendera <code>config.isServer</code> di Webpack akan menjadi teman terbaik Anda jika Anda perlu menjalankan kode yang sama di lingkungan yang berbeda. <br><br>  Selain itu, Next.js mendukung, di samping metode standar untuk siklus hidup komponen Bereaksi, metode <code>getInitialProps()</code> , yang dipanggil hanya ketika kode <code>getInitialProps()</code> dalam mode server: <br><br><pre> <code class="plaintext hljs">class HomePage extends React.Component { static getInitialProps() {   //         } componentDidMount() {   //     ,    } â€¦ }</code> </pre> <br>  Ya, dan jangan lupa bahwa teman baik kita, objek <code>window</code> , yang diperlukan untuk mengatur acara mendengarkan, untuk menentukan ukuran jendela browser dan memberikan akses ke banyak fungsi yang bermanfaat, tidak tersedia di Node.js: <br><br><pre> <code class="plaintext hljs">if (typeof window !== 'undefined') { // ,     `window`      }</code> </pre> <br>  Perlu dicatat bahwa bahkan Next.js tidak dapat menyelamatkan pengembang dari kebutuhan untuk menyelesaikan masalah yang terkait dengan pelaksanaan kode yang sama di server dan di klien.  Tetapi ketika memecahkan masalah seperti itu, <code>config.isServer</code> dan <code>getInitialProps()</code> sangat berguna. <br><br><h2>  <font color="#3AC1EF">Hasil: apa yang akan terjadi setelah Next.js?</font> </h2><br>  Dalam jangka pendek, kerangka Next.js sangat cocok, dalam hal kinerja, persyaratan kami untuk rendering server dan kemampuan untuk melihat situs kami di perangkat yang menonaktifkan JavaScript.  Selain itu, sekarang Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tag meta</a> lanjutan (kaya). <br><br>  Mungkin di masa depan kami akan mempertimbangkan opsi lain jika aplikasi kami membutuhkan server rendering dan logika server yang lebih kompleks (misalnya, kami melihat kemungkinan penerapan teknologi akses tunggal di manifold.co dan dashboard.manifold.co )  Tetapi sampai saat itu kita akan menggunakan Next.js, karena kerangka kerja ini, dengan biaya waktu yang kecil, membawa kita banyak manfaat. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan Next.js dalam proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442654/">https://habr.com/ru/post/id442654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442644/index.html">Sebagian besar keterampilan non-pemrograman meningkatkan nilai pengembang</a></li>
<li><a href="../id442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../id442648/index.html">Go mekanisme alokasi</a></li>
<li><a href="../id442650/index.html">Analisis dan optimalisasi aplikasi Bereaksi</a></li>
<li><a href="../id442652/index.html">Menggunakan Fastify dan Preact ke Prototipe Aplikasi Web dengan Cepat</a></li>
<li><a href="../id442658/index.html">8 trik untuk bekerja dengan CSS: paralaks, sticky footer dan lainnya</a></li>
<li><a href="../id442660/index.html">Matematika Merekonsiliasi Newton dengan Dunia Kuantum</a></li>
<li><a href="../id442662/index.html">Cara menonton SDDL dan tidak mematahkan mata Anda pada titik koma</a></li>
<li><a href="../id442664/index.html">QIWI Kitchen 6 Februari - bagaimana + presentasi pembicara</a></li>
<li><a href="../id442666/index.html">Post-post, meta-meta. Kami belajar menulis di Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>