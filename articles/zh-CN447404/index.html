<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆖 🤲🏻 🖱️ 该代码是活的还是死的。 第一部分 对象 ⚜️ 🧛🏾 🌏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="代码是一种思想。 出现任务，开发人员考虑如何解决该问题，如何在功能和类中表达需求，如何使其成为朋友，如何实现严谨和正确性以及如何正确开展业务。 实践，技术，原则，模式和方法-一切都需要考虑，一切都需要记住。 


 随之而来的是，我们看到了经理，助手，服务，控制器，选择器，适配器，吸气剂，设置器和其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>该代码是活的还是死的。 第一部分 对象</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447404/"><p> 代码是一种思想。 出现任务，开发人员考虑如何解决该问题，如何在功能和类中表达需求，如何使其成为朋友，如何实现严谨和正确性以及如何正确开展业务。 实践，技术，原则，模式和方法-一切都需要考虑，一切都需要记住。 </p><br><p> 随之而来的是，我们看到了经理，助手，服务，控制器，选择器，适配器，吸气剂，设置器和其他恶魔的普遍流行：所有这些都是无效的代码。 他束手无策。 </p><br><p> 我建议以这种方式与之抗争：您需要以自然语言将程序呈现为文本，并对其进行相应的评估。 这是怎么回事以及发生了什么-在文章中。 </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla"> 循环目录 </h2><br><ol><li> 对象 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动作和属性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文字编码</a> </li></ol><br><h2 id="prolog"> 序言 </h2><br><p>我的经验不高（大约四年），但是我工作的越多，我的理解就越多：如果该程序不可读，则毫无意义。 早已众所周知并提醒人们注意-该代码不仅<em>现在</em>解决了一些问题，而且<em>以后又</em>解决了：支持，扩展，更正了它。 而且，他总是：读。 </p><br><p> 毕竟，这是文本。 </p><br><p> 代码作为文本的美观是周期中的关键主题。 这里的美学是杯，我们透过它看事物，然后说，是的，很好，是的，很漂亮。 </p><br><p> 在美观和可理解性方面，言语至关重要。 要说： <em>“目前，由于血液中乙醇含量高，我的感知处于沉闷状态”</em>与<em>“我喝醉</em> <em>了”</em>根本不一样。 </p><br><p> 我们很幸运，程序几乎完全由文字组成。 </p><br><p> 假设您需要创建<em>“一个具有健康和法术力的角色，他可以行走，攻击，使用咒语”，</em>并且您可以立即看到：有<strong>对象</strong> （字符，健康，法术力，咒语）， <strong>动作</strong> （行走，攻击，使用）和<strong>属性</strong> （角色具有健康，法力和施法速度）-所有这些都将被命名为：类，函数，方法，变量，属性和字段，总之，是编程语言所分割的所有内容。 </p><br><p>但是我不会区分类与结构，字段与属性，方法与函数：作为叙述的一部分的字符不依赖于技术细节（可以将其表示为引用或重要类型）。 本质上不同的东西：这是一个角色，他们称他为<code>Hero</code> （或<code>Character</code> ），而不是<code>HeroData</code>或<code>HeroUtils</code> 。 </p><br><p> 现在，我将带大家欣赏一下美学，并展示当今如何编写一些代码以及为什么它远非完美。 </p><br><h2 id="obekty"> 对象 </h2><br><p> 在C＃中（不仅是），对象-放置在堆上的类的实例在其中生活了一段时间，然后垃圾收集器将其删除。 也可以在堆栈或关联数组等上创建结构。 对我们来说，它们是：类名，名词。 </p><br><p> 代码中的名称（如一般名称）可能会造成混淆。 是的，您很少看到一个丑陋的名字，而是一个漂亮的物体。 特别是如果是<code>Manager</code> 。 </p><br><h3 id="menedzher-vmesto-obekta"> 经理而不是对象 </h3><br><p>  <code>UserService</code> ， <code>AccountManager</code> ， <code>DamageUtils</code> ， <code>MathHelper</code> ， <code>GraphicsManager</code> ， <code>GameManager</code> ， <code>VectorUtil</code> 。 </p><br><p> 在这里不是主要的准确性和有形性，而是模糊不清的地方，在雾中留下了阴影。 对于这样的名称，可以允许很多。 </p><br><p> 例如，在任何<code>GameManager</code>您都可以添加与<em>游戏</em>和<em>游戏</em>逻辑相关的任何内容。 六个月后，将会出现技术上的奇异之处。 </p><br><p> 或者，碰巧，您需要使用facebook。 为什么不将所有代码放在一个地方： <code>FacebookManager</code>或<code>FacebookService</code> ？ 听起来很诱人，但这种含糊的<em>意图</em>会造成同样含糊的<em>决定</em> 。 同时，我们知道Facebook上有用户，朋友，消息，群组，音乐，兴趣爱好等。 够了！ </p><br><p> 不仅有足够的单词：我们仍在使用它们。 仅在普通语音中，不在程序之间。 </p><br><p> 不是<code>GitUtils</code> ，而是<code>IRepository</code> ， <code>ICommit</code> ， <code>IBranch</code> ； 不是<code>ExcelHelper</code> ，而是<code>ExcelDocument</code> ， <code>ExcelSheet</code> ; 不是<code>GoogleDocsService</code> ，而是<code>GoogleDocs</code> 。 </p><br><p> 每个主题区域都充满了对象。  <em>“这些物体被巨大的空隙标记”</em> ， <em>“心脏在疯狂跳动”</em> ， <em>“房子在站立”</em> –这些物体的动作，感觉，易于想象； 他们在这里某处，有形而密集。 </p><br><p> 同时，您有时会看到以下内容：在<code>Microsoft/calculator</code>存储库<code>SetPrimaryDisplay</code> ，使用以下方法： <code>SetPrimaryDisplay</code> ， <code>MaxDigitsReached</code> ， <code>SetParentDisplayText</code> ， <code>OnHistoryItemAdded</code> ... </p><br><p>  <em>（不过，我记得曾经见过</em> <code>UtilsManager</code> <em>...）</em> </p><br><p> 它是这样发生的：我想用新的行为扩展<code>List&lt;&gt;</code>类型，并且<code>ListUtils</code>或<code>ListHelper</code>诞生了。 在这种情况下，最好<em>仅</em>使用扩展方法<code>ListExtensions</code>更好，更准确：它们是概念的一部分，而不是过程的转储。 </p><br><p> 少数例外之一是<code>OfficeManager</code>作为帖子。 </p><br><p> 其余的...如果程序包含此类单词，则不应对其进行编译。 </p><br><h3 id="deystvie-vmesto-obekta"> 行动而不是对象 </h3><br><p>  <code>IProcessor</code> ， <code>ILoader</code> ， <code>ISelector</code> ， <code>IFilter</code> ， <code>IProvider</code> ， <code>ISetter</code> ， <code>ICreator</code> ， <code>IOpener</code> ， <code>IHandler</code> ;  <code>IEnableable</code> ， <code>IInitializable</code> ， <code>IUpdatable</code> ， <code>ICloneable</code> ， <code>IDrawable</code> ， <code>ILoadable</code> ， <code>IOpenable</code> ， <code>ISettable</code> ， <code>IConvertible</code> 。 </p><br><p> 在这里，本质的本质是一个过程，而不是一个概念，并且代码再次失去了图像和可读性，通常的单词被人为的代替。 </p><br><p> 更活泼的是<code>ISequence</code> ，不是<code>IEnumerable</code> ;  <code>IBlueprint</code> ，而不是<code>ICreator</code> ；  <code>IButton</code>而不是<code>IButtonPainter</code> ;  <code>IPredicate</code> ，而不是<code>IFilter</code> ；  <code>IGate</code> ，不是<code>IOpeneable</code> ;  <code>IToggle</code> ，不是<code>IEnableable</code> 。 </p><br><p> 一个好的故事讲述的是人物及其发展，而不是创作者的创作方式，建造者的建造以及画家的绘画。 一个动作不能完全代表一个对象。  <code>ListSorter</code>不是<code>SortedList</code> 。 </p><br><p> 以<code>DirectoryCleaner</code>为例，该对象用于清理文件系统上的文件夹。 优雅吗？ 但是我们永远不会说： <em>“要求文件夹清洁程序来清洁D：/测试”</em> ，总是： <em>“清洁D：/测试”</em> ，因此使用<code>Clean</code>方法的<code>Directory</code>看起来更自然，更接近。 </p><br><p> 一个更生动的案例更有趣：.NET中的<code>FileSystemWatcher</code>是报告更改的文件系统观察者。 但是，为什么整个观察者（如果变更<em>本身</em>可以报​​告它们已发生）呢？ 此外，它们必须与文件或文件夹密不可分地链接，因此也应将它们放置在<code>Directory</code>或<code>File</code> （使用<code>Changes</code>属性可以调用<code>file.Changes.OnNext(action)</code> ）。 </p><br><p> 这样的口头名字似乎证明了<code>Strategy</code>设计模式的合理性，指示<em>“封装算法家族”</em> 。 但是，如果<em>我们</em>找到故事中存在的真实对象而不是<em>“算法家族”</em> ，那么我们将看到该策略只是一个概括。 </p><br><p> 为了解释这些以及许多其他错误，我们转向哲学。 </p><br><h3 id="suschestvovanie-predshestvuet-suschnosti"> 存在先于本质 </h3><br><p>  <code>MethodInfo</code> ， <code>ItemData</code> ， <code>AttackOutput</code> ， <code>CreationStrategy</code> ， <code>StringBuilder</code> ， <code>SomethingWrapper</code> ， <code>LogBehaviour</code> 。 </p><br><p> 这样的名字由一件事统一起来：它们的存在是基于细节的。 </p><br><p> 碰巧某些事物会很快干扰任务：某些事物丢失或存在，但并非某种事物。 然后您会想： <em>“现在可以做X的事情会帮助我”</em> -这就是<em>生存</em>的构想。 然后，为了做X，编写了<code>XImpl</code>这就是<em>实体的</em>外观。 </p><br><p> 因此，不是<code>IArrayItem</code>而是<code>IIndexedItem</code>或<code>IItemWithIndex</code>更为常见，或者说，在反射API中，我们只看到有关它的<em>信息</em> （ <code>MethodInfo</code> ），而不是<em>方法</em> （ <code>Method</code> ）。 </p><br><p> 一个更真实的方法：面对生存的需求， <em>找到一个</em>实现它<em>的</em>实体，并且由于这是它的本质，所以<em>找到其他</em>实体。 </p><br><p> 例如，他们希望在不创建中间实例的情况下更改<code>string</code>类型的值-事实证明这是<code>StringBuilder</code>形式的直接解决方案，而我认为更合适<code>MutableString</code> 。 </p><br><p> 调用文件系统：不需要<code>DirectoryRenamer</code>重命名文件夹，因为一旦您同意<code>Directory</code>对象的存在，该操作<em>已经</em>在其中，您只是在代码中<em>找不到</em>相应的方法。 </p><br><p> 如果要描述如何进行<em>锁定</em> ，则无需弄清楚这是<code>ILockBehaviour</code>还是<code>ILockStrategy</code> ，这要容易得多<code>ILock</code> （使用返回<code>IDisposable</code>的<code>Acquire</code>方法）或<code>ICriticalSection</code> （使用<code>Enter</code> ）。 </p><br><p> 这也包括各种<code>Data</code> ， <code>Info</code> ， <code>Output</code> ， <code>Input</code> ， <code>Args</code> ， <code>Params</code> （很少是<code>State</code> ）-完全没有行为的对象，因为它们被认为是单面的。 </p><br><p> 在主要存在的地方，商与一般相混合，并且对象的名称令人困惑-您必须通读每一行并找出角色去向何处以及为什么只有他的<code>Data</code> 。 </p><br><h3 id="prichudlivaya-taksonomiya"> 奇异分类法 </h3><br><p>  <code>CalculatorImpl</code> ， <code>AbstractHero</code> ， <code>ConcreteThing</code> ， <code>CharacterBase</code> 。 </p><br><p> 出于上述相同的原因，有时我们会看到对象，这些对象在层次结构中被精确地指出。 再次，生存急于前进，我们再次看到瞬时需求是如何仓促地涌入代码中，而不考虑后果。 </p><br><p> 毕竟，真的有一个人（ <code>Human</code> ）-基本人的继承人（ <code>HumanBase</code> ）吗？ 但是，当<code>Item</code>继承<code>AbstractItem</code>时如何？ </p><br><p> 有时，他们想要显示出不是<code>Character</code> ，而是某种“原始”相似性-CharacterRaw。 </p><br><p>  <code>Impl</code> ， <code>Abstract</code> ， <code>Custom</code> ， <code>Base</code> ， <code>Concrete</code> ， <code>Internal</code> ， <code>Raw</code>不稳定，建筑模糊的标志，就像第一个场景中的枪一样，它肯定会在以后拍摄。 </p><br><h3 id="povtoreniya"> 重复次数 </h3><br><p> 对于嵌套类型，会发生这种情况： <code>RepositoryItem</code>中的<code>Repository</code> ， <code>Window</code> <code>WindowState</code> ， <code>Hero</code> <code>HeroBuilder</code> 。 </p><br><p> 重复贯穿意义，加剧缺陷，只会增加文本的复杂性。 </p><br><h3 id="izbytochnye-detali"> 冗余部分 </h3><br><p> 为了同步线程， <code>ManualResetEvent</code>通常与以下API结合使用： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualResetEvent</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   —  `EventWaitHandle`. void Set(); void Reset(); bool WaitOne(); }</span></span></code> </pre> <br><p> 每次，个人而言，我都必须记住<code>Set</code>与<code>Reset</code> （语法不舒服）有何不同，以及在使用流时上下文中的<em>“手动重置事件”</em>通常<em>是</em>什么。 </p><br><p> 在这种情况下，比起编程（而不是日常生活）更容易使用隐喻： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ThreadGate</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForOpen</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><p> 当然没有什么可混淆的！ </p><br><p> 有时会变得荒谬：指定<em>项目</em>不仅是<code>Items</code> ，还必须是<code>ItemsList</code>或<code>ItemsDictionary</code> ！ </p><br><p> 但是，如果<code>ItemsList</code>不好笑，那么<em>Spring的</em> <code>AbstractInterceptorDrivenBeanDefinitionDecorator</code> <code>ItemsList</code> 。 这个名字中的单词是缝制巨大怪物的破布。 虽然...如果这是一个怪物，那么<code>HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor</code>是<code>HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor</code> ？ 希望<em>遗产</em> 。 </p><br><p> 除了类和接口名称外，还经常在变量或字段中遇到冗余。 </p><br><p> 例如，类型为<code>IOrdersRepository</code>的字段称为<code>_ordersRepository</code> 。 但是，报告存储库已提交订单有多重要？ 毕竟，容易得多<code>_orders</code> 。 </p><br><p> 碰巧在LINQ查询中，他们编写了lambda表达式的完整参数名称，例如<code>Player.Items.Where(item =&gt; item.IsWeapon)</code> ，尽管我们已经通过查看<code>Player.Items</code>理解了此项。 。 在这种情况下，我总是喜欢使用<em>相同的</em>字符<code>x</code> ： <code>Player.Items.Where(x =&gt; x.IsWeapon)</code> （如果这些是函数内部的函数，则继续到<code>y</code> ， <code>z</code> ）。 </p><br><h2 id="itogo"> 合计 </h2><br><p> 我承认，从这样的开始，要找到客观事实并不容易。 例如，有人会说：写<code>Service</code>或不写<code>Service</code>是有争议的，微不足道的，有品位的，如果有效，它有什么区别？ </p><br><p> 但是你可以用一次性杯子喝！ </p><br><p> 我坚信内容的路径是通过表单，如果不看这个思想，它似乎就消失了。 在该程序的文本中，所有操作均以相同的方式进行：样式，气氛和节奏有助于表达自己，而不会感到困惑，而是可以理解且功能丰富。 </p><br><p> 物体的名称不仅是它的面孔，而且是自我。 它确定是空灵的还是饱和的，抽象的还是真实的，干燥的还是动画的。 名称在变化-内容在变化。 </p><br><p> 在下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中，我们将</a>讨论这一内容及其发生的情况。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447404/">https://habr.com/ru/post/zh-CN447404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447392/index.html">英语语法检查服务的三个问题以及是否可以解决</a></li>
<li><a href="../zh-CN447394/index.html">尼古拉·利哈切夫（Nikolai Likhachev）的父亲弗拉基米尔·利哈切夫（Vladimir Likhachev）的访谈，克里斯·卡巴斯基（Chris Kaspersky）</a></li>
<li><a href="../zh-CN447396/index.html">您的公司数据在AI时代有价值吗？</a></li>
<li><a href="../zh-CN447398/index.html">机器人过程自动化-旧技术的新面貌</a></li>
<li><a href="../zh-CN447402/index.html">Docker中的Splunk Universal Forwarder作为系统记录器</a></li>
<li><a href="../zh-CN447406/index.html">如何使用ViewPager2</a></li>
<li><a href="../zh-CN447408/index.html">从初级到中级学习英语：有用的资源和动机</a></li>
<li><a href="../zh-CN447410/index.html">省篝火或民族诞生</a></li>
<li><a href="../zh-CN447412/index.html">监视RabbitMQ中的消息</a></li>
<li><a href="../zh-CN447414/index.html">ML.NET 1.0 RC发布。 最新消息</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>