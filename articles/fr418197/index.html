<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ 👩‍👧‍👧 👲🏽 Cours MIT "Sécurité des systèmes informatiques". Conférence 4: «Partager les privilèges», partie 2 👨🏻‍🔧 🕎 🐮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "Sécurité des systèmes informatiques." Nikolai Zeldovich, James Mickens. 2014 année...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "Sécurité des systèmes informatiques". Conférence 4: «Partager les privilèges», partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418197/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "Sécurité des systèmes informatiques."  Nikolai Zeldovich, James Mickens.  2014 année </h3><br>  Computer Systems Security est un cours sur le développement et la mise en œuvre de systèmes informatiques sécurisés.  Les conférences couvrent les modèles de menace, les attaques qui compromettent la sécurité et les techniques de sécurité basées sur des travaux scientifiques récents.  Les sujets incluent la sécurité du système d'exploitation (OS), les fonctionnalités, la gestion du flux d'informations, la sécurité des langues, les protocoles réseau, la sécurité matérielle et la sécurité des applications Web. <br><br>  Cours 1: «Introduction: modèles de menace» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 2: «Contrôle des attaques de pirates» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 3: «Débordements de tampon: exploits et protection» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 4: «Séparation des privilèges» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Alors qu'avions-nous d'autre sur cette liste?  Processus.  La mémoire est quelque chose qui se produit simultanément avec le processus.  Ainsi, si vous n'êtes pas dans ce processus, vous ne pouvez pas accéder à sa mémoire.  La mémoire virtuelle améliore parfaitement cet isolement pour nous.  De plus, le mécanisme de débogage vous permet de "pop" dans la mémoire d'un autre processus, si vous avez le même ID utilisateur <br><br>  Ensuite, nous avons le réseau.  Les réseaux sous <b>Unix</b> ne correspondent pas tout à fait au modèle décrit ci-dessus, en partie du fait que le <b>système d'</b> exploitation <b>Unix</b> a d'abord été développé, puis un réseau est apparu, qui est rapidement devenu populaire.  Il a un ensemble de règles légèrement différent.  Par conséquent, les opérations dont nous devons vraiment nous occuper sont de connecter quelqu'un au réseau si vous gérez le réseau ou d'écouter un port si vous agissez en tant que serveur.  Vous devrez peut-être lire ou écrire des données sur cette connexion, ou envoyer et recevoir <b>des</b> paquets <b>bruts</b> . <br><br><img src="https://habrastorage.org/webt/dw/gn/zv/dwgnzva6txwuj_esllvdnx3uexg.jpeg"><br><br>  Ainsi, les réseaux sous <b>Unix</b> sont pour la plupart sans rapport avec l' <b>ID utilisateur</b> .  Les règles sont que n'importe qui peut toujours se connecter à n'importe quelle machine ou n'importe quelle adresse IP ou ouvrir une connexion.  Si vous voulez écouter sur un port, alors dans ce cas il y a une différence, c'est que la plupart des utilisateurs sont interdits d'écouter des ports avec un nombre inférieur à la «valeur magique» de 1024. En principe, vous pouvez écouter de tels ports, mais dans ce cas, vous devriez Soyez un utilisateur spécial appelé <b>"super utilisateur"</b> avec <b>uid = 0</b> . <br><br>  En général, sous Unix, il y a le concept d'administrateur, ou de superutilisateur, qui est représenté par l'identifiant uid = 0, qui peut contourner presque toutes ces vérifications, donc si vous travaillez avec des droits root, vous pouvez lire et écrire des fichiers, changer les droits d'accès pour eux.  Le système d'exploitation vous permettra de le faire car il pense que vous devriez avoir tous les privilèges.  Et vous avez vraiment besoin de tels privilèges pour écouter sur les ports avec un nombre &lt;1024. Que pensez-vous d'une restriction aussi étrange? <br><br>  <b>Public:</b> il identifie des numéros de port spécifiques pour des connexions spécifiques, par exemple, pour <b>http</b> sur le port 80. <br><br>  <b>Professeur:</b> oui, par défaut le <b>protocole HTTP</b> utilise le port 80. En revanche, d'autres services peuvent utiliser des ports avec un nombre supérieur à 1024, pourquoi cette restriction est-elle nécessaire?  Quelle est l'utilité ici? <br><br>  <b>Public:</b> parce que vous ne voulez pas que quelqu'un écoute accidentellement votre <b>HTTP</b> . <br><br>  <b>Professeur:</b> oui.  Je pense que la raison en est que vous aviez auparavant de nombreux utilisateurs sur la même machine.  Ils se sont connectés avec leurs identifiants de connexion, ont lancé leurs applications, vous vouliez donc vous assurer qu'un utilisateur aléatoire, s'étant connecté à l'ordinateur, ne pourrait pas mettre la main sur le serveur Web en cours d'exécution.  Parce que les utilisateurs se connectant de l'extérieur ne savent pas qui travaille sur ce port, et ils se connectent simplement au port 80. Si je veux entrer dans cette machine et démarrer mon propre serveur Web, je transfère simplement tout le trafic du serveur Web vers cette voiture.  Ce n'est probablement pas un très bon plan, mais c'est la façon dont le sous-système réseau Unix empêche les utilisateurs aléatoires de contrôler les services connus s'exécutant sur ces numéros de port bas.  Telle est la justification d'une telle limitation. <br><br><img src="https://habrastorage.org/webt/ba/0o/qn/ba0oqn2qgabud4-_hmizsks086s.jpeg"><br><br>  De plus, du point de vue de la lecture et de l'écriture des données de connexion, si vous avez un fichier descripteur pour un socket spécifique, <b>Unix</b> vous permettra de lire et d'écrire toutes les données de cette <b>connexion TCP</b> ou <b>uTP</b> .  Lors de l'envoi <b>de</b> paquets <b>bruts</b> , <b>Unix</b> se comporte comme un paranoïaque, il ne vous permettra donc pas d'envoyer des paquets arbitraires sur le réseau.  Cela devrait être dans le contexte de la connexion spéciale, sauf si vous avez <b>root - le</b> droit et vous pouvez faire ce que vous voulez. <br><br>  Donc, une question intéressante que vous pourriez poser est d'où viennent tous ces <b>ID utilisateur</b> ? <br><br>  Nous parlons de processus ayant <b>userid</b> ou <b>groupid</b> .  Lorsque vous lancez <b>PS</b> sur votre ordinateur, vous verrez certainement une série de processus avec différentes valeurs <b>uid</b> .  D'où venaient-ils? <br><br>  Nous avons besoin d'un mécanisme pour charger toutes ces valeurs d' <b>ID utilisateur</b> .  <b>Unix</b> a plusieurs appels système conçus pour cela.  Par conséquent, pour amorcer ces valeurs d'identificateur, il existe une fonction appelée <b>setuid (uid)</b> , vous pouvez donc attribuer le numéro <b>uid</b> d'un processus en cours à cette valeur.  C'est en fait une opération dangereuse, comme tout le reste dans la tradition <b>Unix</b> , car vous ne pouvez le faire que si votre <b>uid = 0</b> .  En tout cas, il devrait en être ainsi. <br><br>  Ainsi, si vous êtes un utilisateur avec des droits root et que <b>uid = 0</b> , vous pouvez appeler <b>setuid (uid)</b> et basculer l'utilisateur vers n'importe quel processus.  Il existe quelques autres appels système similaires pour initialiser le <b>gid</b> lié au processus: ce sont <b>setgid</b> et <b>setgroups</b> .  Par conséquent, ces appels système vous permettent de configurer les privilèges de processus. <br><br><img src="https://habrastorage.org/webt/qs/6m/bk/qs6mbkc520bn-n_vlpznivx1z0q.jpeg"><br><br>  Le fait que vos processus obtiennent les droits d'accès corrects lorsque vous vous connectez à la machine <b>Unix</b> ne se produit pas car vous avez le même <b>ID</b> que les processus, car le système ne sait pas encore qui vous êtes.  Au lieu de cela, sous <b>Unix,</b> il existe une sorte de procédure de connexion lorsque le <b>protocole de</b> shell sécurisé <b>SSH</b> démarre le processus pour quiconque se connecte à l'ordinateur et essaie d'authentifier l'utilisateur. <br><br>  Ainsi, initialement, ce processus de connexion commence par <b>uid = 0</b> comme pour un utilisateur avec des droits root, puis, lorsqu'il reçoit un nom d'utilisateur et un mot de passe spécifiques, il les vérifie dans sa propre base de données de comptes.  Généralement, sous <b>Unix,</b> ces données sont stockées dans deux fichiers: <b>/ etc / password</b> (pour des raisons historiques, les mots de passe ne sont plus stockés dans ce fichier) et dans le fichier <b>/ etc / shadow</b> , dans lequel les mots de passe sont stockés.  Cependant, il existe une table dans le fichier <b>/ etc / password</b> qui affiche chaque nom d'utilisateur dans le système sous forme de valeur entière. <br><br>  Ainsi, votre nom d'utilisateur est mappé à un entier spécifique dans ce fichier <b>/ etc / password</b> , puis le processus de connexion vérifie si votre mot de passe est correct en fonction de ce fichier.  S'il trouve votre <b>uid</b> entier, il définit les fonctions <b>setuid</b> sur cette valeur <b>uid</b> et démarre le shell avec la commande <b>exec (/ bin / sh)</b> .  Vous pouvez maintenant interagir avec le shell, mais cela fonctionne sous votre <b>UID</b> , vous ne pourrez donc pas endommager accidentellement cette machine. <br><br><img src="https://habrastorage.org/webt/oa/vi/t8/oavit8bjjn_skjz8-n1k5dhc6co.jpeg"><br><br>  <b>Public: est-</b> il possible de démarrer un nouveau processus avec <b>uid = 0</b> si votre <b>uid</b> n'est pas vraiment 0? <br><br>  <b>Professeur:</b> si vous avez des privilèges root, vous pouvez vous limiter à un autre <b>uid</b> , réduire votre autorité, mais dans tous les cas, vous pouvez créer un processus avec uniquement le même <b>uid</b> que le vôtre.  Mais il arrive que pour diverses raisons vous souhaitiez augmenter vos privilèges.  Supposons que vous devez installer un package pour lequel vous avez besoin <b>des</b> privilèges <b>root</b> . <br><br>  Il existe deux façons de définir des privilèges sur <b>Unix</b> .  Celui que nous avons déjà mentionné est un descripteur de fichier.  Donc, si vous voulez vraiment augmenter vos privilèges, vous pouvez parler à quelqu'un qui travaille sous les droits root et lui demander d'ouvrir ce fichier pour vous.  Ou vous devez installer une nouvelle interface, puis cet assistant ouvre un fichier pour vous et vous renvoie un descripteur de fichier en utilisant le transfert <b>fd</b> .  C'est une façon d'augmenter vos privilèges, mais cela n'est pas pratique car dans certains cas, des processus s'exécutent avec un grand nombre de privilèges.  Pour cela, <b>Unix</b> a un mécanisme intelligent mais en même temps problématique appelé <b>"binaires setuid"</b> .  Ce mécanisme est un exécutable standard sur un <b>système de</b> fichiers <b>Unix</b> , sauf lorsque vous exécutez <b>exec</b> sur le binaire <b>setuid</b> , par exemple, <b>/ bin / su</b> sur la plupart des machines, ou <b>sudo</b> , au démarrage. <br><br>  Un système <b>Unix</b> typique a un tas de binaires <b>setuid</b> .  La différence est que lorsque vous exécutez l'un de ces binaires, il bascule réellement l' <b>ID utilisateur du</b> processus vers le propriétaire de ce binaire.  Ce mécanisme semble étrange lorsque vous le voyez pour la première fois.  En règle générale, les façons de l'utiliser sont que ce «binaire» a très probablement un <b>UID de</b> propriétaire <b>de</b> 0, car vous voulez vraiment restaurer de nombreux privilèges. <br><br><img src="https://habrastorage.org/webt/zt/s5/8d/zts58db83nchnbo1a6qqobpbpuw.jpeg"><br><br>  Vous voulez restaurer les droits de superutilisateur afin que vous puissiez exécuter cette commande <b>su</b> , et le noyau, lorsque vous exécutez ce binaire, basculera l' <b>uid</b> du processus sur 0, de sorte que ce programme effectuera maintenant certaines choses privilégiées. <br><br>  <b>Public:</b> si vous avez <b>uid = 0</b> et que vous changez l' <b>uid de</b> tous ces binaires <b>setuid</b> en autre chose que 0, pouvez-vous restaurer vos privilèges? <br><br>  <b>Professeur:</b> non, de nombreux processus ne pourront pas restaurer les privilèges lors de la baisse du niveau d'accès, vous pouvez donc être bloqué à cet endroit.  Ce mécanisme n'est pas lié à <b>uid = 0</b> .  Comme tout utilisateur d'un système <b>Unix</b> , vous pouvez créer n'importe quel fichier binaire, créer un programme, le compiler et définir ce bit <b>setuid</b> sur le programme lui-même.  Il vous appartient, l'utilisateur, votre ID utilisateur.  Et cela signifie que toute personne qui exécute votre programme exécutera ce code avec votre ID utilisateur.  Y a-t-il un problème avec cela?  Que faut-il faire? <br><br>  <b>Public:</b> c'est-à-dire, s'il y a eu une erreur dans votre candidature, quelqu'un pourrait-il en faire quoi que ce soit, en agissant avec vos privilèges? <br><br>  <b>Professeur: c'est</b> vrai, cela arrive si mon application est "buggy", ou si elle vous permet d'exécuter tout ce que vous voulez.  Supposons que je puisse copier le shell du système et le configurer pour moi, mais n'importe qui peut exécuter ce shell sous mon compte.  Ce n'est probablement pas le meilleur plan d'action.  Mais un tel mécanisme ne crée pas de problème, car la seule personne qui peut définir le bit <b>setuid</b> sur un fichier binaire est le propriétaire de ce fichier.  En tant que propriétaire du fichier, vous disposez du privilège <b>uid</b> , vous pouvez donc transférer votre compte à une autre personne, mais cette autre personne ne pourra pas créer le binaire <b>setuid</b> avec votre <b>ID utilisateur</b> . <br><br>  Ce bit setuid est stocké à côté de ces bits d'autorisation, c'est-à-dire que dans chaque <b>inode</b> il y a aussi un bit <b>setuid</b> qui indique si ce fichier exécutable devrait ou si le programme est passé à l' <b>uid</b> du propriétaire pendant l'exécution. <br><br><img src="https://habrastorage.org/webt/4d/o0/cf/4do0cfauri7y6g94omunnrdyv14.jpeg"><br><br>  Il s'avère que c'est un mécanisme très délicat lorsqu'il est utilisé correctement, et grâce à lui, le noyau implémente le programme correctement.  En fait, c'est assez facile à faire, car une seule vérification est effectuée: si ce bit <b>setuid</b> existe, le processus passe à <b>uid</b> .  C'est assez simple. <br><br>  Mais l'utiliser en toute sécurité est assez difficile, car, comme cela vient d'être indiqué, si ce programme contient des erreurs ou fait quelque chose d'inattendu, vous avez la possibilité de faire des choses arbitraires sous <b>uid = 0</b> ou sous tout autre <b>uid</b> .  Sous <b>Unix,</b> lorsque vous exécutez un programme, vous héritez de beaucoup de choses de votre processus parent. <br><br>  Par exemple, vous pouvez transmettre des variables d'environnement aux binaires <b>setuid</b> .  Le fait est que sous <b>Unix,</b> vous pouvez spécifier la bibliothèque partagée à utiliser pour le processus en définissant la variable d'environnement, et les binaires <b>setuid</b> ne se soucient pas de filtrer ces variables d'environnement. <br><br>  Par exemple, vous pouvez exécuter <b>bin / su</b> , mais utiliser des bibliothèques partagées pour la fonction <b>printf</b> , afin que votre <b>printf</b> démarre lorsque <b>bin / su</b> imprime quelque chose, et vous pouvez exécuter le shell au lieu de printingf. <br><br>  Il y a beaucoup de subtilités que vous devez comprendre correctement concernant la méfiance du programme envers les données que l'utilisateur entre.  Parce que vous faites généralement confiance aux entrées utilisateur, <b>setuid</b> n'a jamais été la partie la plus sûre d'un système <b>Unix</b> complet.  Vous avez des questions à ce sujet? <br><br>  <b>Public:</b> <b>setuid</b> s'applique-t-il également aux groupes ou uniquement à l'utilisateur? <br><br>  <b>Professeur:</b> il y a un bit <b>setgid</b> symétrique au bit <b>setuid</b> , que vous pouvez également régler.  Si le fichier a un <b>gid</b> spécifique et que ce bit <b>setgid</b> est défini au démarrage du programme, vous l'obtiendrez. <br><br>  <b>Setgid n'est</b> pas particulièrement utilisé, mais peut être utile dans les cas où vous souhaitez fournir des privilèges très spécifiques.  Par exemple, <b>bin / su a</b> probablement besoin de beaucoup de privilèges, mais il y a peut-être un programme qui a besoin de quelques privilèges supplémentaires, par exemple, pour écrire quelque chose dans un fichier journal spécial.  Par conséquent, vous souhaiterez probablement lui fournir un certain groupe et créer un fichier journal pour elle qui sera accessible en écriture par ce groupe.  Donc, même si le programme est «buggé», vous ne perdrez rien d'autre que ce groupe.  Ceci est utile comme mécanisme qui, pour une raison quelconque, n'est pas utilisé trop souvent, car après tout, les gens devraient utiliser davantage les droits root. <br><br>  <b>Public:</b> Existe-t-il des restrictions quant à qui peut modifier l'accès? <br><br>  <b>Professeur:</b> oui.  Différentes implémentations <b>Unix</b> ont des vérifications différentes pour cela.  La règle générale est que seul root peut changer le propriétaire du fichier, car vous ne voulez pas créer de fichiers qui appartiendront à quelqu'un d'autre et bien sûr vous ne voulez pas vous approprier les fichiers d'autres personnes.  Donc, si votre <b>UID n'est</b> pas 0, alors vous êtes coincé.  Vous ne pouvez pas modifier la propriété d'un fichier.  Si votre <b>uid = 0</b> , vous avez des privilèges root et vous pouvez changer le propriétaire en n'importe qui.  Il y a quelques complications si vous avez un <b>setuid</b> binaire et que vous passez d'un <b>uid</b> à un autre, c'est assez délicat, mais en gros vous ne pouvez pas changer le propriétaire du fichier si vous n'avez pas les privilèges root. <br><br>  Par tous les comptes, c'est un système légèrement dépassé.  Vous pourriez probablement imaginer de nombreuses façons de simplifier les processus décrits ci-dessus, mais en fait, la plupart des systèmes avancés ressemblent à ceci car ils évoluent avec le temps.  Mais vous pouvez parfaitement utiliser ces mécanismes comme un "bac à sable". <br><br>  Ce ne sont que des principes de base d' <b>Unix</b> , qui apparaissent dans presque tous les systèmes d'exploitation de type Unix: <b>Mac OS X</b> , <b>Linux</b> , <b>FreeBSD</b> , <b>Solaris</b> , si quelqu'un d'autre l'utilise, etc.  Mais chacun de ces systèmes possède des mécanismes plus sophistiqués que vous pourriez utiliser.  Par exemple, sous <b>Linux,</b> il existe un ensemble «bac à sable» <b>COMP</b> , <b>Mac OS X</b> utilise la <b>ceinture de sécurité</b> «bac à sable».  La semaine prochaine, je vous donnerai des exemples de bacs à sable disponibles sur chaque système basé sur <b>Unix</b> . <br><br>  Ainsi, l'un des derniers mécanismes, que nous examinerons avant de plonger dans <b>OKWS</b> , explique comment vous devez gérer les binaires <b>setuid</b> et montre comment vous protéger contre les failles de sécurité existantes.  Le problème est que vous aurez inévitablement des binaires <b>setuid</b> sur votre système, comme <b>/ bin / su</b> , ou <b>sudo</b> , ou autre chose, et il est probable que vos programmes auront des erreurs.  Pour cette raison, quelqu'un pourra exécuter le binaire <b>setuid</b> et le processus pourra accéder à la <b>racine</b> , ce que vous ne voulez pas autoriser. <br><br><img src="https://habrastorage.org/webt/gy/nt/aa/gyntaadl0kgyfcku6ncq8v334kg.jpeg"><br><br>  Le mécanisme <b>Unix</b> , qui est souvent utilisé pour empêcher l'exécution d'un processus potentiellement malveillant à l'aide de binaires <b>setuid</b> , consiste à utiliser l'espace de noms du système de fichiers pour le modifier à l'aide de l'appel système <b>chroot</b> , l'opération de modification du répertoire racine.  <b>OKWS</b> , en tant que serveur Web spécialisé dans la création de services Web rapides et sécurisés, l'utilise assez largement. <br><br><img src="https://habrastorage.org/webt/m3/x1/xr/m3x1xrg_tmht2b2l8rwd8kzzy7s.jpeg"><br><br>  Donc, sous <b>Unix,</b> vous pouvez exécuter <b>chroot</b> dans un répertoire spécifique, vous pouvez donc peut-être aussi exécuter <b>chroot ("/ foo")</b> . <br><br>  Il y a 2 explications pour ce que fait <b>chroot</b> .  Le premier est simplement intuitif, cela signifie qu'après avoir exécuté <b>chroot</b> , le répertoire racine ou le répertoire situé derrière la barre oblique est fondamentalement équivalent à ce que <b>/ foo a utilisé</b> avant d'appeler <b>chroot</b> .  Cela ressemble à limiter l'espace de noms sous votre <b>/ foo</b> .  Par conséquent, si vous avez un fichier qui s'appelait auparavant <b>/ foo / x</b> , après avoir appelé <b>chroot,</b> vous pouvez obtenir ce fichier simplement en ouvrant <b>/ x</b> .  Limitez donc votre espace de noms à un sous-répertoire.  Voici ce qu'est la version intuitive. <br><br><img src="https://habrastorage.org/webt/2w/58/wf/2w58wflgecku62k-urraxwggxcc.jpeg"><br><br>  Bien sûr, en matière de sécurité, ce n'est pas la version intuitive qui compte, mais que fait exactement le noyau avec cet appel système?  Et cela fait essentiellement deux choses.  Tout d'abord, il change la valeur de cette barre oblique, donc chaque fois que vous accédez ou lorsque vous démarrez le nom du répertoire avec une barre oblique, le noyau inclut tout fichier que vous avez fourni avec des opérations <b>chroot</b> .  Dans notre exemple, il s'agit du fichier <b>/ foo</b> avant d'appeler <b>chroot</b> , c'est-à-dire que nous obtenons ce <b>/ = / foo</b> . <br><br><img src="https://habrastorage.org/webt/gn/yx/-t/gnyx-tksd5brn4avys0dhppaw6c.jpeg"><br><br>  La prochaine chose que le noyau essaiera de faire est de vous empêcher de "vous échapper" de votre <b>/</b> si vous le faites <b>/../</b> .  Parce que sur <b>Unix,</b> je pourrais vous demander de me donner, par exemple, <b>/../etc/password</b> .  Donc, si je venais de compléter cette ligne comme ceci: <b>/foo/../etc/password</b> , ce ne serait pas bien, car je pourrais simplement quitter <b>/ foo</b> et continuer pour obtenir <b>/ etc / password</b> . <br><br>  La deuxième chose que le noyau fait avec un appel système <b>Unix</b> est que lorsque vous appelez <b>chroot</b> pour ce processus particulier, il change la façon dont <b>/../ est</b> évalué dans ce répertoire.  Par conséquent, il modifie <b>/../</b> afin que <b>/ foo</b> pointe vers lui-même.  Ainsi, cela ne vous permet pas de «vous échapper», et ce changement ne s'applique qu'à ce processus et n'affecte pas le reste.  Quelles idées avez-vous sur la façon de «s'échapper» de l'environnement <b>chroot en</b> utilisant la façon dont il est mis en œuvre? <br><br>  Fait intéressant, le noyau ne surveille qu'un seul répertoire <b>chroot</b> , vous pouvez donc probablement effectuer l'opération <b>chroot = (/ foo)</b> , mais vous seriez coincé à cet endroit.  Vous voulez donc obtenir <b>/ etc / password</b> , mais comment faire?  Vous pouvez maintenant ouvrir le répertoire racine en tapant <b>open (* / *)</b> .  Cela vous donnera un descripteur de fichier décrivant ce qu'est <b>/ foo</b> .  Ensuite, vous pouvez à nouveau appeler <b>chroot</b> et exécuter <b>chroot (`/ bar)</b> . <br><br><img src="https://habrastorage.org/webt/er/ce/o6/erceo6xadygvj95nuy8fj-zn1bi.jpeg"><br><br> ,    : <b>root</b>   <b>/foo</b> ,  <b>/foo/bar</b>   <b>/../</b>     <b>/foo / bar/..</b> <br><br><img src="https://habrastorage.org/webt/gi/vb/zy/givbzygict7u1xirzzwneycl3sw.jpeg"><br><br>  ,          <b>/foo</b> .            <b>fchdir (fd)</b>     <b>(*/*)</b> ,      <b>chdir (..)</b> . <br><br><img src="https://habrastorage.org/webt/lb/qz/mx/lbqzmxnz8308avfwfyaxxprq7d8.jpeg"><br><br><img src="https://habrastorage.org/webt/gu/cn/kd/gucnkdez6q9ntda3zwtotnc4igg.jpeg"><br><br>       <b>/foo</b> ,     <b>/../</b> .     <b>/foo</b>        ,       <b>root</b> ,       . <br><br> ,    ,       .       .   <b>Unix</b>    root-   <b>chroot</b> ,  <b>chroot</b>     .  ,  <b>Unix</b>    <b>uid = 0</b>  ,      <b>chroot</b> .   .           ,         ,    <b>chroot</b> ,   <b>userid</b>   .   ,     <b>Unix</b> ,     ,    <b>root</b> ,    . <br><br>       ,  , ,     .      <b>chroot</b>       —      .    . <br><br> <b>:</b>  ,       <b>inod</b> ,      ? <br><br> <b>:</b>    !              ,  , , : «   <b>inode</b>  23»,      -        <b>hroot</b> .  ,  <b>Unix</b>     <b>inode</b>   <b>inode</b> ,  , ,   root-. <br><br>  ,      ,  ,   <b>OKWS</b> .  ,      <b>OKWS</b> . <br><br>  ,     -,   ,      -  ,      .          , , <b>httpd</b> , ,  <b>Apache</b> . <br><br>        <b>userid</b>   <b>www</b>  <b>/etc/password</b> .     ,   ,     <b>SSL</b> ,      <b>PHP</b>   ,        .   ,       , , <b>MySQL</b> ,           .    <b>MySQL</b>     .      <b>MySQL</b> , , ,      . <br><br><img src="https://habrastorage.org/webt/sx/tx/gd/sxtxgdpf7q9jr3q_tfxyzi6zgdc.jpeg"><br><br> ,  ,    ,    <b>MySQL</b>    ,        ,             . <br><br>         ,       ,  ,         ,   .    ,      , ,     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou peut-être dans le code d'application ou dans l'interpréteur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et comme il y a des erreurs, vous pouvez les utiliser pour obtenir l'intégralité du contenu de l'application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52:30 min </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suite:</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours MIT "Sécurité des systèmes informatiques".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conférence 4: «Partager les privilèges», partie 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version complète du cours est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en le recommandant à vos amis, une <b>réduction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vérité sur VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbps à partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV à partir de 249 $</a> aux Pays-Bas et aux États-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">création d'un bâtiment d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418197/">https://habr.com/ru/post/fr418197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418187/index.html">En Amérique, ils ont suggéré de remplacer toutes les bibliothèques par des hubs Amazon. Le public s'indigne</a></li>
<li><a href="../fr418189/index.html">Héritier de Zeus: pourquoi le cheval de Troie IcedID est dangereux pour les clients des banques</a></li>
<li><a href="../fr418191/index.html">Analogues en Python et JavaScript. Troisième partie</a></li>
<li><a href="../fr418193/index.html">Comment vous sentez-vous de créer un jeu pour Game Boy en 2017</a></li>
<li><a href="../fr418195/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 4: «Partager les privilèges», partie 1</a></li>
<li><a href="../fr418199/index.html">Comment faire une tâche technique simple et ne pas perdre d'argent et de nerfs</a></li>
<li><a href="../fr418201/index.html">Pouvons-nous relancer Duck Hunt?</a></li>
<li><a href="../fr418203/index.html">API GraphQL (CRUD) sur Go</a></li>
<li><a href="../fr418205/index.html">Space Language Vol.2: Bienvenue, GJ273b</a></li>
<li><a href="../fr418207/index.html">Examen des ordinateurs portables de jeu ASUS ROG Strix GL504GS SCAR II et ASUS ROG Strix GL504GM HERO II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>