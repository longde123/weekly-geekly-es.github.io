<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 🤽🏽 👛 Memperkenalkan CLI Builder 🖲️ 👁‍🗨 👩🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kita akan melihat API CLI Angular baru, yang akan memungkinkan Anda untuk memperluas fitur CLI yang ada dan menambahkan yang baru. K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan CLI Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450746/"><img src="https://habrastorage.org/webt/sm/xo/kb/smxokbjs_uhwjcb1rjv7cwt5k3m.png" alt="Memperkenalkan CLI Builder"><br><br>  Pada artikel ini, kita akan melihat API CLI Angular baru, yang akan memungkinkan Anda untuk memperluas fitur CLI yang ada dan menambahkan yang baru.  Kami akan membahas cara bekerja dengan API ini, dan poin ekstensi apa yang ada, yang memungkinkan penambahan fungsionalitas baru ke CLI. <br><a name="habracut"></a><br><h2>  Ceritanya </h2><br>  Sekitar setahun yang lalu, kami memperkenalkan file workspace ( <i>angular.json</i> ) di CLI Angular dan memikirkan kembali banyak prinsip dasar untuk mengimplementasikan perintahnya.  Kami sampai pada fakta bahwa kami menempatkan tim di "kotak": <br><br><ol><li> <b>Perintah skematik - "Perintah skematik</b> . <b>"</b>  Sekarang, Anda mungkin sudah mendengar tentang Skema, perpustakaan yang digunakan oleh CLI untuk membuat dan memodifikasi kode Anda.  Itu muncul di versi 5 dan saat ini digunakan di sebagian besar perintah yang berkaitan dengan kode Anda, seperti <i>baru</i> , <i>buat</i> , <i>tambah</i> dan <i>perbarui</i> . </li><li>  <b>Perintah lain-lain - "Tim lain"</b> .  Ini adalah perintah yang tidak terkait langsung dengan proyek Anda: <i>bantuan</i> , <i>versi</i> , <i>konfigurasi</i> , <i>doc</i> .  Baru-baru ini, <i>analitik</i> telah muncul, serta telur Paskah kami (Ssst! Tidak sepatah kata pun kepada siapa pun!). </li><li>  <b>Perintah tugas - "Perintah tugas</b> . <b>"</b>  Kategori ini, pada umumnya, "meluncurkan proses yang dieksekusi pada kode orang lain."  - Sebagai contoh, <i>build</i> adalah build proyek, <i>lint</i> sedang debugging dan <i>tes</i> sedang menguji. </li></ol><br>  Kami mulai mendesain <i>angular.json</i> sejak dulu.  Awalnya, itu dikandung sebagai pengganti konfigurasi Webpack.  Selain itu, itu seharusnya memungkinkan pengembang untuk secara mandiri memilih implementasi perakitan proyek.  Hasilnya, kami mendapatkan sistem peluncuran tugas dasar, yang tetap sederhana dan nyaman untuk eksperimen kami.  Kami menyebut API ini "Arsitek." <br><br>  Terlepas dari kenyataan bahwa Arsitek tidak didukung secara resmi, itu populer di kalangan pengembang yang ingin menyesuaikan perakitan proyek, serta di antara perpustakaan pihak ketiga yang perlu mengontrol alur kerja mereka.  Nx menggunakannya untuk menjalankan perintah Bazel, Ionic menggunakannya untuk menjalankan tes unit pada Jest, dan pengguna dapat memperluas konfigurasi Webpack mereka menggunakan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ngx-build-plus</a> .  Dan itu baru permulaan. <br><br>  <b>Versi API yang didukung, stabil, dan ditingkatkan secara resmi ini digunakan dalam Angular CLI versi 8.</b> <br><br><h2>  Konsep </h2><br>  API Arsitek menawarkan alat untuk menjadwalkan dan mengoordinasikan tugas yang digunakan CLI Angular untuk mengimplementasikan perintahnya.  Ini menggunakan fungsi yang disebut <br>  "Pembangun" - "kolektor" yang dapat bertindak sebagai tugas atau perencana kolektor lain.  Selain itu, ia menggunakan angular.json sebagai seperangkat instruksi untuk kolektor sendiri. <br><br>  Ini adalah sistem yang sangat umum yang dirancang agar fleksibel dan dapat diperluas.  Ini berisi API untuk pelaporan, pencatatan dan pengujian.  Jika perlu, sistem dapat diperluas untuk tugas-tugas baru. <br><br><h2>  Pemetik </h2><br>  Assembler adalah fungsi yang menerapkan logika dan perilaku untuk tugas yang dapat menggantikan perintah CLI.  - Misalnya, mulai linter. <br><br>  Fungsi kolektor mengambil dua argumen: nilai input (atau opsi) dan konteks yang menyediakan hubungan antara CLI dan kolektor itu sendiri.  Pembagian tanggung jawab di sini sama dengan Skema - pengguna CLI menentukan opsi, API bertanggung jawab atas konteksnya, dan Anda (pengembang) menetapkan perilaku yang diperlukan.  Perilaku dapat diimplementasikan secara sinkron, asinkron, atau hanya menampilkan sejumlah nilai tertentu.  Output harus bertipe <i>BuilderOutput</i> , yang berisi <i>keberhasilan</i> bidang logis dan <i>kesalahan</i> bidang opsional, yang berisi pesan kesalahan. <br><br><h2>  File dan tugas workspace </h2><br>  API Arsitek bergantung pada <i>angular.json</i> , file ruang kerja untuk menyimpan tugas dan pengaturannya. <br><br>  <i>angular.json</i> membagi ruang kerja menjadi proyek, dan mereka, pada gilirannya, menjadi tugas.  Sebagai contoh, aplikasi Anda dibuat dengan perintah <i>baru ng</i> adalah salah satu proyek tersebut.  Salah satu tugas dalam proyek ini adalah tugas <i>pembangunan</i> , yang dapat diluncurkan menggunakan perintah <i>ng build</i> .  Secara default, tugas ini memiliki tiga kunci: <br><br><ol><li>  <b>builder</b> - nama kolektor yang akan digunakan untuk menyelesaikan tugas, dalam format <i>PACKAGE_NAME: ASSEMBLY_NAME</i> . </li><li>  <b>Pilihan</b> - pengaturan yang digunakan saat memulai tugas secara default. </li><li>  <b>konfigurasi</b> - pengaturan yang akan diterapkan saat memulai tugas dengan konfigurasi yang ditentukan. </li></ol><br>  Pengaturan diterapkan sebagai berikut: ketika tugas dimulai, pengaturan diambil dari blok opsi, kemudian, jika konfigurasi telah ditentukan, pengaturannya ditulis di atas yang sudah ada.  Setelah itu, jika pengaturan tambahan diteruskan ke <i>scheduleTarget ()</i> - blok <i>override</i> , itu akan ditulis terakhir.  Saat menggunakan CLI Angular, argumen baris perintah diteruskan ke <i>penggantian</i> .  Setelah semua pengaturan ditransfer ke kolektor, dia memeriksanya sesuai dengan rencananya, dan hanya jika pengaturan sesuai dengan itu, konteksnya akan dibuat dan kolektor akan mulai bekerja. <br><br>  Informasi lebih lanjut tentang ruang kerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Buat kolektor Anda sendiri </h2><br>  Sebagai contoh, mari kita buat kolektor yang akan menjalankan perintah pada baris perintah.  Untuk membuat kolektor, gunakan pabrik <i>createBuilder</i> dan kembalikan objek <i>BuilderOutput</i> : <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); });</code> </pre> <br>  Sekarang, mari kita tambahkan beberapa logika ke kolektor kami: kami ingin mengontrol kolektor melalui pengaturan, membuat proses baru, menunggu proses selesai, dan jika proses berhasil diselesaikan (yaitu, kembalikan kode 0), beri tanda ini ke Arsitek: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Pemrosesan output </h2><br>  Sekarang, metode <i>spawn</i> meneruskan semua data ke output standar dari proses.  Kami mungkin ingin mentransfernya ke <i>logger</i> - logger.  Dalam hal ini, pertama, debugging selama pengujian akan difasilitasi, dan kedua, Arsitek itu sendiri dapat menjalankan kolektor kami dalam proses terpisah atau menonaktifkan output standar proses (misalnya, dalam aplikasi Electron). <br><br>  Untuk melakukan ini, kita dapat menggunakan <i>Logger</i> , tersedia di objek <i>konteks</i> , yang akan memungkinkan kita untuk mengarahkan ulang output dari proses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Laporan Kinerja dan Status </h2><br>  Bagian terakhir dari API terkait dengan penerapan kolektor Anda sendiri adalah laporan kemajuan dan status saat ini. <br><br>  Dalam kasus kami, perintahnya sudah selesai atau dijalankan, jadi tidak masuk akal untuk menambahkan laporan kemajuan.  Namun, kami dapat mengomunikasikan status kami kepada kolektor induk sehingga ia memahami apa yang terjadi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Executing "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${options.command}</span></span></span><span class="hljs-string">"...`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Done.`</span></span>); child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br>  Untuk melewati laporan <i>kemajuan</i> , gunakan metode <i>reportProgress</i> dengan nilai ringkasan saat ini dan (opsional) sebagai argumen.  <i>total</i> bisa berupa angka apa saja.  Misalnya, jika Anda tahu berapa banyak file yang perlu Anda proses, Anda dapat mentransfer jumlahnya ke <i>total</i> , kemudian ke <i>saat ini</i> Anda dapat mentransfer jumlah file yang sudah diproses.  Ini adalah bagaimana <a href="">pengumpul tslint</a> melaporkan kemajuannya. <br><br><h2>  Input Validasi </h2><br>  Objek <i>opsi yang</i> diteruskan ke kolektor diperiksa menggunakan Skema JSON.  Ini mirip dengan Skema jika Anda tahu apa itu. <br><br>  Dalam contoh kolektor kami, kami berharap bahwa parameter kami akan menjadi objek yang menerima dua kunci: <i>command</i> - command (string) dan <i>args</i> - arguments (array of strings).  Skema verifikasi kami akan terlihat seperti ini: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } }</code> </pre><br>  Skema adalah alat yang sangat kuat yang dapat melakukan sejumlah besar pemeriksaan.  Untuk informasi lebih lanjut tentang skema JSON, Anda dapat merujuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web skema JSON resmi</a> . <br><br><h2>  Buat paket build </h2><br>  Ada satu file kunci yang perlu kita buat untuk kolektor kita sendiri agar membuatnya kompatibel dengan Angular CLI - <i>builders.json</i> , yang bertanggung jawab atas hubungan antara implementasi kolektor, nama, dan skema verifikasi kami.  File itu sendiri terlihat seperti ini: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"implementation"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command/schema.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Runs any command line in the operating system."</span></span> } } }</code> </pre><br>  Kemudian, dalam file <i>package.json</i> , kami menambahkan kunci <i>builders</i> , menunjuk ke file <i>builders.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Builder for Architect"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: <span class="hljs-string"><span class="hljs-string">"builders.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@angular-devkit/architect"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.0.0"</span></span> } }</code> </pre><br>  Ini akan memberi tahu Arsitek tempat mencari file definisi kolektor. <br><br>  Dengan demikian, nama pengumpul kami adalah <i>"@ example / runner-run: command"</i> .  Bagian pertama dari nama, sebelum titik dua (:) adalah nama paket, didefinisikan menggunakan <i>package.json</i> .  Bagian kedua adalah nama kolektor, didefinisikan menggunakan file <i>builders.json</i> . <br><br><h2>  Menguji pembangun Anda sendiri </h2><br>  Cara yang disarankan untuk menguji assembler adalah melalui pengujian integrasi.  Ini karena membuat <i>konteks</i> tidak mudah, jadi Anda harus menggunakan penjadwal dari Arsitek. <br><br>  Untuk menyederhanakan pola, kami memikirkan cara sederhana untuk membuat contoh Arsitek: pertama Anda membuat <i>JsonSchemaRegistry</i> (untuk menguji skema), lalu <i>TestingArchitectHost</i> dan, akhirnya, contoh <i>Arsitek</i> .  Sekarang Anda dapat mengkompilasi <i>file</i> konfigurasi <i>builders.json</i> . <br><br>  Berikut adalah contoh menjalankan kolektor, yang menjalankan <i>perintah ls</i> dan memverifikasi bahwa perintah selesai dengan sukses.  Harap dicatat bahwa kami akan menggunakan output proses standar dalam <i>logger</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Architect, ArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TestingArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { logging, schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/core'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Command Runner Builder'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architect: Architect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architectHost: ArchitectHost; beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.CoreSchemaRegistry(); registry.addPostTransform(schema.transforms.addUndefinedDefaults); <span class="hljs-comment"><span class="hljs-comment">//  TestingArchitectHost –    . //     ,   . architectHost = new TestingArchitectHost(__dirname, __dirname); architect = new Architect(architectHost, registry); //      NPM-, //    package.json  . await architectHost.addBuilderFromPackage('..'); }); //      Windows it('can run ls', async () =&gt; { //  ,     . const logger = new logging.Logger(''); const logs = []; logger.subscribe(ev =&gt; logs.push(ev.message)); // "run"    ,       . const run = await architect.scheduleBuilder('@example/command-runner:command', { command: 'ls', args: [__dirname], }, { logger }); // "result" –    . //    "BuilderOutput". const output = await run.result; //  . Architect     //   ,    ,    . await run.stop(); //   . expect(output.success).toBe(true); // ,     . // `ls $__dirname`. expect(logs).toContain('index_spec.ts'); }); });</span></span></code> </pre><br>  Untuk menjalankan contoh di atas, Anda memerlukan paket <i>ts-node</i> .  Jika Anda bermaksud menggunakan Node, ganti nama <i>index_spec.ts</i> menjadi <i>index_spec.js</i> . <br><br><h2>  Menggunakan kolektor dalam suatu proyek </h2><br>  Mari kita buat angular.json sederhana yang menunjukkan semua yang kita pelajari tentang assembler.  Dengan asumsi kami mengemas kolektor kami dalam <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">contoh</a> / command-runner</i> dan kemudian membuat aplikasi baru menggunakan <i>tes builder baru</i> , file <i>angular.json</i> mungkin terlihat seperti ini (beberapa konten telah dihapus karena singkatnya): <br><br><pre> <code class="json hljs">{ // ...   . <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre><br>  Jika kami memutuskan untuk menambahkan tugas baru untuk menerapkan (misalnya) perintah <i>sentuh</i> ke file (memperbarui tanggal modifikasi file) menggunakan kolektor kami, kami akan menjalankan <i>npm install <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">example</a> / command-runner</i> , dan kemudian membuat perubahan ke <i>angular.json</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"touch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner:command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"touch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fileReplacements"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"replace"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"with"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.prod.ts"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } } } }</code> </pre><br>  CLI Angular memiliki perintah <i>jalankan</i> , yang merupakan perintah utama untuk menjalankan kolektor.  Sebagai argumen pertama, dibutuhkan string dengan format <i>PROYEK: TUGAS [: KONFIGURASI]</i> .  Untuk menjalankan tugas kita, kita dapat menggunakan perintah <i>ng run builder-test: touch</i> . <br><br>  Sekarang kita mungkin ingin mendefinisikan kembali beberapa argumen.  Sayangnya, kami tidak dapat mendefinisikan ulang array dari baris perintah sejauh ini, namun kami dapat mengubah perintah itu sendiri untuk demonstrasi: <i>ng run builder-test: touch --command = ls</i> .  - Ini akan menampilkan file <i>src / main.ts.</i> <br><br><h2>  Mode Tonton </h2><br>  Secara default, diasumsikan bahwa kolektor akan dipanggil sekali dan diakhiri, namun, mereka dapat mengembalikan <i>Observable</i> untuk menerapkan mode pengamatan sendiri (seperti yang dilakukan kolektor <i>Webpack</i> ).  Arsitek akan berlangganan <i>Observable</i> sampai selesai atau berhenti dan dapat berlangganan ke kolektor lagi jika kolektor dipanggil dengan parameter yang sama (walaupun tidak dijamin). <br><br><ol><li>  Kolektor harus mengembalikan objek <i>BuilderOutput</i> setelah setiap eksekusi.  Setelah selesai, ia dapat memasuki mode pengamatan yang disebabkan oleh peristiwa eksternal dan, jika dimulai lagi, ia harus memanggil fungsi <i>context.reportRunning ()</i> untuk memberi tahu Arsitek bahwa kolektor bekerja lagi.  Ini akan melindungi kolektor dari menghentikannya oleh Arsitek pada panggilan baru. </li><li>  Arsitek sendiri berhenti berlangganan dari <i>Observable</i> ketika kolektor berhenti (menggunakan run.stop (), misalnya), menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logika Teardown</a> - algoritma penghancuran.  Ini akan memungkinkan Anda untuk berhenti dan menghapus perakitan jika proses ini sudah berjalan. </li></ol><br>  Ringkas hal di atas, jika kolektor Anda menonton acara eksternal, ia bekerja dalam tiga tahap: <br><br><ol><li>  <b>Pemenuhan.</b>  Misalnya, kompilasi Webpack.  Langkah ini berakhir ketika Webpack selesai membangun dan kolektor Anda mengirimkan <i>BuilderOutput</i> ke <i>Observable</i> . </li><li>  <b>Pengamatan.</b>  - Di antara dua peluncuran, acara eksternal dipantau.  Sebagai contoh, Webpack memonitor sistem file untuk setiap perubahan.  Langkah ini berakhir ketika Webpack melanjutkan build dan <i>context.reportRunning ()</i> dipanggil.  Setelah langkah ini, langkah 1 dimulai lagi. </li><li>  <b>Penyelesaian.</b>  - Tugas selesai sepenuhnya (misalnya, diharapkan bahwa Webpack akan memulai beberapa kali tertentu) atau mulai dari kolektor dihentikan (menggunakan <i>run.stop ()</i> ).  Dalam hal ini, algoritme penghancuran yang <i>dapat diamati</i> dijalankan, dan dihapus. </li></ol><br><h2>  Kesimpulan </h2><br>  Berikut ini ringkasan dari apa yang kami pelajari dalam publikasi ini: <br><br><ol><li>  Kami menyediakan API baru yang akan memungkinkan pengembang untuk mengubah perilaku perintah CLI Angular dan menambahkan yang baru menggunakan assembler yang menerapkan logika yang diperlukan. </li><li>  Kolektor dapat sinkron, asinkron, dan responsif terhadap peristiwa eksternal.  Mereka dapat dipanggil beberapa kali, serta oleh kolektor lain. </li><li>  Parameter yang diterima kolektor ketika tugas dimulai pertama kali dibaca dari file <i>angular.json</i> , kemudian ditimpa oleh parameter dari konfigurasi, jika ada, dan kemudian ditimpa oleh bendera baris perintah jika ditambahkan. </li><li>  Cara yang disarankan untuk menguji pengumpul adalah melalui uji integrasi, namun Anda dapat melakukan pengujian unit secara terpisah dari logika pengumpul. </li><li>  Jika kolektor mengembalikan sebuah Observable, itu harus dibersihkan setelah melewati algoritma penghancuran. </li></ol><br>  Dalam waktu dekat, frekuensi penggunaan API ini akan meningkat.  Misalnya, implementasi Bazel sangat terkait dengan mereka. <br><br>  Kami sudah melihat bagaimana komunitas membuat kolektor CLI baru untuk digunakan, misalnya, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">canda</a></i> dan <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cemara</a></i> untuk pengujian. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450746/">https://habr.com/ru/post/id450746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450734/index.html">Fuzzing adalah langkah penting dalam pengembangan yang aman</a></li>
<li><a href="../id450736/index.html">"Mengisolasi Internet jauh lebih mudah dan lebih murah daripada menyediakannya dengan pemblokiran eksternal."</a></li>
<li><a href="../id450738/index.html">Robot di pusat data: bagaimana kecerdasan buatan dapat berguna?</a></li>
<li><a href="../id450740/index.html">Basis lampu pintar REDMOND - menambah rumah pintar</a></li>
<li><a href="../id450744/index.html">Infrastruktur sepeda Minsk untuk ekspat TI</a></li>
<li><a href="../id450748/index.html">Sertifikasi ISTQB. Bagian 1: menjadi atau tidak menjadi?</a></li>
<li><a href="../id450752/index.html">"Saya hanya punya satu metode pengajaran: hanya bekerja" - wawancara dengan Ryan Dahl (Node.js, Deno)</a></li>
<li><a href="../id450754/index.html">Balapan kursi roda: pilot Rusia memenangkan kejuaraan CYBATHLON di Tokyo</a></li>
<li><a href="../id450756/index.html">Tentang ketidakmampuan militer</a></li>
<li><a href="../id450758/index.html">factory_trace gem membantu membersihkan pabrik Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>