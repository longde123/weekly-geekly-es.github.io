<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏺 👌🏻 👁️ Über LL-Parsing: Ein Ansatz zum Parsen durch das Konzept des String-Schneidens 👩🏻‍🎓 🦇 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grüße an die angesehene Community! 

 Wiederholung ist die Mutter des Lernens, und das Verstehen des Parsens ist eine sehr nützliche Fähigkeit für jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über LL-Parsing: Ein Ansatz zum Parsen durch das Konzept des String-Schneidens</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Grüße an die angesehene Community! <br><br>  Wiederholung ist die Mutter des Lernens, und das Verstehen des Parsens ist eine sehr nützliche Fähigkeit für jeden Programmierer. Deshalb möchte ich dieses Thema noch einmal ansprechen und dieses Mal über die Analyse rekursiver Abstammung (LL) sprechen, ohne zu viel Formalismus zu betreiben (Sie können sie später jederzeit verwenden komm zurück). <br><br>  Wie der große D. Strogov schreibt: "Verstehen heißt vereinfachen."  Um das Konzept des Parsens mit der rekursiven Abstiegsmethode (auch bekannt als LL-Parsing) zu verstehen, vereinfachen wir die Aufgabe so weit wie möglich und schreiben manuell einen Parser in einem JSON-ähnlichen, aber einfacheren Format (wenn Sie möchten, können Sie ihn dann zu einem vollwertigen JSON-Parser erweitern, wenn trainieren wollen).  Schreiben wir es auf der Grundlage der Idee <b>, die Schnur zu schneiden</b> . <br><a name="habracut"></a><br>  In klassischen Büchern und Compiler-Design-Kursen beginnen sie normalerweise, das Thema Parsen und Interpretieren zu erklären, wobei mehrere Phasen hervorgehoben werden: <br><br><ul><li>  Lexikalische Analyse: Aufteilen des Quelltextes in eine Reihe von Teilzeichenfolgen (Token oder Token) </li><li>  Parsing: Erstellen eines Parsing-Baums aus einer Reihe von Token </li><li>  Interpretation (oder Kompilierung): Durchlaufen des resultierenden Baums in der gewünschten (direkten oder umgekehrten) Reihenfolge und Ausführen einiger Interpretations- oder Codegenerierungsaktionen in einigen Schritten dieser Durchquerung </li></ul><br><div class="spoiler">  <b class="spoiler_title">nicht wirklich so</b> <div class="spoiler_text">  Da wir beim Parsen bereits eine Folge von Schritten erhalten, dh eine Folge von Besuchen von Baumknoten, existiert der Baum selbst in expliziter Form möglicherweise überhaupt nicht, aber wir werden noch nicht tief gehen.  Für diejenigen, die tiefer gehen wollen, gibt es am Ende Links. <br></div></div><br>  Jetzt möchte ich einen etwas anderen Ansatz für dasselbe Konzept (LL-Analyse) verwenden und zeigen, wie Sie einen LL-Analysator basierend auf der Idee des Schneidens einer Zeichenfolge erstellen können: Fragmente werden während der Analyse aus der ursprünglichen Zeichenfolge herausgeschnitten, sie wird kleiner und dann analysiert den Rest der Linie ausgesetzt.  Infolgedessen kommen wir zu demselben Konzept des rekursiven Abstiegs, jedoch auf etwas andere Weise als gewöhnlich.  Vielleicht ist dieser Weg bequemer, um das Wesentliche der Idee zu verstehen.  Und wenn nicht, dann ist es immer noch eine Gelegenheit, einen rekursiven Abstieg aus einem anderen Blickwinkel zu betrachten. <br><br>  Beginnen wir mit einer einfacheren Aufgabe: Es gibt eine Zeile mit Trennzeichen, und ich möchte eine Iteration über deren Werte schreiben.  So etwas wie: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Wie kann das gemacht werden?  Die Standardmethode besteht darin, die begrenzte Zeichenfolge mit String.split (in Java) oder names.split (",") (in Javascript) in ein Array oder eine Liste zu konvertieren und das Array bereits zu durchlaufen.  Stellen wir uns jedoch vor, wir möchten oder können die Konvertierung in ein Array nicht verwenden (zum Beispiel plötzlich, wenn wir in der Programmiersprache AVAJ ++ programmieren, in der es keine "Array" -Datenstruktur gibt).  Sie können die Zeichenfolge weiterhin scannen und die Trennzeichen verfolgen, aber ich werde diese Methode auch nicht verwenden, da sie den Iterationsschleifencode umständlich macht und vor allem dem Konzept widerspricht, das ich zeigen möchte.  Daher beziehen wir uns auf eine begrenzte Zeichenfolge genauso wie auf Listen in der funktionalen Programmierung.  Und dort definieren sie immer die Funktionen head (das erste Element der Liste abrufen) und tail (den Rest der Liste abrufen).  Ausgehend von den ersten Dialekten von Lisp, in denen diese Funktionen absolut schrecklich und unintuitiv genannt wurden: Auto und CDR (Auto = Inhalt des Adressregisters, CDR = Inhalt des Dekrementregisters. Die Legenden der alten Zeit sind tief, ja, eheheh.). <br><br>  Unsere Linie ist eine begrenzte Linie.  Markieren Sie die Trennwände in lila: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Und markieren Sie die Listenelemente in Gelb: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Wir nehmen an, dass unsere Zeile veränderlich ist (sie kann geändert werden) und schreiben eine Funktion: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Ihre Unterschrift könnte zum Beispiel sein: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  Zur Eingabe der Funktion geben wir eine Liste (in Form einer Zeichenfolge mit Trennzeichen) und tatsächlich den Wert des Trennzeichens an.  Am Ausgang gibt die Funktion das erste Element der Liste (Liniensegment zum ersten Trennzeichen), den Rest der Liste und das Vorzeichen zurück, ob das erste Element zurückgegeben wurde.  In diesem Fall wird der Rest der Liste in dieselbe Variable wie die ursprüngliche Liste gestellt. <br><br>  Als Ergebnis hatten wir die Möglichkeit, folgendermaßen zu schreiben: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Ergebnisse wie erwartet: <br><br>  ivanov <br>  petrov <br>  sidorov <br><br>  Wir haben auf die Konvertierung in ArrayList verzichtet, aber die Variable names verwöhnt, und jetzt hat sie eine leere Zeichenfolge.  Es sieht noch nicht sehr nützlich aus, als hätten sie die Ahle gegen Seife ausgetauscht.  Aber gehen wir weiter.  Dort werden wir sehen, warum es notwendig war und wohin es uns führen wird. <br><br>  Lassen Sie uns nun etwas Interessanteres analysieren: eine Liste von Schlüssel-Wert-Paaren.  Dies ist auch eine sehr häufige Aufgabe. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Fazit: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Auch erwartet.  Und das Gleiche kann mit String.split erreicht werden, ohne die Linien zu schneiden. <br>  Nehmen wir an, wir wollten jetzt unser Format komplizieren und von einem flachen Schlüsselwert zu einem verschachtelbaren Format übergehen, das an JSON erinnert.  Jetzt wollen wir so etwas lesen: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Welches Trennzeichen wird geteilt?  Wenn es ein Komma ist, haben wir in einem der Token die Zeile <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Offensichtlich nicht das, was wir brauchen.  Daher müssen wir auf die Struktur der Linie achten, die wir analysieren möchten. <br><br>  Es beginnt mit einer geschweiften Klammer und endet mit einer geschweiften Klammer (gepaart damit, was wichtig ist).  In diesen Klammern befindet sich eine Liste der Paare 'Schlüssel': 'Wert', wobei jedes Paar durch ein Komma vom nächsten Paar getrennt ist.  Der Schlüssel und der Wert werden durch einen Doppelpunkt getrennt.  Ein Schlüssel ist eine Buchstabenfolge, die in Apostrophen eingeschlossen ist.  Der Wert kann eine Zeichenfolge sein, die in Apostrophen eingeschlossen ist, oder er kann dieselbe Struktur haben, die mit gepaarten geschweiften Klammern beginnt und endet.  Wir nennen eine solche Struktur das Wort "Objekt", wie es in JSON üblich ist. <br><br>  Wir haben nur informell die Grammatik unseres JSON-ähnlichen Formats beschrieben.  Typischerweise werden Grammatiken in umgekehrter, formaler Form beschrieben, und die BNF-Notation oder ihre Variationen werden verwendet, um sie zu schreiben.  Aber jetzt kann ich darauf verzichten, und wir werden sehen, wie Sie diese Zeile "ausschneiden" können, damit sie gemäß den Regeln dieser Grammatik analysiert werden kann. <br><br>  Tatsächlich beginnt unser „Objekt“ mit einer öffnenden geschweiften Klammer und endet mit einem Paar, das es schließt.  Was kann eine Funktion, die ein solches Format analysiert, tun?  Höchstwahrscheinlich Folgendes: <br><br><ul><li>  Stellen Sie sicher, dass die übergebene Zeichenfolge mit einer öffnenden Klammer beginnt </li><li>  Stellen Sie sicher, dass die übergebene Zeichenfolge mit einem Paar schließender Klammern endet </li><li>  Wenn beide Bedingungen erfüllt sind, schneiden Sie die öffnenden und schließenden Klammern ab und übergeben Sie die verbleibenden Funktionen an die Funktion, die die Liste der Paare 'key': 'value' analysiert. </li></ul><br>  Bitte beachten Sie: Die Wörter "Funktion zum Parsen dieses Formats" und "Funktion zum Parsen der Liste der Paare 'Schlüssel': 'Wert'" wurden angezeigt.  Wir haben zwei Funktionen!  Dies sind genau die Funktionen, die in der klassischen Beschreibung des rekursiven Abstiegsalgorithmus als "Analysefunktionen nichtterminaler Symbole" bezeichnet werden und die besagen, dass "für jedes nichtterminale Symbol eine eigene Analysefunktion erstellt wird".  Was es tatsächlich analysiert.  Wir könnten sie beispielsweise parseJsonObject und parseJsonPairList nennen. <br><br>  Auch jetzt müssen wir darauf achten, dass wir zusätzlich zum Konzept des „Separators“ das Konzept der „Paarklammer“ haben.  Wenn wir eine Zeile zum nächsten Trennzeichen schneiden möchten (ein Doppelpunkt zwischen einem Schlüssel und einem Wert, ein Komma zwischen den Paaren „Schlüssel: Wert“), hat uns die Funktion cutNextToken gereicht, da wir jetzt nicht nur eine Zeichenfolge, sondern auch ein Objekt verwenden können, das wir benötigen Funktion „Auf das nächste Klammerpaar schneiden“.  So etwas wie das: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Diese Funktion schneidet ein Fragment von der Linie von der öffnenden Klammer zu dem Paar, das es schließt, unter Berücksichtigung der Klammern, falls vorhanden.  Natürlich können Sie nicht auf Klammern beschränkt sein, sondern verwenden eine ähnliche Funktion, um verschiedene Blockstrukturen abzuschneiden, die verschachtelt werden können: Operatorblöcke beginnen..end, if..endif, for..endfor und ähnliche. <br><br>  Lassen Sie uns grafisch zeichnen, was mit der Zeichenfolge passieren wird.  Türkisfarbe - Dies bedeutet, dass wir die Linie vorwärts zu dem in Türkis hervorgehobenen Symbol scannen, um zu bestimmen, was als nächstes zu tun ist.  Violett ist „was abgeschnitten werden soll. In diesem Fall schneiden wir die in Violett hervorgehobenen Fragmente von der Linie ab und analysieren weiter, was davon übrig bleibt. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  Zum Vergleich die Ausgabe des Programms (der Programmtext ist im Anhang angegeben), das diese Zeile analysiert: <br><br>  Demonstration der Analyse der JSON-ähnlichen Struktur <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  Wir wissen jederzeit, was wir in unserer Eingabezeile erwarten.  Wenn wir die Funktion parseJsonObject eingegeben haben, erwarten wir, dass das Objekt dort an uns übergeben wurde, und wir können dies durch das Vorhandensein der öffnenden und schließenden Klammern am Anfang und am Ende überprüfen.  Wenn wir die Funktion parseJsonPairList eingegeben haben, erwarten wir dort eine Liste von "Schlüssel: Wert" -Paaren, und nachdem wir den Schlüssel "abgebissen" haben (vor dem Trennzeichen ":"), erwarten wir, dass das nächste, was wir "abbeißen", ist Wert.  Wir können uns das erste Zeichen des Werts ansehen und eine Schlussfolgerung über seinen Typ ziehen (wenn das Apostroph, dann ist der Wert vom Typ "Zeichenfolge", wenn die öffnende geschweifte Klammer der Wert vom Typ "Objekt" ist). <br><br>  Wenn wir also Fragmente von der Zeichenfolge abschneiden, können wir sie mit der Methode der Top-Down-Analyse (rekursiver Abstieg) analysieren.  Und wenn wir analysieren können, können wir das Format analysieren, das wir benötigen.  Oder erstellen Sie Ihr eigenes Format, das für uns geeignet ist, und zerlegen Sie es.  Oder erstellen Sie eine domänenspezifische Sprache (Domain Specific Language, DSL) für unseren speziellen Bereich und entwerfen Sie einen Dolmetscher dafür.  Und um es richtig zu konstruieren, ohne gequälte Lösungen auf regulären Ausdrücken oder selbst erstellten Zustandsmaschinen, die für Programmierer entstehen, die versuchen, ein Problem zu lösen, das analysiert werden muss, aber das Material nicht ganz besitzen. <br><br>  Hier.  Herzlichen Glückwunsch an alle zum kommenden Sommer und alles Gute, Liebe und funktionale Parser :) <br><br>  Zur weiteren Lektüre: <br><br>  Ideologisch: ein paar lange, aber lesenswerte Artikel von Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reichhaltiges Programmiereressen</a> <br><br>  Ein paar Zitate von dort: <br><blockquote>  Sie lernen entweder Compiler und beginnen, Ihre eigenen DSLs zu schreiben, oder Sie lernen eine bessere Sprache </blockquote><blockquote>  Die erste große Phase der Kompilierungspipeline ist das Parsen </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Pinocchio-Problem</a> <br><br>  Zitat von dort: <br><blockquote>  Typumwandlungen, Eingrenzen und Erweitern von Konvertierungen, Friend-Funktionen zum Umgehen des Standardklassenschutzes, <b>Füllen von Minisprachen in Zeichenfolgen und Parsen von Hand</b> . Es gibt Dutzende von Möglichkeiten, die Typsysteme in Java und C ++ zu umgehen, und Programmierer verwenden sie ständig , weil sie (wenig wissen sie) tatsächlich versuchen, Software zu erstellen, nicht Hardware. </blockquote>  Technisch: zwei Artikel zum Parsen über den Unterschied zwischen LL- und LR-Ansätzen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LL und LR Parsing entmystifiziert</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LL und LR im Kontext: Warum Parsing-Tools schwierig sind</a> <br><br>  Und noch tiefer in das Thema: Wie schreibe ich einen Lisp-Interpreter in C ++? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lisp-Interpreter in 90 Zeilen C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Anwendung.</b>  <b class="spoiler_title">Beispielcode (Java), der den im Artikel beschriebenen Analysator implementiert:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412905/">https://habr.com/ru/post/de412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412895/index.html">Vesta Matveeva: Der Kampf gegen Cyberkriminalität ist eine moralische Entscheidung</a></li>
<li><a href="../de412897/index.html">Überwachung von Atlassian-Produkten mit Prometheus</a></li>
<li><a href="../de412899/index.html">Wochenendlesung: 30 Materialien zu Ton, der Geschichte der Audiomarken und der Filmindustrie</a></li>
<li><a href="../de412901/index.html">Überwachung und Kubernetes (Rückblick und Videobericht)</a></li>
<li><a href="../de412903/index.html">Wie wir Habr gemalt haben</a></li>
<li><a href="../de412911/index.html">Entwickler sprechen über Funktionen, die aus Spielen herausgeschnitten wurden</a></li>
<li><a href="../de412913/index.html">"Baikal-T1" wurde für 3990 Rubel verkauft</a></li>
<li><a href="../de412915/index.html">Bestimmung der Gasdichte aus den Ergebnissen der Druck- und Temperaturmessung mit Arduino-Sensoren</a></li>
<li><a href="../de412917/index.html">Die russische Post wird beginnen, Robotersortierer einzusetzen. Wie es funktionieren wird</a></li>
<li><a href="../de412921/index.html">Monero-Netzwerksignaturen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>