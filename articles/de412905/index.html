<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∫ üëåüèª üëÅÔ∏è √úber LL-Parsing: Ein Ansatz zum Parsen durch das Konzept des String-Schneidens üë©üèª‚Äçüéì ü¶á üïê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√º√üe an die angesehene Community! 

 Wiederholung ist die Mutter des Lernens, und das Verstehen des Parsens ist eine sehr n√ºtzliche F√§higkeit f√ºr jed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber LL-Parsing: Ein Ansatz zum Parsen durch das Konzept des String-Schneidens</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Gr√º√üe an die angesehene Community! <br><br>  Wiederholung ist die Mutter des Lernens, und das Verstehen des Parsens ist eine sehr n√ºtzliche F√§higkeit f√ºr jeden Programmierer. Deshalb m√∂chte ich dieses Thema noch einmal ansprechen und dieses Mal √ºber die Analyse rekursiver Abstammung (LL) sprechen, ohne zu viel Formalismus zu betreiben (Sie k√∂nnen sie sp√§ter jederzeit verwenden komm zur√ºck). <br><br>  Wie der gro√üe D. Strogov schreibt: "Verstehen hei√üt vereinfachen."  Um das Konzept des Parsens mit der rekursiven Abstiegsmethode (auch bekannt als LL-Parsing) zu verstehen, vereinfachen wir die Aufgabe so weit wie m√∂glich und schreiben manuell einen Parser in einem JSON-√§hnlichen, aber einfacheren Format (wenn Sie m√∂chten, k√∂nnen Sie ihn dann zu einem vollwertigen JSON-Parser erweitern, wenn trainieren wollen).  Schreiben wir es auf der Grundlage der Idee <b>, die Schnur zu schneiden</b> . <br><a name="habracut"></a><br>  In klassischen B√ºchern und Compiler-Design-Kursen beginnen sie normalerweise, das Thema Parsen und Interpretieren zu erkl√§ren, wobei mehrere Phasen hervorgehoben werden: <br><br><ul><li>  Lexikalische Analyse: Aufteilen des Quelltextes in eine Reihe von Teilzeichenfolgen (Token oder Token) </li><li>  Parsing: Erstellen eines Parsing-Baums aus einer Reihe von Token </li><li>  Interpretation (oder Kompilierung): Durchlaufen des resultierenden Baums in der gew√ºnschten (direkten oder umgekehrten) Reihenfolge und Ausf√ºhren einiger Interpretations- oder Codegenerierungsaktionen in einigen Schritten dieser Durchquerung </li></ul><br><div class="spoiler">  <b class="spoiler_title">nicht wirklich so</b> <div class="spoiler_text">  Da wir beim Parsen bereits eine Folge von Schritten erhalten, dh eine Folge von Besuchen von Baumknoten, existiert der Baum selbst in expliziter Form m√∂glicherweise √ºberhaupt nicht, aber wir werden noch nicht tief gehen.  F√ºr diejenigen, die tiefer gehen wollen, gibt es am Ende Links. <br></div></div><br>  Jetzt m√∂chte ich einen etwas anderen Ansatz f√ºr dasselbe Konzept (LL-Analyse) verwenden und zeigen, wie Sie einen LL-Analysator basierend auf der Idee des Schneidens einer Zeichenfolge erstellen k√∂nnen: Fragmente werden w√§hrend der Analyse aus der urspr√ºnglichen Zeichenfolge herausgeschnitten, sie wird kleiner und dann analysiert den Rest der Linie ausgesetzt.  Infolgedessen kommen wir zu demselben Konzept des rekursiven Abstiegs, jedoch auf etwas andere Weise als gew√∂hnlich.  Vielleicht ist dieser Weg bequemer, um das Wesentliche der Idee zu verstehen.  Und wenn nicht, dann ist es immer noch eine Gelegenheit, einen rekursiven Abstieg aus einem anderen Blickwinkel zu betrachten. <br><br>  Beginnen wir mit einer einfacheren Aufgabe: Es gibt eine Zeile mit Trennzeichen, und ich m√∂chte eine Iteration √ºber deren Werte schreiben.  So etwas wie: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Wie kann das gemacht werden?  Die Standardmethode besteht darin, die begrenzte Zeichenfolge mit String.split (in Java) oder names.split (",") (in Javascript) in ein Array oder eine Liste zu konvertieren und das Array bereits zu durchlaufen.  Stellen wir uns jedoch vor, wir m√∂chten oder k√∂nnen die Konvertierung in ein Array nicht verwenden (zum Beispiel pl√∂tzlich, wenn wir in der Programmiersprache AVAJ ++ programmieren, in der es keine "Array" -Datenstruktur gibt).  Sie k√∂nnen die Zeichenfolge weiterhin scannen und die Trennzeichen verfolgen, aber ich werde diese Methode auch nicht verwenden, da sie den Iterationsschleifencode umst√§ndlich macht und vor allem dem Konzept widerspricht, das ich zeigen m√∂chte.  Daher beziehen wir uns auf eine begrenzte Zeichenfolge genauso wie auf Listen in der funktionalen Programmierung.  Und dort definieren sie immer die Funktionen head (das erste Element der Liste abrufen) und tail (den Rest der Liste abrufen).  Ausgehend von den ersten Dialekten von Lisp, in denen diese Funktionen absolut schrecklich und unintuitiv genannt wurden: Auto und CDR (Auto = Inhalt des Adressregisters, CDR = Inhalt des Dekrementregisters. Die Legenden der alten Zeit sind tief, ja, eheheh.). <br><br>  Unsere Linie ist eine begrenzte Linie.  Markieren Sie die Trennw√§nde in lila: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Und markieren Sie die Listenelemente in Gelb: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Wir nehmen an, dass unsere Zeile ver√§nderlich ist (sie kann ge√§ndert werden) und schreiben eine Funktion: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Ihre Unterschrift k√∂nnte zum Beispiel sein: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  Zur Eingabe der Funktion geben wir eine Liste (in Form einer Zeichenfolge mit Trennzeichen) und tats√§chlich den Wert des Trennzeichens an.  Am Ausgang gibt die Funktion das erste Element der Liste (Liniensegment zum ersten Trennzeichen), den Rest der Liste und das Vorzeichen zur√ºck, ob das erste Element zur√ºckgegeben wurde.  In diesem Fall wird der Rest der Liste in dieselbe Variable wie die urspr√ºngliche Liste gestellt. <br><br>  Als Ergebnis hatten wir die M√∂glichkeit, folgenderma√üen zu schreiben: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Ergebnisse wie erwartet: <br><br>  ivanov <br>  petrov <br>  sidorov <br><br>  Wir haben auf die Konvertierung in ArrayList verzichtet, aber die Variable names verw√∂hnt, und jetzt hat sie eine leere Zeichenfolge.  Es sieht noch nicht sehr n√ºtzlich aus, als h√§tten sie die Ahle gegen Seife ausgetauscht.  Aber gehen wir weiter.  Dort werden wir sehen, warum es notwendig war und wohin es uns f√ºhren wird. <br><br>  Lassen Sie uns nun etwas Interessanteres analysieren: eine Liste von Schl√ºssel-Wert-Paaren.  Dies ist auch eine sehr h√§ufige Aufgabe. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Fazit: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Auch erwartet.  Und das Gleiche kann mit String.split erreicht werden, ohne die Linien zu schneiden. <br>  Nehmen wir an, wir wollten jetzt unser Format komplizieren und von einem flachen Schl√ºsselwert zu einem verschachtelbaren Format √ºbergehen, das an JSON erinnert.  Jetzt wollen wir so etwas lesen: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Welches Trennzeichen wird geteilt?  Wenn es ein Komma ist, haben wir in einem der Token die Zeile <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Offensichtlich nicht das, was wir brauchen.  Daher m√ºssen wir auf die Struktur der Linie achten, die wir analysieren m√∂chten. <br><br>  Es beginnt mit einer geschweiften Klammer und endet mit einer geschweiften Klammer (gepaart damit, was wichtig ist).  In diesen Klammern befindet sich eine Liste der Paare 'Schl√ºssel': 'Wert', wobei jedes Paar durch ein Komma vom n√§chsten Paar getrennt ist.  Der Schl√ºssel und der Wert werden durch einen Doppelpunkt getrennt.  Ein Schl√ºssel ist eine Buchstabenfolge, die in Apostrophen eingeschlossen ist.  Der Wert kann eine Zeichenfolge sein, die in Apostrophen eingeschlossen ist, oder er kann dieselbe Struktur haben, die mit gepaarten geschweiften Klammern beginnt und endet.  Wir nennen eine solche Struktur das Wort "Objekt", wie es in JSON √ºblich ist. <br><br>  Wir haben nur informell die Grammatik unseres JSON-√§hnlichen Formats beschrieben.  Typischerweise werden Grammatiken in umgekehrter, formaler Form beschrieben, und die BNF-Notation oder ihre Variationen werden verwendet, um sie zu schreiben.  Aber jetzt kann ich darauf verzichten, und wir werden sehen, wie Sie diese Zeile "ausschneiden" k√∂nnen, damit sie gem√§√ü den Regeln dieser Grammatik analysiert werden kann. <br><br>  Tats√§chlich beginnt unser ‚ÄûObjekt‚Äú mit einer √∂ffnenden geschweiften Klammer und endet mit einem Paar, das es schlie√üt.  Was kann eine Funktion, die ein solches Format analysiert, tun?  H√∂chstwahrscheinlich Folgendes: <br><br><ul><li>  Stellen Sie sicher, dass die √ºbergebene Zeichenfolge mit einer √∂ffnenden Klammer beginnt </li><li>  Stellen Sie sicher, dass die √ºbergebene Zeichenfolge mit einem Paar schlie√üender Klammern endet </li><li>  Wenn beide Bedingungen erf√ºllt sind, schneiden Sie die √∂ffnenden und schlie√üenden Klammern ab und √ºbergeben Sie die verbleibenden Funktionen an die Funktion, die die Liste der Paare 'key': 'value' analysiert. </li></ul><br>  Bitte beachten Sie: Die W√∂rter "Funktion zum Parsen dieses Formats" und "Funktion zum Parsen der Liste der Paare 'Schl√ºssel': 'Wert'" wurden angezeigt.  Wir haben zwei Funktionen!  Dies sind genau die Funktionen, die in der klassischen Beschreibung des rekursiven Abstiegsalgorithmus als "Analysefunktionen nichtterminaler Symbole" bezeichnet werden und die besagen, dass "f√ºr jedes nichtterminale Symbol eine eigene Analysefunktion erstellt wird".  Was es tats√§chlich analysiert.  Wir k√∂nnten sie beispielsweise parseJsonObject und parseJsonPairList nennen. <br><br>  Auch jetzt m√ºssen wir darauf achten, dass wir zus√§tzlich zum Konzept des ‚ÄûSeparators‚Äú das Konzept der ‚ÄûPaarklammer‚Äú haben.  Wenn wir eine Zeile zum n√§chsten Trennzeichen schneiden m√∂chten (ein Doppelpunkt zwischen einem Schl√ºssel und einem Wert, ein Komma zwischen den Paaren ‚ÄûSchl√ºssel: Wert‚Äú), hat uns die Funktion cutNextToken gereicht, da wir jetzt nicht nur eine Zeichenfolge, sondern auch ein Objekt verwenden k√∂nnen, das wir ben√∂tigen Funktion ‚ÄûAuf das n√§chste Klammerpaar schneiden‚Äú.  So etwas wie das: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Diese Funktion schneidet ein Fragment von der Linie von der √∂ffnenden Klammer zu dem Paar, das es schlie√üt, unter Ber√ºcksichtigung der Klammern, falls vorhanden.  Nat√ºrlich k√∂nnen Sie nicht auf Klammern beschr√§nkt sein, sondern verwenden eine √§hnliche Funktion, um verschiedene Blockstrukturen abzuschneiden, die verschachtelt werden k√∂nnen: Operatorbl√∂cke beginnen..end, if..endif, for..endfor und √§hnliche. <br><br>  Lassen Sie uns grafisch zeichnen, was mit der Zeichenfolge passieren wird.  T√ºrkisfarbe - Dies bedeutet, dass wir die Linie vorw√§rts zu dem in T√ºrkis hervorgehobenen Symbol scannen, um zu bestimmen, was als n√§chstes zu tun ist.  Violett ist ‚Äûwas abgeschnitten werden soll. In diesem Fall schneiden wir die in Violett hervorgehobenen Fragmente von der Linie ab und analysieren weiter, was davon √ºbrig bleibt. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  Zum Vergleich die Ausgabe des Programms (der Programmtext ist im Anhang angegeben), das diese Zeile analysiert: <br><br>  Demonstration der Analyse der JSON-√§hnlichen Struktur <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  Wir wissen jederzeit, was wir in unserer Eingabezeile erwarten.  Wenn wir die Funktion parseJsonObject eingegeben haben, erwarten wir, dass das Objekt dort an uns √ºbergeben wurde, und wir k√∂nnen dies durch das Vorhandensein der √∂ffnenden und schlie√üenden Klammern am Anfang und am Ende √ºberpr√ºfen.  Wenn wir die Funktion parseJsonPairList eingegeben haben, erwarten wir dort eine Liste von "Schl√ºssel: Wert" -Paaren, und nachdem wir den Schl√ºssel "abgebissen" haben (vor dem Trennzeichen ":"), erwarten wir, dass das n√§chste, was wir "abbei√üen", ist Wert.  Wir k√∂nnen uns das erste Zeichen des Werts ansehen und eine Schlussfolgerung √ºber seinen Typ ziehen (wenn das Apostroph, dann ist der Wert vom Typ "Zeichenfolge", wenn die √∂ffnende geschweifte Klammer der Wert vom Typ "Objekt" ist). <br><br>  Wenn wir also Fragmente von der Zeichenfolge abschneiden, k√∂nnen wir sie mit der Methode der Top-Down-Analyse (rekursiver Abstieg) analysieren.  Und wenn wir analysieren k√∂nnen, k√∂nnen wir das Format analysieren, das wir ben√∂tigen.  Oder erstellen Sie Ihr eigenes Format, das f√ºr uns geeignet ist, und zerlegen Sie es.  Oder erstellen Sie eine dom√§nenspezifische Sprache (Domain Specific Language, DSL) f√ºr unseren speziellen Bereich und entwerfen Sie einen Dolmetscher daf√ºr.  Und um es richtig zu konstruieren, ohne gequ√§lte L√∂sungen auf regul√§ren Ausdr√ºcken oder selbst erstellten Zustandsmaschinen, die f√ºr Programmierer entstehen, die versuchen, ein Problem zu l√∂sen, das analysiert werden muss, aber das Material nicht ganz besitzen. <br><br>  Hier.  Herzlichen Gl√ºckwunsch an alle zum kommenden Sommer und alles Gute, Liebe und funktionale Parser :) <br><br>  Zur weiteren Lekt√ºre: <br><br>  Ideologisch: ein paar lange, aber lesenswerte Artikel von Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reichhaltiges Programmiereressen</a> <br><br>  Ein paar Zitate von dort: <br><blockquote>  Sie lernen entweder Compiler und beginnen, Ihre eigenen DSLs zu schreiben, oder Sie lernen eine bessere Sprache </blockquote><blockquote>  Die erste gro√üe Phase der Kompilierungspipeline ist das Parsen </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Pinocchio-Problem</a> <br><br>  Zitat von dort: <br><blockquote>  Typumwandlungen, Eingrenzen und Erweitern von Konvertierungen, Friend-Funktionen zum Umgehen des Standardklassenschutzes, <b>F√ºllen von Minisprachen in Zeichenfolgen und Parsen von Hand</b> . Es gibt Dutzende von M√∂glichkeiten, die Typsysteme in Java und C ++ zu umgehen, und Programmierer verwenden sie st√§ndig , weil sie (wenig wissen sie) tats√§chlich versuchen, Software zu erstellen, nicht Hardware. </blockquote>  Technisch: zwei Artikel zum Parsen √ºber den Unterschied zwischen LL- und LR-Ans√§tzen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LL und LR Parsing entmystifiziert</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LL und LR im Kontext: Warum Parsing-Tools schwierig sind</a> <br><br>  Und noch tiefer in das Thema: Wie schreibe ich einen Lisp-Interpreter in C ++? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lisp-Interpreter in 90 Zeilen C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Anwendung.</b>  <b class="spoiler_title">Beispielcode (Java), der den im Artikel beschriebenen Analysator implementiert:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412905/">https://habr.com/ru/post/de412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412895/index.html">Vesta Matveeva: Der Kampf gegen Cyberkriminalit√§t ist eine moralische Entscheidung</a></li>
<li><a href="../de412897/index.html">√úberwachung von Atlassian-Produkten mit Prometheus</a></li>
<li><a href="../de412899/index.html">Wochenendlesung: 30 Materialien zu Ton, der Geschichte der Audiomarken und der Filmindustrie</a></li>
<li><a href="../de412901/index.html">√úberwachung und Kubernetes (R√ºckblick und Videobericht)</a></li>
<li><a href="../de412903/index.html">Wie wir Habr gemalt haben</a></li>
<li><a href="../de412911/index.html">Entwickler sprechen √ºber Funktionen, die aus Spielen herausgeschnitten wurden</a></li>
<li><a href="../de412913/index.html">"Baikal-T1" wurde f√ºr 3990 Rubel verkauft</a></li>
<li><a href="../de412915/index.html">Bestimmung der Gasdichte aus den Ergebnissen der Druck- und Temperaturmessung mit Arduino-Sensoren</a></li>
<li><a href="../de412917/index.html">Die russische Post wird beginnen, Robotersortierer einzusetzen. Wie es funktionieren wird</a></li>
<li><a href="../de412921/index.html">Monero-Netzwerksignaturen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>