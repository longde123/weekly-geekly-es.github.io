<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ğŸ¾ ğŸ…ğŸ¿ ğŸ‘¨ğŸ½ Cara meluncurkan prototipe ML dalam satu hari. Laporkan Yandex.Taxi ğŸŒªï¸ ğŸ£ ğŸ³ï¸â€ğŸŒˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembelajaran mesin digunakan di seluruh siklus pemesanan mobil Yandex.Taxi, dan jumlah komponen layanan yang bekerja berkat ML terus berkembang. Untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara meluncurkan prototipe ML dalam satu hari. Laporkan Yandex.Taxi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/447186/">  Pembelajaran mesin digunakan di seluruh siklus pemesanan mobil Yandex.Taxi, dan jumlah komponen layanan yang bekerja berkat ML terus berkembang.  Untuk membangunnya secara seragam, kami membutuhkan proses terpisah.  Roman Khalkachev, Kepala Pembelajaran Mesin dan Layanan Analisis Data, berbicara tentang preprocessing data, penggunaan model dalam produksi, layanan prototyping dan alat terkait. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IDHKt1N2IvU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Menurut pendapat saya, beberapa hal baru jauh lebih mudah dipahami ketika mereka diberitahu tentang beberapa contoh sederhana.  Karena itu, agar laporannya tidak kering, saya memutuskan untuk membicarakan salah satu tugas yang sedang kami selesaikan.  Menggunakan teladannya, saya akan menunjukkan mengapa kita bertindak dengan cara ini. <br><br>  Mari kita rumuskan masalahnya.  Ada pengguna taksi yang perlu naik dari titik A ke titik B, dan ada pengemudi yang siap untuk jumlah tertentu untuk mengantarkan pengguna ini dari titik A ke titik B. Pengguna memiliki beberapa kondisi di mana dia berada.  Dia memanggil taksi, memilih titik A, titik B, ongkos, dan sebagainya, melakukan pendaratan taksi, menumpang, dan akhirnya melakukan pendaratan.  Hari ini saya ingin berbicara tentang masuk ke mobil dan masalah yang mungkin timbul. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/i4/wx/-w/i4wx-wctuoekqqjixbj8yud2tsg.jpeg"><br><br>  Biasanya, masalah-masalah ini berkaitan dengan fakta bahwa seseorang perlu memilih tempat di mana taksi harus datang.  Dan di sini ada sejumlah kesulitan.  Kesulitan-kesulitan ini terkait dengan empat hal yang telah saya daftarkan pada slide. <br><br><img src="https://habrastorage.org/webt/vn/ua/og/vnuaogglei7as1bbojryct6pguy.jpeg"><br><br>  Pertama-tama, lokasi mungkin tidak familier bagi pengguna.  Sebagai contoh, Anda bisa membayangkan diri Anda yang datang ke beberapa pusat perbelanjaan besar, di mana Anda tidak sering berkunjung.  Anda ingin pergi, dan Anda tidak benar-benar tahu di mana Anda dapat memanggil taksi di sini, di mana mobil dapat menelepon, tetapi di mana tidak bisa, misalnya, karena penghalang.  Ada masalah dengan kenyataan bahwa di beberapa tempat ada banyak orang, banyak mobil dan sulit bagi Anda untuk menemukan mobil Anda.  Ada tempat-tempat di mana orang biasanya masuk ke dalam mobil, lebih mudah untuk sampai ke sana.  Dan Anda mungkin tidak tahu, berada di tempat baru, belum tentu di pusat perbelanjaan, di mana tepatnya mendarat.  Kesulitan dapat dihubungkan dengan fakta bahwa pengemudi tidak dapat mengemudi ke tempat Anda memanggil taksi: ia dilarang bepergian, ada beberapa pintu keluar besar dari pusat perbelanjaan, di seberangnya Anda tidak dapat berhenti, dll. <br><br>  Di sisi lain, Anda mungkin memiliki masalah sebagai pengguna.  Sopir tiba, semuanya baik-baik saja, tetapi Anda tidak nyaman untuk duduk, karena semua orang menggali.  Anda meminta pengemudi untuk mengemudi di tempat lain.  Ada alasan lain. <br><br>  Contoh paling ilustratif, intisari dari semua hal di atas, adalah bandara, di mana hampir semuanya dilakukan.  Bahkan jika Anda sering terbang dari Sheremetyevo, itu masih merupakan lokasi yang asing bagi Anda, karena banyak hal sering berubah di sana.  Ada banyak orang, banyak mobil, ada tempat yang nyaman untuk pendaratan, ada yang tidak nyaman, tetapi sebagai aturan, tidak ada dari kita yang ingat tentang ini. <br><br><img src="https://habrastorage.org/webt/nb/e_/ab/nbe_abma_ki1jpgwfl1fr-mjqka.jpeg"><br><br>  Solusinya dibaca dari judul slide.  Izinkan kami merekomendasikan kepada pengguna beberapa tempat di mana, menurut pendapat kami, nyaman untuk mendarat.  Pikiran itu tampak jelas, tetapi ada banyak nuansa di sini. <br><br>  Sebagai permulaan, "nyaman" adalah konsep subjektif.  Tampaknya sebelum menyelesaikan masalah, perlu dirumuskan beberapa kriteria untuk fakta bahwa masalah akan diselesaikan dengan benar.  Kami telah merumuskan tiga yang utama untuk diri kami sendiri.  Kriteria pertama adalah seperti dalam tugas rekomendasi: mungkin, rekomendasi bagus jika digunakan.  Jika kami menunjukkan poin dari mana pengguna akan benar-benar pergi - ini mungkin poin yang baik.  Tapi ini, tentu saja, tidak semuanya, karena Anda dapat belajar untuk merekomendasikan sesuatu, menunjukkannya, mendorong pengguna untuk menggunakannya, tetapi Anda tidak bisa mendapatkan keuntungan nyata (kami tidak akan mendapatkan sebagai sistem, atau pengguna, atau pengemudi).  Karena itu, sangat penting untuk melihat metrik lain.  Kami telah memilih dua. <br><br>  Jika kami memberi tahu Anda tentang tempat pendaratan yang dapat dengan mudah dikendarai oleh pengemudi, maka waktu pengiriman kendaraan harus dikurangi.  Di sisi lain, jika lebih mudah bagi pengguna untuk menemukan mobil di tempat ini, lebih mudah untuk mendarat, maka waktu tunggu pengemudi oleh pengemudi harus dikurangi.  Ini adalah beberapa hipotesis kami, yang kami terima begitu saja, dan ini adalah beberapa metrik yang kami lihat ketika kami membuat rekomendasi ini.  Tapi tentu saja, ini bukan satu-satunya metrik untuk dilihat.  Anda bisa menghasilkan selusin lagi.  Saya pikir Anda masing-masing dapat membuat seratus metrik ini. <br><br>  Berikut ini beberapa contoh lainnya.  Ini mungkin proporsi pembatalan sebelum perjalanan.  Secara teori, itu harus berkurang jika lebih mudah bagi pengguna untuk mendarat.  Secara konvensional, ini adalah panggilan saat pengguna memanggil pengemudi yang berusaha menemukannya, atau, sebaliknya, pengemudi memanggil pengguna sebelum perjalanan dimulai.  Seruan ini mendukung, dan bersama selusin lainnya. <br><br>  Kami telah merumuskan masalahnya.  Kami secara kasar memahami kriteria bahwa kami dapat menyelesaikan masalah ini.  Sekarang mari kita pikirkan tentang bagaimana menyelesaikan masalah ini.  Hal pertama yang terlintas dalam pikiran: mari kita merekomendasikan titik pendaratan yang terbukti dan dapat dimengerti tersebut.  Di sini, di slide adalah contoh dari Pusat Perbelanjaan Eropa.  Dan kami tahu pasti bahwa Anda dapat berkendara hingga keluar dari pusat perbelanjaan ini, dan ini adalah semacam tengara berkat pengguna yang dapat menemukan pengemudi.  Mungkin organisasi apa pun.  Ada contoh dengan ABC of Taste di beberapa pusat perbelanjaan.  Menurut pendapat saya, ini adalah Yerevan Plaza.  Ini juga semacam pedoman bagi pengguna dan pengemudi, yang kami ketahui dapat Anda kendarai di sana. <br><br><img src="https://habrastorage.org/webt/ym/ex/lu/ymexlupptviqlhyi4otvpouyjuq.jpeg"><br><br>  Ini mungkin landmark di bandara yang saya bicarakan.  Secara konvensional, ada semacam tiang di Sheremetyevo dengan angka.  Lebih mudah untuk memanggil taksi dan masuk ke mobil.  Solusi yang bagus, tetapi memiliki minus sehingga tidak terlalu skalabel.  Kami memiliki banyak negara, ratusan kota, sejumlah besar pusat perbelanjaan yang berbeda, bandara, persimpangan yang sulit, tempat-tempat asing yang membuat poin-poin ini sulit untuk dibuat secara manual, dan mempertahankannya tetap terkini bahkan lebih sulit.  Di sinilah datang ke bantuan kami apa yang keras disebut "kecerdasan buatan."  Saya lebih suka menyebutnya data mining atau pembelajaran mesin. <br><br>  Pembelajaran mesin membutuhkan beberapa jenis data, dan kami benar-benar memiliki data itu.  Cara lain untuk memecahkan masalah secara otomatis adalah dengan menggunakan data ini.  Gagasan tingkat tinggi adalah bahwa kita memiliki data tentang GPS, log aplikasi, dan ada grafik jalan.  Dan kita dapat memahami di mana pengguna benar-benar masuk ke mobil.  Bukan titik di mana mereka memanggil mobil, tetapi di mana mereka mendarat.  Dan berdasarkan ini, lakukan sesuatu seperti itu. <br><br><img src="https://habrastorage.org/webt/ps/be/vl/psbevlef58dytmd_75_7iqhukts.jpeg"><br><br>  Ini sudah menerima poin secara otomatis untuk pusat bisnis Aurora, tempat tim Yandex.Taxi kami saat ini duduk. <br><br>  Saya berbicara tingkat tinggi tentang tugas kami.  Sekarang mari kita bicara lebih rinci tentang tahap apa dari solusi untuk masalah ini terdiri.  Jelas bahwa ada tahap persiapan data. <br><br><img src="https://habrastorage.org/webt/v7/mt/tw/v7mttwhglgsfcylredz1spr1oli.jpeg"><br><br>  Data apa yang kita miliki?  Pertama, kami memiliki data GPS dari pengguna kami dan data GPS dari driver kami.  Ketika mereka menggunakan aplikasi kami, kami tahu perkiraan lokasi pengguna.  Jelas bahwa GPS memiliki kesalahan besar, di wilayah 13-15 meter, namun demikian, ada sesuatu.  Kedua, kami memiliki informasi yang terkandung dalam log aplikasi tentang kapan pengemudi beralih dari status "Saya menunggu pengguna" ke status "Saya mengambil pengguna".  Dapat diasumsikan bahwa sekitar saat ini pengemudi menunggu pengguna, pengguna masuk ke mobil, dan mereka pergi.  Di sekitar tempat ini, pendaratan dilakukan.  Dan kami memiliki grafik jalan.  Grafik jalan tidak hanya seperangkat tepi, jalan, tetapi juga meta-informasi tambahan: hambatan, informasi tentang parkir, dll. Berdasarkan data ini, Anda sudah bisa mendapatkan semacam titik otomatis. <br><br>  Ini adalah sumber data.  Dan di pintu keluar, kami menginginkan dua hal.  Ini adalah beberapa yang disebut kandidat titik pendaratan.  Bagaimana mereka terjadi?  Sangat disayangkan bahwa tidak mungkin untuk menampilkan video.  Berikut ini terjadi kira-kira.  Kami memiliki banyak titik GPS di mana kami tahu bahwa pengemudi telah beralih dari status "Menunggu penumpang" ke status "Ayo pergi."  Secara kondisional, kita dapat menarik mereka ke grafik, yaitu, memproyeksikannya ke grafik jalan, karena, sebagai suatu peraturan, mobil mulai bergerak dari suatu jalan.  Pada grafik ini, lakukan semacam pengelompokan titik-titik ini.  Dan untuk mendapatkan sejumlah besar kandidat - ini adalah tempat di mana beberapa pengguna masuk ke mobil, dan itu normal, nyaman bagi mereka.  Bukan di mana mereka memanggil, tetapi di mana mereka akhirnya duduk. <br><br>  Setelah itu, ketika kita memiliki banyak kandidat dan kita memiliki beberapa pengguna online, kita tahu lokasinya, jadi dia membuka aplikasi dan ingin memanggil taksi, maka kita dapat memilih lima terbaik dari sejumlah besar kandidat dan menunjukkan kepada mereka.  Lima terbaik ditentukan oleh beberapa model pembelajaran mesin, yang belajar menentukan peringkat semua kandidat berdasarkan kemungkinan bahwa pengguna saat ini, dengan mempertimbangkan lokasi dan riwayat perjalanannya, paling mudah untuk pergi.  Dan kira-kira dengan cara ini kita dapat secara otomatis menghasilkan poin-poin ini.  Selain itu, jika pada suatu titik mereka secara kondisional menggali di suatu tempat, yaitu, menjadi tidak nyaman untuk memanggil taksi, atau di suatu tempat mereka memasang tanda yang melarang berhenti, dan pengemudi dan pengguna benar-benar berhenti mendarat di tempat ini, maka di beberapa saat algoritma akan memahami ini, dan data akan diperbarui. <br><br><img src="https://habrastorage.org/webt/se/90/qi/se90qiau_vugtxbwmlmw5s6dhbs.jpeg"><br><br>  Ini kira-kira diagram blok bagaimana kita mempersiapkan data.  Dengan demikian, ini cukup standar, seperti pada pipa pembelajaran mesin.  Ada persiapan data, ada generasi kandidat menurut algoritma, saya mengatakan versi yang disederhanakan.  Kami menyimpan kandidat ini dalam database tertentu.  Setelah itu, kami menyiapkan beberapa kumpulan untuk pelatihan (sampel pelatihan), di mana ada, secara kondisional, pengguna, waktu, meta-informasi, satu set kandidat, dan diketahui dari titik mana pengguna akhirnya pergi.  Pada ini kita melatih model klasifikasi.  Dan kemudian, berdasarkan prediksi probabilitas, kami memberi peringkat pada kandidat.  Saat model siap, kami mengunggahnya ke beberapa cloud, di mana ia tersimpan dengan baik. <br><br><img src="https://habrastorage.org/webt/ou/0k/5k/ou0k5kbozlb4w_ypk6m5o2djp3y.jpeg"><br><br>  Alat apa yang kami gunakan dalam menyiapkan data?  Pada dasarnya, semua persiapan data yang kami tulis dalam Python, pada tumpukan Python: ini adalah standar NumPy, Panda, Scikit-learn, dll. Kami memiliki banyak data.  Kami memiliki jutaan perjalanan per bulan.  Banyak data tentang GPS, tentang trek driver, log aplikasi, jadi kita perlu memproses semuanya di cluster.  Untuk melakukan ini, kami menggunakan MapReduce versi intra-Yandex kami, yang disebut YT, dan ada perpustakaan yang ditulis dengan Python, yang memungkinkan beberapa pemetaan dan reduksi diluncurkan, dan untuk melakukan beberapa perhitungan pada sekelompok besar. <br><br>  Akhirnya, ketika pipeline sudah siap, kita perlu mengotomatiskannya agar datanya mutakhir, dan untuk ini kita menggunakan hal seperti Nirvana dan Hitman.  Ini juga pengembangan intra-Yandex.  Nirvana adalah kerangka kerja manajemen komputasi cluster.  Bahkan, dia tahu bagaimana menjalankan hampir semua program, menjadi toleran terhadap kesalahan, menjadi lintas DC (00:14:53).  Dan jika ada sesuatu yang jatuh, dia tahu bagaimana me-restart-nya, untuk membuat peluncuran atas kejadian apa pun.  dll. <br><br><img src="https://habrastorage.org/webt/wy/c3/9z/wyc39zj9qbomfd5ybc-ifszugde.jpeg"><br><br>  Ini kira-kira seperti apa antarmuka web cluster MapReduce kami.  Dapat dilihat di sini bahwa kita memiliki banyak mesin, seperti node di mana perhitungan dilakukan. <br><br><img src="https://habrastorage.org/webt/gl/wd/p4/glwdp4bccgeodj-xzpfk3xyjuu8.jpeg"><br><br>  Jadi dalam antarmuka web proses khas dari beberapa jenis preprocessing data dan pelatihan model terlihat.  Ini adalah grafik ketergantungan.  Ketergantungan seperti data, ketika satu bagian (satu kubus) sedang menunggu data dari kubus lain;  dan ketergantungan logis (pertama kami menyiapkan semua data, kemudian memulai pelatihan).  Ini adalah semacam sistem otomatis.  Untuk semua ini, kami biasanya menggunakan Python. <br><br>  Kami merumuskan masalah, merumuskan kriteria keberhasilan, belajar bagaimana menyelesaikannya secara offline, bahkan membuat semacam model, dan tampaknya berfungsi sesuai dengan beberapa metrik offline - itu benar-benar memprediksi titik di mana pengguna meninggalkan dan menemukan titik-titik tersebut yang, tampaknya, akan mengurangi waktu tunggu dan pengiriman mobil. <br><br><img src="https://habrastorage.org/webt/hv/aw/bg/hvawbgrigssxzje4wzv4pgbv72a.jpeg"><br><br>  Mari kita coba model ini, gunakan data ini.  Untuk melakukan ini, bayangkan apa layanan Yandex.Taxi. <br><br>  Diagram yang sangat dangkal terlihat seperti ini.  Ada pengguna, mereka memiliki aplikasi, dan ada driver, mereka juga memiliki aplikasi yang disebut "Taximeter".  Aplikasi ini entah bagaimana berkomunikasi dengan backend, dan backend adalah seperangkat layanan microsoft yang berkomunikasi satu sama lain - Ilya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan</a> hal ini.  Salah satu layanan microser adalah layanan kami, tim kami melakukannya, disebut ML sebagai Layanan, MLaaS. <br><br><img src="https://habrastorage.org/webt/7r/wh/8z/7rwh8zsyfisoucl0_xsvg-u39rg.jpeg"><br><br>  Yang perlu Anda ketahui tentang dia adalah MLaaS yang ditulis dalam C ++, berdasarkan apa yang disebut Fastcgi Daemon.  Ini adalah pustaka sumber terbuka, yang, secara kasar, adalah kerangka kerja untuk menulis server web yang bisa mendapatkan dan mengirim permintaan, semuanya standar.  Itu pernah ditulis dalam Yandex, ditata dalam sumber terbuka.  Kami menggunakan versi yang dicelupkan.  Apa yang bisa dilakukan layanan ini?  Dia tahu cara bekerja dengan model: menerapkannya, menyimpannya di rumah dan kadang-kadang memperbarui, pergi ke cloud yang luar biasa ini, di mana model diperbarui secara berkala, disimpan, dan unduh. <br><br>  Setiap fungsionalitas, misalnya, titik pendaratan ini - di dalamnya kami menyebutnya titik penjemputan - atau, misalnya, tips poin B yang dibicarakan Ilya dan terus-menerus rusak dalam laporan sebelumnya, masing-masing fungsi tersebut, di mana ada semacam pembelajaran mesin, sesuai dengan handler, yang menyimpan logika penerimaan permintaan, menghasilkan faktor pembelajaran mesin, dan menerapkan model, dan menghasilkan respons.  Tentu saja, layanan ini tidak terisolasi, dapat pergi ke beberapa sumber data tambahan, basis data, dan beberapa layanan Microsoft lainnya. <br><br><img src="https://habrastorage.org/webt/g2/st/81/g2st815sxi1r0q1wy6waaoqrxdc.jpeg"><br><br>  Beginilah cara mengaturnya, ia memiliki arsitektur yang agak sederhana.  Saya tidak ingin membahas slide ini secara terperinci, saya hanya ingin mengatakan bahwa, secara konvensional, arsitekturnya sangat sederhana.  Permintaan tiba, ada beberapa pabrik model, yang terkadang mengunduh model-model ini dari cloud.  Dalam memori mereka disimpan dalam satu salinan.  Untuk setiap permintaan, objek model yang agak ringan dibuat, yang mengekstrak fitur, berlaku, dan menghasilkan respons. <br><br><img src="https://habrastorage.org/webt/y3/sq/ru/y3sqruaisy4qicdx5iyvbgrq1ew.jpeg"><br><br>  Tapi apa yang kita miliki untuk saat ini?  Saya sudah memberi tahu Anda bahwa kami memiliki persiapan data, pelatihan, berbagai studi, eksperimen, dan semua ini ditulis dalam Python Stack, dan ada beberapa produksi yang ditulis dalam C ++, hanya karena kami memiliki tuntutan besar pada efisiensi dan produktivitas.  Ketika Anda hidup dalam ekosistem seperti itu, dua masalah muncul. <br><br>  Pertama-tama, ini adalah masalah eksperimen.  Sebagai contoh, seorang ilmuwan data yang bekerja di tim kami mendapat ide.  Jika Anda menjalankan semacam algoritma pengelompokan atau klasifikasi dengan parameter yang sedikit berbeda, Anda dapat mencapai kualitas yang lebih baik.  Dia mencoba menguji hipotesisnya secara offline, membangun ke dalam proses Python kami, menghitungnya, dan ternyata benar-benar terjadi.  Dan sekarang dia ingin percobaan AB, yaitu, bagian dari pengguna untuk menunjukkan algoritma baru dan mengukur beberapa metrik yang sudah online: apakah waktu benar-benar turun, tunggu, penggunaan meningkat.  Untuk melakukan ini, ia secara kondisional memiliki lima versi algoritmanya, di mana ia percaya, yang offline memberikan kualitas yang baik: diimplementasikan dalam C ++ dan melakukan percobaan AB.  Dan setelah percobaan AB ini, mungkin kelima-duanya akan menuju ke memo, yaitu, kualitas mereka secara daring akan menjadi lebih buruk daripada offline, yaitu, lebih buruk daripada dalam produksi.  Artinya, proses eksperimen memakan waktu lama karena fakta bahwa, secara kondisional, dua bahasa berbeda, dua teknologi berbeda. <br><br>  Ini untuk fitur yang ada.  Dan ada yang baru.  Dulu titik pengambilan ini juga merupakan ide yang ingin saya periksa dengan cepat.  Jangan menghabiskan dua bulan pembangunan - disarankan untuk mendapatkan sesuatu dalam tiga minggu.  Untuk membuat prototipe semacam itu cukup melelahkan.  Pertama, tulis dengan Python ekstraksi fitur, hanya karena nyaman - bergerak cepat, seperti kata mereka.  Anda dapat membangun prototipe apa pun dengan Python, ada banyak pustaka untuk analisis data.  Anda bereksperimen di laptop Anda, dan sekarang Anda ingin memeriksa pengguna.  Dan untuk membuat prototipe ternyata cukup sulit.  Kami sampai pada kesimpulan bahwa kami memerlukan beberapa layanan tambahan untuk merakit prototipe semacam itu dengan agak cepat - kondisional, dalam seminggu atau bahkan dalam sehari - dan juga untuk melakukan percobaan AB. <br><br><img src="https://habrastorage.org/webt/zs/yf/kz/zsyfkzkj28m7n4gbzdgl8hmxmaq.jpeg"><br><br>  Kami membuat layanan seperti itu, menyebutnya PyMLaaS.  Seperti apa dia?  Sebenarnya, ini adalah analog lengkap MLaaS, tentang yang saya bicarakan sebelumnya, tetapi ditulis dalam Python berdasarkan Flask, nginx dan Gunicorn.  Arsitekturnya cukup sederhana, sama seperti MLaaS, tetapi ada peluang untuk dengan cepat menggali beberapa prototipe dari eksperimen offline Anda.  Selain itu, kami mengatur proxy seperti itu pada tingkat nginx, sehingga, secara kondisional, kami memiliki kesempatan untuk meneruskan sebagian beban dari MLaaS ke PyMLaaS dan dengan demikian bereksperimen. <br><br><img src="https://habrastorage.org/webt/iw/n9/dm/iwn9dm9njjt7nhav5gpm1szszpc.jpeg"><br><br>  Artinya, kami memindahkan beberapa parameter dan ingin memeriksa bagaimana ini memengaruhi pengguna.  Kami memulai 5% dari beban pada PyMLaaS, dan kami akan melihat apa yang terjadi dalam percobaan.  Akhirnya, nyaman untuk membuat prototipe.  Saya membuat prototipe dari beberapa fitur baru, melihatnya di PyMLaaS dan Anda dapat segera mengujinya dalam produksi. <br><br>  Kami sangat menyukainya sehingga gagasan itu muncul - mengapa tidak menggunakannya sepanjang waktu?  Karena, secara kondisional, ada fitur yang membutuhkan beban besar, 1000 RPS, kebutuhan memori besar.  Saya ingin memiliki paralelisme yang cukup fleksibel.  Tetapi untuk beberapa fitur, untuk beberapa produk atau layanan yang tidak memiliki tuntutan besar pada beban, kinerja, RPS, dan sebagainya, kami cukup berhasil menggunakan layanan ini. <br><br><img src="https://habrastorage.org/webt/6g/ss/t-/6gsst-y5wpmuipwn286nxehsd70.jpeg"><br><br>  Untuk meringkas.         ,    .   .           .    ,  - , ,  ,   -,  - .       -   PyMLaaS,  AB-,      .   ,     MLaaS,    ,       . <br><br>     pickup points â€”   .           .    ,    .   30%     ,   .    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447186/">https://habr.com/ru/post/id447186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447174/index.html">Mitos Kelaparan Personel atau Aturan Dasar untuk Lowongan Kerja</a></li>
<li><a href="../id447178/index.html">5 peluang efektif untuk menggunakan teknologi proses penambangan</a></li>
<li><a href="../id447180/index.html">Ikhtisar dan Perbandingan Pengontrol Ingress untuk Kubernetes</a></li>
<li><a href="../id447182/index.html">Sistem Operasi: Tiga Potongan Mudah. Bagian 3: API Proses (terjemahan)</a></li>
<li><a href="../id447184/index.html">Apa itu Initial Exchange Offering (IEO) dan bagaimana perbedaannya dengan ICO?</a></li>
<li><a href="../id447190/index.html">Prediksi dari ahli matematika. Kami menganalisis metode utama untuk mendeteksi anomali</a></li>
<li><a href="../id447192/index.html">Apa peran yang bisa dimainkan oleh teknologi dalam seni kuno pencampuran rempah?</a></li>
<li><a href="../id447194/index.html">Fitur Rendering di Metro: Exodus c raytracing</a></li>
<li><a href="../id447196/index.html">7. Periksa Titik Memulai R80.20. Kontrol akses</a></li>
<li><a href="../id447198/index.html">Misi Lunar "Bereshit": pendaratan-kecelakaan-jatuh di bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>