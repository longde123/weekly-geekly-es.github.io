<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üëàüèº üíå Pruebas o tipos ‚ùî üë¥üèª üï¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr El otro d√≠a estaba buscando c√≥mo hacer algo en Idris, y encontr√© una buena publicaci√≥n, una traducci√≥n gratuita que parece bastante apropiad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas o tipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Hola Habr</em>  <em>El otro d√≠a estaba buscando c√≥mo hacer algo en Idris, y encontr√© una buena publicaci√≥n, una traducci√≥n gratuita que parece bastante apropiada.</em>  <em>Libertades y mordazas cuando sea necesario, denotar√© "aqu√≠ por tales garabatos al principio y al final".</em> </p><br><p>  ¬øCu√°ndo usar pruebas y cu√°ndo - tipos?  ¬øQu√© informaci√≥n y qu√© garant√≠as recibimos a cambio de nuestros esfuerzos para escribirlas? </p><br><p>  Veremos un ejemplo simple y ligeramente inventado expresado en Python, C, Haskell e Idris.  Tambi√©n veremos qu√© se puede decir sobre la implementaci√≥n sin ning√∫n conocimiento adicional al respecto, en cada caso. </p><br><p> No tomaremos en cuenta las diversas puertas traseras que nos permiten violar expl√≠citamente las garant√≠as del lenguaje (por ejemplo, extensiones C, <code>unsafePerformIO</code> inseguro en Haskell, conversiones de tipo inseguras), de lo contrario ser√≠a imposible sacar conclusiones, y esta publicaci√≥n ser√≠a bastante corta.  "Adem√°s, el mismo Haskell tiene un subconjunto de Safe Haskell que proh√≠be expl√≠cita y transitivamente el uso de estos y otros trucos que podr√≠an violar la integridad del lenguaje". </p><a name="habracut"></a><br><h2>  Especificaci√≥n </h2><br><blockquote>  Deja que se d√© una lista y alg√∫n significado.  Es necesario devolver el √≠ndice de este valor en la lista o indicar que este valor no est√° en la lista. </blockquote><p>  La implementaci√≥n de esta especificaci√≥n es trivial, por lo que es natural preguntar, y aqu√≠ hay generalmente pruebas o tipos.  Sin embargo, esas propiedades y m√©todos de razonamiento, de los que hablaremos hoy, son aplicables a un c√≥digo mucho m√°s complejo.  Deje que la implementaci√≥n tome diez mil l√≠neas de c√≥digo de espagueti ilegible, si ayuda a ver su utilidad. </p><br><h2>  Pit√≥n </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Notamos de inmediato que no estamos interesados ‚Äã‚Äãen las propiedades no controladas ‚ü¶y sem√°nticas que no afectan a un programa como la denominaci√≥n de variables y la documentaci√≥n de texto, por lo que intencionalmente no escrib√≠ c√≥digo que ayude a la percepci√≥n.  Solo nos interesa el hecho de que, sujeto a pasar las pruebas y los controles de tipo, <em>no puede ser falso</em> . </p><br><p>  En el c√≥digo anterior, pr√°cticamente no hay informaci√≥n √∫til m√°s que el hecho de que tenemos una funci√≥n que toma dos argumentos.  Esta funci√≥n tambi√©n puede encontrar el √≠ndice del valor en la lista, o puede enviar una carta insultante a su abuela. </p><br><p>  <strong>An√°lisis</strong> </p><br><p>  No solo obtenemos c√≥digo fr√°gil sin pruebas y tipos, sino que nuestra √∫nica forma de entender lo que hace una funci√≥n es la documentaci√≥n.  Y dado que la documentaci√≥n es verificada por personas, no por m√°quinas, puede resultar desactualizada initially o inicialmente incorrecta‚üß. </p><br><ul><li>  <strong>La documentaci√≥n</strong> <br><ul><li>  ‚úó Conocemos el comportamiento esperado <br>  No tenemos nada que decirnos sobre el comportamiento de esta funci√≥n.  Odias a tu abuela.  Eres un monstruo </li></ul></li><li>  <strong>Garant√≠as</strong> <br><ul><li>  ‚úì Seguridad de memoria <br>  Python es un lenguaje de recolecci√≥n de basura que elimina esta preocupaci√≥n de nosotros.  "Sin embargo, hasta donde yo s√©, nada le impide extraer bibliotecas inseguras o C FFI dentro de esta funci√≥n". </li></ul></li></ul><br><h2>  Python con pruebas </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Ahora sabemos que nuestra funci√≥n funciona, y si falta el elemento, ¬øel resultado es <code>None</code> ? </p><br><p>  Pues no.  Este es solo un ejemplo.  Desafortunadamente, el alcance de nuestra funci√≥n es infinito, y ning√∫n n√∫mero de ejemplos puede probar el funcionamiento correcto de nuestra funci√≥n.  M√°s pruebas: m√°s confianza, pero ninguna cantidad de pruebas resolver√° todas las dudas. </p><br><p>  La posibilidad de que esta funci√≥n devuelva <code>None</code> para <code>4</code> , pero no para <code>5</code> , suena m√°s bien delirante, y en este caso particular, lo m√°s probable es que no tenga sentido.  Podemos estar satisfechos con nuestro nivel de fe y detenernos en un cierto n√∫mero de ejemplos.  Pero, de nuevo, la publicaci√≥n ser√° breve, as√≠ que imaginemos que la implementaci√≥n no es tan obvia. </p><br><p>  Como las pruebas no pueden probar algo en el caso general, sino que solo muestran el comportamiento con ejemplos espec√≠ficos, las pruebas <em>no pueden</em> mostrar la ausencia de errores.  Por ejemplo, no existe una prueba que muestre que nuestra funci√≥n nunca arroja una excepci√≥n o nunca ingresa al ciclo eterno, o no contiene enlaces no v√°lidos.  Esto solo puede ser un an√°lisis est√°tico. </p><br><p>  Sin embargo, incluso si los ejemplos no son muy buenos en el papel de la evidencia, al menos constituyen una buena documentaci√≥n.  De estos dos ejemplos podemos derivar la especificaci√≥n completa full bajo algunos supuestos adicionales a priori: esos dos ejemplos tambi√©n satisfacen, por ejemplo, la "contraespecificaci√≥n" "encontrar el elemento en la matriz y devolver el anterior, si lo hay", lo que me llev√≥ diez segundos para inventar . </p><br><p>  <strong>An√°lisis</strong> </p><br><p>  Aunque las pruebas pueden mostrar c√≥mo usar nuestra funci√≥n, y tambi√©n dan un poco de confianza de que esta funci√≥n funciona correctamente con al menos algunos ejemplos, no pueden <em>probar</em> nada sobre nuestro c√≥digo en el caso general.  Desafortunadamente, esto significa que las pruebas solo ayudan parcialmente a evitar errores. </p><br><ul><li>  <strong>La documentaci√≥n</strong> <br><ul><li>  ‚úì <strong>Tenemos un ejemplo de uso</strong> </li><li>  ‚úì <strong>Conocemos algunas clases de valores que se procesar√°n correctamente</strong> </li><li>  ‚úó Conocemos todos los tipos de valores que se procesar√°n correctamente <br>  No tenemos restricciones sobre los tipos de argumentos, por lo que a pesar de la existencia de ejemplos de lo que puede manejar la funci√≥n, no sabemos qu√© tipos no se han probado. </li><li>  ‚úó Conocemos el comportamiento esperado <br>  ‚ü¶El autor del art√≠culo original marc√≥ aqu√≠, me permitir√© poner una cruz, dado el comentario anterior‚üß </li></ul></li><li>  <strong>Especificaci√≥n</strong> <br><ul><li>  ‚úì <strong>Funciona en al menos un caso</strong> </li><li>  ‚úó El √≠ndice devuelto siempre es un √≠ndice v√°lido </li><li>  ‚úó El √≠ndice devuelto siempre indica un valor adecuado </li><li>  ‚úó El elemento faltante siempre devuelve <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Errores comunes</strong> <br><ul><li>  ‚úó Sin errores tipogr√°ficos o nombres incorrectos <br>  El an√°lisis est√°tico puede ayudar, pero dado que Python es un lenguaje din√°mico con la capacidad de anular varias cosas en tiempo de ejecuci√≥n, nunca podemos probar que no haya errores. <br>  En particular, puede ser muy dif√≠cil o imposible determinar si el nombre del m√©todo es correcto, ya que la validez de la llamada al m√©todo depende del tipo de tiempo de ejecuci√≥n del objeto en el que se realiza la llamada. </li><li>  ‚úó No <code>null</code> inesperado </li><li>  ‚úó El caso de error siempre se maneja <br>  En mi experiencia, esta es una de las fuentes m√°s comunes de errores: en nuestro ejemplo, la funci√≥n devuelve <code>None</code> en caso de que falte un elemento, pero el c√≥digo que usa esta funci√≥n puede suponer, por ejemplo, que siempre devolver√° un n√∫mero.  Adem√°s, esto tambi√©n puede conducir a una excepci√≥n no controlada. </li></ul></li><li>  <strong>Garant√≠as</strong> <br><ul><li>  ‚úì Seguridad de memoria </li><li>  ‚úó La funci√≥n no se puede llamar con el tipo incorrecto </li><li>  ‚úó Sin efectos secundarios </li><li>  ‚úó Sin excepciones </li><li>  ‚úó Sin errores </li><li>  ‚úó Sin ciclos perpetuos </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Si no est√° familiarizado con la sintaxis: esta es la definici√≥n de una funci√≥n <code>x</code> con los par√°metros <code>y</code> y <code>z</code> .  En Haskell, puede omitir tipos, ya que se deducir√°n de la implementaci√≥n ‚ü¶a menos que, por supuesto, utilice diferentes funciones avanzadas de las extensiones modernas del sistema de tipos‚üß. </p><br><p>  Puede parecer que esto no es muy diferente de la versi√≥n de Python, pero solo gracias al hecho de que escribimos nuestra funci√≥n en Haskell y est√° en mosaico, ya podemos hablar de algunas propiedades interesantes. </p><br><p>  <strong>An√°lisis</strong> </p><br><p>  Obviamente, no podemos sacar tantas conclusiones aqu√≠, pero aqu√≠ hay algunos puntos a tener en cuenta: </p><br><ul><li>  <strong>La documentaci√≥n</strong> <br><ul><li>  ‚úó Conocemos el comportamiento esperado </li></ul></li><li>  <strong>Errores comunes</strong> <br><ul><li>  ‚úì <strong>Sin errores tipogr√°ficos o nombres incorrectos</strong> <br>  Dado que Haskell es un lenguaje compilado, todos los nombres deben resolverse en el momento de la compilaci√≥n.  El programa simplemente no se compilar√° si hay este error. </li><li>  ‚úì <strong>Sin <code>null</code> inesperados</strong> <br>  Haskell simplemente no tiene <code>null</code> .  ¬°El problema est√° resuelto! </li></ul></li><li>  <strong>Garant√≠as</strong> <br><ul><li>  ‚úì Seguridad de memoria </li><li>  ‚úì <strong>La funci√≥n no se puede llamar con el tipo incorrecto</strong> </li><li>  ‚úì <strong>Sin efectos secundarios <em>inesperados</em></strong> <br>  "El autor del art√≠culo original no especific√≥ este elemento, pero me permitir√© se√±alar que si hay efectos secundarios, el tipo deducido de esta funci√≥n indicar√° su presencia, de modo que el c√≥digo de llamada conocer√° sus capacidades". </li></ul></li></ul><br><h2>  Tipo de Haskell que especifica </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Anteriormente, hablamos de una actitud bastante intrigante hacia la seguridad de las abuelas: las pruebas dejaron claro que la funci√≥n no iba a da√±ar a nadie, pero ¬ø <em>estaba realmente</em> segura <em>la</em> abuela?  ¬øEsta funci√≥n no env√≠a letras juradas con precisi√≥n? </p><br><p>  Haskell es conocido por ser un lenguaje funcional puro.  Esto no significa que el c√≥digo no pueda tener efectos secundarios, pero todos los efectos secundarios deben estar presentes en el tipo.  Sabemos el tipo de esta funci√≥n, vemos que est√° limpia, por lo que estamos seguros de que esta funci√≥n no modifica ning√∫n estado externo. </p><br><p>  Esta es una propiedad muy interesante por otras razones: como sabemos que no hay efectos secundarios, podemos entender lo que hace esta funci√≥n, ¬°solo en funci√≥n de su firma!  Simplemente busque esta firma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoogle</a> y mire el primer resultado.  Por supuesto, esta no es la √∫nica funci√≥n posible que tendr√≠a un tipo de este tipo, pero el tipo nos da suficiente confianza para los fines de la documentaci√≥n. </p><br><p>  <strong>An√°lisis</strong> </p><br><ul><li>  <strong>La documentaci√≥n</strong> <br><ul><li>  ‚úì <strong>Conocemos el comportamiento esperado</strong> </li><li>  ‚úó Tenemos un ejemplo de uso </li><li>  ‚úì Conocemos algunas clases de valores que se procesar√°n correctamente </li><li>  ‚úì <strong>Conocemos todos los tipos de valores que se procesar√°n correctamente</strong> </li></ul></li><li>  <strong>Especificaci√≥n</strong> <br><ul><li>  ‚úó Funciona en al menos un caso. <br>  Si faltan pruebas o pruebas, ¬°no sabemos si nuestra funci√≥n funciona como esperamos! </li><li>  Index El √≠ndice devuelto es siempre un √≠ndice v√°lido. </li><li>  Index El √≠ndice devuelto siempre indica un valor adecuado. </li><li>  Item Un elemento que falta siempre devuelve <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Errores comunes</strong> <br><ul><li>  ‚úì Sin errores tipogr√°ficos o nombres incorrectos </li><li>  ‚úì Sin <code>null</code> inesperados </li><li>  ‚úì El <strong>caso de error siempre se maneja</strong> <br>  Si nuestra funci√≥n devuelve <code>Nothing</code> , entonces el sistema de tipos se asegura de que este caso sea manejado correctamente por el c√≥digo de llamada.  Por supuesto, este caso puede ser ignorado, pero esto debe hacerse expl√≠citamente. </li></ul></li><li>  <strong>Garant√≠as</strong> <br><ul><li>  ‚úì Seguridad de memoria </li><li>  ‚úì La funci√≥n no se puede llamar con el tipo incorrecto </li><li>  ‚úì <strong>Sin efectos secundarios</strong> </li><li>  ‚úó Sin excepciones <br>  Comparto excepciones y errores, creyendo que despu√©s de las excepciones es posible recuperar, y despu√©s de los errores (por ejemplo, funciones parcialmente definidas) - no. <br>  En su mayor parte, las excepciones se describen en tipos (por ejemplo, en la m√≥nada IO).  En el buen sentido, debemos saber que una funci√≥n no arrojar√° una excepci√≥n, solo en funci√≥n de su tipo.  Sin embargo, Haskell rompe esta expectativa al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">permitir que se generen excepciones desde el c√≥digo puro</a> . <br>  "Adem√°s, vale la pena se√±alar que en Haskell, los errores como llamar incorrectamente a funciones parcialmente definidas tambi√©n se presentan como excepciones que pueden detectarse y procesarse, por lo que la diferencia entre las dos categor√≠as es un poco menos obvia". </li><li>  ‚úó Sin errores <br>  Todav√≠a podemos usar funciones parcialmente definidas, por ejemplo, divisi√≥n por cero. </li><li>  ‚úó Sin ciclos perpetuos </li></ul></li></ul><br><h2>  Haskell con pruebas </h2><br><p>  ¬øRecuerdas que dije antes que las pruebas no pueden probar la ausencia de errores?  Ment√≠  Cuando las estrellas convergen correctamente, y si las pruebas se combinan con tipos, ¬°entonces es posible!  La primera estrella es la finitud del dominio de nuestra funci√≥n.  El segundo: el dominio de la definici√≥n no solo debe ser finito, sino tambi√©n no muy grande, de lo contrario, tal prueba ser√° dif√≠cil de poner en pr√°ctica. </p><br><p>  Por ejemplo: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  La entrada puede ser <code>True</code> o <code>False</code> .  Es suficiente para probar estas dos opciones, y aqu√≠ est√°, ¬°el Santo Grial!  Sin excepciones, ciclos perpetuos, resultados incorrectos, sin errores.  ‚ü¶Sin embargo, para una funci√≥n un poco m√°s compleja, puede que no est√© claro cu√°nto tiempo se dedica a las pruebas: si tardan mucho en completarse, ¬øacabamos en un ciclo eterno, o es simplemente pesado?  El problema de detenerla. </p><br><p>  De hecho, esto tampoco es del todo cierto en el caso de Haskell: en cada tipo de Haskell tambi√©n hay un valor ‚ä• (que puede obtenerse como <code>undefined</code> , <code>error</code> o <code>error</code> en cierto sentido, como recursi√≥n infinita), pero los Haskellistas tradicionalmente cierran los ojos y creen que No existe. </p><br><p>  Lectura extracurricular: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solo hay cuatro mil millones de flotadores, ¬°as√≠ que pru√©belos todos!</a> </p><br><p>  En cualquier caso, en nuestro ejemplo original, el alcance es infinito, por lo que las pruebas solo pueden mostrar que nuestro c√≥digo funciona para un conjunto finito de ejemplos. </p><br><p>  <strong>An√°lisis</strong> <br>  En este caso, las pruebas complementan los tipos y tapan algunos agujeros en el sistema de tipos Haskell.  Tenemos mucha m√°s confianza en nuestro c√≥digo en comparaci√≥n con el uso de solo pruebas o tipos. </p><br><h2>  C </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Consideramos C fuera de inter√©s en sistemas de tipos m√°s antiguos.  En C, en particular, los tipos probablemente no sean necesarios para el programador, sino para el compilador para ayudarlo a generar un c√≥digo m√°s r√°pido. </p><br><p>  En nuestro ejemplo, no sabemos qu√© devolver√° la funci√≥n si no se encuentra el elemento.  Tendremos que confiar en la tradici√≥n o en la documentaci√≥n (por ejemplo, en este caso puede ser <code>-1</code> ). </p><br><p>  Tambi√©n podr√≠amos usar argumentos: de esta manera podemos devolver un error y almacenar el valor de retorno en este argumento de salida.  Esta es una opci√≥n un poco m√°s expresiva, pero a√∫n tenemos que confiar en la documentaci√≥n para comprender qu√© par√°metros se leen y cu√°les se escriben.  En ambos casos, es dif√≠cil entender el comportamiento al observar los tipos. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>An√°lisis</strong> <br>  El sistema de tipos en s√≠ no nos da tantas garant√≠as.  Por supuesto, obtenemos informaci√≥n de estos tipos, pero solo comp√°rela con el caso Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Esta funci√≥n es del mismo tipo que en el caso de Haskell.  Sin embargo, con un sistema de tipo m√°s expresivo, podemos lograr m√°s.  La elecci√≥n de los tipos puede hablar sobre la implementaci√≥n. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Este tipo puede leerse como "dame una lista de tama√±o <code>n</code> y alg√∫n valor, y te devolver√© un n√∫mero menor que <code>n</code> o <code>Nothing</code> ".  Esto asegura que la funci√≥n devuelve un √≠ndice que obviamente no va m√°s all√° de los l√≠mites. </p><br><p>  Adem√°s, esta funci√≥n es total, es decir, el temporizador ha comprobado que siempre termina.  Esto elimina los ciclos perpetuos y los errores. </p><br><p>  <strong>An√°lisis</strong> </p><br><ul><li>  <strong>Especificaci√≥n</strong> <br><ul><li>  ‚úó Funciona en al menos un caso. </li><li>  ‚úì El <strong>√≠ndice devuelto siempre es el √≠ndice correcto</strong> </li><li>  ‚úó El √≠ndice devuelto siempre indica un valor adecuado </li><li>  ‚úó El elemento faltante siempre devuelve <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garant√≠as</strong> <br><ul><li>  ‚úì Seguridad de memoria </li><li>  ‚úì La funci√≥n no se puede llamar con el tipo incorrecto </li><li>  ‚úì Sin efectos secundarios </li><li>  ‚úó Sin excepciones </li><li>  ‚úì <strong>Sin errores</strong> </li><li>  ‚úì <strong>Sin ciclos perpetuos</strong> </li></ul></li></ul><br><h2>  Idris con pruebas </h2><br><p>  Dado que el lenguaje tipo de Idris es tan expresivo como el lenguaje de sus t√©rminos ‚ü¶(o m√°s bien, su parte demostrablemente total)‚üß, la diferencia entre la prueba y el tipo es borrosa: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Esta funci√≥n tiene un tipo bastante extra√±o <code>x [1, 2, 3] 2 = Just 1</code> .  Este tipo significa que para una verificaci√≥n de tipo exitosa, el tipeador debe demostrar que <code>x [1, 2, 3] 2</code> estructuralmente igual a <code>Just 1</code> .  ‚ü¶En este caso, la prueba es trivial, ya que es suficiente para que el volquete normalice los t√©rminos en ambos lados del signo igual, lo que se har√° en un tiempo finito debido a la totalidad de todas las funciones utilizadas, y que conducir√° a un resultado √∫nico debido a Church-Rosser.  Despu√©s de eso, uno puede usar la reflexividad de la igualdad, que es lo que Refl. </p><br><p>  De hecho, escribimos una prueba de nivel de tipo. </p><br><h2>  Idris con evidencia </h2><br><p>  Para completar el an√°lisis, podemos usar todo el poder de los tipos dependientes y <em>probar</em> nuestra implementaci√≥n (ya que los tipos dependientes en Idris son equivalentes a un sistema l√≥gico que incluye l√≥gica constructiva de primer orden). </p><br><p>  En particular, podemos probar propiedades que antes eran inalcanzables para nosotros: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  El tipo <code>findIndexOk</code> se puede leer como "para cualquier tipo <code>a</code> modo que tenga una comparaci√≥n algor√≠tmicamente decidible ( <code>DecEq</code> ), para cualquier vector <code>y</code> elementos de tipo <code>a</code> cualquier longitud <code>n</code> cualquier valor <code>z</code> tipo <code>a</code> : si <code>xyz</code> devuelve el √≠ndice <code>i</code> , entonces este √≠ndice yace <code>z</code> , pero si <code>xyz</code> devuelve <code>Nothing</code> , entonces no existe tal elemento en el vector ". </p><br><p>  "Es interesante que el autor del art√≠culo original le d√© un tipo un poco m√°s d√©bil que el dado anteriormente". </p><br><p>  ¬°Ahora tenemos todo capturado!  ¬øCu√°les son las desventajas?  Bueno, escribir toda esta evidencia puede ser bastante dif√≠cil. </p><br><h2>  Comparaci√≥n </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Pit√≥n </th><th>  Pit√≥n <br>  pruebas </th><th>  Haskell </th><th>  Haskell <br>  tipos </th><th>  Haskell <br>  tipos <br>  pruebas </th><th>  Idris </th><th>  Idris <br>  pruebas </th><th>  Idris <br>  pruebas </th></tr><tr><th>  La documentaci√≥n </th></tr><tr><td>  Conocemos el comportamiento esperado. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Hay un ejemplo de uso </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Conocemos algunos tipos de valores adecuados. </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Conocemos todo tipo de valores adecuados. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><th>  Especificaci√≥n </th></tr><tr><td>  Funciona en al menos un caso </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  El √≠ndice devuelto siempre es v√°lido. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  El √≠ndice devuelto siempre es v√°lido. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td></tr><tr><td>  El elemento que falta da `Ninguno` /` Nada` </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td></tr><tr><th>  Errores comunes </th></tr><tr><td>  Sin errores tipogr√°ficos o nombres incorrectos </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  No repentino `nulo` </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  El caso de error siempre se maneja. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><th>  Garant√≠as </th></tr><tr><td>  Seguridad de la memoria </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  No se puede llamar con el tipo incorrecto. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sin efectos secundarios </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sin excepciones </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sin errores </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sin ciclos perpetuos. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr></tbody></table></div><br><h2>  Opini√≥n </h2><br><p>  En mi opini√≥n, el uso de un sistema de tipo moderno en s√≠ mismo es m√°s efectivo en t√©rminos de la relaci√≥n de la informaci√≥n recibida y las garant√≠as al esfuerzo realizado.  Si desea escribir un c√≥digo bastante confiable, los tipos se pueden condimentar con pruebas.  Idealmente, al estilo de QuickCheck. </p><br><p>  Con los tipos dependientes, la l√≠nea entre pruebas y tipos se vuelve menos obvia.  Si est√° escribiendo software para Boeing o para marcapasos, puede ser √∫til escribir evidencia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467677/">https://habr.com/ru/post/467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467667/index.html">Planificaci√≥n de proyectos de organizaci√≥n (Parte 4)</a></li>
<li><a href="../467669/index.html">M√≠rame completo: aprovecha al m√°ximo el video en vivo en plataformas m√≥viles</a></li>
<li><a href="../467671/index.html">Computadora retro NLX</a></li>
<li><a href="../467673/index.html">Funciones Go integradas</a></li>
<li><a href="../467675/index.html">Modelado del estado de la aplicaci√≥n utilizando objetos Store en SwiftUI</a></li>
<li><a href="../467679/index.html">PyCrunch: ejecuci√≥n de prueba inteligente y cobertura de c√≥digo visual en el IDE</a></li>
<li><a href="../467681/index.html">Vulnerabilidad de desv√≠os de enrutamiento SOAP</a></li>
<li><a href="../467683/index.html">Tratando de componer lo no composable: esquemas de acoplamiento</a></li>
<li><a href="../467689/index.html">Una peque√±a descripci√≥n de SIMD en .NET / C #</a></li>
<li><a href="../467691/index.html">Intel Nervana NNP-T y NNP-I: chips especializados para IA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>