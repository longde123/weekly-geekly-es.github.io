<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦏 🧚 💈 Kami menulis sistem operasi di Rust. Halaman organisasi memori 😕 👨‍👧‍👧 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kami menyajikan halaman , skema manajemen memori yang sangat umum yang juga kami terapkan di OS kami. Artikel ini menjelaskan mengap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis sistem operasi di Rust. Halaman organisasi memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/">  Pada artikel ini, kami menyajikan <i>halaman</i> , skema manajemen memori yang sangat umum yang juga kami terapkan di OS kami.  Artikel ini menjelaskan mengapa isolasi memori diperlukan, bagaimana <i>segmentasi</i> bekerja, apa <i>memori virtual itu,</i> dan bagaimana halaman memecahkan masalah fragmentasi.  Kami juga menjelajahi skema tabel halaman bertingkat dalam arsitektur x86_64. <br><br>  Blog ini diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Jika Anda memiliki pertanyaan atau masalah, buka permintaan terkait di sana. <br><a name="habracut"></a><br><h1>  Perlindungan memori </h1><br>  Salah satu tugas utama sistem operasi adalah mengisolasi program dari satu sama lain.  Misalnya, browser tidak boleh mengganggu editor teks.  Ada berbagai pendekatan tergantung pada implementasi perangkat keras dan OS. <br><br>  Sebagai contoh, beberapa prosesor ARM Cortex-M (dalam embedded system) memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>unit proteksi memori</i></a> (MPU) yang mendefinisikan sejumlah kecil (misalnya, 8) area memori dengan izin akses yang berbeda (misalnya, tidak ada akses, hanya baca, baca dan catatan).  Setiap kali memori diakses, MPU memastikan bahwa alamatnya berada di area dengan izin yang benar, jika tidak maka akan melempar pengecualian.  Dengan mengubah ruang lingkup dan izin akses, OS memastikan bahwa setiap proses hanya memiliki akses ke memorinya untuk mengisolasi proses dari satu sama lain. <br><br>  Pada x86, dua pendekatan berbeda untuk melindungi memori didukung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">segmentasi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paging</a> . <br><br><h1>  Segmentasi </h1><br>  Segmentasi diterapkan kembali pada tahun 1978, awalnya untuk meningkatkan jumlah memori addressable.  Pada saat itu, CPU hanya mendukung alamat 16-bit, yang membatasi jumlah memori yang dapat dialamatkan hingga 64 KB.  Untuk meningkatkan volume ini, register segmen tambahan diperkenalkan, yang masing-masing berisi alamat offset.  CPU secara otomatis menambahkan offset ini pada setiap akses memori, sehingga menangani memori hingga 1 MB. <br><br>  CPU secara otomatis memilih register segmen tergantung pada jenis akses memori: register segmen kode <code>CS</code> digunakan untuk menerima instruksi, dan register segmen stack <code>SS</code> digunakan untuk operasi stack (push / pop).  Instruksi lain menggunakan register segmen data <code>DS</code> atau register segmen <code>ES</code> opsional.  Kemudian, dua register segmen tambahan <code>FS</code> dan <code>GS</code> ditambahkan secara gratis. <br><br>  Dalam versi pertama segmentasi, register secara langsung berisi offset dan kontrol akses tidak dilakukan.  Dengan munculnya <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode terlindungi,</a></i> mekanismenya telah berubah.  Saat CPU beroperasi dalam mode ini, deskriptor segmen menyimpan indeks dalam tabel deskriptor lokal atau global, yang selain alamat offset berisi ukuran segmen dan izin akses.  Dengan memuat tabel deskriptor global / lokal yang terpisah untuk setiap proses, OS dapat mengisolasi proses satu sama lain. <br><br>  Dengan mengubah alamat memori sebelum akses aktual, segmentasi menerapkan metode yang sekarang digunakan hampir di mana-mana: itu adalah <i>memori virtual</i> . <br><br><h3>  Memori virtual </h3><br>  Ide memori virtual adalah untuk mengabstraksi alamat memori dari perangkat fisik.  Alih-alih langsung mengakses perangkat penyimpanan, langkah konversi terlebih dahulu dilakukan.  Dalam hal segmentasi, alamat offset segmen aktif ditambahkan pada tahap terjemahan.  Bayangkan sebuah program yang mengakses alamat memori <code>0x1234000</code> dalam sebuah segmen dengan offset <code>0x1111000</code> : pada kenyataannya, alamatnya menjadi <code>0x2345000</code> . <br><br>  Untuk membedakan antara dua jenis alamat, alamat sebelum konversi disebut <i>virtual</i> , dan alamat setelah konversi disebut <i>fisik</i> .  Ada satu perbedaan penting di antara mereka: alamat fisik adalah unik dan selalu merujuk ke lokasi unik yang sama dalam memori.  Alamat virtual, di sisi lain, bergantung pada fungsi terjemahan.  Dua alamat virtual yang berbeda mungkin merujuk ke alamat fisik yang sama.  Selain itu, alamat virtual yang identik dapat merujuk ke berbagai alamat fisik setelah konversi. <br><br>  Contoh penggunaan yang berguna dari properti ini adalah peluncuran paralel dari program yang sama dua kali: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Di sini, program yang sama berjalan dua kali, tetapi dengan fungsi konversi yang berbeda.  Contoh pertama memiliki offset segmen 100, sehingga alamat virtualnya 0-150 dikonversi ke alamat fisik 100-250.  Contoh kedua memiliki offset 300, yang menerjemahkan alamat virtual 0-150 menjadi alamat fisik 300-450.  Ini memungkinkan kedua program untuk mengeksekusi kode yang sama dan menggunakan alamat virtual yang sama tanpa mengganggu satu sama lain. <br><br>  Keuntungan lain adalah bahwa sekarang program dapat ditempatkan di tempat sewenang-wenang di memori fisik.  Dengan demikian, OS menggunakan seluruh jumlah memori yang tersedia tanpa perlu mengkompilasi ulang program. <br><br><h3>  Fragmentasi </h3><br>  Perbedaan antara alamat virtual dan fisik adalah pencapaian segmentasi yang nyata.  Tapi ada masalah.  Bayangkan kita ingin menjalankan salinan ketiga dari program yang kita lihat di atas: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Meskipun ada lebih dari cukup ruang dalam memori fisik, salinan ketiga tidak cocok di mana pun.  Masalahnya adalah ia membutuhkan fragmen memori yang <i>berkelanjutan</i> dan kami tidak dapat menggunakan bagian bebas yang terpisah. <br><br>  Salah satu cara untuk memerangi fragmentasi adalah menghentikan sementara eksekusi program, memindahkan bagian memori yang digunakan lebih dekat satu sama lain, memperbarui konversi, dan kemudian melanjutkan eksekusi: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Sekarang ada cukup ruang untuk meluncurkan instance ketiga. <br><br>  Kerugian dari defragmentasi ini adalah kebutuhan untuk menyalin sejumlah besar memori, yang mengurangi kinerja.  Prosedur ini harus dilakukan secara teratur sampai memori menjadi terlalu terfragmentasi.  Kinerja menjadi tidak dapat diprediksi, program berhenti kapan saja dan dapat berhenti merespons. <br><br>  Fragmentasi adalah salah satu alasan mengapa segmentasi tidak digunakan di sebagian besar sistem.  Bahkan, itu tidak lagi didukung bahkan dalam mode 64-bit pada x86.  Alih-alih segmentasi, halaman digunakan yang sepenuhnya menghilangkan masalah fragmentasi. <br><br><h1>  Halaman organisasi memori </h1><br>  Idenya adalah untuk membagi ruang memori virtual dan fisik menjadi blok kecil dengan ukuran tetap.  Blok memori virtual disebut halaman, dan blok ruang alamat fisik disebut frame.  Setiap halaman secara individual dipetakan ke sebuah frame, yang memungkinkan Anda untuk membagi area memori yang besar antara frame fisik yang tidak berdekatan. <br><br>  Keuntungannya menjadi jelas jika Anda mengulangi contoh dengan ruang memori yang terfragmentasi, tetapi kali ini menggunakan halaman alih-alih segmentasi: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  Dalam contoh ini, ukuran halaman adalah 50 byte, yaitu, masing-masing area memori dibagi menjadi tiga halaman.  Setiap halaman dipetakan ke frame yang terpisah, sehingga wilayah memori virtual yang berdekatan dapat dipetakan ke frame fisik yang terisolasi.  Ini memungkinkan Anda untuk menjalankan instance ketiga program tanpa defragmentasi. <br><br><h3>  Fragmentasi tersembunyi </h3><br>  Dibandingkan dengan segmentasi, organisasi paging menggunakan banyak area memori berukuran kecil dan bukannya beberapa area berukuran variabel.  Setiap frame memiliki ukuran yang sama, jadi fragmentasi karena frame terlalu kecil tidak dimungkinkan. <br><br>  Tapi ini hanya <i>penampilan</i> .  Bahkan, ada bentuk fragmentasi tersembunyi, yang disebut <i>fragmentasi internal</i> karena fakta bahwa tidak setiap area memori persis kelipatan dari ukuran halaman.  Bayangkan dalam contoh di atas, program ukuran 101: masih akan membutuhkan tiga halaman ukuran 50, sehingga akan membutuhkan 49 byte lebih dari yang Anda butuhkan.  Untuk kejelasan, fragmentasi karena segmentasi disebut <i>fragmentasi eksternal</i> . <br><br>  Tidak ada yang baik dalam fragmentasi internal, tetapi seringkali itu adalah kejahatan yang lebih rendah daripada fragmentasi eksternal.  Memori tambahan masih dikonsumsi, tetapi sekarang Anda tidak perlu men-defragnya, dan volume fragmentasi dapat diprediksi (rata-rata, setengah halaman per area memori). <br><br><h3>  Tabel Halaman </h3><br>  Kami melihat bahwa masing-masing dari jutaan halaman yang mungkin dipetakan secara individual ke sebuah bingkai.  Informasi terjemahan alamat ini perlu disimpan di suatu tempat.  Saat melakukan segmentasi, register segmen yang terpisah digunakan untuk setiap area memori aktif, yang tidak mungkin dalam hal halaman, karena ada lebih banyak dari mereka daripada register.  Sebagai gantinya, ia menggunakan struktur yang disebut <i>tabel halaman</i> . <br><br>  Untuk contoh di atas, tabel akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  Seperti yang Anda lihat, setiap instance dari program memiliki tabel halaman sendiri.  Sebuah penunjuk ke tabel aktif saat ini disimpan dalam register khusus CPU.  Pada <code>x86</code> itu disebut <code>CR3</code> .  Sebelum memulai setiap instance program, sistem operasi harus memuat pointer ke tabel halaman yang benar di sana. <br><br>  Setiap kali memori diakses, CPU membaca pointer tabel dari register dan mencari frame yang sesuai dalam tabel.  Ini adalah fungsi perangkat keras sepenuhnya yang berjalan sepenuhnya transparan untuk program yang sedang berjalan.  Untuk mempercepat proses, banyak arsitektur prosesor memiliki cache khusus yang mengingat hasil konversi terbaru. <br><br>  Bergantung pada arsitektur, atribut seperti izin juga dapat disimpan di bidang bendera pada tabel halaman.  Pada contoh di atas, bendera <code>r/w</code> membuat halaman dapat dibaca dan ditulis. <br><br><h3>  Tabel Halaman Layered </h3><br>  Tabel halaman sederhana memiliki masalah dengan ruang alamat yang besar: memori terbuang sia-sia.  Misalnya, program ini menggunakan empat halaman virtual <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> dan <code>1_000_100</code> (kami menggunakan <code>_</code> sebagai pemisah angka): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Hanya empat bingkai fisik yang diperlukan, tetapi ada lebih dari satu juta catatan dalam tabel halaman.  Kami tidak dapat melewati entri kosong, karena dengan demikian CPU selama proses konversi tidak akan dapat langsung masuk ke entri yang benar (misalnya, tidak lagi dijamin bahwa halaman keempat menggunakan entri keempat). <br><br>  Untuk mengurangi kehilangan memori, Anda dapat menggunakan organisasi <b>dua tingkat</b> .  Idenya adalah kita menggunakan tabel yang berbeda untuk area yang berbeda.  Tabel tambahan, disebut tabel halaman <i>level kedua</i> , mengkonversi antara area alamat dan tabel halaman level pertama. <br><br>  Ini paling baik dijelaskan dengan contoh.  Kami menetapkan bahwa setiap tabel halaman level 1 bertanggung jawab untuk area dengan ukuran <code>10_000</code> .  Maka dalam contoh di atas tabel berikut akan ada: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  Halaman 0 jatuh ke area pertama <code>10_000</code> byte, sehingga menggunakan catatan pertama di tabel halaman tingkat kedua.  Entri ini menunjuk ke tabel halaman T1 tingkat pertama, yang menentukan bahwa halaman 0 mengacu pada frame 0. <br><br>  Halaman <code>1_000_000</code> , <code>1_000_050</code> dan <code>1_000_100</code> termasuk dalam wilayah byte ke- <code>10_000</code> dari <code>10_000</code> , sehingga mereka menggunakan catatan ke-100 tabel tabel level 2. Catatan ini menunjuk ke tabel level pertama lain T2, yang menerjemahkan tiga halaman menjadi frame 100, 150 dan 200. Catatan bahwa alamat halaman dalam tabel di tingkat pertama tidak mengandung offset wilayah, oleh karena itu, misalnya, catatan untuk halaman <code>1_000_050</code> hanya <code>50</code> . <br><br>  Kami masih memiliki 100 entri kosong di tabel tingkat kedua, tetapi ini jauh lebih sedikit daripada juta sebelumnya.  Alasan penghematan adalah bahwa Anda tidak perlu membuat tabel halaman tingkat pertama untuk area memori yang <code>10_000</code> antara <code>10_000</code> dan <code>1_000_000</code> . <br><br>  Prinsip tabel dua tingkat dapat diperpanjang hingga tiga, empat tingkat atau lebih.  Secara umum, sistem seperti itu disebut tabel halaman <i>bertingkat</i> atau <i>hierarkis</i> . <br><br>  Mengetahui organisasi halaman dan tabel multi-level, Anda dapat melihat bagaimana organisasi halaman diimplementasikan dalam arsitektur x86_64 (kami mengasumsikan bahwa prosesor berjalan dalam mode 64-bit). <br><br><h1>  Organisasi Halaman di x86_64 </h1><br>  Arsitektur x86_64 menggunakan tabel empat tingkat dengan ukuran halaman 4 KB.  Terlepas dari level, setiap tabel halaman memiliki 512 elemen.  Setiap record memiliki ukuran 8 byte, sehingga ukuran tabel adalah 512 × 8 byte = 4 KB. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  Seperti yang Anda lihat, setiap indeks tabel berisi 9 bit, yang masuk akal, karena tabel memiliki 2 ^ 9 = 512 entri.  12 bit terbawah adalah offset halaman 4-kilobyte (2 ^ 12 byte = 4 KB).  Bit 48 hingga 64 dibuang, jadi x86_64 sebenarnya bukan sistem 64-bit, tetapi hanya mendukung alamat 48-bit.  Ada rencana untuk memperluas ukuran alamat menjadi 57 bit melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel halaman 5 tingkat</a> , tetapi prosesor seperti itu belum dibuat. <br><br>  Meskipun bit 48 hingga 64 dibuang, mereka tidak dapat diatur ke nilai arbitrer.  Semua bit dalam kisaran ini harus merupakan salinan bit 47 untuk mempertahankan alamat unik dan memungkinkan ekspansi di masa mendatang, misalnya, ke tabel halaman 5-tingkat.  Ini disebut ekstensi tanda, karena sangat mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi tanda pada kode tambahan</a> .  Jika alamat tidak diperluas dengan benar, CPU melempar pengecualian. <br><br><h3>  Contoh konversi </h3><br>  Mari kita lihat contoh cara kerja terjemahan alamat: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  Alamat fisik dari tabel halaman aktif saat ini dari level 4 halaman, yang merupakan tabel root dari halaman halaman level ini, disimpan dalam <code>CR3</code> .  Setiap entri tabel halaman kemudian menunjuk ke bingkai fisik dari tabel level berikutnya.  Entri tabel level 1 menunjukkan bingkai yang ditampilkan.  Harap perhatikan bahwa semua alamat dalam tabel halaman bersifat fisik dan bukan virtual, karena jika tidak, CPU harus mengubah alamat ini (yang dapat menyebabkan rekursi tak terbatas). <br><br>  Hirarki di atas mengonversi dua halaman (berwarna biru).  Dari indeks, kita dapat menyimpulkan bahwa alamat virtual dari halaman ini adalah <code>0x803fe7f000</code> dan <code>0x803FE00000</code> .  Mari kita lihat apa yang terjadi ketika sebuah program mencoba membaca memori di alamat <code>0x803FE7F5CE</code> .  Pertama, ubah alamat menjadi biner dan tentukan indeks tabel halaman dan offset untuk alamat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  Dengan menggunakan indeks ini, kita sekarang bisa melalui hierarki tabel halaman dan menemukan bingkai yang sesuai: <br><br><ul><li>  Baca alamat tabel level keempat dari <code>CR3</code> . </li><li>  Indeks level keempat adalah 1, jadi kami melihat catatan dengan indeks 1 dalam tabel ini.  Dia mengatakan tabel level 3 disimpan pada 16 KB. </li><li>  Kami memuat tabel tingkat ketiga dari alamat ini dan melihat catatan dengan indeks 0, yang menunjuk ke tabel tingkat kedua pada 24 KB. </li><li>  Indeks level kedua adalah 511, jadi kami mencari catatan terakhir pada halaman ini untuk mengetahui alamat tabel level pertama. </li><li>  Dari entri dengan indeks 127 pada tabel tingkat pertama, kami akhirnya menemukan bahwa halaman tersebut sesuai dengan bingkai 12 KB atau 0xc000 dalam format heksadesimal. </li><li>  Langkah terakhir adalah menambahkan offset ke alamat bingkai untuk mendapatkan alamat fisik: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  Untuk halaman di tabel level pertama, <code>r</code> bendera ditentukan, yaitu, hanya bacaan yang diizinkan.  Pengecualian akan dilemparkan ke tingkat perangkat keras jika kami mencoba merekam di sana.  Izin tabel level yang lebih tinggi meluas ke level yang lebih rendah, jadi jika kita mengatur flag read-only pada level ketiga, tidak ada satu halaman berikutnya dari level yang lebih rendah yang dapat ditulisi, bahkan jika ada flag yang memungkinkan penulisan. <br><br>  Meskipun contoh ini hanya menggunakan satu instance dari setiap tabel, biasanya di setiap ruang alamat ada beberapa contoh dari setiap level.  Maksimal: <br><br><ul><li>  satu meja dari tingkat keempat, </li><li>  512 tabel dari level ketiga (karena ada 512 catatan di tabel level keempat), </li><li>  512 * 512 tabel tingkat kedua (karena masing-masing tabel tingkat ketiga memiliki 512 entri), dan </li><li>  512 * 512 * 512 tabel di tingkat pertama (512 catatan untuk setiap tabel di tingkat kedua). </li></ul><br><h3>  Format Tabel Halaman </h3><br>  Dalam arsitektur x86_64, tabel halaman pada dasarnya adalah array dari 512 entri.  Dalam sintaksis Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  Seperti yang ditunjukkan pada atribut <code>repr</code> , tabel harus disejajarkan pada halaman, mis., Pada batas 4 KB.  Persyaratan ini memastikan bahwa tabel selalu secara optimal mengisi seluruh halaman, membuat entri menjadi sangat ringkas. <br><br>  Ukuran setiap catatan adalah 8 byte (64 bit) dan format berikut: <br><br><table><thead><tr><th>  Bit </th><th>  Judul </th><th>  Nilai </th></tr></thead><tbody><tr><td>  0 </td><td>  hadir </td><td>  halaman dalam memori </td></tr><tr><td>  1 </td><td>  dapat ditulis </td><td>  catatan diizinkan </td></tr><tr><td>  2 </td><td>  pengguna dapat diakses </td><td>  jika bit tidak diset, maka hanya kernel yang memiliki akses ke halaman </td></tr><tr><td>  3 </td><td>  tuliskan melalui caching </td><td>  menulis langsung ke memori </td></tr><tr><td>  4 </td><td>  nonaktifkan cache </td><td>  nonaktifkan cache untuk halaman ini </td></tr><tr><td>  5 </td><td>  diakses </td><td>  CPU menyetel bit ini saat halaman sedang digunakan. </td></tr><tr><td>  6 </td><td>  kotor </td><td>  CPU menetapkan bit ini saat menulis ke halaman </td></tr><tr><td>  7 </td><td>  halaman besar / nol </td><td>  bit nol di P1 dan P4 menciptakan 1 halaman KB di P3, halaman 2 MB di P2 </td></tr><tr><td>  8 </td><td>  global </td><td>  halaman tidak diisi dari cache ketika berpindah ruang alamat (bit PGE dari register CR4 harus disetel) </td></tr><tr><td>  9-11 </td><td>  tersedia </td><td>  OS dapat menggunakannya secara bebas </td></tr><tr><td>  12-51 </td><td>  alamat fisik </td><td>  alamat fisik frame-aligned 52-bit dari frame atau tabel halaman berikut </td></tr><tr><td>  52-62 </td><td>  tersedia </td><td>  OS dapat menggunakannya secara bebas </td></tr><tr><td>  63 </td><td>  tidak ada eksekusi </td><td>  melarang eksekusi kode pada halaman ini (bit NXE harus diatur dalam register EFER) </td></tr></tbody></table><br>  Kita melihat bahwa hanya bit 12-51 yang digunakan untuk menyimpan alamat fisik frame, dan sisanya berfungsi sebagai flag atau dapat digunakan secara bebas oleh sistem operasi.  Ini dimungkinkan karena kami selalu menunjuk ke alamat rata-rata 4096-byte, atau ke halaman tabel yang selaras, atau ke awal frame yang sesuai.  Ini berarti bahwa bit 0-11 selalu nol, sehingga tidak dapat disimpan, mereka cukup direset ke tingkat perangkat keras sebelum menggunakan alamat.  Hal yang sama berlaku untuk bit 52-63, karena arsitektur x86_64 hanya mendukung alamat fisik 52-bit (dan hanya alamat virtual 48-bit). <br><br>  Mari kita lihat lebih dekat bendera yang tersedia: <br><br><ul><li>  Bendera ini membedakan halaman yang ditampilkan dari yang tidak ditampilkan.  Ini dapat digunakan untuk menyimpan sementara halaman ke disk ketika memori utama penuh.  Saat berikutnya halaman diakses, pengecualian PageFault khusus terjadi, di mana OS merespons dengan menukar halaman dari disk - program terus bekerja. </li><li>  Flag yang <code>writable</code> dan <code>no execute</code> menentukan apakah konten halaman dapat ditulisi atau masing-masing berisi instruksi yang dapat dieksekusi. </li><li>  Bendera yang <code>accessed</code> dan <code>dirty</code> secara otomatis diatur oleh prosesor saat membaca atau menulis ke halaman.  OS dapat menggunakan informasi ini, misalnya, jika bertukar halaman atau ketika memeriksa untuk melihat apakah isi halaman telah berubah sejak pemompaan terakhir ke disk. </li><li>  Tulisan <code>write through caching</code> dan <code>disable cache</code> flag <code>disable cache</code> memungkinkan Anda mengelola cache untuk setiap halaman secara individual. </li><li>  Bendera yang <code>user accessible</code> membuat halaman dapat diakses untuk kode dari ruang pengguna, jika tidak, hanya tersedia untuk kernel.  Fungsi ini dapat digunakan untuk mempercepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panggilan sistem</a> sambil mempertahankan pemetaan alamat untuk kernel saat program pengguna sedang berjalan.  Namun, kerentanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spectre</a> memungkinkan halaman ini dibaca oleh program dari ruang pengguna. </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 × 4 ,      1  = 512 × 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur x86_64 mendefinisikan format </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabel halaman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rekamannya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi kami tidak harus membuat struktur ini sendiri.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buffer Terjemahan Asosiatif (TLB) </font></font></h3><br> -           .    x86_64           (TLB).    ,     . <br><br>      , TLB   ,           .  ,      TLB  ,    .      CPU   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>invlpg</code></a> (invalidate page),       TLB,           . TLB     <code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang meniru saklar ruang alamat. </font><font style="vertical-align: inherit;">Kedua opsi tersedia </font><font style="vertical-align: inherit;">melalui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul tlb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk diingat untuk membersihkan TLB setelah setiap perubahan tabel halaman, jika tidak CPU akan terus menggunakan terjemahan yang lama, yang akan menyebabkan kesalahan tak terduga yang sangat sulit untuk di-debug.</font></font><br><br><h1>  Implementasi </h1><br>     : <b>     </b> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«   Rust»</a>    ,         ,       64-   x86_64. <br><br>  ,        .    VGA   <code>0xb8000</code>   ,    <i></i>    ,      <code>0xb8000</code>    <code>0xb8000</code> . <br><br>       :         ,       .         :      ,         <br><br><h3>   (PageFault) </h3><br>   PageFault,      . -,         IDT,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); […] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br>    CPU    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CR2</code></a> .     ,   .         <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cr2::read</a></code> .   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PageFaultErrorCode</a></code>          ,  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> LLVM</a>    ,      .    ,      ,     <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hlt_loop</a></code> . <br><br>       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memulai, kita melihat bahwa penangan kesalahan halaman disebut: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar-benar berisi alamat yang </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ingin kita akses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointer instruksi saat ini adalah </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi kami tahu bahwa alamat ini menunjuk ke halaman kode. </font><font style="vertical-align: inherit;">Halaman kode ditampilkan oleh loader read-only, jadi membaca dari alamat ini berfungsi, dan penulisan akan menyebabkan kesalahan. </font><font style="vertical-align: inherit;">Coba ubah pointer </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kami mengomentari baris terakhir, kami dapat memastikan bahwa bacaan berfungsi, dan penulisan menyebabkan kesalahan PageFault. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses ke tabel halaman </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang lihat tabel halaman untuk kernel: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); […] }</span></span></code> </pre> <br>  <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cr3::read</a></code>  <code>x86_64</code>    <code>CR3</code>      .   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PhysFrame</a></code>  <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cr3Flags</a></code> .    . <br><br>     : <br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br>  ,           <i></i>    <code>0x1000</code> ,    <code>PhysAddr</code> .  :        ? <br><br>         ,             .  ,     —    ,        <code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah masalah umum karena kernel harus secara teratur mengakses tabel halaman, misalnya, ketika mengalokasikan tumpukan untuk utas baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi untuk masalah ini akan dijelaskan secara rinci di artikel selanjutnya. Untuk saat ini, katakan saja bahwa loader menggunakan metode yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabel halaman rekursif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Halaman terakhir dari ruang alamat virtual adalah </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami menggunakannya untuk membaca beberapa entri dalam tabel ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } […] }</span></span></code> </pre> <br>          <code>u64</code> .     ,       8  (64 ),  <code>u64</code>     .    <code>for</code>   10  .            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> offset</code></a>   . <br><br>     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br>    ,  <code>0x2023</code>  0    <code>present</code> , <code>writable</code> , <code>accessed</code>     <code>0x2000</code> .  1    <code>0x6e2000</code>      ,  <code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entri 2–9 tidak ada, jadi rentang alamat virtual ini tidak dipetakan ke alamat fisik apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih bekerja dengan pointer yang tidak aman secara langsung, Anda dapat menggunakan tipe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } […] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   —      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1>  Ringkasan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ini menyajikan dua metode melindungi memori: segmentasi dan pengorganisasian halaman. Metode pertama menggunakan area memori berukuran variabel dan menderita fragmentasi eksternal, yang kedua menggunakan halaman berukuran tetap dan memungkinkan kontrol granular lebih besar atas hak akses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organisasi halaman menyimpan informasi terjemahan halaman dalam tabel-tabel dari satu level atau lebih. Arsitektur x86_64 menggunakan tabel empat tingkat dengan ukuran halaman 4 KB. Peralatan secara otomatis mem-bypass tabel halaman dan menyimpan hasil konversi dalam buffer terjemahan asosiatif (TLB). Saat mengganti tabel halaman, harus dipaksa untuk membersihkan.</font></font><br><br>  ,       ,        PageFault.         ,         ,        ,           . <br><br><h1>  Apa selanjutnya </h1><br>      ,    .             <i>  </i> ,         .   ,       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436606/">https://habr.com/ru/post/id436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436594/index.html">Selamat tinggal Chevy Volt: Cerita dan Legenda Hibrida yang Dapat Diisi Ulang</a></li>
<li><a href="../id436596/index.html">Pengembang tumpukan penuh sebenarnya terjebak di tingkat menengah. Bebaskan diri Anda dari penderitaan - jangan menempuh jalan itu</a></li>
<li><a href="../id436598/index.html">Satu langkah raksasa untuk mesin catur</a></li>
<li><a href="../id436600/index.html">Hak cipta diambil alih dan dikoreografikan: Pembuat Fortnite dituntut karena karakter tarian</a></li>
<li><a href="../id436602/index.html">Modul kargo fajar: 20 tahun di orbit</a></li>
<li><a href="../id436608/index.html">[SAP] SAPUI5 untuk boneka: Latihan selangkah demi selangkah yang lengkap</a></li>
<li><a href="../id436610/index.html">Bagaimana kekhususan CSS bekerja di browser</a></li>
<li><a href="../id436612/index.html">Brian Krebs: Basis data akun mega-bocor yang berisi ratusan juta catatan, 2-3 tahun</a></li>
<li><a href="../id436614/index.html">Tesla akan mengurangi jumlah karyawan tetap di seluruh dunia sebesar 7%</a></li>
<li><a href="../id436616/index.html">Bagaimana Singapura Bekerja dengan Inovasi: Dari Peraturan Pemerintah hingga Klub Malam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>