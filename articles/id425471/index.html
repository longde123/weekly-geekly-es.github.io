<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚖️ 🥌 🌠 Bekerja dengan gambar dengan Python 👕 🙋🏻 🏴󠁧󠁢󠁳󠁣󠁴󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Topik pembicaraan hari ini adalah apa yang telah dipelajari Python selama bertahun-tahun keberadaannya dalam bekerja dengan gambar. Memang, selain old...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan gambar dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/425471/">  Topik pembicaraan hari ini adalah apa yang telah dipelajari Python selama bertahun-tahun keberadaannya dalam bekerja dengan gambar.  Memang, selain oldies dari 1990 ImageMagick dan GraphicsMagick, ada perpustakaan modern yang efektif.  Misalnya, Bantal dan Bantal-SIMD yang lebih produktif.  Pengembang aktif mereka Alexander Karpinsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">homm</a> ) di MoscowPython membandingkan perpustakaan yang berbeda untuk bekerja dengan gambar dalam Python, menyajikan tolok ukur dan berbicara tentang fitur yang tidak jelas yang selalu cukup.  Dalam artikel ini, transkrip laporan akan membantu Anda memilih perpustakaan untuk aplikasi Anda, dan membuatnya berfungsi seefisien mungkin. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Alexander Karpinsky bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uploadcare</a> dan terlibat dalam layanan modifikasi gambar cepat dengan cepat.  Dia terlibat dalam pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pillow</a> , perpustakaan populer untuk bekerja dengan gambar dengan Python, dan sedang mengembangkan garpu sendiri dari perpustakaan ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pillow-SIMD</a> , yang menggunakan instruksi prosesor modern untuk kinerja maksimal. <br><a name="habracut"></a><br><h2>  Latar belakang <br></h2><br>  Layanan modifikasi gambar Uploadcare adalah server yang menerima permintaan HTTP dengan pengenal gambar dan beberapa operasi yang perlu dilakukan klien.  Server harus menyelesaikan operasi dan merespons secepat mungkin.  Klien paling sering bertindak sebagai browser. <br><br>  Seluruh layanan dapat digambarkan sebagai pembungkus di sekitar perpustakaan grafik.  Kualitas keseluruhan proyek tergantung pada kualitas, kinerja, dan kegunaan perpustakaan grafis.  Mudah ditebak bahwa Uploadcare menggunakan Bantal sebagai perpustakaan grafik. <br><br><h2>  Perpustakaan <br></h2><br>  Kami akan meninjau secara singkat perpustakaan grafis seperti apa yang secara umum menggunakan Python untuk lebih memahami apa yang akan dibahas nanti. <br><br><h3>  Bantal <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bantal</a> - garpu PIL (Python Imaging Library).  Ini adalah proyek yang sangat lama, dirilis pada 1995 untuk Python 1.2.  Anda bisa bayangkan berapa usianya!  Pada titik tertentu, Perpustakaan Pencitraan Python ditinggalkan dan pengembangannya terhenti.  Garpu Bantal dibuat untuk menginstal dan membangun Perpustakaan Pencitraan Python pada sistem modern.  Secara bertahap, jumlah perubahan yang dibutuhkan orang di Python Imaging Library tumbuh, dan Pillow 2.0 keluar, yang menambahkan dukungan untuk Python 3. Ini dapat dianggap sebagai awal dari kehidupan yang terpisah dari proyek Pillow. <br><br>  Bantal adalah modul asli untuk Python, setengah dari kode ditulis dalam C, setengah dalam Python.  Versi paling beragam dari Python didukung: 2.7, 3.3+, PP, . <br><br><h3>  Bantal-SIMD <br></h3><br>  Ini adalah fork of Pillow saya, yang keluar pada bulan Mei 2016.  SIMD adalah singkatan dari Single Instruction, Multiple Data <strong>&nbsp;</strong>  - Suatu pendekatan di mana prosesor dapat melakukan jumlah tindakan yang lebih besar per siklus menggunakan instruksi modern. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pillow-SIMD</a> bukan garpu dalam arti klasik ketika sebuah proyek mulai menjalani hidupnya sendiri.  Ini adalah pengganti Bantal, yaitu, Anda menginstal satu perpustakaan bukan yang lain, jangan mengubah baris dalam kode sumber Anda, dan mendapatkan lebih banyak kinerja. <br><br>  Bantal-SIMD dapat dirakit dengan instruksi SSE4 (standar).  Ini adalah serangkaian instruksi yang ditemukan di hampir semua prosesor x86 modern.  Bantal-SIMD juga dapat dirakit dengan set instruksi AVX2.  Serangkaian instruksi ini, dimulai dengan arsitektur Haswell, yaitu sekitar tahun 2013. <br><br><h3>  Opencv <br></h3><br>  Pustaka lain untuk bekerja dengan gambar dalam Python yang mungkin Anda pernah dengar adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenCV</a> (Open Computer Vision).  Ini telah bekerja sejak tahun 2000.  Ikatan python disertakan.  Ini berarti mengikat secara konstan relevan, tidak ada sinkronisasi antara perpustakaan itu sendiri dan mengikat. <br><br>  Sayangnya, pustaka ini belum didukung di PyPy, karena OpenCV didasarkan pada numpy, dan numpy baru saja mulai bekerja di bawah PyPy, dan PyC belum mendukung OpenCV. <br><br><h3>  VIPS <br></h3><br>  Perpustakaan lain yang layak diperhatikan adalah VIPS.  Gagasan utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VIPS</a> adalah Anda tidak perlu memuat seluruh gambar ke dalam memori untuk bekerja dengan gambar.  Perpustakaan dapat memuat beberapa potongan kecil, memprosesnya dan menyimpan.  Jadi, untuk memproses gambar gigapixel, Anda tidak perlu menghabiskan memori gigabyte. <br><br>  Ini adalah perpustakaan yang agak tua - 1993, tetapi mengambil alih waktunya.  Untuk waktu yang lama ada sedikit yang terdengar tentang hal itu, tetapi baru-baru ini untuk pengikat VIPS untuk berbagai bahasa mulai muncul, termasuk untuk Go, Node.js, Ruby. <br><br>  Sudah lama saya ingin mencoba perpustakaan ini, merasakannya, tetapi saya tidak berhasil karena alasan yang sangat bodoh.  Saya tidak tahu cara menginstal VIPS, karena pengikatannya sangat rumit.  Tapi sekarang (pada 2017) pengikatan pyvips dirilis dari penulis VIPS itu sendiri, yang tidak ada masalah lagi.  Menginstal dan menggunakan VIPS sekarang sangat mudah.  Didukung: Python 2.7, 3.3+, RuPu, RuPuZ. <br><br><h3>  ImageMagick &amp; GraphicsMagick <br></h3><br>  Jika kita berbicara tentang bekerja dengan grafik, maka kita tidak bisa tidak menyebutkan orang-orang tua - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ImageMagick</a> dan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraphicsMagick</a> .  Yang terakhir ini awalnya merupakan fork ImageMagick dengan kinerja yang lebih besar, tetapi sekarang kinerja mereka tampaknya sama.  Sejauh yang saya tahu, tidak ada perbedaan mendasar di antara mereka.  Karena itu, Anda dapat menggunakan salah satu, lebih tepatnya, yang Anda sukai. <br><br>  Ini adalah perpustakaan tertua yang saya sebutkan hari ini (1990).  Selama ini, ada beberapa binder untuk Python, dan hampir semuanya sudah mati sekarang.  Dari mereka yang dapat digunakan, ada: <br><br><ul><li>  Mengikat tongkat, yang dibangun di atas ctypes, tetapi juga tidak lagi diperbarui. </li><li>  Pengikatan pgmagick menggunakan Boost.Python, jadi ia mengkompilasi untuk waktu yang sangat lama dan tidak berfungsi di PyPy.  Tetapi, bagaimanapun, Anda dapat menggunakannya, saya akan mengatakan bahwa itu lebih disukai daripada Wand. </li></ul><br><h2>  Performa <br></h2><br>  Ketika kita berbicara tentang bekerja dengan gambar, hal pertama yang menarik minat kita (setidaknya bagi saya) adalah kinerja, karena kalau tidak kita bisa menulis sesuatu dengan Python dengan tangan kita. <br><br>  Kinerja bukanlah hal yang sederhana.  Anda tidak bisa mengatakan bahwa satu perpustakaan lebih cepat dari yang lain.  Setiap perpustakaan memiliki serangkaian fungsi, dan setiap fungsi bekerja pada kecepatan yang berbeda. <br><br>  Oleh karena itu, benar untuk mengatakan hanya bahwa kinerja satu fungsi lebih tinggi atau lebih rendah di perpustakaan tertentu.  Atau Anda memiliki aplikasi yang memerlukan serangkaian fungsi tertentu, dan Anda membuat tolok ukur khusus untuk fungsi ini, dan mengatakan bahwa perpustakaan ini dan itu bekerja lebih cepat (lebih lambat) untuk aplikasi Anda. <br><br><h3>  Penting untuk memeriksa hasilnya. <br></h3><br>  Ketika Anda membuat tolok ukur, sangat penting untuk melihat hasil yang diperoleh.  Bahkan jika pada pandangan pertama Anda menulis kode yang sama, ini tidak berarti bahwa itu sama. <br><br>  Baru-baru ini, dalam sebuah artikel yang membandingkan kinerja Pillow dan OpenCV, saya menemukan kode ini: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  Tampaknya ada di sana, dan di sana, BoxBlur, dan di sana, dan di sana, argumen 3, tetapi pada kenyataannya hasilnya berbeda.  Karena pada Pillow (3) ini adalah radius blur, dan dalam OpenCV ksize = (3, 3) adalah ukuran kernel, yaitu, secara garis besar, diameter.  Dalam hal ini, nilai yang benar untuk OpenCV adalah 3 * 2 + 1, yaitu (7, 7). <br><br><h3>  Apa masalahnya? <br></h3><br>  Mengapa kinerja umumnya menjadi masalah saat bekerja dengan grafik?  Karena kompleksitas dari setiap operasi tergantung pada beberapa parameter, dan paling sering kompleksitas tumbuh secara linear dengan masing-masing parameter.  Dan jika, misalnya, ada tiga faktor ini, dan kompleksitas linear tergantung pada masing-masing, maka kompleksitas dalam kubus diperoleh. <br><br>  <strong>Contoh:</strong> Gaussian blur di OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  Di sebelah kiri adalah jari-jari 3, di sebelah kanan adalah 30. Seperti yang Anda lihat, perbedaan dalam kecepatan lebih dari 10 kali. <br><br>  Ketika saya menghadapi tugas menambahkan Gaussian blur ke aplikasi saya, saya tidak senang bahwa, secara hipotesis, 900 ms dapat dihabiskan untuk satu operasi.  Ada ribuan operasi seperti itu per menit dalam aplikasi, dan menghabiskan begitu banyak waktu untuk satu itu tidak praktis.  Oleh karena itu, saya mempelajari masalah ini dan mengimplementasikan Gaussian blur pada Pillow, yang bekerja dalam waktu konstan relatif terhadap jari-jari.  Artinya, hanya ukuran gambar yang memengaruhi kinerja Gaussian blur. <br><br>  Tetapi hal utama di sini bukanlah sesuatu bekerja lebih cepat atau lebih lambat. <br><br><blockquote>  Saya ingin menyampaikan bahwa ketika Anda sedang membangun semacam sistem, penting untuk memahami parameter apa yang bergantung pada kompleksitas output.  Kemudian Anda dapat membatasi parameter ini atau dengan cara lain untuk mengatasi kompleksitas ini. <br></blockquote><br>  Mungkin operasi paling umum yang kita lakukan dengan gambar setelah dibuka adalah ukuran. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  Grafik menunjukkan kinerja (lebih banyak lebih baik) dari berbagai pustaka untuk operasi pengurangan gambar sebanyak 8 dan 1,25 kali. <br><br>  Untuk PIL, hasil dari 17 Mpx / s berarti bahwa foto dari iPhone (12 Mpx) dapat dikurangi 1,25 kali sedikit dalam waktu kurang dari satu detik.  Performa seperti itu tidak cukup untuk aplikasi serius yang melakukan banyak operasi ini. <br><br>  Saya mulai mengoptimalkan kinerja pengubahan ukuran, dan pada Pillow 2.7 saya berhasil mencapai peningkatan dua kali lipat dalam produktivitas, dan pada Pillow 4.3 - threefold (versi Pillow 5.3 saat ini relevan, tetapi kinerja pengubahan ukuran di dalamnya sama). <br><br>  Tapi operasi pengubahan ukuran adalah hal yang sangat pas di SIMD.  Ia mendekati instruksi tunggal, banyak data, dan oleh karena itu, dalam versi Pillow-SIMD saat ini, saya berhasil <strong>meningkatkan kecepatan mengubah ukuran sebanyak 19 kali</strong> dibandingkan dengan Pustaka Pencitraan Python asli menggunakan sumber daya yang sama. <br><br>  Ini jauh lebih tinggi daripada kinerja pengubahan ukuran OpenCV.  Tetapi perbandingannya tidak sepenuhnya benar, karena OpenCV menggunakan metode pengubahan ukuran yang sedikit kurang berkualitas dengan filter kotak, dan pada Pillow-SIMD, pengubahan ukuran dilakukan menggunakan konvolusi. <br><br>  Ini adalah daftar operasi yang tidak lengkap yang dipercepat dalam Bantal-SIMD dibandingkan dengan Bantal biasa. <br><br><ul><li>  Ubah ukuran: 4 hingga 7 kali. </li><li>  Blur: 2,8 kali. </li><li>  Penerapan inti 3 × 3 atau 5 × 5: 11 kali. </li><li>  Perkalian dan pembagian dengan saluran alfa: 4 dan 10 kali. </li><li>  Komposisi alfa: 5 kali. </li></ul><br>  Saya telah mengatakan bahwa seseorang tidak dapat mengatakan bahwa beberapa perpustakaan bekerja lebih cepat daripada yang lain, tetapi Anda dapat membuat beberapa rangkaian operasi yang menarik bagi Anda.  Saya memilih serangkaian operasi yang menarik dalam aplikasi saya, membuat tolok ukur dan mendapatkan hasil seperti itu. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  Ternyata Pillow-SIMD pada set ini bekerja 2 kali lebih cepat dari Pillow.  Pada akhirnya adalah Wand (ingat bahwa ini adalah ImageMagick). <br><br>  Tapi saya tertarik pada sesuatu yang lain - mengapa OpenCV dan VIPS sangat buruk dalam hasil, karena ini adalah perpustakaan yang juga dirancang dengan maksud untuk kinerja?  Ternyata dalam kasus OpenCV, rakitan OpenCV biner yang diinstal menggunakan pip dirakit dengan codec JPEG lambat (penulis rakitan diberitahu, masalah ini telah dipecahkan untuk 2018).  Itu dibangun dengan libjpeg, sementara sebagian besar sistem, setidaknya berbasis debian, menggunakan libjpeg-turbo, yang beberapa kali lebih cepat.  Jika Anda membuat OpenCV sendiri dari sumbernya, maka kinerjanya akan lebih besar. <br><br>  Dalam kasus VIPS, situasinya berbeda.  Saya menghubungi penulis VIPS, menunjukkan kepadanya tolok ukur ini, dan kami berkorespondensi untuk waktu yang lama dan membuahkan hasil.  Setelah itu, penulis VIPS menemukan beberapa tempat di VIPS itu sendiri, di mana eksekusi tidak pada rute yang optimal, dan memperbaikinya. <br><br>  Itulah yang akan terjadi pada kinerja jika Anda membangun OpenCV dari sumber versi saat ini, dan VIPS dari master, yang sudah ada di sana. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  Bahkan jika Anda menemukan semacam tolok ukur, itu bukan fakta bahwa semuanya akan bekerja dengan kecepatan ini persis di mesin Anda. <br></blockquote><br><h3>  Set tolok ukur <br></h3><br>  Semua tolok ukur yang saya bicarakan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman hasil</a> .  Ini adalah proyek kecil yang terpisah di mana saya menulis tolok ukur yang saya sendiri perlu kembangkan sebagai Pillow-SIMD, menjalankannya dan memposting hasilnya. <br><br>  GitHub memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> dengan kerangka kerja pengujian di mana setiap orang dapat menawarkan tolok ukur sendiri atau memperbaiki yang sudah ada. <br><br><h2>  Pekerjaan paralel <br></h2><br>  Sejauh ini saya telah berbicara tentang kinerja murni, yaitu, pada inti prosesor tunggal.  Tapi kita semua sudah lama memiliki akses ke sistem dengan core lebih banyak, dan saya ingin membuangnya.  Di sini saya harus mengatakan bahwa sebenarnya Bantal adalah satu-satunya perpustakaan dari semua yang tidak menggunakan paralelisasi tugas.  Saya akan mencoba menjelaskan mengapa ini terjadi.  Semua perpustakaan lain dalam satu bentuk atau yang lain menggunakannya. <br><br><h3>  Metrik kinerja <br></h3><br>  Dalam hal kinerja, kami tertarik pada 2 parameter: <br><br><ol><li>  <strong>Real time pelaksanaan satu operasi.</strong>  Ada operasi (atau urutan operasi), dan Anda bertanya-tanya kapan waktu sebenarnya (jam dinding) urutan ini akan dieksekusi.  Parameter ini penting di desktop, di mana ada pengguna yang memberi perintah dan menunggu hasilnya. <br></li><li>  <strong>Throughput seluruh sistem</strong> (alur kerja).  Ketika Anda memiliki serangkaian operasi yang sedang berlangsung, atau banyak operasi independen, dan kecepatan pemrosesan operasi ini pada perangkat keras Anda penting bagi Anda.  Metrik ini lebih penting pada server di mana ada banyak klien, dan Anda harus melayani mereka semua.  Waktu yang diperlukan untuk melayani satu klien penting, tentu saja, tetapi sedikit kurang dari total bandwidth. <br></li></ol><br>  Berdasarkan dua metrik ini, kami mempertimbangkan berbagai cara operasi paralel. <br><br><h3>  Metode Kerja Paralel <br></h3><br>  1. <strong>Pada level aplikasi</strong> , ketika Anda memutuskan pada level aplikasi bahwa operasi diproses dalam utas yang berbeda.  Pada saat yang sama, waktu eksekusi aktual dari satu operasi tidak berubah, karena seperti sebelumnya, satu inti terlibat dalam satu urutan operasi.  Kapasitas sistem meningkat secara proporsional dengan jumlah inti, yaitu sangat baik. <br><br>  2. <strong>Pada tingkat operasi grafis</strong> - itulah yang sebenarnya ada di sebagian besar perpustakaan grafis.  Ketika pustaka grafis menerima beberapa jenis operasi, ia menciptakan jumlah utas yang diperlukan di dalamnya, membagi satu operasi menjadi beberapa yang lebih kecil, dan menjalankannya.  Pada saat yang sama, waktu eksekusi aktual berkurang - satu operasi lebih cepat.  Tetapi <strong>throughput tidak tumbuh secara linear</strong> dengan jumlah core.  Ada operasi yang tidak paralel, dan contoh yang mencolok adalah decoding file PNG - tidak dapat diparalelkan dengan cara apa pun.  Selain itu, ada overhead untuk membuat utas, tugas pemisahan, yang juga tidak memungkinkan bandwidth tumbuh secara linear. <br><br>  3. <strong>Pada tingkat perintah dan data prosesor</strong> .  Kami menyiapkan data dengan cara khusus dan menggunakan perintah khusus untuk membuat prosesor bekerja lebih cepat.  Ini adalah pendekatan SIMD, yang, pada kenyataannya, digunakan dalam Pillow-SIMD.  Waktu runtime real-time menurun, throughput meningkat - <strong>ini</strong> adalah <strong>opsi win-win</strong> . <br><br><h3>  Cara menggabungkan kerja paralel <br></h3><br>  Jika kita ingin menggabungkan kerja paralel, maka SIMD bekerja dengan baik dengan paralelisasi di dalam operasi, dan SIMD bekerja dengan baik dengan paralelisasi di dalam suatu aplikasi. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  Tetapi paralelisasi di dalam aplikasi dan di dalam operasi tidak kompatibel satu sama lain.  Jika Anda mencoba melakukan ini, Anda akan mendapatkan kontra dari kedua pendekatan.  Waktu operasi yang sebenarnya akan sama seperti pada satu inti, dan throughput sistem akan meningkat, tetapi tidak secara linier berkenaan dengan jumlah core. <br><br><h3>  Multithreading <br></h3><br>  Jika kita berbicara tentang utas, kita semua menulis dalam Python dan tahu bahwa ia memiliki GIL yang mencegah dua utas berjalan pada saat yang sama.  Python adalah bahasa yang sangat berurutan tunggal. <br><br>  Tentu saja, ini tidak benar, karena GIL sebenarnya mencegah dua utas dari mengeksekusi di Python, dan jika kode ditulis dalam bahasa lain dan tidak menggunakan struktur internal Python selama operasinya, kode ini dapat melepaskan GIL dan dengan demikian membebaskan penerjemah untuk tugas-tugas lain. <br><br>  Banyak perpustakaan grafis merilis GIL selama bekerja, termasuk Pillow, OpenCV, pyvips, Wand.  Hanya satu pgmagick yang tidak gratis.  Artinya, Anda dapat dengan aman membuat utas untuk melakukan beberapa operasi, dan ini akan bekerja secara paralel dengan sisa kode. <br><br>  Tetapi muncul pertanyaan: <strong>berapa banyak utas yang harus dibuat?</strong> <br><br>  Jika kita membuat jumlah utas yang tak terbatas untuk setiap tugas yang kita miliki, maka mereka hanya mengambil semua memori dan seluruh prosesor - kita tidak akan mendapatkan pekerjaan yang efektif.  Saya merumuskan aturan khusus. <br><br><blockquote>  <strong>Aturan N +1</strong> <br><br>  Untuk pekerjaan produktif, Anda harus membuat tidak lebih dari N + 1 pekerja, di mana N adalah jumlah inti atau benang prosesor pada mesin, dan pekerja adalah proses atau benang yang terlibat dalam pemrosesan. <br></blockquote><br>  Proses paling baik digunakan, karena bahkan dalam juru bahasa yang sama ada hambatan dan overhead. <br><br>  Sebagai contoh, dalam aplikasi kita, N + 1 instance Tornado digunakan, keseimbangan di antaranya dilakukan oleh ngnix.  Jika Tornado disebutkan, maka mari kita bicara tentang operasi asinkron. <br><br><h2>  Operasi asinkron <br></h2><br>  Waktu dimana pustaka grafis benar-benar berguna - pemrosesan gambar - dapat dan harus digunakan untuk input / output, jika Anda memilikinya dalam aplikasi.  Kerangka kerja asinkron sangat relevan di sini. <br><br>  Tetapi ada masalah - ketika kita memanggil semacam pemrosesan, itu disebut secara sinkron.  Bahkan jika perpustakaan merilis GIL pada saat itu, Perulangan Kejadian masih diblokir. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Untungnya, masalah ini sangat mudah dipecahkan dengan membuat ThreadPoolExecutor dengan satu utas di mana pemrosesan gambar dimulai.  Panggilan ini sudah terjadi secara tidak sinkron. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  Intinya, antrian dengan satu pekerja dibuat di sini yang melakukan operasi grafis, dan Peristiwa Peristiwa tidak diblokir dan berjalan diam-diam secara paralel di utas lainnya. <br><br><h2>  Input / output <br></h2><br>  Topik lain yang ingin saya bahas dalam diskusi operasi grafis adalah input / output.  Faktanya adalah bahwa kita jarang membuat gambar apa pun menggunakan pustaka grafis.  Paling sering, kami membuka gambar yang datang kepada kami dari pengguna dalam bentuk file yang disandikan (JPEG, PNG, BMP, TIFF, dll.). <br><br>  Dengan demikian, pustaka grafis untuk membangun aplikasi yang baik harus memiliki beberapa barang untuk input / output dari file. <br><br><h3>  Pemuatan malas <br></h3><br>  Roti seperti itu adalah pemuatan malas.  Jika, misalnya, di Bantal Anda membuka gambar, maka pada saat ini penguraian gambar tidak terjadi.  Anda dikembalikan dengan objek yang tampak seolah-olah gambar sudah dimuat dan berfungsi.  Anda dapat melihat propertinya dan memutuskan berdasarkan pada properti dari gambar ini apakah Anda siap untuk bekerja dengannya lebih jauh, jika pengguna telah mengunduh, misalnya, gambar gigapixel untuk memutuskan layanan Anda. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  Jika Anda memutuskan apa yang harus dilakukan selanjutnya, kemudian menggunakan panggilan eksplisit atau implisit untuk memuat, gambar ini diterjemahkan.  Sudah pada saat ini jumlah memori yang diperlukan dialokasikan. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Mode gambar rusak <br></h3><br>  Sanggul kedua yang diperlukan saat bekerja dengan konten buatan pengguna adalah mode gambar rusak.  File yang kami terima dari pengguna sangat sering mengandung beberapa inkonsistensi dengan format di mana mereka dikodekan. <br><br>  Perbedaan ini terjadi karena berbagai alasan.  Terkadang ini adalah kesalahan transmisi melalui jaringan, kadang-kadang itu hanya semacam codec bengkok yang menyandikan gambar.  Secara default, Pillow, ketika melihat gambar yang tidak sesuai dengan format sampai akhir, hanya melempar pengecualian. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  Tetapi pengguna tidak bisa disalahkan karena fakta bahwa fotonya rusak, ia masih ingin mendapatkan hasilnya.  Untungnya, Bantal memiliki mode gambar yang rusak.  Kami mengubah satu pengaturan, dan Pillow mencoba mengabaikan hingga maksimum semua kesalahan pengodean yang ada dalam gambar.  Dengan demikian, pengguna melihat setidaknya sesuatu. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  Bahkan gambar yang dipangkas masih lebih baik daripada tidak sama sekali - hanya halaman dengan kesalahan. <br><br><h3>  Tabel ringkasan <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  Dalam tabel di atas, saya telah mengumpulkan semua yang berhubungan dengan input / output di perpustakaan yang saya bicarakan.  Secara khusus, saya menghitung jumlah codec dari berbagai format yang ada di perpustakaan.  Ternyata di OpenCV mereka yang paling sedikit, di ImageMagick - paling banyak.  Tampaknya di ImageMagick Anda dapat membuka semua gambar yang Anda temui.  VIPS memiliki 12 codec asli, tetapi VIPS dapat menggunakan ImageMagick sebagai perantara.  Saya belum menguji cara kerjanya, semoga mulus. <br><br>  Bantal memiliki 17 codec.  Sekarang ini adalah satu-satunya pustaka yang tidak ada putar otomatis EXIF.  Tetapi sekarang ini adalah masalah kecil, karena Anda dapat membaca EXIF ​​sendiri dan memutar gambar sesuai dengannya.  Ini adalah pertanyaan tentang cuplikan kecil, yang dengan mudah google dan membutuhkan maksimal 20 baris. <br><br><h3>  Fitur-fitur dari OpenCV <br></h3><br>  Jika Anda melihat tabel ini dengan seksama, Anda dapat melihatnya di OpenCV, pada kenyataannya, tidak semuanya baik dengan input / output.  Ini memiliki jumlah codec paling sedikit, tidak ada pemuatan malas, dan Anda tidak dapat membaca EXIF ​​dan profil warna. <br><br>  Tapi itu belum semuanya.  Faktanya, OpenCV memiliki lebih banyak fitur.  Ketika kita hanya membuka gambar, <code>cv2.imread(filename)</code> memutar file JPEG sesuai dengan EXIF ​​(lihat tabel), tetapi mengabaikan saluran alfa file PNG - perilaku yang agak aneh! <br><br>  Untungnya, OpenCV memiliki flag: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  Jika Anda menentukan flag IMREAD_UNCHANGED, maka OpenCV meninggalkan saluran alpha untuk file PNG, tetapi berhenti memutar file JPEG sesuai dengan EXIF.  Artinya, bendera yang sama mempengaruhi dua properti yang sama sekali berbeda.  Seperti dapat dilihat dari tabel, OpenCV tidak memiliki kemampuan untuk membaca EXIF, dan ternyata dalam kasus flag ini tidak mungkin untuk memutar JPEG sama sekali. <br><br>  Bagaimana jika Anda tidak tahu sebelumnya apa format gambar Anda dan Anda perlu saluran alpha untuk PNG dan auto-rotate untuk JPEG?  Tidak ada hubungannya - OpenCV tidak berfungsi seperti itu. <br><br>  Alasan mengapa OpenCV memiliki masalah seperti itu terletak pada nama perpustakaan ini.  Ini memiliki banyak fungsi untuk visi komputer dan analisis gambar.  Faktanya, OpenCV dirancang untuk bekerja dengan sumber yang diverifikasi.  Ini adalah, misalnya, kamera pengintai luar ruang yang mengambil gambar satu detik sekali dan melakukan ini selama 5 tahun dalam format yang sama dan resolusi yang sama.  Tidak perlu variabilitas dalam masalah I / O. <br><br>  Orang yang membutuhkan fungsionalitas OpenCV tidak benar-benar membutuhkan fungsionalitas konten pengguna. <br><br>  Tetapi bagaimana jika aplikasi Anda masih membutuhkan fungsionalitas untuk bekerja dengan konten pengguna, dan pada saat yang sama Anda membutuhkan semua kekuatan OpenCV untuk pemrosesan dan statistik? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  Solusinya adalah menggabungkan perpustakaan.  Faktanya adalah bahwa OpenCV dibangun berdasarkan numpy, dan Pillow memiliki semua sarana untuk mengekspor gambar dari Pillow ke array numpy.  Artinya, kami mengekspor array numpy, dan OpenCV dapat terus bekerja dengan gambar ini, seperti miliknya sendiri.  Ini dilakukan dengan sangat mudah: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  Lebih lanjut, ketika kita melakukan sihir menggunakan OpenCV (pemrosesan), kita memanggil metode Bantal lain dan mengimpor gambar dari OpenCV kembali ke format Bantal.  Dengan demikian, I / O dapat digunakan kembali. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Jadi, ternyata kami menggunakan input / output dari Pillow, dan pemrosesan dari OpenCV, yaitu, kami mengambil yang terbaik dari dua dunia. <br><br>  Semoga ini membantu Anda membangun aplikasi grafis yang dimuat. <br><br><blockquote>  Anda dapat mempelajari beberapa rahasia pengembangan lainnya dengan Python, belajar dari pengalaman yang tak ternilai dan terkadang tak terduga, dan yang paling penting, Anda dapat mendiskusikan tugas Anda segera di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> .  Misalnya, perhatikan nama dan topik tersebut dalam jadwal. <br><br><ul><li>  Donald Whyte dengan sebuah cerita tentang bagaimana membuat matematika 10 kali lebih cepat menggunakan perpustakaan populer, trik dan kelicikan, dan kodenya dapat dimengerti dan didukung. </li><li>  Andrei Popov adalah tentang mengumpulkan sejumlah besar data dan menganalisisnya untuk ancaman. </li><li>  Ephraim Matosyan dalam laporannya "Make Python fast again" akan memberi tahu Anda cara meningkatkan kinerja daemon yang memproses pesan dari bus. </li></ul><br>  Daftar lengkap apa yang akan dibahas pada 22 dan 23 Oktober di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , punya waktu untuk bergabung. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425471/">https://habr.com/ru/post/id425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425461/index.html">Devops and Security: Wawancara dengan Seth Wargo dan Liz Rice</a></li>
<li><a href="../id425463/index.html">Peta Unity Hexagon: Air, Tengara, dan Dinding Benteng</a></li>
<li><a href="../id425465/index.html">Bagaimana seorang desainer dapat memperoleh lebih banyak, alat yang ideal untuk bekerja dan mencari ide</a></li>
<li><a href="../id425467/index.html">Mesin Renault D4F> B4D (alias SCe). Perubahan generasi. Tampilan pengendara</a></li>
<li><a href="../id425469/index.html">Penulis Python tidak lagi memimpin pengembangan. Apakah ini akan membuat bahasa menjadi lebih baik atau lebih buruk?</a></li>
<li><a href="../id425473/index.html">Konferensi tentang Python dan tentang komunikasi</a></li>
<li><a href="../id425475/index.html">Robot kolaborasi universal Robots di IMTS 2018 di Chicago</a></li>
<li><a href="../id425477/index.html">Webmaster Skillbox Friday: Dari Memilih Bahasa Pemrograman hingga Menemukan Perusahaan Anda</a></li>
<li><a href="../id425479/index.html">Segera setengah dari panggilan akan dari robot. Kiat: jangan jawab (?)</a></li>
<li><a href="../id425483/index.html">Weekend Reading: 22 artikel tentang sejarah perusahaan audio legendaris dan bagaimana mereka "membuat suara"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>