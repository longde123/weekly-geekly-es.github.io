<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üö£üèº ‚õπüèº UDB Que es esto Parte 3. Datapath FIFO ü§∑üèª üëèüèæ üö≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos traduciendo la documentaci√≥n patentada de Cypress a bloques UDB. Adem√°s, todo coincide muy bien. Para continuar el art√≠culo pr√°ctico sobre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB Que es esto Parte 3. Datapath FIFO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434706/"><img src="https://habrastorage.org/webt/et/v5/rr/etv5rr-xdmsl0tyw4vtp_doh75k.jpeg"><br><br>  Continuamos traduciendo la documentaci√≥n patentada de Cypress a bloques UDB.  Adem√°s, todo coincide muy bien.  Para continuar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo pr√°ctico sobre UDB,</a> necesitar√° usar FIFO, y en la parte te√≥rica llegamos a la descripci√≥n de ellos.  Por lo tanto, comenzamos a estudiarlos en detalle. <br><a name="habracut"></a><br>  El contenido general del ciclo ‚ÄúUDB.  ¬øQu√© es esto? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1. Introducci√≥n.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pld.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Ruta de datos.</a> <br>  Parte 3. Datapath FIFO.  (Art√≠culo actual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4. Datapath ALU.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5. Ruta de datos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Peque√±as cosas √∫tiles.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6. M√≥dulo de gesti√≥n y estado.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7. M√≥dulo de control de temporizaci√≥n y reinicio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8. Abordar UDB</a> <br><br><h2>  21.3.2.2 Ruta de datos FIFO </h2><br><h3>  Modos y configuraciones FIFO </h3><br>  Cada b√∫fer FIFO tiene varios modos operativos y configuraciones disponibles: <br><br>  Tabla 21-2.  Modos y configuraciones FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  El modo </th><th>  Descripci√≥n </th></tr><tr><td>  Entrada / salida <br>  (B√∫fer de entrada / salida) </td><td>  En el modo de b√∫fer de entrada, la CPU o DMA escribe <br>  datos en FIFO, y Datapath lo lee.  En modo <br>  los datos del b√∫fer de salida entran al FIFO desde <br>  Datapath, y los lee desde all√≠ CPU o DMA. </td></tr><tr><td>  Tamp√≥n individual <br>  (B√∫fer √∫nico) </td><td>  FIFO funciona como un √∫nico b√∫fer sin estado. <br>  Los datos registrados en FIFO se pueden leer de inmediato y pueden <br>  ser sobrescrito en cualquier momento. </td></tr><tr><td>  Nivel / borde <br>  (Nivel / Delta) </td><td>  El par√°metro responsable de cargar FIFO desde Datapath, <br>  Se puede activar por nivel o por diferencial. </td></tr><tr><td>  Normal / r√°pido <br>  (Normal / r√°pido) </td><td>  Par√°metro responsable de cargar FIFO desde la fuente <br>  Datapath: se registra a la frecuencia de la seleccionada para Datapath <br>  fuente de reloj (normal) o frecuencia de bus (r√°pida). <br>  Esto le permite capturar a la frecuencia m√°s alta. <br>  en el sistema (frecuencia del bus), independientemente de la frecuencia del reloj Datapath. </td></tr><tr><td>  Captura de software <br>  (Captura de software) </td><td>  Cuando este modo est√° activado y FIFO est√° en modo <br>  b√∫fer de salida, leer CPU o DMA relacionados <br>  bater√≠a (A0 para F0, A1 para F1), inicializa <br>  Transfiera sincr√≥nicamente el valor de la bater√≠a a FIFO. <br>  El valor capturado se puede leer inmediatamente desde FIFO. <br>  Si el soporte de encadenamiento est√° activado, <br>  la operaci√≥n seguir√° la cadena hasta el bloque MS para que <br>  Datapath podr√≠a realizar una lectura at√≥mica de multibyte <br>  valores </td></tr><tr><td>  Asynch <br>  (Asincr√≥nico) </td><td>  Cuando los relojes Datapach y del bus del sistema no est√°n <br>  sincronizado, las se√±ales de estado FIFO pueden ser <br>  reenviado al resto de datapath <br>  directamente, sincronizado desde la frecuencia de reloj Datapath, <br>  o con doble sincronizaci√≥n, en modo Asynch. </td></tr><tr><td>  Polaridad de reloj independiente <br>  (Polaridad del reloj independiente) </td><td>  Cada FIFO tiene un bit de control para invertir <br>  La polaridad del reloj FIFO versus el reloj Datapath. </td></tr></tbody></table></div><br>  La Figura 21-7 muestra las posibles opciones de configuraci√≥n para el par FIFO, dependiendo de los modos de Entrada / Salida seleccionados para cada uno de ellos.  Si un FIFO est√° en el modo de entrada y el otro en el modo de salida, obtenemos la configuraci√≥n RX / TX.  Un ejemplo t√≠pico donde se necesita dicha configuraci√≥n es el controlador de bus SPI.  La configuraci√≥n de <b>captura dual</b> (ambos FIFO est√°n configurados para la salida) proporciona una captura independiente del par A0 y A1 o dos capturas independientes de los registros A0 o A1.  Finalmente, en el modo <b>Dual Buffer</b> (ambos en la entrada), es posible usar un par de registros o dos registros independientes para cargar o comparar. <br><br><img src="https://habrastorage.org/webt/jw/ii/lz/jwiilz_qkbulrpqu4n1xahxnsjq.png"><br><br>  Figura 21-7.  Configuraciones FIFO. <br><br>  La figura 21-8 muestra en detalle las fuentes y los receptores para FIFO. <br><br><img src="https://habrastorage.org/webt/lj/rf/4l/ljrf4lqn5lyyq2xsi6sml5ywi5o.png"><br><br>  Figura 21-8.  Fuentes FIFO y receptores. <br><br>  Cuando FIFO funciona en el modo de b√∫fer de entrada, la fuente es el bus del sistema y los receptores son los registros Dx y Ax.  Cuando se trabaja en el modo de b√∫fer de salida, las fuentes son los registros Ax y ALU, y el receptor es el bus del sistema.  La selecci√≥n del multiplexor se establece est√°ticamente en el registro de configuraci√≥n UDB CFG15, como se muestra en la tabla para F0_INSEL [1: 0] o F1_INSEL [1: 0]: <br><br>  Tabla 21-3.  Un conjunto de multiplexores FIFO en el registro de configuraci√≥n UDB. <br><div class="scrollable-table"><table><tbody><tr><th>  Fx_INSEL [1: 0] </th><th>  Descripci√≥n </th></tr><tr><td>  00 </td><td>  Modo de b√∫fer de entrada: el bus del sistema escribe en FIFO, mientras que el receptor <br>  FIFO es Ax o Dx. </td></tr><tr><td>  01 </td><td>  Modo de b√∫fer de salida: la fuente FIFO es A0 y el receptor <br>  FIFO - bus del sistema. </td></tr><tr><td>  10 </td><td>  Modo de b√∫fer de salida: la fuente de FIFO es A1, y el receptor <br>  FIFO - bus del sistema. </td></tr><tr><td>  11 </td><td>  Modo de b√∫fer de salida: la fuente FIFO es la salida ALU y el receptor <br>  FIFO - bus del sistema. </td></tr></tbody></table></div><br><h3>  Estado FIFO </h3><br>  Cada FIFO genera dos se√±ales de estado, "bus" y "bloque", que se transmiten a los recursos de rastreo UDB a trav√©s del multiplexor de salida Datapath.  El estado del bus se puede usar para interrumpir o solicitar una lectura / escritura de DMA al FIFO.  El estado de "bloque" est√° destinado principalmente a pasar el estado FIFO a entidades UDB internas.  El prop√≥sito de los bits de estado depende de la direcci√≥n configurada (Fx_INSEL [1: 0]) y de los bits de nivel FIFO.  Los bits de nivel FIFO (Fx_LVL) se establecen en el registro de control auxiliar en el espacio de registro de trabajo.  Las opciones de estado se muestran en la siguiente tabla: <br><br>  Tabla 21-4.  Opciones de estado FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  Fx_INSEL [1: 0] </th><th>  Fx_lvl </th><th>  Condici√≥n </th><th>  Se√±al </th><th>  Descripci√≥n </th></tr><tr><td>  Entrar </td><td>  0 0 </td><td>  No lleno </td><td>  Estado del bus </td><td>  Ladeado cuando hay un FIFO <br>  colocar por al menos un byte. </td></tr><tr><td>  Entrar </td><td>  1 </td><td>  Devastado <br>  al menos <br>  medio </td><td>  Estado del bus </td><td>  Ladeado cuando hay un FIFO <br>  espacio para al menos 2 bytes. </td></tr><tr><td>  Entrar </td><td>  N / A </td><td>  Esta vacio </td><td>  Estado del bloque </td><td>  Ladeado cuando no hay FIFO <br>  Ni un solo byte. <br>  Cuando FIFO no est√° vac√≠o, Datapath <br>  puede leer bytes <br>  Cuando FIFO est√° vac√≠o, Datapath <br>  puede ser capaz <br>  las expectativas generan <br>  estado de devastaci√≥n </td></tr><tr><td></td></tr><tr><td>  Conclusi√≥n </td><td>  0 0 </td><td>  No vacio </td><td>  Estado del bus </td><td>  Ladeado cuando en FIFO <br>  al menos 1 byte disponible <br>  para leer </td></tr><tr><td>  Conclusi√≥n </td><td>  1 </td><td>  Esta lleno <br>  al menos <br>  medio </td><td>  Estado del bus </td><td>  Armado cuando est√° disponible en FIFO <br>  al menos 2 bytes para leer. </td></tr><tr><td>  Conclusi√≥n </td><td>  N / A </td><td>  Esta lleno </td><td>  Estado del bloque </td><td>  Ladeado cuando FIFO est√° lleno. <br>  Cuando FIFO no est√° completo, Datapath <br>  puede escribir bytes en FIFO. <br>  Cuando FIFO est√° lleno, Datapath <br>  puede estar en <br>  en espera o <br>  generar condici√≥n <br>  desbordamiento </td></tr></tbody></table></div><br><h3>  Ilustraci√≥n de trabajo FIFO </h3><br>  La figura 21-9 muestra una secuencia t√≠pica de lectura y escritura, as√≠ como la generaci√≥n de estados asociados con estas operaciones.  En la figura, la lectura y la escritura ocurren en diferentes momentos, pero pueden realizarse simult√°neamente. <br><br><img src="https://habrastorage.org/webt/pp/kr/-p/ppkr-pcweqaiz61mam-o3d4oeti.png"><br><br>  Figura 21-9 Funcionamiento de los receptores FIFO. <br><br><h3>  Modo r√°pido FIFO (FIFO FAST) </h3><br>  Cuando FIFO est√° en modo de b√∫fer de salida, la operaci√≥n de arranque FIFO generalmente usa la frecuencia de reloj del Datapath seleccionado para registrar la se√±al de escritura.  Como se muestra en la Figura 21-10, al seleccionar el modo r√°pido FIFO (FIFO FAST), puede seleccionar la frecuencia del bus para esta operaci√≥n en particular.  Cuando se usa junto con el modo <b>Nivel / Borde = Borde</b> , esta operaci√≥n reduce el retraso de transmisi√≥n de la bater√≠a al FIFO desde el per√≠odo del reloj Datapath al per√≠odo del reloj del bus, ya que la frecuencia del bus puede ser mucho mayor.  Esto permite que la CPU o el DMA lean el resultado FIFO recibido con un retraso m√≠nimo. <br><br>  Como se muestra en la Figura 21-10, la operaci√≥n de arranque r√°pido se realiza independientemente del reloj Datapath actual, sin embargo, el uso de la velocidad del reloj del bus puede aumentar el consumo de energ√≠a. <br><br><img src="https://habrastorage.org/webt/au/4c/0i/au4c0iq5pfcnnebsvxxq1hmf-zu.png"><br><br>  Figura 21-10.  FIFO receptores de configuraci√≥n r√°pida. <br><br><h3>  Modo de grabaci√≥n FIFO Edge / Level (diferencial / nivel) </h3><br>  Hay dos modos de grabaci√≥n en FIFO desde Datapath.  En el primer modo, los datos se transfieren sincr√≥nicamente desde las bater√≠as al FIFO.  La se√±al de control de este registro (FX_LD) generalmente es generada por una m√°quina de estado o por una condici√≥n sincronizada con el reloj Datapath.  La escritura en FIFO se realizar√° en cualquier ciclo en el que la se√±al de control de carga de entrada sea '1'.  En el segundo modo, FIFO se utiliza para capturar los valores de la bater√≠a en respuesta a un borde positivo de la se√±al FX_LD.  En este modo, el formato de la se√±al de la se√±al es arbitrario (sin embargo, su per√≠odo debe ser igual a al menos un ciclo de reloj Datapath).  Un ejemplo de este modo es capturar el valor de la bater√≠a utilizando la entrada del pie externo como disparador.  Una limitaci√≥n de este modo es que el par√°metro de entrada debe volver al valor '0' al menos un ciclo antes de que se detecte otra diferencia positiva. <br><br>  La figura 21-11 muestra la implementaci√≥n del modo de detecci√≥n diferencial en la entrada FX_LD.  El modo de ambos FIFO en UDB est√° controlado por el mismo bit, alternando esta opci√≥n.  Tenga en cuenta que la detecci√≥n diferencial se sincroniza a una frecuencia igual a la frecuencia del FIFO seleccionado. <br><br><img src="https://habrastorage.org/webt/xv/hq/u8/xvhqu8l5xwjgn-4aaww9ru8tkli.png"><br><br>  Figura 21-11.  Detecci√≥n diferencial para receptores de grabaci√≥n FIFO internos. <br><br><h3>  Modo de captura de software FIFO </h3><br>  Un requisito com√∫n e importante es permitir que la CPU y el DMA lean de manera confiable el contenido de la bater√≠a durante el funcionamiento normal.  Esto se realiza mediante la captura de software y se habilita mediante el bit de configuraci√≥n FIFO Cap.  Este bit se aplica a ambos FIFO en UDB, pero solo funciona cuando el FIFO est√° en modo de b√∫fer de salida.  Cuando se utiliza la captura de software, F0 debe leer de A0 y F1 de A1. <br><br>  Como se muestra en la Figura 21-12, la lectura de la bater√≠a inicia la escritura en el FIFO desde la bater√≠a.  La se√±al est√° vinculada en una cadena para que al leer un byte espec√≠fico al mismo tiempo capture los valores de bater√≠a de todos los UDB en la cadena.  Esto permite que el procesador de 8 bits lea con √©xito 16 bits o m√°s al mismo tiempo.  Los datos devueltos al leer la bater√≠a deben ignorarse, y el valor capturado puede leerse inmediatamente desde FIFO. <br><br>  La se√±al rastreada FX_LD, que genera la carga FIFO, se env√≠a al t√©rmino OR junto con la se√±al de captura del programa.  Cuando se utiliza la captura de hardware y software al mismo tiempo, el resultado puede ser impredecible.  Como regla general, estas funciones deben ser mutuamente excluyentes, sin embargo, la captura de hardware y software puede usarse simult√°neamente bajo las siguientes condiciones: <br><br><ul><li>  El modo de reloj de captura FIFO est√° configurado en FIFO FAST. </li><li>  El modo de grabaci√≥n FIFO est√° configurado en FIFO EDGE. </li></ul><br>  En las condiciones descritas anteriormente, la captura de hardware y software funciona esencialmente de la misma manera, y durante cualquier ciclo de reloj del bus, cualquiera de estas se√±ales puede desencadenar una captura. <br><br>  Tambi√©n se recomienda que borre el FIFO de destino en el c√≥digo del programa (registro ACTL) antes de que comience la captura del programa.  Gracias a esto, los punteros de lectura y escritura FIFO se establecer√°n en un estado conocido. <br><br><img src="https://habrastorage.org/webt/0n/c7/zg/0nc7zgc7je5sn3emupt2ij7kdc0.png"><br><br>  Figura 21-12.  Configuraci√≥n de captura de software. <br><br>  <i><b>Nota del traductor:</b></i> <i><br></i>  <i>Durante mucho tiempo no pude entender el significado de esta secci√≥n.</i>  <i>Luego, durante mucho tiempo, estuve seguro de que la secci√≥n fue escrita para PSoC3, cuyo n√∫cleo de ocho bits no puede acceder m√°s que un byte.</i>  <i>Pero al crear la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octava parte de la traducci√≥n</a> , result√≥ que incluso en PSoC5LP, para todos los n√∫cleos de procesador ARM de 32 bits, el acceso a los registros UDB en funcionamiento se puede llevar a cabo en modo de ocho o diecis√©is bits.</i>  <i>A juzgar por el documento, no m√°s.</i>  <i>Aqu√≠ es donde la funcionalidad descrita resulta √∫til.</i> <i><br></i> <br><br><h3>  Bits de control FIFO </h3><br>  El registro de control auxiliar, que puede usarse para controlar FIFO durante el funcionamiento normal, contiene 4 bits. <br><br>  Los bits FIFO0 CLR y FIFO1 CLR se utilizan para restablecer o borrar FIFOs.  Cuando a uno de estos bits se le asigna el valor '1', el FIFO asociado se restablece.  El bit debe restaurarse a su valor original ('0') para que FIFO contin√∫e funcionando.  Si el valor del bit permanece igual a uno, el FIFO correspondiente se desactivar√° y funcionar√° como un b√∫fer de un solo byte sin estado.  Los datos se pueden escribir en FIFO, los datos se pueden leer de inmediato y se pueden sobrescribir en cualquier momento.  La direcci√≥n de datos con los bits de configuraci√≥n FX INSEL [1: 0] a√∫n se puede establecer. <br><br>  Los bits FIFO0 LVL y FIFO1 LVL determinan el nivel en el que FIFO activar√° el bit de estado <b>"bus"</b> (cuando el bus lee o escribe en FIFO).  Es decir, el estado del <b>"bus"</b> depende de la direcci√≥n dada, como se muestra en la tabla a continuaci√≥n. <br><br>  Tabla 21-5.  Bits de control de nivel FIFO <br><div class="scrollable-table"><table><tbody><tr><th>  FIFO LVL </th><th>  Modo buffer de entrada <br>  (el autob√∫s escribe a FIFO) </th><th>  Modo buffer de salida <br>  (el autob√∫s lee de FIFO) </th></tr><tr><td>  0 0 </td><td>  No lleno <br>  Se puede escribir al menos 1 byte. </td><td>  No vacio <br>  Se puede leer al menos 1 byte. </td></tr><tr><td>  1 </td><td>  Vaciar al menos hasta la mitad <br>  Se pueden escribir al menos 2 bytes. </td><td>  Medio lleno <br>  Se pueden leer al menos 2 bytes. </td></tr></tbody></table></div><br><h3>  Operaci√≥n asincr√≥nica FIFO </h3><br>  La figura 21-13 muestra el principio del funcionamiento asincr√≥nico de FIFO.  Como ejemplo, imagine que F0 opera en el modo de b√∫fer de entrada y F1 en el modo de b√∫fer de salida, que es una configuraci√≥n t√≠pica de los registros TX y RX. <br><br><img src="https://habrastorage.org/webt/ct/ei/lo/cteilo6ne7nn0ah0hprjtkbawvo.png"><br><br>  Figura 21-13.  Operaci√≥n asincr√≥nica FIFO. <br><br>  En el lado de TX, la m√°quina de estado de Datapath utiliza el indicador <b>Vac√≠o</b> para determinar si hay bytes disponibles para recibir.  El valor de <b>Vac√≠o</b> se establece sincr√≥nicamente con la m√°quina de estado Datapath, y se borra de forma asincr√≥nica debido a la escritura desde el bus.  Despu√©s de la limpieza, el estado se sincroniza nuevamente con la m√°quina de estado Datapath. <br><br>  En el lado RX, la m√°quina de estado RX usa <b>Full</b> para determinar si hay espacio libre para escribir en el FIFO.  El valor <b>Completo</b> se establece de forma sincr√≥nica con la m√°quina de estado Datapath, y se borra de forma asincr√≥nica debido a la lectura del bus.  Despu√©s de la limpieza, el estado se sincroniza nuevamente con la m√°quina de estado Datapath. <br><br>  Se utiliza un bit FIFO ASYNCH para habilitar este m√©todo de sincronizaci√≥n, despu√©s de la activaci√≥n, este m√©todo se aplica a ambos FIFO. <br><br>  Se aplica solo al estado de <b>Bloque</b> , ya que se supone que el estado de <b>Bus</b> est√° naturalmente sincronizado por el proceso de interrupci√≥n. <br><br>  Cuadro 21-6.  <b>Bloquee</b> las opciones de sincronizaci√≥n de estado FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  As√≠ncrono </th><th>  AGREGAR SINCRONIZACI√ìN </th><th>  Operaci√≥n </th><th>  Modelo de uso </th></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  Sincronizado con sincronizaci√≥n de bus </td><td>  Cambios de estado de escritura / lectura de CPU <br>  ocurrir a la frecuencia del bus.  Puede <br>  utilizar por m√≠nimo <br>  retrasos si puedes lograr <br>  Frecuencias de reloj de parche de datos <br>  igual a la frecuencia del bus. </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  Resincronizaci√≥n de frecuencia <br>  neum√°ticos a la frecuencia de Datapath. </td><td>  Este modo deber√≠a ser <br>  modo de operaci√≥n predeterminado.  Cuando <br>  La CPU realiza operaciones de lectura / escritura, <br>  el cambio de estado se volver√° a sincronizar <br>  con la frecuencia utilizada en Datapath. <br>  Permite utilizar el completo <br>  Periodo de frecuencia de ruta de datos para establecer <br>  se√±al para l√≥gica UDB. </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  Reservado </td><td>  - </td></tr><tr><td>  1 </td><td>  1 </td><td>  Sincronizaci√≥n de doble frecuencia <br>  neum√°ticos a la frecuencia de Datapath. </td><td>  Cuando el reloj pulsa para Datapath <br>  no solo no est√° sincronizado con <br>  sist√©mica en frecuencia pero tambi√©n <br>  producido por separado <br>  generador independiente <br>  este par√°metro puede ser <br>  utilizado para doble <br>  operaciones de sincronizaci√≥n <br>  leer y escribir cpu <br>  con reloj Datapath. </td></tr></tbody></table></div><br><h3>  FIFO desbordamiento durante la operaci√≥n </h3><br>  Para la implementaci√≥n segura de operaciones de lectura y escritura internas (Datapath) y externas (CPU o DMA), se deben usar se√±ales de estado FIFO.  No hay protecci√≥n incorporada contra condiciones de vaciado y desbordamiento.  Si la FIFO est√° llena y se realizan operaciones de escritura posteriores (desbordamiento), los nuevos datos sobrescriben el comienzo de la FIFO (los datos que se emiten actualmente son los siguientes en la cola de lectura).  Si el FIFO est√° vac√≠o y se realizan lecturas posteriores (vaciado o agotamiento), el valor de lectura no est√° definido.  Los punteros FIFO siguen siendo precisos independientemente del subdesbordamiento y desbordamiento. <br><br><h3>  Inversi√≥n de reloj FIFO </h3><br>  Cada FIFO tiene un bit de control Fx CK INV, que es responsable de la polaridad del reloj FIFO con respecto a la polaridad del reloj Datapath.  Por defecto, FIFO funciona con la misma polaridad que el reloj Datapath.  Cuando este bit es 1, FIFO funciona con polaridad inversa en relaci√≥n con Datapath.  Esto proporciona soporte de protocolo para intercambiar datos en ambos frentes, como SPI. <br><br><h3>  Control din√°mico FIFO </h3><br>  Normalmente, los FIFO se configuran est√°ticamente en el modo de b√∫fer de entrada o en el modo de b√∫fer de salida.  Alternativamente, cada FIFO puede configurarse para operar en un modo en el que la direcci√≥n se controla din√°micamente (bajo la influencia de se√±ales externas).  Un bit de configuraci√≥n por FIFO (Fx DYN) es responsable de activar este modo.  La Figura 21-14 muestra las configuraciones disponibles en el modo din√°mico FIFO. <br><br><img src="https://habrastorage.org/webt/ny/ei/vo/nyeivo9hrnmr6vg8tkcbnnkaz8i.png"><br><br>  Figura 21-14.  Modo din√°mico FIFO. <br><br>  En el modo de acceso interno, Datapath puede leer y escribir en FIFO.  En esta configuraci√≥n, para seleccionar la fuente de operaciones de escritura en FIFO, los bits Fx INSEL deben establecerse en 1. Fx INSEL = 0 (fuente del bus de CPU) en este modo es incorrecto, solo puede tomar los valores 1, 2 o 3 (A0, A1 o ALU )  Vale la pena se√±alar que la lectura solo tiene acceso a la bater√≠a adecuada, la direcci√≥n de los registros de datos en este modo no est√° disponible. <br><br>  En el modo de acceso externo, la CPU o el DMA pueden leer o escribir en FIFO. <br><br>  La configuraci√≥n cambia din√°micamente entre acceso externo e interno mediante el reenv√≠o de se√±ales de Datapath.  Para esto, se utilizan las se√±ales de entrada Datapath d0_load y d1_load.  Vale la pena se√±alar que en el modo de control din√°mico, d0_load y d1_load no est√°n disponibles para su uso normal al cargar registros D0 / D1 desde F0 / F1.  Las se√±ales Dx_load pueden ser activadas por cualquier se√±al de rastreo, incluidas las constantes. <br><br>  Considere un ejemplo en el que, comenzando con el acceso externo (dx_load == 1), la CPU o el DMA pueden escribir uno o m√°s bytes de datos en la FIFO.  Luego, al cambiar al acceso interno (dx_load == 0), Datapath puede realizar operaciones en los datos.  Despu√©s de eso, al cambiar a acceso externo, la CPU o DMA puede leer el resultado de los c√°lculos. <br>  Como Fx INSEL siempre debe ser 01, 10 u 11 (A0, A1 o ALU), que corresponde al "modo de b√∫fer de salida" durante el funcionamiento normal, las se√±ales de estado FIFO tienen las siguientes definiciones (seg√∫n el par√°metro Fx LVL): <br><br>  Cuadro 21-7.  Estado FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  Se√±al de estado </th><th>  Valor </th><th>  Fx LVL = 0 </th><th>  Fx LVL = 1 </th></tr><tr><td>  fx_blk_stat </td><td>  Estado de registro </td><td>  FIFO est√° lleno </td><td>  FIFO est√° lleno </td></tr><tr><td>  fx_bus_stat </td><td>  Estado de lectura </td><td>  FIFO no est√° completo </td><td>  Medio lleno </td></tr></tbody></table></div><br>  Dado que tanto Datapath como la CPU pueden escribir y leer desde FIFO, estas se√±ales ya no se consideran estados de bloque y bus.  La se√±al blk_stat se usa para el estado de escritura y la se√±al bus_stat para el estado de lectura <br><br><h2>  21.3.2.3 Estado FIFO </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay cuatro se√±ales de estado FIFO, dos para cada FIFO: fifo0_bus_stat, fifo0_blk_stat, fifo1_bus_stat y fifo1_blk_stat. </font><font style="vertical-align: inherit;">El significado de estas se√±ales depende de la direcci√≥n de la FIFO particular, que est√° determinada por la configuraci√≥n est√°tica. </font><font style="vertical-align: inherit;">El estado FIFO se describe en detalle en la secci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21.3.2.2 Datapath FIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la siguiente parte, pasaremos al an√°lisis de la Unidad de l√≥gica aritm√©tica (ALU).</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434706/">https://habr.com/ru/post/es434706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434696/index.html">Los empleados de gigantes de TI descubrieron c√≥mo influir en las pol√≠ticas de sus empresas</a></li>
<li><a href="../es434698/index.html">Pesimismo sobre el multiproceso</a></li>
<li><a href="../es434700/index.html">Ventajas de seguir las gu√≠as de estilo al desarrollar aplicaciones angulares</a></li>
<li><a href="../es434702/index.html">¬øPor qu√© el SSD moderno me bloquea?</a></li>
<li><a href="../es434704/index.html">Razones para la disminuci√≥n del costo del tr√°fico m√≥vil en Rusia y el pron√≥stico para 2019</a></li>
<li><a href="../es434708/index.html">HL 2018. Resumen del informe "¬°Haga que las contrase√±as vuelvan a ser geniales! C√≥mo vencer a la fuerza bruta y dejar a los hackers sin nada "</a></li>
<li><a href="../es434710/index.html">Blog de RUVDS sobre Habr: a√±o en tres</a></li>
<li><a href="../es434712/index.html">Tercera prueba de Turing en ruso</a></li>
<li><a href="../es434714/index.html">Sincronizaci√≥n de solicitud de cliente en Spring</a></li>
<li><a href="../es434716/index.html">Mudarse al centro de datos: preparaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>