<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèæ üßëüèø‚Äçü§ù‚Äçüßëüèª üè≥Ô∏è Compara√ß√£o de bibliotecas CLI populares para Python: click, cement, fire e outras üîê ü§ï üïäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Python √© uma √≥tima linguagem para aplicativos de console e destaca um grande n√∫mero de bibliotecas para essas tarefas. Mas quais bibliotecas existem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compara√ß√£o de bibliotecas CLI populares para Python: click, cement, fire e outras</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466999/"><img src="https://habrastorage.org/webt/rp/ek/be/rpekben_u6jtlwru-flsslxk70e.png"><br><br>  O Python √© uma √≥tima linguagem para aplicativos de console e destaca um grande n√∫mero de bibliotecas para essas tarefas.  <i>Mas quais bibliotecas existem?</i>  <i>E qual √© o melhor para levar?</i>  Este material compara ferramentas populares e n√£o muito para o mundo dos consoles e tenta responder √† segunda pergunta. <br><br>  Para facilitar a leitura, a revis√£o √© dividida em duas postagens: a primeira compara as seis bibliotecas mais populares, a segunda - a menos popular e mais espec√≠fica, mas ainda digna de aten√ß√£o. <br><a name="habracut"></a><br>  Em cada exemplo, um utilit√°rio de console para a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">todolib</a> ser√° gravado no Python 3.7, com o qual voc√™ pode criar, exibir, marcar e excluir tarefas.  O restante ser√° adicionado, sujeito √† simplicidade da implementa√ß√£o em uma estrutura espec√≠fica.  As pr√≥prias tarefas s√£o armazenadas em um arquivo json, que ser√° salvo em uma chamada separada - uma condi√ß√£o adicional para os exemplos. <br>  Al√©m disso, um teste trivial ser√° gravado para cada implementa√ß√£o.  O Pytest com os seguintes equipamentos foi usado como uma estrutura de teste: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(autouse=True) def db(monkeypatch): """ monkeypatch     ,        """ value = {"tasks": []} monkeypatch.setattr(todolib.TodoApp, "get_db", lambda _: value) return value @pytest.yield_fixture(autouse=True) def check(db): """      """ yield assert db["tasks"] and db["tasks"][0]["title"] == "test" # ,      EXPECTED = "Task 'test' created with number 1.\n"</span></span></code> </pre> <br>  Em princ√≠pio, todas as op√ß√µes acima ser√£o suficientes para demonstrar as bibliotecas.  O c√≥digo fonte completo est√° dispon√≠vel <a href="">neste</a> reposit√≥rio. <br><br><h2>  argparse </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Argparse</a> tem uma vantagem ineg√°vel - est√° na biblioteca padr√£o e sua API n√£o √© dif√≠cil de aprender: existe um analisador, h√° argumentos, os argumentos t√™m <i>tipo</i> , <i>a√ß√£o</i> , <i>dest</i> , <i>padr√£o</i> e <i>ajuda</i> .  E h√° <i>subparser</i> - a capacidade de separar parte dos argumentos e da l√≥gica em comandos separados. <br><br><h4>  Analisador </h4><br>  √Ä primeira vista - nada de anormal, o analisador √© como um analisador.  Mas - na minha opini√£o - a legibilidade n√£o √© a melhor quando comparada com outras bibliotecas, porque  argumentos para diferentes comandos s√£o descritos em um s√≥ lugar. <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> parser = argparse.ArgumentParser(<span class="hljs-string"><span class="hljs-string">"Todo notes - argparse version"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, <span class="hljs-string"><span class="hljs-string">"-v"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Enable verbose mode"</span></span> ) parser.add_argument(<span class="hljs-string"><span class="hljs-string">"--version"</span></span>, <span class="hljs-string"><span class="hljs-string">"-V"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show version"</span></span>) subparsers = parser.add_subparsers(title=<span class="hljs-string"><span class="hljs-string">"Commands"</span></span>, dest=<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>) add = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>) add.add_argument(<span class="hljs-string"><span class="hljs-string">"title"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Todo title"</span></span>) show = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"show"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show tasks"</span></span>) show.add_argument( <span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks in the output"</span></span> ) done = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"done"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>) done.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) remove = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"remove"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Remove task"</span></span>) remove.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser</code> </pre><br></div></div><br><h4>  principal </h4><br>  E aqui a mesma coisa - o analisador, exceto os argumentos de an√°lise, n√£o pode fazer mais nada; portanto, a l√≥gica ter√° que ser escrita independentemente e em um s√≥ lugar.  Por um lado - √© poss√≠vel viver, por outro - √© poss√≠vel melhor, mas ainda n√£o est√° claro como. <br><br>  <b>UPD:</b> <i>Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">foldr</a> observou, de fato, os subparsers podem definir fun√ß√µes via set_defaults (func = foo), ou seja, argparse permite reduzir o tamanho principal para o tamanho pequeno.</i>  <i>Viva e aprenda.</i> <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(raw_args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Argparse example entrypoint """</span></span> parser = get_parser() args = parser.parse_args(raw_args) logging.basicConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.verbose: logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(logging.INFO) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.version: print(lib_version) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) cmd = args.cmd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> cmd: parser.print_help() exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"add"</span></span>: task = app.add_task(args.title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"show"</span></span>: app.print_tasks(args.show_done) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"done"</span></span>: task = app.task_done(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"remove"</span></span>: task = app.remove_task(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Teste </h4><br>  Para verificar a sa√≠da do utilit√°rio, √© <i>usado</i> o acess√≥rio <i>capsys</i> , que fornece acesso ao texto de stdout e stderr. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_argparse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_argparse.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Sum√°rio </h4><br>  Das vantagens - um bom conjunto de recursos para an√°lise, a presen√ßa de um m√≥dulo na biblioteca padr√£o. <br><br>  Em contrapartida, a argparse est√° envolvida apenas na an√°lise de argumentos, a maior parte da l√≥gica principal teve que ser escrita por mim.  E n√£o est√° claro como testar o c√≥digo de sa√≠da nos testes. <br><br><h2>  docopt </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O docopt</a> √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisador</a> pequeno (&lt;600 linhas, comparado a 2500 com argparse), que far√° voc√™ sorrir, citando uma descri√ß√£o no GitHub.  A id√©ia principal do docopt √© descrever a interface literalmente com texto, por exemplo, na sequ√™ncia de documentos. <br><br>  No mesmo github, docopt&gt; 6700 estrelas, √© usado em pelo menos 22 mil outros projetos.  E isso √© apenas com a implementa√ß√£o do python!  A p√°gina do projeto docopt possui muitas op√ß√µes para diferentes linguagens, de C e PHP a CoffeeScript e at√© R. Essa plataforma cruzada s√≥ pode ser explicada pela compacidade e simplicidade do c√≥digo. <br><br><h4>  Analisador </h4><br>  Comparado ao argparse, esse analisador √© um grande passo √† frente. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Todo notes on docopt. Usage: todo_docopt [-v | -vv ] add &lt;task&gt; todo_docopt [-v | -vv ] show --show-done todo_docopt [-v | -vv ] done &lt;number&gt; todo_docopt [-v | -vv ] remove &lt;number&gt; todo_docopt -h | --help todo_docopt --version Options: -h --help Show help. -v --verbose Enable verbose mode. """</span></span></code> </pre><br><h4>  principal </h4><br>  Em geral, tudo √© o mesmo que com argparse, mas agora <i>detalhado</i> pode ter v√°rios valores (0-2), e o acesso aos argumentos √© diferente: docopt n√£o retorna um espa√ßo para nome com atributos, mas apenas um dicion√°rio, onde a escolha de um comando √© indicada atrav√©s de seu booleano, como visto <i>se</i> : <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv=None)</span></span></span><span class="hljs-function">:</span></span> args = docopt(__doc__, argv=argv, version=lib_version) log.setLevel(levels[args[<span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>]]) logging.basicConfig() log.debug(<span class="hljs-string"><span class="hljs-string">"Arguments: %s"</span></span>, args) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args[<span class="hljs-string"><span class="hljs-string">"add"</span></span>]: task = app.add_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;task&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"show"</span></span>]: app.print_tasks(args[<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: task = app.task_done(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"remove"</span></span>]: task = app.remove_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Teste </h4><br>  Semelhante ao teste argparse: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_docopt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_docopt.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Sum√°rio </h4><br>  Dos benef√≠cios - muito menos c√≥digo para o analisador, facilidade de descri√ß√£o e leitura de comandos e argumentos, vers√£o embutida. <br><br>  Contras, em primeiro lugar, o mesmo que argparse - muita l√≥gica em <i>main</i> , voc√™ n√£o pode testar o c√≥digo de sa√≠da.  Al√©m disso, a vers√£o atual (0.6.2) do docopt ainda n√£o √© est√°vel e provavelmente nunca ser√° - o projeto foi desenvolvido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ativamente</a> de 2012 at√© o final de 2013, o √∫ltimo commit foi em 17 de dezembro.  E a coisa mais desagrad√°vel no momento √© que alguns docopt regulares provocam DeprecationWarning ao executar testes. <br><br><h2>  Clique em </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Click √©</a> fundamentalmente diferente de argparse e docopt pelo n√∫mero de recursos e pela abordagem para descrever comandos e par√¢metros por meio de decoradores, e prop√µe-se que a pr√≥pria l√≥gica seja separada em fun√ß√µes separadas, em vez de uma grande.  Os autores afirmam que o Click possui muitas configura√ß√µes, mas os par√¢metros padr√£o devem ser suficientes.  Entre os recursos, os comandos aninhados e seu carregamento lento s√£o enfatizados. <br><br>  O projeto √© extremamente popular: al√©m de ter mais de 8100 estrelas e us√°-lo em pelo menos 174 mil projetos (!), Ele ainda est√° em desenvolvimento: a vers√£o 7.0 foi lan√ßada no outono de 2018 e novas solicita√ß√µes de confirma√ß√£o e mesclagem aparecem at√© hoje. dia <br><br><h4>  Analisador </h4><br>  Na p√°gina de documenta√ß√£o, encontrei o decorador de <i>confirma√ß√£o_op√ß√£o</i> , que solicita confirma√ß√£o do usu√°rio antes de executar o comando.  Para demonstr√°-lo, o comando wipe foi adicionado, o que limpa toda a lista de tarefas. <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs">levels = [logging.WARN, logging.INFO, logging.DEBUG] pass_app = click.make_pass_decorator(TodoApp) @click.group() @click.version_option(lib_version, prog_name=<span class="hljs-string"><span class="hljs-string">"todo_click"</span></span>) @click.option(<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, count=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-comment"><span class="hljs-comment"># click   ,     @click.option("--db", help="Path to the database file") @click.pass_context def cli(ctx, verbose, db): """Todo notes - click version.""" level = levels[min(verbose, 2)] logging.basicConfig(level=level) logging.getLogger("todolib").setLevel(level) ctx.obj = TodoApp.fromenv(db) atexit.register(ctx.obj.save) @cli.command() @click.argument("task") @pass_app def add(app, task): """ Add new task. """ task = app.add_task(task) click.echo(f"{task} created with number {task.number}.") @cli.command() @click.option("--show-done", is_flag=True, help="Include done tasks") @pass_app def show(app, show_done): """ Show current tasks. """ app.print_tasks(show_done) @cli.command() @click.argument("number", type=int) @pass_app def done(app, number): """ Mark task as done. """ task = app.task_done(number) click.echo(f"{task} marked as done.") @cli.command() @click.argument("number", type=int) @pass_app def remove(app, number): """ Remove task from the list. """ task = app.remove_task(number) click.echo(f"{task} removed from the list.") @cli.command() @click.confirmation_option(prompt="Are you sure you want to remove database") @pass_app def wipe(app): for task in app.list_tasks(): task.remove()</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  E aqui encontramos a principal vantagem do Click - devido ao fato de a l√≥gica dos comandos ser separada por suas fun√ß√µes, quase nada permanece principal.  Tamb√©m √© demonstrada aqui a capacidade da biblioteca de receber argumentos e par√¢metros de vari√°veis ‚Äã‚Äãde ambiente. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: cli(auto_envvar_prefix=<span class="hljs-string"><span class="hljs-string">"TODO"</span></span>)</code> </pre><br><h4>  Teste </h4><br>  No caso do Click, n√£o h√° necessidade de interceptar o sys.stdout, pois existe um m√≥dulo de teste de <i>click.t</i> com um corredor para essas coisas.  E <i>o CliRunner</i> n√£o apenas intercepta a sa√≠da, mas tamb√©m permite verificar o c√≥digo de sa√≠da, o que tamb√©m √© legal.  Tudo isso permite testar os utilit√°rios de clique sem usar o pytest e ignorar o m√≥dulo <i>unittest</i> padr√£o. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> click.testing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> runner = click.testing.CliRunner() result = runner.invoke(todo_click.cli, [<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.exit_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.output == EXPECTED</code> </pre><br><h4>  Sum√°rio </h4><br>  Esta √© apenas uma pequena parte do que o Click pode fazer.  Do restante da API - valida√ß√£o de valores, integra√ß√£o com o terminal (cores, pager a la less, barra de progresso etc.), retorno de chamada de resultado, preenchimento autom√°tico e muito mais.  Voc√™ pode ver os exemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Pr√≥s: muitas ferramentas para qualquer ocasi√£o, uma abordagem original, mas ao mesmo tempo conveniente para descrever equipes, facilidade de teste e vida ativa do projeto. <br><br>  Contras: Quais s√£o as desvantagens de um "clique" - essa √© uma pergunta dif√≠cil.  Talvez ele n√£o saiba algo do que as seguintes bibliotecas s√£o capazes? <br><br><h2>  Fogo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Fire</a> n√£o √© apenas uma biblioteca jovem (publicada em 2017) para interfaces de console do Google, √© uma biblioteca para gerar interfaces de console de, entre aspas, <i>absolutamente qualquer objeto</i> Python. <br>  Entre outras coisas, afirma-se que o fire ajuda no desenvolvimento e na depura√ß√£o de c√≥digo, ajuda a adaptar o c√≥digo existente na CLI, facilita a transi√ß√£o do bash para o Python e tem seu pr√≥prio REPL para trabalho interativo.  Vamos ver? <br><br><h4>  Analisador e principal </h4><br>  O fire.Fire √© realmente capaz de aceitar qualquer objeto: um m√≥dulo, uma inst√¢ncia de classe, um dicion√°rio com nomes de comandos e fun√ß√µes correspondentes, e assim por diante. <br><br>  O que √© importante para n√≥s √© que o Fire permite a transfer√™ncia de um objeto de classe.  Assim, o construtor da classe aceita argumentos comuns a todos os comandos, e seus m√©todos e atributos s√£o comandos separados.  Vamos usar isso: <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Commands</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, db=None, verbose=False)</span></span></span><span class="hljs-function">:</span></span> level = logging.INFO <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> logging.WARNING logging.basicConfig(level=level) logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(level) self._app = todolib.TodoApp.fromenv(db) atexit.register(self._app.save) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todolib.__version__ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, task)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self._app.add_task(task) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Show current tasks. """</span></span> self._app.print_tasks(show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Mark task as done. """</span></span> task = self._app.task_done(number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Removes task from the list. """</span></span> task = self._app.remove_task(number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> fire.Fire(Commands, command=args)</code> </pre><br></div></div><br><h4>  Sinalizadores embutidos </h4><br>  O Fire possui suas pr√≥prias bandeiras com uma sintaxe especial (elas devem ser passadas ap√≥s o "-"), que permitem que voc√™ olhe sob o cap√¥ do analisador e do aplicativo como um todo: <br><br><div class="spoiler">  <b class="spoiler_title">exemplos de chamadas</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./todo_fire.py show -- --trace Fire trace: 1. Initial component 2. Instantiated class <span class="hljs-string"><span class="hljs-string">"Commands"</span></span> (todo_fire.py:9) 3. Accessed property <span class="hljs-string"><span class="hljs-string">"show"</span></span> (todo_fire.py:25) $ ./todo_fire.py -- --verbose | head -n 12 <span class="hljs-comment"><span class="hljs-comment">#    , ,  Commands._app NAME todo_fire.py - SYNOPSIS todo_fire.py - GROUP | COMMAND GROUPS GROUP is one of the following: _app Todo Application definition. $ ./todo_fire.py show -- --interactive Fire is starting a Python REPL with the following objects: Modules: atexit, fire, logging, todolib Objects: Commands, args, component, main, result, self, todo_fire.py, trace Python 3.7.4 (default, Aug 15 2019, 13:09:37) [GCC 7.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. (InteractiveConsole) &gt;&gt;&gt; self &lt;__main__.Commands object at 0x7fd0a6125bd0&gt; &gt;&gt;&gt; self._app.db {'tasks': [{'title': 'test', 'done': False}]}</span></span></code> </pre><br></div></div><br><h4>  Teste </h4><br>  Testar a fun√ß√£o principal √© semelhante a testar argparse e docopt, ent√£o n√£o vejo o ponto aqui. <br><br>  Ao mesmo tempo, vale a pena notar que, devido √† natureza introspectiva do fogo, √© igualmente poss√≠vel testar a classe Commands imediatamente. <br><br><h4>  Sum√°rio </h4><br>  O fogo √© uma ferramenta n√£o menos interessante que o clique.  N√£o √© necess√°rio listar muitas op√ß√µes no analisador, a configura√ß√£o √© m√≠nima, h√° op√ß√µes para depura√ß√£o e a pr√≥pria biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vive e se desenvolve</a> ainda mais ativamente do que o clique (60 confirma neste ver√£o). <br><br>  Contras: pode ser significativamente menor que o clique e outros analisadores;  API inst√°vel (a vers√£o atual √© 0.2.1). <br><br><h2>  Cimento </h2><br>  De fato, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cement</a> n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> exatamente uma biblioteca CLI, mas uma estrutura para aplicativos de console, mas argumenta-se que √© adequado para scripts e aplicativos complexos com v√°rias integra√ß√µes. <br><br><h4>  Analisador </h4><br>  O analisador em Cement parece incomum, mas se voc√™ observar atentamente os par√¢metros, √© f√°cil adivinhar que o argumento familiar est√° sob o cap√¥.  Mas talvez isso seja o melhor - n√£o h√° necessidade de aprender novos par√¢metros. <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cement <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Controller, ex <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Controller)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> label = <span class="hljs-string"><span class="hljs-string">"base"</span></span> arguments = [ ( [<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--version"</span></span>], {<span class="hljs-string"><span class="hljs-string">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"version"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">f"todo_cement v</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{todolib.__version__}</span></span></span><span class="hljs-string">"</span></span>}, ) ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Default action if no sub-command is passed."""</span></span> self.app.args.print_help() @ex(help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"task"</span></span>], {<span class="hljs-string"><span class="hljs-string">"help"</span></span>: <span class="hljs-string"><span class="hljs-string">"Task title"</span></span>})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> title = self.app.pargs.task self.app.log.debug(<span class="hljs-string"><span class="hljs-string">f"Task title: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{title!r}</span></span></span><span class="hljs-string">"</span></span>) task = self.app.todoobj.add_task(title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) @ex( help=<span class="hljs-string"><span class="hljs-string">"Show current tasks"</span></span>, arguments=[ ([<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>], dict(action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks"</span></span>)) ], ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.app.todoobj.print_tasks(self.app.pargs.show_done) @ex(help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.task_done(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) @ex(help=<span class="hljs-string"><span class="hljs-string">"Remove task from the list"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.remove_task(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>)</code> </pre><br></div></div><br><h4>  App e principal </h4><br>  O cimento, entre outras coisas, ainda envolve sinais em exce√ß√µes.  Isso √© demonstrado aqui na sa√≠da de c√≥digo zero com SIGINT / SIGTERM. <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(App)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, argv=None)</span></span></span><span class="hljs-function">:</span></span> super().__init__(argv=argv) self.todoobj = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj.save() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># application label label = "todo_cement" # register handlers handlers = [Base] hooks = [("post_setup", lambda app: app.load_db()), ("pre_close", lambda app: app.save())] # call sys.exit() on close close_on_exit = True def main(): with TodoApp() as app: try: app.run() except CaughtSignal as e: if e.signum not in (signal.SIGINT, signal.SIGTERM): raise app.log.debug(f"\n{e}") app.exit_code = 0</span></span></code> </pre><br></div></div><br>  Se voc√™ entender o main, poder√° ver que o carregamento e o salvamento do todolib.TodoApp tamb√©m podem ser feitos no __enter __ / __ exit__ substitu√≠do, mas essas fases acabaram sendo separadas em m√©todos separados para demonstrar ganchos de cimento. <br><br><h4>  Teste </h4><br>  Para teste, voc√™ pode usar a mesma classe de aplicativo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> todo_cement.TodoApp(argv=[<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.run() out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED <span class="hljs-comment"><span class="hljs-comment">#     jinja,       assert app.last_rendered is None</span></span></code> </pre><br><h4>  Sum√°rio </h4><br>  Pr√≥s: O conjunto de APIs √© como um conjunto de facas su√≠√ßas, extensibilidade atrav√©s de ganchos e plugins, uma interface est√°vel e desenvolvimento ativo. <br><br>  Contras: Em locais com documenta√ß√£o vazia;  pequenos scripts baseados em cimento podem parecer um pouco complicados. <br><br><h2>  Cleo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Cleo est√°</a> longe de ser uma estrutura t√£o popular quanto as outras listadas aqui (cerca de 400 estrelas no GitHub no total), e ainda assim consegui conhec√™-la quando estudei como o formato Poetry foi formatado. <br><br>  Portanto, o Cleo √© um dos projetos do autor da j√° mencionada Poesia, uma ferramenta para gerenciar depend√™ncias, virtualenvs e compila√ß√µes de aplicativos.  Sobre a poesia em um habr j√° mais de uma vez escreveu, e sobre sua parte do console - n√£o. <br><br><h4>  Analisador </h4><br>  Cleo, como Cimento, √© constru√≠do sobre princ√≠pios de objetos, ou seja,  Os comandos s√£o definidos por meio da classe Command e sua documenta√ß√£o, os par√¢metros s√£o acessados ‚Äã‚Äãpelo m√©todo option () e assim por diante.  Al√©m disso, o m√©todo line (), usado para gerar texto, suporta estilos (ou seja, cores) e filtragem de sa√≠da com base no n√∫mero de sinalizadores detalhados da caixa.  Cleo tamb√©m tem sa√≠da de tabela.  E tamb√©m barras de progresso.  E ainda ... Em geral, veja: <br><br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Command <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseCommand <span class="hljs-comment"><span class="hljs-comment"># cleo    clikit,          from clikit.api.io import flags as verbosity class Command(BaseCommand): def __init__(self): super().__init__() self.todoapp = None def handle(self): with todolib.TodoApp.fromenv() as app: self.todoapp = app self.do_handle() def do_handle(self): raise NotImplementedError class AddCommand(Command): """ Add new task. add {task : Task to add} """ def do_handle(self): title = self.argument("task") task = self.todoapp.add_task(title) # will be printed only on "-vvv" self.line(f"Title: {title}", style="comment", verbosity=verbosity.DEBUG) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; created with number {task.number}.") class ShowCommand(Command): """ Show current tasks. show {--show-done : Include tasks that are done.} """ def do_handle(self): tasks = self.todoapp.list_tasks(self.option("show-done")) if not tasks: self.line("There is no TODOs.", style="info") self.render_table( ["Number", "Title", "Status"], [ [str(task.number), task.title, "" if task.done else "‚úò"] for task in tasks ], ) class DoneCommand(Command): """ Mark task as done. done {number : Task number} """ def do_handle(self): task = self.todoapp.task_done(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; marked as done.") class RemoveCommand(Command): """ Removes task from the list. remove {number : Task number} """ def do_handle(self): task = self.todoapp.remove_task(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; removed from the list.")</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  Tudo o que √© necess√°rio √© criar um objeto <i>cleo.Application</i> e passar comandos para add_commands.  Para n√£o repetir durante o teste, tudo isso foi transferido do principal para o construtor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseApplication <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseApplication)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(name=<span class="hljs-string"><span class="hljs-string">"ToDo app - cleo version"</span></span>, version=todolib.__version__) self.add_commands(AddCommand(), ShowCommand(), DoneCommand(), RemoveCommand()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> TodoApp().run(args=args)</code> </pre><br><h4>  Teste </h4><br>  Para testar comandos no Cleo, existe o <i>CommandTester</i> , que, como todos os <s>tios</s> adultos <s>da</s> estrutura, intercepta E / S e c√≥digo de sa√≠da: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cleo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> app = todo_cleo.TodoApp() command = app.find(<span class="hljs-string"><span class="hljs-string">"add"</span></span>) tester = cleo.CommandTester(command) tester.execute(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.status_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.io.fetch_output() == <span class="hljs-string"><span class="hljs-string">"Task test created with number 0.\n"</span></span></code> </pre><br><h4>  Sum√°rio </h4><br>  Pr√≥s: estrutura de objetos com dicas de tipo, o que simplifica o desenvolvimento (como muitos IDEs e editores t√™m bom suporte para c√≥digo OOP e m√≥dulo de digita√ß√£o);  Uma boa quantidade de funcionalidade para trabalhar n√£o apenas com argumentos, mas tamb√©m com E / S. <br><br>  Mais ou menos: seu par√¢metro de verbosidade, compat√≠vel apenas com a E / S Cleo / CliKit.  Embora voc√™ possa escrever um manipulador personalizado para o m√≥dulo de registro em log, pode ser dif√≠cil manter junto com o desenvolvimento do cleo. <br><br>  Contras: obviamente - uma opini√£o pessoal - uma API jovem: o framework n√£o possui outro usu√°rio "grande", exceto Poetry, e o Cleo est√° desenvolvendo paralelamente ao desenvolvimento e √†s necessidades de um;  √Äs vezes, a documenta√ß√£o est√° desatualizada (por exemplo, os n√≠veis de log agora n√£o est√£o no m√≥dulo clikit, mas em clikit.api.io.flags) e, em geral, √© ruim e n√£o reflete a API inteira. <br><br>  Cleo, comparado com Cement, est√° mais focado na CLI e √© o √∫nico que pensou em formatar (ocultar o rastreamento de pilha padr√£o) de exce√ß√µes na sa√≠da padr√£o.  Mas ele - novamente uma opini√£o pessoal - perde para Cement na juventude e na estabilidade da API. <br><br><h2>  Em conclus√£o </h2><br>  Neste ponto, todos j√° t√™m sua pr√≥pria opini√£o, o que √© melhor, mas a conclus√£o deve ser: Gostei mais do Click, porque h√° muitas coisas nele e √© muito f√°cil desenvolver e testar aplicativos com ele.  Se voc√™ tentar escrever c√≥digo no m√≠nimo - comece com o Fire.  Seu script precisa acessar o Memcached, formatar com jinja e extensibilidade - use Cement e voc√™ n√£o se arrepender√°.  Voc√™ tem um projeto para animais de estima√ß√£o ou deseja tentar outra coisa - veja o cleo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466999/">https://habr.com/ru/post/pt466999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466983/index.html">Por que ningu√©m pode vencer a corrida de Tesla</a></li>
<li><a href="../pt466985/index.html">Sobre os novos padr√µes C ++</a></li>
<li><a href="../pt466987/index.html">Os "ls" at√≠picos ou como os linux√≠deos s√£o entretidos</a></li>
<li><a href="../pt466993/index.html">Configura√ß√£o do plugin Warnings Next Generation para integra√ß√£o com o PVS-Studio</a></li>
<li><a href="../pt466995/index.html">Configurando o Plug-in Warnings Next Generation para Integra√ß√£o PVS-Studio</a></li>
<li><a href="../pt467003/index.html">Menu r√°pido, conveniente e adapt√°vel para 1075 categorias (36000 produtos)</a></li>
<li><a href="../pt467005/index.html">Como colorir polin√¥mios corretamente</a></li>
<li><a href="../pt467007/index.html">FLProg - Integra√ß√£o independente ao programa de controladores personalizados</a></li>
<li><a href="../pt467009/index.html">Criando uma biblioteca dom√©stica com o Notion e o Python</a></li>
<li><a href="../pt467011/index.html">O que ler e ver para come√ßar na Data Science: livros, dicion√°rios e cursos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>