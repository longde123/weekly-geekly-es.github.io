<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 😒 👨🏿‍💼 Actualización de perfil de por vida en Visual Studio 2019 Preview 2 🧖🏻 👩🏾‍🚀 🗝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El Perfil de por vida de las Pautas básicas de C ++, que forma parte de las Pautas básicas de C ++ , tiene como objetivo detectar problemas de por vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Actualización de perfil de por vida en Visual Studio 2019 Preview 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437660/"><p>  El Perfil de por vida de las Pautas básicas de C ++, que forma parte de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pautas básicas de C ++</a> , tiene como objetivo detectar problemas de por vida, como punteros colgantes y referencias, en el código de C ++.  Utiliza la información de tipo ya presente en la fuente junto con algunos contratos simples entre funciones para detectar defectos en tiempo de compilación con una anotación mínima. </p><br><br><img src="https://habrastorage.org/webt/m6/sd/zl/m6sdzl8oiweahnxld6esvr3s03u.png"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Original en blog</a> <br><br><p>  Estos son los contratos básicos que el perfil espera que siga el código: </p><br><ol><li>  No use un puntero potencialmente colgante. </li><li>  No pase un puntero potencialmente colgante a otra función. </li><li>  No devuelva un puntero potencialmente colgante de ninguna función. </li></ol><br><p>  Para obtener más información sobre la historia y los objetivos del perfil, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicación de blog de Herb Sutter sobre la versión 1.0</a> . </p><br><h2>  Novedades de Visual Studio 2019 Preview 2 </h2><br><p>  En la Vista previa 2, hemos enviado una versión de vista previa de Lifetime Profile Checker que implementa la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión publicada de Lifetime Profile</a> .  Este verificador es parte de los verificadores principales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++</a> en Visual Studio. </p><br><ul><li>  Soporte para iteradores, string_views y spans. </li><li>  Mejor detección de los tipos de puntero y propietario personalizados que permite que los tipos personalizados que se comportan como contenedores, punteros propietarios o punteros no propietarios participen en el análisis. </li><li>  Las reglas predeterminadas de tipo para condiciones de llamada previa y posterior a la función ayudan a reducir los falsos positivos y mejorar la precisión. </li><li>  Mejor soporte para tipos agregados. </li><li>  Corrección general y mejoras de rendimiento. </li><li>  Algunos análisis simples nullptr. </li></ul><br><h2>  Habilitación de las reglas del verificador de perfil de por vida </h2><br><p>  Las reglas del verificador no están habilitadas por defecto.  Si desea probar las nuevas reglas, deberá actualizar el conjunto de reglas de análisis de código seleccionado para su proyecto.  Puede seleccionar las “Reglas de por vida de C ++ Core Check”, que habilita solo las reglas del Perfil de por vida, o puede modificar su conjunto de reglas existente para habilitar las advertencias 26486 a 26489. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/602/81e/cdc/60281ecdcf10232b8e9f58c5f0623d31.png" alt="Captura de pantalla de la página de propiedades de Análisis de código que muestra el conjunto de reglas de C ++ Core Check Lifetime Rules seleccionado." width="1253" height="898"></a> <p>  Captura de pantalla de la página de propiedades de Análisis de código que muestra el conjunto de reglas de C ++ Core Check Lifetime Rules seleccionado. </p><br><p>  Las advertencias aparecerán en la Lista de errores cuando se ejecute el análisis de código (Analizar&gt; Ejecutar análisis de código), o si tiene habilitado el Análisis de código de fondo, los errores de por vida se mostrarán en el editor con garabatos verdes. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/593/6da/b6c/5936dab6c4be57347101009d35125739.png" alt="Captura de pantalla que muestra una advertencia de Lifetime Profile Checker con un garabato verde en el código fuente." width="982" height="134"></a> <p>  Captura de pantalla que muestra una advertencia de Lifetime Profile Checker con un garabato verde en el código fuente. </p><br><h2>  Ejemplos </h2><br><h3>  Puntero colgando </h3><br><p> El ejemplo más simple, usar un puntero colgante, es el mejor lugar para comenzar.  Aquí <code>px</code> apunta a <code>x</code> y luego <code>x</code> deja el alcance dejando <code>px</code> colgando.  Cuando se utiliza <code>px</code> , se emite una advertencia. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* px; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; px = &amp;x; } *px = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error, dangling pointer to 'x' }</span></span></code> </pre> <br><h3>  Puntero de salida colgante </h3><br><p>  Tampoco se permite devolver punteros colgantes.  En este caso, se presume que el parámetro <code>ppx</code> es un parámetro de salida.  En este caso, está configurado para apuntar a <code>x</code> que queda fuera de alcance al final de la función.  Esto deja <code>*ppx</code> colgando. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out_parameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">** ppx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// *ppx points to 'x' which is invalid { *ppx = &amp;x; }</span></span></span></span></code> </pre> <br><h3>  Vista de cuerdas colgantes </h3><br><p>  Los dos últimos ejemplos fueron obvios, pero las instancias temporales pueden introducir errores sutiles.  ¿Puedes encontrar el error en el siguiente código? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_string_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view sv = get_string(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = sv.at(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  En este caso, la vista de cadena <code>sv</code> se construye con la instancia de cadena temporal devuelta por <code>get_string()</code> .  La cadena temporal se destruye, lo que deja la vista de cadena haciendo referencia a un objeto no válido. </p><br><h3>  Iterador colgando </h3><br><p>  Otro problema difícil de detectar ocurre cuando se usa un iterador invalidado en un contenedor.  En el siguiente caso, la llamada a <code>push_back</code> puede hacer que el vector reasigne su almacenamiento subyacente, lo que invalida el iterador. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = v.begin(); *it = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok, iterator is valid v.push_back(4); *it = 0; // error, using an invalid iterator }</span></span></code> </pre> <br><p>  Una cosa a tener en cuenta sobre este ejemplo es que no hay un manejo especial para 'std :: vector :: push_back'.  Este comportamiento cae fuera de las reglas de perfil predeterminadas.  Una regla clasifica los contenedores como 'Propietario'.  Luego, cuando se llama a un método no constante en el Propietario, se supone que su memoria propia está invalidada y los iteradores que apuntan a la memoria propia también se consideran inválidos. </p><br><h3>  Propietario modificado </h3><br><p>  El perfil es prescriptivo en su orientación.  Espera que su código utilice el sistema de tipos de forma idiomática al definir los parámetros de la función.  En el siguiente ejemplo, <code>std::unique_ptr</code> , un tipo 'Propietario', se pasa a otra función por referencia no constante.  De acuerdo con las reglas del perfil, se supone que el titular de la llamada modifica a los propietarios que pasan por referencia no constante. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_unique_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; upRef)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assumes_modification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> unique = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Line A auto ptr = unique.get(); *ptr = 10; // ok, ptr is valid use_unique_ptr(unique); *ptr = 10; // error, dangling pointer to the memory held by 'unique' at Line A }</span></span></code> </pre> <br><p>  En este ejemplo, obtenemos un puntero en bruto, <code>ptr</code> , a la memoria propiedad de <code>unique</code> .  Luego se pasa <code>unique</code> a la función <code>use_unique_ptr</code> por referencia no constante.  Debido a que este es un uso no const de <code>unique</code> donde la función podría hacer cualquier cosa, el análisis asume que <code>unique</code> 'se invalida de alguna manera (por ejemplo, unique_ptr :: reset) lo que causaría que <code>ptr</code> cuelgue. </p><br><h3>  Más ejemplos </h3><br><p>  Hay muchos otros casos que el análisis puede detectar.  Pruébelo en Visual Studio con su propio código y vea lo que encuentra.  Consulte también <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el blog de Herb</a> para obtener más ejemplos y, si tiene curiosidad, lea el documento de Lifetime Profile. </p><br><h2>  Problemas conocidos </h2><br><p>  La implementación actual no es totalmente compatible con el análisis como se describe en el documento de Lifetime Profile.  Estas son las categorías generales que no se implementan en esta versión. </p><br><ul><li>  <b>Anotaciones</b> : el documento presenta anotaciones (es decir, <code>[[gsl::lifetime-const]]</code> ) que no son compatibles.  Prácticamente esto significa que si las reglas de análisis predeterminadas no funcionan para su código, no hay mucho que pueda hacer aparte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suprimir</a> falsos positivos. </li><li>  <b>Excepciones</b> : las rutas de manejo de excepciones, incluido el contenido de <code>catch</code> bloques <code>catch</code> , no se analizan actualmente. </li><li>  <b>Reglas predeterminadas para los</b> <b>tipos de STL</b> : en lugar de una anotación de por <code>lifetime-const</code> , el documento recomienda que para las raras funciones de los miembros del contenedor de STL donde queremos anular los valores predeterminados, los tratemos como si estuvieran anotados.  Por ejemplo, una sobrecarga de <code>std::vector::at</code> no es <code>const</code> porque puede devolver una referencia no constante; sin embargo, sabemos que llamarla es <code>lifetime-const</code> por <code>lifetime-const</code> porque no invalida la memoria del vector.  No hemos completado el trabajo para hacer esta anotación implícita de todos los tipos de contenedores STL. </li><li>  <b>Capturas de Lambda</b> : si una variable de pila se captura por referencia en una lambda, actualmente no detectamos si la lambda abandona el alcance de la variable capturada. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> captures_x = [&amp;x] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captures_x; <span class="hljs-comment"><span class="hljs-comment">// returns a dangling reference to 'x' }</span></span></code> </pre> </li></ul><br><h2>  Concluir </h2><br><p>  Pruebe el Verificador de perfil de por vida en Visual Studio 2019 Preview 2. Esperamos que ayude a identificar problemas de por vida en sus proyectos.  Si encuentra falsos positivos o falsos negativos, infórmelos para que podamos priorizar los escenarios que son importantes para usted.  Si tiene sugerencias o problemas con esta verificación, o con cualquier función de Visual Studio, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe un problema</a> o publíquelo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores</a> y avísenos.  También estamos en Twitter en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@VisualC</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437660/">https://habr.com/ru/post/437660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437650/index.html">Una selección de los mejores regalos para la persona entusiasta y geek el 23 de febrero</a></li>
<li><a href="../437652/index.html">Anuncio de TypeScript 3.3 RC</a></li>
<li><a href="../437654/index.html">Impresoras 3D de fotopolímero económicas y económicas</a></li>
<li><a href="../437656/index.html">Elefante en una tienda china: impresoras 3D con un gran campo de impresión</a></li>
<li><a href="../437658/index.html">Guía: Thymeleaf + Spring. Parte 3</a></li>
<li><a href="../437664/index.html">Recuperación compuesta</a></li>
<li><a href="../437666/index.html">Anuncio de la vista previa de F # 4.6</a></li>
<li><a href="../437670/index.html">Actualizaciones de back-end de MSVC en Visual Studio 2019 Preview 2: Nuevas optimizaciones, OpenMP y mejoras de rendimiento de compilación</a></li>
<li><a href="../437672/index.html">Cyberd: Calcular el conocimiento de web3</a></li>
<li><a href="../437674/index.html">Métodos de reconocimiento de objetos en 3D para vehículos no tripulados. Informe Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>