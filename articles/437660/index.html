<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ó üòí üë®üèø‚Äçüíº Actualizaci√≥n de perfil de por vida en Visual Studio 2019 Preview 2 üßñüèª üë©üèæ‚ÄçüöÄ üóùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El Perfil de por vida de las Pautas b√°sicas de C ++, que forma parte de las Pautas b√°sicas de C ++ , tiene como objetivo detectar problemas de por vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Actualizaci√≥n de perfil de por vida en Visual Studio 2019 Preview 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437660/"><p>  El Perfil de por vida de las Pautas b√°sicas de C ++, que forma parte de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pautas b√°sicas de C ++</a> , tiene como objetivo detectar problemas de por vida, como punteros colgantes y referencias, en el c√≥digo de C ++.  Utiliza la informaci√≥n de tipo ya presente en la fuente junto con algunos contratos simples entre funciones para detectar defectos en tiempo de compilaci√≥n con una anotaci√≥n m√≠nima. </p><br><br><img src="https://habrastorage.org/webt/m6/sd/zl/m6sdzl8oiweahnxld6esvr3s03u.png"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Original en blog</a> <br><br><p>  Estos son los contratos b√°sicos que el perfil espera que siga el c√≥digo: </p><br><ol><li>  No use un puntero potencialmente colgante. </li><li>  No pase un puntero potencialmente colgante a otra funci√≥n. </li><li>  No devuelva un puntero potencialmente colgante de ninguna funci√≥n. </li></ol><br><p>  Para obtener m√°s informaci√≥n sobre la historia y los objetivos del perfil, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicaci√≥n de blog de Herb Sutter sobre la versi√≥n 1.0</a> . </p><br><h2>  Novedades de Visual Studio 2019 Preview 2 </h2><br><p>  En la Vista previa 2, hemos enviado una versi√≥n de vista previa de Lifetime Profile Checker que implementa la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n publicada de Lifetime Profile</a> .  Este verificador es parte de los verificadores principales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++</a> en Visual Studio. </p><br><ul><li>  Soporte para iteradores, string_views y spans. </li><li>  Mejor detecci√≥n de los tipos de puntero y propietario personalizados que permite que los tipos personalizados que se comportan como contenedores, punteros propietarios o punteros no propietarios participen en el an√°lisis. </li><li>  Las reglas predeterminadas de tipo para condiciones de llamada previa y posterior a la funci√≥n ayudan a reducir los falsos positivos y mejorar la precisi√≥n. </li><li>  Mejor soporte para tipos agregados. </li><li>  Correcci√≥n general y mejoras de rendimiento. </li><li>  Algunos an√°lisis simples nullptr. </li></ul><br><h2>  Habilitaci√≥n de las reglas del verificador de perfil de por vida </h2><br><p>  Las reglas del verificador no est√°n habilitadas por defecto.  Si desea probar las nuevas reglas, deber√° actualizar el conjunto de reglas de an√°lisis de c√≥digo seleccionado para su proyecto.  Puede seleccionar las ‚ÄúReglas de por vida de C ++ Core Check‚Äù, que habilita solo las reglas del Perfil de por vida, o puede modificar su conjunto de reglas existente para habilitar las advertencias 26486 a 26489. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/602/81e/cdc/60281ecdcf10232b8e9f58c5f0623d31.png" alt="Captura de pantalla de la p√°gina de propiedades de An√°lisis de c√≥digo que muestra el conjunto de reglas de C ++ Core Check Lifetime Rules seleccionado." width="1253" height="898"></a> <p>  Captura de pantalla de la p√°gina de propiedades de An√°lisis de c√≥digo que muestra el conjunto de reglas de C ++ Core Check Lifetime Rules seleccionado. </p><br><p>  Las advertencias aparecer√°n en la Lista de errores cuando se ejecute el an√°lisis de c√≥digo (Analizar&gt; Ejecutar an√°lisis de c√≥digo), o si tiene habilitado el An√°lisis de c√≥digo de fondo, los errores de por vida se mostrar√°n en el editor con garabatos verdes. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/593/6da/b6c/5936dab6c4be57347101009d35125739.png" alt="Captura de pantalla que muestra una advertencia de Lifetime Profile Checker con un garabato verde en el c√≥digo fuente." width="982" height="134"></a> <p>  Captura de pantalla que muestra una advertencia de Lifetime Profile Checker con un garabato verde en el c√≥digo fuente. </p><br><h2>  Ejemplos </h2><br><h3>  Puntero colgando </h3><br><p> El ejemplo m√°s simple, usar un puntero colgante, es el mejor lugar para comenzar.  Aqu√≠ <code>px</code> apunta a <code>x</code> y luego <code>x</code> deja el alcance dejando <code>px</code> colgando.  Cuando se utiliza <code>px</code> , se emite una advertencia. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* px; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; px = &amp;x; } *px = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error, dangling pointer to 'x' }</span></span></code> </pre> <br><h3>  Puntero de salida colgante </h3><br><p>  Tampoco se permite devolver punteros colgantes.  En este caso, se presume que el par√°metro <code>ppx</code> es un par√°metro de salida.  En este caso, est√° configurado para apuntar a <code>x</code> que queda fuera de alcance al final de la funci√≥n.  Esto deja <code>*ppx</code> colgando. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out_parameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">** ppx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// *ppx points to 'x' which is invalid { *ppx = &amp;x; }</span></span></span></span></code> </pre> <br><h3>  Vista de cuerdas colgantes </h3><br><p>  Los dos √∫ltimos ejemplos fueron obvios, pero las instancias temporales pueden introducir errores sutiles.  ¬øPuedes encontrar el error en el siguiente c√≥digo? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_string_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view sv = get_string(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = sv.at(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  En este caso, la vista de cadena <code>sv</code> se construye con la instancia de cadena temporal devuelta por <code>get_string()</code> .  La cadena temporal se destruye, lo que deja la vista de cadena haciendo referencia a un objeto no v√°lido. </p><br><h3>  Iterador colgando </h3><br><p>  Otro problema dif√≠cil de detectar ocurre cuando se usa un iterador invalidado en un contenedor.  En el siguiente caso, la llamada a <code>push_back</code> puede hacer que el vector reasigne su almacenamiento subyacente, lo que invalida el iterador. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = v.begin(); *it = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok, iterator is valid v.push_back(4); *it = 0; // error, using an invalid iterator }</span></span></code> </pre> <br><p>  Una cosa a tener en cuenta sobre este ejemplo es que no hay un manejo especial para 'std :: vector :: push_back'.  Este comportamiento cae fuera de las reglas de perfil predeterminadas.  Una regla clasifica los contenedores como 'Propietario'.  Luego, cuando se llama a un m√©todo no constante en el Propietario, se supone que su memoria propia est√° invalidada y los iteradores que apuntan a la memoria propia tambi√©n se consideran inv√°lidos. </p><br><h3>  Propietario modificado </h3><br><p>  El perfil es prescriptivo en su orientaci√≥n.  Espera que su c√≥digo utilice el sistema de tipos de forma idiom√°tica al definir los par√°metros de la funci√≥n.  En el siguiente ejemplo, <code>std::unique_ptr</code> , un tipo 'Propietario', se pasa a otra funci√≥n por referencia no constante.  De acuerdo con las reglas del perfil, se supone que el titular de la llamada modifica a los propietarios que pasan por referencia no constante. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_unique_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; upRef)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assumes_modification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> unique = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Line A auto ptr = unique.get(); *ptr = 10; // ok, ptr is valid use_unique_ptr(unique); *ptr = 10; // error, dangling pointer to the memory held by 'unique' at Line A }</span></span></code> </pre> <br><p>  En este ejemplo, obtenemos un puntero en bruto, <code>ptr</code> , a la memoria propiedad de <code>unique</code> .  Luego se pasa <code>unique</code> a la funci√≥n <code>use_unique_ptr</code> por referencia no constante.  Debido a que este es un uso no const de <code>unique</code> donde la funci√≥n podr√≠a hacer cualquier cosa, el an√°lisis asume que <code>unique</code> 'se invalida de alguna manera (por ejemplo, unique_ptr :: reset) lo que causar√≠a que <code>ptr</code> cuelgue. </p><br><h3>  M√°s ejemplos </h3><br><p>  Hay muchos otros casos que el an√°lisis puede detectar.  Pru√©belo en Visual Studio con su propio c√≥digo y vea lo que encuentra.  Consulte tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el blog de Herb</a> para obtener m√°s ejemplos y, si tiene curiosidad, lea el documento de Lifetime Profile. </p><br><h2>  Problemas conocidos </h2><br><p>  La implementaci√≥n actual no es totalmente compatible con el an√°lisis como se describe en el documento de Lifetime Profile.  Estas son las categor√≠as generales que no se implementan en esta versi√≥n. </p><br><ul><li>  <b>Anotaciones</b> : el documento presenta anotaciones (es decir, <code>[[gsl::lifetime-const]]</code> ) que no son compatibles.  Pr√°cticamente esto significa que si las reglas de an√°lisis predeterminadas no funcionan para su c√≥digo, no hay mucho que pueda hacer aparte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suprimir</a> falsos positivos. </li><li>  <b>Excepciones</b> : las rutas de manejo de excepciones, incluido el contenido de <code>catch</code> bloques <code>catch</code> , no se analizan actualmente. </li><li>  <b>Reglas predeterminadas para los</b> <b>tipos de STL</b> : en lugar de una anotaci√≥n de por <code>lifetime-const</code> , el documento recomienda que para las raras funciones de los miembros del contenedor de STL donde queremos anular los valores predeterminados, los tratemos como si estuvieran anotados.  Por ejemplo, una sobrecarga de <code>std::vector::at</code> no es <code>const</code> porque puede devolver una referencia no constante; sin embargo, sabemos que llamarla es <code>lifetime-const</code> por <code>lifetime-const</code> porque no invalida la memoria del vector.  No hemos completado el trabajo para hacer esta anotaci√≥n impl√≠cita de todos los tipos de contenedores STL. </li><li>  <b>Capturas de Lambda</b> : si una variable de pila se captura por referencia en una lambda, actualmente no detectamos si la lambda abandona el alcance de la variable capturada. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> captures_x = [&amp;x] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captures_x; <span class="hljs-comment"><span class="hljs-comment">// returns a dangling reference to 'x' }</span></span></code> </pre> </li></ul><br><h2>  Concluir </h2><br><p>  Pruebe el Verificador de perfil de por vida en Visual Studio 2019 Preview 2. Esperamos que ayude a identificar problemas de por vida en sus proyectos.  Si encuentra falsos positivos o falsos negativos, inf√≥rmelos para que podamos priorizar los escenarios que son importantes para usted.  Si tiene sugerencias o problemas con esta verificaci√≥n, o con cualquier funci√≥n de Visual Studio, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe un problema</a> o publ√≠quelo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores</a> y av√≠senos.  Tambi√©n estamos en Twitter en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@VisualC</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437660/">https://habr.com/ru/post/437660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437650/index.html">Una selecci√≥n de los mejores regalos para la persona entusiasta y geek el 23 de febrero</a></li>
<li><a href="../437652/index.html">Anuncio de TypeScript 3.3 RC</a></li>
<li><a href="../437654/index.html">Impresoras 3D de fotopol√≠mero econ√≥micas y econ√≥micas</a></li>
<li><a href="../437656/index.html">Elefante en una tienda china: impresoras 3D con un gran campo de impresi√≥n</a></li>
<li><a href="../437658/index.html">Gu√≠a: Thymeleaf + Spring. Parte 3</a></li>
<li><a href="../437664/index.html">Recuperaci√≥n compuesta</a></li>
<li><a href="../437666/index.html">Anuncio de la vista previa de F # 4.6</a></li>
<li><a href="../437670/index.html">Actualizaciones de back-end de MSVC en Visual Studio 2019 Preview 2: Nuevas optimizaciones, OpenMP y mejoras de rendimiento de compilaci√≥n</a></li>
<li><a href="../437672/index.html">Cyberd: Calcular el conocimiento de web3</a></li>
<li><a href="../437674/index.html">M√©todos de reconocimiento de objetos en 3D para veh√≠culos no tripulados. Informe Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>