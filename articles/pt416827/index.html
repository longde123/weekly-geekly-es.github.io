<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 🎶 🛂 Contentores para adultos (parte 02): um guia prático de terminologia 🍌 💤 🔳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitos modelos de construção de contêineres. Um contêiner é apenas uma versão executável de sua própria imagem. Portanto, a maneira de constru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contentores para adultos (parte 02): um guia prático de terminologia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Existem muitos modelos de construção de contêineres.  Um contêiner é apenas uma versão executável de sua própria imagem.  Portanto, a maneira de construir um contêiner está intimamente relacionada a como ele é iniciado. <br><br>  Algumas imagens de contêiner funcionam bem sem privilégios especiais; outras requerem privilégios de root.  Além disso, a mesma imagem / contêiner pode combinar vários padrões de construção e cenários de uso ao mesmo tempo. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  Abaixo, consideraremos os casos de uso de contêiner mais comuns. <br><br>  (Para uma introdução à terminologia de contêiner, consulte a primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte</a> ) <br><a name="habracut"></a><br><h3>  Cenários de uso de contêineres </h3><br><h4>  Contêineres para aplicativos </h4><br>  Os contêineres de aplicativos são o tipo mais comum de contêiner.  Desenvolvedores e proprietários de aplicativos os tratam e eles mesmos contêm o código-fonte, além de coisas como MySQL, Apache, MongoDB e Node.js. <br><br>  Um vasto ecossistema de contêineres de aplicativos está sendo formado.  Projetos como o Software Collections fornecem imagens de contêiner de aplicativos seguras e suportadas para o Red Hat Enterprise Linux.  Ao mesmo tempo, os membros da comunidade Red Hat estão desenvolvendo e dando suporte a contêineres de aplicativos inovadores. <br><br>  Na Red Hat, acreditamos que os contêineres de aplicativos geralmente não precisam de privilégios especiais.  No entanto, ao criar ambientes de produção de contêineres, são necessários outros contêineres. <br><br><h4>  Contêineres do sistema operacional </h4><br>  O contêiner do sistema operacional é um contêiner muito mais parecido com um sistema operacional virtual completo.  Esses contêineres também usam o kernel do host, mas executam o sistema init completo, o que lhes permite executar facilmente vários processos.  Exemplos de contêineres do sistema operacional são LXC e LXD. <br><br>  Os contêineres do sistema operacional podem, em princípio, ser emulados usando contêineres docker / OCI, desde que você possa executar o sistema dentro deles para que o usuário final possa instalar software dentro desses contêineres da maneira usual e percebê-los como um sistema operacional virtual completo. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Isso simplifica bastante a conteinerização de aplicativos existentes.  A Red Hat está trabalhando duro para simplificar os contêineres do sistema operacional, permitindo que o systemd execute dentro do contêiner e use o daemon usinado.  Embora muitos clientes ainda não estejam prontos para a arquitetura de microsserviço, a transição para um modelo de entrega de software em contêiner com base em imagens de contêiner ainda pode oferecer muitas vantagens. <br><br><h4>  Recipientes para animais de estimação </h4><br>  Embora a Red Hat recomende, promova e ofereça suporte ao uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos baseados em nuvem</a> no desenvolvimento de novos aplicativos, sabemos que nem todos os aplicativos existentes serão reescritos dessa maneira.  Em particular, porque muitos deles são tão únicos e inimitáveis ​​que, em comparação com aplicativos padrão, parecem animais de estimação (animais de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estimação</a> ) contra um rebanho de vacas.  É para essas aplicações que os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recipientes</a> especiais para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">animais de estimação</a> são projetados. <br><br>  Os contêineres para animais de estimação combinam a portabilidade e a conveniência de uma infraestrutura de contêiner construída com base em servidores de registro, imagens e hosts de contêineres com a flexibilidade de um ambiente de TI tradicional, implementado em um contêiner separado.  A idéia aqui é simplificar a conteinerização de aplicativos existentes devido à mesma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">capacidade de usar systemd dentro do contêiner</a> para usar ferramentas de automação existentes, instalações de software e outras ferramentas para criar facilmente imagens prontas para contêineres para lançamento. <br><br><h4>  Super Privilege Containers </h4><br>  Ao criar uma infra-estrutura de contêiner baseada em hosts de contêiner dedicados como o Host Atômico do Red Hat Enterprise Linux, os administradores de sistema ainda precisam gerenciar.  E os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Super Privileged Containers</a> (SPCs) provam ser muito úteis nesses ambientes distribuídos, seja Kubernetes, OpenShift ou até contêineres independentes.  Os SPCs podem até carregar módulos especializados do kernel, como systemtap. <br><br>  Na infraestrutura criada para executar contêineres, é provável que os administradores precisem de contêineres do SPC para executar tarefas como monitoramento, backup etc. É importante entender que, como os contêineres do SPC geralmente estão muito mais conectados ao núcleo do host, os administradores devem Preste atenção especial aos problemas de confiabilidade e padronização ao escolher sistemas operacionais host, especialmente em grandes ambientes em cluster e distribuídos que dificultam a solução de problemas.  Além disso, os administradores precisam garantir que o espaço do usuário no SPC seja compatível com o núcleo do host. <br><br><h4>  Ferramentas e software do sistema </h4><br>  As distribuições Linux sempre forneciam ao usuário software do sistema, como Rsyslogd, SSSD, sadc, etc. Tradicionalmente, esse software era instalado na forma de pacotes RPM ou DEB, mas com o advento dos formatos de embalagens de contêineres, tornou-se mais fácil e conveniente instalar imagens de contêineres.  Em particular, a Red Hat oferece coisas como contêineres prontos, como as ferramentas de virtualização da Red Hat, rsyslog, sssd e sadc. <br><br><h3>  Arquitetura de contêiner </h3><br>  À medida que a entrega de software em contêiner está ganhando força, novos padrões de design de contêiner estão surgindo.  Nesta seção, falaremos sobre alguns deles. <br><br>  A maneira como o contêiner é salvo no disco (em outras palavras, o formato da imagem) pode afetar muito a forma como ele é iniciado.  Por exemplo, um contêiner projetado para executar o sssd deve ter privilégios especiais toda vez que iniciar, caso contrário, não poderá executar seu trabalho.  Abaixo, consideramos brevemente os principais padrões que atualmente estão passando pelo estágio de formação ativa. <br><br><h4>  Imagens de aplicativos </h4><br>  É com essas imagens que os usuários finais lidam.  Os cenários para usar essas imagens variam de DBMS e servidores da Web a aplicativos individuais e barramentos de serviço.  Essas imagens podem ser criadas internamente pela organização ou fornecidas por fornecedores de software.  Portanto, os usuários finais geralmente se relacionam com o conteúdo desses contêineres autônomos com cautela e escrupulosidade.  Além disso, embora essa seja a opção mais fácil para o usuário final de contêineres, as imagens independentes são muito mais difíceis de projetar, criar e corrigir. <br><br><h4>  Imagens básicas </h4><br>  Uma imagem básica é um dos tipos mais simples de imagens.  No entanto, as pessoas podem denotar esse termo com várias coisas, por exemplo, uma montagem corporativa padrão ou até uma imagem de aplicativo.  Embora, estritamente falando, essas não sejam imagens básicas, mas intermediárias. <br>  Portanto, deixe claro que a imagem base é uma imagem que não possui uma camada pai.  As imagens básicas geralmente contêm uma cópia limpa do sistema operacional, bem como as ferramentas necessárias para instalar pacotes de software ou atualizar a imagem posteriormente (yum, rpm, apt-get, dnf, microdnf).  Imagens básicas podem ser coletadas manualmente pelo usuário final, mas na prática elas geralmente são criadas e liberadas por comunidades de desenvolvimento (por exemplo, Debian, Fedora ou CentOS) ou fornecedores de software (por exemplo, Red Hat).  A origem da imagem base é fundamental para a segurança.  Resumindo, o principal e único objetivo da imagem básica é fornecer uma base com base na qual você pode criar suas imagens filhas.  Ao usar o dockerfile, a seleção da imagem base subjacente é feita explicitamente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Imagens do construtor </h4><br>  Este é um tipo especial de imagem com base no qual as imagens filho dos contêineres do aplicativo são criadas.  As imagens do construtor incluem tudo, exceto o código-fonte escrito pelos desenvolvedores, como bibliotecas de SO, tempos de execução de idiomas, middleware e ferramentas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">origem para imagem</a> . <br><br>  Na inicialização, a imagem do construtor exibe o código-fonte do aplicativo gravado pelos desenvolvedores e cria uma imagem filho do contêiner do aplicativo que está pronto para ser lançado, que pode ser executado em um ambiente de desenvolvimento ou produção. <br><br>  Digamos que os desenvolvedores tenham escrito o código PHP para o aplicativo e desejem executá-lo no contêiner.  Para fazer isso, eles simplesmente pegam a imagem de construtor do PHP e passam a URL no site do GitHub, onde seu código é armazenado.  Como resultado, os desenvolvedores preparam uma imagem de contêiner de aplicativo pronta para lançamento que contém o Red Hat Enterprise Linux, PHP da Software Collections e, é claro, o código PHP de origem para o aplicativo. <br><br>  As imagens do construtor são uma maneira poderosa, fácil e rápida de transformar o código-fonte em um contêiner criado com base em componentes confiáveis. <br><br><h4>  Componentes em contêiner </h4><br>  Um contêiner destina-se principalmente a ser implantado como um componente de um sistema de software maior, e não como uma unidade independente.  E há duas razões principais para isso. <br><br>  Em primeiro lugar, a arquitetura de microsserviço aumenta a liberdade de escolha de componentes e também leva a um aumento no número de componentes dos quais os aplicativos e sistemas de software são compostos.  Componentes em contêineres ajudam a implantar esses sistemas de maneira mais rápida e fácil.  Por exemplo, imagens de contêiner facilitam a solução do problema da coexistência de versões diferentes do mesmo componente.  E ferramentas de definição de aplicativo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implantações yaml / json</a> no Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">broker de serviço aberto</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenShift Templates</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Helm Charts,</a> fornecem a criação de descrições de aplicativos de alto nível. <br><br>  Em segundo lugar, longe de sempre todas as partes de um sistema de software podem ser facilmente contêineres.  Portanto, faz sentido executar a conteinerização apenas para componentes individuais mais adequados para isso ou mais promissores em termos de resultados.  Em aplicativos multisserviço, uma parte dos serviços pode ser implantada como contêineres e a outra usando métodos tradicionais, como RPM ou scripts de instalação, consulte contêineres de animais de estimação.  Além disso, alguns componentes podem ser difíceis de contêineres, porque são mal divididos em componentes, ou estão vinculados a algum hardware especial, ou usam chamadas de API de kernel de baixo nível etc. Portanto, em um grande sistema de software, provavelmente haverá peças que podem ser conteinerizadas e peças que não podem ser contêineres.  Componentes em container são o que pode ser em container e já em container.  Os componentes em contêineres são projetados para serem executados como parte de um aplicativo específico, e não sozinhos.  É importante entender que eles não se destinam à operação autônoma, pois são úteis apenas como parte de um sistema de software maior e, isoladamente, são praticamente inúteis. <br><br>  Por exemplo, no OpenShift Enterprise 3.0, a maior parte do código principal foi implantada usando o RPM, mas após a instalação, os administradores implantaram o roteador e o registro como contêineres.  O OpenShift 3.1 introduziu a opção de implantação em contêiner para master, node, openvswitch e etcd e, uma vez instalados, os administradores também podem implantar elasticsearch, fluentd e kibana como contêineres. <br><br>  Embora o instalador do OpenShift ainda esteja fazendo alterações no sistema de arquivos do servidor, todos os principais componentes de software agora podem ser instalados usando imagens de contêiner.  Portanto, esses componentes em contêiner, por exemplo, uma instância da imagem etcd incorporada no OpenShift, nunca devem - e não serão - usados ​​para armazenar o código-fonte do aplicativo com o qual seus clientes estão trabalhando, simplesmente porque esses componentes em contêiner devem ser executados como parte Plataforma de contêiner OpenShift. <br><br>  Nas novas versões do OpenShift, a tendência para a conteinerização de componentes está se intensificando e outros desenvolvedores de software estão usando cada vez mais essa abordagem. <br><br><h4>  Imagens do implantador </h4><br>  A imagem do implementador é um tipo especial de contêiner que, quando iniciado, implanta ou gerencia outros contêineres.  O Implantador permite implementar esquemas de implantação complexos, por exemplo, iniciando contêineres em uma determinada ordem ou executando algumas ações no primeiro início, como gerar um esquema de dados ou preencher inicialmente o banco de dados. <br><br>  Por exemplo, no OpenShift, o modelo "tipo de imagem / contêiner" é usado para implantar logs e métricas.  A implantação desses componentes usando imagens do implementador permite que os engenheiros do OpenShift controlem a ordem em que os vários componentes são executados e verifique se eles funcionam corretamente. <br><br><h4>  Imagens intermediárias </h4><br>  Uma imagem intermediária é qualquer imagem de um contêiner que depende de uma imagem base.  Assemblies de kernel, middleware e tempos de execução de idioma geralmente são implementados como camadas adicionais na parte superior da imagem base e, em seguida, especificados na diretiva FROM com esta imagem base.  As imagens intermediárias geralmente não são usadas por si próprias, mas como blocos de construção na criação de uma imagem autônoma. <br><br>  Diferentes camadas da imagem, como regra, estão envolvidas em diferentes grupos de especialistas.  Por exemplo, os administradores de sistema são responsáveis ​​pela camada de montagem do kernel e os desenvolvedores pela camada de middleware.  Ao mesmo tempo, as camadas subjacentes preparadas por uma equipe atuam como uma imagem intermediária para os responsáveis ​​por camadas de nível superior.  Embora algumas vezes essas imagens intermediárias possam ser usadas de forma autônoma, principalmente no teste. <br><br><h4>  Imagens multiuso (intermodais) </h4><br>  Imagens de contêiner multiuso são imagens com uma arquitetura híbrida.  Por exemplo, muitas das imagens no Red Hat Software Collections podem ser usadas de duas maneiras.  Primeiramente, como contêineres de aplicativos regulares com o servidor Ruby on Rails e Apache completo.  Em segundo lugar, você pode usá-los como imagens do construtor para o OpenShift Container Platform e criar imagens filho baseadas nelas, contendo Ruby on Rails, Apache e o código do aplicativo que você passou para o processo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">origem para imagem</a> ao criar uma imagem filho. <br><br>  Observe que as imagens multiuso estão ganhando popularidade porque permitem que você resolva duas tarefas fundamentalmente diferentes usando a mesma imagem. <br><br><h4>  Contêineres do sistema </h4><br>  Ao implantar o software do sistema na forma de contêineres, os últimos geralmente exigem privilégios de superusuário.  Para simplificar essa opção de implantação e garantir que esses contêineres sejam iniciados antes do tempo de execução do contêiner e do sistema de orquestração, a Red Hat desenvolveu um modelo especial chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contêineres do sistema</a> .  Esses contêineres são iniciados durante o processo de inicialização do sistema operacional usando systemd e o comando atômico, o que os torna independentes de qualquer sistema de orquestração de tempo de execução ou contêiner.  Hoje, a Red Hat oferece contêineres de sistema para rsyslog, cockpit, etcd e flanneld e expandirá essa lista no futuro. <br><br>  Os contêineres do sistema simplificam bastante a adição seletiva desses serviços ao Red Hat Enterprise Linux e Atomic Host. <br><br><h3>  Conclusão </h3><br>  Os contêineres parecem ser algo bastante simples para o consumidor final, mas muitas questões surgem ao criar um ambiente de produção de contêineres.  Para discutir proveitosamente a arquitetura e os métodos de construção de tais ambientes, é necessária uma terminologia uniforme para todos os participantes.  Quanto mais você se aprofunda no design e na construção de tais ambientes, mais armadilhas surgem.  Por fim, lembramos apenas alguns deles. <br><br>  As pessoas geralmente não vêem a diferença entre os termos "imagem do contêiner" e "repositório", especialmente quando são usados ​​nos comandos do docker.  Mas se você pode usar os comandos sem entender as diferenças, ao trabalhar na arquitetura dos ambientes de contêiner, você deve entender claramente que o repositório é realmente a principal estrutura de dados. <br><br>  Também é muito fácil entender mal a diferença entre namespaces, repositórios, camadas de imagem e tags.  Cada uma dessas coisas tem seu objetivo na arquitetura de contêiner.  E embora fornecedores e usuários os usem para uma variedade de propósitos, eles são apenas ferramentas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  O objetivo deste artigo é ajudá-lo a entender a terminologia para que você possa criar arquiteturas mais avançadas.  Por exemplo, imagine que você acabou de ser contratado para desenvolver uma infraestrutura que delimite a disponibilidade de namespaces, repositórios e, além disso, tags e camadas, dependendo das funções e regras de negócios.  E a última - lembre-se de que a maneira como o contêiner é montado determina em grande parte como é iniciado (orquestração, privilégios etc.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416827/">https://habr.com/ru/post/pt416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416817/index.html">3º lugar na fase de qualificação do DataScienceGame 2018</a></li>
<li><a href="../pt416819/index.html">Adeus, microsserviços: de cem crianças problemáticas a uma estrela</a></li>
<li><a href="../pt416821/index.html">Como o JS funciona: comunicações WebRTC e P2P</a></li>
<li><a href="../pt416823/index.html">Sangue, suor e pixels: o que é o livro de Jason Schreier</a></li>
<li><a href="../pt416825/index.html">Como NÃO ser um desenvolvedor medíocre</a></li>
<li><a href="../pt416829/index.html">Padrão de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../pt416831/index.html">O roteamento externo do tráfego russo interno será reduzido para 5%</a></li>
<li><a href="../pt416833/index.html">Bem-vindo ao MskDotNet Meetup # 24</a></li>
<li><a href="../pt416837/index.html"># Dashanalune 0</a></li>
<li><a href="../pt416839/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>