<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥š ğŸ¶ ğŸ›‚ Contentores para adultos (parte 02): um guia prÃ¡tico de terminologia ğŸŒ ğŸ’¤ ğŸ”³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitos modelos de construÃ§Ã£o de contÃªineres. Um contÃªiner Ã© apenas uma versÃ£o executÃ¡vel de sua prÃ³pria imagem. Portanto, a maneira de constru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contentores para adultos (parte 02): um guia prÃ¡tico de terminologia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Existem muitos modelos de construÃ§Ã£o de contÃªineres.  Um contÃªiner Ã© apenas uma versÃ£o executÃ¡vel de sua prÃ³pria imagem.  Portanto, a maneira de construir um contÃªiner estÃ¡ intimamente relacionada a como ele Ã© iniciado. <br><br>  Algumas imagens de contÃªiner funcionam bem sem privilÃ©gios especiais; outras requerem privilÃ©gios de root.  AlÃ©m disso, a mesma imagem / contÃªiner pode combinar vÃ¡rios padrÃµes de construÃ§Ã£o e cenÃ¡rios de uso ao mesmo tempo. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  Abaixo, consideraremos os casos de uso de contÃªiner mais comuns. <br><br>  (Para uma introduÃ§Ã£o Ã  terminologia de contÃªiner, consulte a primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte</a> ) <br><a name="habracut"></a><br><h3>  CenÃ¡rios de uso de contÃªineres </h3><br><h4>  ContÃªineres para aplicativos </h4><br>  Os contÃªineres de aplicativos sÃ£o o tipo mais comum de contÃªiner.  Desenvolvedores e proprietÃ¡rios de aplicativos os tratam e eles mesmos contÃªm o cÃ³digo-fonte, alÃ©m de coisas como MySQL, Apache, MongoDB e Node.js. <br><br>  Um vasto ecossistema de contÃªineres de aplicativos estÃ¡ sendo formado.  Projetos como o Software Collections fornecem imagens de contÃªiner de aplicativos seguras e suportadas para o Red Hat Enterprise Linux.  Ao mesmo tempo, os membros da comunidade Red Hat estÃ£o desenvolvendo e dando suporte a contÃªineres de aplicativos inovadores. <br><br>  Na Red Hat, acreditamos que os contÃªineres de aplicativos geralmente nÃ£o precisam de privilÃ©gios especiais.  No entanto, ao criar ambientes de produÃ§Ã£o de contÃªineres, sÃ£o necessÃ¡rios outros contÃªineres. <br><br><h4>  ContÃªineres do sistema operacional </h4><br>  O contÃªiner do sistema operacional Ã© um contÃªiner muito mais parecido com um sistema operacional virtual completo.  Esses contÃªineres tambÃ©m usam o kernel do host, mas executam o sistema init completo, o que lhes permite executar facilmente vÃ¡rios processos.  Exemplos de contÃªineres do sistema operacional sÃ£o LXC e LXD. <br><br>  Os contÃªineres do sistema operacional podem, em princÃ­pio, ser emulados usando contÃªineres docker / OCI, desde que vocÃª possa executar o sistema dentro deles para que o usuÃ¡rio final possa instalar software dentro desses contÃªineres da maneira usual e percebÃª-los como um sistema operacional virtual completo. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Isso simplifica bastante a conteinerizaÃ§Ã£o de aplicativos existentes.  A Red Hat estÃ¡ trabalhando duro para simplificar os contÃªineres do sistema operacional, permitindo que o systemd execute dentro do contÃªiner e use o daemon usinado.  Embora muitos clientes ainda nÃ£o estejam prontos para a arquitetura de microsserviÃ§o, a transiÃ§Ã£o para um modelo de entrega de software em contÃªiner com base em imagens de contÃªiner ainda pode oferecer muitas vantagens. <br><br><h4>  Recipientes para animais de estimaÃ§Ã£o </h4><br>  Embora a Red Hat recomende, promova e ofereÃ§a suporte ao uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos baseados em nuvem</a> no desenvolvimento de novos aplicativos, sabemos que nem todos os aplicativos existentes serÃ£o reescritos dessa maneira.  Em particular, porque muitos deles sÃ£o tÃ£o Ãºnicos e inimitÃ¡veis â€‹â€‹que, em comparaÃ§Ã£o com aplicativos padrÃ£o, parecem animais de estimaÃ§Ã£o (animais de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estimaÃ§Ã£o</a> ) contra um rebanho de vacas.  Ã‰ para essas aplicaÃ§Ãµes que os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recipientes</a> especiais para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">animais de estimaÃ§Ã£o</a> sÃ£o projetados. <br><br>  Os contÃªineres para animais de estimaÃ§Ã£o combinam a portabilidade e a conveniÃªncia de uma infraestrutura de contÃªiner construÃ­da com base em servidores de registro, imagens e hosts de contÃªineres com a flexibilidade de um ambiente de TI tradicional, implementado em um contÃªiner separado.  A idÃ©ia aqui Ã© simplificar a conteinerizaÃ§Ã£o de aplicativos existentes devido Ã  mesma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">capacidade de usar systemd dentro do contÃªiner</a> para usar ferramentas de automaÃ§Ã£o existentes, instalaÃ§Ãµes de software e outras ferramentas para criar facilmente imagens prontas para contÃªineres para lanÃ§amento. <br><br><h4>  Super Privilege Containers </h4><br>  Ao criar uma infra-estrutura de contÃªiner baseada em hosts de contÃªiner dedicados como o Host AtÃ´mico do Red Hat Enterprise Linux, os administradores de sistema ainda precisam gerenciar.  E os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Super Privileged Containers</a> (SPCs) provam ser muito Ãºteis nesses ambientes distribuÃ­dos, seja Kubernetes, OpenShift ou atÃ© contÃªineres independentes.  Os SPCs podem atÃ© carregar mÃ³dulos especializados do kernel, como systemtap. <br><br>  Na infraestrutura criada para executar contÃªineres, Ã© provÃ¡vel que os administradores precisem de contÃªineres do SPC para executar tarefas como monitoramento, backup etc. Ã‰ importante entender que, como os contÃªineres do SPC geralmente estÃ£o muito mais conectados ao nÃºcleo do host, os administradores devem Preste atenÃ§Ã£o especial aos problemas de confiabilidade e padronizaÃ§Ã£o ao escolher sistemas operacionais host, especialmente em grandes ambientes em cluster e distribuÃ­dos que dificultam a soluÃ§Ã£o de problemas.  AlÃ©m disso, os administradores precisam garantir que o espaÃ§o do usuÃ¡rio no SPC seja compatÃ­vel com o nÃºcleo do host. <br><br><h4>  Ferramentas e software do sistema </h4><br>  As distribuiÃ§Ãµes Linux sempre forneciam ao usuÃ¡rio software do sistema, como Rsyslogd, SSSD, sadc, etc. Tradicionalmente, esse software era instalado na forma de pacotes RPM ou DEB, mas com o advento dos formatos de embalagens de contÃªineres, tornou-se mais fÃ¡cil e conveniente instalar imagens de contÃªineres.  Em particular, a Red Hat oferece coisas como contÃªineres prontos, como as ferramentas de virtualizaÃ§Ã£o da Red Hat, rsyslog, sssd e sadc. <br><br><h3>  Arquitetura de contÃªiner </h3><br>  Ã€ medida que a entrega de software em contÃªiner estÃ¡ ganhando forÃ§a, novos padrÃµes de design de contÃªiner estÃ£o surgindo.  Nesta seÃ§Ã£o, falaremos sobre alguns deles. <br><br>  A maneira como o contÃªiner Ã© salvo no disco (em outras palavras, o formato da imagem) pode afetar muito a forma como ele Ã© iniciado.  Por exemplo, um contÃªiner projetado para executar o sssd deve ter privilÃ©gios especiais toda vez que iniciar, caso contrÃ¡rio, nÃ£o poderÃ¡ executar seu trabalho.  Abaixo, consideramos brevemente os principais padrÃµes que atualmente estÃ£o passando pelo estÃ¡gio de formaÃ§Ã£o ativa. <br><br><h4>  Imagens de aplicativos </h4><br>  Ã‰ com essas imagens que os usuÃ¡rios finais lidam.  Os cenÃ¡rios para usar essas imagens variam de DBMS e servidores da Web a aplicativos individuais e barramentos de serviÃ§o.  Essas imagens podem ser criadas internamente pela organizaÃ§Ã£o ou fornecidas por fornecedores de software.  Portanto, os usuÃ¡rios finais geralmente se relacionam com o conteÃºdo desses contÃªineres autÃ´nomos com cautela e escrupulosidade.  AlÃ©m disso, embora essa seja a opÃ§Ã£o mais fÃ¡cil para o usuÃ¡rio final de contÃªineres, as imagens independentes sÃ£o muito mais difÃ­ceis de projetar, criar e corrigir. <br><br><h4>  Imagens bÃ¡sicas </h4><br>  Uma imagem bÃ¡sica Ã© um dos tipos mais simples de imagens.  No entanto, as pessoas podem denotar esse termo com vÃ¡rias coisas, por exemplo, uma montagem corporativa padrÃ£o ou atÃ© uma imagem de aplicativo.  Embora, estritamente falando, essas nÃ£o sejam imagens bÃ¡sicas, mas intermediÃ¡rias. <br>  Portanto, deixe claro que a imagem base Ã© uma imagem que nÃ£o possui uma camada pai.  As imagens bÃ¡sicas geralmente contÃªm uma cÃ³pia limpa do sistema operacional, bem como as ferramentas necessÃ¡rias para instalar pacotes de software ou atualizar a imagem posteriormente (yum, rpm, apt-get, dnf, microdnf).  Imagens bÃ¡sicas podem ser coletadas manualmente pelo usuÃ¡rio final, mas na prÃ¡tica elas geralmente sÃ£o criadas e liberadas por comunidades de desenvolvimento (por exemplo, Debian, Fedora ou CentOS) ou fornecedores de software (por exemplo, Red Hat).  A origem da imagem base Ã© fundamental para a seguranÃ§a.  Resumindo, o principal e Ãºnico objetivo da imagem bÃ¡sica Ã© fornecer uma base com base na qual vocÃª pode criar suas imagens filhas.  Ao usar o dockerfile, a seleÃ§Ã£o da imagem base subjacente Ã© feita explicitamente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Imagens do construtor </h4><br>  Este Ã© um tipo especial de imagem com base no qual as imagens filho dos contÃªineres do aplicativo sÃ£o criadas.  As imagens do construtor incluem tudo, exceto o cÃ³digo-fonte escrito pelos desenvolvedores, como bibliotecas de SO, tempos de execuÃ§Ã£o de idiomas, middleware e ferramentas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">origem para imagem</a> . <br><br>  Na inicializaÃ§Ã£o, a imagem do construtor exibe o cÃ³digo-fonte do aplicativo gravado pelos desenvolvedores e cria uma imagem filho do contÃªiner do aplicativo que estÃ¡ pronto para ser lanÃ§ado, que pode ser executado em um ambiente de desenvolvimento ou produÃ§Ã£o. <br><br>  Digamos que os desenvolvedores tenham escrito o cÃ³digo PHP para o aplicativo e desejem executÃ¡-lo no contÃªiner.  Para fazer isso, eles simplesmente pegam a imagem de construtor do PHP e passam a URL no site do GitHub, onde seu cÃ³digo Ã© armazenado.  Como resultado, os desenvolvedores preparam uma imagem de contÃªiner de aplicativo pronta para lanÃ§amento que contÃ©m o Red Hat Enterprise Linux, PHP da Software Collections e, Ã© claro, o cÃ³digo PHP de origem para o aplicativo. <br><br>  As imagens do construtor sÃ£o uma maneira poderosa, fÃ¡cil e rÃ¡pida de transformar o cÃ³digo-fonte em um contÃªiner criado com base em componentes confiÃ¡veis. <br><br><h4>  Componentes em contÃªiner </h4><br>  Um contÃªiner destina-se principalmente a ser implantado como um componente de um sistema de software maior, e nÃ£o como uma unidade independente.  E hÃ¡ duas razÃµes principais para isso. <br><br>  Em primeiro lugar, a arquitetura de microsserviÃ§o aumenta a liberdade de escolha de componentes e tambÃ©m leva a um aumento no nÃºmero de componentes dos quais os aplicativos e sistemas de software sÃ£o compostos.  Componentes em contÃªineres ajudam a implantar esses sistemas de maneira mais rÃ¡pida e fÃ¡cil.  Por exemplo, imagens de contÃªiner facilitam a soluÃ§Ã£o do problema da coexistÃªncia de versÃµes diferentes do mesmo componente.  E ferramentas de definiÃ§Ã£o de aplicativo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implantaÃ§Ãµes yaml / json</a> no Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">broker de serviÃ§o aberto</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenShift Templates</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Helm Charts,</a> fornecem a criaÃ§Ã£o de descriÃ§Ãµes de aplicativos de alto nÃ­vel. <br><br>  Em segundo lugar, longe de sempre todas as partes de um sistema de software podem ser facilmente contÃªineres.  Portanto, faz sentido executar a conteinerizaÃ§Ã£o apenas para componentes individuais mais adequados para isso ou mais promissores em termos de resultados.  Em aplicativos multisserviÃ§o, uma parte dos serviÃ§os pode ser implantada como contÃªineres e a outra usando mÃ©todos tradicionais, como RPM ou scripts de instalaÃ§Ã£o, consulte contÃªineres de animais de estimaÃ§Ã£o.  AlÃ©m disso, alguns componentes podem ser difÃ­ceis de contÃªineres, porque sÃ£o mal divididos em componentes, ou estÃ£o vinculados a algum hardware especial, ou usam chamadas de API de kernel de baixo nÃ­vel etc. Portanto, em um grande sistema de software, provavelmente haverÃ¡ peÃ§as que podem ser conteinerizadas e peÃ§as que nÃ£o podem ser contÃªineres.  Componentes em container sÃ£o o que pode ser em container e jÃ¡ em container.  Os componentes em contÃªineres sÃ£o projetados para serem executados como parte de um aplicativo especÃ­fico, e nÃ£o sozinhos.  Ã‰ importante entender que eles nÃ£o se destinam Ã  operaÃ§Ã£o autÃ´noma, pois sÃ£o Ãºteis apenas como parte de um sistema de software maior e, isoladamente, sÃ£o praticamente inÃºteis. <br><br>  Por exemplo, no OpenShift Enterprise 3.0, a maior parte do cÃ³digo principal foi implantada usando o RPM, mas apÃ³s a instalaÃ§Ã£o, os administradores implantaram o roteador e o registro como contÃªineres.  O OpenShift 3.1 introduziu a opÃ§Ã£o de implantaÃ§Ã£o em contÃªiner para master, node, openvswitch e etcd e, uma vez instalados, os administradores tambÃ©m podem implantar elasticsearch, fluentd e kibana como contÃªineres. <br><br>  Embora o instalador do OpenShift ainda esteja fazendo alteraÃ§Ãµes no sistema de arquivos do servidor, todos os principais componentes de software agora podem ser instalados usando imagens de contÃªiner.  Portanto, esses componentes em contÃªiner, por exemplo, uma instÃ¢ncia da imagem etcd incorporada no OpenShift, nunca devem - e nÃ£o serÃ£o - usados â€‹â€‹para armazenar o cÃ³digo-fonte do aplicativo com o qual seus clientes estÃ£o trabalhando, simplesmente porque esses componentes em contÃªiner devem ser executados como parte Plataforma de contÃªiner OpenShift. <br><br>  Nas novas versÃµes do OpenShift, a tendÃªncia para a conteinerizaÃ§Ã£o de componentes estÃ¡ se intensificando e outros desenvolvedores de software estÃ£o usando cada vez mais essa abordagem. <br><br><h4>  Imagens do implantador </h4><br>  A imagem do implementador Ã© um tipo especial de contÃªiner que, quando iniciado, implanta ou gerencia outros contÃªineres.  O Implantador permite implementar esquemas de implantaÃ§Ã£o complexos, por exemplo, iniciando contÃªineres em uma determinada ordem ou executando algumas aÃ§Ãµes no primeiro inÃ­cio, como gerar um esquema de dados ou preencher inicialmente o banco de dados. <br><br>  Por exemplo, no OpenShift, o modelo "tipo de imagem / contÃªiner" Ã© usado para implantar logs e mÃ©tricas.  A implantaÃ§Ã£o desses componentes usando imagens do implementador permite que os engenheiros do OpenShift controlem a ordem em que os vÃ¡rios componentes sÃ£o executados e verifique se eles funcionam corretamente. <br><br><h4>  Imagens intermediÃ¡rias </h4><br>  Uma imagem intermediÃ¡ria Ã© qualquer imagem de um contÃªiner que depende de uma imagem base.  Assemblies de kernel, middleware e tempos de execuÃ§Ã£o de idioma geralmente sÃ£o implementados como camadas adicionais na parte superior da imagem base e, em seguida, especificados na diretiva FROM com esta imagem base.  As imagens intermediÃ¡rias geralmente nÃ£o sÃ£o usadas por si prÃ³prias, mas como blocos de construÃ§Ã£o na criaÃ§Ã£o de uma imagem autÃ´noma. <br><br>  Diferentes camadas da imagem, como regra, estÃ£o envolvidas em diferentes grupos de especialistas.  Por exemplo, os administradores de sistema sÃ£o responsÃ¡veis â€‹â€‹pela camada de montagem do kernel e os desenvolvedores pela camada de middleware.  Ao mesmo tempo, as camadas subjacentes preparadas por uma equipe atuam como uma imagem intermediÃ¡ria para os responsÃ¡veis â€‹â€‹por camadas de nÃ­vel superior.  Embora algumas vezes essas imagens intermediÃ¡rias possam ser usadas de forma autÃ´noma, principalmente no teste. <br><br><h4>  Imagens multiuso (intermodais) </h4><br>  Imagens de contÃªiner multiuso sÃ£o imagens com uma arquitetura hÃ­brida.  Por exemplo, muitas das imagens no Red Hat Software Collections podem ser usadas de duas maneiras.  Primeiramente, como contÃªineres de aplicativos regulares com o servidor Ruby on Rails e Apache completo.  Em segundo lugar, vocÃª pode usÃ¡-los como imagens do construtor para o OpenShift Container Platform e criar imagens filho baseadas nelas, contendo Ruby on Rails, Apache e o cÃ³digo do aplicativo que vocÃª passou para o processo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">origem para imagem</a> ao criar uma imagem filho. <br><br>  Observe que as imagens multiuso estÃ£o ganhando popularidade porque permitem que vocÃª resolva duas tarefas fundamentalmente diferentes usando a mesma imagem. <br><br><h4>  ContÃªineres do sistema </h4><br>  Ao implantar o software do sistema na forma de contÃªineres, os Ãºltimos geralmente exigem privilÃ©gios de superusuÃ¡rio.  Para simplificar essa opÃ§Ã£o de implantaÃ§Ã£o e garantir que esses contÃªineres sejam iniciados antes do tempo de execuÃ§Ã£o do contÃªiner e do sistema de orquestraÃ§Ã£o, a Red Hat desenvolveu um modelo especial chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contÃªineres do sistema</a> .  Esses contÃªineres sÃ£o iniciados durante o processo de inicializaÃ§Ã£o do sistema operacional usando systemd e o comando atÃ´mico, o que os torna independentes de qualquer sistema de orquestraÃ§Ã£o de tempo de execuÃ§Ã£o ou contÃªiner.  Hoje, a Red Hat oferece contÃªineres de sistema para rsyslog, cockpit, etcd e flanneld e expandirÃ¡ essa lista no futuro. <br><br>  Os contÃªineres do sistema simplificam bastante a adiÃ§Ã£o seletiva desses serviÃ§os ao Red Hat Enterprise Linux e Atomic Host. <br><br><h3>  ConclusÃ£o </h3><br>  Os contÃªineres parecem ser algo bastante simples para o consumidor final, mas muitas questÃµes surgem ao criar um ambiente de produÃ§Ã£o de contÃªineres.  Para discutir proveitosamente a arquitetura e os mÃ©todos de construÃ§Ã£o de tais ambientes, Ã© necessÃ¡ria uma terminologia uniforme para todos os participantes.  Quanto mais vocÃª se aprofunda no design e na construÃ§Ã£o de tais ambientes, mais armadilhas surgem.  Por fim, lembramos apenas alguns deles. <br><br>  As pessoas geralmente nÃ£o vÃªem a diferenÃ§a entre os termos "imagem do contÃªiner" e "repositÃ³rio", especialmente quando sÃ£o usados â€‹â€‹nos comandos do docker.  Mas se vocÃª pode usar os comandos sem entender as diferenÃ§as, ao trabalhar na arquitetura dos ambientes de contÃªiner, vocÃª deve entender claramente que o repositÃ³rio Ã© realmente a principal estrutura de dados. <br><br>  TambÃ©m Ã© muito fÃ¡cil entender mal a diferenÃ§a entre namespaces, repositÃ³rios, camadas de imagem e tags.  Cada uma dessas coisas tem seu objetivo na arquitetura de contÃªiner.  E embora fornecedores e usuÃ¡rios os usem para uma variedade de propÃ³sitos, eles sÃ£o apenas ferramentas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  O objetivo deste artigo Ã© ajudÃ¡-lo a entender a terminologia para que vocÃª possa criar arquiteturas mais avanÃ§adas.  Por exemplo, imagine que vocÃª acabou de ser contratado para desenvolver uma infraestrutura que delimite a disponibilidade de namespaces, repositÃ³rios e, alÃ©m disso, tags e camadas, dependendo das funÃ§Ãµes e regras de negÃ³cios.  E a Ãºltima - lembre-se de que a maneira como o contÃªiner Ã© montado determina em grande parte como Ã© iniciado (orquestraÃ§Ã£o, privilÃ©gios etc.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416827/">https://habr.com/ru/post/pt416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416817/index.html">3Âº lugar na fase de qualificaÃ§Ã£o do DataScienceGame 2018</a></li>
<li><a href="../pt416819/index.html">Adeus, microsserviÃ§os: de cem crianÃ§as problemÃ¡ticas a uma estrela</a></li>
<li><a href="../pt416821/index.html">Como o JS funciona: comunicaÃ§Ãµes WebRTC e P2P</a></li>
<li><a href="../pt416823/index.html">Sangue, suor e pixels: o que Ã© o livro de Jason Schreier</a></li>
<li><a href="../pt416825/index.html">Como NÃƒO ser um desenvolvedor medÃ­ocre</a></li>
<li><a href="../pt416829/index.html">PadrÃ£o de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../pt416831/index.html">O roteamento externo do trÃ¡fego russo interno serÃ¡ reduzido para 5%</a></li>
<li><a href="../pt416833/index.html">Bem-vindo ao MskDotNet Meetup # 24</a></li>
<li><a href="../pt416837/index.html"># Dashanalune 0</a></li>
<li><a href="../pt416839/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Aula 3: Estouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£o, Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>