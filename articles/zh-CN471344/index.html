<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💎 📌 ℹ️ 再次关于Java中的ImmutableList 🥟 🤚 🖼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我以前的文章“ 用Java掩盖ImmutableList”中，我提出了一个解决方案，解决了Java中不存在不可变列表的问题，在Java中无论现在还是现在都不是固定的。 


 然后，仅在“有这样一个想法”的级别上制定解决方案，并且代码中的实现歪曲了，因此一切都被怀疑了。 在本文中，我提出了一种改进...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>再次关于Java中的ImmutableList</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471344/"><p> 在我以前的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用Java掩盖ImmutableList”中，</a>我提出了一个解决方案，解决了Java中不存在不可变列表的问题，在Java中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无论现在还是现在都不</a>是固定的。 </p><br><p> 然后，仅在“有这样一个想法”的级别上制定解决方案，并且代码中的实现歪曲了，因此一切都被怀疑了。 在本文中，我提出了一种改进的解决方案。 使用的逻辑和API已达到可接受的水平。 在代码中的实现达到beta级。 </p><a name="habracut"></a><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p>我们将使用原始文章中的定义。 特别是，这意味着<code>ImmutableList</code>是对某些对象的引用的不可变列表。 如果事实证明这些对象不是不可变的，那么尽管名称如此，列表也将不是一个不可变的对象。 实际上，这不太可能伤害任何人，但是为了避免不合理的期望，有必要提一下。 </p><br><p> 同样很明显，可以通过反射或在同一包中创建自己的类，然后弹出列表的受保护字段或类似的方式来“破坏”列表的不变性。 </p><br><p> 与原始文章不同，我们不会坚持“全有或全无”的原则：那里的作者似乎认为，如果不能在JDK级别解决问题，那么就什么也不做。  （实际上，还有另一个问题，“无法解决”或“ Java作者不希望解决它。”在我看来，通过添加其他接口，类和方法来使现有集合更接近，还是有可能的。所需的外观，虽然比您立即想到的外观要漂亮，但现在并不是这样。） </p><br><p> 我们将创建一个可以与Java现有集合成功共存的库。 </p><br><p> 图书馆的主要思想： </p><br><ul><li> 有<code>ImmutableList</code>和<code>MutableList</code> 。 通过强制转换类型，不可能从另一个中获取一个。 </li><li> 在我们要使用库进行改进的项目中，我们用这两个接口之一替换了所有<code>List</code> 。 如果在某个时候您不能没有<code>List</code> ，那么我们将在第一个机会将<code>List</code>从/转换为两个接口之一。 这同样适用于使用<code>List</code>接收/传输数据到第三方库的时刻。 </li><li>  <code>ImmutableList</code> ， <code>MutableList</code> ， <code>List</code>之间的相互转换应尽快执行（也就是说，如果可能的话，不复制列表）。 没有“便宜的”往返转换，整个想法就开始变得可疑。 </li></ul><br><p> 应该注意的是，仅考虑列表，因为目前仅在库中实现它们。 但是，没有什么可以阻止库对<code>Set</code>和<code>Map</code>补充。 </p><br><h2 id="api">  API </h2><br><h3 id="immutablelist"> 不可变列表 </h3><br><p>  <code>ImmutableList</code>是<code>ReadOnlyList</code>的后继者（与上一篇文章一样， <code>ReadOnlyList</code>是一个复制的<code>List</code>接口，从中抛出所有变异方法）。 添加的方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  <code>toList</code>方法提供了将<code>ImmutableList</code>传递给等待<code>List</code>的代码段的功能。 返回一个包装器，所有修改方法都返回一个<code>UnsupportedOperationException</code> ，然后将其余方法重定向到原始<code>ImmutableList</code> 。 </p><br><p>  <code>mutable</code>方法将<code>ImmutableList</code>转换为<code>MutableList</code> 。 返回包装器，在该包装器中，所有方法都将重定向到原始<code>ImmutableList</code>直到进行第​​一次更改。 更改之前，将包装与原始<code>ImmutableList</code> ，将其内容复制到内部<code>ArrayList</code> ，然后将所有操作重定向到该内部。 </p><br><p>  <code>contentEquals</code>方法用于将列表的内容与传递的任意<code>Iterable</code>的内容进行比较（当然，此操作仅对具有某些不同元素顺序的<code>Iterable</code>实现有意义。） </p><br><p> 请注意，在我们的<code>ReadOnlyList</code>实现中， <code>iterator</code>和<code>listIterator</code>返回标准<code>java.util.Iterator</code> / <code>java.util.ListIterator</code> 。 这些迭代器包含修改方法，必须通过抛出<code>UnsupportedOperationException</code>来抑制这些修改方法。 最好使用<code>ReadOnlyIterator</code> ，但是在这种情况下，我们无法编写<code>for (Object item : immutableList)</code> ，这将立即破坏使用该库的所有乐趣。 </p><br><h3 id="mutablelist"> 可变列表 </h3><br><p>  <code>MutableList</code>是常规<code>List</code>的后代。 添加的方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseSnapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  <code>snapshot</code>方法旨在将<code>MutableList</code>当前状态的“快照”作为<code>ImmutableList</code> 。  “快照”保存在<code>MutableList</code> ，如果在下一次方法调用时状态未更改， <code>ImmutableList</code>的相同实例。 第一次调用任何修改方法时或调用<code>releaseSnapshot</code>时，将丢弃存储在其中的“快照”。 如果您确定没有人需要“快照”，则可以使用<code>releaseSnapshot</code>方法来节省内存，但是不会很快调用修改方法。 </p><br><h3 id="mutabor">  Mutabor </h3><br><p>  <code>Mutabor</code>类提供了一组静态方法，这些方法是库的“入口”。 </p><br><p> 是的，该项目现在被称为“ mutabor”（与“ mutable”相辅相成，在翻译中意为“我将转型”，这与将某些类型的馆藏快速“转化”为其他类型的想法非常一致）。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E[] original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;E&gt; original)</span></span></span></span>;</code> </pre> <br><p>  <code>copyTo*</code>方法旨在通过复制提供的数据来创建适当的集合。  <code>convertTo*</code>方法<code>convertTo*</code>将传输的集合快速转换为所需的类型，如果无法快速转换，则执行慢速复制。 如果快速转换成功，则原始集合将被清除，并假定将来不会使用它（尽管可以，但这几乎没有道理）。 </p><br><p> 对<code>ImmutableList</code> / <code>MutableList</code>实现<code>ImmutableList</code>的构造函数的调用<code>MutableList</code>隐藏的。 假定用户仅处理接口，他不创建此类对象，而是使用上述方法转换集合。 </p><br><h2 id="detali-realizacii"> 实施细节 </h2><br><h3 id="immutablelistimpl">  ImmutableListImpl </h3><br><p> 封装对象数组。 该实现大致与<code>ArrayList</code>实现相对应，从中抛出所有修改方法和并发修改检查。 </p><br><p>  <code>toList</code>和<code>contentEquals</code>也很简单。  <code>toList</code>方法返回一个包装器，该包装器将调用重定向到给定的<code>ImmutableList</code> ；不会发生数据的慢速复制。 </p><br><p>  <code>mutable</code>方法返回基于此<code>ImmutableList</code>创建的<code>MutableListImpl</code> 。 在接收到的<code>MutableList</code>上调用任何修改方法之前，不会发生数据复制。 </p><br><h3 id="mutablelistimpl">  MutableListImpl </h3><br><p> 封装指向<code>ImmutableList</code>和<code>List</code>链接。 创建对象时，始终仅填充这两个链接之一，另一个保持为<code>null</code> 。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ImmutableList&lt;E&gt; immutable; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> List&lt;E&gt; list;</code> </pre> <br><p> 不可变方法将调用重定向到<code>ImmutableList</code>如果它不为<code>null</code> ，否则重定向到<code>List</code> 。 </p><br><p> 初始化后，修改方法会将调用重定向到<code>List</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(immutable.toList()); } immutable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  <code>snapshot</code>方法如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable; } immutable = InternalUtils.convertToImmutableList(list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //   ,  . //     immutable     . list = null; return immutable; } immutable = InternalUtils.copyToImmutableList(list); return immutable; }</span></span></code> </pre> <br><p>  <code>releaseSnapshot</code>和<code>contentEquals</code>简单。 </p><br><p> 这种方法使您可以在“常规”使用期间最大程度地减少数据副本的数量，从而用快速转换替换副本。 </p><br><h3 id="bystroe-preobrazovanie-spiskov"> 快速列表转换 </h3><br><p>  <code>ArrayList</code>或<code>Arrays$ArrayList</code>类（ <code>Arrays.asList()</code>方法的结果<code>Arrays.asList()</code>可以进行快速转换。 实际上，在大多数情况下，碰巧就是这些类。 </p><br><p> 这些类中包含一个元素数组。 快速转换的本质是通过反射获取对此数组的引用（这是一个私有字段），并用对空数组的引用替换它。 这样可以确保对数组的唯一引用保留在我们的对象中，并且数组保持不变。 </p><br><p> 在该库的先前版本中，集合类型的快速转换通过调用构造函数来执行。 同时，原始的收集对象变坏了（它变得不适合进一步使用），这是您在不知不觉中不希望设计师看到的。 现在，使用了一种特殊的静态方法进行转换，原始集合不会变质，只是被清除了。 因此，消除了令人恐惧的异常行为。 </p><br><h3 id="problemy-s-equals--hashcode">  equals / hashCode问题 </h3><br><p>  Java集合使用一种非常奇怪的方法来实现<code>equals</code>和<code>hashCode</code>方法。 </p><br><p> 比较是根据内容执行的，这似乎是合乎逻辑的，但是未考虑列表本身的类别。 因此，例如，具有相同内容的<code>ArrayList</code>和<code>LinkedList</code>将<code>equals</code> 。 </p><br><div class="spoiler">  <b class="spoiler_title">这是AbstractList的equals / hashCode实现（继承ArrayList）</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o1==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? o2==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : o1.equals(o2))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(e1.hasNext() || e2.hasNext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) hashCode = <span class="hljs-number"><span class="hljs-number">31</span></span>*hashCode + (e==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : e.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashCode; }</code> </pre> </div></div><br><p> 因此，现在绝对需要所有<code>List</code>实现都具有相似的<code>equals</code>实现（因此，是<code>hashCode</code> ）。 否则，您会遇到<code>a.equals(b) &amp;&amp; !b.equals(a)</code>不好的情况。  <code>Set</code>和<code>Map</code>情况与此类似。 </p><br><p> 在该库的应用程序中，这意味着<code>equals</code>和<code>hashCode</code> for <code>MutableList</code>预定义的，并且在这种实现中，具有相同内容的<code>ImmutableList</code>和<code>MutableList</code>不能<code>equals</code> （因为<code>ImmutableList</code>不是<code>List</code> ）。 因此，添加了<code>contentEquals</code>方法来比较内容。 </p><br><p> 使<code>ImmutableList</code>的<code>equals</code>和<code>hashCode</code>方法的实现与<code>AbstractList</code>的版本完全相似，但用<code>ReadOnlyList</code>替换<code>List</code> 。 </p><br><h2 id="itogo"> 合计 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库的源代码和测试</a>以Maven项目的形式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过引用发布</a> 。 </p><br><p> 如果有人要使用该库，他已经创建了一个“反馈” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">联系人组</a> 。 </p><br><p> 使用该库非常明显，这是一个简短的示例： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myBusinessProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Entity&gt; tempFromDb = queryEntitiesFromDatabase(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM my_table"</span></span>); ImmutableList&lt;Entity&gt; fromDb = Mutabor.convertToImmutableList(tempFromDb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromDb.isEmpty() || !someChecksPassed(fromDb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... MutableList&lt;Entity&gt; list = fromDb.mutable(); //time to change list.remove(1); ImmutableList&lt;Entity&gt; processed = list.snapshot(); //time to change ended //... if (!callSideLibraryExpectsListParameter(processed.toList())) { return false; } for (Entity entity : processed) { outputToUI(entity); } return true; }</span></span></code> </pre> <br><p> 祝大家好运！ 发送错误报告！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471344/">https://habr.com/ru/post/zh-CN471344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471332/index.html">月球计算机的故事。 第三部分</a></li>
<li><a href="../zh-CN471334/index.html">记住而不是补习-通过卡片学习</a></li>
<li><a href="../zh-CN471336/index.html">霍利瓦尔 吕内特的历史。 第6部分。锁：潜伏，磁带，282nd和中文路径</a></li>
<li><a href="../zh-CN471340/index.html">Drimsim vs Mate 20专业赛！ 但是对于谁呢？</a></li>
<li><a href="../zh-CN471342/index.html">时尚的阿瓦隆</a></li>
<li><a href="../zh-CN471346/index.html">上周第384期（2019年10月7日至13日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN471350/index.html">1969年通过模拟计算机对低噪声运算放大器进行逆向工程</a></li>
<li><a href="../zh-CN471352/index.html">在LaTeX中编写演示文稿</a></li>
<li><a href="../zh-CN471358/index.html">如何使用Python on Ontology编写智能合约？ 第4部分：本机API</a></li>
<li><a href="../zh-CN471360/index.html">复制方法。 ICE设计的11个示例</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>