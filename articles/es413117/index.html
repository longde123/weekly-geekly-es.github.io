<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèΩ ü§üüèΩ ü§úüèº C√≥mo programar de forma segura en bash ü§ó ‚ö∞Ô∏è üë∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øPor qu√© bash? 
 Hay matrices y modo seguro en bash. Cuando se usa correctamente, bash es casi consistente con las pr√°cticas de codificaci√≥n seguras. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo programar de forma segura en bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  ¬øPor qu√© bash? </h1><br>  Hay matrices y modo seguro en bash.  Cuando se usa correctamente, bash es casi consistente con las pr√°cticas de codificaci√≥n seguras. <br><br>  Es m√°s dif√≠cil cometer un error en el pescado, pero no hay modo seguro.  Por lo tanto, la creaci√≥n de prototipos en peces y luego la traducci√≥n de peces a bash deber√≠a ser una buena idea si sabe c√≥mo hacerlo correctamente. <br><br><h1>  Pr√≥logo </h1><br>  Esta gu√≠a acompa√±a a ShellHarden, pero el autor tambi√©n recomienda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ShellCheck</a> para que las reglas de ShellHarden no difieran de ShellCheck. <br><br>  Bash no es un lenguaje donde la forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s correcta de resolver un problema al mismo tiempo es la m√°s f√°cil</a> .  Si toma el examen de programaci√≥n segura de bash, entonces la primera regla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BashPitfalls</a> ser√≠a: siempre use comillas. <br><br><h1>  Lo principal que debes saber sobre la programaci√≥n en bash </h1><br>  <b>Comillas man√≠acas!</b>  Una variable sin comillas debe considerarse como una bomba armada: explota al entrar en contacto con un espacio.  S√≠, explota en el sentido de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dividir una cadena en una matriz</a> .  En particular, las extensiones variables como <code>$var</code> y las sustituciones de comandos como <code>$(cmd)</code> se dividen en <i>palabras</i> cuando la cadena interna se expande en una matriz debido a la divisi√≥n en una variable especial <code>$IFS</code> con un espacio predeterminado.  Esto suele ser invisible, porque con mayor frecuencia el resultado es una matriz de 1 elemento, indistinguible de la cadena esperada. <br><a name="habracut"></a><br>  No solo esto se expande, sino tambi√©n comodines ( <code>*?</code> ).  Este proceso ocurre despu√©s de que se divide la palabra, por lo que si hay al menos un comod√≠n en la palabra, la palabra se convierte en un comod√≠n que se aplica a cualquier ruta de archivo adecuada.  ¬°Entonces esta caracter√≠stica comienza a aplicarse al sistema de archivos! <br><br>  La cita suprime la divisi√≥n de palabras y la expansi√≥n de patrones para variables y sustituciones de comandos. <br><br>  Extensi√≥n Variable: <br><br><ul><li>  Bien: <code>"$my_var"</code> </li><li>  Malo: <code>$my_var</code> </li></ul><br>  Sustituci√≥n de comando: <br><br><ul><li>  Bien: <code>"$(cmd)"</code> </li><li>  Malo: <code>$(cmd)</code> </li></ul><br>  Hay excepciones con comillas opcionales, pero las comillas nunca afectar√°n, y la regla general es tener cuidado de no citar variables sin comillas, por lo que no buscaremos excepciones fronterizas para su beneficio.  Parece incorrecto, y la pr√°ctica incorrecta est√° lo suficientemente extendida como para levantar sospechas: muchos scripts se han escrito con un procesamiento roto de nombres de archivos y espacios en ellos ... <br><br>  ShellHarden menciona solo algunas excepciones: ¬øson estas variables con contenido num√©rico como <code>$?</code>  , <code>$#</code> y <code>${#array[@]}</code> . <br><br><h3>  ¬øNecesito usar backticks? </h3><br>  Las sustituciones de comandos tambi√©n pueden tener la siguiente forma: <br><br><ul><li>  Correcto: <code>"`cmd`"</code> </li><li>  Malo: <code>`cmd`</code> </li></ul><br>  Aunque este estilo se puede usar correctamente, parece menos conveniente entre comillas y menos legible cuando est√° anidado.  El consenso aqu√≠ es bastante claro: ev√≠telo. <br><br>  ShellHarden reescribe tales marcas de verificaci√≥n entre par√©ntesis en d√≥lares. <br><br><h3>  ¬øSe deben usar llaves? </h3><br>  Los corchetes se utilizan para interpolar cadenas, por lo que suelen ser redundantes: <br><br><ul><li>  Malo: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pobre y detallado: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bien, pero detallado: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bien: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Te√≥ricamente, el uso de llaves no es un problema, pero seg√∫n la experiencia de su autor, existe una fuerte correlaci√≥n negativa entre el uso innecesario de llaves y el uso correcto de comillas: ¬°casi todos eligen la forma "mala y detallada" en lugar de la "buena pero detallada"! <br><br>  Teor√≠as de tu autor: <br><br><ul><li>  Debido al temor de hacer algo mal: en lugar del peligro real (falta de comillas), los principiantes pueden preocuparse de que la variable <code>$prefix</code> haga que la variable <code>"$prefix_postfix"</code> expanda, pero no funciona de esa manera. </li><li>  Culto a la carga: escribir c√≥digo en el pacto del miedo equivocado que lo precedi√≥. </li><li>  Los corchetes compiten con comillas por el l√≠mite de verbosidad permisible. </li></ul><br>  Por lo tanto, se decidi√≥ prohibir llaves innecesarias: ShellHarden reemplaza estas opciones con la forma m√°s simple. <br><br>  Y ahora sobre la interpolaci√≥n de cadenas, donde las llaves son realmente √∫tiles: <br><br><ul><li>  Malo (concatenaci√≥n): <code>$var1"more string content"$var2</code> </li><li>  Bien (concatenaci√≥n): <code>"$var1""more string content""$var2"</code> </li><li>  Bien (interpolaci√≥n): <code>"${var1}more string content${var2}"</code> </li></ul><br>  La concatenaci√≥n y la interpolaci√≥n en bash son equivalentes incluso en matrices (lo cual es rid√≠culo). <br><br>  Debido a que ShellHarden no formatea estilos, no se supone que cambie el c√≥digo correcto.  Esto es cierto para la opci√≥n "buena (interpolaci√≥n)": desde el punto de vista de ShellHarden, esta ser√° la forma can√≥nicamente correcta. <br><br>  ShellHarden ahora est√° agregando y eliminando llaves seg√∫n sea necesario: en un mal ejemplo, var1 se suministra con corchetes, pero no est√°n permitidos para var2 incluso en el caso de "bueno (interpolaci√≥n)", ya que nunca son necesarios al final de la l√≠nea.  El √∫ltimo requisito bien puede ser revertido. <br><br><h4>  Gotcha: argumentos numerados </h4><br>  A diferencia de los nombres de <i>identificadores de</i> variables normales (en regex: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), los argumentos numerados requieren corchetes (la interpolaci√≥n de l√≠nea no).  ShellCheck dice: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden se niega a arreglarlo (considera la diferencia demasiado sutil). <br><br>  Dado que los par√©ntesis est√°n permitidos hasta 9, ShellHarden les permite todos los argumentos numerados. <br><br><h1>  Usar matrices </h1><br>  Para poder citar todas las variables, debe usar matrices reales, no cadenas pseudo-masivas separadas por espacios. <br><br>  La sintaxis es detallada, pero hay que manejarla.  Este bashismo es solo una raz√≥n para abandonar la compatibilidad POSIX para la mayor√≠a de los scripts de shell. <br><br>  Bueno <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Malo: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Es por eso que las matrices son una funci√≥n tan b√°sica para un shell: los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">argumentos de los comandos son fundamentalmente arrays</a> (y los scripts de shell son comandos y argumentos).  Podemos decir que el shell, que artificialmente hace imposible pasar varios argumentos, ser√° c√≥mico e in√∫til.  Algunos proyectiles comunes de esta categor√≠a incluyen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dash</a> y Busybox Ash.  Estos son shells compatibles con POSIX m√≠nimos, pero ¬øde qu√© sirve la compatibilidad si lo m√°s importante <i>no</i> est√° en POSIX? <br><br><h3>  Casos excepcionales cuando realmente vas a romper una l√≠nea </h3><br>  Ejemplo con <code>\v</code> como separador de datos (observe la segunda aparici√≥n): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  De esta forma, evitamos la expansi√≥n de la plantilla y el m√©todo funciona incluso si el separador de datos es <code>\n</code> .  La segunda aparici√≥n del separador de datos protege el √∫ltimo elemento si resulta ser un espacio.  Por alguna raz√≥n, la opci√≥n <code>-d</code> deber√≠a ir primero, por lo que <code>-rad ''</code> opciones en <code>-rad ''</code> tentador, pero no funcionar√°.  Como read devuelve un valor distinto de cero en este caso, deber√≠a estar protegido de errexit ( <code>|| true</code> ), si est√° habilitado.  Probado en bash 4.0, 4.1, 4.2, 4.3 y 4.4. <br><br>  Alternativa para bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Donde comenzar un script bash </h1><br>  De algo como esto: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Esto incluye: <br><br><ul><li>  Shebang: <br><ul><li>  Problemas de portabilidad: la ruta absoluta a <code>env</code> probablemente mejor para la portabilidad que la ruta absoluta a <code>bash</code> .  Puedes ver el ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NixOS</a> .  POSIX requiere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">env</a> , pero no bash. </li><li>  Problemas de seguridad: ¬°Sin lenguaje, opciones como <code>-euo pipefail</code> no ser√°n aceptadas favorablemente <code>-euo pipefail</code> !  Esto se vuelve imposible cuando se usa la redirecci√≥n <code>env</code> , pero incluso si su shebang comienza con <code>#!/bin/bash</code> , este no es el lugar para los par√°metros que afectan el valor del script, ya que pueden anularse, lo que har√° posible ejecutar el script incorrectamente.  Sin embargo, como beneficio adicional, las opciones que no afectan el valor del script, como <code>set -x</code> , si se usan, pueden redefinirse. </li></ul></li><li>  ¬øQu√© necesitamos del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo estricto no oficial de Bash</a> , con la comprobaci√≥n de funciones <code>set -u</code> ?  No necesitamos todo el modo estricto de Bash, porque la compatibilidad shellcheck / shellharden significa citar todo y todo lo que es mucho m√°s estricto.  Adem√°s, la opci√≥n <code>set -u</code> <b>no debe usarse</b> en Bash 4.3 y versiones anteriores.  Como esta opci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">considera que las matrices vac√≠as se descartan</a> en esas versiones, las matrices no se pueden usar para los fines descritos aqu√≠.  El uso de matrices es el segundo consejo m√°s importante de esta gu√≠a (despu√©s de las comillas) y la √∫nica raz√≥n por la que sacrificamos la compatibilidad con POSIX, por lo que esto no es inaceptable: no use <code>set -u</code> , o use Bash 4.4 u otro shell normal como Zsh.  Esto es m√°s f√°cil decirlo que hacerlo, porque existe la posibilidad de que alguien a√∫n ejecute su script en la versi√≥n antigua de Bash.  Afortunadamente, todo lo que funciona con <code>set -u</code> funcionar√° sin √©l (para <code>set -e</code> no se puede decir eso).  Es por eso que es importante utilizar la verificaci√≥n de versiones.  Tenga cuidado con la suposici√≥n de que las pruebas y el desarrollo tienen lugar en un shell compatible con Bash 4.4 (por lo que se prueba el aspecto <code>set -u</code> ).  Si esto le molesta, entonces otra opci√≥n es rechazar la compatibilidad (el script falla cuando falla la verificaci√≥n de la versi√≥n) o rechazar <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> obliga <code>for f in *.txt</code> a funcionar correctamente si <code>*.txt</code> no encuentra archivos.  El comportamiento predeterminado (tambi√©n <i>conocido</i> como <i>passglob</i> ) pasa la plantilla sin cambios, lo que en caso de un resultado cero es peligroso por varias razones.  Para <i>globstar,</i> esto activa la b√∫squeda recursiva.  La sustituci√≥n es m√°s f√°cil de usar que <code>find</code> .  As√≠ que √∫salo. </li></ul><br>  Pero no: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Establecer el <i>delimitador de campo interno en</i> una cadena vac√≠a hace que sea imposible dividir la palabra.  Suena como la soluci√≥n perfecta.  Desafortunadamente, este es un reemplazo incompleto para las variables de comillas y las sustituciones de comandos, y dado que va a usar comillas, no da nada.  La raz√≥n por la cual las comillas a√∫n deben usarse es porque de lo contrario las cadenas vac√≠as se convierten en matrices vac√≠as (como en la <code>test $x = ""</code> ) y la expansi√≥n indirecta de la plantilla a√∫n es posible.  Adem√°s, los problemas con esta variable tambi√©n causar√°n problemas con comandos como <code>read</code> , que rompe construcciones como <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  La extensi√≥n de la plantilla est√° deshabilitada: no solo la infame extensi√≥n indirecta, sino tambi√©n la extensi√≥n directa sin problemas, que, como dije, deber√≠as usar.  Entonces es dif√≠cil de aceptar.  Y esto tambi√©n es completamente opcional para un script compatible con shellcheck / shellharden. </li><li>  A diferencia de <i>nullglob</i> , <i>failglob</i> falla con un resultado nulo.  Aunque para la mayor√≠a de los comandos esto tiene sentido, por ejemplo, <code>rm -- *.txt</code> (porque para la mayor√≠a de los comandos todav√≠a no se espera que se ejecute con un resultado cero), obviamente, <i>failglob solo</i> puede usarse si no espera un resultado cero.  Esto significa que generalmente no colocar√° plantillas de grupo en argumentos de comando a menos que asuma lo mismo.  Pero lo que siempre puede suceder es usar <i>nullglob</i> y extender la plantilla a argumentos nulos en construcciones que puedan tomarlos, como un bucle o asignar valores a una matriz ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  C√≥mo completar un script bash </h1><br>  El estado de salida del script es el estado del √∫ltimo comando ejecutado.  Aseg√∫rese de que represente un verdadero √©xito o fracaso. <br><br>  Lo peor es dejar la soluci√≥n a una condici√≥n no relacionada en forma de una lista AND al final del script.  Si la condici√≥n es falsa, el √∫ltimo comando ejecutado ser√° la condici√≥n misma. <br><br>  Para errexit, las condiciones en forma de una lista AND nunca se utilizan en primer lugar.  Si no se usa errexit, considere manejar los errores incluso para el √∫ltimo comando, por lo que su estado de salida no se enmascarar√° si se agrega c√≥digo adicional al script. <br><br>  Malo: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bueno (opci√≥n errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bueno (opci√≥n de manejo de errores): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  C√≥mo usar errexit </h1><br>  Como <code>set -e</code> . <br><br><h3>  Limpieza programada a nivel de programa </h3><br>  Si errexit funciona como deber√≠a, use esto para instalar cualquier limpieza necesaria al salir. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Atrapado: errexit se ignora en los argumentos de comando </h3><br>  Aqu√≠ hay una "bomba" de ramificaci√≥n muy complicada, cuya comprensi√≥n me fue muy querida.  Mi script de compilaci√≥n funcion√≥ bien en diferentes m√°quinas de desarrollo, pero puso de rodillas al servidor de compilaci√≥n: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correcto (sustituci√≥n de comando en la tarea): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Advertencia: <code>local</code> comandos integrados <code>local</code> y de <code>export</code> siguen siendo comandos, por lo que esto sigue siendo incorrecto: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck solo advierte sobre comandos especiales como <code>local</code> en este caso. <br><br>  Para usar <code>local</code> , separe la declaraci√≥n del trabajo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Atrapado: errexit se ignora dependiendo del contexto de la persona que llama </h3><br>  A veces POSIX es terrible.  Errexit se ignora en funciones, comandos de grupo e incluso subcapas si la persona que llama comprueba su √©xito.  Todos estos ejemplos imprimen <code>Unreachable</code> y <code>Great success</code> , por extra√±o que parezca. <br><br>  Subshell: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Equipo grupal: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Funci√≥n: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Debido a esto, bash con errexit es pr√°cticamente inadecuado para vincular: s√≠, <i>es posible</i> ajustar las funciones de errexit para que funcionen, pero existen dudas de que el esfuerzo ahorrado (en el manejo expl√≠cito de errores) valga la pena.  En cambio, considere dividir en scripts totalmente aut√≥nomos. <br><br><h1>  Evitar llamar al shell con comillas incorrectas </h1><br>  Al invocar comandos de otros lenguajes de programaci√≥n, es m√°s f√°cil cometer un error e invocar impl√≠citamente el shell.  Si este comando de shell es est√°tico, es bueno, funciona o no.  Pero si su programa de alguna manera procesa las l√≠neas para construir este comando, entonces necesita comprender: ¬°est√° <b>generando un script de shell</b> !  Rara vez quiero hacer esto, y es muy agotador organizar todo correctamente: <br><br><ul><li>  cita cada argumento; </li><li>  escapar de los caracteres correspondientes en los argumentos. </li></ul><br>  No importa en qu√© lenguaje de programaci√≥n haga esto, hay al menos tres formas de construir un equipo correctamente.  En orden de preferencia: <br><br><h3>  Plan A: prescindir de una c√°scara </h3><br>  Si esto es solo un comando con argumentos (es decir, no hay funciones de shell como canalizar o redirigir), seleccione una opci√≥n de matriz. <br><br><ul><li>  Malo (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bien (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Malo (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bueno (C / POSIX), menos manejo de errores: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plan B: un script de shell est√°tico </h3><br>  Si se requiere un shell, deje que los argumentos sean argumentos.  Puede pensar que fue engorroso escribir un script de shell especial en su propio archivo y acceder a √©l hasta que vea ese truco: <br><br>  Malo (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bien (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  ¬øPuedes notar el script de shell? <br><br>  As√≠ es, el comando printf se redirige.  Preste atenci√≥n a los argumentos numerados correctamente citados.  Implementar un script de shell est√°tico est√° bien. <br><br>  Estos ejemplos se ejecutan en Docker porque de lo contrario no ser√°n tan √∫tiles, pero Docker tambi√©n es un gran ejemplo de un comando que ejecuta otros comandos basados ‚Äã‚Äãen argumentos.  A diferencia de Ssh, como veremos m√°s adelante. <br><br><h3>  √öltima opci√≥n: procesamiento de l√≠nea </h3><br>  Si <i>debe</i> ser una cadena (por ejemplo, porque debe funcionar a trav√©s de <code>ssh</code> ), no se puede omitir.  Tendr√° que citar cada argumento y escapar de los caracteres necesarios para salir de estas citas.  La forma m√°s f√°cil es cambiar a comillas simples, porque tienen las reglas de escape m√°s simples.  Solo una regla: <code>'</code> ‚Üí <code>'\"</code> . <br><br>  Nombre de archivo t√≠pico entre comillas simples: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  ¬øC√≥mo usar este truco para ejecutar comandos ssh de forma segura?  Esto es imposible!  Bueno, aqu√≠ est√° la soluci√≥n "a menudo correcta": <br><br><ul><li>  La soluci√≥n "a menudo correcta" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Nosotros mismos debemos combinar todos los argumentos en una cadena para que Ssh no lo haga mal: si intenta pasar varios argumentos ssh, comenzar√° a combinar traicioneramente los argumentos sin comillas. <br><br>  La raz√≥n por la que esto generalmente no es posible es porque la decisi√≥n correcta depende de las preferencias del usuario en el otro extremo, es decir, el shell remoto, que puede ser cualquier cosa.  B√°sicamente, incluso podr√≠a ser tu madre.  Es "a menudo correcto" suponer que el shell remoto es bash u otro shell compatible con POSIX, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fish es incompatible en esta etapa</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413117/">https://habr.com/ru/post/es413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413105/index.html">Notas del proveedor de IoT. Activaci√≥n y seguridad en LoraWAN</a></li>
<li><a href="../es413107/index.html">Traducci√≥n del wiki del proyecto Svelto.ECS. Marco ECS para Unity3D</a></li>
<li><a href="../es413109/index.html">C√≥mo construir una plataforma de integraci√≥n de productos SaaS: experiencia de pago de Cloud Poster</a></li>
<li><a href="../es413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../es413113/index.html">Soporte de serializaci√≥n JavaScript JavaScript de clase</a></li>
<li><a href="../es413119/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 317 (28 de mayo - 3 de junio de 2018)</a></li>
<li><a href="../es413121/index.html">Recorrido fotogr√°fico por el coworking de Mosc√∫ #tceh</a></li>
<li><a href="../es413123/index.html">√öNETE en bases de datos NoSQL</a></li>
<li><a href="../es413125/index.html">La terapia g√©nica brinda a los pacientes peque√±os con atrofia muscular la oportunidad de sobrevivir</a></li>
<li><a href="../es413127/index.html">Algunas palabras sobre el rendimiento real del hipervisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>