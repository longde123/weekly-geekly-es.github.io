<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏽 🤟🏽 🤜🏼 Cómo programar de forma segura en bash 🤗 ⚰️ 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Por qué bash? 
 Hay matrices y modo seguro en bash. Cuando se usa correctamente, bash es casi consistente con las prácticas de codificación seguras. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo programar de forma segura en bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  ¿Por qué bash? </h1><br>  Hay matrices y modo seguro en bash.  Cuando se usa correctamente, bash es casi consistente con las prácticas de codificación seguras. <br><br>  Es más difícil cometer un error en el pescado, pero no hay modo seguro.  Por lo tanto, la creación de prototipos en peces y luego la traducción de peces a bash debería ser una buena idea si sabe cómo hacerlo correctamente. <br><br><h1>  Prólogo </h1><br>  Esta guía acompaña a ShellHarden, pero el autor también recomienda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ShellCheck</a> para que las reglas de ShellHarden no difieran de ShellCheck. <br><br>  Bash no es un lenguaje donde la forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más correcta de resolver un problema al mismo tiempo es la más fácil</a> .  Si toma el examen de programación segura de bash, entonces la primera regla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BashPitfalls</a> sería: siempre use comillas. <br><br><h1>  Lo principal que debes saber sobre la programación en bash </h1><br>  <b>Comillas maníacas!</b>  Una variable sin comillas debe considerarse como una bomba armada: explota al entrar en contacto con un espacio.  Sí, explota en el sentido de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dividir una cadena en una matriz</a> .  En particular, las extensiones variables como <code>$var</code> y las sustituciones de comandos como <code>$(cmd)</code> se dividen en <i>palabras</i> cuando la cadena interna se expande en una matriz debido a la división en una variable especial <code>$IFS</code> con un espacio predeterminado.  Esto suele ser invisible, porque con mayor frecuencia el resultado es una matriz de 1 elemento, indistinguible de la cadena esperada. <br><a name="habracut"></a><br>  No solo esto se expande, sino también comodines ( <code>*?</code> ).  Este proceso ocurre después de que se divide la palabra, por lo que si hay al menos un comodín en la palabra, la palabra se convierte en un comodín que se aplica a cualquier ruta de archivo adecuada.  ¡Entonces esta característica comienza a aplicarse al sistema de archivos! <br><br>  La cita suprime la división de palabras y la expansión de patrones para variables y sustituciones de comandos. <br><br>  Extensión Variable: <br><br><ul><li>  Bien: <code>"$my_var"</code> </li><li>  Malo: <code>$my_var</code> </li></ul><br>  Sustitución de comando: <br><br><ul><li>  Bien: <code>"$(cmd)"</code> </li><li>  Malo: <code>$(cmd)</code> </li></ul><br>  Hay excepciones con comillas opcionales, pero las comillas nunca afectarán, y la regla general es tener cuidado de no citar variables sin comillas, por lo que no buscaremos excepciones fronterizas para su beneficio.  Parece incorrecto, y la práctica incorrecta está lo suficientemente extendida como para levantar sospechas: muchos scripts se han escrito con un procesamiento roto de nombres de archivos y espacios en ellos ... <br><br>  ShellHarden menciona solo algunas excepciones: ¿son estas variables con contenido numérico como <code>$?</code>  , <code>$#</code> y <code>${#array[@]}</code> . <br><br><h3>  ¿Necesito usar backticks? </h3><br>  Las sustituciones de comandos también pueden tener la siguiente forma: <br><br><ul><li>  Correcto: <code>"`cmd`"</code> </li><li>  Malo: <code>`cmd`</code> </li></ul><br>  Aunque este estilo se puede usar correctamente, parece menos conveniente entre comillas y menos legible cuando está anidado.  El consenso aquí es bastante claro: evítelo. <br><br>  ShellHarden reescribe tales marcas de verificación entre paréntesis en dólares. <br><br><h3>  ¿Se deben usar llaves? </h3><br>  Los corchetes se utilizan para interpolar cadenas, por lo que suelen ser redundantes: <br><br><ul><li>  Malo: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pobre y detallado: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bien, pero detallado: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bien: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Teóricamente, el uso de llaves no es un problema, pero según la experiencia de su autor, existe una fuerte correlación negativa entre el uso innecesario de llaves y el uso correcto de comillas: ¡casi todos eligen la forma "mala y detallada" en lugar de la "buena pero detallada"! <br><br>  Teorías de tu autor: <br><br><ul><li>  Debido al temor de hacer algo mal: en lugar del peligro real (falta de comillas), los principiantes pueden preocuparse de que la variable <code>$prefix</code> haga que la variable <code>"$prefix_postfix"</code> expanda, pero no funciona de esa manera. </li><li>  Culto a la carga: escribir código en el pacto del miedo equivocado que lo precedió. </li><li>  Los corchetes compiten con comillas por el límite de verbosidad permisible. </li></ul><br>  Por lo tanto, se decidió prohibir llaves innecesarias: ShellHarden reemplaza estas opciones con la forma más simple. <br><br>  Y ahora sobre la interpolación de cadenas, donde las llaves son realmente útiles: <br><br><ul><li>  Malo (concatenación): <code>$var1"more string content"$var2</code> </li><li>  Bien (concatenación): <code>"$var1""more string content""$var2"</code> </li><li>  Bien (interpolación): <code>"${var1}more string content${var2}"</code> </li></ul><br>  La concatenación y la interpolación en bash son equivalentes incluso en matrices (lo cual es ridículo). <br><br>  Debido a que ShellHarden no formatea estilos, no se supone que cambie el código correcto.  Esto es cierto para la opción "buena (interpolación)": desde el punto de vista de ShellHarden, esta será la forma canónicamente correcta. <br><br>  ShellHarden ahora está agregando y eliminando llaves según sea necesario: en un mal ejemplo, var1 se suministra con corchetes, pero no están permitidos para var2 incluso en el caso de "bueno (interpolación)", ya que nunca son necesarios al final de la línea.  El último requisito bien puede ser revertido. <br><br><h4>  Gotcha: argumentos numerados </h4><br>  A diferencia de los nombres de <i>identificadores de</i> variables normales (en regex: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), los argumentos numerados requieren corchetes (la interpolación de línea no).  ShellCheck dice: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden se niega a arreglarlo (considera la diferencia demasiado sutil). <br><br>  Dado que los paréntesis están permitidos hasta 9, ShellHarden les permite todos los argumentos numerados. <br><br><h1>  Usar matrices </h1><br>  Para poder citar todas las variables, debe usar matrices reales, no cadenas pseudo-masivas separadas por espacios. <br><br>  La sintaxis es detallada, pero hay que manejarla.  Este bashismo es solo una razón para abandonar la compatibilidad POSIX para la mayoría de los scripts de shell. <br><br>  Bueno <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Malo: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Es por eso que las matrices son una función tan básica para un shell: los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">argumentos de los comandos son fundamentalmente arrays</a> (y los scripts de shell son comandos y argumentos).  Podemos decir que el shell, que artificialmente hace imposible pasar varios argumentos, será cómico e inútil.  Algunos proyectiles comunes de esta categoría incluyen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dash</a> y Busybox Ash.  Estos son shells compatibles con POSIX mínimos, pero ¿de qué sirve la compatibilidad si lo más importante <i>no</i> está en POSIX? <br><br><h3>  Casos excepcionales cuando realmente vas a romper una línea </h3><br>  Ejemplo con <code>\v</code> como separador de datos (observe la segunda aparición): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  De esta forma, evitamos la expansión de la plantilla y el método funciona incluso si el separador de datos es <code>\n</code> .  La segunda aparición del separador de datos protege el último elemento si resulta ser un espacio.  Por alguna razón, la opción <code>-d</code> debería ir primero, por lo que <code>-rad ''</code> opciones en <code>-rad ''</code> tentador, pero no funcionará.  Como read devuelve un valor distinto de cero en este caso, debería estar protegido de errexit ( <code>|| true</code> ), si está habilitado.  Probado en bash 4.0, 4.1, 4.2, 4.3 y 4.4. <br><br>  Alternativa para bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Donde comenzar un script bash </h1><br>  De algo como esto: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Esto incluye: <br><br><ul><li>  Shebang: <br><ul><li>  Problemas de portabilidad: la ruta absoluta a <code>env</code> probablemente mejor para la portabilidad que la ruta absoluta a <code>bash</code> .  Puedes ver el ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NixOS</a> .  POSIX requiere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">env</a> , pero no bash. </li><li>  Problemas de seguridad: ¡Sin lenguaje, opciones como <code>-euo pipefail</code> no serán aceptadas favorablemente <code>-euo pipefail</code> !  Esto se vuelve imposible cuando se usa la redirección <code>env</code> , pero incluso si su shebang comienza con <code>#!/bin/bash</code> , este no es el lugar para los parámetros que afectan el valor del script, ya que pueden anularse, lo que hará posible ejecutar el script incorrectamente.  Sin embargo, como beneficio adicional, las opciones que no afectan el valor del script, como <code>set -x</code> , si se usan, pueden redefinirse. </li></ul></li><li>  ¿Qué necesitamos del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo estricto no oficial de Bash</a> , con la comprobación de funciones <code>set -u</code> ?  No necesitamos todo el modo estricto de Bash, porque la compatibilidad shellcheck / shellharden significa citar todo y todo lo que es mucho más estricto.  Además, la opción <code>set -u</code> <b>no debe usarse</b> en Bash 4.3 y versiones anteriores.  Como esta opción <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">considera que las matrices vacías se descartan</a> en esas versiones, las matrices no se pueden usar para los fines descritos aquí.  El uso de matrices es el segundo consejo más importante de esta guía (después de las comillas) y la única razón por la que sacrificamos la compatibilidad con POSIX, por lo que esto no es inaceptable: no use <code>set -u</code> , o use Bash 4.4 u otro shell normal como Zsh.  Esto es más fácil decirlo que hacerlo, porque existe la posibilidad de que alguien aún ejecute su script en la versión antigua de Bash.  Afortunadamente, todo lo que funciona con <code>set -u</code> funcionará sin él (para <code>set -e</code> no se puede decir eso).  Es por eso que es importante utilizar la verificación de versiones.  Tenga cuidado con la suposición de que las pruebas y el desarrollo tienen lugar en un shell compatible con Bash 4.4 (por lo que se prueba el aspecto <code>set -u</code> ).  Si esto le molesta, entonces otra opción es rechazar la compatibilidad (el script falla cuando falla la verificación de la versión) o rechazar <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> obliga <code>for f in *.txt</code> a funcionar correctamente si <code>*.txt</code> no encuentra archivos.  El comportamiento predeterminado (también <i>conocido</i> como <i>passglob</i> ) pasa la plantilla sin cambios, lo que en caso de un resultado cero es peligroso por varias razones.  Para <i>globstar,</i> esto activa la búsqueda recursiva.  La sustitución es más fácil de usar que <code>find</code> .  Así que úsalo. </li></ul><br>  Pero no: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Establecer el <i>delimitador de campo interno en</i> una cadena vacía hace que sea imposible dividir la palabra.  Suena como la solución perfecta.  Desafortunadamente, este es un reemplazo incompleto para las variables de comillas y las sustituciones de comandos, y dado que va a usar comillas, no da nada.  La razón por la cual las comillas aún deben usarse es porque de lo contrario las cadenas vacías se convierten en matrices vacías (como en la <code>test $x = ""</code> ) y la expansión indirecta de la plantilla aún es posible.  Además, los problemas con esta variable también causarán problemas con comandos como <code>read</code> , que rompe construcciones como <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  La extensión de la plantilla está deshabilitada: no solo la infame extensión indirecta, sino también la extensión directa sin problemas, que, como dije, deberías usar.  Entonces es difícil de aceptar.  Y esto también es completamente opcional para un script compatible con shellcheck / shellharden. </li><li>  A diferencia de <i>nullglob</i> , <i>failglob</i> falla con un resultado nulo.  Aunque para la mayoría de los comandos esto tiene sentido, por ejemplo, <code>rm -- *.txt</code> (porque para la mayoría de los comandos todavía no se espera que se ejecute con un resultado cero), obviamente, <i>failglob solo</i> puede usarse si no espera un resultado cero.  Esto significa que generalmente no colocará plantillas de grupo en argumentos de comando a menos que asuma lo mismo.  Pero lo que siempre puede suceder es usar <i>nullglob</i> y extender la plantilla a argumentos nulos en construcciones que puedan tomarlos, como un bucle o asignar valores a una matriz ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Cómo completar un script bash </h1><br>  El estado de salida del script es el estado del último comando ejecutado.  Asegúrese de que represente un verdadero éxito o fracaso. <br><br>  Lo peor es dejar la solución a una condición no relacionada en forma de una lista AND al final del script.  Si la condición es falsa, el último comando ejecutado será la condición misma. <br><br>  Para errexit, las condiciones en forma de una lista AND nunca se utilizan en primer lugar.  Si no se usa errexit, considere manejar los errores incluso para el último comando, por lo que su estado de salida no se enmascarará si se agrega código adicional al script. <br><br>  Malo: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bueno (opción errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bueno (opción de manejo de errores): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Cómo usar errexit </h1><br>  Como <code>set -e</code> . <br><br><h3>  Limpieza programada a nivel de programa </h3><br>  Si errexit funciona como debería, use esto para instalar cualquier limpieza necesaria al salir. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Atrapado: errexit se ignora en los argumentos de comando </h3><br>  Aquí hay una "bomba" de ramificación muy complicada, cuya comprensión me fue muy querida.  Mi script de compilación funcionó bien en diferentes máquinas de desarrollo, pero puso de rodillas al servidor de compilación: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correcto (sustitución de comando en la tarea): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Advertencia: <code>local</code> comandos integrados <code>local</code> y de <code>export</code> siguen siendo comandos, por lo que esto sigue siendo incorrecto: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck solo advierte sobre comandos especiales como <code>local</code> en este caso. <br><br>  Para usar <code>local</code> , separe la declaración del trabajo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Atrapado: errexit se ignora dependiendo del contexto de la persona que llama </h3><br>  A veces POSIX es terrible.  Errexit se ignora en funciones, comandos de grupo e incluso subcapas si la persona que llama comprueba su éxito.  Todos estos ejemplos imprimen <code>Unreachable</code> y <code>Great success</code> , por extraño que parezca. <br><br>  Subshell: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Equipo grupal: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Función: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Debido a esto, bash con errexit es prácticamente inadecuado para vincular: sí, <i>es posible</i> ajustar las funciones de errexit para que funcionen, pero existen dudas de que el esfuerzo ahorrado (en el manejo explícito de errores) valga la pena.  En cambio, considere dividir en scripts totalmente autónomos. <br><br><h1>  Evitar llamar al shell con comillas incorrectas </h1><br>  Al invocar comandos de otros lenguajes de programación, es más fácil cometer un error e invocar implícitamente el shell.  Si este comando de shell es estático, es bueno, funciona o no.  Pero si su programa de alguna manera procesa las líneas para construir este comando, entonces necesita comprender: ¡está <b>generando un script de shell</b> !  Rara vez quiero hacer esto, y es muy agotador organizar todo correctamente: <br><br><ul><li>  cita cada argumento; </li><li>  escapar de los caracteres correspondientes en los argumentos. </li></ul><br>  No importa en qué lenguaje de programación haga esto, hay al menos tres formas de construir un equipo correctamente.  En orden de preferencia: <br><br><h3>  Plan A: prescindir de una cáscara </h3><br>  Si esto es solo un comando con argumentos (es decir, no hay funciones de shell como canalizar o redirigir), seleccione una opción de matriz. <br><br><ul><li>  Malo (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bien (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Malo (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bueno (C / POSIX), menos manejo de errores: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plan B: un script de shell estático </h3><br>  Si se requiere un shell, deje que los argumentos sean argumentos.  Puede pensar que fue engorroso escribir un script de shell especial en su propio archivo y acceder a él hasta que vea ese truco: <br><br>  Malo (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bien (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  ¿Puedes notar el script de shell? <br><br>  Así es, el comando printf se redirige.  Preste atención a los argumentos numerados correctamente citados.  Implementar un script de shell estático está bien. <br><br>  Estos ejemplos se ejecutan en Docker porque de lo contrario no serán tan útiles, pero Docker también es un gran ejemplo de un comando que ejecuta otros comandos basados ​​en argumentos.  A diferencia de Ssh, como veremos más adelante. <br><br><h3>  Última opción: procesamiento de línea </h3><br>  Si <i>debe</i> ser una cadena (por ejemplo, porque debe funcionar a través de <code>ssh</code> ), no se puede omitir.  Tendrá que citar cada argumento y escapar de los caracteres necesarios para salir de estas citas.  La forma más fácil es cambiar a comillas simples, porque tienen las reglas de escape más simples.  Solo una regla: <code>'</code> → <code>'\"</code> . <br><br>  Nombre de archivo típico entre comillas simples: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  ¿Cómo usar este truco para ejecutar comandos ssh de forma segura?  Esto es imposible!  Bueno, aquí está la solución "a menudo correcta": <br><br><ul><li>  La solución "a menudo correcta" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Nosotros mismos debemos combinar todos los argumentos en una cadena para que Ssh no lo haga mal: si intenta pasar varios argumentos ssh, comenzará a combinar traicioneramente los argumentos sin comillas. <br><br>  La razón por la que esto generalmente no es posible es porque la decisión correcta depende de las preferencias del usuario en el otro extremo, es decir, el shell remoto, que puede ser cualquier cosa.  Básicamente, incluso podría ser tu madre.  Es "a menudo correcto" suponer que el shell remoto es bash u otro shell compatible con POSIX, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fish es incompatible en esta etapa</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413117/">https://habr.com/ru/post/es413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413105/index.html">Notas del proveedor de IoT. Activación y seguridad en LoraWAN</a></li>
<li><a href="../es413107/index.html">Traducción del wiki del proyecto Svelto.ECS. Marco ECS para Unity3D</a></li>
<li><a href="../es413109/index.html">Cómo construir una plataforma de integración de productos SaaS: experiencia de pago de Cloud Poster</a></li>
<li><a href="../es413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../es413113/index.html">Soporte de serialización JavaScript JavaScript de clase</a></li>
<li><a href="../es413119/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 317 (28 de mayo - 3 de junio de 2018)</a></li>
<li><a href="../es413121/index.html">Recorrido fotográfico por el coworking de Moscú #tceh</a></li>
<li><a href="../es413123/index.html">ÚNETE en bases de datos NoSQL</a></li>
<li><a href="../es413125/index.html">La terapia génica brinda a los pacientes pequeños con atrofia muscular la oportunidad de sobrevivir</a></li>
<li><a href="../es413127/index.html">Algunas palabras sobre el rendimiento real del hipervisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>