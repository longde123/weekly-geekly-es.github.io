<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‡ğŸ¾ ğŸ•ºğŸ¿ â–¶ï¸ Memperkenalkan Data Musim Semi JDBC ğŸ‘¨ğŸ» ğŸˆº ğŸ˜¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam rilis Spring Data mendatang, nama kode Lovelace, kita akan memasukkan modul baru: Spring Data JDBC . 


 Gagasan di balik Spring Data JDBC adala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan Data Musim Semi JDBC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423697/"><p>  Dalam rilis Spring Data mendatang, nama kode <em>Lovelace,</em> kita akan memasukkan modul baru: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Data JDBC</a> . </p><br><p>  Gagasan di balik Spring Data JDBC adalah untuk menyediakan akses ke database relasional <strong>tanpa menggunakan semua kompleksitas JPA</strong> . </p><a name="habracut"></a><br><p>  JPA menawarkan fitur-fitur seperti <em>pemuatan yang malas</em> , <em>caching,</em> dan <em>perubahan pelacakan</em> (pelacakan kotor).  Terlepas dari kenyataan bahwa fitur-fitur ini sangat keren, jika Anda benar-benar membutuhkannya, tentu saja, mereka dapat sangat mempersulit pemahaman tentang logika akses data. </p><br><p>  Mekanisme <em>lazy loading</em> tiba-tiba dapat mengeksekusi permintaan sumber daya intensif, atau bahkan gagal dengan pengecualian.  <em>Caching</em> dapat menghalangi Anda ketika Anda memutuskan untuk membandingkan dua versi suatu entitas, dan ditambah dengan <em>pelacakan perubahan</em> itu membuatnya lebih sulit untuk memahami pada titik apa semua operasi database sebenarnya akan dilakukan? </p><br><p>  Data Musim Semi JDBC berfokus pada <strong>model yang jauh lebih sederhana</strong> .  Tidak akan ada caching, perubahan pelacakan, atau pemuatan malas.  Sebaliknya, kueri SQL akan dieksekusi jika dan hanya jika Anda memanggil metode repositori.  Hasil yang dikembalikan akan sepenuhnya dimuat ke dalam memori setelah metode ini dijalankan.  Tidak akan ada mekanisme "sesi" atau objek proxy untuk entitas.  Dan semua ini harus membuat Spring Data JDBC alat yang lebih sederhana dan lebih intuitif untuk mengakses data. </p><br><p>  Tentu saja, pendekatan yang disederhanakan seperti itu diterjemahkan ke dalam sejumlah keterbatasan, yang akan kita diskusikan di posting selanjutnya.  Rilis yang akan datang adalah versi pertama dari perpustakaan, kami memiliki banyak rencana dan ide yang ingin kami terapkan, tetapi kami harus menundanya untuk memberi Anda kesempatan untuk mulai menggunakan Spring Data JDBC sedini mungkin. </p><br><h1 id="primer">  Contoh </h1><br><p>  Untuk memulai, kita perlu mendefinisikan entitas: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; String firstName; LocalDate dob; }</code> </pre> <br><blockquote>  Harap dicatat bahwa kami tidak mendefinisikan getter atau setter.  Tentu saja, Anda dapat menambahkannya jika mau.  Pada dasarnya, satu-satunya persyaratan untuk entitas adalah memiliki bidang yang dianotasi dengan anotasi <code>Id</code> (tetapi yaitu <code>org.springframework.data.annotation.Id</code> , bukan <code>javax.persistence one</code> ). </blockquote><p>  Selanjutnya, Anda perlu mendefinisikan repositori.  Cara termudah untuk melakukan ini adalah memperluas antarmuka <code>CrudRepository</code> . </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{}</code> </pre> <br><p>  Akhirnya, Anda perlu mengkonfigurasi <code>ApplicationContext</code> sehingga implementasi antarmuka ini dibuat secara otomatis: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableJdbcRepositories</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JdbcConfiguration</span></span></span><span class="hljs-class"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">NamedParameterJdbcOperations </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedParameterJdbcTemplate(dataSource()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">PlatformTransactionManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transactionManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSourceTransactionManager(dataSource()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ (<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmbeddedDatabaseBuilder() .generateUniqueName(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setType(EmbeddedDatabaseType.HSQL) .addScript(<span class="hljs-string"><span class="hljs-string">"create-customer-schema.sql"</span></span>) .build(); } }</code> </pre> <br><p>  Mari kita menganalisis konfigurasi lebih terinci. </p><br><ol><li>  <code>EnableJdbcRepositories</code> pembuatan repositori otomatis.  Agar ini berfungsi, Anda perlu menyediakan beberapa kacang tambahan, yang akan membutuhkan seluruh kelas konfigurasi kami. </li><li>  Karena  kelas konfigurasi meluas <code>JdbcConfiguration</code> , beberapa kacang akan ditambahkan ke konteks secara otomatis.  Anda juga bisa tumpang tindih jika Anda perlu mengubah perilaku Spring Data JDBC.  Namun dalam contoh ini, kita akan meninggalkan perilaku default. </li><li>  Komponen yang sangat penting adalah <code>NamedParameterJdbcOperations</code> , yang digunakan untuk melakukan query database. </li><li>  Manajer transaksi, sebenarnya, tidak diperlukan.  Tetapi tanpa itu, tidak akan ada dukungan transaksi, dan sedikit yang akan menyukainya, kan? </li><li>  Spring Data JDBC tidak menggunakan <code>DataSource</code> secara langsung, tetapi <code>TransactionManager</code> dan <code>NamedParameterJdbcOperation</code> memerlukan kehadirannya dalam konteks, itulah sebabnya kami menentukan kacang yang diinginkan. </li></ol><br><p>  Hanya itu yang diperlukan untuk memulai dengan Data Spring JDBC.  Sekarang tulis tes untuk melihat bagaimana semuanya bekerja: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = CustomerConfig.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerRepositoryTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CustomerRepository customerRepo; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSimpleCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Customer customer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(); customer.dob = LocalDate.of(<span class="hljs-number"><span class="hljs-number">1904</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>); customer.firstName = <span class="hljs-string"><span class="hljs-string">"Albert"</span></span>; Customer saved = customerRepo.save(customer); assertThat(saved.id).isNotNull(); saved.firstName = <span class="hljs-string"><span class="hljs-string">"Hans Albert"</span></span>; customerRepo.save(saved); Optional&lt;Customer&gt; reloaded = customerRepo.findById(saved.id); assertThat(reloaded).isNotEmpty(); assertThat(reloaded.get().firstName).isEqualTo(<span class="hljs-string"><span class="hljs-string">"Hans Albert"</span></span>); } }</code> </pre> <br><h1 id="annotaciya-query">  <code>@Query</code> </h1><br><p>  Hanya dengan metode CRUD standar yang dapat Anda lakukan jauh dari repositori kelas <code>CrudRepository</code> .  Kami sengaja memutuskan untuk menunda pembuatan kueri otomatis - fitur populer dari Data Spring, ketika kueri SQL dihasilkan berdasarkan nama metode - untuk rilis mendatang.  Dan untuk saat ini, Anda cukup menggunakan anotasi <code>@Query</code> familier untuk menentukan dengan tepat query SQL mana yang harus dieksekusi. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select id, first_name, dob from customer where upper(first_name) like '%' || upper(:name) || '%' "</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Customer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String name)</span></span>;</code> </pre> <br><p>  Jika Anda ingin mengubah atau menghapus data dalam permintaan, Anda dapat menambahkan penjelasan <code>@Modifying</code> dengan metode ini. </p><br><p>  Mari kita menulis tes untuk melihat cara kerja metode baru kita. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Customer customer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(); customer.dob = LocalDate.of(<span class="hljs-number"><span class="hljs-number">1904</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>); customer.firstName = <span class="hljs-string"><span class="hljs-string">"Albert"</span></span>; Customer saved = customerRepo.save(customer); assertThat(saved.id).isNotNull(); customer.id= <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; (<span class="hljs-number"><span class="hljs-number">1</span></span>) customer.firstName = <span class="hljs-string"><span class="hljs-string">"Bertram"</span></span>; customerRepo.save(customer); customer.id= <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; customer.firstName = <span class="hljs-string"><span class="hljs-string">"Beth"</span></span>; customerRepo.save(customer); assertThat(customerRepo.findByName(<span class="hljs-string"><span class="hljs-string">"bert"</span></span>)).hasSize(<span class="hljs-number"><span class="hljs-number">2</span></span>); (<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><ol><li>  Karena  Karena koneksi antara objek Java dan catatan dalam database hanya berdasarkan bidang dan jenis <code>Id</code> , pengaturan <code>Id</code> ke <code>null</code> dan menyimpan objek ini akan membuat catatan baru. </li><li>  Dalam permintaan, kami menggunakan case-sensitive seperti, dan oleh karena itu kami menemukan "Albert" dan "Bertram", tetapi tidak "Beth". </li></ol><br><h1 id="v-zavershenie">  Kesimpulannya </h1><br><p>  Tentu saja, lebih banyak yang bisa dikatakan tentang Spring Data JDBC, dan kami pasti akan memberi tahu Anda di artikel mendatang. </p><br><p>  Sementara itu, Anda dapat mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sampel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , dan, tentu saja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> .  Jika Anda memiliki pertanyaan, jangan ragu untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bertanya di StackOverflow</a> .  Dan jika Anda menemukan bug atau ingin meminta fitur baru - silakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buat tiket</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423697/">https://habr.com/ru/post/id423697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423685/index.html">Konkurensi PostgreSQL: tidak berbentuk bola, bukan kuda, tidak dalam ruang hampa</a></li>
<li><a href="../id423687/index.html">HyperX Pulsefire FPS Pro - lebih cepat, lebih kejam, lebih terjangkau</a></li>
<li><a href="../id423689/index.html">RTOS MAX - gratis? Kami berencana untuk membuka lisensi untuk penggunaan komersial gratis</a></li>
<li><a href="../id423693/index.html">Cara lain untuk menggunakan Webpack 4 dan pemisahan kode</a></li>
<li><a href="../id423695/index.html">Cara pensiun sebelum 40 tahun dengan sejuta dolar di rekening bank</a></li>
<li><a href="../id423699/index.html">"Ekonomi Digital" telah naik harganya: 2 triliun rubel harus dialokasikan dari anggaran</a></li>
<li><a href="../id423701/index.html">Panduan Node.js, Bagian 3: Hosting, REPL, Operasi Konsol, Modul</a></li>
<li><a href="../id423703/index.html">Manual Node.js, Bagian 4: File npm, package.json dan package-lock.json</a></li>
<li><a href="../id423705/index.html">Manual Node.js, Bagian 5: npm dan npx</a></li>
<li><a href="../id423707/index.html">Apa yang ada di balik tudung Jaxx. Entropi dari kotak 128 bit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>