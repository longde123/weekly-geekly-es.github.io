<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚öïÔ∏è üì¥ üë©üèº‚Äçü§ù‚Äçüë©üèª iOS Redes cuando la aplicaci√≥n no se est√° ejecutando üéø üëàüèº üìÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los usuarios esperan que la red funcione "m√°gicamente" y sin ser notada. Esta magia depende de los desarrolladores del sistema y las aplicaciones. Es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Redes cuando la aplicaci√≥n no se est√° ejecutando</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/478566/"><p><img src="https://habrastorage.org/webt/ok/hf/in/okhfincdajhwvcffenwaoaj6wcs.png" alt="imagen"></p><br><p>  Los usuarios esperan que la red funcione "m√°gicamente" y sin ser notada.  Esta magia depende de los desarrolladores del sistema y las aplicaciones.  Es dif√≠cil influir en el sistema, por lo tanto, nos limitaremos a la aplicaci√≥n. </p><br><p>  Este tema es complejo y hay innumerables problemas.  Discutiremos los que hemos encontrado en los √∫ltimos meses.  Pido disculpas por el volumen de inmediato.  En resumen, de ninguna manera, demasiadas peque√±as cosas a las que vale la pena prestarles atenci√≥n. </p><a name="habracut"></a><br><p>  Para empezar, tratemos con la terminolog√≠a. </p><br><p>  La transferencia de datos ocurre en dos direcciones: </p><br><ul><li>  <em>descargar</em> (descargar, descargar datos del servidor), </li><li>  <em>cargar</em> (enviar datos al servidor). </li></ul><br><p>  La aplicaci√≥n puede estar activa, pero puede funcionar en segundo plano.  Formalmente, tiene <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">otros estados</a> , pero solo nos interesan estos: </p><br><ul><li>  <em>fondo</em> (cuando la aplicaci√≥n est√° minimizada), </li><li>  <em>activo</em> (cuando la aplicaci√≥n est√° activa, en la pantalla). </li></ul><br><p> Patrones √∫tiles: <em>devoluci√≥n de llamada</em> , <em>delegado</em> ( <a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns">Patrones de dise√±o de cacao</a> , <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">sobre devoluci√≥n de llamada en Wikipedia</a> ).  Tambi√©n necesita saber <a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started"><code>  URLSession</code></a> (en el art√≠culo, el enlace tambi√©n menciona el trabajo de fondo con la red, pero de paso). </p><br><p>  Todos los ejemplos est√°n escritos en <a href="https://docs.swift.org/swift-book/">Swift 5</a> , funcionan en iOS 11 y versiones posteriores (probado en iOS 11 y 12) y asumen el uso de solicitudes HTTP regulares.  En su mayor parte, todo esto funcionar√°, comenzando con iOS 9, pero hay "matices". </p><br><h2 id="obschaya-shema-raboty-s-setyu-urlsession">  El esquema general de trabajo con la red.  URLSession </h2><br><p>  Trabajar con la red no es particularmente dif√≠cil: </p><br><ul><li>  crear la configuraci√≥n de <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration"><code>URLSessionConfiguration</code></a> ; </li><li>  crear una instancia de configuraci√≥n de <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> ; </li><li>  crear una tarea (usando <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask"><code>session.dataTask(‚Ä¶)</code></a> y m√©todos similares); </li><li>  suscribirse a las actualizaciones de tareas.  Las actualizaciones llegan de forma as√≠ncrona, pueden llegar al <em>delegado,</em> que se registra cuando se crea la sesi√≥n, o pueden estar en la <em>devoluci√≥n de llamada,</em> que se crea cuando se crea la tarea; </li><li>  Cuando vimos que la tarea est√° completa, volvemos a la l√≥gica de la aplicaci√≥n. </li></ul><br><p>  Un ejemplo simple se ve as√≠: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataTask = session.dataTask(with: url) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     //  callback,    }</span></span></code> </pre> <br><p>  Este esquema es similar para varias tareas, solo cambian las peque√±as cosas.  Y hasta que no necesitemos seguir trabajando con la red despu√©s de que el usuario haya cerrado la aplicaci√≥n, todo es relativamente simple. </p><br><blockquote>  Noto de inmediato que incluso en este escenario hay muchas cosas interesantes.  A veces necesita trabajar con redireccionamientos dif√≠ciles, a veces necesita autorizaci√≥n, fijaci√≥n de SSL o todo a la vez.  Puedes leer mucho sobre esto.  Por alguna raz√≥n, trabajar con la red en segundo plano se describe mucho menos. </blockquote><br><h2 id="sozdanie-sessii-dlya-raboty-v-background">  Crear una sesi√≥n para trabajar en segundo plano </h2><br><p>  ¬øCu√°l es la diferencia entre <em>URLSession de</em> fondo y habitual?  Funciona fuera del proceso de solicitud, en alg√∫n lugar dentro del sistema.  Por lo tanto, no "muere" cuando se completa el proceso de solicitud.  Se llama una sesi√≥n en segundo plano (as√≠ como el estado de la aplicaci√≥n, que es un poco confuso) y requiere configuraciones espec√≠ficas.  Por ejemplo, esto: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configuration = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.background(withIdentifier: <span class="hljs-string"><span class="hljs-string">"com.my.app"</span></span>) configuration.sessionSendsLaunchEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.isDiscretionary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.allowsCellularAccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.shouldUseExtendedBackgroundIdleMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.waitsForConnectivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  La configuraci√≥n tiene muchos otros par√°metros, pero estos se relacionan directamente con las sesiones en segundo plano: </p><br><ul><li>  <em>El identificador</em> (pasado en el inicializador) es una cadena que se utiliza para hacer coincidir las sesiones en segundo plano cuando la aplicaci√≥n se reinicia.  Si la aplicaci√≥n se reinicia y crea una sesi√≥n en segundo plano con un identificador que ya se utiliz√≥ en otra sesi√≥n en segundo plano, la nueva tendr√° acceso a las tareas de la anterior.  La conclusi√≥n de esto es simple.  Para un funcionamiento correcto, necesita que este identificador sea √∫nico para su aplicaci√≥n y permanente (puede usar, por ejemplo, un derivado de aplicaciones <em>bundleId</em> ); </li><li>  <em>sessionSendsLaunchEvents</em> indica si la sesi√≥n en segundo plano debe iniciar la aplicaci√≥n cuando se completa la transferencia de datos.  Si este par√°metro se establece en <code>false,</code> el disparador no suceder√° y la aplicaci√≥n recibir√° todos los eventos la pr√≥xima vez que se inicie.  Si el par√°metro es <code>true</code> , luego de que se complete la transferencia de datos, el sistema iniciar√° la aplicaci√≥n y llamar√° al m√©todo <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> correspondiente <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> ; </li><li>  <em>isDiscretionary</em> permite que el sistema programe tareas m√°s raramente.  Esto, por un lado, mejora la duraci√≥n de la bater√≠a y, por otro, puede ralentizar la tarea.  O tal vez acelerarlo.  Por ejemplo, si se descarga un gran volumen, el sistema podr√° pausar la tarea hasta que se conecte a WiFi y luego descargar todo r√°pidamente sin gastar Internet m√≥vil lento (si est√° permitido, ¬øqu√© sigue?).  Si la tarea se crea cuando la aplicaci√≥n ya est√° en segundo plano, este par√°metro se establece autom√°ticamente en <code>true</code> ; </li><li>  <em>allowCellularAccess</em> : un par√°metro que muestra que puede usar la comunicaci√≥n celular para trabajar con la red.  No jugu√© con √©l con cuidado, pero seg√∫n las revisiones, all√≠ (junto con un cambio de sistema similar) se presentan una gran cantidad de rastrillos; </li><li>  <em>shouldUseExtendedBackgroundIdleMode.</em>  Un par√°metro √∫til que muestra que el sistema debe mantener una conexi√≥n con el servidor durante m√°s tiempo cuando la aplicaci√≥n pasa a segundo plano.  De lo contrario, la conexi√≥n se interrumpir√°. </li><li>  <em>waitsForConnectivity</em> En un dispositivo m√≥vil, las comunicaciones pueden desaparecer por cortos per√≠odos de tiempo.  Las tareas creadas en este momento pueden suspenderse hasta que aparezca una conexi√≥n, o inmediatamente devolver un error de "no hay conexi√≥n".  El par√°metro le permite controlar este comportamiento.  Si es <code>false,</code> en ausencia de comunicaci√≥n, la tarea se interrumpir√° inmediatamente con un error.  Si es <code>true</code> , espere hasta que aparezca un enlace. </li><li>  la √∫ltima l√≠nea (inicializador de sesi√≥n) contiene un par√°metro importante, <em>delegado.</em>  Sobre √©l, un poco m√°s. </li></ul><br><h3 id="delegate-vs-callbacks">  Delegado vs Callbacks </h3><br><p>  Como dije anteriormente, hay dos formas de obtener eventos de una tarea / de una sesi√≥n.  El primero es la <em>devoluci√≥n de llamada:</em> </p><br><pre> <code class="swift hljs">session.dataTask(with: request) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...   }</code> </pre> <br><p>  En este caso, el evento de finalizaci√≥n de la tarea se enviar√° al cierre, donde debe verificar si hay un error, qu√© hay en la respuesta y qu√© datos han llegado. </p><br><p>  La segunda opci√≥n para trabajar con una sesi√≥n es a trav√©s de <em>delegado.</em>  En este caso, debemos crear una clase que implemente los protocolos <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> y (u) otros cercanos (para los diferentes tipos de tareas, los protocolos son ligeramente diferentes).  Una referencia a una instancia de esta clase vive en una sesi√≥n, y sus m√©todos se llaman cuando los eventos se pasan al delegado.  El enlace puede ser registrado en la sesi√≥n por el inicializador.  En el ejemplo, <code>self.</code> </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Para sesiones regulares, ambos m√©todos est√°n disponibles.  Las sesiones en segundo plano solo pueden ser utilizadas por un delegado. </p><br><p>  Entonces, configuramos la sesi√≥n, la creamos, veamos c√≥mo descargar algo. </p><br><h2 id="obschaya-shema-skachivaniya-dannyh-v-fone">  Esquema general para descargar datos en segundo plano </h2><br><p>  Para descargar datos, generalmente necesita formar una <a href="https://developer.apple.com/documentation/foundation/urlrequest"><code> (URLRequest)</code></a> , registrar los par√°metros / encabezados / datos necesarios en ella, crear una <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask"><code>URLSessionDownloadTask</code></a> y ejecutarla para su ejecuci√≥n.  Algo como esto: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//  request,   let task = session.downloadTask(with: request) if #available(iOS 11, *) { task.countOfBytesClientExpectsToSend = [approximate size of request] task.countOfBytesClientExpectsToReceive = [approximate size of response] } task.resume()</span></span></code> </pre> <br><p>  En este punto, nada es muy diferente de la tarea de descarga habitual.  Es cierto que <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">aparecieron</a> dos par√°metros <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">countOfBytesClientExpectsToSend</a> / <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">countOfBytesClientExpectsToReceive</a> , muestran la cantidad de datos que planeamos enviar en la solicitud y volver a la respuesta.  Esto es necesario para que el sistema pueda planificar m√°s correctamente el trabajo con la tarea, descargar m√°s r√°pido, sin sobrecargarse.  Estos valores no tienen que ser precisos. </p><br><p>  Despu√©s de <code>resume()</code> tarea se ejecutar√°.  Durante la transferencia de datos, se transmitir√° el progreso (al respecto; lea a continuaci√≥n, tambi√©n hay opciones all√≠) y, una vez completado, se ejecutar√°n varios m√©todos de delegado.  Entre ellos, hay uno muy importante: </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:downloadTask:didFinishDownloadingTo:)</code> </pre> <br><p>  El hecho es que la descarga se realiza en un archivo temporal, despu√©s de lo cual la aplicaci√≥n tiene la oportunidad de mover este archivo a alg√∫n lugar o hacer algo m√°s con √©l.  Este archivo temporal est√° disponible solo dentro de este m√©todo, despu√©s de salir de √©l, el archivo se elimina y no se puede hacer nada con √©l. </p><br><p>  Despu√©s de este importante m√©todo, se llamar√° a otro m√©todo donde caer√° el error si ocurre.  Si no hay <code>error</code> , el <code>error</code> ser√° <code>nil.</code> </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:task:didCompleteWithError:)</code> </pre> <br><p>  ¬øY qu√© sucede al final, si la solicitud pas√≥ a un segundo plano o se complet√≥?  ¬øC√≥mo llamar a los m√©todos delegados?  No es f√°cil aqu√≠. </p><br><p>  Si la descarga de algo iniciado por la aplicaci√≥n ha finalizado y el indicador <code>sessionSendsLaunchEvents</code> en la configuraci√≥n de la sesi√≥n, el sistema iniciar√° la aplicaci√≥n (en segundo plano) y llamar√° a la <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application%3Flanguage%3Dobjc">aplicaci√≥n (_: handleEventsForBackgroundURLSession: completeHandler :)</a> m√©todo en <code>AppDelegate,</code> . </p><br><p>  En este m√©todo, la aplicaci√≥n deber√≠a: </p><br><ul><li>  save <code>completionHandler</code> (deber√° llamarse despu√©s de un tiempo, de forma asincr√≥nica y en el hilo principal); </li><li>  recrear una sesi√≥n en segundo plano con el mismo identificador que antes (y que se pasa a este m√©todo en caso de que haya varias sesiones en segundo plano); </li><li>  en una sesi√≥n reci√©n creada, los eventos llegar√°n al delegado (en particular, la muy importante <code>urlSession(_:downloadTask:didFinishDownloadingTo:)</code> ), debe procesarlos, copiar los archivos donde desee; </li><li>  despu√©s de llamar a todos los m√©todos, se llama a otro m√©todo delegado, que se llama <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> y en el que tendr√° que llamar al <code>completionHandler.</code> almacenado anteriormente <code>completionHandler.</code> </li></ul><br><blockquote>  Es importante  Es necesario llamar a <code>completionHandler</code> en el hilo principal usando <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main"><code>DispatchQueue.main.async(...)</code></a> . </blockquote><p>  Al mismo tiempo, debe recordar que todo esto sucede en una aplicaci√≥n que funciona en segundo plano.  Y esto significa que los recursos (tiempo de ejecuci√≥n) son limitados.  Guarde r√°pidamente los archivos donde lo necesite, cambie los estados necesarios en la aplicaci√≥n y cierre, eso es todo lo que se puede hacer.  Si desea hacer m√°s, puede usar <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask"><code>UIApplication.beginBackgroundTask()</code></a> o las nuevas <a href="https://developer.apple.com/documentation/backgroundtasks">BackgroundTasks</a> . </p><br><h2 id="obschaya-shema-fonovoy-otpravki-dannyh">  Esquema general de env√≠o de datos de fondo </h2><br><p>  Subir archivos al servidor tambi√©n funciona con restricciones.  Sin embargo, todo comienza de manera similar: formamos una solicitud, creamos una tarea (ahora ser√° <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> , ejecutamos la tarea.  Cual es el problema </p><br><p>  El problema es c√≥mo creamos la solicitud.  Por lo general, formamos los datos enviados como <code>Data</code> .  Background <code>URLSession,</code> no sabe c√≥mo trabajar con esto.  Y con una solicitud de transmisi√≥n ( <code>uploadTask(withStreamedRequest:)</code> ) tampoco sabe c√≥mo.  Es necesario escribir todo lo que debe enviarse a un archivo y crear una tarea de env√≠o desde el archivo.  Resulta de alguna manera as√≠: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileUrl = methodThatSavesFileAndRetursItsUrl(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = session.uploadTask(with: request, fromFile: fileUrl) task.resume()</code> </pre> <br><p>  Pero no es necesario registrar el tama√±o, <code>URLSession</code> puede verlo por s√≠ mismo.  Despu√©s de enviar, <code>urlSession(_:task:didCompleteWithError:)</code> al mismo m√©todo delegado <code>urlSession(_:task:didCompleteWithError:)</code> como cuando se descarga.  Y as√≠, si la aplicaci√≥n fue eliminada o pas√≥ a un segundo plano durante el proceso de env√≠o, la <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> llegar√° <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> que debe procesarse exactamente de acuerdo con las mismas reglas que cuando se descargan datos. </p><br><h2 id="chto-takoe-prilozhenie-zaversheno">  ¬øQu√© es una solicitud completa? </h2><br><p>  Para probar las descargas y env√≠os en segundo plano, debe simular la finalizaci√≥n de la aplicaci√≥n (el trabajo en segundo plano con la red est√° especialmente dise√±ado para sobrevivir).  Como hacerlo  Inicialmente, de ninguna manera.  Es decir, no existe un m√©todo regular (autorizado, p√∫blico) que permita hacer esto.  Veamos d√≥nde est√° el rastrillo. </p><br><ul><li>  En primer lugar, simplemente cerrar la aplicaci√≥n (presionando el bot√≥n de inicio o haciendo un gesto apropiado) no funcionar√°.  Esto no matar√° la aplicaci√≥n, sino que solo la enviar√° a un segundo plano.  El significado de trabajar con una sesi√≥n en segundo plano es que funciona incluso si la aplicaci√≥n se elimina "por completo"; </li><li>  en segundo lugar, es imposible que un depurador (AppCode, Xcode o simplemente LLDB) est√© conectado, no permitir√° que la aplicaci√≥n muera ni siquiera un tiempo despu√©s de que se "cierre"; </li><li>  en tercer lugar, no puede eliminar la aplicaci√≥n desde la barra de tareas (administrador de tareas, inicio doble o deslizar lentamente "hacia arriba").  Por lo tanto, una aplicaci√≥n cancelada se considera "permanentemente" y el sistema detiene, junto con dicha acci√≥n, las sesiones de fondo asociadas con la aplicaci√≥n; </li><li>  cuarto, debe probar este proceso en un dispositivo real.  No hay problemas con el registro (ver m√°s abajo) y est√° m√°s depurado.  Se argumenta que el simulador tambi√©n deber√≠a funcionar como deber√≠a.  Pero not√© rarezas inexplicables que no puedo explicar con nada m√°s que fallas en el simulador.  En general, prueba en el dispositivo; </li><li>  La √∫nica forma razonable de hacer lo que quiere es con la funci√≥n <code>exit(int)</code> .  Como todos saben, no puede cargarlo en el servidor ( <a href="https://developer.apple.com/library/archive/qa/qa1561">esto contradice directamente los requisitos</a> ), pero por ahora solo estamos probando, no da miedo.  Conozco dos opciones razonables para usar esta funci√≥n: <br><ul><li>  <code>AppDelegate.applicationDidEnterBackground(_:)</code> autom√°ticamente en el m√©todo <code>AppDelegate.applicationDidEnterBackground(_:)</code> para que la aplicaci√≥n se cierre inmediatamente despu√©s de salir al Springboard; </li><li>  haga un componente en la interfaz (por ejemplo, un bot√≥n o cuelgue una acci√≥n en un gesto), haciendo clic en el cual <code>exit(...).</code> <br>  En este caso, la aplicaci√≥n se cerrar√° y el trabajo en segundo plano con la red deber√≠a continuar.  Y, despu√©s de alg√∫n tiempo, deber√≠amos recibir una llamada a la <code>application(_:handleEventsForBackgroundURLSession:completionHandler:).</code> </li></ul></li></ul><br><h2 id="kak-protokolirovat-rabotu-prilozheniya-esli-nelzya-polzovatsya-otladochnoy-konsolyu-xcode">  ¬øC√≥mo registrar la aplicaci√≥n si no puede usar la consola de depuraci√≥n Xcode? </h2><br><p>  Bueno, es imposible  Puedes, si realmente quieres.  No puede comenzar desde Xcode, y si la aplicaci√≥n, por ejemplo, ya se ha reiniciado debido a un evento del sistema, puede adjuntarla (adjuntarla al proceso) a la aplicaci√≥n y retirarla.  Pero esta soluci√≥n es regular, debe probar de alguna manera el proceso de reinicio. </p><br><p>  Puede usar <a href="https://en.wikipedia.org/wiki/Log_file">protocolos (registros, registros)</a> .  Hay varias opciones para su implementaci√≥n: </p><br><ul><li> <a href="https://developer.apple.com/documentation/swift/1541053-print"><code>print.</code></a>  A menudo se usa como "vamos a sacar algo r√°pidamente".  En nuestro caso, es imposible de usar, ya que no tenemos acceso a la consola en el dispositivo, la aplicaci√≥n se cierra. </li><li> <a href="https://developer.apple.com/documentation/foundation/1409759-nslog"><code>NSLog.</code></a>  Funcionar√°, ya que utiliza el tercer m√©todo. </li><li> <a href="https://developer.apple.com/documentation/os/logging"><code>os_log.</code></a>  El m√©todo m√°s correcto que le permite configurar correctamente los registros, pegarlos con el tipo deseado, deshabilitar despu√©s de la depuraci√≥n, sin cortar el c√≥digo en s√≠, y as√≠ sucesivamente. </li></ul><br><blockquote>  Atencion  Con <code>os_log</code> hay problemas (por ejemplo, la falta de registros de depuraci√≥n) que se reproducen solo en el simulador, pero no se reproducen en este dispositivo.  Usa el dispositivo. </blockquote><p>  C√≥mo usar <code>os_log,</code> lea c√≥mo configurarlo correctamente en la <a href="https://developer.apple.com/documentation/os/logging">documentaci√≥n de Apple</a> .  En particular, debe habilitar los registros de <code>debug</code> e <code>info</code> , de forma predeterminada est√°n ocultos. </p><br><h2 id="otslezhivanie-progressa-skachivaniya-ili-otpravki-dannyh">  Seguimiento del progreso de descarga o env√≠o de datos </h2><br><p>  En el proceso de transferencia de datos, quiero entender cu√°nto se ha enviado, cu√°nto queda.  Hay dos formas de hacer esto.  El primero es usar m√©todos delegados: </p><br><ul><li>  para enviar, debe usar <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code> </li><li>  existe un m√©todo similar para descargar <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> </li></ul><br><p>  Estos m√©todos se llaman cada vez que se descarga o env√≠a la siguiente pieza de datos.  No son necesariamente consistentes con los m√©todos para completar el proceso; tambi√©n se pueden invocar despu√©s de que los datos se hayan descargado o enviado por completo, por lo tanto, es imposible determinar que "todo ha terminado". </p><br><p>  El segundo m√©todo es m√°s interesante.  El hecho es que cada tarea proporciona un objeto de tipo <a href="https://developer.apple.com/documentation/foundation/progress"><code>Progress</code></a> (se encuentra en el campo <code>task.progress</code> ), que proporciona la capacidad de monitorear un proceso arbitrario, incluido el proceso de transferencia de datos.  ¬øC√≥mo es √©l interesante?  Dos cosas: </p><br><ul><li>  desde los objetos de <code>Progress</code> puede crear un √°rbol de ejecuci√≥n de tareas, cada uno de los cuales mostrar√° cu√°n avanzadas son todas las tareas que contiene.  Por ejemplo, si necesita enviar cinco archivos, puede tomar el progreso de cada uno, hacer un progreso general, agregarle otros cinco y monitorear el progreso de un padre, vinculando sus actualizaciones a alg√∫n elemento de la interfaz; </li><li>  puede agregar su progreso a este √°rbol, y tambi√©n puede pausar y cancelar acciones asociadas con el progreso agregado. </li></ul><br><p>  ¬øC√≥mo se relaciona esto con la descarga o el env√≠o de datos en segundo plano?  De ninguna manera  No se llama a los m√©todos delegados, y los objetos de progreso mueren cuando finaliza la aplicaci√≥n.  Para sesiones en segundo plano, este m√©todo no es adecuado. </p><br><h2 id="peredacha-zadach-iz-obychnoy-sessii-v-background-sessiyu">  "Transferir" tareas de una sesi√≥n normal a una sesi√≥n en segundo plano </h2><br><p>  Bueno, es m√°s dif√≠cil trabajar con una sesi√≥n de fondo.  ¬°Pero esto es conveniente!  No se perder√° una sola tarea, alguna vez obtendremos todos los datos que solicitamos, ¬øpor qu√© no usar siempre la sesi√≥n en segundo plano? </p><br><p>  Desafortunadamente, ella tiene fallas y serias.  Por ejemplo, una sesi√≥n en segundo plano es m√°s lenta.  En mis experimentos, la velocidad vari√≥ varias veces.  En segundo lugar, la ejecuci√≥n en segundo plano de una tarea puede retrasarse (especialmente si se establece el par√°metro <code>isDiscretionary</code> , que, como mencion√©, siempre es <code>true</code> para las tareas creadas mientras la aplicaci√≥n se ejecuta en segundo plano. </p><br><p>  Por lo tanto, cada vez que crea una tarea, debe comprender exactamente qu√© criterios para su trabajo, d√≥nde agregarla, a una sesi√≥n regular o en segundo plano.  Normal corre m√°s r√°pido, comienza de inmediato.  Fondo: m√°s largo, no inmediatamente, pero no se eliminar√° si el usuario cierra la aplicaci√≥n. </p><br><p>  Si no hay una comprensi√≥n obvia de que la tarea debe realizarse en la sesi√≥n en segundo plano (por ejemplo, la transferencia no cr√≠tica de una gran cantidad de datos, como la sincronizaci√≥n o la copia de seguridad), entonces vale la pena hacer lo siguiente: </p><br><ul><li>  Comience la tarea en una sesi√≥n regular.  En este caso, ejecute <em>backgroundTask</em> para que el sistema comprenda que necesitamos tiempo para completar la tarea.  Esto da algo de tiempo (hasta varios minutos, pero algo se rompi√≥ en iOS 13 y no est√° claro qu√© est√° sucediendo con √©l) para que la tarea se pueda completar. </li><li>  si no tiene tiempo, al final de <em>backgroundTask</em> transferimos la tarea de una sesi√≥n normal a una de fondo, donde contin√∫a funcionando y termina cuando puede. </li></ul><br><p>  ¬øC√≥mo transferir?  De ninguna manera  Simplemente elimine (cancele) la tarea habitual y cree un fondo similar (con la misma solicitud).  ¬øPor qu√© se llama esto una "transferencia"?  ¬øY por qu√© entre comillas? </p><br><p>  No hay transferencia para enviar datos.  Hay exactamente lo que se describe.  Mataron una tarea, lanzaron otra, se perdieron todos los datos que se enviaron por primera vez. </p><br><p>  Para descargar, la situaci√≥n es diferente.  El sistema sabe a qu√© archivo se descarga la solicitud.  Si ejecuta varias tareas para descargar la misma URL, por ejemplo, no ejecutar√° la solicitud varias veces.  Los datos se descargan una vez, despu√©s de lo cual el m√©todo delegado final (o devoluci√≥n de llamada) se ejecutar√° varias veces.  <a href="https://medium.com/%40sdrzn/handling-multiple-urlsession-tasks-efficiently-91c0957a7d77">Aqu√≠ se describe un experimento</a> que confirma esto.  Lo m√°s probable es que el almacenamiento en cach√© HTTP est√°ndar se use en el interior, al igual que en los navegadores. </p><br><p>  Aqu√≠ hay un c√≥digo de muestra que hace esto: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = backgroundSession.downloadTask(with: request) task.resume() } task.resume()</code> </pre> <br><p>  Si la tarea finaliza antes de que <code>expirationHandler</code> <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> , debe recordar llamar a <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> .  Esto se describe con m√°s detalle en la <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask">documentaci√≥n</a> . </p><br><p>  Para ayudar al sistema a continuar la descarga (por ejemplo, la cancelaci√≥n puede hacer que el archivo temporal se elimine antes de que se reanude la descarga en segundo plano), existen m√©todos especiales: </p><br><ul><li>  para obtener los datos necesarios para la renovaci√≥n, debe cancelar la tarea anterior utilizando el m√©todo <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">cancel (byProducingResumeData :)</a> ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para crear una tarea, dados los datos ya descargados: </font></font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">downloadTask (withResumeData :) -&gt; URLSessionDownloadTask</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, algo como esto:</font></font></li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel { data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDownloadTask</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data { task = backgroundSession.downloadTask(withResumeData: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task = backgroundSession.downloadTask(with: request) } task.resume() } }</code> </pre> <br><h2 id="grabli-na-kotorye-ya-nastupil"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El rastrillo que pis√© </font></font></h2><br><h3 id="logi">  Registros </h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La parte m√°s dif√≠cil de todo esto es entender exactamente lo que est√° sucediendo. </font><font style="vertical-align: inherit;">Un registro excelente es la primera tarea que debe abordarse de inmediato. </font><font style="vertical-align: inherit;">El comportamiento de las sesiones en segundo plano no se puede probar de ninguna manera, excepto mediante registros normales.</font></font></p><br><p> ,  ,  background     -,       ,      ,          (   UI,      ). , ,    ‚Äî .     ,   ‚Äî ,  ,  <code>os_log.</code> ( <code>NSLog)</code> </p><br><h3 id="priostanovka-biznes-logiki">  - </h3><br><p>        -  ,         .         ,     -  .    ,      ,   ,      ( )     . ,    ,      -,  ,  .     ‚Äî       ‚Äî ,    .   ‚Äî  ,       -  ( ),       ,      . </p><br><h3 id="testirovanie-na-ustroystve">    </h3><br><p>     .            (  ),    .  ,      ,    ,       . </p><br><h3 id="ogranicheniya">  Limitaciones </h3><br><p>    : </p><br><ul><li>   ,  ; </li><li>  ‚Äî  ,    ; </li><li>        ,     (,    ‚Ä¶); </li></ul><br><h3 id="melochi">  </h3><br><ul><li>        ,    <code>(task.taskIdentifier)</code>  ,     (Dictionary).    ,          1,   . </li><li>   , <code>URLSession.getAllTasks</code> .    ,        background .  ,    .   ,    . ¬Ø\_(„ÉÑ)_/¬Ø </li><li>   ,  ,         ,    ,     . </li></ul><br><p>       ,      background ,      .      ,      -    .      : <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1</a> .   , : </p><br><blockquote> If your app extension initiates a background NSURLSession task, you must also set up a shared container that both the extension and its containing app can access. Use the sharedContainerIdentifier property of the NSURLSessionConfiguration class to specify an identifier for the shared container so that you can access it later. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478566/">https://habr.com/ru/post/478566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478550/index.html">¬øC√≥mo gestionar un reloj? An√°lisis de la pista front-end del segundo campeonato de programaci√≥n.</a></li>
<li><a href="../478552/index.html">Segundo applet, cierre y botones transparentes en Processing 3</a></li>
<li><a href="../478554/index.html">Seminario web "SRE: ¬øexageraci√≥n o el futuro?" 12 de diciembre a las 11:00</a></li>
<li><a href="../478560/index.html">¬øSon an√≥nimos los mensajeros instant√°neos gratuitos?</a></li>
<li><a href="../478564/index.html">C√≥mo nosotros en TsIAN domesticamos terabytes de troncos</a></li>
<li><a href="../478572/index.html">Bot en redes neuronales: c√≥mo funciona y aprende un asistente virtual</a></li>
<li><a href="../478574/index.html">La verdad sobre los frenos de ferrocarril: Parte 4 - Frenos de pasajeros</a></li>
<li><a href="../478582/index.html">Informe VPN global sobre dispositivos m√≥viles en 2019</a></li>
<li><a href="../478584/index.html">Elementos internos de JVM, Parte 2 - Estructura de archivos de clase</a></li>
<li><a href="../478586/index.html">Ineficiencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>