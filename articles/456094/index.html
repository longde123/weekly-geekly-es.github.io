<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèΩ ‚úàÔ∏è üåâ Leemos hojas de datos 2: SPI en STM32; Temporizadores e interrupciones PWM en el STM8 ü•ò üë©üèΩ‚Äç‚öñÔ∏è üë©üèº‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte, trat√© de decirles a los aficionados a la electr√≥nica que surgieron de los pantalones Arduino c√≥mo y por qu√© deber√≠an leer hojas d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leemos hojas de datos 2: SPI en STM32; Temporizadores e interrupciones PWM en el STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte,</a> trat√© de decirles a los aficionados a la electr√≥nica que surgieron de los pantalones Arduino c√≥mo y por qu√© deber√≠an leer hojas de datos y otra documentaci√≥n para microcontroladores.  El texto result√≥ ser extenso, as√≠ que promet√≠ mostrar ejemplos pr√°cticos en un art√≠culo separado.  Bueno, se llam√≥ a s√≠ mismo un cargamento ... </p><br><p>  Hoy mostrar√© c√≥mo usar hojas de datos para resolver tareas bastante simples, pero necesarias para muchos proyectos, en los controladores STM32 (Blue Pill) y STM8.  Todos los proyectos de demostraci√≥n est√°n dedicados a mis LED favoritos, los iluminaremos en grandes cantidades, para lo cual tendremos que usar todo tipo de perif√©ricos interesantes. </p><a name="habracut"></a><br><p>  El texto result√≥ ser enorme nuevamente, as√≠ que por conveniencia estoy haciendo el contenido: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P√≠ldora azul STM32: 16 LED con controlador DM634</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STM8: Configuraci√≥n de seis pines PWM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STM8: 8 LED RGB en tres pines, interrupciones</a> </p><br><p>  <em>Descargo de responsabilidad: no soy ingeniero, no pretendo tener un conocimiento profundo en electr√≥nica, el art√≠culo est√° destinado a amantes como yo.</em>  <em>De hecho, como p√∫blico objetivo, me consider√© hace dos a√±os.</em>  <em>Si alguien me dijera que no da miedo leer hojas de datos en un chip desconocido, no habr√≠a pasado mucho tiempo buscando algunos c√≥digos en Internet e inventando muletas con tijeras y una curita.</em> </p><br><p>  <em>En el centro de este art√≠culo hay hojas de datos, no proyectos, por lo que es posible que el c√≥digo no se peine demasiado y, a menudo, se forje.</em>  <em>Los proyectos en s√≠ mismos son muy simples, aunque adecuados para un primer contacto con el nuevo chip.</em> </p><br><p>  <em>Espero que mi art√≠culo ayude a alguien en una etapa similar en una inmersi√≥n de hobby.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs con DM634 y SPI </h1><br><p>  Un peque√±o proyecto con la p√≠ldora azul (STM32F103C8T6) y el controlador LED DM634.  Con la ayuda de hojas de datos, trataremos con el controlador, IO-ports STM y configuraremos SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  Chip taiwan√©s con 16 salidas PWM de 16 bits, se puede conectar en cadenas.  El modelo m√°s joven de 12 bits es conocido por el proyecto dom√©stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lightpack</a> .  En un momento, al elegir entre el DM63x y el conocido TLC5940, me decid√≠ por el DM por varias razones: 1) El TLC en Aliexpress es definitivamente falso, pero este no lo es;  2) el DM tiene un PWM aut√≥nomo con su propio generador de frecuencia;  3) podr√≠a comprarse a bajo precio en Mosc√∫, y no esperar un paquete con Ali.  Bueno, por supuesto, fue interesante aprender a administrar el chip usted mismo y no usar una biblioteca preparada.  Los chips ahora se presentan principalmente en el paquete SSOP24, son f√°ciles de soldar al adaptador. </p><br><p>  Como el fabricante es taiwan√©s, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos</a> para el chip est√° escrita en ingl√©s chino, lo que significa que ser√° divertido.  Primero, mire la <em>conexi√≥n</em> del <em>pin</em> ( <em>Conexi√≥n del pin</em> ) para comprender a qu√© pata conectarse y la descripci√≥n de los pines ( <em>Descripci√≥n del pin</em> ).  16 conclusiones: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Fuentes de entrada de corriente continua (drenaje abierto)</sup> </p><br><p>  <strong>Salida de</strong> <strong>sumidero</strong> / <strong>drenaje abierto</strong> - drenaje;  fuente de corriente entrante;  salida activa conectada a tierra: los LED est√°n conectados al controlador por c√°todos.  El√©ctricamente, esto, por supuesto, no es un "drenaje abierto", pero en las hojas de datos esta designaci√≥n para salidas en modo de drenaje es com√∫n. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Resistencias externas entre REXT y GND para establecer el valor de la corriente de salida</sup> </p><br><p>  Se instala una resistencia de referencia entre el pin REXT y la tierra, que controla la resistencia interna de las salidas, consulte el gr√°fico en la p√°gina 9 de la hoja de datos.  En DM634, esta resistencia tambi√©n se puede controlar mediante programaci√≥n configurando el <em>brillo global</em> ;  No entrar√© en detalles en este art√≠culo, solo puse una resistencia de 2.2 - 3 kOhm aqu√≠. </p><br><p>  Para comprender c√≥mo controlar el chip, mire la descripci√≥n de la interfaz del dispositivo: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  S√≠, aqu√≠ est√°, ingl√©s chino en todo su esplendor.  Es problem√°tico traducir, puede comprenderlo si lo desea, pero hay otra forma: ver c√≥mo se describe la conexi√≥n en la hoja de datos del TLC5940 funcionalmente cercano: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Solo se requieren tres pines para ingresar datos en el dispositivo.</sub>  <sub>El borde de ataque de la se√±al SCLK desplaza los datos del pin SIN al registro interno.</sub>  <sub>Despu√©s de que se hayan descargado todos los datos, una breve se√±al XLAT alta captura los datos en serie en registros internos.</sub>  <sub>Registros internos: v√°lvulas de compuerta activadas por XLAT.</sub>  <sub>Todos los datos se transmiten en el bit hacia adelante m√°s significativo.</sub> </p><br><p>  <strong>Pestillo</strong> : un pestillo / pestillo / abrazadera. <br>  <strong>Borde ascendente</strong> - borde de ataque del impulso <br>  <strong>MSB primero</strong> : el <strong>bit m√°s significativo</strong> (m√°s a la izquierda) hacia adelante. <br>  <strong>para registrar datos</strong> : transmita datos secuencialmente (bit a bit). </p><br><p>  La palabra <em>pestillo a</em> menudo se encuentra en la documentaci√≥n para chips y se traduce de varias maneras, por lo que me permitir√© entender </p><div class="spoiler">  <b class="spoiler_title">peque√±o programa educativo</b> <div class="spoiler_text">  El controlador LED es esencialmente un registro de desplazamiento.  "Shift" en el nombre es un movimiento de datos dentro del dispositivo: cada nuevo bit empujado hacia adentro empuja toda la cadena frente a s√≠ mismo.  Dado que nadie quiere ver el destello ca√≥tico de los LED durante el turno, el proceso se lleva a cabo en registros de b√∫fer separados de los que funcionan por un <em>pestillo</em> ; este es un tipo de sala de espera, donde los bits est√°n dispuestos en la secuencia correcta.  Cuando todo est√° listo, el obturador se abre y los bits se env√≠an a trabajar, reemplazando el lote anterior.  La palabra <em>pestillo</em> en la documentaci√≥n para microcircuitos casi siempre implica tal amortiguador, sin importar en qu√© combinaci√≥n se use. </div></div><br><p>  Entonces, la transferencia de datos al DM634 es la siguiente: establezca la entrada DAI en el bit de orden superior del LED lejano, jale el DCK hacia arriba y hacia abajo;  establezca la entrada DAI al siguiente bit, extraiga DCK;  y as√≠ sucesivamente, hasta que se transmitan todos los bits ( <em>sincronizados</em> ), luego de lo cual extraemos el LAT.  Esto se puede hacer manualmente ( <em>bit-bang</em> ), pero es mejor usar la interfaz SPI afilada especialmente para esto, ya que se presenta en nuestro STM32 en dos copias. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Tableta azul STM32F103 </h2><br><p>  Introductorio: los controladores STM32 son mucho m√°s complicados que Atmega328 de lo que pueden asustar.  Al mismo tiempo, por razones de ahorro de energ√≠a, casi todos los perif√©ricos est√°n desactivados al inicio, y la frecuencia del reloj es de 8 MHz desde una fuente interna.  Afortunadamente, los programadores de STM escribieron un c√≥digo que llev√≥ el chip a los 72 MHz "calculados", y los autores de todos los IDE que conoc√≠a lo incluyeron en el procedimiento de inicializaci√≥n, por lo que no es necesario que lo registremos (pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede</a> hacerlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, si realmente lo desea</a> ).  Pero tienes que encender los perif√©ricos. </p><br><p>  Documentaci√≥n: El popular chip STM32F103C8T6 est√° instalado en la p√≠ldora azul, hay dos documentos √∫tiles para ello: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoja de datos</a> para microcontroladores STM32F103x8 y STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual de referencia</a> para toda la l√≠nea STM32F103 y m√°s all√°. </li></ul><br><p>  En una hoja de datos podemos estar interesados ‚Äã‚Äãen: </p><br><ul><li>  Pinouts - pinouts de chips - en caso de que decidamos hacer tablas nosotros mismos; </li><li>  Mapa de memoria: tarjeta de memoria para un chip espec√≠fico.  En el Manual de referencia hay una tarjeta para toda la l√≠nea, enumera los registros que no est√°n en el nuestro. </li><li>  Definiciones de pines de tabla: enumera las funciones principales y alternativas de los pines;  para la "p√≠ldora azul" en Internet, puede encontrar im√°genes m√°s convenientes con una lista de pines y sus funciones.  Por lo tanto, busque en Google el pinout Blue Pill y tenga a mano esta imagen: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: en la imagen de Internet se not√≥ un error en los comentarios, por lo que gracias.</em>  <em>La imagen ha sido reemplazada, pero esta es una lecci√≥n: es mejor verificar la informaci√≥n de las hojas que no son de datos.</em> </p><br><p>  Eliminamos la hoja de datos, abrimos el Manual de referencia, ahora solo la usamos. <br>  Procedimiento: nos ocupamos de la entrada / salida est√°ndar, configuramos SPI, activamos los perif√©ricos deseados. </p><br><h3 id="vvod-vyvod">  Entrada-salida </h3><br><p>  Atmega328 I / O es extremadamente simple, por lo que la abundancia de opciones de STM32 puede ser confusa.  Ahora solo necesitamos conclusiones, pero incluso hay cuatro opciones: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>salida de drenaje abierto, salida de contrafase, salida alternativa de contrafase, drenaje abierto alternativo</sub> </p><br><p>  " <em>Push-pull</em> " ( <em>push-pull</em> ): la conclusi√≥n habitual de Arduina, el pin puede ser ALTO o BAJO.  Pero con el "drenaje abierto" hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dificultades</a> , aunque en realidad todo es simple aqu√≠: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Configuraci√≥n de salida / cuando el puerto est√° asignado a la salida: / el b√∫fer de salida est√° activado: / - modo de drenaje abierto: "0" activa N-MOS en el registro de salida, "1" deja el puerto en modo Hi-Z en el registro de salida (P-MOS no est√° activado ) / - modo push-pull: "0" en el registro de salida activa N-MOS, "1" en el registro de salida activa P-MOS.</sub> </p><br><p>  La diferencia completa entre drenaje abierto y <em>push-pull</em> es que en el primer pin no puede aceptar el estado ALTO: al escribir una unidad en el registro de salida, cambia a <em>alta impedancia</em> , <em>hola -Z</em> ).  Al grabar cero, el pin en ambos modos se comporta igual, tanto l√≥gica como el√©ctricamente. </p><br><p>  En el modo de salida normal, el pin simplemente traduce el contenido del registro de salida.  En la "alternativa" est√° controlada por la periferia correspondiente (ver 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Si el bit de puerto se configura como una salida de funci√≥n alternativa, el registro de salida se deshabilita y el pin se conecta a la se√±al de salida perif√©rica</sub> </p><br><p>  Una funcionalidad alternativa para cada pin se describe en la hoja de datos de <em>Definiciones de Pin</em> y se encuentra en la imagen descargada.  Cuando se le pregunta qu√© hacer si el pin tiene varias funciones alternativas, la respuesta da una nota al pie en la hoja de datos: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Si varias unidades perif√©ricas usan el mismo pin, para evitar un conflicto entre funciones alternativas, solo se debe usar una unidad perif√©rica a la vez, cambiando usando el bit de activaci√≥n del reloj perif√©rico (en el registro RCC correspondiente).</sub> </p><br><p>  Finalmente, los pines en modo de salida tambi√©n tienen una velocidad de reloj.  Esta es otra caracter√≠stica de ahorro de energ√≠a, en nuestro caso, simplemente lo configuramos al m√°ximo y lo olvidamos. </p><br><p>  Entonces: utilizamos SPI, por lo que dos pines (con datos y una se√±al de reloj) deber√≠an ser una "funci√≥n push-push alternativa", y otra (LAT) deber√≠a ser "pull-push normal".  Pero antes de asignarlos, trataremos con SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Otro peque√±o programa educativo</b> <div class="spoiler_text"><p>  SPI o interfaz perif√©rica en serie (interfaz perif√©rica en serie): una interfaz simple y muy efectiva para la comunicaci√≥n MK con otras MK y el mundo exterior en general.  El principio de su funcionamiento ya se ha descrito anteriormente, donde se trata del controlador LED chino (en el manual de referencia, consulte la secci√≥n 25).  SPI puede funcionar en modo maestro ("maestro") y esclavo ("esclavo").  SPI tiene cuatro canales b√°sicos, de los cuales no todos pueden estar involucrados: </p><br><ul><li>  MOSI, Salida maestra / Entrada esclava: este pin en el modo maestro env√≠a, pero en el modo esclavo recibe datos; </li><li>  MISO, entrada maestra / salida esclava: por el contrario, en el maestro acepta, en el esclavo da; </li><li>  SCK, Serial Clock: establece la frecuencia de transferencia de datos en el maestro o recibe una se√±al de reloj en el esclavo.  Esencialmente late bits; </li><li>  SS, Slave Select: a trav√©s de este canal, el esclavo aprende que quiere algo de √©l.  En STM32, se llama NSS, donde N = negativo, es decir  el controlador se convierte en esclavo si hay tierra en este canal.  Combina bien con el modo Open Drain Output, pero esa es una historia diferente. </li></ul></div></div><br><p>  Como todo lo dem√°s, el SPI en el STM32 es rico en funcionalidad, lo que hace que sea algo dif√≠cil de entender.  Por ejemplo, puede funcionar no solo con el SPI, sino tambi√©n con la interfaz I2S, y en la documentaci√≥n sus descripciones est√°n mezcladas, debe cortar el exceso de manera oportuna.  Nuestra tarea es extremadamente simple: solo necesita enviar datos utilizando solo MOSI y SCK.  Vamos a la secci√≥n 25.3.4 (comunicaci√≥n semid√∫plex), donde encontramos <em>1 reloj y 1 cable de datos unidireccional</em> (1 se√±al de reloj y 1 flujo de datos unidireccional): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>En este modo, la aplicaci√≥n usa SPI en modo de solo transmisi√≥n o solo de recepci√≥n.</sub>  <sub>/ El modo de solo transmisi√≥n es similar al modo d√∫plex: los datos se transmiten en el pin de transmisi√≥n (MOSI en modo maestro o MISO en modo esclavo), y el pin de recepci√≥n (MISO o MOSI, respectivamente) se puede usar como un pin de entrada-salida regular.</sub>  <sub>En este caso, es suficiente que la aplicaci√≥n ignore el b√∫fer Rx (si lo lee, no habr√° datos transmitidos).</sub> </p><br><p>  Bueno, el pin MISO est√° libre de nosotros, conectemos la se√±al LAT a √©l.  Nos ocuparemos de Slave Select, que puede controlarse mediante programaci√≥n en el STM32, lo cual es extremadamente conveniente.  Leemos el p√°rrafo del mismo nombre en la secci√≥n 25.3.1 de la Descripci√≥n general de SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>Control de programa NSS (SSM = 1) / La informaci√≥n sobre la selecci√≥n del esclavo est√° contenida en el bit SSI del registro SPI_CR1.</sub>  <sub>El pin NSS externo permanece libre para otras necesidades de aplicaci√≥n.</sub> </p><br><p>  Es hora de escribir en los registros.  Decid√≠ usar SPI2, estamos buscando la direcci√≥n base en la hoja de datos, en la secci√≥n 3.3 Mapa de memoria: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Bueno, comenzamos: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Abrimos la secci√≥n 25.3.3 con el dicho "Configuraci√≥n de SPI en modo maestro": </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Configure la velocidad del reloj serial con los bits BR [2: 0] en el registro SPI_CR1.</strong> </p><br><p>  Los registros se recopilan en la secci√≥n del manual de referencia del mismo nombre.  CR1 tiene un <em>desplazamiento de direcci√≥n</em> ( <em>desplazamiento de direcci√≥n</em> ) de 0x00, por defecto todos los bits se restablecen ( <em>valor de restablecimiento</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Los bits BR establecen el divisor de frecuencia del reloj del controlador, determinando as√≠ la frecuencia a la que operar√° el SPI.  Tendremos una frecuencia STM32 de 72 MHz, el controlador LED, seg√∫n su hoja de datos, funciona con una frecuencia de hasta 25 MHz, por lo que debe dividirlo en cuatro (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Configure los bits CPOL y CPHA para determinar la relaci√≥n entre la transferencia de datos y la sincronizaci√≥n de la interfaz en serie (consulte el diagrama en la p√°gina 240)</strong> </p><br><p>  Como estamos leyendo hojas de datos aqu√≠, y sin considerar los circuitos, estudiemos mejor la descripci√≥n textual de los bits de CPOL y CPHA en la p√°gina 704 (Descripci√≥n general de SPI): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Fase de reloj y polaridad</sub> <sub><br></sub>  <sub>Usando los bits CPOL y CPHA del registro SPI_CR1, se pueden seleccionar cuatro opciones para las relaciones de temporizaci√≥n mediante programaci√≥n.</sub>  <sub>El bit CPOL (polaridad del reloj) controla el estado del reloj cuando no se transmiten datos.</sub>  <sub>Este bit controla los modos maestro y esclavo.</sub>  <sub>Si se restablece el CPOL, el pin SCK est√° bajo en modo inactivo.</sub>  <sub>Si se establece el bit CPOL, el pin SCK est√° en un nivel alto en modo inactivo.</sub> <sub><br></sub>  <sub>Si se establece el bit CPHA (fase de reloj), el segundo borde de la se√±al SCK act√∫a como una puerta trampa del bit alto (descendente si se borra CPOL o ascendente si se establece CPOL).</sub>  <sub>Los datos son capturados por el segundo cambio en la se√±al del reloj.</sub>  <sub>Si se borra el bit CPHA, el borde de ataque de la se√±al SCK act√∫a como una puerta trampa del bit alto (hacia abajo si se establece CPOL, o hacia arriba si se borra CPOL).</sub>  <sub>Los datos son capturados por el primer cambio en la se√±al del reloj.</sub> </p><br><p>  Habiendo fumado este conocimiento, concluimos que ambos bits deben permanecer ceros, porque  necesitamos que la se√±al SCK permanezca baja cuando no est√© en uso, y que los datos se transmitan a lo largo del borde delantero del pulso (consulte el <em>borde ascendente</em> en la hoja de datos del DM634). </p><br><p>  Por cierto, aqu√≠ encontramos por primera vez una caracter√≠stica del vocabulario en las hojas de datos ST: en ellas, la frase "restablecer bit a cero" se escribe <em>para restablecer un bit</em> y no <em>para borrar un bit</em> , como, por ejemplo, en Atmega. </p><br><p>  <strong>3. Configure el bit DFF para definir un formato de bloque de datos de 8 o 16 bits.</strong> </p><br><p>  Tom√© espec√≠ficamente el DM634 de 16 bits, para no molestarme con la transmisi√≥n de datos PWM de 12 bits, como el DM633.  DFF tiene sentido poner en una unidad: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Configure el bit LSBFIRST en el registro SPI_CR1 para determinar el formato de bloque</strong> </p><br><p>  LSBFIRST, como su nombre lo indica, establece el bit de orden inferior hacia adelante.  Pero el DM634 quiere recibir datos comenzando con el bit alto.  Por lo tanto, lo dejamos descartado. </p><br><p>  <strong>5. En modo hardware, si se requiere la entrada del pin NSS, env√≠e una se√±al alta al pin NSS durante toda la secuencia de transferencia de bytes.</strong>  <strong>En el modo de programa NSS, configure los bits SSM y SSI en el registro SPI_CR1.</strong>  <strong>Si el pin NSS deber√≠a funcionar en la salida, solo se debe establecer el bit SSOE.</strong> </p><br><p>  Instale SSM y SSI para olvidarse del modo de hardware NSS: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Los bits MSTR y SPE deben establecerse (permanecen establecidos solo si se aplica una se√±al alta al NSS)</strong> </p><br><p>  En realidad, con estos bits asignamos nuestro SPI como maestro y lo activamos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  SPI est√° configurado, escribamos funciones que env√≠en bytes al controlador de inmediato.  Continuamos leyendo 25.3.3 "Configuraci√≥n de SPI en modo maestro": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Procedimiento de transferencia de datos</sub> <sub><br></sub>  <sub>La transmisi√≥n comienza cuando se escribe un byte en el b√∫fer Tx.</sub> <sub><br></sub>  <sub>El byte de datos se carga en el registro de desplazamiento en modo <strong>paralelo</strong> (desde el bus interno) durante la transmisi√≥n del primer bit, despu√©s de lo cual se transmite en modo <strong>serie</strong> al pin MOSI, el primer o el √∫ltimo bit hacia adelante, dependiendo de la configuraci√≥n del bit LSBFIRST en el registro CPI_CR1.</sub>  <sub>El indicador TXE se establece despu√©s de que los datos se transfieren <strong>del b√∫fer Tx al registro de desplazamiento</strong> , y tambi√©n se crea una interrupci√≥n si el bit TXEIE se establece en el registro CPI_CR1.</sub> </p><br><p>  Destaqu√© algunas palabras en la traducci√≥n para llamar la atenci√≥n sobre una caracter√≠stica de la implementaci√≥n de SPI en los controladores STM.  En Atmega, el indicador TXE ( <em>Tx vac√≠o</em> , Tx est√° vac√≠o y listo para recibir datos) se establece solo despu√©s de que se haya apagado todo el byte.  Y aqu√≠ esta bandera se establece despu√©s de que el byte se inserta en el registro de desplazamiento interno.  Dado que todos los bits empujan all√≠ simult√°neamente (en paralelo), y luego los datos se transmiten secuencialmente, TXE se establece antes de que el byte se env√≠e completamente.  Esto es importante porque  en el caso de nuestro controlador LED, necesitamos extraer el pin LAT despu√©s de enviar <em>todos los</em> datos, es decir  Solo la bandera TXE no ser√° suficiente para nosotros. </p><br><p>  Y esto significa que necesitamos otra bandera.  Veamos en 25.3.7 - "Indicadores de estado": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>Bandera ocupada</sub> <sub><br></sub>  <sub>El indicador BSY se establece y restablece por hardware (escribir en √©l no afecta nada).</sub>  <sub>El indicador BSY indica el estado de la capa de comunicaci√≥n SPI.</sub> <sub><br></sub>  <sub>Se reinicia:</sub> <sub><br></sub>  <sub>cuando se completa la transferencia (excepto para el modo maestro, si la transferencia es continua)</sub> <sub><br></sub>  <sub>cuando SPI est√° deshabilitado</sub> <sub><br></sub>  <sub>cuando se produce un error en el modo asistente (MODF = 1)</sub> <sub><br></sub>  <sub>Si la transmisi√≥n no es continua, el indicador BSY se borra entre cada transmisi√≥n de datos.</sub> </p><br><p>  De acuerdo, ven a la mano.  Descubrimos d√≥nde se encuentra el b√∫fer Tx.  Para hacer esto, lea el "Registro de datos SPI": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Registro de datos</sub> <sub><br></sub>  <sub>Datos recibidos o datos para la transmisi√≥n.</sub> <sub><br></sub>  <sub>El registro de datos se divide en dos memorias intermedias: una para escribir (memoria intermedia de transmisi√≥n) y la segunda para leer (memoria intermedia de recepci√≥n).</sub>  <sub>Escribir en el registro de datos escribe en el b√∫fer Tx, y leer desde el registro de datos devolver√° el valor contenido en el b√∫fer Rx.</sub> </p><br><p>  Bueno, el registro de estado, donde hay banderas TXE y BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Nosotros escribimos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Bueno, dado que necesitamos transmitir 16 bytes dos veces, de acuerdo con el n√∫mero de salidas del controlador LED, algo como esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Pero todav√≠a no sabemos c√≥mo extraer el pin LAT, por lo que volveremos a E / S. </p><br><h3 id="naznachaem-piny">  Asignar pasadores </h3><br><p>  En STM32F1, los registros responsables del estado de los pines son bastante inusuales.  Est√° claro que hay m√°s de ellos que Atmega, pero tambi√©n difieren de otros chips STM.  Secci√≥n 9.1 Descripci√≥n general de GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Cada uno de los puertos de entrada / salida de prop√≥sito general <em>(GPIO)</em> tiene dos registros de configuraci√≥n de 32 bits (GPIOx_CRL y GPIOx_CRH), dos registros de datos de 32 bits (GPIOx_IDR y GPIOx_ODR), un registro de restablecimiento / restablecimiento de 32 bits (GPIOx_BSRR), 16 bits un registro de reinicio (GPIOx_BRR) y un registro de bloque de 32 bits (GPIOx_LCKR).</sub> </p><br><p>  Inusuales, adem√°s de bastante inconvenientes, los primeros dos registros est√°n aqu√≠, porque 16 pines de puerto est√°n dispersos sobre ellos en el formato "cuatro bits por hermano".  Es decir  los pines del cero al s√©ptimo est√°n en la CRL, y el resto en el CRH.  Al mismo tiempo, el resto de los registros caben con √©xito en los bits de todos los pines del puerto, a menudo quedando medio "reservado". </p><br><p>  Para simplificar, comience al final de la lista. </p><br><p>  No necesitamos un registro de bloque. </p><br><p>  Los registros de configuraci√≥n y restablecimiento son bastante divertidos, ya que se duplican parcialmente entre s√≠: puede escribir todo solo en BSRR, donde los 16 bits superiores restablecer√°n el pin a cero, y los inferiores, configurados en 1, o usar tambi√©n BRR, los 16 bits inferiores de los cuales solo restablecen el pin .  Me gusta la segunda opci√≥n.  Estos registros son importantes porque proporcionan acceso at√≥mico a los pines: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Instalaci√≥n at√≥mica o reinicio</sub> <sub><br></sub>  <sub>No necesita deshabilitar las interrupciones al programar GPIOx_ODR a nivel de bit: puede cambiar uno o m√°s bits con una operaci√≥n de escritura at√≥mica APB2.</sub>  <sub>Esto se logra escribiendo "1" en el registro de set / reset (GPIOx_BSRR o, solo para reset, en GPIOx_BRR) el bit que desea cambiar.</sub>  <sub>Otros bits permanecer√°n sin cambios.</sub> </p><br><p>  Los registros de datos tienen nombres bastante comunes: IDR = Registro de direcci√≥n de entrada, registro de entrada;  ODR = Registro de direcci√≥n de salida, registro de salida.  En el proyecto actual no los necesitaremos. </p><br><p>  Y finalmente, los registros de control.  Dado que estamos interesados ‚Äã‚Äãen los pines del segundo SPI, a saber, PB13, PB14 y PB15, miramos inmediatamente a CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  Y vemos que ser√° necesario escribir algo en bits del 20 al 31. </p><br><p>  Ya hemos descubierto lo que queremos de los pines, as√≠ que aqu√≠ puedo prescindir de una captura de pantalla, solo digo que MODE establece la direcci√≥n (entrada, si ambos bits est√°n configurados en 0) y la velocidad del pin (necesitamos 50MHz, es decir, ambos pin en "1"), y CNF establece el modo: normal "push-push" - 00, "alternativa" - 10. Por defecto, como vemos arriba, todos los pines tienen el tercer bit desde abajo (CNF0), los establece en modo de <em>entrada flotante</em> . </p><br><p>  Como planeo hacer algo m√°s con este chip, por simplicidad, he definido todos los valores posibles de MODE y CNF para los registros de control inferior y superior. </p><br><div class="spoiler">  <b class="spoiler_title">Bueno algo como esto</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Nuestros pines se encuentran en el puerto B (la direcci√≥n base es 0x40010C00), c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO ‚Äì B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  Y, en consecuencia, puede escribir definiciones para el LAT, que mover√° los registros BRR y BSRR: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse ‚Äì high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low solo por inercia, de alguna manera siempre fue as√≠, d√©jate quedar) </p><br><p>  Ahora todo ya est√° genial, simplemente no funciona.  Debido a que es STM32, ahorra electricidad, lo que significa que debe habilitar el reloj para los perif√©ricos necesarios. </p><br><h2 id="vklyuchaem-taktirovanie">  Activar el tiempo </h2><br><p>  El reloj es el responsable del reloj, tambi√©n son Clock.  Y ya pudimos ver la abreviatura RCC.  Lo estamos buscando en la documentaci√≥n: esto es Restablecer y Control de reloj. </p><br><p>  Como se dijo anteriormente, afortunadamente, la gente de STM hizo la parte m√°s dif√≠cil del tema del tiempo para nosotros, por lo que agradecemos mucho (una vez m√°s, le dar√© un enlace al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web de Di Halt</a> para aclarar cu√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confundido</a> est√°).  Solo necesitamos los registros responsables de habilitar los relojes perif√©ricos (Peripheral Clock Enable Registers).  Primero, encuentre la direcci√≥n base de RCC, est√° al comienzo de la "Tarjeta de memoria": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  Y luego haga clic en el enlace donde intenta encontrar algo en la placa o, mucho mejor, repase las descripciones de los registros de inclusi√≥n de las secciones sobre <em>habilitar registros</em> .  Donde encontramos RCC_APB1ENR y RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  Y en ellos, respectivamente, bits, incluido el marcado SPI2, IOPB (I / O Port B) y funciones alternativas (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  El c√≥digo final se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Si hay una oportunidad y deseo de probar, entonces conectamos DM634 de esta manera: DAI a PB15, DCK a PB13, LAT a PB14.  Alimentamos al conductor desde 5 voltios, no olvides combinar la tierra. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM en STM8 </h1><br><p>  Cuando estaba planeando este art√≠culo, por ejemplo, decid√≠ intentar aprender algunas funcionalidades de un chip desconocido con solo una hoja de datos, para no tener un zapatero sin botas.  STM8 se adaptaba perfectamente a este rol: en primer lugar, ten√≠a un par de placas base chinas con STM8S103, y en segundo lugar, no es muy popular, y por lo tanto la tentaci√≥n de leer y encontrar una soluci√≥n en Internet reside en la ausencia de estas soluciones. </p><br><p>  El chip tambi√©n tiene una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de datos</a> y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual de referencia RM0016</a> , en el primer pinout y direcciones de registro, en el segundo, todo lo dem√°s.  STM8 est√° programado en C en el feo IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ST Visual Develop</a> . </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Reloj y E / S </h3><br><p>  Por defecto, el STM8 funciona a una frecuencia de 2 MHz, esto debe ser reparado de inmediato. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>Reloj HSI (velocidad interna)</sub> <sub><br></sub>  <sub>El reloj HSI se obtiene de un oscilador RC interno de 16 MHz con un divisor programable (1 a 8).</sub>  <sub>Se establece en el registro del divisor de reloj (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Nota: al comienzo, el oscilador HSI RC con divisor 8 se selecciona como la fuente de reloj principal.</sub> </p><br><p>  Encontramos la direcci√≥n del registro en la hoja de datos, la descripci√≥n en refman y vemos que el registro debe borrarse: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Como vamos a iniciar PWM y conectar los LED, miramos el pinout: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  El chip es peque√±o, muchas funciones est√°n suspendidas en los mismos pines.  El hecho de que entre corchetes es "funcionalidad alternativa", se cambia por " <em>bytes de opci√≥n</em> ", algo as√≠ como los fusibles de Atmega.  Puede cambiar sus valores mediante programaci√≥n, pero no es necesario, porque  La nueva funcionalidad se activa solo despu√©s de un reinicio.  Es m√°s f√°cil usar ST Visual Programmer (descargas junto con Visual Develop) que puede cambiar estos bytes.  El pinout muestra que las conclusiones de CH1 y CH2 del primer temporizador est√°n ocultas entre corchetes;  es necesario poner los bits AFR1 y AFR0 en STVP, y el segundo tambi√©n transferir√° la salida de CH1 del segundo temporizador de PD4 a PC5. </p><br><p>  Por lo tanto, 6 pines controlar√°n los LED: PC6, PC7 y PC3 para el primer temporizador, PC5, PD3 y PA3 para el segundo. </p><br><p>  Configurar los pines de E / S en el STM8 es m√°s simple y l√≥gico que en el STM32: </p><br><ul><li>  familiarizado con el <em>registro de direcci√≥n de datos de</em> Atmega: 1 = salida; </li><li>  el primer registro de control CR1 en la salida establece el modo push-pull (1) o drenaje abierto (0);  Como conecto los LED al chip con c√°todos, dejo aqu√≠ ceros; </li><li>  el segundo registro de control CR2 en la salida establece la velocidad del reloj: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  Configuraci√≥n PWM </h2><br><p>  Primero, definamos los t√©rminos: </p><br><ul><li>  <strong>Frecuencia PWM</strong> : frecuencia con la que el temporizador est√° marcando; </li><li>  <strong>Recarga autom√°tica, AR</strong> : valor de carga autom√°tica con el que contar√° el temporizador (per√≠odo de pulso); </li><li>  <strong>Actualizar evento, UEV</strong> : un evento <strong>que ocurre</strong> cuando el temporizador ha contado a AR; </li><li>  <strong>Ciclo de</strong> trabajo PWM - <strong>Ciclo de</strong> trabajo PWM, a menudo denominado "ciclo de trabajo"; </li><li>  <strong>Capture / Compare Value</strong> (Valor de captura / comparaci√≥n): valor de captura / comparaci√≥n, habiendo contado hasta qu√© momento el temporizador <em>har√° algo</em> (en el caso de PWM, invierte la se√±al de salida); </li><li>  <strong>Valor de</strong> precarga: valor precargado.  <em>El valor de comparaci√≥n</em> no puede cambiar mientras el temporizador est√° funcionando; de lo contrario, el ciclo PWM se interrumpir√°.  Por lo tanto, los nuevos valores transmitidos se colocan en el b√∫fer y se extraen de all√≠ cuando el temporizador llega al final del conteo y se reinicia; </li><li>  <strong>Modos alineados al</strong> <strong>borde y alineados al</strong> <strong>centro</strong> : alineaci√≥n en el borde y en el centro, lo mismo que Atmelovskie <em>Fast PWM</em> y <em>Phase-correct PWM</em> . </li><li>  <strong>OCiREF, Se√±al de referencia de comparaci√≥n de salida</strong> : la se√±al de salida de referencia, de hecho, que en el modo PWM est√° en el pin correspondiente. </li></ul><br><p>  Como ya se desprende del pinout, dos temporizadores tienen las capacidades PWM: el primero y el segundo.  Ambos son de 16 bits, el primero tiene muchas caracter√≠sticas adicionales (en particular, puede contar tanto hacia arriba como hacia abajo).  Necesitamos que ambos trabajen de la misma manera, as√≠ que decid√≠ comenzar con el segundo obviamente m√°s pobre, para no usar accidentalmente algo que no est√° en √©l.  Alg√∫n problema es que la descripci√≥n de la funcionalidad PWM de todos los temporizadores en el manual de referencia se encuentra en el cap√≠tulo sobre el primer temporizador (17.5.7 Modo PWM), por lo que debe saltar de un lado a otro del documento. </p><br><p>  PWM en STM8 tiene una ventaja importante sobre PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM con alineaci√≥n de bordes</sub> <sub><br></sub>  <sub>Configuraci√≥n de cuenta de abajo hacia arriba</sub> <sub><br></sub>  <sub>El recuento ascendente est√° activo si el bit DIR en el registro TIM_CR1 se borra</sub> <sub><br></sub>  <sub>Ejemplo</sub> <sub><br></sub>  <sub>El ejemplo usa el primer modo PWM.</sub>  <sub>La se√±al de referencia OCiREF PWM se mantiene alta mientras TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>De lo contrario, se necesita un nivel bajo.</sub>  <sub>Si el valor de comparaci√≥n en TIM1_CCRi es mayor que el valor de inicio (registro TIM1_ARR), la se√±al OCiREF se mantiene en 1. <strong>Si el valor de comparaci√≥n es 0, OCiREF se mantiene en cero.</strong></sub>  <sub>...</sub> </p><br><p>  El temporizador STM8 durante el <em>evento de actualizaci√≥n</em> primero verifica el <em>valor de comparaci√≥n</em> y solo luego emite una se√±al de referencia.  El temporizador de Atmega se baraja primero y luego se compara, como resultado de lo cual, cuando se <code>compare value == 0</code> la salida da como resultado una aguja que necesita ser combatida de alguna manera (por ejemplo, mediante la l√≥gica de inversi√≥n program√°tica). </p><br><p>  Entonces, lo que queremos hacer: PWM de 8 bits ( <code>AR == 255</code> ), consideramos de abajo hacia arriba, la alineaci√≥n a lo largo del borde.  Como las bombillas est√°n conectadas al chip por c√°todos, el PWM debe emitir 0 (el LED est√° encendido) antes de <em>comparar el valor</em> y 1 despu√©s. </p><br><p>  Ya le√≠mos acerca de alg√∫n <em>modo PWM</em> , por lo que encontramos el registro deseado del segundo temporizador buscando en el manual de referencia esta frase (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Primer modo PWM: cuando se cuenta de abajo hacia arriba, el primer canal est√° activo mientras TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>De lo contrario, el primer canal est√° inactivo.</sub>  <sub>[m√°s adelante en el documento copiar y pegar err√≥neamente desde el temporizador 1]</sub> <sub><br></sub>  <sub>111: Segundo modo PWM: cuando se cuenta de abajo hacia arriba, el primer canal est√° inactivo mientras TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>De lo contrario, el primer canal est√° activo.</sub> </p><br><p>  Dado que los LED est√°n conectados a los c√°todos MK, el segundo modo es adecuado para nosotros (el primero tambi√©n, pero a√∫n no lo sabemos). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Habilitar precarga de salida 1</sub> <sub><br></sub>  <sub>0: registro de precarga en TIMx_CCR1 apagado.</sub>  <sub>Puede escribir a TIMx_CCR1 en cualquier momento.</sub>  <sub>El nuevo valor funciona de inmediato.</sub> <sub><br></sub>  <sub>1: el registro de precarga en TIMx_CCR1 est√° habilitado.</sub>  <sub>Las operaciones de lectura / escritura acceden al registro de precarga.</sub>  <sub>El valor precargado TIMx_CCR1 se carga en el registro sombra durante cada evento de actualizaci√≥n.</sub> <sub><br></sub>  <sub>* Nota: para que el modo PWM funcione correctamente, los registros de precarga deben estar activados.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   ¬´¬ª   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   ‚Ä¶    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   ‚Äì  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     ¬´¬ª   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   ¬´¬ª,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  ‚Äì ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     ‚Äì      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X ‚Äì  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> ‚Äì   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  Es decir  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     ‚Ññ13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    ‚Ññ13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> ‚Äì     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    ‚Äì <code>sim</code> ‚Äì  .          ¬´¬ª,         . </p><br><p>   ‚Äì <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456094/">https://habr.com/ru/post/456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456082/index.html">C√≥mo desarrollamos recomendaciones personalizadas de productos</a></li>
<li><a href="../456084/index.html">Kubernetes 1.15: Resumen de lo m√°s destacado</a></li>
<li><a href="../456086/index.html">iOS Storyboards: an√°lisis de los pros y contras, mejores pr√°cticas</a></li>
<li><a href="../456090/index.html">Introducci√≥n a las pruebas unitarias en Unity</a></li>
<li><a href="../456092/index.html">Siete signos preocupantes de que depende del clima, incluso si no lo cree</a></li>
<li><a href="../456096/index.html">Lo que hace el lector promedio de geektimes mientras se cierne en las nubes</a></li>
<li><a href="../456100/index.html">Ahora en el nuevo empaque: Kingston A400 en formato M.2 se apresura al mercado</a></li>
<li><a href="../456102/index.html">Reportes f√°ciles en C / C ++</a></li>
<li><a href="../456104/index.html">Ezblock Pi: programaci√≥n sin programaci√≥n, esta vez para fan√°ticos de Raspberry Pi</a></li>
<li><a href="../456106/index.html">Dividimos las funciones m√°s r√°pido. Experiencia de desarrollo de Android en Badoo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>