<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëπ ü§™ üà≥ Coleta de lixo na V8: como o novo GC Orinoco funciona üë®üèø‚Äçü§ù‚Äçüë®üèΩ üèôÔ∏è ü•â</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para ser honesto, este √© um dos artigos mais brutais que li recentemente: h√° muito sobre a morte em tenra idade, sobre persegui√ß√£o de uma √°rea da mem√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coleta de lixo na V8: como o novo GC Orinoco funciona</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/454930/">  Para ser honesto, este √© um dos artigos mais brutais que li recentemente: h√° muito sobre a morte em tenra idade, sobre persegui√ß√£o de uma √°rea da mem√≥ria para outra e sobre uma feroz luta pela produtividade.  Em geral, bem-vindo ao kat - h√° uma tradu√ß√£o de um excelente artigo de Peter Marshall sobre como a coleta de lixo funciona na V8 hoje. <br><br><img src="https://habrastorage.org/webt/s1/vj/i4/s1vji4ia58-4d6fppntreacevai.jpeg"><a name="habracut"></a><br><br>  Nos √∫ltimos anos, a abordagem da coleta de lixo na V8 mudou muito.  Como parte do projeto Orinoco, ele passou de uma abordagem consistente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parar o mundo</a> para abordagens paralelas e competitivas com fallback incremental. <br><br>  Nota: se voc√™ preferir assistir ao relat√≥rio do que ler o artigo, pode faz√™-lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Caso contr√°rio, continue a ler. <br><br>  Qualquer coletor de lixo possui um conjunto de tarefas que precisam ser executadas periodicamente: <br><br><ol><li>  Encontre objetos vivos / mortos na mem√≥ria. <br></li><li>  Reutilize a mem√≥ria ocupada por objetos mortos. <br></li><li>  Mem√≥ria compacta / desfragmentada (opcional). <br></li></ol><br>  Essas tarefas podem ser executadas sequencialmente ou voc√™ pode alternar.  A maneira mais f√°cil √© interromper a execu√ß√£o do JavaScript e fazer tudo sequencialmente no encadeamento principal.  No entanto, isso pode levar a atrasos, sobre os quais falamos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagens</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriores</a> , bem como a uma diminui√ß√£o no desempenho do programa em geral. <br><br><h2>  GC principal (marca compacta completa) </h2><br>  O GC principal coleta lixo de toda a pilha. <br><img src="https://habrastorage.org/webt/ap/4a/ew/ap4aewr_soaajwsy8pw7ybdn2qo.png"><br>  <i><font color="gray">A limpeza do lixo ocorre em tr√™s etapas: rotulagem, descarte e compacta√ß√£o</font></i> <br><br><h3>  Marca√ß√£o </h3><br>  Determinar de quais objetos voc√™ pode liberar mem√≥ria √© uma parte essencial do coletor de lixo.  Ele considera o objeto vivo com base em informa√ß√µes sobre sua acessibilidade.  Isso significa que qualquer objeto referenciado no tempo de execu√ß√£o atual deve ser armazenado na mem√≥ria e todos os objetos inacess√≠veis podem ser montados pelo GC. <br><br>  A marca√ß√£o √© o processo de localiza√ß√£o de objetos alcan√ß√°veis.  O GC possui um conjunto de ponteiros com os quais come√ßa a pesquisar, o chamado conjunto raiz.  Este conjunto inclui objetos da pilha de execu√ß√£o atual e objeto global.  Come√ßando com este conjunto, o GC segue cada ponteiro para um objeto JavaScript e marca cada um como alcan√ß√°vel, ap√≥s o que se move para ponteiros de objetos para outros objetos e repete esse processo recursivamente at√© que todos os objetos acess√≠veis sejam marcados. <br><br><h3>  Elimina√ß√£o </h3><br>  O descarte √© um processo no qual as √°reas de mem√≥ria restantes de objetos mortos s√£o inseridas em uma lista chamada lista livre.  Ap√≥s a conclus√£o do processo de marca√ß√£o, o GC encontra essas √°reas e as adiciona √† lista apropriada.  As listas gratuitas diferem entre si em que tamanho as √°reas de mem√≥ria est√£o armazenadas nelas, o que permite encontrar rapidamente a correta.  Posteriormente, quando queremos alocar mem√≥ria, procuraremos em uma das listas e encontraremos uma se√ß√£o de tamanho adequado. <br><br><h3>  Seal </h3><br>  Al√©m disso, o GC principal √†s vezes toma decis√µes sobre a limpeza / compacta√ß√£o de algumas p√°ginas de mem√≥ria com base em suas pr√≥prias estimativas heur√≠sticas, com base no grau de fragmenta√ß√£o da p√°gina.  Voc√™ pode pensar em compacta√ß√£o como um an√°logo de desfragmentar um disco r√≠gido em PCs mais antigos.  Copiamos os objetos sobreviventes para outras p√°ginas que ainda n√£o foram compactadas (aqui apenas use a lista livre).  Assim, podemos reutilizar os pequenos peda√ßos de mem√≥ria dispersos que sobraram dos objetos mortos. <br><br>  Uma das desvantagens do GC que copia objetos sobreviventes √© que, quando voc√™ cria muitos objetos de vida longa, precisa pagar um pre√ßo alto por copi√°-los.  √â por esse motivo que apenas algumas p√°ginas de mem√≥ria altamente fragmentadas s√£o compactadas, enquanto as demais s√£o simplesmente descartadas, o que n√£o requer c√≥pia de objetos sobreviventes. <br><br><h3>  Dispositivo de gera√ß√£o de mem√≥ria </h3><br>  A pilha na V8 √© dividida em √°reas chamadas gera√ß√µes.  H√° uma gera√ß√£o jovem (que por sua vez √© subdividida em gera√ß√£o "intermedi√°ria" e "intermedi√°ria") e gera√ß√µes antigas.  Objetos criados s√£o colocados na "manjedoura".  Posteriormente, se sobreviverem √† pr√≥xima coleta de lixo, permanecer√£o na gera√ß√£o mais jovem, mas passar√£o para a categoria "intermedi√°rio".  Se eles sobreviverem ap√≥s a pr√≥xima assembl√©ia, ser√£o colocados na gera√ß√£o mais antiga. <br><img src="https://habrastorage.org/webt/bl/jl/qc/bljlqc2s8amymre3zunoc1lgngi.png"><br>  <i><font color="gray">Um monte de V8 √© dividido em gera√ß√µes.</font></i>  <i><font color="gray">Objetos passam de mais jovens para mais velhos se sobreviverem √† coleta de lixo</font></i> <br><br>  Na coleta de lixo, existe o importante termo "hip√≥tese geracional".  Em termos simples, isso significa que a maioria dos objetos "morre jovem".  Em outras palavras, a maioria dos objetos √© criada e morre quase imediatamente do ponto de vista do GC.  E esta afirma√ß√£o √© verdadeira n√£o apenas para JavaScript, mas para as linguagens de programa√ß√£o mais din√¢micas. <br><br>  A organiza√ß√£o de heap na V8 √© baseada na hip√≥tese acima.  Por exemplo, √† primeira vista, pode parecer contra-intuitivo que o GC esteja compactando / movendo objetos que sobreviveram √† coleta de lixo, porque copiar objetos √© uma opera√ß√£o bastante cara para executar durante a coleta de lixo.  Mas, com base na hip√≥tese geracional, sabemos que muito poucos objetos sobreviver√£o a esse procedimento.  Portanto, se voc√™ mover apenas objetos sobreviventes, tudo o que n√£o foi movido poder√° ser automaticamente considerado lixo.  Isso significa que o pre√ßo que pagamos pela c√≥pia √© proporcional ao n√∫mero de objetos sobreviventes, e nem todos criados. <br><br><h2>  GC auxiliar (limpador) </h2><br>  Na verdade, existem dois coletores de lixo na V8.  O principal (mark-compact) coleta o lixo com bastante efici√™ncia de toda a pilha, enquanto o secund√°rio coleta o lixo apenas em uma mem√≥ria jovem, porque a hip√≥tese de gera√ß√£o nos diz que os principais esfor√ßos de coleta de lixo devem ser direcionados para l√°. <br><br>  O princ√≠pio operacional do GC auxiliar √© que os objetos sobreviventes sempre se movem para uma nova p√°gina de mem√≥ria.  Na V8, a mem√≥ria jovem √© dividida em duas metades.  Um √© sempre livre para permitir que objetos sobreviventes sejam movidos para ele e, durante a montagem, essa √°rea inicialmente vazia √© chamada de To-space.  A √°rea da qual a c√≥pia ocorre √© denominada From-space.  Na pior das hip√≥teses, todos os objetos podem sobreviver e, em seguida, voc√™ deve copi√°-los todos. <br><br>  Para esse tipo de montagem, existe um conjunto separado de ponteiros que se referem da mem√≥ria antiga para a jovem.  E, em vez de varrer toda a pilha, usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">barreiras de grava√ß√£o</a> para manter esse conjunto.  Assim, combinando esse conjunto com uma pilha e um objeto global, obtemos todos os links na mem√≥ria jovem sem precisar varrer todos os objetos da mem√≥ria antiga. <br><br>  Ao copiar objetos do espa√ßo para o espa√ßo, todos os objetos restantes s√£o colocados em uma se√ß√£o cont√≠nua da mem√≥ria.  Assim, √© poss√≠vel se livrar da fragmenta√ß√£o - falhas de mem√≥ria deixadas por objetos mortos.  Ap√≥s a conclus√£o da transfer√™ncia, o To-space torna-se From-space e vice-versa.  Assim que o GC terminar seu trabalho, a mem√≥ria para novos objetos ser√° alocada a partir do primeiro endere√ßo livre no From-space. <br><img src="https://habrastorage.org/webt/jt/yl/43/jtyl43bxlb-u7n8cgp3spapeksm.png"><br>  <i><font color="gray">O limpador transfere objetos sobreviventes para uma nova p√°gina de mem√≥ria</font></i> <i><br></i> <br>  Se voc√™ usar apenas essa estrat√©gia e n√£o mover objetos da mem√≥ria jovem, a mem√≥ria terminar√° rapidamente.  Portanto, objetos que sobreviveram a duas coletas de lixo s√£o movidos para a mem√≥ria antiga. <br><br>  A etapa final √© atualizar os ponteiros para objetos que foram movidos.  Cada objeto copiado deixa seu endere√ßo original, deixando o endere√ßo de encaminhamento, o que √© necess√°rio para encontrar o objeto original no futuro. <br><img src="https://habrastorage.org/webt/ld/kv/oo/ldkvoorwihux9nfklfxk2p3fbos.png"><br>  <i><font color="gray">O limpador transfere objetos "intermedi√°rios" para a mem√≥ria antiga e objetos da "manjedoura" - para uma nova p√°gina</font></i> <br><br>  Assim, a coleta de lixo na mem√≥ria jovem consiste em tr√™s etapas: marcar objetos, copi√°-los, atualizar ponteiros. <br><br><h2>  Orinoco </h2><br>  A maioria desses algoritmos √© descrita em v√°rias fontes e geralmente √© usada em ambientes de tempo de execu√ß√£o que suportam a coleta autom√°tica de lixo.  Mas o GC no V8 percorreu um longo caminho antes de se tornar uma ferramenta verdadeiramente moderna.  Uma das m√©tricas significativas que descrevem seu desempenho √© com que frequ√™ncia e por quanto tempo o encadeamento principal √© interrompido enquanto o coletor de lixo executa suas fun√ß√µes.  Para os construtores cl√°ssicos de parar o mundo, esse tempo deixa sua marca na experi√™ncia de usar a p√°gina devido a atrasos, renderiza√ß√£o de baixa qualidade e aumento do tempo de resposta. <br><img src="https://habrastorage.org/webt/za/ct/gv/zactgvbniosnjhuqfmuvbeazggs.png"><br>  <i><font color="gray">Orinoco GC V8 Logo</font></i> <br><br>  Orinoco √© o nome de c√≥digo do GC usando t√©cnicas avan√ßadas de coleta de lixo paralela, incremental e competitiva.  Existem alguns termos que t√™m significados espec√≠ficos no contexto do GC, ent√£o vamos primeiro dar suas defini√ß√µes. <br><br><h3>  Paralelismo </h3><br>  Paralelismo √© quando os encadeamentos principal e auxiliar realizam aproximadamente a mesma quantidade de trabalho por unidade de tempo.  Essa ainda √© a abordagem de parar o mundo, mas a dura√ß√£o da pausa neste caso √© dividida pelo n√∫mero de threads que participam do trabalho (menos o custo da sincroniza√ß√£o). <br><br>  Essa √© a mais simples das tr√™s t√©cnicas.  O heap n√£o muda porque o JavaScript n√£o √© executado, portanto, √© suficiente que os threads mantenham a sincroniza√ß√£o do acesso aos objetos. <br><img src="https://habrastorage.org/webt/1s/1z/sl/1s1zsldqhz08kn8nciao0dooadi.png"><br>  <i><font color="gray">Threads principal e auxiliar trabalham na mesma tarefa ao mesmo tempo</font></i> <br><br><h3>  Incrementalidade </h3><br>  Incrementalidade √© quando o thread principal faz uma pequena quantidade de trabalho intermitentemente.  Em vez de coleta de lixo completa, pequenas tarefas para coleta parcial s√£o conclu√≠das. <br><br>  Essa √© uma tarefa mais dif√≠cil, porque o JavaScript √© executado entre montagens incrementais, o que significa que o estado do heap muda, o que por sua vez pode invalidar parte do trabalho realizado na itera√ß√£o anterior. <br><br>  Como pode ser visto no diagrama, essa abordagem n√£o reduz a quantidade total de trabalho (e, em regra, at√© aumenta), mas distribui esse trabalho no tempo.  Portanto, essa √© uma boa maneira de resolver uma das principais tarefas - reduzindo o tempo de resposta do fluxo principal. <br>  Ao permitir que o JavaScript seja executado com pouca interrup√ß√£o na coleta de lixo, o aplicativo pode continuar respondendo: responda √† entrada do usu√°rio e atualize as anima√ß√µes. <br><img src="https://habrastorage.org/webt/mc/yi/t7/mcyit7ystjkd8iddxxfj8zqhruw.png"><br>  <i><font color="gray">Pequenas √°reas do GC trabalham no segmento principal</font></i> <br><br><h3>  Competitividade </h3><br>  A competi√ß√£o ocorre quando o encadeamento principal executa o JavaScript continuamente e os encadeamentos auxiliares coletam lixo em segundo plano.  Essa √© a mais dif√≠cil das tr√™s t√©cnicas: o heap pode mudar a qualquer momento, invalidando o trabalho feito pelo GC antes. <br><br>  Al√©m disso, tamb√©m existem corridas de leitura / grava√ß√£o, pois os fluxos auxiliar e principal l√™em ou modificam simultaneamente os mesmos objetos. <br><img src="https://habrastorage.org/webt/bm/uh/9y/bmuh9y_1linhkt6v4rthj1xky3g.png"><br>  <i><font color="gray">A montagem ocorre completamente em segundo plano, o thread principal no momento pode executar JavaScript</font></i> <br><br><h2>  Status do GC na V8 </h2><br><h3>  Limpeza </h3><br>  O V8 distribui o trabalho de coleta de lixo entre os threads auxiliares na mem√≥ria jovem (elimina√ß√£o).  Cada thread recebe um conjunto de ponteiros, ap√≥s o qual move todos os objetos vivos para o To-space. <br><br>  Ao mover objetos no To-space, os encadeamentos precisam ser sincronizados por meio de opera√ß√µes at√¥micas de leitura / grava√ß√£o / compara√ß√£o e troca para evitar uma situa√ß√£o em que, por exemplo, outro encadeamento tenha detectado o mesmo objeto, mas seguindo um caminho diferente, e tamb√©m tente mov√™-lo. <br><br>  O thread que moveu o objeto para To-space retorna e deixa um ponteiro de encaminhamento para que outros threads que encontrarem esse objeto possam seguir o endere√ßo correto.  Para aloca√ß√£o de mem√≥ria r√°pida e sem sincroniza√ß√£o para objetos sobreviventes, os threads usam buffers locais do thread. <br><img src="https://habrastorage.org/webt/jy/hj/cf/jyhjcfoy8qok8juwfddy6cczslu.png"><br>  <i><font color="gray">A montagem paralela distribui o trabalho entre v√°rias roscas auxiliares e a rosca principal</font></i> <br><br><h3>  Core gc </h3><br>  O GC principal na V8 come√ßa marcando objetos.  Assim que o heap atinge um certo limite (calculado dinamicamente), marcadores competitivos come√ßam seu trabalho.  Cada um dos fluxos recebe um conjunto de ponteiros e, seguindo-os, eles marcam cada objeto encontrado como alcan√ß√°vel. <br><br>  A rotulagem competitiva ocorre completamente em segundo plano enquanto o JavaScript est√° em execu√ß√£o no segmento principal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Barreiras de grava√ß√£o</a> s√£o usadas para acompanhar novos links entre objetos criados em JavaScript enquanto os threads est√£o marcando. <br><br><img src="https://habrastorage.org/webt/er/bi/-l/erbi-lduzw0biseu7gysr416fuq.png"><br>  <i><font color="gray">O GC prim√°rio usa rotulagem, descarte e compacta√ß√£o paralela e atualiza√ß√£o de indicadores</font></i> <br><br>  No final da rotulagem competitiva, a rosca principal executa um passo r√°pido para finalizar a rotulagem.  Durante isso, a execu√ß√£o do JavaScript no thread principal √© pausada. <br><br>  O conjunto raiz √© verificado novamente para garantir que todos os objetos vivos estejam marcados e, em seguida, a compacta√ß√£o de mem√≥ria e a atualiza√ß√£o dos ponteiros come√ßam em v√°rios segmentos. <br>  Nem todas as p√°ginas da mem√≥ria antiga s√£o compactadas - aquelas que n√£o s√£o ser√£o digitalizadas para as √°reas de mem√≥ria liberada (varredura) para list√°-las em listas gratuitas. <br><br>  Durante essa pausa, tarefas abrangentes que competem com as tarefas de compacta√ß√£o de mem√≥ria e o encadeamento principal e podem continuar mesmo quando o JavaScript √© executado no encadeamento principal. <br><br><h2>  GC em tempo ocioso </h2><br>  Os desenvolvedores de JavaScript n√£o t√™m acesso ao GC - ele faz parte do ambiente de implementa√ß√£o.  E embora o c√≥digo JS n√£o possa chamar o GC diretamente, a V8 fornece esse acesso ao ambiente que incorpora o mecanismo. <br><br>  O GC pode enviar tarefas (tarefas ociosas) que podem ser feitas "no seu tempo livre" e que s√£o partes do trabalho que precisariam ser feitas de qualquer maneira.  Um ambiente como o Chrome, onde o mecanismo est√° incorporado, pode ter uma id√©ia do que considerar como tempo livre.  Por exemplo, no Chrome, a uma taxa de quadros de 60 quadros por segundo, o navegador tem aproximadamente 16,6 ms para renderizar um quadro de anima√ß√£o. <br><br>  Se o trabalho de anima√ß√£o for conclu√≠do anteriormente, no seu tempo livre, antes do pr√≥ximo quadro, o Chrome poder√° executar algumas das tarefas recebidas do GC. <br><img src="https://habrastorage.org/webt/la/-i/bi/la-ibisn9rw6ulv6djzufbu-tt0.png"><br>  <i><font color="gray">O GC usa o tempo livre do fluxo principal para pr√©-limpar</font></i> <br><br>  Detalhes podem ser encontrados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossa publica√ß√£o no GC em tempo ocioso</a> . <br><br><h2>  Sum√°rio </h2><br>  O GC na V8 percorreu um longo caminho desde a sua introdu√ß√£o.  A adi√ß√£o de t√©cnicas paralelas, incrementais e competitivas levou v√°rios anos, mas valeu a pena, permitindo que voc√™ fizesse a maior parte do trabalho em segundo plano. <br><br>  Tudo relacionado a pausas do fluxo principal, tempo de resposta e carregamento da p√°gina melhorou significativamente, o que permite tornar as anima√ß√µes, a rolagem e a intera√ß√£o do usu√°rio na p√°gina muito mais suaves.  O coletor paralelo permitiu reduzir o tempo total de processamento da mem√≥ria jovem em 20-50%, dependendo da carga. <br><br>  O GC em tempo ocioso reduz o tamanho do heap usado para o Gmail em 45%.  A rotulagem e descarte competitivos (varredura) podem reduzir a dura√ß√£o das pausas do GC em jogos WebGL pesados ‚Äã‚Äãem at√© 50%. <br><br>  No entanto, o trabalho ainda n√£o est√° conclu√≠do.  Reduzir pausas continua sendo uma tarefa importante para simplificar a vida dos usu√°rios da Web, e estamos buscando a possibilidade de usar t√©cnicas mais avan√ßadas para atingir a meta. <br><br>  Al√©m disso, o Blink (um renderizador no Chrome) tamb√©m √© equipado com um tanque de √≥leo, e estamos trabalhando para melhorar a intera√ß√£o entre os dois GCs, bem como para usar as t√©cnicas do Orinoco no Oilpan. <br><br>  A maioria dos desenvolvedores de JavaScript n√£o precisa pensar em como o GC funciona, mas alguma compreens√£o disso pode ajud√°-lo a tomar as melhores decis√µes em rela√ß√£o ao uso de mem√≥ria e aos padr√µes de programa√ß√£o.  Por exemplo, dada a estrutura geracional da pilha V8, objetos de baixa vida s√£o realmente muito baratos do ponto de vista do GC, pois pagamos principalmente pelos objetos sobreviventes.  E esse tipo de padr√£o √© caracter√≠stico n√£o apenas do JavaScript, mas tamb√©m de muitos idiomas com suporte para coleta de lixo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454930/">https://habr.com/ru/post/pt454930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454916/index.html">Arquitetura de rede neural para implementar o algoritmo RL com a capacidade de definir a√ß√µes em execu√ß√£o simultaneamente</a></li>
<li><a href="../pt454918/index.html">Como combinar as costas de dois varejistas no SAP em 12 horas</a></li>
<li><a href="../pt454920/index.html">Desempenho do front end: analisando m√©tricas importantes</a></li>
<li><a href="../pt454924/index.html">Configura√ß√µes de autentica√ß√£o no Veeam Backup para Microsoft Office 365 v3</a></li>
<li><a href="../pt454928/index.html">Maneira de ignorar a tela de bloqueio do Windows em sess√µes RDP</a></li>
<li><a href="../pt454932/index.html">Investimentos e software: 5 terminais de negocia√ß√£o para negocia√ß√£o na bolsa</a></li>
<li><a href="../pt454936/index.html">Vivaldi: o bloqueio de an√∫ncios deve ser a escolha do usu√°rio</a></li>
<li><a href="../pt454940/index.html">Seguro de sa√∫de de viagem: instru√ß√µes detalhadas</a></li>
<li><a href="../pt454944/index.html">Como o formato JPEG funciona</a></li>
<li><a href="../pt454946/index.html">Estados globais: por que e como evit√°-los</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>