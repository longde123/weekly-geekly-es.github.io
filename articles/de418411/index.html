<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé† üë®üèº‚Äç‚öñÔ∏è üñ±Ô∏è Browser-Netzwerk-Shooter auf Node.js. ü§ï üí™üèø üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung von Multiplayer-Spielen ist aus vielen Gr√ºnden kompliziert: Ihr Hosting kann teuer sein, die Struktur ist nicht offensichtlich und die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Browser-Netzwerk-Shooter auf Node.js.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418411/"> Die Entwicklung von Multiplayer-Spielen ist aus vielen Gr√ºnden kompliziert: Ihr Hosting kann teuer sein, die Struktur ist nicht offensichtlich und die Implementierung ist schwierig.  In diesem Tutorial werde ich versuchen, Ihnen zu helfen, die letzte Barriere zu √ºberwinden. <br><br>  Dieser Artikel richtet sich an Entwickler, die Spiele erstellen k√∂nnen und mit JavaScript vertraut sind, aber noch nie Multiplayer-Online-Spiele geschrieben haben.  Nach Abschluss dieses Tutorials beherrschen Sie die Implementierung grundlegender Netzwerkkomponenten in Ihrem Spiel und k√∂nnen sie zu etwas mehr entwickeln!  Folgendes werden wir erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/220/340/e9a22034098ab10a84721a48615a1476.png"></div><br>  Sie k√∂nnen das fertige Spiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier spielen</a> !  Wenn Sie die W- oder "Auf" -Taste dr√ºcken, n√§hert sich das Schiff dem Cursor. Wenn Sie mit der Maus klicken, schie√üt es.  <em>(Wenn niemand online ist, √∂ffnen Sie zwei Browserfenster auf einem Computer oder eines davon auf dem Telefon, um zu √ºberpr√ºfen, wie der Mehrspielermodus funktioniert.)</em>  Wenn Sie das Spiel lokal ausf√ºhren m√∂chten, ist der vollst√§ndige Quellcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">GitHub</a> verf√ºgbar. <br><a name="habracut"></a><br>  Bei der Erstellung des Spiels habe ich die grafischen Ressourcen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Kenneys Piratenpaket</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Phaser-</a> Spiel-Framework verwendet.  In diesem Tutorial wird Ihnen die Rolle des Netzwerkprogrammierers zugewiesen.  Der Ausgangspunkt wird eine voll funktionsf√§hige Einzelbenutzerversion des Spiels sein. Unsere Aufgabe wird es sein, einen Server auf Node.js mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Socket.io</a> f√ºr den Netzwerkteil zu schreiben.  Um das Tutorial nicht zu √ºberladen, werde ich mich auf Teile konzentrieren, die sich auf Multiplayer beziehen, und Konzepte √ºberspringen, die sich auf Phaser und Node.js beziehen. <br><br>  Sie m√ºssen nichts lokal konfigurieren, da wir dieses Spiel vollst√§ndig im Browser auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glitch.com erstellen werden</a> !  Glitch ist ein gro√üartiges Tool zum Erstellen von Webanwendungen, einschlie√ülich Backends, Datenbanken und mehr.  Es eignet sich hervorragend f√ºr Prototyping, Schulung und Zusammenarbeit, und ich freue mich sehr, Ihnen in diesem Lernprogramm die Funktionen vorstellen zu k√∂nnen. <br><br>  Fangen wir an. <br><br><h2>  1. Vorbereitung </h2><br>  Ich habe den Entwurf des Projekts auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Glitch.com ver√∂ffentlicht</a> . <br><br>  Tipps zur Benutzeroberfl√§che: Sie k√∂nnen die Anwendungsvorschau starten, indem Sie auf die Schaltfl√§che Anzeigen (oben links) klicken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/8b6/4dd/ac28b64dd9c37370872ad6a913b10078.png"></div><br>  Die vertikale Seitenleiste links enth√§lt alle Anwendungsdateien.  Um diese Anwendung zu bearbeiten, m√ºssen Sie ihren ‚ÄûRemix‚Äú erstellen.  Also werden wir eine Kopie davon in unserem Konto erstellen (oder "Gabel" im Git-Jargon).  Klicken Sie auf die Schaltfl√§che <strong>Diesen Remix</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/88f/6e4/f7188f6e4b66e9b9801d04c7891d42dd.png"></div><br>  Zu diesem Zeitpunkt bearbeiten Sie die Anwendung unter einem anonymen Konto.  Um Ihre Arbeit zu speichern, k√∂nnen Sie sich anmelden (oben rechts). <br><br>  Bevor Sie fortfahren, ist es wichtig, dass Sie sich mit dem Spiel vertraut machen, in dem wir einen Mehrspielermodus hinzuf√ºgen.  Schauen Sie sich <strong>index.html an</strong> .  Es hat drei wichtige Funktionen, die Sie kennen m√ºssen: <code>preload</code> (Zeile 99), <code>GameLoop</code> (Zeile 115) und <code>GameLoop</code> (Zeile 142) sowie das Player-Objekt (Zeile 35). <br><br>  Wenn Sie lieber durch √úben lernen m√∂chten, m√ºssen Sie die Arbeit des Spiels verstehen, indem Sie die folgenden Aufgaben ausf√ºhren: <br><br><ul><li>  Erh√∂hen Sie die Gr√∂√üe der Welt <em>(Zeile 29).</em> <em>Beachten Sie, dass es eine separate Weltgr√∂√üe f√ºr die Welt im Spiel und eine Fenstergr√∂√üe f√ºr die Seitenfl√§che selbst gibt</em> . </li><li>  Machen Sie es m√∂glich, mit Hilfe des ‚ÄûLeerzeichens‚Äú <em>(Zeile 53)</em> vorw√§rts zu gehen <em>.</em> </li><li>  √Ñndern Sie den Schiffstyp des Spielers <em>(Zeile 129).</em> </li><li>  Verlangsamen Sie die Bewegung der Muscheln <em>(Zeile 155).</em> </li></ul><br><h3>  Installieren Sie Socket.io </h3><br>  Socket.io ist eine Bibliothek zum Verwalten der Echtzeitkommunikation in einem Browser mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSockets</a> (anstelle von Protokollen wie UDP, mit denen klassische Multiplayer-Spiele erstellt werden).  Dar√ºber hinaus verf√ºgt die Bibliothek √ºber redundante M√∂glichkeiten, um den Betrieb sicherzustellen, auch wenn WebSockets nicht unterst√ºtzt werden.  Das hei√üt, sie befasst sich mit Messaging-Protokollen und erm√∂glicht die Verwendung eines praktischen ereignisbasierten Messaging-Systems. <br><br>  Als erstes m√ºssen wir das Socket.io-Modul installieren.  In Glitch k√∂nnen Sie dazu in die Datei <strong>package.json gehen</strong> und dann entweder das erforderliche Modul in die Abh√§ngigkeiten eingeben oder auf <strong>Paket</strong> hinzuf√ºgen klicken und "socket.io" eingeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/41f/005/d9441f0059e23044aa69f6f8750c81bb.png"></div><br>  Jetzt ist der richtige Zeitpunkt, um mit Serverprotokollen umzugehen.  Klicken Sie links auf die Schaltfl√§che <strong>Protokolle</strong> , um das Serverprotokoll zu √∂ffnen.  Sie sollten sehen, dass Socket.io mit all seinen Abh√§ngigkeiten installiert wird.  Hier m√ºssen Sie nach allen Fehlern und der Ausgabe des Servercodes suchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/6e1/58c/7db6e158c6e48d0d91f70344eaf51af7.png"></div><br>  Gehen wir jetzt zu <strong>server.js</strong> .  Hier befindet sich unser Servercode.  Bisher gibt es nur einen grundlegenden Code f√ºr die Bereitstellung unseres HTML-Codes.  F√ºgen Sie oben in der Datei eine Zeile hinzu, um Socket.io zu aktivieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(http); <span class="hljs-comment"><span class="hljs-comment">//     http</span></span></code> </pre> <br>  Jetzt m√ºssen wir auch Socket.io im Client aktivieren. Kehren wir also zu <strong>index.html zur√ºck</strong> und f√ºgen die folgenden Zeilen in das <code>&lt;head&gt;</code> -Tag ein: <br><br><pre> <code class="javascript hljs">&lt;!--    Socket.io --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/socket.io/socket.io.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  <em>Hinweis: Socket.io verarbeitet das Laden der Clientbibliothek automatisch √ºber diesen Pfad, sodass diese Zeile auch dann funktioniert, wenn sich in Ihren Ordnern kein Verzeichnis /socket.io/ befindet.</em> <br><br>  Jetzt ist Socket.io im Projekt enthalten und einsatzbereit! <br><br><h2>  2. Erkennen und Laichen von Spielern </h2><br>  Unser erster wirklicher Schritt wird darin bestehen, Verbindungen auf dem Server zu akzeptieren und neue Player im Client zu erstellen. <br><br><h3>  Serververbindungen akzeptieren </h3><br>  F√ºgen Sie diesen Code am Ende von <strong>server.js hinzu</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); })</span></span></code> </pre> <br>  Daher bitten wir Socket.io, alle <code>connection</code> abzuh√∂ren, die automatisch auftreten, wenn ein Client eine Verbindung herstellt.  Die Bibliothek erstellt f√ºr jeden Client ein neues <code>socket</code> Objekt, wobei <code>socket.id</code> die eindeutige Kennung f√ºr diesen Client ist. <br><br>  Um zu √ºberpr√ºfen, ob dies funktioniert, kehren Sie zum Client ( <strong>index.html</strong> ) zur√ºck und f√ºgen Sie diese Zeile irgendwo in der <strong>Erstellungsfunktion hinzu</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = io(); <span class="hljs-comment"><span class="hljs-comment">//    'connection'  </span></span></code> </pre> <br>  Wenn Sie das Spiel starten und das Serverprotokoll anzeigen (klicken Sie auf die Schaltfl√§che <strong>Protokolle</strong> ), sehen Sie, dass der Server dieses Verbindungsereignis registriert hat! <br><br>  Wenn wir nun einen neuen Spieler verbinden, erwarten wir, dass er uns Informationen √ºber seinen Zustand gibt.  In unserem Fall m√ºssen wir mindestens <strong>x</strong> , <strong>y</strong> und <strong>Winkel kennen</strong> , um es am richtigen Punkt korrekt zu erstellen. <br><br>  Das <code>connection</code> war ein Inline-Ereignis, das von Socket.io ausgel√∂st wurde.  Wir k√∂nnen alle unabh√§ngig festgelegten Ereignisse anh√∂ren.  Ich werde meinen Event <code>new-player</code> benennen und ich erwarte, dass der Client ihn sendet, sobald er sich mit Informationen √ºber seine Position verbindet.  Es wird so aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); }) })</span></span></code> </pre> <br>  Wenn Sie diesen Code ausf√ºhren, bis Sie etwas im Serverprotokoll sehen, weil wir den Client noch nicht angewiesen haben, dieses Ereignis f√ºr <code>new-player</code> zu generieren.  Aber tun wir f√ºr einen Moment so, als h√§tten wir dies bereits getan, und arbeiten wir weiter am Server.  Was soll passieren, nachdem der Standort eines neuen Spielers gefunden wurde? <br><br>  Wir k√∂nnen allen <em>anderen</em> verbundenen Spielern eine Nachricht senden, damit sie wissen, dass ein neuer Spieler aufgetaucht ist.  Socket.io hat hierf√ºr eine praktische Funktion: <br><br><pre> <code class="javascript hljs">socket.broadcast.emit(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,state_data);</code> </pre> <br>  Wenn <code>socket.emit</code> aufgerufen wird <code>socket.emit</code> Nachricht einfach an diesen einzelnen Client √ºbergeben.  Wenn <code>socket.broadcast.emit</code> aufgerufen wird <code>socket.broadcast.emit</code> es an jeden mit dem Server verbundenen Client gesendet, au√üer an dessen Socket diese Funktion aufgerufen wurde. <br><br>  Die Funktion <code>io.emit</code> sendet <code>io.emit</code> eine Nachricht an jeden mit dem Server verbundenen Client.  In unserem Schema brauchen wir das nicht, denn wenn wir eine Nachricht vom Server erhalten, in der wir aufgefordert werden, unser eigenes Schiff zu erstellen, erhalten wir ein Duplikat des Sprites, da wir bereits zu Beginn des Spiels unser eigenes Schiff erstellt haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein praktischer Tipp</a> zu den verschiedenen Arten von Messaging-Funktionen, die wir in diesem Tutorial verwenden werden. <br><br>  Der Servercode sollte nun folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); socket.broadcast.emit('create-player',state_data); }) })</span></span></code> </pre> <br>  Das hei√üt, jedes Mal, wenn sich ein Spieler verbindet, erwarten wir, dass er uns eine Nachricht mit Informationen √ºber seinen Standort sendet, und wir senden diese Daten an alle anderen Spieler, damit diese sein Sprite erstellen k√∂nnen. <br><br><h3>  Client-Laichen </h3><br>  Um diesen Zyklus abzuschlie√üen, m√ºssen wir nun zwei Aktionen im Client ausf√ºhren: <br><br><ol><li>  Generieren Sie nach der Verbindung eine Nachricht mit den Daten unseres Standorts. </li><li>  H√∂ren Sie sich Ereignisse zum Erstellen von Spielern an und erstellen Sie an dieser Stelle einen Spieler. </li></ol><br>  Um die erste Aktion nach dem Erstellen eines Players in der <strong>Erstellungsfunktion</strong> (ungef√§hr in Zeile 135) auszuf√ºhren, k√∂nnen wir eine Nachricht generieren, die die Standortdaten enth√§lt, die wir senden m√ºssen: <br><br><pre> <code class="javascript hljs">socket.emit(<span class="hljs-string"><span class="hljs-string">'new-player'</span></span>,{<span class="hljs-attr"><span class="hljs-attr">x</span></span>:player.sprite.x,<span class="hljs-attr"><span class="hljs-attr">y</span></span>:player.sprite.y,<span class="hljs-attr"><span class="hljs-attr">angle</span></span>:player.sprite.rotation})</code> </pre> <br>  Wir m√ºssen uns nicht um die Serialisierung der gesendeten Daten k√ºmmern.  Sie k√∂nnen sie in jede Art von Objekt √ºbertragen, und Socket.io wird es f√ºr uns verarbeiten. <br><br>  <em>Testen Sie den Code,</em> bevor Sie <em>fortfahren</em> .  In den Serverprotokollen sollte eine √§hnliche Meldung angezeigt werden: <br><br><pre> <code class="javascript hljs">New player has state: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">728.8180247836519</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">261.9979387913289</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Jetzt wissen wir, dass unser Server eine Benachrichtigung √ºber die Verbindung eines neuen Players erh√§lt und die Daten √ºber seinen Standort korrekt liest! <br><br>  Als n√§chstes m√∂chten wir Anfragen abh√∂ren, um einen neuen Player zu erstellen.  Wir k√∂nnen diesen Code sofort nach dem Generieren der Nachricht platzieren. Er sollte folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CreateShip -      ,     CreateShip(1,state.x,state.y,state.angle) })</span></span></code> </pre> <br>  <em>Testen Sie nun den Code</em> .  √ñffne zwei Fenster mit dem Spiel und stelle sicher, dass es funktioniert. <br><br>  Sie sollten sehen, dass nach dem √ñffnen von zwei Clients auf dem ersten Client zwei Schiffe erstellt wurden und auf dem zweiten nur eines. <br><br><blockquote>  Aufgabe: K√∂nnen Sie herausfinden, warum es passiert ist?  Oder wie k√∂nnen Sie das beheben?  Folgen Sie Schritt f√ºr Schritt der von uns geschriebenen Client / Server-Logik und versuchen Sie, sie zu debuggen. </blockquote><br>  Ich hoffe, Sie haben versucht, es selbst herauszufinden!  Folgendes passiert: Wenn der erste Spieler eine Verbindung herstellt, sendet der Server ein Ereignis zum <code>create-player</code> eines <code>create-player</code> an alle anderen Spieler, aber es gibt noch keine Spieler, die es empfangen k√∂nnen.  Nach dem Verbinden des zweiten Spielers sendet der Server seine Nachrichten erneut, und der erste Spieler empf√§ngt sie und erstellt das Sprite korrekt, w√§hrend der zweite Spieler die Nachricht des ersten Spielers verpasst hat. <br><br>  Das Problem ist, dass der zweite Spieler sp√§ter eine Verbindung zum Spiel herstellt und den Status des Spiels kennen muss.  Wir m√ºssen alle neuen Verbindungsspieler dar√ºber informieren, dass die Spieler bereits existieren (sowie andere Ereignisse, die in der Welt stattgefunden haben), damit sie sich orientieren k√∂nnen.  Bevor wir dieses Problem l√∂sen, habe ich eine kurze Warnung. <br><br><h3>  Warnung zur Synchronisierung des Spielstatus </h3><br>  Es gibt zwei Ans√§tze zur Implementierung der Synchronisation aller Spieler.  Die erste besteht darin, eine Mindestmenge an Informationen √ºber die √Ñnderungen zu senden, die √ºber das Netzwerk vorgenommen wurden.  Das hei√üt, jedes Mal, wenn ein neuer Spieler verbunden wird, senden wir allen anderen Spielern nur Informationen √ºber diesen neuen Spieler (und senden eine Liste aller anderen Spieler auf der Welt an diesen neuen Spieler), und nach dem Trennen der Verbindung informieren wir alle Spieler, dass dieser bestimmte Spieler die Verbindung getrennt hat. <br><br>  Der zweite Ansatz besteht darin, den gesamten Status des Spiels zu vermitteln.  In diesem Fall senden wir jedes Mal, wenn Sie eine Verbindung herstellen oder trennen, jedem eine vollst√§ndige Liste aller Spieler. <br><br>  Der erste Ansatz ist insofern besser, als er die Menge der √ºber das Netzwerk √ºbertragenen Informationen minimiert. Die Implementierung kann jedoch sehr schwierig sein und es besteht die Wahrscheinlichkeit, dass die Spieler nicht synchron sind.  Die zweite stellt sicher, dass die Spieler immer synchron sind, aber jede Nachricht muss mehr Daten senden. <br><br>  In unserem Fall k√∂nnen wir all dies zu einem gemeinsamen <code>update</code> kombinieren, anstatt zu versuchen, Nachrichten zu senden, wenn ein Player verbunden ist, um es zu erstellen, und wenn die Verbindung zum L√∂schen getrennt wird, um es zu l√∂schen, sowie wenn Sie sich bewegen, um seine Position zu <code>update</code> .  Dieses Update-Ereignis sendet immer die Positionen jedes Spielers an alle Kunden.  Dies sollte der Server tun.  Die Aufgabe des Kunden besteht darin, die weltweite Einhaltung des Empfangsstatus aufrechtzuerhalten. <br><br>  Um ein solches Schema zu implementieren, werde ich Folgendes tun: <br><br><ol><li>  Ich werde ein W√∂rterbuch der Spieler f√ºhren, dessen Schl√ºssel ihre ID ist, und der Wert werden Daten √ºber ihren Standort sein. </li><li>  F√ºgen Sie diesem W√∂rterbuch einen Player hinzu, wenn es verbunden ist, und senden Sie ein Aktualisierungsereignis. </li><li>  Entfernen Sie den Player aus diesem W√∂rterbuch, wenn er ausgeschaltet ist, und senden Sie ein Aktualisierungsereignis. </li></ol><br>  Sie k√∂nnen versuchen, dieses System selbst zu implementieren, da diese Schritte recht einfach sind ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">mein Feature-Tipp</a> kann hier n√ºtzlich sein).  So k√∂nnte die vollst√§ndige Implementierung aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    // 1 -      / var players = {}; io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); // 2 -      players[socket.id] = state_data; //    io.emit('update-players',players); }) socket.on('disconnect',function(){ // 3-       delete players[socket.id]; //    }) })</span></span></code> </pre> <br>  Die Client-Seite ist etwas komplizierter.  Einerseits sollten wir uns jetzt nur um das <code>update-players</code> Ereignis k√ºmmern, andererseits sollten wir in Betracht ziehen, neue Schiffe zu erstellen, wenn der Server mehr Schiffe sendet als wir wissen, oder zu l√∂schen, wenn zu viele davon vorhanden sind. <br><br>  So gehe ich mit diesem Ereignis im Client um: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     // : -         other_players = {} socket.on('update-players',function(players_data){ var players_found = {}; //        for(var id in players_data){ //      if(other_players[id] == undefined &amp;&amp; id != socket.id){ // ,      var data = players_data[id]; var p = CreateShip(1,data.x,data.y,data.angle); other_players[id] = p; console.log("Created new player at (" + data.x + ", " + data.y + ")"); } players_found[id] = true; //     if(id != socket.id){ other_players[id].x = players_data[id].x; //  ,    ,      other_players[id].y = players_data[id].y; other_players[id].rotation = players_data[id].angle; } } //       for(var id in other_players){ if(!players_found[id]){ other_players[id].destroy(); delete other_players[id]; } } })</span></span></code> </pre> <br>  Auf der Clientseite speichere ich Schiffe im W√∂rterbuch <code>other_players</code> , das ich gerade oben im Skript definiert habe (es wird hier nicht angezeigt).  Da der Server Spielerdaten an alle Spieler sendet, muss ich eine Pr√ºfung hinzuf√ºgen, damit der Client kein zus√§tzliches Sprite f√ºr sich selbst erstellt.  (Wenn Sie Probleme mit der Strukturierung haben, finden Sie hier den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">vollst√§ndigen Code</a> , der sich derzeit in index.html befinden sollte.) <br><br>  <em>Testen Sie nun den Code</em> .  Sie sollten in der Lage sein, mehrere Kunden zu erstellen und die richtige Anzahl von Schiffen an den richtigen Positionen zu sehen! <br><br><h2>  3. Synchronisation der Schiffspositionen </h2><br>  Hier beginnt ein sehr interessanter Teil.  Wir m√∂chten Schiffspositionen auf allen Kunden synchronisieren.  Dies wird die Einfachheit der Struktur zeigen, die wir im Moment erstellt haben.  Wir haben bereits ein Update-Ereignis, mit dem die Standorte aller Schiffe synchronisiert werden k√∂nnen.  Es reicht uns, Folgendes zu tun: <br><br><ol><li>  Erzwingen Sie, dass der Client jedes Mal eine Nachricht generiert, wenn er an eine neue Position wechselt. </li><li>  Bringen Sie dem Server bei, diese Verschiebungsnachricht abzuh√∂ren und das Spielerdatenelement im <code>players</code> aktualisieren. </li><li>  Generieren Sie ein Update-Ereignis f√ºr alle Clients. </li></ol><br>  Und das sollte reichen!  Jetzt sind Sie an der Reihe, dies selbst umzusetzen. <br><br>  Wenn Sie v√∂llig verwirrt sind und einen Hinweis ben√∂tigen, schauen Sie sich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fertige Projekt an</a> . <br><br><h3>  Hinweis zur Minimierung der √ºber das Netzwerk √ºbertragenen Daten </h3><br>  Die einfachste M√∂glichkeit, dies zu implementieren, besteht darin, die Positionen aller Spieler jedes Mal zu aktualisieren, wenn ein Bewegungsereignis von <em>einem</em> Spieler empfangen wird.  Es ist gro√üartig, wenn Spieler immer sofort nach dem Erscheinen die neuesten Informationen erhalten, aber die Anzahl der √ºber das Netzwerk √ºbertragenen Nachrichten kann leicht auf Hunderte pro Frame ansteigen.  Stellen Sie sich vor, Sie haben 10 Spieler, von denen jeder in jedem Frame eine Bewegungsnachricht sendet.  Der Server muss sie an alle 10 Spieler zur√ºckleiten.  Das sind schon 100 Nachrichten pro Frame! <br><br>  Es ist besser, dies zu tun: Warten Sie, bis der Server alle Nachrichten von allen Spielern empf√§ngt, und senden Sie dann allen Spielern ein umfangreiches Update mit allen Informationen.  Daher reduzieren wir die Anzahl der √ºbertragenen Nachrichten auf die Anzahl der im Spiel vorhandenen Benutzer (anstelle des Quadrats dieser Anzahl).  Das Problem hierbei ist, dass alle Benutzer die gleiche Verz√∂gerung wie der Player mit der langsamsten Verbindung haben. <br><br>  Eine andere L√∂sung besteht darin, die Serveraktualisierungen unabh√§ngig von der Anzahl der vom Player empfangenen Nachrichten mit einer konstanten H√§ufigkeit zu senden.  Ein g√§ngiger Standard ist die Aktualisierung des Servers ungef√§hr 30 Mal pro Sekunde. <br><br>  Bei der Auswahl der Serverstruktur sollten Sie jedoch die Anzahl der in jedem Frame √ºbertragenen Nachrichten in den fr√ºhen Phasen der Spieleentwicklung bewerten. <br><br><h2>  4. Shell-Synchronisation </h2><br>  Wir sind fast fertig!  Der letzte wichtige Teil ist die Synchronisierung √ºber ein Netzwerk von Shells.  Wir k√∂nnen es genauso implementieren wie synchronisierte Player: <br><br><ul><li>  Jeder Client sendet die Positionen aller seiner Shells in jedem Frame. </li><li>  Der Server leitet sie an jeden Spieler weiter. </li></ul><br>  Aber es gibt ein Problem. <br><br><h3>  Betrugsschutz </h3><br>  Wenn Sie alles, was der Client √ºbertr√§gt, als die wahren Positionen der Granaten umleiten, kann der Spieler leicht betr√ºgen, indem er seinen Client modifiziert und gef√§lschte Daten an Sie √ºbertr√§gt, z. B. Granaten, die sich zu den Positionen der Schiffe teleportieren.  Sie k√∂nnen dies einfach selbst √ºberpr√ºfen, indem Sie die Webseite herunterladen, den Code in JavaScript √§ndern und erneut √∂ffnen.  Und das ist nicht nur bei Browsergames ein Problem.  Im Allgemeinen k√∂nnen wir den vom Benutzer stammenden Daten niemals vertrauen. <br><br>  Um dieses Problem teilweise zu l√∂sen, werden wir versuchen, ein anderes Schema zu verwenden: <br><br><ul><li>  Der Client generiert eine Nachricht √ºber die Schussh√ºlle mit ihrer Position und Richtung. </li><li>  Der Server simuliert die Bewegung von Shells. </li><li>  Der Server aktualisiert die Daten jedes Clients und √ºbergibt die Position aller Shells. </li><li>  Clients rendern Shells an Positionen, die vom Server empfangen wurden. </li></ul><br>  Somit ist der Kunde f√ºr die Position des Projektils verantwortlich, jedoch nicht f√ºr seine Geschwindigkeit und nicht f√ºr seine weitere Bewegung.  Der Kunde kann die Position der Muscheln f√ºr sich selbst √§ndern, dies √§ndert jedoch nichts an dem, was andere Kunden sehen. <br><br>  Um ein solches Schema zu implementieren, f√ºgen wir beim Ausl√∂sen eine Nachrichtengenerierung hinzu.  Ich werde das Sprite nicht mehr selbst erstellen, da seine Existenz und sein Standort vollst√§ndig vom Server bestimmt werden.  Jetzt sieht unser neues Projektil in <strong>index.html folgenderma√üen</strong> aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){ var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20; var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20; /*    ,       ,       var bullet = {}; bullet.speed_x = speed_x; bullet.speed_y = speed_y; bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet'); bullet_array.push(bullet); */ this.shot = true; //  ,     socket.emit('shoot-bullet',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y}) }</span></span></code> </pre> <br>  Auch jetzt k√∂nnen wir das gesamte Codefragment auskommentieren und die Shells im Client aktualisieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,         //   for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.sprite.x += bullet.speed_x; bullet.sprite.y += bullet.speed_y; //  ,       if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){ bullet.sprite.destroy(); bullet_array.splice(i,1); i--; } } */</span></span></code> </pre> <br>  Schlie√ülich m√ºssen wir den Client dazu bringen, auf Shell-Updates zu warten.  Ich habe beschlossen, dies auf die gleiche Weise wie bei den Spielern zu implementieren, dh der Server sendet einfach ein Array aller Shell-Positionen in einem Ereignis namens <code>bullets-update</code> , und der Client erstellt oder zerst√∂rt Shells, um die Synchronisation aufrechtzuerhalten.  So sieht es aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     socket.on('bullets-update',function(server_bullet_array){ //     ,   for(var i=0;i&lt;server_bullet_array.length;i++){ if(bullet_array[i] == undefined){ bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet'); } else { //      ! bullet_array[i].x = server_bullet_array[i].x; bullet_array[i].y = server_bullet_array[i].y; } } //    ,   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){ bullet_array[i].destroy(); bullet_array.splice(i,1); i--; } })</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das ist alles, was im Client sein sollte. </font><font style="vertical-align: inherit;">Ich gehe davon aus, dass Sie bereits wissen, wo Sie diese Codefragmente einbetten und wie Sie alles zusammensetzen k√∂nnen. Wenn Sie jedoch Probleme haben, k√∂nnen Sie immer das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertige Ergebnis anzeigen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir in server.js Shells verfolgen und simulieren. </font><font style="vertical-align: inherit;">Zuerst erstellen wir ein Array zum Verfolgen von Muscheln, √§hnlich einem Array f√ºr Spieler:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bullet_array = []; <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als n√§chstes h√∂ren wir uns das Projektilschuss-Ereignis an: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   shoot-bullet        socket.on('shoot-bullet',function(data){ if(players[socket.id] == undefined) return; var new_bullet = data; data.owner_id = socket.id; //    id  bullet_array.push(new_bullet); });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt simulieren wir Muscheln 60 Mal pro Sekunde: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   60       function ServerGameLoop(){ for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.x += bullet.speed_x; bullet.y += bullet.speed_y; // ,       if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){ bullet_array.splice(i,1); i--; } } } setInterval(ServerGameLoop, 16);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und der letzte Schritt besteht darin, das Update-Ereignis irgendwo innerhalb dieser Funktion zu senden (aber definitiv au√üerhalb der for-Schleife): </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,    io.emit("bullets-update",bullet_array);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir endlich das Spiel testen! </font><font style="vertical-align: inherit;">Wenn alles richtig gelaufen ist, sollten Sie sicherstellen, dass die Shells auf allen Clients korrekt synchronisiert sind. </font><font style="vertical-align: inherit;">Die Tatsache, dass wir dies auf dem Server implementiert haben, zwang uns zu mehr Arbeit, aber es gab uns viel mehr Kontrolle. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise ein Ereignis erhalten, bei dem ein Projektil abgefeuert wird, k√∂nnen wir √ºberpr√ºfen, ob die Geschwindigkeit des Projektils innerhalb eines bestimmten Intervalls liegt. Wenn dies nicht der Fall ist, wissen wir, dass dieser Spieler betr√ºgt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Kollision mit Muscheln </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die letzte grundlegende Mechanik, die wir implementieren. </font><font style="vertical-align: inherit;">Ich hoffe, Sie sind bereits an das Verfahren zur Planung Ihrer Implementierung gew√∂hnt, indem Sie zuerst die Client-Implementierung vollst√§ndig abschlie√üen und dann auf den Server wechseln (oder umgekehrt). </font><font style="vertical-align: inherit;">Diese Methode ist viel weniger fehleranf√§llig als das Springen, wenn sie hin und her implementiert wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kollisionspr√ºfung ist eine wichtige Spielmechanik, daher m√∂chten wir, dass sie vor Betrug gesch√ºtzt wird. </font><font style="vertical-align: inherit;">Wir implementieren es auf dem Server genauso wie bei Shells. </font><font style="vertical-align: inherit;">Wir brauchen folgendes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfen Sie, ob das Projektil nahe genug an einem Spieler auf dem Server ist. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generieren Sie ein Ereignis f√ºr alle Kunden, wenn ein Projektil einen Spieler trifft. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bringen Sie dem Kunden bei, das Trefferereignis anzuh√∂ren und das Schiff bei einem Treffer blinken zu lassen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen versuchen, diesen Teil selbst zu implementieren. </font><font style="vertical-align: inherit;">Um das Schiff des Spielers bei einem Treffer flackern zu lassen, setzen Sie einfach seinen Alphakanal auf 0:</font></font><br><br><pre> <code class="javascript hljs">player.sprite.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es kehrt reibungslos zur vollen Deckkraft zur√ºck (dies erfolgt im Player-Update). </font><font style="vertical-align: inherit;">F√ºr andere Spieler ist die Aktion √§hnlich, aber Sie m√ºssen den Alphakanal in der Update-Funktion mit einem √§hnlichen Wert auf einen zur√ºcksetzen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> other_players){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other_players[id].alpha &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ other_players[id].alpha += (<span class="hljs-number"><span class="hljs-number">1</span></span> - other_players[id].alpha) * <span class="hljs-number"><span class="hljs-number">0.16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other_players[id].alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einzige schwierige Teil kann sein, zu √ºberpr√ºfen, ob der Spieler seine eigenen Granaten nicht trifft (andernfalls erleidet er bei jedem Schie√üen Schaden). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass in diesem Schema, selbst wenn der Client versucht zu betr√ºgen und sich weigert, die vom Server an ihn gesendete Treffermeldung zu akzeptieren, dies nur das √§ndert, was er auf seinem eigenen Bildschirm sieht. </font><font style="vertical-align: inherit;">Alle anderen Spieler werden weiterhin sehen, dass sie den Spieler getroffen haben.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Bewegungsgl√§ttung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie alle Schritte bis zu diesem Punkt abgeschlossen haben, kann ich Ihnen gratulieren. </font><font style="vertical-align: inherit;">Sie haben gerade ein funktionierendes Multiplayer-Spiel erstellt! </font><font style="vertical-align: inherit;">Senden Sie den Link an einen Freund und sehen Sie, wie die Magie des Online-Multiplayers Spieler zusammenbringen kann! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel ist voll funktionsf√§hig, aber unsere Arbeit endet nicht dort. </font><font style="vertical-align: inherit;">Es gibt einige Probleme, die sich negativ auf das Gameplay auswirken k√∂nnen, und wir m√ºssen uns mit ihnen befassen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn nicht jeder eine schnelle Verbindung hat, sieht die Bewegung der anderen Spieler sehr nerv√∂s aus. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muscheln scheinen langsam zu sein, weil sie nicht sofort abgefeuert werden. </font><font style="vertical-align: inherit;">Bevor sie auf dem Bildschirm des Clients angezeigt werden, warten sie auf eine R√ºckmeldung vom Server.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das erste Problem l√∂sen, indem wir unsere Schiffspositionsdaten im Client interpolieren. Wenn wir also nicht schnell genug Updates erhalten, k√∂nnen wir das Schiff reibungslos an den Ort bringen, an dem es sein sollte, und es nicht einfach dorthin teleportieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalen erfordern eine komplexere L√∂sung. Wir m√∂chten, dass der Server Granaten verarbeitet, um sich vor Betrug zu sch√ºtzen, aber wir brauchen auch eine sofortige Reaktion: einen Schuss und ein fliegendes Projektil. Die beste L√∂sung ist ein hybrider Ansatz. Sowohl der Server als auch der Client k√∂nnen Shells simulieren, und der Server sendet weiterhin Aktualisierungen an die Positionen der Shells. Wenn sie nicht synchron sind, gehen wir davon aus, dass der Server richtig ist, und definieren die Position des Projektils im Client neu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dieses Shell-System in diesem Tutorial nicht implementieren, aber es ist sch√∂n zu wissen, dass diese Methode existiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Durchf√ºhren einer einfachen Interpolation von Schiffspositionen ist sehr einfach. </font><font style="vertical-align: inherit;">Anstatt eine Position direkt im Aktualisierungsereignis festzulegen, wo wir zuerst neue Positionsdaten erhalten, speichern wir einfach die Zielposition:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     if(id != socket.id){ other_players[id].target_x = players_data[id].x; //  ,    ,     other_players[id].target_y = players_data[id].y; other_players[id].target_rotation = players_data[id].angle; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der Update-Funktion (auch auf der Client-Seite) umkreisen wir dann alle anderen Spieler und schieben sie in Richtung ihres Ziels: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      for(var id in other_players){ var p = other_players[id]; if(p.target_x != undefined){ px += (p.target_x - px) * 0.16; py += (p.target_y - py) * 0.16; //  ,    /  var angle = p.target_rotation; var dir = (angle - p.rotation) / (Math.PI * 2); dir -= Math.round(dir); dir = dir * Math.PI * 2; p.rotation += dir * 0.16; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somit sendet uns der Server 30 Mal pro Sekunde Updates, aber wir k√∂nnen immer noch mit 60 fps spielen und das Spiel sieht immer noch reibungslos aus! </font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben viele Probleme untersucht. Lassen Sie uns sie auflisten: Wir haben gelernt, wie Sie Nachrichten zwischen dem Client und dem Server √ºbertragen, den Status des Spiels synchronisieren und vom Server an alle Spieler senden. Dies ist der einfachste Weg, um ein Multiplayer-Online-Spiel zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben auch gelernt, wie man das Spiel vor Betrug sch√ºtzt, seine wichtigen Teile auf dem Server simuliert und Kunden √ºber die Ergebnisse informiert. Je weniger Sie dem Kunden vertrauen, desto sicherer wird das Spiel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich haben wir gelernt, wie Verz√∂gerungen mithilfe der Client-Interpolation √ºberwunden werden k√∂nnen. Die Kompensation von Verz√∂gerungen ist ein ernstes Thema und sehr wichtig (einige Spiele mit einer ausreichend gro√üen Verz√∂gerung werden einfach nicht mehr spielbar). Das Interpolieren w√§hrend des Wartens auf das n√§chste Update vom Server ist nur eine M√∂glichkeit, das Problem zu reduzieren. Ein anderer sagt die n√§chsten Frames im Voraus voraus und korrigiert sie, wenn echte Daten vom Server empfangen werden, aber dieser Ansatz kann nat√ºrlich sehr schwierig sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine v√∂llig andere M√∂glichkeit, die Auswirkungen von Verz√∂gerungen zu verringern, besteht darin, das Systemdesign dieses Problem umgehen zu lassen. </font><font style="vertical-align: inherit;">Der Vorteil langsamer Schiffsumdrehungen besteht darin, dass es sich um eine einzigartige Bewegungsmechanik handelt und dass pl√∂tzliche Bewegungs√§nderungen verhindert werden k√∂nnen. </font><font style="vertical-align: inherit;">Daher werden sie auch bei einer langsamen Verbindung das Gameplay nicht zerst√∂ren. </font><font style="vertical-align: inherit;">Es ist sehr wichtig, die Verz√∂gerung bei der Entwicklung der Grundelemente des Spiels zu ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Manchmal sind die besten Entscheidungen √ºberhaupt keine technischen Tricks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen eine weitere n√ºtzliche Glitch-Funktion verwenden, die darin besteht, dass Sie Ihr eigenes Projekt √ºber die erweiterten Optionen in der oberen linken Ecke herunterladen oder exportieren k√∂nnen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/d6b/dba/c62d6bdba51311a7a0d8976c37dbe6fb.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418411/">https://habr.com/ru/post/de418411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418399/index.html">Auf der Welle von Selectel FM</a></li>
<li><a href="../de418401/index.html">Wie ich nicht zu dir geworden bin: ein Beitrag der Liebe zu Systemadministratoren</a></li>
<li><a href="../de418403/index.html">Beispiel f√ºr die Programmierung eines FPGA-Beschleunigers</a></li>
<li><a href="../de418405/index.html">Das Prinzip der umgekehrten Pyramide in der Analytik. Wir erstellen ein verst√§ndliches Dashboard</a></li>
<li><a href="../de418407/index.html">Hashflare Cloud Mining wurde geschlossen. Geld kehrt nicht zur√ºck</a></li>
<li><a href="../de418415/index.html">Telegram f√ºhrte einen eigenen Passport-Dienst zur √úberpr√ºfung und Autorisierung von Benutzern ein</a></li>
<li><a href="../de418417/index.html">Apollo: 9 Monate - normaler Flug</a></li>
<li><a href="../de418419/index.html">Wie Dodo Pizza gesch√§ftliche Probleme mithilfe von maschinellem Lernen l√∂st</a></li>
<li><a href="../de418423/index.html">Smart Home: Eine neue Dimension des Komforts und das Streben nach Spitzenleistungen. Teil eins</a></li>
<li><a href="../de418427/index.html">Mobile-First-Indizierung. Wie und warum √§ndert sich das Linkdiagramm?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>