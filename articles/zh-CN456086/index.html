<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏑 🥡 🕤 iOS故事板：优缺点分析，最佳做法 🙍🏽 🚵🏽 🏕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="苹果创建了Storyboard，以便开发人员可以可视化iOS应用程序的屏幕及其之间的关系。 并非每个人都喜欢此工具，这是有充分理由的。 我见过许多批评Storyboard的文章，但我没有考虑到最佳实践，对所有优点和缺点进行详尽而公正的分析。 最后，我决定自己写一篇这样的文章。 

 我将尝试详细分析...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS故事板：优缺点分析，最佳做法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/456086/"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br> 苹果创建了Storyboard，以便开发人员可以可视化iOS应用程序的屏幕及其之间的关系。 并非每个人都喜欢此工具，这是有充分理由的。 我见过许多批评Storyboard的文章，但我没有考虑到最佳实践，对所有优点和缺点进行详尽而公正的分析。 最后，我决定自己写一篇这样的文章。 <br><a name="habracut"></a><br> 我将尝试详细分析使用情节提要的缺点和优势。 在权衡它们之后，您可以做出有意义的决定，以确定项目中是否需要它们。 这个决定不必太激进。 如果在某些情况下情节提要板产生问题，在其他情况下则应说明情节提要的使用：它有助于有效地解决任务并编写简单，易于维护的代码。 <br><br> 让我们从缺点开始，分析所有缺点是否仍然相关。 <br><br><h2> 缺点 </h2><br><h3>  1.合并更改时，情节提要板很难管理冲突 </h3><br> 故事板是一个XML文件。 它比代码可读性差，因此解决其中的冲突更加困难。 但是这种复杂性还取决于我们如何使用情节提要。 如果遵循以下规则，则可以大大简化您的任务： <br><br><ul><li>不要将整个UI放在一个Storyboard中，而是将其分成几个较小的Storyboard。 这将使在Storyboard上的开发人员之间分配工作没有冲突的风险，并且在不可避免的情况下-将简化解决它们的任务。 <br></li><li> 如果需要在多个地方使用同一View，请在具有其自己的Xib文件的单独子类中选择它。 <br></li><li> 进行提交的频率更高，因为处理零散的更改要容易得多。 <br></li></ul><br> 使用多个情节提要板而不是一个，使我们无法在一个文件中查看应用程序的整个地图。 但这通常不是必需的-仅此刻我们正在研究的特定部分就足够了。 <br><br><h3>  2.故事板可防止代码重用 </h3><br> 如果我们谈论的是在项目中仅使用没有Xib的情节提要，那么肯定会出现问题。 但是，我认为Xib是使用Storyboard时的必要元素。 多亏了他们，您可以轻松创建可重用的视图，这些视图在代码中也很方便使用。 <br><br> 首先，创建<code>XibView</code>基类，该基类负责在Storyboard中渲染在<code>UIView</code>创建的<code>UIView</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code>将把<code>XibView</code>的<code>UIView</code>加载到<code>contentView</code> ，并将其添加为其子视图。 我们在<code>setup()</code>方法中执行此操作： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  <code>loadViewFromNib()</code>方法如下所示： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  <code>setup()</code>方法应在初始化程序中调用： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  <code>XibView</code>类<code>XibView</code>准备就绪。 外观在<code>XibView</code>文件中呈现的已重用视图将继承自<code>XibView</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br> 如果现在将新的<code>UIView</code>添加到Storyboard并将其类设置为<code>RedView</code> ，那么一切将成功显示： <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br> 用代码创建<code>RedView</code>实例的方式通常是这样的： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br> 并非所有人都知道的另一个有用的细节是能够将颜色添加到<b>.xcassets</b>目录中。 这使您可以在使用它们的所有情节提要和Xib中进行全局更改。 <br><br> 要添加颜色，请单击左下方的“ +”，然后选择“新颜色集”： <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br> 指定所需的名称和颜色： <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br> 创建的颜色将出现在“命名的颜色”部分中： <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br> 另外，它可以在代码中获得： <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3.您不能对在Storyboard中创建的<code>UIViewControllers</code>使用自定义初始化程序 </h3><br> 对于情节提要，我们无法在<code>UIViewControllers</code>的初始化程序中传递依赖项。 通常看起来像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br> 使用某种常量来表示标识符或诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SwiftGen</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R.swift之</a>类的工具甚至是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Perform</a>可以更好地完成此代码。 但是通过这种方式，我们仅摆脱了字符串文字并添加了语法糖，并且无法解决出现的问题： <br><br><ul><li> 我如何知道上例中的<code>DetailViewController</code>如何配置的？ 如果您不熟悉该项目，并且不具备此知识，则必须打开一个包含该控制器说明的文件并进行研究。 <br></li><li> 在初始化后设置<code>DetailViewController</code>属性，这意味着它们必须是可选的。 有必要处理任何属性为<code>nil</code> ，否则应用程序可能在最不适当的时刻崩溃。 您可以将属性标记为隐式扩展的可选（ <code>var object: Object!</code> ），但是本质不会改变。 <br></li><li> 属性必须标记为<code>var</code> ，而不是<code>let</code> 。 因此，当外部有人想要更改它们时，可能会出现这种情况。  <code>DetailViewController</code>应该处理这种情况。 <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>介绍了一种解决方案。 <br><br><h3>  4.随着情节提要的增长，在其中进行导航变得更加困难 </h3><br> 如前所述，您无需将所有内容都放在一个Storyboard中，最好将其分解为几个较小的内容。 随着<b>情节提要参考</b>的出现<b>，</b>它变得非常简单。 <br> 将故事板引用从对象库添加到故事板： <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br> 我们在“ <b>属性”检查器中</b>设置了必填字段值-这是情节提要板文件的名称，如有必要，还指定了“ <b>参考ID”</b> ，该<b>ID与</b>所需屏幕的<b>情节提要ID</b>相对应。 默认情况下， <b>初始视图控制器</b>将加载： <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br> 如果您在“情节提要”字段中指定了无效的名称或引用了不存在的情节提要ID，则Xcode将在编译阶段就此警告您。 <br><br><h3>  5.加载情节提要时Xcode变慢 </h3><br> 如果情节提要板包含大量具有众多约束的屏幕，则加载它确实需要一些时间。 但是话又说回来，最好将大型Storyboard分成较小的Storyboard。 另外，它们加载得更快，并且使用它们变得更加方便。 <br><br><h3>  6.故事板很脆弱，错误可能导致应用程序在运行时崩溃 </h3><br> 主要弱点： <br><br><ul><li>  <code>UITableViewCell</code>和<code>UICollectionViewCell</code>错误。 <br></li><li>  segues标识符中的错误。 <br></li><li> 使用不再存在的<code>UIView</code>子类。 <br></li><li>  <code>IBActions</code>和<code>IBOutlets</code>与代码的同步。 <br></li></ul><br> 所有这些以及其他一些问题可能导致应用程序在运行时崩溃，这意味着此类错误很可能会落入发行版中。 例如，当我们在情节提要中设置单元格标识符或segue时，无论使用什么位置，都应将它们复制到代码中。 通过在一个位置更改标识符，必须在其余所有位置都更改它。 您可能会简单地忘记它或输入错误，但仅在应用程序运行时了解错误。 <br><br> 您可以通过消除代码中的字符串文字来减少错误的可能性。 为此，可以为<code>UITableViewCell</code>和<code>UICollectionViewCell</code>分配单元格类本身的名称：例如， <code>ItemTableViewCell</code>标识符将为字符串“ ItemTableViewCell”。 在代码中，我们得到这样的单元格： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br> 您可以将相应的泛型函数添加到<code>UITableView</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br> 然后变得更容易获得该单元格： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br> 如果您突然忘记在情节提要中指定单元格标识符的值，则Xcode将显示警告，因此您不应忽略它们。 <br><br> 至于segues标识符，您可以为它们使用枚举。 让我们创建一个特殊的协议： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br> 支持该协议的<code>UIViewController</code>将需要定义一个具有相同名称的嵌套类型。 它列出了此<code>UIViewController</code>可以处理的所有segues标识符： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br> 另外，在<code>SegueHandler</code>协议扩展中， <code>SegueHandler</code>定义了两个函数：一个接受<code>UIStoryboardSegue</code>并返回相应的<code>SegueIdentifier</code>值，另一个<code>SegueIdentifier</code>输入简单地调用<code>performSegue</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br> 现在，在支持新协议的<code>UIViewController</code>中，您可以按以下方式使用<code>prepare(for:sender:)</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br> 并像这样运行segue： <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br> 如果您向<code>SegueIdentifier</code>添加新的标识符，则Xcode肯定会强制它在<code>switch/case</code>进行处理。 <br><br> 摆脱字符串文字（如标识符segues等）的另一种选择是使用代码生成工具（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R.swift）</a> 。 <br><br><h3>  7.故事板的灵活性不及代码。 </h3><br> 是的，这是真的。 如果任务是创建一个包含情节提要无法处理的动画和效果的复杂屏幕，那么您需要使用代码！ <br><br><h3>  8.情节提要不允许更改特殊的<code>UIViewControllers</code>的类型 </h3><br> 例如，当您需要将<code>UITableViewController</code>的类型更改为<code>UICollectionViewController</code> ，您必须删除该对象，添加具有另一种类型的新对象，然后重新配置它。 尽管这种情况并不常见，但值得注意的是，这些更改在代码中的执行速度更快。 <br><br><h3>  9.情节提要向项目添加了两个附加依赖项。 它们可能包含开发人员无法修复的错误。 </h3><br> 这是Interface Builder和Storyboards解析器。 这种情况很少见，通常可以通过其他解决方案来规避。 <br><br><h3>  10.复杂的代码审查 </h3><br> 请记住，代码审查并不是真正的错误搜索。 是的，它们是在查看代码的过程中发现的，但主要目标是确定从长远来看可能造成问题的弱点。 对于情节提要，这主要是<b>Auto Layout</b>的工作。 不应有任何<b>歧义</b>和<b>错位</b> 。 要找到它们，只需在情节提要XML中对“模糊=“是””和“放错位置=“是””行进行搜索，或者仅在Interface Builder中打开情节提要并查找红色和黄色的点： <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br> 但是，这可能还不够。 在应用程序运行时，也可以检测到约束之间的冲突。 如果发生类似情况，则控制台中会显示有关此信息。 这种情况并不少见，因此，也应认真对待它们。 <br><br> 其他所有内容（将元素的位置和大小与设计相匹配， <code>IBOutlets</code>和<code>IBActions</code>的正确绑定）均不用于代码审查。 <br><br> 另外，重要的是要更频繁地进行提交，这样审阅者就可以更轻松地查看小更改。 他将能够更好地研究细节而不会遗漏任何东西。 反过来，这将对代码审查的质量产生积极影响。 <br><br><h3> 总结 </h3><br> 在“情节提要”缺陷列表中，我留下了4个项目（按其值的降序排列）： <br><br><ol><li> 合并更改时，情节提要板很难管理冲突。 <br></li><li> 故事板的灵活性不及代码。 <br></li><li> 故事板非常脆弱，错误可能导致运行时崩溃。 <br></li><li> 您不能对在Storyboard中创建的<code>UIViewControllers</code>使用自定义初始化程序。 <br></li></ol><br><h2> 好处 </h2><br><h3>  1.可视化的用户界面和约束 </h3><br> 即使您是初学者，并且刚刚开始一个陌生的项目，也可以轻松找到该应用程序的入口点以及如何从中进入所需的屏幕。 您知道每个按钮，标签或文本字段的外观，它们将处于什么位置，约束如何影响它们，它们如何与其他元素交互。 只需单击几下，您就可以轻松创建新的<code>UIView</code> ，自定义其外观和行为。 自动布局使我们可以自然地使用<code>UIView</code> ，就像我们说的那样：“此按钮应该在该标签的左侧，并且具有相同的高度。” 这种用户界面体验是直观而有效的。 您可以尝试举一些示例，在这些示例中，编写良好的代码可以在创建某些UI元素时节省更多时间，但在全局范围内并不会改变太多。 情节提要很好地工作。 <br><br> 另外，请注意自动版式。 这是一个非常强大且有用的工具，如果没有它，将很难创建一个支持所有不同屏幕尺寸的应用程序。  Interface Builder使您无需启动应用程序即可查看使用Auto Layout的结果，并且如果某些约束不适合常规方案，Xcode会立即警告您。 当然，在某些情况下，Interface Builder无法提供某些非常动态和复杂的接口的必要行为，那么您就必须依靠代码。 但是即使在这种情况下，您也可以在Interface Builder中完成大部分操作，并仅用几行代码对其进行补充。 <br><br> 让我们看一些示例，这些示例演示Interface Builder的有用功能。 <br><br><h4> 基于<code>UIStackView</code>动态表 </h4><br> 创建一个新的<code>UIViewController</code> ，全屏添加一个<code>UIScrollView</code> ： <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br> 在<code>UIScrollView</code>添加垂直<code>UIStackView</code> ，将其捕捉到边缘并将高度和宽度设置为与<code>UIScrollView</code>相等。 在此高度下，分配<b>优先级=低（250）</b> ： <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br> 接下来，创建所有必需的单元格并将它们添加到<code>UIStackView</code> 。 我们可能会在一个副本中使用普通的<code>UIView</code> ，或者可能是<code>UIView</code> ，为此我们创建了自己的Xib文件。 无论如何，该屏幕的整个UI都位于情节提要中，并且由于正确配置了自动版式，滚动可以完美地进行，以适应内容： <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br> 我们还可以使单元格适应其内容的大小。 将<code>UILabel</code>添加到每个单元格，将它们绑定到边缘： <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br> 现在已经清楚了如何在运行时查看这些内容。 您可以将任何操作附加到单元格，例如，切换到另一个屏幕。 而所有这些都不需要一行代码。 <br> 此外，如果为<code>UIStackView</code>的<code>UIView</code>设置<code>hidden = true</code> ，则它不仅会隐藏，而且不会占用空间。  <code>UIStackView</code>将自动重新计算其大小： <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4> 自定格单元 </h4><br> 在表的“ <b>大小”检查器中</b> ，将“ <b>行高度=自动”</b>设置为“平均值”，并将其设置为某个平均值： <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br> 为此，必须在单元格本身中正确配置约束，并允许基于运行时的内容准确计算单元格高度。 如果不清楚有什么危险， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档中</a>有很好的解释。 <br><br> 结果，启动应用程序，我们将看到一切正确显示： <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4> 自动上浆桌 </h4><br> 您需要实现此表的行为： <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br> 如何实现类似的高度动态变化？ 与<code>UILabel</code> ， <code>UIButton</code>和<code>UIView</code>其他子类不同，使用表要难一些，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内在内容大小</a>并不取决于表中单元格的大小。 她无法根据内容计算身高，但是有机会帮助她。 <br><br> 请注意，在视频中的某个位置，桌子的高度停止变化，达到某个最大值。 这可以通过将表<b>高度约束</b>设置为值<b>Relation =小于或等于来实现</b> ： <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br> 在此阶段，Interface Builder尚不知道桌子的高度，他只知道其最大值等于200（根据高度限制）。 如前所述，“内在内容大小”不等于表的内容。 但是，我们可以在“ <b>本征大小”</b>字段中设置占位符： <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br> 该值仅在使用Interface Builder时有效。 当然，运行时内在内容大小不必等于此值。 我们只是告诉Interface Builder，一切都在控制之中。 <br><br> 接下来，创建<code>CustomTableView</code>表的新子类： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br> 需要代码的情况之一。 每当表的<code>contentSize</code>更改时，我们就在这里调用<code>invalidateIntrinsicContentSize</code> 。 这将允许系统接受新的“内在内容大小”。 反过来，它返回<code>contentSize</code> ，迫使表动态调整其高度并显示一定数量的单元格而无需滚动。 当我们达到高度限制限制时，就会出现滚动。 <br><br> 所有这三个Interface Builder功能都可以相互组合。 它们为内容组织选项增加了更多灵活性，而无需其他约束或任何<code>UIView</code> 。 <br><br><h3>  2.能够立即看到他们行动的结果 </h3><br> 如果您调整<code>UIView</code>大小，将其移动到侧面两个点或更改背景颜色，您将立即看到它在运行时的外观，而无需启动应用程序。 不必怀疑为什么某些按钮没有出现在屏幕上，或者为什么<code>UIView</code>的行为不是所期望的。 <br><br> 使用<code>@IBInspectable</code>会更有趣地揭示此好处。 在<code>RedView</code>添加两个<code>UILabel</code>和两个属性： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  <code>RedView</code>的<b>属性检查器</b>中将出现两个新字段- <code>Title</code>和<code>Subtitle</code> ，我们将其标记为<code>@IBInspectable</code> ： <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br> 如果尝试在这些字段中输入值，我们将立即看到一切在运行时的外观： <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br> 您可以控制任何东西： <code>cornerRadius</code> ， <code>borderWidth</code> ， <code>borderColor</code> 。 例如，我们扩展了基类<code>UIView</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br> 我们看到<code>RedView</code>对象的Attributes Inspector获得了另外4个新字段，您现在也可以使用它们： <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3.一次预览所有屏幕尺寸 </h3><br> 因此，我们在屏幕上放置了必要的元素，调整了它们的外观并添加了必要的约束。 我们如何确定内容是否可以正确显示在不同的屏幕尺寸上？ 当然，您可以在每个模拟器上运行该应用程序，但这会花费很多时间。 有一个更好的选择：Xcode具有预览模式，它使您无需启动应用程序即可一次查看多个屏幕尺寸。 <br><br> 我们调用<b>助手编辑器</b> ，在其中单击过渡栏的第一段，选择“ <b>预览”-&gt;“ Settings.storyboard”</b> （作为示例）： <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br> 最初，我们只看到一个屏幕，但是我们可以通过单击左下角的“ +”并从列表中选择必要的设备来添加所需的内容： <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br> 此外，如果情节提要板支持多种语言，则可以看到所选屏幕在每种语言下的外观： <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br> 可以一次为所有屏幕选择语言，也可以分别为每个屏幕选择语言。 <br><br><h3>  4.删除模板UI代码 </h3><br> 在不使用Interface Builder的情况下创建用户界面时，会伴随大量的样板代码或需要额外维护工作的超类和扩展。 此代码可以渗透到应用程序的其他部分，从而使其难以阅读和搜索。 使用情节提要和Xibs可以减轻代码负担，使其更加专注于逻辑。 <br><br><h3>  5.尺寸等级 </h3><br> 每年都会出现新设备，您需要为其调整用户界面。  <b>特质变化</b> （尤其是<b>大小类）</b>的概念对此有所帮助，它允许您为屏幕的任何大小和方向创建UI。 <br><br> 尺寸类别将设备屏幕的高度（h）和宽度（w）按照<b>紧凑</b>和<b>常规</b> （ <b>C</b>和<b>R</b> ）分类。 例如，iPhone 8的纵向尺寸级别为<b>（wC hR）</b> ，横向的尺寸级别为<b>（wC</b> <b>hC）</b> ，而iPhone 8 Plus的尺寸级别分别为<b>（wC hR）</b>和<b>（wR hC）</b> 。 其余的设备可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每种大小级别的一个Storyboard或Xib中，您可以存储自己的数据集，应用程序将在运行时根据设备和屏幕方向使用适当的数据集，从而标识当前的大小级别。</font><font style="vertical-align: inherit;">如果某些布局参数对于所有尺寸类别均相同，则可以在“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">类别</font><font style="vertical-align: inherit;">（默认情况下已选择）中</font><font style="vertical-align: inherit;">对其进行配置</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，根据大小类别配置字体大小。</font><font style="vertical-align: inherit;">我们选择iPhone 8 Plus设备以纵向显示在Storyboard中，并为</font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font><font style="vertical-align: inherit;">条件添加新条件</font><font style="vertical-align: inherit;">：如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">width为Regular</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（将其余设置为“ Any”），则字体大小应为37：</font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，如果我们更改屏幕方向，则字体大小将增加-一种新的条件将起作用，因为iPhone 8 Plus在横向方向上具有大小级别</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（wR hC）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在情节提要中，根据大小类，您还可以隐藏视图，启用/禁用约束，更改其值</font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读有关如何执行所有操作的更多信息</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上面的屏幕截图中，值得注意的是底部面板选择了显示布局的设备。它使您可以快速检查UI在任何设备上以及在任何屏幕方向上的适应性，还可以显示当前配置的大小类别（在设备名称旁边）。除其他事项外，在右侧有一个按钮« </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变化为特质</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”。</font><font style="vertical-align: inherit;">其目的是仅同时对宽度，高度或宽度和高度的特定类别启用特征变化。</font><font style="vertical-align: inherit;">例如，选择具有大小等级</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（wR hR）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的iPad </font><font style="vertical-align: inherit;">，单击“因性状而异”，然后选中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">width</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">height</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旁边的框</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，所有后续布局更改将仅适用于具有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（wR hR）的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设备，</font><font style="vertical-align: inherit;">直到我们单击</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“完成变化”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2> 结论 </h2><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ＃ </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 缺点 </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 好处 </font></font><br></th></tr><tr><td>  1个 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 难以处理的冲突 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI可视化和约束 </font></font><br></td></tr><tr><td>  2 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不如代码灵活 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 即时查看您的操作结果的能力 </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 错误可能导致运行时崩溃。 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一次预览所有屏幕尺寸 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您不能使用自定义初始化程序来 </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 删除模板UI代码 </font></font><br></td></tr><tr><td>  5 <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 尺寸等级 </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看到情节提要有其优点和缺点。</font><font style="vertical-align: inherit;">我认为您不应该完全拒绝使用它们。</font><font style="vertical-align: inherit;">如果使用正确，它们将带来巨大的好处，并有助于有效地解决任务。</font><font style="vertical-align: inherit;">您只需要学习如何确定优先级并忘记诸如“我不喜欢情节提要”或“我已经习惯这样做”之类的论点。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456086/">https://habr.com/ru/post/zh-CN456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456072/index.html">Dav1d-默认情况下，Firefox中最快的AV1解码器</a></li>
<li><a href="../zh-CN456076/index.html">PyDaCon在Mail.ru集团的聚会：6月22日</a></li>
<li><a href="../zh-CN456078/index.html">公司对网络连接的冲突的预测</a></li>
<li><a href="../zh-CN456082/index.html">我们如何制定个性化产品推荐</a></li>
<li><a href="../zh-CN456084/index.html">Kubernetes 1.15：亮点概述</a></li>
<li><a href="../zh-CN456088/index.html">大数据分析问题</a></li>
<li><a href="../zh-CN456090/index.html">Unity中的单元测试简介</a></li>
<li><a href="../zh-CN456092/index.html">七个令人不安的迹象表明您依赖天气，即使您不这样认为</a></li>
<li><a href="../zh-CN456094/index.html">我们阅读了数据手册2：STM32上的SPI; STM8上的PWM定时器和中断</a></li>
<li><a href="../zh-CN456096/index.html">极客时间平均读者在云中徘徊时的行为</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>