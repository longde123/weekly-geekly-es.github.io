<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍇 ⛸️ 👇🏼 使用PVS-Studio分析CUBA平台的代码 🛠️ 🕤 💨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java开发人员可以使用许多有用的工具来帮助编写高质量的代码，例如功能强大的IDE IntelliJ IDEA，免费的分析器SpotBugs，PMD等。 在CUBA平台上工作的开发人员已经在使用所有这些工具，本次审查将展示该项目如何从静态代码分析器PVS-Studio的使用中进一步受益。 

 关于...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio分析CUBA平台的代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449020/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89f/a3b/650/89fa3b6506fd8962c8996579f4dcc460.png"></div><br>  Java开发人员可以使用许多有用的工具来帮助编写高质量的代码，例如功能强大的IDE IntelliJ IDEA，免费的分析器SpotBugs，PMD等。 在CUBA平台上工作的开发人员已经在使用所有这些工具，本次审查将展示该项目如何从静态代码分析器PVS-Studio的使用中进一步受益。 <br><a name="habracut"></a><br><h2> 关于项目和分析器的几句话 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA平台</a>是用于企业应用程序开发的高级框架。 该平台使开发人员从基础技术中抽象出来，使他们可以专注于业务任务，同时通过提供对低级代码的无限制访问来保留完全的灵活性。 源代码是从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>下载的。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>是一种工具，用于检测用C，C ++，C＃和Java编写的程序的源代码中的错误和潜在的安全漏洞。 该分析仪可在64位Windows，Linux和macOS系统上运行。 为了使Java程序员更轻松，我们为Maven，Gradle和IntelliJ IDEA开发了插件。 我使用Gradle插件检查了该项目，结果一切顺利。 <br><br><h2> 条件错误 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'StringUtils.isNotEmpty（“ handleTabKey”）'始终为true。  SourceCodeEditorLoader.java（60） <br><br><pre><code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... String handleTabKey = element.attributeValue(<span class="hljs-string"><span class="hljs-string">"handleTabKey"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringUtils.isNotEmpty(<span class="hljs-string"><span class="hljs-string">"handleTabKey"</span></span>)) { resultComponent.setHandleTabKey(Boolean.parseBoolean(handleTabKey)); } .... }</code> </pre> <br> 不检查从元素提取的属性值。 相反， <i>isNotEmpty</i>函数获取字符串文字作为其参数，而不是变量<i>handleTabKey</i> 。 <br><br> 在文件AbstractTableLoader.java中发现类似的错误： <br><br><ul><li>  V6007表达式'StringUtils.isNotEmpty（“ editable”）'始终为true。  AbstractTableLoader.java（596） </li></ul><br>  <b>警告2</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'previousMenuItemFlatIndex&gt; = 0'始终为true。  CubaSideMenuWidget.java（328） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> menuItemWidgets.get(previousMenuItemFlatIndex); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br> 如果在列表中找不到元素，则<i>indexOf</i>函数将返回<i>-1</i> 。 然后将值<i>1</i>添加到索引中，从而掩盖了元素缺失的问题。 另一个潜在的问题与上一个<i>MenuItemFlatIndex</i>变量将始终大于或等于零有关。 例如，如果发现<i>menuItemWidgets</i>列表为空，则该程序将以数组溢出结束。 <br><br>  <b>警告3</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6009</a> “删除”功能可以接收“ -1”值，而预期为非负值。 检查参数：1. AbstractCollectionDatasource.java（556） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> DataLoadContextQuery </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDataQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... StringBuilder orderBy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (orderBy.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { orderBy.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(orderBy.length() - <span class="hljs-number"><span class="hljs-number">2</span></span>, orderBy.length()); orderBy.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">" order by "</span></span>); } .... }</code> </pre> <br> 如果元素总数大于零（即，字符串包含至少一个字符），则删除<i>orderBy</i>缓冲区的最后两个字符。 但是，删除开始的起始位置偏移了2。因此，如果<i>orderBy</i>碰巧包含一个字符，则尝试删除它会引发<i>StringIndexOutOfBoundsException</i> 。 <br><br>  <b>警告4</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6013</a>通过引用比较了对象“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">masterCollection</a> ”和“实体”。 可能希望进行平等比较。  CollectionPropertyContainerImpl.java（81） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Collection&lt;E&gt; entities)</span></span></span><span class="hljs-function"> </span></span>{ super.setItems(entities); Entity masterItem = master.getItemOrNull(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (masterItem != null) { MetaProperty masterProperty = getMasterProperty(); Collection masterCollection = masterItem.getValue(masterProperty.getName()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (masterCollection != entities) { updateMasterCollection(masterProperty, masterCollection, entities); } } }</code> </pre> <br> 在<i>updateMasterCollection</i>函数中，来自<i>实体</i>的值被复制到<i>masterCollection</i> 。 前面一行，已经通过引用比较了集合，但是程序员可能希望将其作为按值比较。 <br><br>  <b>警告5</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6013</a>通过引用比较对象“值”和“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">旧</a>值”。 可能希望进行平等比较。  WebOptionsList.java（278） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCollectionValuesChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;I&gt; value, Collection&lt;I&gt; oldValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value != oldValue; }</code> </pre> <br> 这种情况类似于前一种情况。 在<i>isCollectionValuesChanged</i>函数中对集合进行比较，引用比较可能也不是这里想要的。 <br><br><h2> 冗余条件 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'mask.charAt（i + offset）！= PlaceHolder'始终为true。  DatePickerDocument.java（238） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateFormattedString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, String text)</span></span></span><span class="hljs-function"> .... </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mask.charAt(i + offset) == placeHolder)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } else if ((mask.charAt(i + offset) != placeHolder) &amp;&amp; // &lt;= (Character.isDigit(text.charAt(i)))) { .... } .... }</span></span></code> </pre> <br> 第二个条件检查与第一个条件中检查的表达式相反的表达式。 因此，可以安全地删除后者以缩短代码。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'connector == null'始终为false。  HTML5Support.java（169） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NativeEvent event)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (connector == null) { widget = widget.getParent(); connector = Util.findConnectorFor(widget); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connector == connector) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connector == null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } else if (connector.getWidget() instanceof VDDHasDropHandler) { return false; } return true; }</span></span></code> </pre> <br> 退出<i>while</i>循环后， <i>连接器</i>变量的值将不等于<i>null</i> ，因此可以删除冗余检查。 <br><br> 需要检查的另一种此类可疑警告： <br><br><ul><li>  V6007表达式'StringUtils.isBlank（strValue）'始终为true。  Param.java（818） </li></ul><br><h2> 测试中无法访问的代码 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6019</a>检测<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不到</a>代码。 可能存在错误。  TransactionTest.java（283） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(TEST_EXCEPTION_MSG); } @<span class="hljs-function"><span class="hljs-function">Test </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuspendRollback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Transaction tx = cont.persistence().createTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... Transaction tx1 = cont.persistence().createTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { EntityManager em1 = cont.persistence().getEntityManager(); assertTrue(em != em1); Server server1 = em1.find(Server.class, server.getId()); assertNull(server1); throwException(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= tx1.commit(); // &lt;= } catch (Exception e) { // } finally { tx1.end(); } tx.commit(); } finally { tx.end(); } }</span></span></code> </pre> <br>  <i>throwException</i>函数引发一个异常，该异常阻止执行<i>tx1.commit</i>的调用。 应当交换这两行以使代码正常工作。 <br><br> 其他测试也有一些类似的问题： <br><br><ul><li>  V6019检测不到代码。 可能存在错误。  TransactionTest.java（218） </li><li>  V6019检测不到代码。 可能存在错误。  TransactionTest.java（163） </li><li>  V6019检测不到代码。 可能存在错误。  TransactionTest.java（203） </li><li>  V6019检测不到代码。 可能存在错误。  TransactionTest.java（137） </li><li>  V6019检测不到代码。 可能存在错误。  UpdateDetachedTest.java（153） </li><li>  V6019检测不到代码。 可能存在错误。  EclipseLinkDetachedTest.java（132） </li><li>  V6019检测不到代码。 可能存在错误。  PersistenceTest.java（223） </li></ul><br><h2> 可疑论点 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6023</a>参数“ salt”在使用前总是在方法体内被重写。  BCryptEncryptionModule.java（47） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String content, String salt)</span></span></span><span class="hljs-function"> </span></span>{ salt = BCrypt.gensalt(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BCrypt.hashpw(content, salt); }</code> </pre> <br> 在密码术中， <i>salt</i>是一个数据字符串，您将其与密码一起传递给哈希函数。 它主要用于保护程序免受字典攻击和彩虹表攻击，以及掩盖相同的密码。 更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Salt（密码学）</a> 。 <br><br> 在此函数中，输入后立即将传递的字符串覆盖。 忽略传递给函数的值是潜在的漏洞。 <br><br>  <b>警告2</b> <br><br> 此功能立即触发两个警告： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6023</a>参数'offsetWidth'始终在使用前在方法主体中重写。  CubaSuggestionFieldWidget.java（433） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6023</a>参数'offsetHeight'总是在使用前在方法主体中重写。  CubaSuggestionFieldWidget.java（433） </li></ul><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offsetWidth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offsetHeight)</span></span></span><span class="hljs-function"> </span></span>{ offsetHeight = getOffsetHeight(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offsetHeight + getPopupTop() &gt; ....)) { .... } .... offsetWidth = containerFirstChild.getOffsetWidth(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offsetWidth + getPopupLeft() &gt; ....)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { left = getPopupLeft(); } setPopupPosition(left, top); }</code> </pre> <br> 那是一个很好奇的片段。 仅使用两个变量作为参数调用该函数<i>offsetWidth</i>和<i>offsetHeight</i> ，并且在使用前都将其覆盖。 <br><br>  <b>警告3</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6022</a>构造函数体内未使用参数“快捷方式”。  DeclarativeTrackingAction.java（47） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeclarativeTrackingAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, String caption, String description, String icon, String enable, String visible, String methodName, @Nullable String shortcut, ActionsHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ super(id); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.caption = caption; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.description = description; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.icon = icon; setEnabled(enable == null || Boolean.parseBoolean(enable)); setVisible(visible == null || Boolean.parseBoolean(visible)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.methodName = methodName; checkActionsHolder(holder); }</code> </pre> <br> 该函数不使用作为<i>快捷方式</i>参数传递的值。 函数的界面可能已过时，或者此警告只是误报。 <br><br> 这种类型的一些缺陷： <br><br><ul><li>  V6022构造函数体内未使用参数'type'。  QueryNode.java（36） </li><li>  V6022构造函数体内未使用参数'text2'。  MarkerAddition.java（22） </li><li>  V6022构造函数体内未使用参数“选择”。  AceEditor.java（114） </li><li>  V6022参数'options'不在构造函数体内使用。  EntitySerialization.java（379） </li></ul><br><h2> 功能不同，代码相同 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6032</a>方法'firstItemId'的主体完全等效于另一个方法'lastItemId'的主体，这很奇怪。  ContainerTableItems.java（213），ContainerTableItems.java（219） <br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;E&gt; items = container.getItems(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.isEmpty() ? null : items.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getId(); } @<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;E&gt; items = container.getItems(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.isEmpty() ? null : items.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getId(); }</code> </pre> <br> 函数<i>firstItemId</i>和<i>lastItemId</i>具有相同的实现。 后者可能意味着获取最后一个元素的索引，而不是获取索引0处的元素。 <br><br>  <b>警告2</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6032</a>方法的主体完全等同于另一种方法的主体，这很奇怪。  SearchComboBoxPainter.java（495），SearchComboBoxPainter.java（501） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintBackgroundDisabledAndEditable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Graphics2D g)</span></span></span><span class="hljs-function"> </span></span>{ rect = decodeRect1(); g.setPaint(color53); g.fill(rect); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintBackgroundEnabledAndEditable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Graphics2D g)</span></span></span><span class="hljs-function"> </span></span>{ rect = decodeRect1(); g.setPaint(color53); g.fill(rect); }</code> </pre> <br> 具有可疑相同主体的另外两个功能。 我的猜测是，其中一个应该使用其他颜色而不是<i>color53</i> 。 <br><br><h2> 空解除引用 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6060已</a>使用'descriptionPopup'参考，然后将其对照null进行验证。  SuggestPopup.java（252），SuggestPopup.java（251） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDescriptionPopupPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = getAbsoluteLeft() + WIDTH; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = getAbsoluteTop(); descriptionPopup.setPopupPosition(x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptionPopup!=null) { descriptionPopup.setPopupPosition(x, y); } }</code> </pre> <br> 仅用两行，程序员就编写了一个高度可疑的代码。 首先，调用对象<i>descriptionPopup的</i> <i>setPopupPosition</i>方法，然后检查该对象是否为<i>null</i> 。 对<i>setPopupPosition</i>的第一次调用可能是多余的，并且有潜在危险。 我猜这是由于不良的重构造成的。 <br><br>  <b>警告2</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6060</a>在对null进行验证之前，已使用'tableModel'引用。  DesktopAbstractTable.java（1580），DesktopAbstractTable.java（1564） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Column </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addRuntimeGeneratedColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String columnId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// store old cell editors / renderers TableCellEditor[] cellEditors = new TableCellEditor[tableModel.getColumnCount() + 1]; // &lt;= TableCellRenderer[] cellRenderers = new TableCellRenderer[tableModel.getColumnCount() + 1]; // &lt;= for (int i = 0; i &lt; tableModel.getColumnCount(); i++) { // &lt;= Column tableModelColumn = tableModel.getColumn(i); if (tableModel.isGeneratedColumn(tableModelColumn)) { // &lt;= TableColumn tableColumn = getColumn(tableModelColumn); cellEditors[i] = tableColumn.getCellEditor(); cellRenderers[i] = tableColumn.getCellRenderer(); } } Column col = new Column(columnId, columnId); col.setEditable(false); columns.put(col.getId(), col); if (tableModel != null) { // &lt;= tableModel.addColumn(col); } .... }</span></span></code> </pre> <br> 这种情况类似于前一种情况。 到<i>tableModel</i>对象检查为<i>null时</i> ，它已经被多次访问。 <br><br> 另一个例子： <br><br><ul><li>  V6060在对null进行验证之前，已使用'tableModel'引用。  DesktopAbstractTable.java（596），DesktopAbstractTable.java（579） </li></ul><br><h2> 可能是逻辑错误 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6026</a>该值已经分配给'sortAscending'变量。  CubaScrollTableWidget.java（488） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sortAscending) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sortClickCounter &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// special case for initial revert sorting instead of reset sort order if (sortClickCounter == 0) { client.updateVariable(paintableId, "sortascending", false, false); } else { reloadDataFromServer = false; sortClickCounter = 0; sortColumn = null; sortAscending = true; // &lt;= client.updateVariable(paintableId, "resetsortorder", "", true); } } else { client.updateVariable(paintableId, "sortascending", false, false); } } else { if (sortClickCounter &lt; 2) { // special case for initial revert sorting instead of reset sort order if (sortClickCounter == 0) { client.updateVariable(paintableId, "sortascending", true, false); } else { reloadDataFromServer = false; sortClickCounter = 0; sortColumn = null; sortAscending = true; client.updateVariable(paintableId, "resetsortorder", "", true); } } else { reloadDataFromServer = false; sortClickCounter = 0; sortColumn = null; sortAscending = true; client.updateVariable(paintableId, "resetsortorder", "", true); } } .... }</span></span></code> </pre> <br> 在第一种情况下，已经为变量<i>sortAscending</i>分配了值<i>true</i> ，但稍后仍会再次为其分配相同的值。 这肯定是一个错误，并且作者可能将其值设为<i>false</i> 。 <br><br> 来自不同文件的类似示例： <br><br><ul><li>  V6026该值已经分配给'sortAscending'变量。  CubaTreeTableWidget.java（444） </li></ul><br><h2> 返回值奇怪 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6037</a>循环内无条件的“返回”。  QueryCacheManager.java（128） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSingleResultFromCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryKey queryKey, List&lt;View&gt; views)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object id : queryResult.getResult()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) em.find(metaClass.getJavaClass(), id, views.toArray(....)); } .... }</code> </pre> <br> 分析器检测到无条件调用，以在<i>for</i>循环的第一次迭代中<i>返回</i> 。 该行不正确，或者循环应重写为<i>if</i>语句。 <br><br>  <b>警告2</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6014</a>这种方法总是返回一个相同的值，这很奇怪。  DefaultExceptionHandler.java（40） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorEvent event, App app)</span></span></span><span class="hljs-function"> </span></span>{ Throwable t = event.getThrowable(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t instanceof SocketException || ExceptionUtils.getRootCause(t) instanceof SocketException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ExceptionUtils.getThrowableList(t).stream() .anyMatch(o -&gt; o.getClass().getName().equals(<span class="hljs-string"><span class="hljs-string">"...."</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringUtils.contains(ExceptionUtils.getMessage(t), <span class="hljs-string"><span class="hljs-string">"...."</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } AppUI ui = AppUI.getCurrent(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ui == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (app.getConnection().getSession() != null) { showDialog(app, t); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { showNotification(app, t); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 在每种情况下，此函数均返回<i>true</i> ，而最后一行显然要求<i>false</i> 。 看起来像个错误。 <br><br> 以下是其他类似可疑功能的完整列表： <br><br><ul><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  ErrorNodesFinder.java（31） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  FileDownloadController.java（69） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  IdVarSelector.java（73） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  IdVarSelector.java（48） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  IdVarSelector.java（67） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  IdVarSelector.java（46） </li><li>  V6014这种方法总是返回一个相同的值，这很奇怪。  JoinVariableNode.java（57） </li></ul><br>  <b>警告3</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式“ needReload”始终为false。  WebAbstractTable.java（2702） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleSpecificVariables</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, Object&gt; variables)</span></span></span><span class="hljs-function"> </span></span>{ boolean needReload = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUsePresentations() &amp;&amp; presentations != null) { Presentations p = getPresentations(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.getCurrent() != null &amp;&amp; p.isAutoSave(p.getCurrent()) &amp;&amp; needUpdatePresentation(variables)) { Element e = p.getSettings(p.getCurrent()); saveSettings(e); p.setSettings(p.getCurrent(), e); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> needReload; }</code> </pre> <br> 该函数返回<i>NeedReload</i>变量，其值始终为<i>false</i> 。 其中一个条件可能缺少一些用于更改该值的代码。 <br><br>  <b>警告4</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6062</a> “ isFocused”方法内可能进行无限递归。  GwtAceEditor.java（189），GwtAceEditor.java（190） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> final native </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">focus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*-{ this.focus(); }-*/</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> final boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFocused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isFocused(); }</code> </pre> <br> 分析仪检测到没有停止条件的递归功能。 该文件包含许多功能，这些功能标有关键字<i>native</i>并包含注释掉的代码。 开发人员现在可能正在重写此文件，并且很快也会注意到<i>isFocused</i>函数。 <br><br><h2> 杂项 </h2><br>  <b>警告1</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6002</a> switch语句未涵盖“ Operation”枚举的所有值：ADD。  DesktopAbstractTable.java（665） <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Operation which caused the datasource change. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Operation { REFRESH, CLEAR, ADD, REMOVE, UPDATE } @<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setDatasource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(final CollectionDatasource datasource)</span></span></span><span class="hljs-function"> </span></span>{ .... collectionChangeListener = e -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e.getOperation()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CLEAR: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REFRESH: fieldDatasources.clear(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPDATE: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REMOVE: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object entity : e.getItems()) { fieldDatasources.remove(entity); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }; .... }</code> </pre> <br>  <i>switch</i>语句没有大小写<i>ADD的情况</i> 。 这是唯一未检查的值，因此开发人员应查看此代码。 <br><br>  <b>警告2</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6021</a>不使用变量“源”。  DefaultHorizo​​ntalLayoutDropHandler.java（177） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleHTML5Drop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DragAndDropEvent event)</span></span></span><span class="hljs-function"> </span></span>{ LayoutBoundTransferable transferable = (LayoutBoundTransferable) event .getTransferable(); HorizontalLayoutTargetDetails details = (HorizontalLayoutTargetDetails) event .getTargetDetails(); AbstractOrderedLayout layout = (AbstractOrderedLayout) details .getTarget(); Component source = event.getTransferable().getSourceComponent(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= int idx = (details).getOverIndex(); HorizontalDropLocation loc = (details).getDropLocation(); if (loc == HorizontalDropLocation.CENTER || loc == HorizontalDropLocation.RIGHT) { idx++; } Component comp = resolveComponentFromHTML5Drop(event); if (idx &gt;= 0) { layout.addComponent(comp, idx); } else { layout.addComponent(comp); } if (dropAlignment != null) { layout.setComponentAlignment(comp, dropAlignment); } }</span></span></code> </pre> <br> 声明了变量<i>source</i> ，但未使用。 也许作者忘记了将<i>源代码</i>添加到<i>布局中</i> ，就像发生在这种类型的另一个变量<i>comp上一样</i> 。 <br><br> 其他具有未使用变量的函数： <br><br><ul><li>  V6021不使用变量“源”。  DefaultHorizo​​ntalLayoutDropHandler.java（175） </li><li>  V6021该值已分配给'r'变量，但未使用。  ExcelExporter.java（262） </li><li>  V6021不使用变量“ over”。  DefaultCssLayoutDropHandler.java（49） </li><li>  V6021不使用变量“可转移”。  DefaultHorizo​​ntalLayoutDropHandler.java（171） </li><li>  V6021不使用变量“可转移”。  DefaultHorizo​​ntalLayoutDropHandler.java（169） </li><li>  V6021未使用变量'beanLocator'。  ScreenEventMixin.java（28） </li></ul><br>  <b>警告3</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6054</a>不应按名称<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对</a>类进行比较。  MessageTools.java（283） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasPropertyCaption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaProperty property)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; declaringClass = property.getDeclaringClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (declaringClass == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; String caption = getPropertyCaption(property); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = caption.indexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; declaringClass.getSimpleName().equals(caption.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, i))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 分析器已按名称检测到类别比较。 按名称比较类是不正确的，因为根据规范，JVM类的名称仅在包内必须唯一。 这样的比较会产生错误的结果，并导致执行错误的代码。 <br><br><h2>  CUBA平台开发人员的评论 </h2><br>  <i>任何大型项目肯定都存在错误。</i>  <i>知道这一点，当PVS-Studio团队提出检查我们的项目时，我们感到非常高兴。</i>  <i>CUBA存储库包含Apache 2许可下的一些第三方OSS库的分支，并且由于分析器在这些源中发现了许多问题，因此我们似乎应该更加注意该代码。</i>  <i>我们目前使用SpotBugs作为我们的主要分析器，它无法注意到PVS-Studio报告的一些大错误。</i>  <i>看来我们应该自己编写一些其他诊断程序。</i>  <i>非常感谢PVS-Studio团队的工作。</i> <br><br> 开发商还告诉我们，警告V6013和V6054是误报； 他们有意识地决定以自己的方式编写该代码。 该分析仪用于检测可疑的代码片段，发现真正错误的可能性在不同的诊断程序中有所不同。 但是，可以使用特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">批量警告抑制</a>机制轻松处理此类警告，而无需修改源文件。 <br><br> 此外，PVS-Studio团队无法注意到“似乎我们应该自己编写一些其他诊断信息”这一短语，并且没有这张图片:) <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fac/fb2/ba3/facfb2ba3cd66c0f1deb0e05dd99c655.png" alt="图片3"></div><br><h2> 结论 </h2><br>  PVS-Studio可以完美地补充开发过程中使用的现有质量控制工具。 对于拥有数十，数百或数千开发人员的公司而言尤其如此。  PVS-Studio不仅旨在检测错误，而且还可以帮助您修复错误，我的意思不是自动代码编辑，而是可靠的代码质量控制手段。 在大型公司中，不可能每个开发人员都使用不同的工具来检查代码的各个部分，因此对于此类公司来说，更好的解决方案是采用PVS-Studio之类的工具，该工具在每个开发阶段都提供代码质量控制，而不是仅在程序员方面。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449020/">https://habr.com/ru/post/zh-CN449020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449006/index.html">视频游戏老虎机的隐藏复杂性</a></li>
<li><a href="../zh-CN449008/index.html">使用线轴在Spring Boot中记录HTTP请求</a></li>
<li><a href="../zh-CN449012/index.html">世界！ 辛苦！ iOS！ 优惠长寿1天</a></li>
<li><a href="../zh-CN449014/index.html">先进的以太坊DAPP</a></li>
<li><a href="../zh-CN449016/index.html">光盘文件系统中的隐写术</a></li>
<li><a href="../zh-CN449022/index.html">使用PVS-Studio进行CUBA平台代码分析</a></li>
<li><a href="../zh-CN449026/index.html">操作系统：三个简单的部分。 第4部分：计划程序简介（翻译）</a></li>
<li><a href="../zh-CN449028/index.html">使用InfluxDB时的愤怒，讨价还价和沮丧</a></li>
<li><a href="../zh-CN449032/index.html">我们设计了一种喷水灭火系统</a></li>
<li><a href="../zh-CN449036/index.html">再穿上羊皮的狼</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>