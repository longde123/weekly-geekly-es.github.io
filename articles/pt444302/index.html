<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üôçüèΩ üì™ A evolu√ß√£o da arquitetura do sistema de negocia√ß√£o e compensa√ß√£o da Bolsa de Moscou. Parte 2 üîÇ üíπ üß•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a continua√ß√£o de uma longa hist√≥ria sobre nosso caminho espinhoso para a cria√ß√£o de um sistema poderoso e altamente carregado que garante a ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A evolu√ß√£o da arquitetura do sistema de negocia√ß√£o e compensa√ß√£o da Bolsa de Moscou. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444302/"><img src="https://habrastorage.org/webt/fj/7h/zk/fj7hzkntltigzuhy-4zrisejpyu.jpeg"><br><br>  Esta √© a continua√ß√£o de uma longa hist√≥ria sobre nosso caminho espinhoso para a cria√ß√£o de um sistema poderoso e altamente carregado que garante a opera√ß√£o do Exchange.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A primeira parte est√° aqui</a> . <br><a name="habracut"></a><br><h2>  Erro misterioso </h2><br>  Ap√≥s numerosos testes, o sistema de negocia√ß√£o e compensa√ß√£o atualizado foi colocado em opera√ß√£o e encontramos um bug sobre o qual era correto escrever uma hist√≥ria m√≠stica de detetive. <br><br>  Logo ap√≥s iniciar no servidor principal, uma das transa√ß√µes foi processada com um erro.  Ao mesmo tempo, tudo estava em ordem no servidor de backup.  Aconteceu que uma opera√ß√£o matem√°tica simples de calcular o expoente no servidor principal deu um resultado negativo a partir de um argumento v√°lido!  As pesquisas continuaram e, no registro SSE2, eles encontraram uma diferen√ßa em um bit, respons√°vel pelo arredondamento ao trabalhar com n√∫meros de ponto flutuante. <br><br>  Eles escreveram um utilit√°rio de teste simples para calcular o expoente com o conjunto de bits de arredondamento.  Descobriu-se que na vers√£o do RedHat Linux que usamos, havia um erro ao trabalhar com uma fun√ß√£o matem√°tica quando o bit incorreto foi inserido.  Relatamos isso ao RedHat, depois de um tempo recebemos um patch deles e o enrolamos.  O erro n√£o ocorreu mais, mas n√£o estava claro de onde veio esse bit?  A fun√ß√£o <code>fesetround</code> de C. foi respons√°vel por isso. Analisamos cuidadosamente nosso c√≥digo em busca do suposto erro: verificamos todas as situa√ß√µes poss√≠veis;  considerou todas as fun√ß√µes que usavam arredondamento;  tentou reproduzir uma sess√£o com falha;  usou compiladores diferentes com op√ß√µes diferentes;  utilizou an√°lise est√°tica e din√¢mica. <br><br>  N√£o foi poss√≠vel encontrar a causa do erro. <br><br>  Ent√£o eles come√ßaram a verificar o hardware: executaram testes de carga dos processadores;  checou a RAM;  at√© executou testes para um cen√°rio muito improv√°vel de erro de v√°rios bits em uma c√©lula.  Sem sucesso. <br><br>  No final, eles adotaram teorias do mundo da f√≠sica de alta energia: algumas part√≠culas de alta energia voaram para o nosso data center, romperam a parede do gabinete, atingiram o processador e fizeram com que a trava do gatilho ficasse na mesma parte.  Essa teoria absurda foi chamada de "neutrino".  Se voc√™ est√° longe da f√≠sica de part√≠culas elementares: os neutrinos dificilmente interagem com o mundo exterior e, certamente, eles n√£o s√£o capazes de afetar o processador. <br><br>  Como n√£o foi poss√≠vel encontrar a causa da falha, apenas no caso de eles exclu√≠rem o servidor ‚Äúdelinquente‚Äù da opera√ß√£o. <br><br>  Depois de algum tempo, come√ßamos a melhorar o sistema hot standby: introduzimos as chamadas "reservas quentes" (r√©plicas ass√≠ncronas).  Eles receberam um fluxo de transa√ß√µes que podem estar em diferentes datacenters, mas o Warm n√£o oferece suporte √† intera√ß√£o ativa com outros servidores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/4fd/67f/61c4fd67f72a529370bcc7a792ae946e.png"><br><br>  Por que isso foi feito?  Se o servidor de backup falhar, o v√≠nculo quente com o servidor principal se tornar√° o novo backup.  Ou seja, ap√≥s uma falha, o sistema n√£o permanece at√© o final da sess√£o de negocia√ß√£o com um servidor principal. <br><br>  E quando a nova vers√£o do sistema foi testada e colocada em opera√ß√£o, ocorreu novamente um erro com um bit de arredondamento.  Al√©m disso, com o aumento do n√∫mero de servidores quentes, o erro come√ßou a aparecer com mais frequ√™ncia.  Nesse caso, o fornecedor n√£o tinha nada a apresentar, pois n√£o h√° evid√™ncias concretas. <br><br>  Durante a pr√≥xima an√°lise da situa√ß√£o, surgiu a teoria de que o problema poderia estar relacionado ao sistema operacional.  <code>fesetround</code> um programa simples que chama a fun√ß√£o <code>fesetround</code> em um loop infinito, lembra o estado atual e o verifica durante o sono, e isso √© feito em muitos threads concorrentes.  Depois de selecionar os par√¢metros de suspens√£o e o n√∫mero de threads, come√ßamos a reproduzir de forma est√°vel a falha de bits ap√≥s cerca de 5 minutos do utilit√°rio.  No entanto, o suporte da Red Hat n√£o conseguiu reproduzi-lo.  O teste de nossos outros servidores mostrou que apenas aqueles com determinados processadores instalados s√£o afetados pelo erro.  Ao mesmo tempo, a transi√ß√£o para um novo n√∫cleo resolveu o problema.  No final, acabamos de substituir o sistema operacional e a verdadeira causa do bug ainda n√£o estava clara. <br><br>  E de repente, no ano passado, apareceu um artigo em Habr√© " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como encontrei um bug nos processadores Intel Skylake</a> ".  A situa√ß√£o descrita era muito semelhante √† nossa, mas o autor avan√ßou mais na investiga√ß√£o e avan√ßou na teoria de que o erro estava no microc√≥digo.  E ao atualizar os kernels do Linux, os fabricantes tamb√©m atualizam o microc√≥digo. <br><br><h2>  Desenvolvimento adicional do sistema </h2><br>  Embora tenhamos nos livrado do erro, essa hist√≥ria nos fez reconsiderar a arquitetura do sistema novamente.  Afinal, n√£o est√°vamos protegidos da repeti√ß√£o de tais bugs. <br><br>  Os seguintes princ√≠pios formaram a base para melhorias adicionais no sistema de backup: <br><br><ul><li>  Voc√™ n√£o pode confiar em ningu√©m.  Servidores podem n√£o funcionar corretamente. </li><li>  Redund√¢ncia de maioria. </li><li>  Constru√ß√£o de consenso.  Como complemento l√≥gico da redund√¢ncia majorit√°ria. </li><li>  S√£o poss√≠veis falhas duplas. </li><li>  Vitalidade.  O novo esquema de hot spare n√£o deve ser pior que o anterior.  O com√©rcio deve ocorrer sem problemas at√© o √∫ltimo servidor. </li><li>  Um ligeiro aumento no atraso.  Qualquer tempo de inatividade acarreta enormes perdas financeiras. </li><li>  Intera√ß√£o m√≠nima de rede para que o atraso seja o mais baixo poss√≠vel. </li><li>  Selecione um novo servidor mestre em segundos. </li></ul><br>  Nenhuma das solu√ß√µes dispon√≠veis no mercado nos convinha, e o protocolo Raft ainda estava em sua inf√¢ncia, por isso criamos nossa pr√≥pria solu√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/bc0/73e/d50bc073e4a2bbb805b724d0040b18f9.png"><br><br><h2>  Conectividade de rede </h2><br>  Al√©m do sistema de backup, come√ßamos a modernizar a conectividade de rede.  O subsistema de E / S era uma infinidade de processos, que da pior maneira afetavam a instabilidade e o atraso.  Tendo centenas de processos que processam conex√µes TCP, fomos for√ßados a alternar constantemente entre eles e, em uma escala de microssegundos, essa √© uma opera√ß√£o bastante demorada.  Mas a pior parte √© que, quando um processo recebe um pacote para processamento, ele o envia para uma fila do SystemV e, em seguida, espera por eventos de outra fila do SystemV.  No entanto, com um grande n√∫mero de n√≥s, a chegada de um novo pacote TCP em um processo e o recebimento de dados em uma fila em outro representam dois eventos concorrentes para o sistema operacional.  Nesse caso, se n√£o houver processadores f√≠sicos dispon√≠veis para as duas tarefas, um ser√° processado e o segundo permanecer√° na fila de espera.  √â imposs√≠vel prever as consequ√™ncias. <br><br>  Nessas situa√ß√µes, voc√™ pode aplicar o controle din√¢mico de prioridade do processo, mas isso exigir√° o uso de chamadas do sistema com muitos recursos.  Como resultado, mudamos para um thread usando o epoll cl√°ssico, isso aumentou muito a velocidade e reduziu o tempo de processamento da transa√ß√£o.  Tamb√©m nos livramos de certos processos de intera√ß√£o de rede e intera√ß√£o atrav√©s do SystemV, reduzimos significativamente o n√∫mero de chamadas do sistema e come√ßamos a controlar as prioridades das opera√ß√µes.  Usando apenas um subsistema de E / S, foi poss√≠vel economizar de 8 a 17 microssegundos, dependendo do cen√°rio.  Desde ent√£o, esse esquema de thread √∫nico foi aplicado inalterado; um fluxo de epoll com margem √© suficiente para atender a todas as conex√µes. <br><br><h2>  Processamento de transa√ß√£o </h2><br>  A carga crescente em nosso sistema exigiu a moderniza√ß√£o de quase todos os seus componentes.  Infelizmente, por√©m, a estagna√ß√£o no aumento da velocidade do clock do processador nos √∫ltimos anos n√£o nos permitiu mais escalar os processos "de frente".  Portanto, decidimos dividir o processo do mecanismo em tr√™s n√≠veis, sendo o mais carregado o sistema de verifica√ß√£o de riscos, que avalia a disponibilidade de fundos nas contas e cria as pr√≥prias transa√ß√µes.  Mas o dinheiro pode estar em moedas diferentes, e foi necess√°rio descobrir em que princ√≠pio dividir o processamento de solicita√ß√µes. <br><br>  A solu√ß√£o l√≥gica √© dividir por moeda: um servidor negocia em d√≥lares, outro em libras e um terceiro euro.  Mas se, com esse esquema, duas transa√ß√µes forem enviadas para comprar moedas diferentes, haver√° um problema de carteiras fora de sincronia.  E sincronizar √© dif√≠cil e caro.  Portanto, ser√° correto estilha√ßar separadamente nas carteiras e nas ferramentas.  A prop√≥sito, na maioria das trocas ocidentais, a tarefa de verificar riscos n√£o √© t√£o aguda quanto a nossa, portanto, na maioria das vezes, isso √© feito offline.  Precis√°vamos implementar uma verifica√ß√£o online. <br><br>  Vamos ilustrar com um exemplo.  O profissional deseja comprar US $ 30, e a solicita√ß√£o √© validada para a transa√ß√£o: verificamos se esse profissional est√° autorizado a esse modo de negocia√ß√£o, se possui os direitos necess√°rios.  Se tudo estiver em ordem, a solicita√ß√£o ser√° direcionada ao sistema de verifica√ß√£o de riscos, ou seja,  verificar a sufici√™ncia de fundos para concluir uma transa√ß√£o.  H√° uma observa√ß√£o de que a quantidade necess√°ria est√° atualmente bloqueada.  Al√©m disso, a solicita√ß√£o √© redirecionada para o sistema de negocia√ß√£o, que aprova ou n√£o a transa√ß√£o.  Digamos que a transa√ß√£o seja aprovada - ent√£o o sistema de verifica√ß√£o de riscos observa que o dinheiro √© desbloqueado e os rublos s√£o convertidos em d√≥lares. <br><br>  Em geral, o sistema de verifica√ß√£o de riscos cont√©m algoritmos complexos e realiza uma grande quantidade de c√°lculos que consomem muitos recursos e n√£o apenas verifica o ‚Äúsaldo da conta‚Äù, como pode parecer √† primeira vista. <br><br>  Quando come√ßamos a dividir o processo do mecanismo em n√≠veis, encontramos um problema: o c√≥digo que estava dispon√≠vel naquele momento nos est√°gios de valida√ß√£o e verifica√ß√£o usava ativamente a mesma matriz de dados, o que exigia a reescrita de toda a base de c√≥digos.  Como resultado, emprestamos uma metodologia para processar instru√ß√µes dos processadores modernos: cada um deles √© dividido em pequenos est√°gios e v√°rias a√ß√µes s√£o executadas em paralelo em um ciclo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40f/d5b/011/40fd5b0119fef43d909ce33abc898ff8.png"><br><br>  Ap√≥s uma pequena adapta√ß√£o do c√≥digo, criamos um pipeline para processamento paralelo de transa√ß√µes, no qual a transa√ß√£o foi dividida em 4 etapas do pipeline: intera√ß√£o da rede, valida√ß√£o, execu√ß√£o e publica√ß√£o do resultado <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/90f/55b/dd690f55b9be4e03a50a9ecb3930c746.png"><br><br>  Considere um exemplo.  Temos dois sistemas de processamento, serial e paralelo.  A primeira transa√ß√£o chega e, nos dois sistemas, √© validada.  Em seguida, chega a segunda transa√ß√£o: em um sistema paralelo, ela √© imediatamente levada ao trabalho e, em um sistema seq√ºencial, √© enfileirada em antecipa√ß√£o at√© a primeira transa√ß√£o passar no est√°gio de processamento atual.  Ou seja, a principal vantagem do pipelining √© que processamos a fila de transa√ß√µes mais rapidamente. <br><br>  Ent√£o, n√≥s temos o sistema ASTS +. <br><br>  √â verdade que tamb√©m com transportadores, nem tudo √© t√£o suave.  Suponha que tenhamos uma transa√ß√£o que afeta as matrizes de dados em uma transa√ß√£o vizinha, essa √© uma situa√ß√£o t√≠pica da troca.  Essa transa√ß√£o n√£o pode ser executada no pipeline, porque pode afetar outras.  Essa situa√ß√£o √© chamada de risco de dados e essas transa√ß√µes s√£o simplesmente processadas separadamente: quando as transa√ß√µes "r√°pidas" na fila terminam, o pipeline para, o sistema processa a transa√ß√£o "lenta" e inicia o pipeline novamente.  Felizmente, a participa√ß√£o dessas transa√ß√µes no fluxo total √© muito pequena; portanto, o pipeline para t√£o raramente que n√£o afeta o desempenho geral. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/131/de5/0e0131de5df810723111aba61853dd77.png"><br><br>  Ent√£o come√ßamos a resolver o problema de sincronizar tr√™s threads de execu√ß√£o.  Como resultado, nasceu um sistema baseado em um buffer circular com c√©lulas de tamanho fixo.  Neste sistema, tudo est√° sujeito √† velocidade de processamento, os dados n√£o s√£o copiados. <br><br><ul><li>  Todos os pacotes de rede recebidos entram no est√°gio de aloca√ß√£o. </li><li>  N√≥s os colocamos em uma matriz e marcamos que eles est√£o dispon√≠veis para o est√°gio n ¬∞ 1. </li><li>  A segunda transa√ß√£o chegou, est√° novamente dispon√≠vel para o est√°gio n√∫mero 1. </li><li>  O primeiro fluxo de processamento v√™ as transa√ß√µes dispon√≠veis, as processa e as transfere para o pr√≥ximo est√°gio do segundo fluxo de processamento. </li><li>  Em seguida, processa a primeira transa√ß√£o e marca a c√©lula correspondente com o sinalizador <code>deleted</code> - agora est√° dispon√≠vel para novo uso. </li></ul><br>  Assim, toda a fila √© processada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/172/d67/3a8172d67dad9c45dc21448dfb74e135.png"><br><br>  O processamento de cada est√°gio leva unidades ou dezenas de microssegundos.  E se voc√™ usar esquemas de sincroniza√ß√£o padr√£o do SO, perderemos mais tempo na pr√≥pria sincroniza√ß√£o.  Portanto, come√ßamos a usar o spinlock.  No entanto, esse √© um tom muito ruim em um sistema em tempo real, e o RedHat recomenda enfaticamente n√£o fazer isso; portanto, usamos o spinlock por 100 ms e, em seguida, entramos no modo de sem√°foro para excluir a possibilidade de conflito. <br><br>  Como resultado, alcan√ßamos um desempenho de cerca de 8 milh√µes de transa√ß√µes por segundo.  E apenas dois meses depois, em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> sobre o LMAX Disruptor, eles viram uma descri√ß√£o de um circuito com a mesma funcionalidade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b31/498/732/b31498732113050fe76ed4dee7c9c82e.png"><br><br>  Agora, em um est√°gio, pode haver v√°rios segmentos de execu√ß√£o.  Todas as transa√ß√µes foram processadas por sua vez, na ordem recebida.  Como resultado, o desempenho m√°ximo aumentou de 18 mil para 50 mil transa√ß√µes por segundo. <br><br><h2>  Sistema de Gerenciamento de Risco de C√¢mbio </h2><br>  N√£o h√° limite para a perfei√ß√£o e logo come√ßamos a nos modernizar novamente: no √¢mbito do ASTS +, come√ßamos a transferir sistemas de gerenciamento de riscos e opera√ß√µes de liquida√ß√£o para componentes aut√¥nomos.  Desenvolvemos uma arquitetura moderna flex√≠vel e um novo modelo de risco hier√°rquico, tentado sempre que poss√≠vel usar a classe <code>fixed_point</code> vez de <code>double</code> . <br><br>  Mas imediatamente surgiu o problema: como sincronizar toda a l√≥gica de neg√≥cios que funciona h√° muitos anos e transferi-la para o novo sistema?  Como resultado, a primeira vers√£o do prot√≥tipo do novo sistema teve que ser abandonada.  A segunda vers√£o, que est√° atualmente trabalhando na produ√ß√£o, √© baseada no mesmo c√≥digo que funciona tanto na parte comercial quanto na de risco.  Durante o desenvolvimento, a coisa mais dif√≠cil foi fazer a fus√£o do git entre as duas vers√µes.  Nosso colega Evgeny Mazurenok realizou essa opera√ß√£o toda semana e xingou por muito tempo. <br><br>  Ao selecionar um novo sistema, imediatamente tivemos que resolver o problema de intera√ß√£o.  Ao escolher um barramento de dados, era necess√°rio garantir instabilidade est√°vel e atraso m√≠nimo.  Para isso, a rede InfiniBand RDMA √© mais adequada: o tempo m√©dio de processamento √© 4 vezes menor que nas redes Ethernet de 10 G.  Mas a diferen√ßa real estava nos percentis - 99 e 99,9. <br><br>  Obviamente, o InfiniBand tem suas pr√≥prias dificuldades.  Primeiro, outra API √© ibverbs em vez de soquetes.  Em segundo lugar, quase n√£o existem solu√ß√µes de mensagens de c√≥digo aberto amplamente dispon√≠veis.  Tentamos fazer nosso prot√≥tipo, mas ele se mostrou muito dif√≠cil, por isso escolhemos uma solu√ß√£o comercial - Confinity Low Latency Messaging (anteriormente IBM MQ LLM). <br><br>  Surgiu ent√£o o problema da separa√ß√£o correta do sistema de riscos.  Se voc√™ apenas remover o Mecanismo de Risco e n√£o criar um n√≥ intermedi√°rio, as transa√ß√µes de duas fontes poder√£o ser misturadas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/b59/4c9/41cb594c970d774c5715a43f43d3f29b.png"><br><br>  As chamadas solu√ß√µes de ultra baixa lat√™ncia t√™m um modo de reordena√ß√£o: as transa√ß√µes de duas fontes podem ser organizadas na ordem correta ap√≥s o recebimento, isso √© realizado usando um canal separado para troca de informa√ß√µes sobre a sequ√™ncia.  Mas ainda n√£o aplicamos esse modo: ele complica todo o processo e, em algumas solu√ß√µes, ele n√£o √© suportado.  Al√©m disso, cada transa√ß√£o teria que receber os carimbos de data e hora apropriados e, em nosso esquema, esse mecanismo √© muito dif√≠cil de implementar corretamente.  Portanto, usamos o esquema cl√°ssico com o intermedi√°rio de mensagens, ou seja, com um despachante que distribui mensagens entre o Risk Engine. <br><br>  O segundo problema estava relacionado ao acesso do cliente: se houver v√°rios Gateways de Risco, o cliente precisar√° se conectar a cada um deles e, para isso, ser√° necess√°rio fazer altera√ß√µes na camada do cliente.  Quer√≠amos nos afastar disso nesta fase; portanto, no atual esquema do Risk Gateway, eles processam todo o fluxo de dados.  Isso limita severamente o rendimento m√°ximo, mas simplifica bastante a integra√ß√£o do sistema. <br><br><h2>  Duplica√ß√£o </h2><br>  Nosso sistema n√£o deve ter um √∫nico ponto de falha, ou seja, todos os componentes devem ser duplicados, incluindo um intermedi√°rio de mensagens.  Resolvemos esse problema usando o sistema CLLM: ele cont√©m um cluster RCMS no qual dois despachantes podem trabalhar no modo mestre-escravo e, quando um falha, o sistema alterna automaticamente para o outro. <br><br><h2>  Trabalhar com um data center de backup </h2><br>  O InfiniBand √© otimizado para funcionar como uma rede local, ou seja, para conectar equipamentos montados em rack, e n√£o h√° como estabelecer uma rede InfiniBand entre dois data centers geograficamente distribu√≠dos.  Portanto, implementamos uma ponte / despachante que se conecta ao armazenamento de mensagens atrav√©s de redes Ethernet regulares e retransmite todas as transa√ß√µes para a segunda rede IB.  Quando voc√™ precisar migrar do data center, podemos escolher com que data center trabalhar agora. <br><br><h2>  Sum√°rio </h2><br>  Todas as op√ß√µes acima n√£o foram feitas de uma s√≥ vez; foram necess√°rias v√°rias itera√ß√µes para o desenvolvimento de uma nova arquitetura.  Criamos o prot√≥tipo em um m√™s, mas foram necess√°rios mais de dois anos para finalizar a condi√ß√£o de trabalho.  Tentamos alcan√ßar o melhor compromisso entre aumentar a dura√ß√£o do processamento da transa√ß√£o e aumentar a confiabilidade do sistema. <br><br>  Como o sistema foi fortemente atualizado, implementamos a recupera√ß√£o de dados de duas fontes independentes.  Se, por algum motivo, o armazenamento de mensagens n√£o estiver funcionando corretamente, voc√™ poder√° obter o log de transa√ß√µes de uma segunda fonte - no Risk Engine.  Este princ√≠pio √© respeitado em todo o sistema. <br><br>  Entre outras coisas, conseguimos manter a API do cliente para que nem os corretores nem qualquer outra pessoa precisassem de uma altera√ß√£o significativa para a nova arquitetura.  Eu tive que mudar algumas interfaces, mas n√£o precisei fazer altera√ß√µes significativas no modelo de trabalho. <br><br>  Chamamos a vers√£o atual de nossa plataforma de Rebus - como uma abrevia√ß√£o para as duas inova√ß√µes mais not√°veis ‚Äã‚Äãem arquitetura, Risk Engine e BUS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/179/4f2/bf5/1794f2bf5eb87f3ab59df9d9e0d829d8.png"><br><br>  Inicialmente, quer√≠amos destacar apenas a parte da compensa√ß√£o, mas o resultado foi um enorme sistema distribu√≠do.  Agora, os clientes podem interagir com o Gateway de negocia√ß√£o ou com a compensa√ß√£o ou com os dois ao mesmo tempo. <br><br>  O que finalmente alcan√ßamos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/6e7/d8d/2d46e7d8d73032984b0c5ecb8bc1e9e1.png"><br><br>  Reduzido o n√≠vel de atraso.  Com um pequeno volume de transa√ß√µes, o sistema funciona da mesma forma que na vers√£o anterior, mas ao mesmo tempo suporta uma carga muito maior. <br><br>  O pico de produtividade aumentou de 50 mil para 180 mil transa√ß√µes por segundo.  Um fluxo adicional de informa√ß√µes est√° impedindo um crescimento maior. <br><br>     :  matching      Gateway.   Gateway    ,       . <br><br>      ,   -: <br><br><ul><li>      .    . </li><li>   ,  , . ,        .   ,      . </li><li>          ,   . </li><li>          ,      . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444302/">https://habr.com/ru/post/pt444302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444290/index.html">No√ß√µes b√°sicas de programa√ß√£o reativa usando RxJS. Parte 2. Operadores e tubula√ß√µes</a></li>
<li><a href="../pt444294/index.html">Como funciona a avia√ß√£o executiva na R√∫ssia (centros FBO)</a></li>
<li><a href="../pt444296/index.html">6 recursos e servi√ßos √∫teis para potenciais emigrantes para os EUA, Alemanha e Canad√°</a></li>
<li><a href="../pt444298/index.html">Cientistas dizem que podem remodelar dinossauros vivos por 5 anos</a></li>
<li><a href="../pt444300/index.html">A evolu√ß√£o da arquitetura do sistema de negocia√ß√£o e compensa√ß√£o da Bolsa de Moscou. Parte 1</a></li>
<li><a href="../pt444304/index.html">Huawei e Nutanix anunciam parceria HCI</a></li>
<li><a href="../pt444306/index.html">Sexo, amor e relacionamentos atrav√©s do prisma da arquitetura de microsservi√ßos</a></li>
<li><a href="../pt444308/index.html">Not√≠cias da ind√∫stria de jogos (11 a 18 de mar√ßo de 2019)</a></li>
<li><a href="../pt444312/index.html">Instale o ReactOS a partir de um dispositivo USB</a></li>
<li><a href="../pt444314/index.html">V√°lvula come√ßa a combater coment√°rios negativos offshore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>