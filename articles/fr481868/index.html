<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤨 🤰 🎩 Dagaz: un nouveau départ 💘 👩‍🔧 🚨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il court au sud et tourne au nord, encerclant, encerclant pour courir avec son vent 
 Et selon ses circuits le vent revient; 
 Toutes les rivières se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: un nouveau départ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Il court au sud et tourne au nord, encerclant, encerclant pour courir avec son vent</i></b> <b><i><br></i></b>  <b><i>Et selon ses circuits le vent revient;</i></b> <b><i><br></i></b>  <b><i>Toutes les rivières se jettent dans la mer - et la mer ne déborde pas,</i></b> <b><i><br></i></b>  <b><i>À l'endroit où les fleuves coulent, - Là, ils continuent de couler;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">Le livre des ecclésiastes</a></i></b> <br><br>  En 1998, une application tout à fait unique, pour son époque, a été développée qui vous permet de réduire le processus de développement d'un jeu de société abstrait (ou puzzle) à un petit langage de description de texte, rappelant vaguement <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> .  Ce projet s'appelait <a href="http://www.zillions-of-games.com/" rel="nofollow">Zillions of Games</a> .  Cela a fait fureur parmi les fans de jeux de société.  Actuellement, plus de 2 000 applications ont été créées à l'aide de cette technologie. <br><a name="habracut"></a><br>  Il est rapidement devenu évident que ZoG avait de nombreux inconvénients.  J'ai déjà <a href="https://habr.com/ru/post/221779/">écrit</a> à ce sujet dans Habr et je ne vais pas me répéter.  Permettez-moi simplement de dire que les développeurs n'ont pas pris en compte les caractéristiques d'un grand nombre de jeux existants et que certaines options importantes ont été codées en dur, de sorte que leur changement est devenu extrêmement problématique.  Greg Schmidt, en 2007, a tenté de rectifier la situation en publiant le <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">kit de développement Axiom</a> , mais son intégration étroite avec ZoG ne permet pas de résoudre tous les problèmes. <br><br>  Le projet <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi a</a> mis en évidence de nouvelles frontières, en utilisant le «moteur» de jeu universel et <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">des algorithmes génétiques</a> pour automatiser le processus de développement de nouveaux jeux de société.  Malheureusement, cette approche a été initialement envisagée comme une simplification délibérée des mécanismes de jeu et du niveau de l'IA employée.  La discussion des objectifs de ce projet dépasse le cadre de cet article, mais certaines de ses solutions techniques ont sans aucun doute servi de point de départ à mon propre développement. <br><br>  Mon objectif est le développement d'un «moteur» plus polyvalent et convivial pour la création de jeux de société abstraits.  Depuis près d'un an, j'étudie la possibilité de ZoG et Axiom et j'ai beaucoup appris sur leurs limites.  Je pense que je peux résoudre leurs problèmes en créant une solution plus universelle et multiplateforme.  Sur l'état d'avancement des travaux sur ce projet, je ferai rapport. <br><br><h2>  Ouverture et modularité </h2><br>  Peut-être que le principal inconvénient de ZoG est sa fermeture.  Le produit a été assemblé «une fois pour toutes» sous une seule plate-forme - Windows.  S'il s'agissait de code open-source, on pourrait essayer de le porter sous Linux, Android, iOS ... Un autre problème est sa monolithicité. <br><br>  Dans ZoG, il y a les débuts de la modularité, permettant la connexion à la DLL de jeux, y compris les implémentations personnalisées de l'IA.  Axiom va un peu plus loin, vous permettant d'exécuter des applications en mode de lecture automatique, sans utiliser le noyau ZoG.  Malgré les sérieuses limitations de cette solution (ne prenant en charge les applications que pour deux joueurs), cet exemple montre à quel point la modularité serait utile!  L'opportunité d'organiser un jeu avec deux bots (en utilisant différents paramètres d'IA) et de collecter des statistiques sur un grand nombre de jeux ne peut pas être surestimée.  Mais combien il serait préférable que le produit soit entièrement modulaire! <br><br><ul><li>  Module de génération de mouvements </li><li>  Déplacer le module d'exécution </li><li>  Module de commande </li><li>  Module AI </li><li>  Module de visualisation </li></ul><br>  Tout le travail décrivant les jeux doit être effectué par le module de génération de mouvements.  C'est le «cœur» du projet.  Le transfert de toutes les tâches non liées à cette fonction vers d'autres modules le rendra aussi simple que possible.  Vous pouvez améliorer ce module, sans regarder les problèmes d'IA et l'interaction des utilisateurs.  Vous pouvez changer complètement le format de la description des jeux ou ajouter un support pour les descriptions au format ZoG, Axiom et Ludi.  La modularité est la base de la flexibilité de la solution! <br><br>  Le module d'exécution des mouvements est le gardien de l'état du jeu.  Les informations sur l'état actuel du jeu sont transférées à tous les autres modules sur demande.  Pour les raisons que je donnerai ci-dessous, la progression de l'exécution doit passer par le module de génération, dont la tâche est la formation d'une commande en termes d'exécution du module.  De plus, la tâche du module de génération de mouvements est la configuration principale de l'espace de jeu, basée sur la description du jeu. <br><br>  Le module de contrôle est en fait l'application elle-même.  Il demande au module de génération de coups une liste des coups possibles et change l'état du jeu, en passant le coup sélectionné au module d'exécution des coups.  Le module de contrôle peut être connecté pour jouer à un ou plusieurs robots AI.  Autant que vous en avez besoin (et éventuellement différents)!  Le type d'unité de contrôle est déterminé par la répartition des tâches.  Cela peut être une lecture automatique pour collecter des statistiques de jeu, un serveur de jeu (il peut contrôler plusieurs magasins d'état, menant un grand nombre de sessions de jeu) ou des applications individuelles pour jouer hors ligne. <br><br>  La possibilité de connecter différentes implémentations de l'IA améliorera la qualité du jeu.  Il est entendu que les modules du jeu d'échecs et de go doivent utiliser des approches différentes.  Les jeux avec des informations incomplètes et les jeux utilisant des données aléatoires nécessitent également une approche individuelle.  La mise en œuvre universelle de l'IA sera également mauvaise pour tous les jeux!  L'IA de connexion modulaire permettra de comparer la «force» des algorithmes, y compris un mode de jeu «les uns aux autres». Puisque l'architecture de l'IA est séparée de l'état de stockage du jeu, une instance du bot de jeu peut prendre en charge un nombre illimité de sessions de jeu simultanément. <br><br>  La visualisation du processus de jeu peut également varier.  La première chose qui me vient à l'esprit sont les implémentations 2D et 3D.  La plate-forme pour laquelle l'application est en cours de développement est également importante.  Moins évident est que la visualisation peut être une partie importante du jeu!  Par exemple, dans le jeu <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> , prendre des pièces sera complètement non évident en l'absence d'animation appropriée des mouvements. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  En général, la modularité semble une bonne idée pour un tel projet, et le code open source permettra à tous ceux qui souhaitent participer au projet.  À l'heure actuelle, je ne me fixe pas d'objectifs commerciaux, mais je pense que, si je le souhaite, je trouverai un moyen de gagner de l'argent sans fermer le code source. <br><br><h2>  L'espace de jeu </h2><br>  Avant de commencer le spectacle, vous devez préparer le terrain.  La planche n'est pas seulement un endroit où les pièces sont rangées.  En plus de cela, le sens de déplacement des pièces peut être déterminé (en fait, les connexions entre les positions du plateau), des zones de jeu (par exemple, des zones de conversion des pièces), des champs interdits, etc.  Voici à quoi ressemble la définition de l'échiquier dans l'implémentation ZoG: <br><br><div class="spoiler">  <b class="spoiler_title">Définition de la carte dans ZoG</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  Vous remarquerez peut-être qu'en plus des paramètres du jeu, voici les paramètres associés à la visualisation.  Je suis fermement convaincu que ces paramètres n'appartiennent pas ici.  Lors de la mise en œuvre d'un module de visualisation, plusieurs paramètres peuvent être utilisés et différents paramètres peuvent être requis.  De plus, les jeux de simulation peuvent fonctionner sans aucun module de visualisation (comme la lecture automatique dans Axiom).  En effet, puisque Axiom est utilisé pour visualiser ZoG, la définition ne contient rien de superflu: <br><br><div class="spoiler">  <b class="spoiler_title">Définition de la carte dans Axiom</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Malheureusement, Axiom n'a pas non plus de moyen de déterminer les zones de jeu (l'emplacement des zones de jeu doit être déterminé manuellement dans le code).  Ce n'est pas la seule simplification d'Axiom.  La définition de la carte dans ce projet ne peut pas contenir plus d'une grille et cette grille doit être bidimensionnelle.  La carte, ainsi définie, est un tableau unidimensionnel, mais pour la commodité du programmeur, des synonymes sont définis pour chacun des espaces comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  Comparées au schéma plus flexible de définition de grille dans ZoG, ces restrictions sont assez inconfortables (surtout compte tenu du fait que le schéma de nommage imposé utilisait ces champs dans le but même de la visualisation).  Heureusement, il est possible de définir une planche de forme arbitraire.  Axiom et ZoG offrent tous deux la possibilité d'identifier chaque élément sur la carte ainsi que la possibilité de déterminer les liens entre des paires de positions arbitraires.  En utilisant cette approche, nous pouvons définir une carte de n'importe quelle topologie.  Son seul inconvénient est l'extrême verbosité et la complexité de la description. <br><br>  En plus de l'emplacement des pièces sur le plateau et dans la réserve, le système devrait avoir la possibilité de stocker des attributs pour des pièces individuelles et pour les espaces sur le plateau.  Un bon exemple de la nécessité d'utiliser les attributs d'une règle de « <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">roque</a> » dans les <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">échecs</a> .  Il s'agit d'un mouvement difficile, qui comprend le mouvement simultané du roi et d'une tour, autorisé, à condition qu'aucune de ces pièces n'ait bougé avant d'effectuer ce mouvement.  Un attribut pourrait être utilisé pour stocker une balise booléenne indiquant si la pièce a déjà bougé.  Les attributs de champ peuvent également trouver des applications intéressantes. <br><br>  Il convient de noter que les attributs ne sont pas seulement des variables mais font partie de l'état du jeu.  Une valeur d'attribut peut être modifiée par l'exécution d'un tour (y compris par le module AI) et devrait être disponible pour tous les tours suivants, mais pas pour les tours effectués dans une autre branche du jeu.  Actuellement, ZoG prend en charge le stockage des attributs booléens des pièces.  Les attributs de stockage Axiom ne sont pas pris en charge, mais vous pouvez ajouter à la définition de la carte une description des variables et des tableaux.  Ces variables peuvent être utilisées, telles que les compteurs de la quantité de pièces capturées: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Encore une autre limitation de ZoG et d'Axiom est la règle selon laquelle chaque position de la planche ne peut contenir plus d'une pièce.  Si une pièce complète un mouvement vers une position occupée par une autre pièce, la pièce occupant précédemment la position est automatiquement considérée comme «mangée».  Cette règle va bien avec le principe «d'échecs» de prendre des pièces et sert à simplifier la description de ce jeu, mais complique la mise en œuvre de jeux tels que « <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">bashni checkers</a> » et « <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> ». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  Dans ces jeux, les pièces peuvent être organisées en «colonnes».  Une telle «colonne» peut être déplacée tous ensemble, comme une seule pièce.  Après réflexion, j'ai décidé qu'il valait mieux ne pas abandonner l'implémentation automatique de la capture «Chess», mais améliorer les mécanismes de déplacement des groupes de pièces.  En effet, pour l'implémentation des «piliers», vous pouvez toujours ajouter à bord une autre dimension (c'est particulièrement facile, tant que le module de visualisation est séparé du module de génération de mouvement et de l'IA, alors vous pouvez utiliser n'importe quelle logique que ce soit pour rendre la carte en trois dimensions dans sa visualisation en deux dimensions).  Un autre argument en faveur de cette décision était que le mouvement de pièces «à empilement élevé» n'est pas le seul type de voyage de groupe.  Par exemple, dans les panneaux « <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> », les fragments peuvent être tournés avec les pièces montées dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  En résumé, je peux dire que, pour mon cadre de jeu, j'ai décidé de prendre tout ce qui a été pensé dans ZoG, Axiom et Ludi, et d'ajouter tout ce qui, à mon avis, leur manque. <br><br><h2>  Déplacer la génération </h2><br>  La génération de mouvements s'apparente à <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">une programmation non déterministe</a> .  La tâche du générateur de déplacement fournit, sur demande, une liste de tous les déplacements possibles à partir de la position actuelle.  Le mouvement de cette liste sera sélectionné par un joueur ou l'IA n'est pas sa fonction.  Voyons comment la génération de mouvements se fait dans ZoG.  À titre d'exemple, nous prenons la macro de génération de mouvement pour une pièce à longue portée (une reine ou un évêque).  Voici comment il est utilisé pour déterminer les mouvements de ces pièces: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  En paramètre, une macro passe la direction du mouvement sur la planche.  Si vous n'envisagez pas la possibilité d'installer de nouvelles pièces sur la planche, la génération d'un coup semble simple.  Pour chacune des pièces du plateau, tous les mouvements possibles selon les règles sont calculés.  Puis la magie commence ... <br><br>  Chacune des définitions peut ajouter à la liste un certain nombre de mouvements possibles!  L'ajout d'un coup à la liste se fait avec la commande add (en positionnant en même temps chaque pièce en mouvement sur le plateau).  J'ai déjà <a href="https://habr.com/ru/post/221779/">écrit</a> à quel point cette solution architecturale est extrêmement pauvre.  La commande pour la formation du mouvement doit être séparée des commandes qui manipulent les pièces (comme cela a été fait dans Axiom).  Voyons comment fonctionne la macro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Tout d'abord, le déplacement est effectué par une cellule, dans la direction donnée, puis dans un cycle, l'espace atteint est vérifié pour l'absence des pièces dessus, un mouvement est formé et l'arrangement se poursuit vers une autre cellule dans la même direction.  Si vous vous arrêtez ici, la pièce peut «glisser» à travers des cellules vides, mais comment pouvez-vous prendre des pièces ennemies? <br><br>  Très simple!  Après avoir exécuté la commande Verify, la vérification que le champ n'est pas occupé par une pièce amie, nous formons une autre commande d'ajout, terminant le déplacement.  Si sur cette cellule se trouvait une pièce ennemie, elle sera prise automatiquement (comme sur une case du plateau, à la fois, vous ne pouvez pas avoir plus d'une pièce).  Si la pièce était conviviale, le calcul du coup sera abandonné avec la commande vérifier (la violation des conditions spécifiées dans cette commande met immédiatement fin au calcul du coup en cours). <br><br>  Dans ZoG et Axiom, on ne peut déplacer que ses propres pièces (ou plutôt, déplacer les pièces de l'adversaire est possible, mais uniquement si cela est spécifié dans le mode de calcul d'un déplacement d'une de ses propres pièces).  Je trouve que c'est une restriction extrêmement gênante, car il existe de nombreux jeux dans lesquels vous pouvez déplacer directement la pièce de l'adversaire (dans « <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> », par exemple).  Il serait plus cohérent d'effectuer le calcul de déplacement pour toutes les pièces, quelle que soit leur affiliation.  Dans la macro qui détermine le mouvement, il suffirait d'ajouter une seule vérification pour permettre de déplacer uniquement ses propres pièces: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Il est important de pouvoir exécuter un mouvement composé de plusieurs mouvements «partiels».  Dans les implémentations de brouillons, cette capacité est utilisée pour effectuer des captures «en chaîne»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  La commande de déplacement partiel est formée avec add-partial (pour cette commande, ainsi que pour la commande add, il y a une variation du déplacement, avec «transformation» des pièces).  Un tel mouvement fait toujours partie d'un mouvement plus large et «composite».  En règle générale, pour les mouvements ultérieurs, un «mode» est défini, que la suite doit implémenter.  Ainsi, dans les dames, une capture ne peut se poursuivre qu'avec les captures suivantes, mais pas avec un mouvement «doux» (sans capture). <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Dans ZoG, l'implémentation des déplacements partiels est médiocre.  Essayer d'exécuter la commande add-partial dans un cycle provoque une erreur.  En conséquence, la capture effectuée par un roi vérificateur ne peut être réalisée que de la manière très maladroite suivante: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  Et ainsi de suite, jusqu'à king-jump-7!  Permettez-moi de vous rappeler que dans la plupart des variétés de pions avec un roi «à longue portée», le roi, après chaque capture, peut s'arrêter sur n'importe quel espace d'une chaîne continue d'espaces vides suivant la pièce capturée.  Il existe d'ailleurs une variante de ce jeu dans laquelle la règle de capture «chaîne» est formulée différemment.  C'est exactement ce que j'aime chez les dames - tout le monde peut trouver une variante à son goût. <br></div></div><br>  Un tel système de description des règles est très flexible, mais une logique parfois plus complexe est nécessaire.  Par exemple, si la pièce, lors d'une progression «partielle», ne doit pas repasser à travers un champ précédemment parcouru, il est logique d'utiliser les drapeaux associés aux positions sur la carte.  Après avoir visité un espace, nous avons mis un drapeau, donc par la suite de ne plus y retourner: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  En plus des indicateurs «positionnels», dans ZoG, vous pouvez utiliser des indicateurs globaux.  Ces capacités ne doivent pas être confondues avec les attributs des pièces.  Contrairement à ce dernier, ceux-ci ne font pas partie de l'état du jeu.  Malheureusement, les attributs des pièces et des drapeaux dans ZoG ne peuvent être que booléens (dans Axiom, les attributs ne sont même pas pris en charge).  Cette limitation rend difficile l'exécution d'opérations associées aux différents types de comptage.  Par exemple, dans <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">ce</a> petit casse-tête, je devais utiliser pour «compter» des pièces, prises dans une «fourchette», une paire de drapeaux booléens (le nombre exact dont je n'avais pas besoin, tant que les pièces étaient plus d'une). <br><br>  Une autre chose à corriger est l'absence d'un «cycle de vie» clair dans l'exécution du déménagement.  Tous les drapeaux sont automatiquement réinitialisés avant de commencer le déplacement, mais il serait plus facile d'identifier clairement la phase d'initialisation.  À mon avis, dans le calcul du déménagement, il devrait se produire les phases suivantes: <br><br><ol><li>  Initialisation des variables et vérification des conditions préalables au mouvement composite </li><li>  Initialisation des variables et vérification des conditions préalables au déplacement partiel </li><li>  Génération du mouvement partiel </li><li>  Vérification des postconditions du déménagement partiel </li><li>  Génération, achèvement et vérification des postconditions du mouvement composite </li><li>  Vérification des conditions de résiliation du jeu </li></ol><br>  Le groupe d'étapes de la deuxième à la quatrième, dans le mouvement composite complet, peut être répété plusieurs fois.  L'idée de pré- et post-conditions, que j'appelle des invariants, je me suis inspirée du projet Ludi.  Je vous en dirai plus sur l'utilisation des invariants plus tard. <br><br><h2>  Sur l'importance de la notation </h2><br>  La génération de tous les mouvements possibles à partir de la position n'est que la moitié de l'histoire.  Pour contrôler l'état du jeu, une présentation compacte des mouvements générés est nécessaire.  Dans ZoG, à cet effet, la notation ZSG est utilisée.  Voici un compte rendu d'un début possible d'une partie d'échecs sous cette forme: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Ce script est proche de la <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">notation d'échecs</a> habituelle et généralement convivial.  Seul le quatrième coup du blanc peut semer la confusion.  Donc, dans ZSG, cela ressemble à du <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">roque</a> .  La partie de la description du déplacement avant le caractère «@» est assez claire;  c'est le mouvement simultané de la tour et du roi, mais qu'est-ce qui suit?  Ainsi, dans ZSG, il semble qu'une réinitialisation des attributs des pièces soit nécessaire afin d'éviter la possibilité de roque répétée. <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  ZoG utilise sa notation ZSG en particulier pour montrer le déroulement du jeu sous une forme compréhensible par le joueur.  À droite du tableau, une sous-fenêtre "Liste des mouvements" peut être ouverte.  Cette liste peut être utilisée pour naviguer dans le jeu enregistré.  Cette liste n'est pas très pratique, car une arborescence de branchements de jeux alternatifs n'est pas prise en charge.  La partie des tours enregistrés associée aux changements d'attributs des pièces, n'est pas affichée à l'utilisateur. <br></div></div><br>  L'enregistrement d'un coup en notation ZSG doit contenir des informations complètes suffisantes pour changer correctement l'état du jeu.  Si des informations sur un changement d'attributs sont perdues, dans un jeu selon un tel record, un mouvement pourrait être incorrectement répété (par exemple, le joueur aurait la possibilité de réexécuter le roque).  Malheureusement, dans les extensions DLL (comme Axiom), les informations étendues ne peuvent pas être transmises. <br><br>  En travaillant avec les extensions DLL, ZoG est obligé de faire une manipulation assez astucieuse lors du positionnement sur un mouvement sélectionné (par exemple, lorsque vous annulez un mouvement).  À partir de [chaque] position précédente [depuis le début du jeu], tous les coups possibles sont générés, puis, dans cette liste, il faut rechercher un coup avec la représentation ZSG [correspondante].  Les [effets secondaires de chaque] mouvement généré sont appliqués à [chaque état de jeu] successif, car il est possible d'effectuer des effets secondaires non reflétés dans la représentation ZSG du mouvement. <br><br>  La situation est aggravée par le fait que la seule façon d'accéder à l'état de jeu lors d'un coup dans le passé est l'application cohérente de tous les coups depuis le début de la partie jusqu'à l'état initial du plateau.  Dans <a href="https://habr.com/ru/post/234587/">des cas</a> vraiment <a href="https://habr.com/ru/post/234587/">complexes</a> , ce type de navigation ne se fait pas rapidement.  Un autre inconvénient de la notation ZSG peut être illustré par l'enregistrement du mouvement suivant dans le jeu de <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go</a> : <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Ici, dans la position G19, une pierre blanche est placée qui capture un groupe de pierres noires.  Étant donné que toutes les pièces impliquées dans la performance du placement doivent être mentionnées dans la performance ZSG, l'enregistrement du tour peut sembler très long (en Go, une goutte peut capturer jusqu'à 360 pierres).  À quoi cela peut conduire, j'ai écrit <a href="https://habr.com/ru/post/235483/">plus tôt</a> .  La taille de la mémoire tampon allouée pour l'enregistrement du mouvement ZoG peut ne pas être suffisante.  De plus, si pour une raison quelconque l'ordre de retrait des pierres change (dans le processus de développement du jeu, cela se produit), une tentative d'application d'un mouvement, d'un ancien ordre de captures, échouera. <br><br>  Heureusement, il existe un moyen simple de résoudre tous ces problèmes.  Voyons comment définir les mouvements de pièces dans ZRF: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  Les noms de mouvements, définis dans les macros ZoG, sont inaccessibles en tant que générateur de mouvements.  Mais qu'est-ce qui nous empêche de renoncer aux macros et de décrire les mouvements avec leurs noms?  Voici à quoi ressemblerait le dossier pour une partie d'échecs: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Les lecteurs astucieux peuvent remarquer que dans les mouvements pour «noir», j'ai utilisé des directions non appropriées aux directions réelles sur l'échiquier.  Ceci est lié au fait que des «symétries» sont définies pour le noir: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  En gros, alors, pour le blanc, c'est «nord», pour noir, c'est «sud», et vice versa. <br></div></div><br>  Les avantages d'un tel enregistrement ne sont pas évidents, mais il présente un avantage important.  Tous les mouvements sont décrits de manière uniforme et ces descriptions ne contiennent rien de plus (les noms des descriptions de mouvements, bien sûr, pourraient être rendus plus «descriptifs»).  Dans la description du roque, on a réussi à se débarrasser à la fois des changements d'attributs et de la description du déplacement de la tour (cette description ne dépend plus des détails d'implémentation du déplacement).  Une utilité encore plus claire de ces enregistrements existe dans le cas du jeu de Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  Et c'est tout!  Si les pierres de l'adversaire sont prises conformément aux règles du jeu, il n'est pas nécessaire de toutes les énumérer dans la description du coup.  Il suffit d'indiquer l'espace de déplacement initial et final (éventuellement avec un signe à prendre), le nom du mouvement en cours d'exécution et la ligne de paramètres qui lui est passée.  Bien sûr, pour effectuer un déplacement selon cette description, pour le décodage, il est nécessaire d'accéder au module de génération de déplacement, mais ZoG le fait! <br><br>  Une autre possibilité, que l'on devrait prendre en charge, apparaît dans la fonctionnalité des déplacements «partiels».  Voici un exemple de « <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">dames russes</a> »: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Ici, les noirs, à leur deuxième coup, prennent deux pièces en d4 et f4.  Une «transformation» préliminaire de ces pièces en XChecker est une caractéristique de cette implémentation et sert à empêcher la reprise des pièces «vaincues» du même coup.  L'expression «partielle 2» décrit le début d'un cours «composite», qui consiste en deux mouvements «partiels».  Cette forme de description n'est pas pratique, car au moment de la génération du premier mouvement, la durée de la séquence de mouvements "partiels" peut ne pas être connue.  Voici à quoi ressemblera cette description dans un nouveau format: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Les détails de mise en œuvre liés à la «transformation» des pièces ne sont pas pertinents.  La capture des pièces n'est pas non plus spécifiée, car dans les dames, la capture se produit comme un «effet secondaire» du mouvement de la pièce et non selon le «principe des échecs». La progression partielle sera codée avec le symbole «+» au début de la ligne.  Un seul «+» indique la fin d'un «coup composite» (en fait, c'est le coup «partiel» habituel, contenant un coup manquant, une chaîne vide). <br><br>  Ainsi, en utilisant des règles nommées pour l'implémentation des mouvements, on a réussi à créer une notation universelle, satisfaisant pleinement nos exigences.  Bien sûr, cela n'a rien à voir avec les échecs standard ou avec toute autre notation, mais il se trouve que la notation conventionnelle des échecs, des dames et d'autres jeux n'a rien à voir entre eux.  Le module de visualisation peut toujours convertir l'enregistrement de mouvement en une forme plus familière acceptée pour un jeu particulier.  La conversion peut également prendre une forme universelle, comme <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  Le cycle de vie du jeu </h2><br>  En plus des informations sur le placement de pièces sur le plateau, la séquence de tours fait partie intégrante de l'état du jeu, une variable dans le processus de jeu.  Dans le cas le plus simple (et le plus courant), pour stocker ces informations, un bit suffira, mais ZoG offre quelques opportunités supplémentaires pour implémenter des cas plus complexes.  Voici à quoi pourrait ressembler une description d'une séquence de mouvements pour le jeu <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  Dans ce jeu, chaque joueur fait trois coups à la fois, mais si vous donniez au premier joueur la possibilité de faire trois coups à partir de la position initiale, il pourrait détruire l'une des pièces de l'adversaire, ce qui lui donnerait un avantage significatif.  Pour cette raison, le premier joueur ne doit effectuer qu'un seul coup (cela donne la possibilité de se préparer à attaquer un joueur adverse, mais pas à l'attaquer), le second - deux coups (ce n'est pas non plus suffisant pour attaquer un joueur adverse), après où chaque joueur fait toujours trois coups. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  La répétition d'étiquette indique le début d'une séquence cyclique répétitive de mouvements.  S'il n'apparaît pas, la description complète est répétée cycliquement.  ZoG ne permet pas de répéter l'utilisation de l'étiquette plus d'une fois.  Une autre caractéristique importante est la spécification de l'ordre du tour.  Voici à quoi pourrait ressembler une description de la séquence de tours d'un jeu dans lequel chaque joueur effectue deux tours (le premier coup - déplacer des pièces, le second - capturer les pièces de l'adversaire): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  Il y a une capacité supplémentaire associée à la description du déplacement des pièces de quelqu'un d'autre, mais il est très gênant à utiliser.  Le problème est qu'une telle description n'a pas d'alternative.  Si la description indique que le mouvement doit être effectué par une pièce ennemie, le joueur doit effectuer ce mouvement!  Dans ZoG, il est impossible de décrire un choix de déplacer sa propre pièce ou celle d'une autre personne.  Si une telle capacité est nécessaire dans un jeu (comme dans " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> "), il est nécessaire de rendre toutes les pièces neutres (créant à cet effet un joueur qui ne participe pas au jeu) et de déterminer pour tous les joueurs l'opportunité pour déplacer une pièce neutre.  J'ai dit ci-dessus qu'il est beaucoup plus facile par défaut de permettre à tous les joueurs de déplacer n'importe quelle pièce (la leur ainsi que celle de leur adversaire) en ajoutant les vérifications nécessaires dans les algorithmes de génération de mouvement. <br><br>  Comme vous pouvez le voir, la gamme d'options fournies par ZoG pour la description de la séquence de virages est extrêmement limitée.  Axiom échoue également à ajouter de nouvelles fonctionnalités, car il s'exécute (généralement) sur ZoG.  Ludi, à cet égard, est encore plus pauvre.  Afin de maximiser l'unification des règles du jeu (nécessaire pour la possibilité d'utiliser des algorithmes génériques), dans ce projet, toutes les capacités descriptives ont été délibérément simplifiées, ce qui a entraîné une élimination de couches entières de jeux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " est un bon exemple d'un jeu avec un cycle de vie complexe. Dans ce jeu, il y a deux phases avec des règles d'exécution de mouvement qui diffèrent considérablement. Au début du jeu, une partie des pierres est "dans la main" "De chaque joueur. Alors qu'il y a encore des pierres" en main ", des pierres sont mises dans les puits, une pierre à la fois. Lorsque les pierres" en main "s'épuisent, la deuxième phase du jeu commence, avec la distribution des insérés On ne peut pas dire que ce jeu ne peut pas être décrit dans ZRF (le langage de description de ZoG), mais en raison des limites de ZoG, cette mise en œuvre serait extrêmement déroutante (ce qui n'est certainement pas le meilleur pour la qualité du travail de l'IA). Voyons à quoi ressemblerait la description d'un tel jeu dans un «monde idéal»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Ici, chaque liste d'ordre de tour détermine sa séquence répétée de mouvements (en se distinguant par le mode d'exécution du mouvement).  Le mot-clé label définit un label vers lequel une transition peut être effectuée lors de la génération du dernier mouvement.  Vous remarquerez peut-être que nous partons ici de l'hypothèse implicite qu'une telle transition se produit toujours après le coup du deuxième joueur (sinon cela violerait la séquence des coups).  Comment faire la transition vers la phase suivante à un moment arbitraire? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Ici, les étiquettes sont portées dans le corps de la boucle et comprennent deux noms.  Les noms d'étiquette dans les listes d'étiquettes apparaissent dans l'ordre de transfert des joueurs dans la liste des joueurs.  Le nom utilisé pour la transition est déterminé par le joueur qui a fait le dernier mouvement.  S'il s'agissait du Nord, il passera à la première étiquette, sinon, à la seconde.  Si aucun des noms des étiquettes n'est utilisé, la position correspondante peut être remplie par un tiret. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Un aspect important dans la gestion des mouvements alternés est la possibilité d'effectuer un tour répété.  Dans les jeux de la <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">famille Tables</a> , comme <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Backgammon</a> ou <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , par exemple, la possibilité d'effectuer des tours répétés est un élément important des tactiques de jeu.  Dans ZoG, on peut utiliser passer un tour pour émuler cette fonctionnalité, mais cette approche complique considérablement la description du jeu (en particulier avec plus de joueurs).  Il serait beaucoup plus logique d'utiliser une étiquette pour répéter un tour: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Le jeu ayant sauté sur la répétition de l'étiquette, le joueur jouera à nouveau son tour (l'étiquette la plus proche de la position actuelle dans la liste des tours prendra effet).  J'aime l'approche de <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> dans ses définitions implicites.  La génération implicite de structures de contrôle peut simplifier considérablement la description du jeu.  Dans la mesure où des mouvements répétés peuvent être utilisés dans de nombreux jeux, les étiquettes se répètent, anticiper la répétition possible d'un tour peut être implicite: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  De plus, puisque la séquence de tours est entièrement cohérente avec l'ordre écrit des joueurs dans la construction des joueurs, vous pouvez générer automatiquement la phrase d'ordre de tour entière: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Plus la description est facile à écrire, mieux c'est. <br><br><h2>  Invariant cassable </h2><br>  La principale chose que je n'aime pas dans ZoG peut être exprimée en un seul mot - échec et mat.  À première vue, c'est juste une condition (très courante dans les jeux de la <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">famille des échecs</a> ) liant la fin de la partie à la formation d'un partenaire.  Hélas, à y regarder de plus près, la simplicité se révèle trompeuse.  L'utilisation de ce mot-clé signifie non seulement l'exécution, après chaque coup, d'une vérification de la fin du jeu, mais impose également au joueur un certain «comportement». <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Du <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi</a> habituel, ce jeu ne diffère que par le nombre de joueurs.  Malheureusement, cette différence est suffisante pour rendre incorrect le travail de détermination du mat (et tout ce qui est associé à ce mot «magique»).  La vérification de la mise en échec n'est effectuée que par rapport à l'un des joueurs.  En conséquence, le roi peut devenir attaqué et être dévoré [par une combinaison de tours d'adversaires même lorsqu'il n'est pas laissé en «échec»]!  Que ce ne soit pas optimal se reflétera dans le travail de l'IA. <br><br>  Si ce problème semble insignifiant, il convient de rappeler que les coalitions se forment généralement dans des parties à quatre joueurs «paire contre paire».  Dans le cas de la formation de coalitions, il faut considérer que des pièces amies au roi ne le menacent pas!  Ainsi, par exemple, deux rois amis peuvent bien résider sur les espaces voisins du plateau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Cela devient plus compliqué que jamais si un joueur peut avoir plusieurs rois.  Dans " <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">Échecs Tamerlan</a> ", le pion royal se transforme en prince (en fait, un deuxième roi).  Si cela se produit, vous ne pouvez gagner qu'en capturant le premier roi (l'un des deux) et en accouplant le second.  Dans ce jeu, vous pouvez même obtenir un troisième roi, doublant les dépenses pour la transformation du «pion des pions»!  Les capacités expressives de «échec et mat» ne suffisent pas à décrire adéquatement cette situation. <br><br>  Une autre difficulté peut être le processus même de donner du maté.  Ainsi, aux échecs mongols ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ), le résultat de la tentative d'accouplement dépend de l'ordre dans lequel les pièces exécutent le «contrôle» séquentiel.  Le résultat peut s'avérer être soit une victoire ou un match nul (comme un pion par un pion), soit même une défaite (pote de cheval interdit, mais vous pouvez donner un chèque).  À cet égard, le shogi japonais est un peu moins exotique.  Dans ce jeu, il est interdit de donner un compagnon avec un pion abandonné, mais vous pouvez donner un chèque avec un pion abandonné et donner un compagnon avec un pion déplacé. <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Il y a un autre point important à mentionner.  Dans certains jeux, comme Rhythmomagic, il peut y avoir plusieurs façons de terminer le jeu.  Le moyen le plus évident de gagner, impliquant la destruction des pièces de l'adversaire, est également le moins préféré.  Pour une victoire plus significative, il faut disposer ses pièces sur le territoire ennemi selon un certain schéma. <br><br>  Il faut distinguer les types de victoires (et de défaites et de nuls) au niveau de la description du jeu, car le type de fin de jeu peut avoir de l'importance pour le joueur.  De plus, il devrait être possible d'attribuer des priorités numériques aux différentes fins de jeu.  Lors de la réalisation simultanée de plusieurs conditions d'achèvement, celle qui a la priorité la plus élevée doit compter. <br></div></div><br>  Évidemment, il faut séparer la logique de vérification de la fin de partie du test du roi tombé en échec, qui est une <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">règle invariable</a> qui est vérifiée après chaque tour.  La violation de la règle rend impossible l'exécution du mouvement (le mouvement est supprimé de la liste des mouvements disponibles).  Ainsi, un test (simplifié) pour un roi en échec pourrait ressembler à ceci pour "les échecs de Tamerlan": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Il est important de comprendre que ce test ne doit être effectué que pour ses propres rois (j'ai utilisé le prédicat mon?, Parce que le prédicat ami?, Avec le soutien des coalitions, sera satisfait non seulement pour ses propres pièces, mais aussi pour le morceaux de tous les joueurs amis).  Acceptable (et souhaitable, [s'il y a plusieurs rois amis]) est la situation dans laquelle le roi ennemi tombe sous contrôle, après un mouvement, mais par son propre roi.  Cette situation devrait être impossible [à moins qu'il y ait plusieurs rois amis]!  Après avoir fourni un support pour vérifier ces règles, vérifier la fin du jeu par échec et mat devient trivial.  S'il n'y a pas de coups possibles et que le [seul] roi est en échec, la partie est terminée [si ce roi appartient au dernier joueur survivant de l'avant-dernière coalition survivante]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  La capacité de déterminer les invariants sera utile dans d'autres jeux, comme les <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">dames</a> .  La plus grande difficulté dans la mise en œuvre des jeux de cette famille, est liée à la mise en œuvre de la «règle de la majorité».  Dans presque tous les jeux de dames, la capture est obligatoire.  De plus, dans la plupart des jeux de cette famille, il y a une réalisation caractéristique des «captures de chaîne» en un seul tour.  Le vérificateur, après avoir capturé, continue de prendre d'autres pièces, si possible.  Dans la plupart des jeux, le joueur doit effectuer des captures de chaîne jusqu'à la fin, mais il existe des exceptions à cette règle, par exemple <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  En utilisant le mécanisme des mouvements partiels, la mise en œuvre d'une «capture en chaîne» est assez simple.  Des difficultés surgissent lorsque, de plus, on impose une condition dans laquelle, de toutes les options possibles, on doit choisir une chaîne dans laquelle un nombre maximal de pièces est capturé.  Dans ZoG, cette logique doit être implémentée à partir de zéro au niveau du «hardcoding»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Ce paramètre convient aux « <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">contrôleurs internationaux</a> », mais dans les « <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">contrôleurs italiens</a> », la règle de la majorité est formulée différemment.  Dans cette version du jeu, s'il existe plusieurs options pour le même nombre de captures, vous devez sélectionner une option qui capture le plus grand nombre de pions transformés (rois).  Les développeurs de ZoG l'ont fourni.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous entrez le paramètre suivant: </font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cadre, on compte non seulement le nombre de pièces capturées, mais aussi leur type. </font><font style="vertical-align: inherit;">Malheureusement, tout n'est pas prévisible. </font><font style="vertical-align: inherit;">Voici comment la «règle de la majorité» est formulée dans les «vieux dames françaises»:</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si par une série de captures il est possible de capturer le même nombre de pions avec un homme simple ou avec un roi, le joueur doit utiliser le roi. </font><font style="vertical-align: inherit;">Cependant, si le nombre de pions est le même dans les deux cas, mais dans l'un il y a un roi ennemi (ou il y en a plus), le joueur doit choisir cette option, même si la capture se fait ensuite à l'aide du simple pion, et non en utilisant le roi.</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, à l'heure actuelle, presque personne ne joue cette version des dames, mais son existence même démontre clairement les lacunes de la mise en œuvre «codée en dur». </font><font style="vertical-align: inherit;">L'utilisation du mécanisme des invariants permet toutes les options possibles pour la «règle de la majorité» de manière universelle. </font><font style="vertical-align: inherit;">Pour les « </font></font><a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vieux dames françaises</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> », la mise en œuvre serait la suivante:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous supposons que les règles de génération de capture remplissent correctement [les] variables locales suivantes: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture-count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nombre total de pièces capturées</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture-sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nombre de rois capturés</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacking-value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valeur de la capture de pièce</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À chacune de ces variables est associé un accumulateur de valeurs, stocké dans une variable avec le préfixe max. Les trois contrôles sont exécutés en série. La violation de l'une des conditions de vérification interrompt immédiatement la génération de l'option de tour suivant (la capture n'est pas stockée dans la liste des tours possibles). Les contrôles effectués étant associés à des valeurs variables, il ne suffit pas [de tester uniquement la nouvelle option de capture actuelle]. Chaque test génère une «règle flexible» associée à la capture générée [qui peut réviser la valeur maximale accumulée]. Après chaque modification d'un accumulateur, toutes les règles associées doivent être vérifiées à nouveau [pour chaque option de la liste]. Si l'une des conditions n'est pas respectée pour une option générée précédemment, cette option doit être supprimée de la liste des options de virage possibles.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est la traduction de mon article de l'année 2014. </font><font style="vertical-align: inherit;">Depuis, j'ai beaucoup repensé et le </font></font><a href="https://glukkazan.github.io/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet Dagaz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est devenu réalité, mais je n'ai presque rien changé dans le texte. </font><font style="vertical-align: inherit;">Cet article a été traduit par mon ami </font></font><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Howard McCay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et je lui suis reconnaissant pour le travail accompli.</font></font><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481868/">https://habr.com/ru/post/fr481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481854/index.html">Tester des idées grâce au prototypage de tableaux de bord</a></li>
<li><a href="../fr481858/index.html">Anniversaires sur Google Agenda avec l'âge</a></li>
<li><a href="../fr481860/index.html">Que devrait faire l'informatique en 2020?</a></li>
<li><a href="../fr481862/index.html">Nvidia Jetson Embedded Machine Learning Systems</a></li>
<li><a href="../fr481866/index.html">DBA: lorsque le vide passe - nous nettoyons la table manuellement</a></li>
<li><a href="../fr481874/index.html">Métriques - indicateurs de la santé du projet</a></li>
<li><a href="../fr481880/index.html">Physique pour un tireur PvP mobile et comment nous nous sommes liés d'amitié avec ECS</a></li>
<li><a href="../fr481882/index.html">4. Mise en route de Fortinet v6.0. Stratégies de pare-feu</a></li>
<li><a href="../fr481884/index.html">Carrefour des seniors: où aller ensuite?</a></li>
<li><a href="../fr481886/index.html">Comment créer rapidement un journal de présence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>