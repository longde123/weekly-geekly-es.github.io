<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¨ ğŸ¤° ğŸ© Dagaz: un nouveau dÃ©part ğŸ’˜ ğŸ‘©â€ğŸ”§ ğŸš¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il court au sud et tourne au nord, encerclant, encerclant pour courir avec son vent 
 Et selon ses circuits le vent revient; 
 Toutes les riviÃ¨res se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: un nouveau dÃ©part</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Il court au sud et tourne au nord, encerclant, encerclant pour courir avec son vent</i></b> <b><i><br></i></b>  <b><i>Et selon ses circuits le vent revient;</i></b> <b><i><br></i></b>  <b><i>Toutes les riviÃ¨res se jettent dans la mer - et la mer ne dÃ©borde pas,</i></b> <b><i><br></i></b>  <b><i>Ã€ l'endroit oÃ¹ les fleuves coulent, - LÃ , ils continuent de couler;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">Le livre des ecclÃ©siastes</a></i></b> <br><br>  En 1998, une application tout Ã  fait unique, pour son Ã©poque, a Ã©tÃ© dÃ©veloppÃ©e qui vous permet de rÃ©duire le processus de dÃ©veloppement d'un jeu de sociÃ©tÃ© abstrait (ou puzzle) Ã  un petit langage de description de texte, rappelant vaguement <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> .  Ce projet s'appelait <a href="http://www.zillions-of-games.com/" rel="nofollow">Zillions of Games</a> .  Cela a fait fureur parmi les fans de jeux de sociÃ©tÃ©.  Actuellement, plus de 2 000 applications ont Ã©tÃ© crÃ©Ã©es Ã  l'aide de cette technologie. <br><a name="habracut"></a><br>  Il est rapidement devenu Ã©vident que ZoG avait de nombreux inconvÃ©nients.  J'ai dÃ©jÃ  <a href="https://habr.com/ru/post/221779/">Ã©crit</a> Ã  ce sujet dans Habr et je ne vais pas me rÃ©pÃ©ter.  Permettez-moi simplement de dire que les dÃ©veloppeurs n'ont pas pris en compte les caractÃ©ristiques d'un grand nombre de jeux existants et que certaines options importantes ont Ã©tÃ© codÃ©es en dur, de sorte que leur changement est devenu extrÃªmement problÃ©matique.  Greg Schmidt, en 2007, a tentÃ© de rectifier la situation en publiant le <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">kit de dÃ©veloppement Axiom</a> , mais son intÃ©gration Ã©troite avec ZoG ne permet pas de rÃ©soudre tous les problÃ¨mes. <br><br>  Le projet <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi a</a> mis en Ã©vidence de nouvelles frontiÃ¨res, en utilisant le Â«moteurÂ» de jeu universel et <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">des algorithmes gÃ©nÃ©tiques</a> pour automatiser le processus de dÃ©veloppement de nouveaux jeux de sociÃ©tÃ©.  Malheureusement, cette approche a Ã©tÃ© initialement envisagÃ©e comme une simplification dÃ©libÃ©rÃ©e des mÃ©canismes de jeu et du niveau de l'IA employÃ©e.  La discussion des objectifs de ce projet dÃ©passe le cadre de cet article, mais certaines de ses solutions techniques ont sans aucun doute servi de point de dÃ©part Ã  mon propre dÃ©veloppement. <br><br>  Mon objectif est le dÃ©veloppement d'un Â«moteurÂ» plus polyvalent et convivial pour la crÃ©ation de jeux de sociÃ©tÃ© abstraits.  Depuis prÃ¨s d'un an, j'Ã©tudie la possibilitÃ© de ZoG et Axiom et j'ai beaucoup appris sur leurs limites.  Je pense que je peux rÃ©soudre leurs problÃ¨mes en crÃ©ant une solution plus universelle et multiplateforme.  Sur l'Ã©tat d'avancement des travaux sur ce projet, je ferai rapport. <br><br><h2>  Ouverture et modularitÃ© </h2><br>  Peut-Ãªtre que le principal inconvÃ©nient de ZoG est sa fermeture.  Le produit a Ã©tÃ© assemblÃ© Â«une fois pour toutesÂ» sous une seule plate-forme - Windows.  S'il s'agissait de code open-source, on pourrait essayer de le porter sous Linux, Android, iOS ... Un autre problÃ¨me est sa monolithicitÃ©. <br><br>  Dans ZoG, il y a les dÃ©buts de la modularitÃ©, permettant la connexion Ã  la DLL de jeux, y compris les implÃ©mentations personnalisÃ©es de l'IA.  Axiom va un peu plus loin, vous permettant d'exÃ©cuter des applications en mode de lecture automatique, sans utiliser le noyau ZoG.  MalgrÃ© les sÃ©rieuses limitations de cette solution (ne prenant en charge les applications que pour deux joueurs), cet exemple montre Ã  quel point la modularitÃ© serait utile!  L'opportunitÃ© d'organiser un jeu avec deux bots (en utilisant diffÃ©rents paramÃ¨tres d'IA) et de collecter des statistiques sur un grand nombre de jeux ne peut pas Ãªtre surestimÃ©e.  Mais combien il serait prÃ©fÃ©rable que le produit soit entiÃ¨rement modulaire! <br><br><ul><li>  Module de gÃ©nÃ©ration de mouvements </li><li>  DÃ©placer le module d'exÃ©cution </li><li>  Module de commande </li><li>  Module AI </li><li>  Module de visualisation </li></ul><br>  Tout le travail dÃ©crivant les jeux doit Ãªtre effectuÃ© par le module de gÃ©nÃ©ration de mouvements.  C'est le Â«cÅ“urÂ» du projet.  Le transfert de toutes les tÃ¢ches non liÃ©es Ã  cette fonction vers d'autres modules le rendra aussi simple que possible.  Vous pouvez amÃ©liorer ce module, sans regarder les problÃ¨mes d'IA et l'interaction des utilisateurs.  Vous pouvez changer complÃ¨tement le format de la description des jeux ou ajouter un support pour les descriptions au format ZoG, Axiom et Ludi.  La modularitÃ© est la base de la flexibilitÃ© de la solution! <br><br>  Le module d'exÃ©cution des mouvements est le gardien de l'Ã©tat du jeu.  Les informations sur l'Ã©tat actuel du jeu sont transfÃ©rÃ©es Ã  tous les autres modules sur demande.  Pour les raisons que je donnerai ci-dessous, la progression de l'exÃ©cution doit passer par le module de gÃ©nÃ©ration, dont la tÃ¢che est la formation d'une commande en termes d'exÃ©cution du module.  De plus, la tÃ¢che du module de gÃ©nÃ©ration de mouvements est la configuration principale de l'espace de jeu, basÃ©e sur la description du jeu. <br><br>  Le module de contrÃ´le est en fait l'application elle-mÃªme.  Il demande au module de gÃ©nÃ©ration de coups une liste des coups possibles et change l'Ã©tat du jeu, en passant le coup sÃ©lectionnÃ© au module d'exÃ©cution des coups.  Le module de contrÃ´le peut Ãªtre connectÃ© pour jouer Ã  un ou plusieurs robots AI.  Autant que vous en avez besoin (et Ã©ventuellement diffÃ©rents)!  Le type d'unitÃ© de contrÃ´le est dÃ©terminÃ© par la rÃ©partition des tÃ¢ches.  Cela peut Ãªtre une lecture automatique pour collecter des statistiques de jeu, un serveur de jeu (il peut contrÃ´ler plusieurs magasins d'Ã©tat, menant un grand nombre de sessions de jeu) ou des applications individuelles pour jouer hors ligne. <br><br>  La possibilitÃ© de connecter diffÃ©rentes implÃ©mentations de l'IA amÃ©liorera la qualitÃ© du jeu.  Il est entendu que les modules du jeu d'Ã©checs et de go doivent utiliser des approches diffÃ©rentes.  Les jeux avec des informations incomplÃ¨tes et les jeux utilisant des donnÃ©es alÃ©atoires nÃ©cessitent Ã©galement une approche individuelle.  La mise en Å“uvre universelle de l'IA sera Ã©galement mauvaise pour tous les jeux!  L'IA de connexion modulaire permettra de comparer la Â«forceÂ» des algorithmes, y compris un mode de jeu Â«les uns aux autresÂ». Puisque l'architecture de l'IA est sÃ©parÃ©e de l'Ã©tat de stockage du jeu, une instance du bot de jeu peut prendre en charge un nombre illimitÃ© de sessions de jeu simultanÃ©ment. <br><br>  La visualisation du processus de jeu peut Ã©galement varier.  La premiÃ¨re chose qui me vient Ã  l'esprit sont les implÃ©mentations 2D et 3D.  La plate-forme pour laquelle l'application est en cours de dÃ©veloppement est Ã©galement importante.  Moins Ã©vident est que la visualisation peut Ãªtre une partie importante du jeu!  Par exemple, dans le jeu <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> , prendre des piÃ¨ces sera complÃ¨tement non Ã©vident en l'absence d'animation appropriÃ©e des mouvements. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  En gÃ©nÃ©ral, la modularitÃ© semble une bonne idÃ©e pour un tel projet, et le code open source permettra Ã  tous ceux qui souhaitent participer au projet.  Ã€ l'heure actuelle, je ne me fixe pas d'objectifs commerciaux, mais je pense que, si je le souhaite, je trouverai un moyen de gagner de l'argent sans fermer le code source. <br><br><h2>  L'espace de jeu </h2><br>  Avant de commencer le spectacle, vous devez prÃ©parer le terrain.  La planche n'est pas seulement un endroit oÃ¹ les piÃ¨ces sont rangÃ©es.  En plus de cela, le sens de dÃ©placement des piÃ¨ces peut Ãªtre dÃ©terminÃ© (en fait, les connexions entre les positions du plateau), des zones de jeu (par exemple, des zones de conversion des piÃ¨ces), des champs interdits, etc.  Voici Ã  quoi ressemble la dÃ©finition de l'Ã©chiquier dans l'implÃ©mentation ZoG: <br><br><div class="spoiler">  <b class="spoiler_title">DÃ©finition de la carte dans ZoG</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  Vous remarquerez peut-Ãªtre qu'en plus des paramÃ¨tres du jeu, voici les paramÃ¨tres associÃ©s Ã  la visualisation.  Je suis fermement convaincu que ces paramÃ¨tres n'appartiennent pas ici.  Lors de la mise en Å“uvre d'un module de visualisation, plusieurs paramÃ¨tres peuvent Ãªtre utilisÃ©s et diffÃ©rents paramÃ¨tres peuvent Ãªtre requis.  De plus, les jeux de simulation peuvent fonctionner sans aucun module de visualisation (comme la lecture automatique dans Axiom).  En effet, puisque Axiom est utilisÃ© pour visualiser ZoG, la dÃ©finition ne contient rien de superflu: <br><br><div class="spoiler">  <b class="spoiler_title">DÃ©finition de la carte dans Axiom</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Malheureusement, Axiom n'a pas non plus de moyen de dÃ©terminer les zones de jeu (l'emplacement des zones de jeu doit Ãªtre dÃ©terminÃ© manuellement dans le code).  Ce n'est pas la seule simplification d'Axiom.  La dÃ©finition de la carte dans ce projet ne peut pas contenir plus d'une grille et cette grille doit Ãªtre bidimensionnelle.  La carte, ainsi dÃ©finie, est un tableau unidimensionnel, mais pour la commoditÃ© du programmeur, des synonymes sont dÃ©finis pour chacun des espaces comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  ComparÃ©es au schÃ©ma plus flexible de dÃ©finition de grille dans ZoG, ces restrictions sont assez inconfortables (surtout compte tenu du fait que le schÃ©ma de nommage imposÃ© utilisait ces champs dans le but mÃªme de la visualisation).  Heureusement, il est possible de dÃ©finir une planche de forme arbitraire.  Axiom et ZoG offrent tous deux la possibilitÃ© d'identifier chaque Ã©lÃ©ment sur la carte ainsi que la possibilitÃ© de dÃ©terminer les liens entre des paires de positions arbitraires.  En utilisant cette approche, nous pouvons dÃ©finir une carte de n'importe quelle topologie.  Son seul inconvÃ©nient est l'extrÃªme verbositÃ© et la complexitÃ© de la description. <br><br>  En plus de l'emplacement des piÃ¨ces sur le plateau et dans la rÃ©serve, le systÃ¨me devrait avoir la possibilitÃ© de stocker des attributs pour des piÃ¨ces individuelles et pour les espaces sur le plateau.  Un bon exemple de la nÃ©cessitÃ© d'utiliser les attributs d'une rÃ¨gle de Â« <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">roque</a> Â» dans les <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">Ã©checs</a> .  Il s'agit d'un mouvement difficile, qui comprend le mouvement simultanÃ© du roi et d'une tour, autorisÃ©, Ã  condition qu'aucune de ces piÃ¨ces n'ait bougÃ© avant d'effectuer ce mouvement.  Un attribut pourrait Ãªtre utilisÃ© pour stocker une balise boolÃ©enne indiquant si la piÃ¨ce a dÃ©jÃ  bougÃ©.  Les attributs de champ peuvent Ã©galement trouver des applications intÃ©ressantes. <br><br>  Il convient de noter que les attributs ne sont pas seulement des variables mais font partie de l'Ã©tat du jeu.  Une valeur d'attribut peut Ãªtre modifiÃ©e par l'exÃ©cution d'un tour (y compris par le module AI) et devrait Ãªtre disponible pour tous les tours suivants, mais pas pour les tours effectuÃ©s dans une autre branche du jeu.  Actuellement, ZoG prend en charge le stockage des attributs boolÃ©ens des piÃ¨ces.  Les attributs de stockage Axiom ne sont pas pris en charge, mais vous pouvez ajouter Ã  la dÃ©finition de la carte une description des variables et des tableaux.  Ces variables peuvent Ãªtre utilisÃ©es, telles que les compteurs de la quantitÃ© de piÃ¨ces capturÃ©es: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Encore une autre limitation de ZoG et d'Axiom est la rÃ¨gle selon laquelle chaque position de la planche ne peut contenir plus d'une piÃ¨ce.  Si une piÃ¨ce complÃ¨te un mouvement vers une position occupÃ©e par une autre piÃ¨ce, la piÃ¨ce occupant prÃ©cÃ©demment la position est automatiquement considÃ©rÃ©e comme Â«mangÃ©eÂ».  Cette rÃ¨gle va bien avec le principe Â«d'Ã©checsÂ» de prendre des piÃ¨ces et sert Ã  simplifier la description de ce jeu, mais complique la mise en Å“uvre de jeux tels que Â« <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">bashni checkers</a> Â» et Â« <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> Â». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  Dans ces jeux, les piÃ¨ces peuvent Ãªtre organisÃ©es en Â«colonnesÂ».  Une telle Â«colonneÂ» peut Ãªtre dÃ©placÃ©e tous ensemble, comme une seule piÃ¨ce.  AprÃ¨s rÃ©flexion, j'ai dÃ©cidÃ© qu'il valait mieux ne pas abandonner l'implÃ©mentation automatique de la capture Â«ChessÂ», mais amÃ©liorer les mÃ©canismes de dÃ©placement des groupes de piÃ¨ces.  En effet, pour l'implÃ©mentation des Â«piliersÂ», vous pouvez toujours ajouter Ã  bord une autre dimension (c'est particuliÃ¨rement facile, tant que le module de visualisation est sÃ©parÃ© du module de gÃ©nÃ©ration de mouvement et de l'IA, alors vous pouvez utiliser n'importe quelle logique que ce soit pour rendre la carte en trois dimensions dans sa visualisation en deux dimensions).  Un autre argument en faveur de cette dÃ©cision Ã©tait que le mouvement de piÃ¨ces Â«Ã  empilement Ã©levÃ©Â» n'est pas le seul type de voyage de groupe.  Par exemple, dans les panneaux Â« <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> Â», les fragments peuvent Ãªtre tournÃ©s avec les piÃ¨ces montÃ©es dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  En rÃ©sumÃ©, je peux dire que, pour mon cadre de jeu, j'ai dÃ©cidÃ© de prendre tout ce qui a Ã©tÃ© pensÃ© dans ZoG, Axiom et Ludi, et d'ajouter tout ce qui, Ã  mon avis, leur manque. <br><br><h2>  DÃ©placer la gÃ©nÃ©ration </h2><br>  La gÃ©nÃ©ration de mouvements s'apparente Ã  <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">une programmation non dÃ©terministe</a> .  La tÃ¢che du gÃ©nÃ©rateur de dÃ©placement fournit, sur demande, une liste de tous les dÃ©placements possibles Ã  partir de la position actuelle.  Le mouvement de cette liste sera sÃ©lectionnÃ© par un joueur ou l'IA n'est pas sa fonction.  Voyons comment la gÃ©nÃ©ration de mouvements se fait dans ZoG.  Ã€ titre d'exemple, nous prenons la macro de gÃ©nÃ©ration de mouvement pour une piÃ¨ce Ã  longue portÃ©e (une reine ou un Ã©vÃªque).  Voici comment il est utilisÃ© pour dÃ©terminer les mouvements de ces piÃ¨ces: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  En paramÃ¨tre, une macro passe la direction du mouvement sur la planche.  Si vous n'envisagez pas la possibilitÃ© d'installer de nouvelles piÃ¨ces sur la planche, la gÃ©nÃ©ration d'un coup semble simple.  Pour chacune des piÃ¨ces du plateau, tous les mouvements possibles selon les rÃ¨gles sont calculÃ©s.  Puis la magie commence ... <br><br>  Chacune des dÃ©finitions peut ajouter Ã  la liste un certain nombre de mouvements possibles!  L'ajout d'un coup Ã  la liste se fait avec la commande add (en positionnant en mÃªme temps chaque piÃ¨ce en mouvement sur le plateau).  J'ai dÃ©jÃ  <a href="https://habr.com/ru/post/221779/">Ã©crit</a> Ã  quel point cette solution architecturale est extrÃªmement pauvre.  La commande pour la formation du mouvement doit Ãªtre sÃ©parÃ©e des commandes qui manipulent les piÃ¨ces (comme cela a Ã©tÃ© fait dans Axiom).  Voyons comment fonctionne la macro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Tout d'abord, le dÃ©placement est effectuÃ© par une cellule, dans la direction donnÃ©e, puis dans un cycle, l'espace atteint est vÃ©rifiÃ© pour l'absence des piÃ¨ces dessus, un mouvement est formÃ© et l'arrangement se poursuit vers une autre cellule dans la mÃªme direction.  Si vous vous arrÃªtez ici, la piÃ¨ce peut Â«glisserÂ» Ã  travers des cellules vides, mais comment pouvez-vous prendre des piÃ¨ces ennemies? <br><br>  TrÃ¨s simple!  AprÃ¨s avoir exÃ©cutÃ© la commande Verify, la vÃ©rification que le champ n'est pas occupÃ© par une piÃ¨ce amie, nous formons une autre commande d'ajout, terminant le dÃ©placement.  Si sur cette cellule se trouvait une piÃ¨ce ennemie, elle sera prise automatiquement (comme sur une case du plateau, Ã  la fois, vous ne pouvez pas avoir plus d'une piÃ¨ce).  Si la piÃ¨ce Ã©tait conviviale, le calcul du coup sera abandonnÃ© avec la commande vÃ©rifier (la violation des conditions spÃ©cifiÃ©es dans cette commande met immÃ©diatement fin au calcul du coup en cours). <br><br>  Dans ZoG et Axiom, on ne peut dÃ©placer que ses propres piÃ¨ces (ou plutÃ´t, dÃ©placer les piÃ¨ces de l'adversaire est possible, mais uniquement si cela est spÃ©cifiÃ© dans le mode de calcul d'un dÃ©placement d'une de ses propres piÃ¨ces).  Je trouve que c'est une restriction extrÃªmement gÃªnante, car il existe de nombreux jeux dans lesquels vous pouvez dÃ©placer directement la piÃ¨ce de l'adversaire (dans Â« <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> Â», par exemple).  Il serait plus cohÃ©rent d'effectuer le calcul de dÃ©placement pour toutes les piÃ¨ces, quelle que soit leur affiliation.  Dans la macro qui dÃ©termine le mouvement, il suffirait d'ajouter une seule vÃ©rification pour permettre de dÃ©placer uniquement ses propres piÃ¨ces: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Il est important de pouvoir exÃ©cuter un mouvement composÃ© de plusieurs mouvements Â«partielsÂ».  Dans les implÃ©mentations de brouillons, cette capacitÃ© est utilisÃ©e pour effectuer des captures Â«en chaÃ®neÂ»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  La commande de dÃ©placement partiel est formÃ©e avec add-partial (pour cette commande, ainsi que pour la commande add, il y a une variation du dÃ©placement, avec Â«transformationÂ» des piÃ¨ces).  Un tel mouvement fait toujours partie d'un mouvement plus large et Â«compositeÂ».  En rÃ¨gle gÃ©nÃ©rale, pour les mouvements ultÃ©rieurs, un Â«modeÂ» est dÃ©fini, que la suite doit implÃ©menter.  Ainsi, dans les dames, une capture ne peut se poursuivre qu'avec les captures suivantes, mais pas avec un mouvement Â«douxÂ» (sans capture). <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Dans ZoG, l'implÃ©mentation des dÃ©placements partiels est mÃ©diocre.  Essayer d'exÃ©cuter la commande add-partial dans un cycle provoque une erreur.  En consÃ©quence, la capture effectuÃ©e par un roi vÃ©rificateur ne peut Ãªtre rÃ©alisÃ©e que de la maniÃ¨re trÃ¨s maladroite suivante: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  Et ainsi de suite, jusqu'Ã  king-jump-7!  Permettez-moi de vous rappeler que dans la plupart des variÃ©tÃ©s de pions avec un roi Â«Ã  longue portÃ©eÂ», le roi, aprÃ¨s chaque capture, peut s'arrÃªter sur n'importe quel espace d'une chaÃ®ne continue d'espaces vides suivant la piÃ¨ce capturÃ©e.  Il existe d'ailleurs une variante de ce jeu dans laquelle la rÃ¨gle de capture Â«chaÃ®neÂ» est formulÃ©e diffÃ©remment.  C'est exactement ce que j'aime chez les dames - tout le monde peut trouver une variante Ã  son goÃ»t. <br></div></div><br>  Un tel systÃ¨me de description des rÃ¨gles est trÃ¨s flexible, mais une logique parfois plus complexe est nÃ©cessaire.  Par exemple, si la piÃ¨ce, lors d'une progression Â«partielleÂ», ne doit pas repasser Ã  travers un champ prÃ©cÃ©demment parcouru, il est logique d'utiliser les drapeaux associÃ©s aux positions sur la carte.  AprÃ¨s avoir visitÃ© un espace, nous avons mis un drapeau, donc par la suite de ne plus y retourner: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  En plus des indicateurs Â«positionnelsÂ», dans ZoG, vous pouvez utiliser des indicateurs globaux.  Ces capacitÃ©s ne doivent pas Ãªtre confondues avec les attributs des piÃ¨ces.  Contrairement Ã  ce dernier, ceux-ci ne font pas partie de l'Ã©tat du jeu.  Malheureusement, les attributs des piÃ¨ces et des drapeaux dans ZoG ne peuvent Ãªtre que boolÃ©ens (dans Axiom, les attributs ne sont mÃªme pas pris en charge).  Cette limitation rend difficile l'exÃ©cution d'opÃ©rations associÃ©es aux diffÃ©rents types de comptage.  Par exemple, dans <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">ce</a> petit casse-tÃªte, je devais utiliser pour Â«compterÂ» des piÃ¨ces, prises dans une Â«fourchetteÂ», une paire de drapeaux boolÃ©ens (le nombre exact dont je n'avais pas besoin, tant que les piÃ¨ces Ã©taient plus d'une). <br><br>  Une autre chose Ã  corriger est l'absence d'un Â«cycle de vieÂ» clair dans l'exÃ©cution du dÃ©mÃ©nagement.  Tous les drapeaux sont automatiquement rÃ©initialisÃ©s avant de commencer le dÃ©placement, mais il serait plus facile d'identifier clairement la phase d'initialisation.  Ã€ mon avis, dans le calcul du dÃ©mÃ©nagement, il devrait se produire les phases suivantes: <br><br><ol><li>  Initialisation des variables et vÃ©rification des conditions prÃ©alables au mouvement composite </li><li>  Initialisation des variables et vÃ©rification des conditions prÃ©alables au dÃ©placement partiel </li><li>  GÃ©nÃ©ration du mouvement partiel </li><li>  VÃ©rification des postconditions du dÃ©mÃ©nagement partiel </li><li>  GÃ©nÃ©ration, achÃ¨vement et vÃ©rification des postconditions du mouvement composite </li><li>  VÃ©rification des conditions de rÃ©siliation du jeu </li></ol><br>  Le groupe d'Ã©tapes de la deuxiÃ¨me Ã  la quatriÃ¨me, dans le mouvement composite complet, peut Ãªtre rÃ©pÃ©tÃ© plusieurs fois.  L'idÃ©e de prÃ©- et post-conditions, que j'appelle des invariants, je me suis inspirÃ©e du projet Ludi.  Je vous en dirai plus sur l'utilisation des invariants plus tard. <br><br><h2>  Sur l'importance de la notation </h2><br>  La gÃ©nÃ©ration de tous les mouvements possibles Ã  partir de la position n'est que la moitiÃ© de l'histoire.  Pour contrÃ´ler l'Ã©tat du jeu, une prÃ©sentation compacte des mouvements gÃ©nÃ©rÃ©s est nÃ©cessaire.  Dans ZoG, Ã  cet effet, la notation ZSG est utilisÃ©e.  Voici un compte rendu d'un dÃ©but possible d'une partie d'Ã©checs sous cette forme: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Ce script est proche de la <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">notation d'Ã©checs</a> habituelle et gÃ©nÃ©ralement convivial.  Seul le quatriÃ¨me coup du blanc peut semer la confusion.  Donc, dans ZSG, cela ressemble Ã  du <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">roque</a> .  La partie de la description du dÃ©placement avant le caractÃ¨re Â«@Â» est assez claire;  c'est le mouvement simultanÃ© de la tour et du roi, mais qu'est-ce qui suit?  Ainsi, dans ZSG, il semble qu'une rÃ©initialisation des attributs des piÃ¨ces soit nÃ©cessaire afin d'Ã©viter la possibilitÃ© de roque rÃ©pÃ©tÃ©e. <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  ZoG utilise sa notation ZSG en particulier pour montrer le dÃ©roulement du jeu sous une forme comprÃ©hensible par le joueur.  Ã€ droite du tableau, une sous-fenÃªtre "Liste des mouvements" peut Ãªtre ouverte.  Cette liste peut Ãªtre utilisÃ©e pour naviguer dans le jeu enregistrÃ©.  Cette liste n'est pas trÃ¨s pratique, car une arborescence de branchements de jeux alternatifs n'est pas prise en charge.  La partie des tours enregistrÃ©s associÃ©e aux changements d'attributs des piÃ¨ces, n'est pas affichÃ©e Ã  l'utilisateur. <br></div></div><br>  L'enregistrement d'un coup en notation ZSG doit contenir des informations complÃ¨tes suffisantes pour changer correctement l'Ã©tat du jeu.  Si des informations sur un changement d'attributs sont perdues, dans un jeu selon un tel record, un mouvement pourrait Ãªtre incorrectement rÃ©pÃ©tÃ© (par exemple, le joueur aurait la possibilitÃ© de rÃ©exÃ©cuter le roque).  Malheureusement, dans les extensions DLL (comme Axiom), les informations Ã©tendues ne peuvent pas Ãªtre transmises. <br><br>  En travaillant avec les extensions DLL, ZoG est obligÃ© de faire une manipulation assez astucieuse lors du positionnement sur un mouvement sÃ©lectionnÃ© (par exemple, lorsque vous annulez un mouvement).  Ã€ partir de [chaque] position prÃ©cÃ©dente [depuis le dÃ©but du jeu], tous les coups possibles sont gÃ©nÃ©rÃ©s, puis, dans cette liste, il faut rechercher un coup avec la reprÃ©sentation ZSG [correspondante].  Les [effets secondaires de chaque] mouvement gÃ©nÃ©rÃ© sont appliquÃ©s Ã  [chaque Ã©tat de jeu] successif, car il est possible d'effectuer des effets secondaires non reflÃ©tÃ©s dans la reprÃ©sentation ZSG du mouvement. <br><br>  La situation est aggravÃ©e par le fait que la seule faÃ§on d'accÃ©der Ã  l'Ã©tat de jeu lors d'un coup dans le passÃ© est l'application cohÃ©rente de tous les coups depuis le dÃ©but de la partie jusqu'Ã  l'Ã©tat initial du plateau.  Dans <a href="https://habr.com/ru/post/234587/">des cas</a> vraiment <a href="https://habr.com/ru/post/234587/">complexes</a> , ce type de navigation ne se fait pas rapidement.  Un autre inconvÃ©nient de la notation ZSG peut Ãªtre illustrÃ© par l'enregistrement du mouvement suivant dans le jeu de <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go</a> : <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Ici, dans la position G19, une pierre blanche est placÃ©e qui capture un groupe de pierres noires.  Ã‰tant donnÃ© que toutes les piÃ¨ces impliquÃ©es dans la performance du placement doivent Ãªtre mentionnÃ©es dans la performance ZSG, l'enregistrement du tour peut sembler trÃ¨s long (en Go, une goutte peut capturer jusqu'Ã  360 pierres).  Ã€ quoi cela peut conduire, j'ai Ã©crit <a href="https://habr.com/ru/post/235483/">plus tÃ´t</a> .  La taille de la mÃ©moire tampon allouÃ©e pour l'enregistrement du mouvement ZoG peut ne pas Ãªtre suffisante.  De plus, si pour une raison quelconque l'ordre de retrait des pierres change (dans le processus de dÃ©veloppement du jeu, cela se produit), une tentative d'application d'un mouvement, d'un ancien ordre de captures, Ã©chouera. <br><br>  Heureusement, il existe un moyen simple de rÃ©soudre tous ces problÃ¨mes.  Voyons comment dÃ©finir les mouvements de piÃ¨ces dans ZRF: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  Les noms de mouvements, dÃ©finis dans les macros ZoG, sont inaccessibles en tant que gÃ©nÃ©rateur de mouvements.  Mais qu'est-ce qui nous empÃªche de renoncer aux macros et de dÃ©crire les mouvements avec leurs noms?  Voici Ã  quoi ressemblerait le dossier pour une partie d'Ã©checs: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Les lecteurs astucieux peuvent remarquer que dans les mouvements pour Â«noirÂ», j'ai utilisÃ© des directions non appropriÃ©es aux directions rÃ©elles sur l'Ã©chiquier.  Ceci est liÃ© au fait que des Â«symÃ©triesÂ» sont dÃ©finies pour le noir: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  En gros, alors, pour le blanc, c'est Â«nordÂ», pour noir, c'est Â«sudÂ», et vice versa. <br></div></div><br>  Les avantages d'un tel enregistrement ne sont pas Ã©vidents, mais il prÃ©sente un avantage important.  Tous les mouvements sont dÃ©crits de maniÃ¨re uniforme et ces descriptions ne contiennent rien de plus (les noms des descriptions de mouvements, bien sÃ»r, pourraient Ãªtre rendus plus Â«descriptifsÂ»).  Dans la description du roque, on a rÃ©ussi Ã  se dÃ©barrasser Ã  la fois des changements d'attributs et de la description du dÃ©placement de la tour (cette description ne dÃ©pend plus des dÃ©tails d'implÃ©mentation du dÃ©placement).  Une utilitÃ© encore plus claire de ces enregistrements existe dans le cas du jeu de Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  Et c'est tout!  Si les pierres de l'adversaire sont prises conformÃ©ment aux rÃ¨gles du jeu, il n'est pas nÃ©cessaire de toutes les Ã©numÃ©rer dans la description du coup.  Il suffit d'indiquer l'espace de dÃ©placement initial et final (Ã©ventuellement avec un signe Ã  prendre), le nom du mouvement en cours d'exÃ©cution et la ligne de paramÃ¨tres qui lui est passÃ©e.  Bien sÃ»r, pour effectuer un dÃ©placement selon cette description, pour le dÃ©codage, il est nÃ©cessaire d'accÃ©der au module de gÃ©nÃ©ration de dÃ©placement, mais ZoG le fait! <br><br>  Une autre possibilitÃ©, que l'on devrait prendre en charge, apparaÃ®t dans la fonctionnalitÃ© des dÃ©placements Â«partielsÂ».  Voici un exemple de Â« <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">dames russes</a> Â»: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Ici, les noirs, Ã  leur deuxiÃ¨me coup, prennent deux piÃ¨ces en d4 et f4.  Une Â«transformationÂ» prÃ©liminaire de ces piÃ¨ces en XChecker est une caractÃ©ristique de cette implÃ©mentation et sert Ã  empÃªcher la reprise des piÃ¨ces Â«vaincuesÂ» du mÃªme coup.  L'expression Â«partielle 2Â» dÃ©crit le dÃ©but d'un cours Â«compositeÂ», qui consiste en deux mouvements Â«partielsÂ».  Cette forme de description n'est pas pratique, car au moment de la gÃ©nÃ©ration du premier mouvement, la durÃ©e de la sÃ©quence de mouvements "partiels" peut ne pas Ãªtre connue.  Voici Ã  quoi ressemblera cette description dans un nouveau format: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Les dÃ©tails de mise en Å“uvre liÃ©s Ã  la Â«transformationÂ» des piÃ¨ces ne sont pas pertinents.  La capture des piÃ¨ces n'est pas non plus spÃ©cifiÃ©e, car dans les dames, la capture se produit comme un Â«effet secondaireÂ» du mouvement de la piÃ¨ce et non selon le Â«principe des Ã©checsÂ». La progression partielle sera codÃ©e avec le symbole Â«+Â» au dÃ©but de la ligne.  Un seul Â«+Â» indique la fin d'un Â«coup compositeÂ» (en fait, c'est le coup Â«partielÂ» habituel, contenant un coup manquant, une chaÃ®ne vide). <br><br>  Ainsi, en utilisant des rÃ¨gles nommÃ©es pour l'implÃ©mentation des mouvements, on a rÃ©ussi Ã  crÃ©er une notation universelle, satisfaisant pleinement nos exigences.  Bien sÃ»r, cela n'a rien Ã  voir avec les Ã©checs standard ou avec toute autre notation, mais il se trouve que la notation conventionnelle des Ã©checs, des dames et d'autres jeux n'a rien Ã  voir entre eux.  Le module de visualisation peut toujours convertir l'enregistrement de mouvement en une forme plus familiÃ¨re acceptÃ©e pour un jeu particulier.  La conversion peut Ã©galement prendre une forme universelle, comme <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  Le cycle de vie du jeu </h2><br>  En plus des informations sur le placement de piÃ¨ces sur le plateau, la sÃ©quence de tours fait partie intÃ©grante de l'Ã©tat du jeu, une variable dans le processus de jeu.  Dans le cas le plus simple (et le plus courant), pour stocker ces informations, un bit suffira, mais ZoG offre quelques opportunitÃ©s supplÃ©mentaires pour implÃ©menter des cas plus complexes.  Voici Ã  quoi pourrait ressembler une description d'une sÃ©quence de mouvements pour le jeu <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  Dans ce jeu, chaque joueur fait trois coups Ã  la fois, mais si vous donniez au premier joueur la possibilitÃ© de faire trois coups Ã  partir de la position initiale, il pourrait dÃ©truire l'une des piÃ¨ces de l'adversaire, ce qui lui donnerait un avantage significatif.  Pour cette raison, le premier joueur ne doit effectuer qu'un seul coup (cela donne la possibilitÃ© de se prÃ©parer Ã  attaquer un joueur adverse, mais pas Ã  l'attaquer), le second - deux coups (ce n'est pas non plus suffisant pour attaquer un joueur adverse), aprÃ¨s oÃ¹ chaque joueur fait toujours trois coups. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  La rÃ©pÃ©tition d'Ã©tiquette indique le dÃ©but d'une sÃ©quence cyclique rÃ©pÃ©titive de mouvements.  S'il n'apparaÃ®t pas, la description complÃ¨te est rÃ©pÃ©tÃ©e cycliquement.  ZoG ne permet pas de rÃ©pÃ©ter l'utilisation de l'Ã©tiquette plus d'une fois.  Une autre caractÃ©ristique importante est la spÃ©cification de l'ordre du tour.  Voici Ã  quoi pourrait ressembler une description de la sÃ©quence de tours d'un jeu dans lequel chaque joueur effectue deux tours (le premier coup - dÃ©placer des piÃ¨ces, le second - capturer les piÃ¨ces de l'adversaire): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  Il y a une capacitÃ© supplÃ©mentaire associÃ©e Ã  la description du dÃ©placement des piÃ¨ces de quelqu'un d'autre, mais il est trÃ¨s gÃªnant Ã  utiliser.  Le problÃ¨me est qu'une telle description n'a pas d'alternative.  Si la description indique que le mouvement doit Ãªtre effectuÃ© par une piÃ¨ce ennemie, le joueur doit effectuer ce mouvement!  Dans ZoG, il est impossible de dÃ©crire un choix de dÃ©placer sa propre piÃ¨ce ou celle d'une autre personne.  Si une telle capacitÃ© est nÃ©cessaire dans un jeu (comme dans " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> "), il est nÃ©cessaire de rendre toutes les piÃ¨ces neutres (crÃ©ant Ã  cet effet un joueur qui ne participe pas au jeu) et de dÃ©terminer pour tous les joueurs l'opportunitÃ© pour dÃ©placer une piÃ¨ce neutre.  J'ai dit ci-dessus qu'il est beaucoup plus facile par dÃ©faut de permettre Ã  tous les joueurs de dÃ©placer n'importe quelle piÃ¨ce (la leur ainsi que celle de leur adversaire) en ajoutant les vÃ©rifications nÃ©cessaires dans les algorithmes de gÃ©nÃ©ration de mouvement. <br><br>  Comme vous pouvez le voir, la gamme d'options fournies par ZoG pour la description de la sÃ©quence de virages est extrÃªmement limitÃ©e.  Axiom Ã©choue Ã©galement Ã  ajouter de nouvelles fonctionnalitÃ©s, car il s'exÃ©cute (gÃ©nÃ©ralement) sur ZoG.  Ludi, Ã  cet Ã©gard, est encore plus pauvre.  Afin de maximiser l'unification des rÃ¨gles du jeu (nÃ©cessaire pour la possibilitÃ© d'utiliser des algorithmes gÃ©nÃ©riques), dans ce projet, toutes les capacitÃ©s descriptives ont Ã©tÃ© dÃ©libÃ©rÃ©ment simplifiÃ©es, ce qui a entraÃ®nÃ© une Ã©limination de couches entiÃ¨res de jeux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " est un bon exemple d'un jeu avec un cycle de vie complexe. Dans ce jeu, il y a deux phases avec des rÃ¨gles d'exÃ©cution de mouvement qui diffÃ¨rent considÃ©rablement. Au dÃ©but du jeu, une partie des pierres est "dans la main" "De chaque joueur. Alors qu'il y a encore des pierres" en main ", des pierres sont mises dans les puits, une pierre Ã  la fois. Lorsque les pierres" en main "s'Ã©puisent, la deuxiÃ¨me phase du jeu commence, avec la distribution des insÃ©rÃ©s On ne peut pas dire que ce jeu ne peut pas Ãªtre dÃ©crit dans ZRF (le langage de description de ZoG), mais en raison des limites de ZoG, cette mise en Å“uvre serait extrÃªmement dÃ©routante (ce qui n'est certainement pas le meilleur pour la qualitÃ© du travail de l'IA). Voyons Ã  quoi ressemblerait la description d'un tel jeu dans un Â«monde idÃ©alÂ»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Ici, chaque liste d'ordre de tour dÃ©termine sa sÃ©quence rÃ©pÃ©tÃ©e de mouvements (en se distinguant par le mode d'exÃ©cution du mouvement).  Le mot-clÃ© label dÃ©finit un label vers lequel une transition peut Ãªtre effectuÃ©e lors de la gÃ©nÃ©ration du dernier mouvement.  Vous remarquerez peut-Ãªtre que nous partons ici de l'hypothÃ¨se implicite qu'une telle transition se produit toujours aprÃ¨s le coup du deuxiÃ¨me joueur (sinon cela violerait la sÃ©quence des coups).  Comment faire la transition vers la phase suivante Ã  un moment arbitraire? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Ici, les Ã©tiquettes sont portÃ©es dans le corps de la boucle et comprennent deux noms.  Les noms d'Ã©tiquette dans les listes d'Ã©tiquettes apparaissent dans l'ordre de transfert des joueurs dans la liste des joueurs.  Le nom utilisÃ© pour la transition est dÃ©terminÃ© par le joueur qui a fait le dernier mouvement.  S'il s'agissait du Nord, il passera Ã  la premiÃ¨re Ã©tiquette, sinon, Ã  la seconde.  Si aucun des noms des Ã©tiquettes n'est utilisÃ©, la position correspondante peut Ãªtre remplie par un tiret. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Un aspect important dans la gestion des mouvements alternÃ©s est la possibilitÃ© d'effectuer un tour rÃ©pÃ©tÃ©.  Dans les jeux de la <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">famille Tables</a> , comme <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Backgammon</a> ou <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , par exemple, la possibilitÃ© d'effectuer des tours rÃ©pÃ©tÃ©s est un Ã©lÃ©ment important des tactiques de jeu.  Dans ZoG, on peut utiliser passer un tour pour Ã©muler cette fonctionnalitÃ©, mais cette approche complique considÃ©rablement la description du jeu (en particulier avec plus de joueurs).  Il serait beaucoup plus logique d'utiliser une Ã©tiquette pour rÃ©pÃ©ter un tour: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Le jeu ayant sautÃ© sur la rÃ©pÃ©tition de l'Ã©tiquette, le joueur jouera Ã  nouveau son tour (l'Ã©tiquette la plus proche de la position actuelle dans la liste des tours prendra effet).  J'aime l'approche de <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> dans ses dÃ©finitions implicites.  La gÃ©nÃ©ration implicite de structures de contrÃ´le peut simplifier considÃ©rablement la description du jeu.  Dans la mesure oÃ¹ des mouvements rÃ©pÃ©tÃ©s peuvent Ãªtre utilisÃ©s dans de nombreux jeux, les Ã©tiquettes se rÃ©pÃ¨tent, anticiper la rÃ©pÃ©tition possible d'un tour peut Ãªtre implicite: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  De plus, puisque la sÃ©quence de tours est entiÃ¨rement cohÃ©rente avec l'ordre Ã©crit des joueurs dans la construction des joueurs, vous pouvez gÃ©nÃ©rer automatiquement la phrase d'ordre de tour entiÃ¨re: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Plus la description est facile Ã  Ã©crire, mieux c'est. <br><br><h2>  Invariant cassable </h2><br>  La principale chose que je n'aime pas dans ZoG peut Ãªtre exprimÃ©e en un seul mot - Ã©chec et mat.  Ã€ premiÃ¨re vue, c'est juste une condition (trÃ¨s courante dans les jeux de la <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">famille des Ã©checs</a> ) liant la fin de la partie Ã  la formation d'un partenaire.  HÃ©las, Ã  y regarder de plus prÃ¨s, la simplicitÃ© se rÃ©vÃ¨le trompeuse.  L'utilisation de ce mot-clÃ© signifie non seulement l'exÃ©cution, aprÃ¨s chaque coup, d'une vÃ©rification de la fin du jeu, mais impose Ã©galement au joueur un certain Â«comportementÂ». <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Du <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi</a> habituel, ce jeu ne diffÃ¨re que par le nombre de joueurs.  Malheureusement, cette diffÃ©rence est suffisante pour rendre incorrect le travail de dÃ©termination du mat (et tout ce qui est associÃ© Ã  ce mot Â«magiqueÂ»).  La vÃ©rification de la mise en Ã©chec n'est effectuÃ©e que par rapport Ã  l'un des joueurs.  En consÃ©quence, le roi peut devenir attaquÃ© et Ãªtre dÃ©vorÃ© [par une combinaison de tours d'adversaires mÃªme lorsqu'il n'est pas laissÃ© en Â«Ã©checÂ»]!  Que ce ne soit pas optimal se reflÃ©tera dans le travail de l'IA. <br><br>  Si ce problÃ¨me semble insignifiant, il convient de rappeler que les coalitions se forment gÃ©nÃ©ralement dans des parties Ã  quatre joueurs Â«paire contre paireÂ».  Dans le cas de la formation de coalitions, il faut considÃ©rer que des piÃ¨ces amies au roi ne le menacent pas!  Ainsi, par exemple, deux rois amis peuvent bien rÃ©sider sur les espaces voisins du plateau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Cela devient plus compliquÃ© que jamais si un joueur peut avoir plusieurs rois.  Dans " <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">Ã‰checs Tamerlan</a> ", le pion royal se transforme en prince (en fait, un deuxiÃ¨me roi).  Si cela se produit, vous ne pouvez gagner qu'en capturant le premier roi (l'un des deux) et en accouplant le second.  Dans ce jeu, vous pouvez mÃªme obtenir un troisiÃ¨me roi, doublant les dÃ©penses pour la transformation du Â«pion des pionsÂ»!  Les capacitÃ©s expressives de Â«Ã©chec et matÂ» ne suffisent pas Ã  dÃ©crire adÃ©quatement cette situation. <br><br>  Une autre difficultÃ© peut Ãªtre le processus mÃªme de donner du matÃ©.  Ainsi, aux Ã©checs mongols ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ), le rÃ©sultat de la tentative d'accouplement dÃ©pend de l'ordre dans lequel les piÃ¨ces exÃ©cutent le Â«contrÃ´leÂ» sÃ©quentiel.  Le rÃ©sultat peut s'avÃ©rer Ãªtre soit une victoire ou un match nul (comme un pion par un pion), soit mÃªme une dÃ©faite (pote de cheval interdit, mais vous pouvez donner un chÃ¨que).  Ã€ cet Ã©gard, le shogi japonais est un peu moins exotique.  Dans ce jeu, il est interdit de donner un compagnon avec un pion abandonnÃ©, mais vous pouvez donner un chÃ¨que avec un pion abandonnÃ© et donner un compagnon avec un pion dÃ©placÃ©. <br><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Il y a un autre point important Ã  mentionner.  Dans certains jeux, comme Rhythmomagic, il peut y avoir plusieurs faÃ§ons de terminer le jeu.  Le moyen le plus Ã©vident de gagner, impliquant la destruction des piÃ¨ces de l'adversaire, est Ã©galement le moins prÃ©fÃ©rÃ©.  Pour une victoire plus significative, il faut disposer ses piÃ¨ces sur le territoire ennemi selon un certain schÃ©ma. <br><br>  Il faut distinguer les types de victoires (et de dÃ©faites et de nuls) au niveau de la description du jeu, car le type de fin de jeu peut avoir de l'importance pour le joueur.  De plus, il devrait Ãªtre possible d'attribuer des prioritÃ©s numÃ©riques aux diffÃ©rentes fins de jeu.  Lors de la rÃ©alisation simultanÃ©e de plusieurs conditions d'achÃ¨vement, celle qui a la prioritÃ© la plus Ã©levÃ©e doit compter. <br></div></div><br>  Ã‰videmment, il faut sÃ©parer la logique de vÃ©rification de la fin de partie du test du roi tombÃ© en Ã©chec, qui est une <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">rÃ¨gle invariable</a> qui est vÃ©rifiÃ©e aprÃ¨s chaque tour.  La violation de la rÃ¨gle rend impossible l'exÃ©cution du mouvement (le mouvement est supprimÃ© de la liste des mouvements disponibles).  Ainsi, un test (simplifiÃ©) pour un roi en Ã©chec pourrait ressembler Ã  ceci pour "les Ã©checs de Tamerlan": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Il est important de comprendre que ce test ne doit Ãªtre effectuÃ© que pour ses propres rois (j'ai utilisÃ© le prÃ©dicat mon?, Parce que le prÃ©dicat ami?, Avec le soutien des coalitions, sera satisfait non seulement pour ses propres piÃ¨ces, mais aussi pour le morceaux de tous les joueurs amis).  Acceptable (et souhaitable, [s'il y a plusieurs rois amis]) est la situation dans laquelle le roi ennemi tombe sous contrÃ´le, aprÃ¨s un mouvement, mais par son propre roi.  Cette situation devrait Ãªtre impossible [Ã  moins qu'il y ait plusieurs rois amis]!  AprÃ¨s avoir fourni un support pour vÃ©rifier ces rÃ¨gles, vÃ©rifier la fin du jeu par Ã©chec et mat devient trivial.  S'il n'y a pas de coups possibles et que le [seul] roi est en Ã©chec, la partie est terminÃ©e [si ce roi appartient au dernier joueur survivant de l'avant-derniÃ¨re coalition survivante]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  La capacitÃ© de dÃ©terminer les invariants sera utile dans d'autres jeux, comme les <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">dames</a> .  La plus grande difficultÃ© dans la mise en Å“uvre des jeux de cette famille, est liÃ©e Ã  la mise en Å“uvre de la Â«rÃ¨gle de la majoritÃ©Â».  Dans presque tous les jeux de dames, la capture est obligatoire.  De plus, dans la plupart des jeux de cette famille, il y a une rÃ©alisation caractÃ©ristique des Â«captures de chaÃ®neÂ» en un seul tour.  Le vÃ©rificateur, aprÃ¨s avoir capturÃ©, continue de prendre d'autres piÃ¨ces, si possible.  Dans la plupart des jeux, le joueur doit effectuer des captures de chaÃ®ne jusqu'Ã  la fin, mais il existe des exceptions Ã  cette rÃ¨gle, par exemple <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  En utilisant le mÃ©canisme des mouvements partiels, la mise en Å“uvre d'une Â«capture en chaÃ®neÂ» est assez simple.  Des difficultÃ©s surgissent lorsque, de plus, on impose une condition dans laquelle, de toutes les options possibles, on doit choisir une chaÃ®ne dans laquelle un nombre maximal de piÃ¨ces est capturÃ©.  Dans ZoG, cette logique doit Ãªtre implÃ©mentÃ©e Ã  partir de zÃ©ro au niveau du Â«hardcodingÂ»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Ce paramÃ¨tre convient aux Â« <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">contrÃ´leurs internationaux</a> Â», mais dans les Â« <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">contrÃ´leurs italiens</a> Â», la rÃ¨gle de la majoritÃ© est formulÃ©e diffÃ©remment.  Dans cette version du jeu, s'il existe plusieurs options pour le mÃªme nombre de captures, vous devez sÃ©lectionner une option qui capture le plus grand nombre de pions transformÃ©s (rois).  Les dÃ©veloppeurs de ZoG l'ont fourni.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous entrez le paramÃ¨tre suivant: </font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cadre, on compte non seulement le nombre de piÃ¨ces capturÃ©es, mais aussi leur type. </font><font style="vertical-align: inherit;">Malheureusement, tout n'est pas prÃ©visible. </font><font style="vertical-align: inherit;">Voici comment la Â«rÃ¨gle de la majoritÃ©Â» est formulÃ©e dans les Â«vieux dames franÃ§aisesÂ»:</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si par une sÃ©rie de captures il est possible de capturer le mÃªme nombre de pions avec un homme simple ou avec un roi, le joueur doit utiliser le roi. </font><font style="vertical-align: inherit;">Cependant, si le nombre de pions est le mÃªme dans les deux cas, mais dans l'un il y a un roi ennemi (ou il y en a plus), le joueur doit choisir cette option, mÃªme si la capture se fait ensuite Ã  l'aide du simple pion, et non en utilisant le roi.</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sÃ»r, Ã  l'heure actuelle, presque personne ne joue cette version des dames, mais son existence mÃªme dÃ©montre clairement les lacunes de la mise en Å“uvre Â«codÃ©e en durÂ». </font><font style="vertical-align: inherit;">L'utilisation du mÃ©canisme des invariants permet toutes les options possibles pour la Â«rÃ¨gle de la majoritÃ©Â» de maniÃ¨re universelle. </font><font style="vertical-align: inherit;">Pour les Â« </font></font><a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vieux dames franÃ§aises</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Â», la mise en Å“uvre serait la suivante:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous supposons que les rÃ¨gles de gÃ©nÃ©ration de capture remplissent correctement [les] variables locales suivantes: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture-count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nombre total de piÃ¨ces capturÃ©es</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture-sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nombre de rois capturÃ©s</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacking-value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valeur de la capture de piÃ¨ce</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã€ chacune de ces variables est associÃ© un accumulateur de valeurs, stockÃ© dans une variable avec le prÃ©fixe max. Les trois contrÃ´les sont exÃ©cutÃ©s en sÃ©rie. La violation de l'une des conditions de vÃ©rification interrompt immÃ©diatement la gÃ©nÃ©ration de l'option de tour suivant (la capture n'est pas stockÃ©e dans la liste des tours possibles). Les contrÃ´les effectuÃ©s Ã©tant associÃ©s Ã  des valeurs variables, il ne suffit pas [de tester uniquement la nouvelle option de capture actuelle]. Chaque test gÃ©nÃ¨re une Â«rÃ¨gle flexibleÂ» associÃ©e Ã  la capture gÃ©nÃ©rÃ©e [qui peut rÃ©viser la valeur maximale accumulÃ©e]. AprÃ¨s chaque modification d'un accumulateur, toutes les rÃ¨gles associÃ©es doivent Ãªtre vÃ©rifiÃ©es Ã  nouveau [pour chaque option de la liste]. Si l'une des conditions n'est pas respectÃ©e pour une option gÃ©nÃ©rÃ©e prÃ©cÃ©demment, cette option doit Ãªtre supprimÃ©e de la liste des options de virage possibles.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est la traduction de mon article de l'annÃ©e 2014. </font><font style="vertical-align: inherit;">Depuis, j'ai beaucoup repensÃ© et le </font></font><a href="https://glukkazan.github.io/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet Dagaz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est devenu rÃ©alitÃ©, mais je n'ai presque rien changÃ© dans le texte. </font><font style="vertical-align: inherit;">Cet article a Ã©tÃ© traduit par mon ami </font></font><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Howard McCay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et je lui suis reconnaissant pour le travail accompli.</font></font><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481868/">https://habr.com/ru/post/fr481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481854/index.html">Tester des idÃ©es grÃ¢ce au prototypage de tableaux de bord</a></li>
<li><a href="../fr481858/index.html">Anniversaires sur Google Agenda avec l'Ã¢ge</a></li>
<li><a href="../fr481860/index.html">Que devrait faire l'informatique en 2020?</a></li>
<li><a href="../fr481862/index.html">Nvidia Jetson Embedded Machine Learning Systems</a></li>
<li><a href="../fr481866/index.html">DBA: lorsque le vide passe - nous nettoyons la table manuellement</a></li>
<li><a href="../fr481874/index.html">MÃ©triques - indicateurs de la santÃ© du projet</a></li>
<li><a href="../fr481880/index.html">Physique pour un tireur PvP mobile et comment nous nous sommes liÃ©s d'amitiÃ© avec ECS</a></li>
<li><a href="../fr481882/index.html">4. Mise en route de Fortinet v6.0. StratÃ©gies de pare-feu</a></li>
<li><a href="../fr481884/index.html">Carrefour des seniors: oÃ¹ aller ensuite?</a></li>
<li><a href="../fr481886/index.html">Comment crÃ©er rapidement un journal de prÃ©sence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>