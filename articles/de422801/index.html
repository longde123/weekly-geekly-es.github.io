<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≥ üçµ üê∫ RBAC in Kubernetes verstehen üö∂üèΩ üöÜ üë®üèæ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der Artikel wurde von Javier Salmeron, einem Ingenieur aus der bekannten Kubernetes-Community von Bitnami, verfasst und Anfang August...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RBAC in Kubernetes verstehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/422801/"> <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Der Artikel wurde von Javier Salmeron, einem Ingenieur aus der bekannten Kubernetes-Community von Bitnami, verfasst und Anfang August im CNCF-Blog ver√∂ffentlicht.</i>  <i>Der Autor spricht √ºber die Grundlagen des RBAC-Mechanismus (rollenbasierte Zugriffskontrolle), der vor anderthalb Jahren in Kubernetes eingef√ºhrt wurde.</i>  <i>Das Material ist besonders n√ºtzlich f√ºr diejenigen, die mit dem Ger√§t der Schl√ºsselkomponenten von K8 vertraut sind (siehe Links zu anderen √§hnlichen Artikeln am Ende).</i> <br><br><img src="https://habrastorage.org/webt/tz/xm/qe/tzxmqenidfjgy8nps6myfacun2i.jpeg"><br>  <i>Folie aus einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation</a> eines Google-Mitarbeiters anl√§sslich der Ver√∂ffentlichung von Kubernetes 1.6</i> <br><br>  Viele erfahrene Kubernetes-Benutzer erinnern sich m√∂glicherweise an die Version Kubernetes 1.6, als die auf der rollenbasierten Zugriffskontrolle (RBAC) basierende Autorisierung Beta wurde.  So erschien ein alternativer Authentifizierungsmechanismus, der die bereits vorhandene, aber schwer zu verwaltende und zu verstehende Attributbasierte Zugriffskontrolle (ABAC) erg√§nzte.  Alle begr√º√üten die neue Funktion begeistert, aber gleichzeitig waren unz√§hlige Benutzer entt√§uscht.  StackOverflow und GitHub waren reich an Berichten √ºber RBAC-Einschr√§nkungen, da die meisten Dokumentationen und Beispiele RBAC nicht ber√ºcksichtigten (aber jetzt ist alles in Ordnung).  Das Referenzbeispiel war Helm: Nur das Ausf√ºhren von <code>helm init</code> + <code>helm install</code> funktionierte nicht mehr.  Pl√∂tzlich mussten wir ‚Äûseltsame‚Äú Elemente wie <code>ServiceAccounts</code> oder <code>RoleBindings</code> bevor <code>RoleBindings</code> das Diagramm √ºberhaupt mit WordPress oder Redis <code>RoleBindings</code> (weitere <code>RoleBindings</code> hierzu finden Sie in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen</a> ). <a name="habracut"></a><br><br>  Wenn man diese erfolglosen ersten Versuche beiseite l√§sst, kann man den enormen Beitrag, den RBAC geleistet hat, um Kubernetes zu einer produktionsbereiten Plattform zu machen, nicht leugnen.  Viele von uns haben es geschafft, mit Kubernetes mit vollen Administratorrechten zu spielen, und wir verstehen vollkommen, dass es in einer realen Umgebung notwendig ist: <br><br><ul><li>  Viele Benutzer mit unterschiedlichen Eigenschaften, die den gew√ºnschten Authentifizierungsmechanismus bereitstellen. </li><li>  Sie haben die volle Kontrolle dar√ºber, welche Vorg√§nge jeder Benutzer oder jede Benutzergruppe ausf√ºhren kann. </li><li>  Haben Sie die volle Kontrolle dar√ºber, welche Operationen jeder Prozess im Herzen ausf√ºhren kann. </li><li>  Begrenzen Sie die Sichtbarkeit bestimmter Ressourcen in Namespaces. </li></ul><br>  In dieser Hinsicht ist RBAC ein Schl√ºsselelement, das dringend ben√∂tigte Funktionen bietet.  In diesem Artikel werden wir schnell auf die Grundlagen eingehen <i>(Einzelheiten finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Video</a> ; folgen Sie dem einst√ºndigen Link zum Bitnami-Webinar in englischer Sprache - <b>ca. √úbersetzung</b> ).</i> Und gehen Sie etwas tiefer in die verwirrendsten Momente ein. <br><br><h2>  Der Schl√ºssel zum Verst√§ndnis von RBAC in Kubernetes </h2><br>  Um die Idee von RBAC vollst√§ndig zu verwirklichen, m√ºssen Sie verstehen, dass drei Elemente daran beteiligt sind: <br><br><ul><li>  <i>Themen</i> - eine Gruppe von Benutzern und Prozessen, die Zugriff auf die Kubernetes-API haben m√∂chten; </li><li>  <i>Ressourcen</i> - Eine Sammlung von Kubernetes-API-Objekten, die in einem Cluster verf√ºgbar sind.  Ihre Beispiele (unter anderem) sind <i>Pods</i> , <i>Bereitstellungen</i> , <i>Dienste</i> , <i>Knoten</i> , <i>persistente Volumes</i> ; </li><li>  <i>Verben</i> (Verben) - eine Reihe von Operationen, die f√ºr Ressourcen ausgef√ºhrt werden k√∂nnen.  Es gibt verschiedene Verben (abrufen, beobachten, erstellen, l√∂schen usw.), aber alle sind letztendlich Operationen aus der CRUD-Kategorie (Erstellen, Lesen, Aktualisieren, L√∂schen). </li></ul><br><img src="https://habrastorage.org/webt/xc/yp/cy/xcypcyyglvjo5v6igg213nbkfxo.png"><br><br>  Unter Ber√ºcksichtigung dieser drei Elemente lautet die Schl√ºsselidee von RBAC: <br><br>  "Wir m√∂chten die Themen, API-Ressourcen und Operationen verbinden."  Mit anderen Worten, wir m√∂chten f√ºr einen bestimmten <b>Benutzer</b> angeben, welche <b>Vorg√§nge</b> mit einer Vielzahl von <b>Ressourcen ausgef√ºhrt werden k√∂nnen</b> . <br><br><h2>  Grundlegendes zu RBAC-Objekten in der API </h2><br>  Durch die Kombination dieser drei Entit√§tstypen werden die in der Kubernetes-API verf√ºgbaren RBAC-Objekte deutlich: <br><br><ul><li>  <code>Roles</code> verbinden Ressourcen und Verben.  Sie k√∂nnen f√ºr verschiedene Themen wiederverwendet werden.  An einen Namespace gebunden (wir k√∂nnen keine Vorlagen verwenden, die mehr als einen [Namespace] darstellen, aber wir k√∂nnen dasselbe Rollenobjekt f√ºr verschiedene Namespaces bereitstellen).  Wenn Sie die Rolle auf den gesamten Cluster anwenden m√∂chten, gibt es ein √§hnliches <code>ClusterRoles</code> Objekt. </li><li>  <code>RoleBindings</code> verbinden die verbleibenden Entit√§tsentit√§ten.  Durch Angabe einer Rolle, die API-Objekte bereits mit Verben verkn√ºpft, w√§hlen wir nun die Themen aus, die sie verwenden k√∂nnen.  Das √Ñquivalent f√ºr die Cluster-Ebene (d. H. Ohne Bindung an Namespaces) ist <code>ClusterRoleBindings</code> . </li></ul><br>  Im folgenden Beispiel geben wir dem Benutzer <i>jsalmeron das</i> Recht, im <i>Test-</i> Namespace zu lesen, eine Liste <i>abzurufen</i> und Herde zu erstellen.  Dies bedeutet, dass <i>jsalmeron</i> die folgenden Befehle ausf√ºhren kann: <br><br><pre> <code class="bash hljs">kubectl get pods --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> kubectl describe pod --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> pod-name kubectl create --namespace <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -f pod.yaml <span class="hljs-comment"><span class="hljs-comment">#     </span></span></code> </pre> <br>  ... aber nicht so: <br><br><pre> <code class="bash hljs">kubectl get pods --namespace kube-system <span class="hljs-comment"><span class="hljs-comment">#    kubectl get pods --namespace test -w #    watch</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/rz/es/71/rzes71nhwjlob2scvnv0m5yfahy.png"><br><br>  Beispiele f√ºr YAML-Dateien: <br><br><pre> <code class="plaintext hljs">kind: Role apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: pod-read-create namespace: test rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "list", "create"]</code> </pre> <br><pre> <code class="plaintext hljs">kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: salme-pods namespace: test subjects: - kind: User name: jsalmeron apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-read-create apiGroup: rbac.authorization.k8s.io</code> </pre> <br>  Ein weiterer interessanter Punkt ist folgender: K√∂nnen wir jetzt, da der Benutzer Pods erstellen kann, begrenzen, wie viel?  Dies erfordert andere Objekte, die nicht direkt mit der RBAC-Spezifikation zusammenh√§ngen, und erm√∂glicht Ihnen das Konfigurieren von Ressourcenlimits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ResourceQuota</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>LimitRanges</code></a> .  Es lohnt sich auf jeden Fall, sie zu untersuchen, wenn Sie eine so wichtige Cluster-Komponente konfigurieren [wie das Erstellen von Herden]. <br><br><h2>  Themen: Benutzer und ... ServiceAccounts? </h2><br>  Eine der Schwierigkeiten, mit denen viele Kubernetes-Benutzer im Zusammenhang mit Themen konfrontiert sind, ist die Unterscheidung zwischen regul√§ren Benutzern und <code>ServiceAccounts</code> .  Theoretisch ist alles einfach: <br><br><ul><li>  <code>Users</code> - globale Benutzer, die f√ºr Personen oder Prozesse au√üerhalb des Clusters entwickelt wurden; </li><li>  <code>ServiceAccounts</code> - begrenzt durch den Namespace und f√ºr Prozesse innerhalb des Clusters vorgesehen, die auf Pods ausgef√ºhrt werden. </li></ul><br>  Die √Ñhnlichkeit beider Typen liegt in der Notwendigkeit, sich bei der API zu authentifizieren, um bestimmte Vorg√§nge f√ºr viele Ressourcen auszuf√ºhren, und ihre Themenbereiche sehen sehr spezifisch aus.  Sie k√∂nnen auch zu Gruppen geh√∂ren, sodass <code>RoleBinding</code> mit <code>RoleBinding</code> mehr als einen Betreff binden k√∂nnen (obwohl f√ºr <code>ServiceAccounts</code> - <code>system:serviceaccounts</code> <code>RoleBinding</code> nur eine Gruppe zul√§ssig ist).  Der Hauptunterschied ist jedoch die Ursache der Kopfschmerzen: Benutzer haben keine entsprechenden Objekte in der Kubernetes-API.  Es stellt sich heraus, dass eine solche Operation existiert: <br><br><pre> <code class="bash hljs">kubectl create serviceaccount <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-service-account <span class="hljs-comment"><span class="hljs-comment"># OK</span></span></code> </pre> <br>  ... aber dieser ist weg: <br><br><pre> <code class="bash hljs">kubectl create user jsalmeron <span class="hljs-comment"><span class="hljs-comment"># !</span></span></code> </pre> <br>  Diese Situation hat schwerwiegende Folgen: Wenn der Cluster keine Informationen √ºber Benutzer speichert, muss der Administrator Konten au√üerhalb des Clusters verwalten.  Es gibt verschiedene M√∂glichkeiten, das Problem zu l√∂sen: TLS-Zertifikate, Token, OAuth2 usw. <br><br>  Dar√ºber hinaus m√ºssen Sie <code>kubectl</code> Kontexte erstellen, <code>kubectl</code> wir √ºber diese neuen Konten auf den Cluster zugreifen k√∂nnen.  Um Dateien mit ihnen zu erstellen, k√∂nnen Sie die Befehle <code>kubectl config</code> (f√ºr die kein Zugriff auf die Kubernetes-API erforderlich ist, sodass sie von jedem Benutzer ausgef√ºhrt werden k√∂nnen).  Das obige Video zeigt ein Beispiel f√ºr das Erstellen eines Benutzers mit TLS-Zertifikaten. <br><br><h2>  RBAC in Bereitstellungen: Beispiel </h2><br>  Wir haben ein Beispiel gesehen, in dem dem angegebenen Benutzer Rechte f√ºr Operationen im Cluster gew√§hrt werden.  Aber was ist mit <i>Bereitstellungen,</i> die Zugriff auf die Kubernetes-API erfordern?  Stellen Sie sich ein bestimmtes Szenario vor, um ein besseres Verst√§ndnis zu erhalten. <br><br>  Nehmen Sie zum Beispiel die beliebte Infrastrukturanwendung RabbitMQ.  Wir werden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm-Diagramm f√ºr RabbitMQ</a> von Bitnami (aus dem offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm- / Diagramm-</a> Repository) verwenden, das den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitnami / Rabbitmq-Container verwendet</a> .  In den Container ist ein Plugin f√ºr Kubernetes integriert, das f√ºr die Erkennung anderer Mitglieder des RabbitMQ-Clusters verantwortlich ist.  Aus diesem Grund erfordert der Prozess im Container Zugriff auf die Kubernetes-API, und wir m√ºssen das <code>ServiceAccount</code> mit den richtigen RBAC-Berechtigungen konfigurieren. <br><br>  Befolgen Sie bei <code>ServiceAccounts</code> folgenden bew√§hrten Methoden: <br><br>  - Konfigurieren Sie <b>ServiceAccounts f√ºr jede Bereitstellung</b> mit einem <b>Mindestsatz an Berechtigungen</b> . <br><br>  Bei Anwendungen, die Zugriff auf die Kubernetes-API ben√∂tigen, k√∂nnten Sie versucht sein, eine Art "privilegiertes <code>ServiceAccount</code> " zu erstellen, das fast alles im Cluster <code>ServiceAccount</code> kann.  Dies scheint zwar eine einfachere L√∂sung zu sein, kann jedoch letztendlich zu einer Sicherheitsl√ºcke f√ºhren, die unerw√ºnschte Vorg√§nge erm√∂glichen kann.  (Das Video zeigt ein Beispiel f√ºr eine Pinne [Helm-Komponente] und die Konsequenzen von <code>ServiceAccounts</code> mit gro√üen Berechtigungen.) <br><br>  Dar√ºber hinaus haben unterschiedliche <i>Bereitstellungen</i> unterschiedliche Anforderungen hinsichtlich des Zugriffs auf die API. Daher ist es f√ºr jede <i>Bereitstellung</i> sinnvoll, unterschiedliche <code>ServiceAccounts</code> zu haben. <br><br>  Lassen Sie uns vor diesem Hintergrund sehen, welche RBAC-Konfiguration f√ºr <i>den</i> Fall der <i>Bereitstellung</i> mit RabbitMQ korrekt ist. <br><br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin-Dokumentation</a> und <a href="">ihrem Quellcode k√∂nnen</a> Sie sehen, dass eine Liste von <i>Endpunkten</i> von der Kubernetes-API angefordert wird.  Auf diese Weise werden die verbleibenden Mitglieder des RabbitMQ-Clusters erkannt.  Daher erstellt das Bitnami RabbitMQ-Diagramm: <br><br><ul><li>  <a href=""><b>ServiceAccount</b></a> f√ºr Herde mit RabbitMQ: <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} apiVersion: v1 kind: ServiceAccount metadata: name: {{ template "rabbitmq.fullname" . }} labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" {{- end }}</code> </pre> </li><li>  <a href=""><b>Rolle</b></a> (wir gehen davon aus, dass der gesamte RabbitMQ-Cluster in einem einzigen Namespace bereitgestellt wird), sodass das Verb <i>get</i> f√ºr die <i>Endpoint-</i> Ressource <i>abgerufen werden</i> kann: <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: {{ template "rabbitmq.fullname" . }}-endpoint-reader labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" rules: - apiGroups: [""] resources: ["endpoints"] verbs: ["get"] {{- end }}</code> </pre> </li><li>  <a href=""><b>RoleBinding</b></a> , das ein <code>ServiceAccount</code> mit einer Rolle verbindet: <br><br><pre> <code class="plaintext hljs">{{- if .Values.rbacEnabled }} kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: {{ template "rabbitmq.fullname" . }}-endpoint-reader labels: app: {{ template "rabbitmq.name" . }} chart: {{ template "rabbitmq.chart" . }} release: "{{ .Release.Name }}" heritage: "{{ .Release.Service }}" subjects: - kind: ServiceAccount name: {{ template "rabbitmq.fullname" . }} roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: {{ template "rabbitmq.fullname" . }}-endpoint-reader {{- end }}</code> </pre> </li></ul><br><img src="https://habrastorage.org/webt/lx/uw/vg/lxuwvgvlcluwmoln2mx0wgkxdyk.png"><br><br>  Das Diagramm zeigt, dass Prozesse, die in RabbitMQ-Pods ausgef√ºhrt werden, <i>Get-</i> Operationen f√ºr <i>Endpoint-</i> Objekte ausf√ºhren d√ºrfen.  Dies ist die Mindestmenge an Vorg√§ngen, die erforderlich ist, damit alles funktioniert.  Gleichzeitig wissen wir, dass das bereitgestellte Diagramm sicher ist und keine unerw√ºnschten Aktionen innerhalb des Kubernetes-Clusters ausf√ºhrt. <br><br><h2>  Letzte Gedanken </h2><br>  F√ºr die Arbeit mit Kubernetes in der Produktion sind RBAC-Richtlinien nicht optional.  Sie k√∂nnen nicht als eine Reihe von API-Objekten betrachtet werden, die nur Administratoren kennen sollten.  Entwickler ben√∂tigen sie tats√§chlich, um sichere Anwendungen bereitzustellen und das Potenzial der Kubernetes-API f√ºr Cloud-native Anwendungen voll auszusch√∂pfen.  Weitere Informationen zu RBAC finden Sie unter folgenden Links: <br><br><ul><li>  Bitnami-Dokumentation: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfigurieren Sie RBAC in Ihrem Kubernetes-Cluster</a> ‚Äú; </li><li>  Kubernetes-Dokumentation: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden der RBAC-Autorisierung</a> ." </li></ul><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11 Wege, um (nicht) ein Opfer von Kubernetes Hacking zu werden</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was passiert in Kubernetes, wenn der Kubectl-Lauf startet?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie funktioniert der Kubernetes-Scheduler tats√§chlich?"</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinter den Kulissen des Netzwerks bei Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> " <i>(Videobericht, der eine Einf√ºhrung in das technische Ger√§t von Kubernetes enth√§lt)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422801/">https://habr.com/ru/post/de422801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422791/index.html">Wie man NICHT Englisch lernt: H√§ufige Fehler</a></li>
<li><a href="../de422793/index.html">DEFCON-Konferenz 22. Andrew "Zoz" Brooks. Nicht vermasseln! Teil 2</a></li>
<li><a href="../de422795/index.html">Technologie und Wirtschaft: Ein neues Modell der Zusammenarbeit mit Zyxel in Russland</a></li>
<li><a href="../de422797/index.html">Wie wir aus einer normalen IP-Kamera einen kleinen Cloud-Videorecorder gemacht haben</a></li>
<li><a href="../de422799/index.html">Wie Microsoft den gesamten Server versteckt hat und wie man ihn findet</a></li>
<li><a href="../de422803/index.html">Speicherkostenrechner oder Wie wir die "Black Box" ge√∂ffnet haben</a></li>
<li><a href="../de422805/index.html">Schnelles Abbestellen von Mailinglisten in Mail.Ru Mail</a></li>
<li><a href="../de422807/index.html">AliceVision: Befehlszeilenphotogrammetrie</a></li>
<li><a href="../de422809/index.html">Meine Adresse ist kein Haus oder eine Stra√üe: Was wird die Adresse des 21. Jahrhunderts sein?</a></li>
<li><a href="../de422811/index.html">Auf den Himmel klopfen: Einkauf in der Cloud mit SAP Ariba verwalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>