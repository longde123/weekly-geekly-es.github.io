<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊 🤴🏻 👌🏽 À propos du modèle de réseau dans les jeux pour débutants 📤 👩🏾‍🤝‍👩🏽 🌀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis deux semaines, je travaille sur un moteur réseau pour mon jeu. Avant cela, je ne connaissais rien aux technologies réseau dans les jeux, j'ai d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos du modèle de réseau dans les jeux pour débutants</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="image"></div><br>  Depuis deux semaines, je travaille sur un moteur réseau pour mon jeu.  Avant cela, je ne connaissais rien aux technologies réseau dans les jeux, j'ai donc lu de nombreux articles et mené de nombreuses expériences pour comprendre tous les concepts et pouvoir écrire mon propre moteur réseau. <br><br>  Dans ce guide, je voudrais partager avec vous divers concepts que vous devez apprendre avant d'écrire votre propre moteur de jeu, ainsi que les meilleures ressources et articles pour les apprendre. <br><br>  En général, il existe deux principaux types d'architectures de réseau: peer-to-peer et client-serveur.  Dans l'architecture peer-to-peer (p2p), les données sont transférées entre n'importe quelle paire de joueurs connectés, et dans l'architecture client-serveur, les données sont transmises uniquement entre les joueurs et le serveur. <br><br>  Bien que l'architecture peer-to-peer soit encore utilisée dans certains jeux, la norme est client-serveur: elle est plus facile à implémenter, nécessite une largeur de canal plus petite et facilite la protection contre la triche.  Par conséquent, dans ce guide, nous nous concentrerons sur l'architecture client-serveur. <br><a name="habracut"></a><br>  En particulier, nous nous intéressons surtout aux serveurs autoritaires: dans de tels systèmes, le serveur a toujours raison.  Par exemple, si un joueur pense qu'il est en coordonnées (10, 5) et que le serveur lui dit qu'il est en (5, 3), alors le client doit remplacer sa position par celle transmise par le serveur, et non l'inverse.  L'utilisation de serveurs autoritaires facilite la reconnaissance des tricheurs. <br><br>  Les systèmes de réseaux de jeux comportent trois composants principaux: <br><br><ul><li>  Protocole de transport: comment les données sont transférées entre les clients et le serveur. </li><li>  Protocole d'application: ce qui est transféré des clients au serveur et du serveur aux clients et dans quel format. </li><li>  Logique d'application: comment les données transmises sont utilisées pour mettre à jour l'état des clients et du serveur. </li></ul><br>  Il est très important de comprendre le rôle de chaque pièce et les difficultés qui y sont associées. <br><br><h1>  Protocole de transport </h1><br>  La première étape consiste à choisir un protocole de transport de données entre le serveur et les clients.  Il existe deux protocoles Internet pour cela: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TCP</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UDP</a> .  Mais vous pouvez créer votre propre protocole de transport basé sur l'un d'eux ou utiliser la bibliothèque dans laquelle ils sont utilisés. <br><br><h2>  Comparaison de TCP et UDP </h2><br>  TCP et UDP sont tous deux basés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IP</a> .  IP vous permet de transférer un paquet de la source au destinataire, mais ne garantit pas que le paquet envoyé atteindra tôt ou tard le destinataire, qu'il l'atteindra au moins une fois et que la séquence de paquets arrivera dans le bon ordre.  De plus, un paquet ne peut contenir qu'une taille de données limitée spécifiée par la valeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MTU</a> . <br><br>  UDP n'est qu'une fine couche sur IP.  Par conséquent, il a les mêmes limitations.  En revanche, TCP possède de nombreuses fonctionnalités.  Il fournit une connexion ordonnée fiable entre deux nœuds avec vérification des erreurs.  Par conséquent, TCP est très pratique et est utilisé dans de nombreux autres protocoles, par exemple en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTP</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMTP</a> .  Mais toutes ces fonctionnalités ont un prix: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>retard</em></a> . <br><br>  Pour comprendre pourquoi ces fonctions peuvent provoquer un retard, vous devez comprendre le fonctionnement de TCP.  Lorsque le nœud émetteur transmet le paquet au nœud récepteur, il s'attend à recevoir un accusé de réception (ACK).  Si après un certain temps, il ne le reçoit pas (parce que le paquet ou la confirmation a été perdu, ou pour d'autres raisons), il renvoie le paquet.  De plus, TCP garantit que les paquets sont reçus dans le bon ordre. Par conséquent, jusqu'à ce qu'un paquet perdu soit reçu, tous les autres paquets ne peuvent pas être traités, même s'ils ont déjà été reçus par le nœud récepteur. <br><br>  Mais comme vous le savez probablement, le retard dans les jeux multijoueurs est très important, en particulier dans des genres actifs tels que FPS.  C'est pourquoi de nombreux jeux utilisent UDP avec leur propre protocole. <br><br>  Un protocole natif basé sur UDP peut être plus efficace que TCP pour diverses raisons.  Par exemple, il peut marquer certains packages comme approuvés et d'autres comme non approuvés.  Par conséquent, il ne se soucie pas si le paquet non approuvé a atteint le récepteur.  Ou il peut traiter plusieurs flux de données afin qu'un paquet perdu dans un flux ne ralentisse pas les flux restants.  Par exemple, il peut y avoir un flux pour l'entrée du lecteur et un autre flux pour les messages de discussion.  Si un message de chat qui n'est pas des données urgentes est perdu, cela ne ralentira pas l'entrée, qui est urgente.  Ou, un protocole propriétaire peut implémenter la fiabilité différemment de TCP afin d'être plus efficace dans les jeux vidéo. <br><br>  Donc, si TCP est tellement nul, alors nous allons créer notre propre protocole de transport basé sur UDP? <br><br>  Tout est un peu plus compliqué.  Même si TCP est presque sous-optimal pour les systèmes de jeu en réseau, il peut très bien fonctionner dans votre jeu et vous faire gagner un temps précieux.  Par exemple, le retard peut ne pas être un problème pour un jeu au tour par tour ou un jeu qui ne peut être joué que sur des réseaux locaux, où il y a beaucoup moins de retards et de pertes de paquets que sur Internet. <br><br>  De nombreux jeux à succès, notamment World of Warcraft, Minecraft et Terraria, utilisent TCP.  Cependant, la plupart des FPS utilisent des protocoles propriétaires basés sur UDP, nous en parlerons donc ci-dessous. <br><br>  Si vous décidez d'utiliser TCP, assurez-vous que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme Nagle est</a> désactivé, car il met en mémoire tampon les paquets avant l'envoi, ce qui signifie qu'il augmente le délai. <br><br>  Pour en savoir plus sur les différences entre UDP et TCP dans le contexte des jeux multijoueurs, vous pouvez lire l'article de Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Protocole propre </h2><br>  Vous souhaitez donc créer votre propre protocole de transport, mais vous ne savez pas par où commencer?  Vous avez de la chance, car Glenn Fiedler a écrit deux articles incroyables à ce sujet.  Vous y trouverez de nombreuses pensées intelligentes. <br><br>  Le premier article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmers</em></a> 2008, est plus simple que le second, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Je vous recommande de commencer avec un ancien. <br><br>  Gardez à l'esprit que Glenn Fiedler est un grand partisan de l'utilisation de son propre protocole UDP.  Et après avoir lu ses articles, vous allez sûrement vous remettre de son opinion que TCP a de sérieux inconvénients dans les jeux vidéo, et vous voulez mettre en œuvre votre propre protocole. <br><br>  Mais si vous débutez en réseau, faites-vous plaisir et utilisez TCP ou une bibliothèque.  Pour réussir à implémenter votre propre protocole de transport, vous devez d'abord en apprendre beaucoup. <br><br><h2>  Bibliothèques réseau </h2><br>  Si vous avez besoin de quelque chose de plus efficace que TCP, mais que vous ne voulez pas vous soucier de mettre en œuvre votre propre protocole et entrer dans de nombreux détails, vous pouvez utiliser la bibliothèque réseau.  Il y en a beaucoup: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RakNet</a> , qui n'est plus pris en charge, mais sa fourchette de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SLikeNet</a> semble être toujours active. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ENet</a> est une bibliothèque créée pour le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cube</a> FPS multi-utilisateurs </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GameNetworkingSockets de Valve</a> </li></ul><br>  Je ne les ai pas tous essayés, mais je préfère ENet, car il est facile à utiliser et fiable.  De plus, elle dispose d'une documentation claire et d'un tutoriel pour les débutants. <br><br><h2>  Protocole de transport: conclusion </h2><br>  Pour résumer: il existe deux protocoles de transport principaux: TCP et UDP.  TCP a de nombreuses fonctionnalités utiles: fiabilité, commande de paquets, détection d'erreurs.  UDP n'a pas tout cela, mais TCP, par sa nature, a augmenté les retards qui sont inacceptables pour certains jeux.  Autrement dit, pour garantir de faibles latences, vous pouvez créer votre propre protocole basé sur UDP ou utiliser une bibliothèque qui implémente le protocole de transport UDP et est adaptée aux jeux vidéo multi-joueurs. <br><br>  Le choix entre TCP, UDP et la bibliothèque dépend de plusieurs facteurs.  Tout d'abord, par rapport aux besoins du jeu: a-t-il besoin de faibles latences?  Deuxièmement, à partir des exigences du protocole d'application: a-t-il besoin d'un protocole fiable?  Comme nous le verrons dans la partie suivante, vous pouvez créer un protocole d'application pour lequel un protocole peu fiable est tout à fait approprié.  Enfin, vous devez également prendre en compte l'expérience du développeur du moteur réseau. <br><br>  J'ai deux conseils: <br><br><ul><li>  Maximisez le protocole de transport à partir du reste de l'application afin qu'il puisse être facilement remplacé sans réécrire tout le code. </li><li>  Ne faites pas d'optimisation prématurée.  Si vous n'êtes pas un spécialiste du réseau et ne savez pas si vous avez besoin de votre propre protocole de transport basé sur UDP, vous pouvez commencer avec TCP ou une bibliothèque qui fournit la fiabilité, puis tester et mesurer les performances.  Si vous avez des problèmes et que vous êtes sûr que la raison réside dans le protocole de transport, le moment est peut-être venu de créer votre propre protocole de transport. </li></ul><br>  À la fin de cette partie, je vous recommande de lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20190519135537/"><em>introduction de</em></a> Brian Hook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20190519135537/"><em>à la programmation de jeux multijoueurs</em></a> , qui couvre de nombreux sujets abordés ici. <br><br><h1>  Protocole d'application </h1><br>  Maintenant que nous pouvons échanger des données entre les clients et le serveur, nous devons décider quelles données transférer et dans quel format. <br><br>  Le schéma classique est que les clients envoient des entrées ou des actions au serveur et que le serveur envoie l'état actuel du jeu aux clients. <br><br>  Le serveur n'envoie pas un état complet mais filtré avec des entités situées à côté du lecteur.  Il le fait pour trois raisons.  Premièrement, l'état global peut être trop grand pour une transmission à haute fréquence.  Deuxièmement, les clients sont principalement intéressés par les données visuelles et audio, car la majeure partie de la logique du jeu est simulée sur le serveur de jeu.  Troisièmement, dans certains jeux, le joueur n'a pas besoin de connaître certaines données, par exemple la position de l'adversaire à l'autre bout de la carte, car sinon il peut renifler des paquets et savoir exactement où se déplacer pour le tuer. <br><br><h2>  Sérialisation </h2><br>  La première étape consiste à convertir les données que nous voulons envoyer (état d'entrée ou de jeu) dans un format adapté à la transmission.  Ce processus est appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>sérialisation</em></a> . <br><br>  L'idée vient immédiatement à l'esprit d'utiliser un format lisible par l'homme, tel que JSON ou XML.  Mais il sera totalement inefficace et occupera en vain l'essentiel du canal. <br><br>  Au lieu de cela, il est recommandé d'utiliser un format binaire beaucoup plus compact.  Autrement dit, les paquets ne contiendront que quelques octets.  Ici, vous devez considérer le problème <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>de l'ordre des octets</em></a> , qui peut différer sur différents ordinateurs. <br><br>  Vous pouvez utiliser une bibliothèque pour sérialiser des données, par exemple: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FlatBuffers</a> </li><li>  Sandstorm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">céréales par</a> Shane Grant et Randolph Voorhees </li></ul><br>  Assurez-vous simplement que la bibliothèque crée des archives portables et prend en charge l'ordre des octets. <br><br>  Une solution indépendante peut être une implémentation indépendante, ce n'est pas particulièrement compliqué, surtout si vous utilisez une approche orientée données dans le code.  De plus, il vous permettra d'effectuer des optimisations qui ne sont pas toujours possibles lors de l'utilisation de la bibliothèque. <br><br>  Glenn Fiedler a écrit deux articles sur la sérialisation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823004533/"><em>lecture et écriture de paquets</em></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823015044/"><em>stratégies de sérialisation</em></a> . <br><br><h2>  La compression </h2><br>  La quantité de données transférées entre les clients et le serveur est limitée par la bande passante du canal.  La compression des données vous permet de transférer plus de données dans chaque instantané, d'augmenter le taux de rafraîchissement ou simplement de réduire les exigences de canal. <br><br><h3>  Emballage de bits </h3><br>  La première technique est le compactage des bits.  Elle consiste à utiliser exactement le nombre de bits nécessaire pour décrire la valeur souhaitée.  Par exemple, si vous avez une énumération qui peut avoir 16 valeurs différentes, alors au lieu d'un octet entier (8 bits), vous ne pouvez utiliser que 4 bits. <br><br>  Glenn Fiedler explique comment implémenter cela dans la deuxième partie de l'article sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823004533/"><em>paquets de lecture et d'écriture</em></a> . <br><br>  L'emballage de bits fonctionne particulièrement bien avec l'échantillonnage, qui sera le sujet de la section suivante. <br><br><h3>  Discrétisation </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>La discrétisation</em></a> est une technique de compression avec perte qui n'utilise qu'un sous-ensemble des valeurs possibles pour coder une valeur.  La façon la plus simple de mettre en œuvre la discrétisation consiste à arrondir les nombres à virgule flottante. <br><br>  Glenn Fiedler (encore!) Montre comment appliquer l'échantillonnage dans la pratique dans son article sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823021121/">compression d'instantané</a> . <br><br><h3>  Algorithmes de compression </h3><br>  La prochaine technique sera les algorithmes de compression sans perte. <br><br>  Voici, à mon avis, les trois algorithmes les plus intéressants que vous devez connaître: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codage Huffman</a> avec du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> pré-calculé extrêmement rapide et pouvant donner de bons résultats.  Il a été utilisé pour compresser les paquets dans le moteur réseau Quake3. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zlib</a> est un algorithme de compression à usage général qui n'augmente jamais la quantité de données.  Comme on peut le voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , il a été utilisé dans de nombreuses applications.  Il peut être redondant de mettre à jour les états.  Mais cela peut être utile si vous devez envoyer des actifs, des textes longs ou des secours aux clients à partir du serveur. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La copie de longueurs de séries</a> est probablement l'algorithme de compression le plus simple, mais il est très efficace pour certains types de données et peut être utilisé comme étape de prétraitement avant zlib.  Il est particulièrement adapté à la compression de terrains constitués de tuiles ou de voxels, dans lesquels de nombreux éléments voisins se répètent. </li></ul><br><h3>  Compression delta </h3><br>  La dernière technique de compression est la compression delta.  Elle réside dans le fait que seules les différences entre l'état actuel du jeu et le dernier état reçu par le client sont transmises. <br><br>  Il a d'abord été utilisé dans le moteur de réseau Quake3.  Voici deux articles expliquant comment l'utiliser: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20190628180906/"><em>Le modèle de mise en réseau Quake3 par</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Examen du code source de Quake 3: modèle de réseau</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction de l'</a> article sur Habré, voir la section "Modèle de réseau"] </li></ul><br>  Glenn Fiedler l'a également utilisé dans la deuxième partie de son article sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823021121/"><em>compression d'images</em></a> . <br><br><h2>  Cryptage </h2><br>  En outre, vous devrez peut-être crypter le transfert d'informations entre les clients et le serveur.  Il y a plusieurs raisons à cela: <br><br><ul><li>  confidentialité / confidentialité: les messages ne peuvent être lus que par le destinataire, et aucune autre personne reniflant le réseau ne peut les lire. </li><li>  authentification: une personne qui veut jouer le rôle d'un joueur doit connaître sa clé. </li><li>  prévention de la triche: il sera beaucoup plus difficile pour les joueurs malveillants de créer leurs propres paquets de triche, ils devront reproduire le schéma de cryptage et trouver la clé (qui change à chaque connexion). </li></ul><br>  Je recommande fortement d'utiliser la bibliothèque pour cela.  Je suggère d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libsodium</a> car il est particulièrement simple et propose d'excellents tutoriels.  Le didacticiel d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échange de clés</a> est particulièrement intéressant. Il vous permet de générer de nouvelles clés à chaque nouvelle connexion. <br><br><h2>  Protocole d'application: conclusion </h2><br>  Nous terminerons avec le protocole d'application.  Je pense que la compression est complètement facultative et la décision de l'utiliser ne dépend que du jeu et de la bande passante requise.  Le cryptage, à mon avis, est obligatoire, mais dans le premier prototype, vous pouvez vous en passer. <br><br><h1>  Logique d'application </h1><br>  Nous pouvons maintenant mettre à jour l'état du client, mais nous pouvons rencontrer des problèmes de retard.  Une fois entré, le joueur doit attendre la mise à jour de l'état du jeu depuis le serveur pour voir quel impact il a eu sur le monde. <br><br>  De plus, entre deux mises à jour d'état, le monde est complètement statique.  Si le taux de rafraîchissement des états est faible, les mouvements seront très saccadés. <br><br>  Il existe plusieurs techniques pour réduire l'impact de ce problème, et dans la section suivante, j'en parlerai. <br><br><h2>  Techniques de lissage différé </h2><br>  Toutes les techniques décrites dans cette section sont discutées en détail dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>série multijoueur à rythme rapide de</em></a> Gabriel Gambetta.  Je recommande fortement de lire cette grande série d'articles.  Il dispose également d'une démonstration interactive qui vous permet de voir comment ces techniques fonctionnent dans la pratique. <br><br>  La première technique consiste à appliquer directement l'entrée, sans attendre de réponse du serveur.  C'est ce qu'on appelle la <em>prédiction côté client</em> .  Cependant, lorsque le client reçoit la mise à jour du serveur, il doit s'assurer que sa prévision était correcte.  Si ce n'est pas le cas, il lui suffit de changer son état en fonction de celui reçu du serveur, car le serveur est autoritaire.  Cette technique a été utilisée pour la première fois à Quake.  Vous pouvez en savoir plus à ce sujet dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Revue du code Quake Engine par</em></a> Fabien Sanglar. <br><br>  Le deuxième ensemble de techniques est utilisé pour faciliter le mouvement d'autres entités entre deux mises à jour d'état.  Il existe deux façons de résoudre ce problème: l'interpolation et l'extrapolation.  En cas d'interpolation, les deux derniers états sont pris et la transition de l'un à l'autre est affichée.  Son inconvénient est qu'il cause une petite fraction du retard, car le client voit toujours ce qui s'est passé dans le passé.  L'extrapolation prédit où les entités devraient désormais être basées sur le dernier état reçu par le client.  Son inconvénient est que si l'entité change complètement la direction du mouvement, alors il y aura une grande erreur entre la prévision et la position réelle. <br><br>  La dernière technique, la plus avancée, utile uniquement en FPS est la <em>compensation de décalage</em> .  Lors de l'utilisation de la compensation de décalage, le serveur prend en compte les retards du client lorsqu'il tire sur une cible.  Par exemple, si un joueur a effectué un tir à la tête sur son écran, mais en réalité son objectif était situé ailleurs en raison du retard, il serait alors malhonnête de refuser au joueur le droit de tuer en raison du retard.  Par conséquent, le serveur rembobine le temps jusqu'au moment où le joueur a tiré pour simuler ce que le joueur a vu sur son écran et vérifier la collision entre son tir et la cible. <br><br>  Glenn Fiedler (comme toujours!) A écrit un article de 2004 dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823005028/"><em>Network Physics (2004)</em></a> , qui a jeté les bases de la synchronisation des simulations physiques entre un serveur et un client.  En 2014, il a écrit une nouvelle série d'articles sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823004853/"><em>physique</em></a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823004853/"><em>réseaux</em></a> qui décrivaient d'autres techniques de synchronisation des simulations physiques. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a également deux articles sur le wiki Valve, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Multiplayer Networking</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latency Compensating Methods in Client / Server In-game Protocol Design and Optimization</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui traitent de la compensation des retards.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prévention de la triche </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux techniques principales pour éviter la tricherie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premièrement: compliquer l'envoi de colis malveillants par des tricheurs. </font><font style="vertical-align: inherit;">Comme indiqué ci-dessus, le cryptage est un bon moyen de le mettre en œuvre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement: un serveur autoritaire ne devrait recevoir que des commandes / entrées / actions. </font><font style="vertical-align: inherit;">Le client ne doit pas pouvoir modifier l'état sur le serveur, sauf en envoyant des entrées. </font><font style="vertical-align: inherit;">Ensuite, chaque fois que l'entrée est reçue, le serveur doit en vérifier la validité avant de l'appliquer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logique d'application: conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vous recommande d'implémenter une méthode de simulation de retards importants et de faibles taux de rafraîchissement afin de pouvoir tester le comportement de votre jeu dans de mauvaises conditions, même lorsque le client et le serveur fonctionnent sur le même ordinateur. </font><font style="vertical-align: inherit;">Cela simplifiera considérablement la mise en œuvre des techniques de lissage des retards.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autres ressources utiles </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous souhaitez explorer d'autres ressources sur les modèles de réseau, vous pouvez les trouver ici: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20190328001900/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le blog de Glenn Fiedler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il vaut la peine de lire l'intégralité de son blog, il contient de nombreux excellents articles. </font><font style="vertical-align: inherit;">Tous les articles sur les technologies réseau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collectés </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;">ici</font></a><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awesome Game Networking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par M. Fatih MAR est une liste détaillée d'articles et de vidéos sur les moteurs de réseaux de jeux vidéo.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki r / gamedev subreddit contient</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> également de nombreux liens utiles.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467025/">https://habr.com/ru/post/fr467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467015/index.html">JWT: attaque de signature numérique contre attaque MAC</a></li>
<li><a href="../fr467017/index.html">Qu'est-ce que HED / MRSD et à quoi sert-il?</a></li>
<li><a href="../fr467019/index.html">Conception de tableaux de bord pour un site de commerce électronique d'analyse Web. Partie 3: Chaîne SEO</a></li>
<li><a href="../fr467021/index.html">Comment le robot Conscience communique avec les clients</a></li>
<li><a href="../fr467023/index.html">Nous avons créé un plugin dans Grafana pour surveiller les k8: déjà dans la boutique officielle Grafana</a></li>
<li><a href="../fr467029/index.html">Grigory Petrov: travailler avec un réseau à Ruby</a></li>
<li><a href="../fr467033/index.html">Une sélection de papiers techniques sympas du Chaos Communication Camp 2019</a></li>
<li><a href="../fr467035/index.html">Conception de tableaux de bord pour un site de commerce électronique d'analyse Web. Partie 4: Chaîne Youtube</a></li>
<li><a href="../fr467037/index.html">Affacturage: comment obtenir de l'argent pour des chaises</a></li>
<li><a href="../fr467039/index.html">Comment effectuer une révision du code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>