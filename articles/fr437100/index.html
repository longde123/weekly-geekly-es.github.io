<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èØÔ∏è ü§≤üèΩ üïî L'ing√©nierie inverse du rendu de The Witcher 3 ‚ú≥Ô∏è ü¶ê üìä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La premi√®re partie de la traduction est ici . Dans cette partie, nous parlerons de l'effet de la nettet√©, de la luminosit√© moyenne, des phases de la l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'ing√©nierie inverse du rendu de The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  La premi√®re partie de la traduction est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Dans cette partie, nous parlerons de l'effet de la nettet√©, de la luminosit√© moyenne, des phases de la lune et des ph√©nom√®nes atmosph√©riques sous la pluie. <br><br><h2>  Partie 6. Aiguiser </h2><br>  Dans cette partie, nous allons examiner de plus pr√®s un autre effet de post-traitement de The Witcher 3 - Sharpen. <br><br>  La nettet√© rend l'image de sortie un peu plus nette.  Cet effet nous est connu de Photoshop et d'autres √©diteurs graphiques. <br><br>  Dans The Witcher 3, la nettet√© a deux options: basse et haute.  Je vais parler de la diff√©rence entre eux ci-dessous, mais pour l'instant, regardons les captures d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="image"></div><br>  <i>Option ¬´Low¬ª - jusqu'√†</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="image"></div><br>  <i>Option ¬´Low¬ª - apr√®s</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Option √©lev√©e - jusqu'√†</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Option "High" - apr√®s</i> <br><br>  Si vous souhaitez jeter un ≈ìil √† des comparaisons plus d√©taill√©es (interactives), consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section du Guide de performances de The Witcher 3 de Nvidia</a> .  Comme vous pouvez le voir, l'effet est particuli√®rement visible sur l'herbe et le feuillage. <br><br>  Dans cette partie du post, nous √©tudierons le cadre depuis le tout d√©but du jeu: je l'ai choisi intentionnellement, car ici on voit le relief (longue distance de dessin) et le d√¥me du ciel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  En termes d'entr√©e, la nettet√© n√©cessite un tampon de couleur <b>t0</b> (LDR apr√®s correction de tonalit√© et reflets de l'objectif) et un tampon de profondeur <b>t1</b> . <br><br>  Examinons le code assembleur pour le pixel shader: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 lignes de code assembleur semblent √™tre une t√¢che r√©alisable.  Passons √† la r√©solution. <br><br><h3>  Accentuer la g√©n√©ration de valeur </h3><br>  La premi√®re √©tape consiste √† charger le tampon de profondeur (ligne 1).  Il est √† noter que le ¬´The Witcher 3¬ª utilise une profondeur invers√©e (1.0 - proche, 0.0 - √©loign√©).  Comme vous le savez peut-√™tre, la profondeur du mat√©riel est li√©e de mani√®re non lin√©aire (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article pour plus de d√©tails</a> ). <br><br>  Les lignes 3 √† 6 fournissent un moyen tr√®s int√©ressant d'associer cette profondeur mat√©rielle [1.0 - 0.0] √† des valeurs [presque √©loign√©es] (nous les avons d√©finies √† l'√©tape MatrixPerspectiveFov).  Consid√©rez les valeurs du tampon constant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Ayant la valeur ¬´close¬ª de 0,2 et la valeur de ¬´far¬ª 5000, nous pouvons calculer les valeurs de cb12_v21.xy comme suit: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Ce morceau de code est assez courant dans les shaders TW3, donc je pense que c'est juste une fonction. <br><br>  Apr√®s avoir obtenu la ¬´profondeur de la pyramide de visibilit√©¬ª, la ligne 7 utilise l'√©chelle / distorsion pour cr√©er le coefficient d'interpolation (ici on utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">satur√©</a> pour limiter les valeurs √† l'intervalle [0-1]). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy et cb3_v2.xy - il s'agit de la luminosit√© de l'effet de nettet√© √† courte et longue distance.  Appelons-les sharpenNear et sharpenFar.  Et c'est la seule diff√©rence entre les options ¬´Low¬ª et ¬´High¬ª de cet effet dans The Witcher 3. <br><br>  Il est maintenant temps d'utiliser le rapport r√©sultant.  Les lignes 8-9 ne font que <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  √Ä quoi √ßa sert?  Gr√¢ce √† cela, nous obtenons une luminosit√© diff√©rente pr√®s de Geralt et loin de lui.  Jetez un oeil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Peut-√™tre que cela est √† peine perceptible, mais ici, nous avons interpol√© en fonction de la distance la nettet√© de la luminosit√© √† c√¥t√© du lecteur (2.177151) et la luminosit√© de l'effet est tr√®s loin (1.91303).  Apr√®s ce calcul, nous ajoutons 1,0 √† la luminosit√© (ligne 10).  Pourquoi est-ce n√©cessaire?  Supposons que l'op√©ration lerp indiqu√©e ci-dessus nous donne 0,0.  Apr√®s avoir ajout√© 1.0, nous obtenons naturellement 1.0, et c'est une valeur qui n'affectera pas le pixel lors de la nettet√©.  En savoir plus √† ce sujet ci-dessous. <br><br>  Pendant l‚Äôaff√ªtage, nous ne voulons pas affecter le ciel.  Ceci peut √™tre r√©alis√© en ajoutant une simple v√©rification conditionnelle: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  Dans The Witcher 3, la valeur de la profondeur de pixel du ciel est de 1,0, nous l'utilisons donc pour obtenir une sorte de ¬´filtre binaire¬ª (fait int√©ressant: dans ce cas, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tape</a> ne fonctionnera pas correctement). <br><br>  Nous pouvons maintenant multiplier la luminosit√© interpol√©e par un ¬´filtre ciel¬ª: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Cette multiplication est effectu√©e sur la ligne 13. <br><br>  Exemple de code de shader: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Centre d'√©chantillonnage des pixels </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SV_Position</a> a un aspect qui sera important ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un d√©calage d'un demi-pixel</a> .  Il s'av√®re que ce pixel dans le coin sup√©rieur gauche (0, 0) a des coordonn√©es non pas (0, 0) en termes de SV_Position.xy, mais (0,5, 0,5).  Ouah! <br><br>  Ici, nous voulons prendre un √©chantillon au centre du pixel, alors regardons les lignes 14-16.  Vous pouvez les √©crire en HLSL: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  Et plus tard, nous √©chantillonnons la texture de couleur d'entr√©e de texcoords ¬´uvCenter¬ª.  Ne vous inqui√©tez pas, le r√©sultat de l'√©chantillonnage sera le m√™me qu'avec la m√©thode ¬´normale¬ª (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Aiguiser ou ne pas aiguiser </h3><br>  La d√©cision d'utiliser ou non la nettet√© d√©pend de fSharpenAmount. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Aiguiser </h3><br>  Il est temps de jeter un ≈ìil √† l'int√©rieur de l'algorithme lui-m√™me. <br><br>  Essentiellement, il effectue les actions suivantes: <br><br>  - √©chantillonne quatre fois la texture de couleur d'entr√©e aux coins du pixel, <br><br>  - ajoute des √©chantillons et calcule la valeur moyenne, <br><br>  - calcule la diff√©rence entre "center" et "cornerAverage", <br><br>  - trouve la composante absolue maximale de la diff√©rence, <br><br>  - corrige max.  abs.  composante utilisant des valeurs d'√©chelle + biais, <br><br>  - d√©termine l'ampleur de l'effet en utilisant max.  abs.  composant <br><br>  - calcule la valeur de luminosit√© (luma) pour "centerColor" et "averageColor", <br><br>  - divise colorCenter en sa luma, <br><br>  - calcule une nouvelle valeur de luma interpol√©e en fonction de l'ampleur de l'effet, <br><br>  - Multiplie colorCenter par la nouvelle valeur de luma. <br><br>  Beaucoup de travail, et c'√©tait difficile pour moi de le comprendre, car je n'avais jamais exp√©riment√© avec des filtres plus nets. <br><br>  Commen√ßons par le mod√®le d'√©chantillonnage.  Comme vous pouvez le voir dans le code assembleur, quatre lectures de texture sont effectu√©es. <br><br>  Cela sera mieux illustr√© √† l'aide d'un exemple d'image pixel (le niveau de comp√©tence de l'artiste est <i>un expert</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Toutes les lectures du shader utilisent l'√©chantillonnage bilin√©aire (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  Le d√©calage entre le centre et chacun des angles est de (¬± 0,5, ¬± 0,5), selon l'angle. <br><br>  Voyez comment cela peut √™tre mis en ≈ìuvre sur HLSL?  Voyons voir: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Donc, maintenant, les quatre √©chantillons sont r√©sum√©s dans la variable ¬´colorCorners¬ª.  Suivons ces √©tapes: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  La reconnaissance des contours est effectu√©e en calculant max.  abs.  composante de diff√©rence.  D√©m√©nagement intelligent!  D√©couvrez sa visualisation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualisation de la composante absolue maximale de la diff√©rence.</i> <br><br>  Super.  Le shader HLSL fini est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  D√©sol√© pour le formatage assez m√©diocre.  Vous pouvez utiliser mon programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HLSLexplorer</a> et exp√©rimenter avec le code. <br><br>  Je peux dire avec plaisir que le code ci-dessus cr√©e le m√™me code assembleur que dans le jeu! <br><br>  Pour r√©sumer: Le shader de nettet√© de Witcher 3 est tr√®s bien √©crit (notez que fPixelSharpenAmount est sup√©rieur √† 1.0! C'est int√©ressant ...).  De plus, le principal moyen de modifier la luminosit√© de l'effet est la luminosit√© des objets proches / √©loign√©s.  Dans ce jeu, ce ne sont pas des constantes;  J'ai compil√© plusieurs exemples de valeurs: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  aiguiser </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>faible</b> </td></tr></tbody><tbody><tr><td>  <b>haut</b> </td><td>  2.0 </td><td>  1,8 </td><td>  0,025 <br></td><td>  -0,25 <br></td><td>  -13,33333 <br></td><td>  1,33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  aiguiser <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  faible <br></td><td>  0,57751 <br></td><td>  0,31303 <br></td><td>  0,06665 <br></td><td>  -0.33256 <br></td><td>  -1,0 <br></td><td>  2.0 <br></td></tr><tr><td>  haut <br></td><td>  2.17751 <br></td><td>  1,91303 <br></td><td>  0,06665 <br></td><td>  -0.33256 <br></td><td>  -1,0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Partie 7. Luminosit√© moyenne </h2><br>  L'op√©ration de calcul de la luminosit√© moyenne de l'image actuelle peut √™tre trouv√©e dans presque tous les jeux vid√©o modernes.  Cette valeur est souvent utilis√©e plus tard pour l'effet de l'adaptation oculaire et de la correction tonale (voir dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie pr√©c√©dente de l'</a> article).  Dans les solutions simples, le calcul de la luminosit√© est utilis√©, par exemple, pour la texture 512 <sup>2</sup> , puis le calcul de ses niveaux de mip et l'application de cette derni√®re.  Cela fonctionne g√©n√©ralement, mais limite consid√©rablement les possibilit√©s.  Des solutions plus complexes utilisent des shaders de calcul qui effectuent, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une r√©duction parall√®le</a> . <br><br>  Voyons comment l'√©quipe de CD Projekt Red a r√©solu ce probl√®me dans The Witcher 3.  Dans la partie pr√©c√©dente, j'ai d√©j√† examin√© la correction tonale et l'adaptation de l'≈ìil, donc la seule pi√®ce restante du puzzle √©tait la luminosit√© moyenne. <br><br>  Pour commencer, le calcul de la luminosit√© moyenne de The Witcher 3 se compose de deux passes.  Pour plus de clart√©, j'ai d√©cid√© de les diviser en parties distinctes, et nous examinons d'abord le premier passage - ¬´distribution de la luminosit√©¬ª (calcul de l'histogramme de la luminosit√©). <br><br><h3>  R√©partition de la luminosit√© </h3><br>  Ces deux passes sont assez faciles √† trouver dans n'importe quel analyseur de trame.  Ce sont les appels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dispatch</a> dans l'ordre juste avant d'effectuer l'adaptation oculaire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Regardons l'entr√©e pour ce pass.  Il a besoin de deux textures: <br><br>  1) Tampon couleur HDR, dont l'√©chelle est r√©duite √† 1/4 x 1/4 (par exemple, de 1920x1080 √† 480x270), <br><br>  2) Tampon de profondeur plein √©cran <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>Tampon couleur 1/4 x 1/4 HDR.</i>  <i>Notez l'astuce d√©licate - ce tampon fait partie d'un plus grand tampon.</i>  <i>La r√©utilisation des tampons est une bonne pratique.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Tampon de profondeur plein √©cran</i> <br><br>  Pourquoi faire un zoom arri√®re sur le tampon de couleur?  Je pense que c'est une question de performance. <br><br>  Quant √† la sortie de cette passe, c'est un buffer structur√©.  256 √©l√©ments de 4 octets chacun. <br><br>  Les shaders n'ont pas d'informations de d√©bogage ici, alors supposez que ce n'est qu'un tampon de valeurs int non sign√©es. <br><br>  Important: la premi√®re √©tape du calcul de la luminosit√© moyenne appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ClearUnorderedAccessViewUint</a> pour remettre √† z√©ro tous les √©l√©ments du tampon structur√©. <br><br>  √âtudions le code assembleur du shader de calcul (c'est le premier shader de calcul de toute notre analyse!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  Et un tampon constant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  Nous savons d√©j√† que la premi√®re entr√©e est un tampon couleur HDR.  Avec FullHD, sa r√©solution est de 480x270.  Regardons l'appel Dispatch. <br><br>  Dispatch (270, 1, 1) - cela signifie que nous ex√©cutons 270 groupes de threads.  Autrement dit, nous ex√©cutons un groupe de threads par ligne du tampon de couleur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Chaque groupe de threads ex√©cute une ligne de m√©moire tampon couleur HDR</i> <br><br>  Maintenant que nous avons ce contexte, essayons de comprendre ce que fait le shader. <br><br>  Chaque groupe de threads a 64 threads dans la direction X (dcl_thread_group 64, 1, 1), ainsi qu'une m√©moire partag√©e, 256 √©l√©ments de 4 octets chacun (dcl_tgsm_structured g0, 4, 256). <br><br>  Notez que dans le shader, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269]. <br><br>  1) Nous commen√ßons par affecter √† tous les √©l√©ments de la m√©moire partag√©e des valeurs nulles.  √âtant donn√© que la m√©moire totale contient 256 √©l√©ments et 64 threads par groupe, cela peut commod√©ment √™tre fait avec une simple boucle: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Apr√®s cela, nous avons d√©fini la barri√®re √† l'aide de GroupMemoryBarrierWithGroupSync (sync_g_t).  Nous faisons cela pour nous assurer que tous les threads dans la m√©moire partag√©e des groupes sont remis √† z√©ro avant de passer √† l'√©tape suivante. <br><br>  3) Maintenant, nous ex√©cutons une boucle, qui peut √™tre grossi√®rement √©crite comme ceci: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Il s'agit d'une simple boucle for avec un incr√©ment de 64 (avez-vous d√©j√† compris pourquoi?). <br><br>  L'√©tape suivante consiste √† calculer la position du pixel charg√©. <br><br>  R√©fl√©chissons-y. <br><br>  Pour la coordonn√©e Y, nous pouvons utiliser SV_GroupID.x car nous avons lanc√© 270 groupes de threads. <br><br>  Pour la coordonn√©e X, nous ... pouvons profiter du flux de groupe actuel!  Essayons de le faire. <br><br>  Puisqu'il y a 64 threads dans chaque groupe, une telle solution contournera tous les pixels. <br><br>  Consid√©rez le groupe de threads (0, 0, 0). <br><br>  - Le flux (0, 0, 0) traitera les pixels (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448,0). <br><br>  - Le flux (1, 0, 0) traitera les pixels (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - Le flux (63, 0, 0) traitera les pixels (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Ainsi, tous les pixels seront trait√©s. <br><br>  Nous devons √©galement nous assurer que nous ne chargeons pas les pixels de l'ext√©rieur du tampon de couleur: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Tu vois?  C'est assez simple! <br><br>  J'ai √©galement calcul√© la luminosit√© (ligne 21 du code assembleur). <br><br>  Tr√®s bien, nous avons d√©j√† calcul√© la luminosit√© √† partir d'un pixel de couleur.  L'√©tape suivante consiste √† charger (et non √† √©chantillonner!) La valeur de profondeur correspondante. <br><br>  Mais ici, nous avons un probl√®me, car nous avons connect√© le tampon de profondeurs de pleine r√©solution.  Que faire √† ce sujet? <br><br>  C'est √©tonnamment simple - multipliez simplement colorPos par une constante (cb0_v2.z).  Nous avons r√©duit le tampon de couleur HDR √† quatre reprises.  donc la valeur est 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  Jusqu'ici tout va bien!  Mais ... nous sommes arriv√©s aux lignes 24-25 ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Alors  Nous avons d'abord une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comparaison de l'√©galit√© en</a> virgule flottante, son r√©sultat est √©crit en r2.x, et juste apr√®s √ßa va ... quoi?  Au niveau du bit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">et</a> ??  Vraiment?  Pour une valeur en virgule flottante?  Que diable ??? <br><br>  <b>Le probl√®me 'eq + et'</b> <br><br>  Permettez-moi de dire que pour moi, c'√©tait la partie la plus difficile du shader.  J'ai m√™me essay√© d'√©tranges combinaisons asint / asfloat ... <br><br>  Et si vous utilisez une approche l√©g√®rement diff√©rente?  Faisons juste la comparaison flottante-flottante habituelle dans HLSL. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  Et voici la sortie en code assembleur: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Int√©ressant, non?  Je ne m'attendais pas √† voir "et" ici. <br><br>  0x3f800000 est juste 1.0f ... C'est logique parce que nous obtenons 1.0 et 0.0 sinon si la comparaison r√©ussit. <br><br>  Mais que se passe-t-il si nous ¬´rempla√ßons¬ª 1.0 par une autre valeur?  Par exemple, comme ceci: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  On obtient le r√©sultat suivant: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  √áa a march√©.  Ce n'est que la magie du compilateur HLSL.  Remarque: si vous remplacez 0.0 par autre chose, vous obtenez simplement movc. <br><br>  Revenons au shader de calcul.  L'√©tape suivante consiste √† v√©rifier que la profondeur est √©gale √† cb0_v2.w.  Il est toujours √©gal √† 0,0 - en d'autres termes, nous v√©rifions si un pixel est sur un plan lointain (dans le ciel).  Si c'est le cas, alors nous attribuons √† ce coefficient une valeur, environ 0,5 (j'ai v√©rifi√© sur plusieurs images). <br><br>  Ce coefficient calcul√© est utilis√© pour interpoler entre la luminosit√© de la couleur et la luminosit√© du ¬´ciel¬ª (valeur cb0_v2.x, qui est souvent approximativement √©gale √† 0,0).  Je suppose que cela est n√©cessaire pour contr√¥ler l'importance du ciel dans le calcul de la luminosit√© moyenne.  Habituellement, l'importance est r√©duite.  Id√©e tr√®s intelligente. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Puisque nous avons lumaOk, l'√©tape suivante consiste √† calculer son logarithme naturel pour cr√©er une bonne distribution.  Mais attendez, disons que lumaOk est de 0,0.  Nous savons que la valeur de log (0) n'est pas d√©finie, nous ajoutons donc 1,0 car log (1) = 0,0. <br><br>  Apr√®s cela, nous modifions le logarithme calcul√© √† 128 pour le distribuer dans 256 cellules.  Tr√®s intelligent! <br><br>  Et c'est d'ici que cette valeur 88.722839 est prise.  Il s'agit d'un <code>128 *   (2)</code> . <br><br>  C'est juste la fa√ßon dont HLSL calcule les logarithmes. <br><br>  Il n'y a qu'une seule fonction dans le code assembleur HLSL qui calcule les logarithmes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">log</a> , et elle a une base de 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Enfin, nous calculons l'indice de la cellule √† partir de la luminosit√© distribu√©e logarithmiquement et ajoutons 1 √† la cellule correspondante dans la m√©moire partag√©e. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  L'√©tape suivante consistera √† nouveau √† d√©finir une barri√®re pour garantir que tous les pixels de la ligne ont √©t√© trait√©s. <br><br>  Et la derni√®re √©tape consiste √† ajouter des valeurs de la m√©moire partag√©e au tampon structur√©.  Cela se fait de la m√™me mani√®re, √† travers une simple boucle: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Une fois que les 64 threads du groupe de threads ont rempli les donn√©es communes, chaque thread ajoute 4 valeurs au tampon de sortie. <br><br>  Consid√©rez le tampon de sortie.  R√©fl√©chissons-y.  La somme de toutes les valeurs dans le tampon est √©gale au nombre total de pixels!  (√† 480x270 = 129 600).  Autrement dit, nous savons combien de pixels ont une valeur de luminosit√© sp√©cifique. <br><br>  Si vous √™tes mal familiaris√© avec les shaders informatiques (comme moi), alors au d√©but, cela peut ne pas √™tre clair, alors lisez le post plusieurs fois, prenez du papier et un crayon et essayez de comprendre les concepts sur lesquels cette technique est construite. <br><br>  C'est tout!  C'est ainsi que The Witcher 3 calcule un histogramme de luminosit√©.  Personnellement, j'ai beaucoup appris en √©crivant cette partie.  F√©licitations aux gars de CD Projekt Red pour leur excellent travail! <br><br>  Si vous √™tes int√©ress√© par un shader HLSL complet, alors il est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Je m'efforce toujours d'obtenir le code d'assemblage le plus pr√®s possible du jeu et je suis tr√®s heureux d'avoir r√©ussi √† nouveau! <br><br><h2>  Calcul de la luminosit√© moyenne </h2><br>  Il s'agit de la deuxi√®me partie de l'analyse des calculs de luminosit√© moyenne dans "The Witcher 3: Wild Hunt". <br><br>  Avant de nous lancer dans la bataille avec un autre shader de calcul, r√©p√©tons bri√®vement ce qui s'est pass√© dans la derni√®re partie: nous avons travaill√© avec un tampon de couleur HDR avec une √©chelle jusqu'√† 1 / 4x1 / 4.  Apr√®s la premi√®re passe, nous avons obtenu un histogramme de luminosit√© (tampon structur√© de 256 valeurs enti√®res non sign√©es).  Nous avons calcul√© le logarithme de la luminosit√© de chaque pixel, l'avons r√©parti sur 256 cellules et augment√© la valeur correspondante du tampon structur√© de 1 par pixel.  Pour cette raison, la somme totale de toutes les valeurs dans ces 256 cellules est √©gale au nombre de pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Un exemple de la sortie de la premi√®re passe.</i>  <i>Il y a 256 √©l√©ments.</i> <br><br>  Par exemple, notre tampon plein √©cran a une taille de 1920x1080.  Apr√®s un zoom arri√®re, la premi√®re passe a utilis√© un tampon 480x270.  La somme des 256 valeurs du tampon sera √©gale √† 480 * 270 = 129 600. <br><br>  Apr√®s cette br√®ve introduction, nous sommes pr√™ts √† passer √† l'√©tape suivante: l'informatique. <br><br>  Cette fois, un seul groupe de threads est utilis√© (Dispatch (1, 1, 1)). <br><br>  Regardons le code assembleur du shader de calcul: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  Il y a un tampon constant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Jetons un coup d'≈ìil au code assembleur: deux drones sont attach√©s (u0: tampon d'entr√©e de la premi√®re partie et u1: texture de sortie du format 1x1 R32_FLOAT).  Nous voyons √©galement qu'il y a 64 threads par groupe et 256 √©l√©ments de m√©moire de groupe partag√©e sur 4 octets. <br><br>  Nous commen√ßons par remplir la m√©moire partag√©e avec les donn√©es du tampon d'entr√©e.  Nous avons 64 threads, vous devrez donc faire presque la m√™me chose qu'avant. <br><br>  Pour √™tre absolument s√ªr que toutes les donn√©es ont √©t√© charg√©es pour un traitement ult√©rieur, nous mettons ensuite une barri√®re. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Tous les calculs sont effectu√©s dans un seul thread, tous les autres sont simplement utilis√©s pour charger des valeurs du tampon dans la m√©moire partag√©e. <br><br>  Le flux "informatique" a un indice de 0. Pourquoi?  Th√©oriquement, nous pouvons utiliser n'importe quel flux de l'intervalle [0-63], mais gr√¢ce √† une comparaison avec 0, nous pouvons √©viter des comparaisons entiers-entiers suppl√©mentaires (instructions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ieq</a> ). <br><br>  L'algorithme est bas√© sur l'indication de l'intervalle de pixels qui sera pris en compte dans l'op√©ration. <br><br>  √Ä la ligne 11, nous multiplions largeur * hauteur pour obtenir le nombre total de pixels et multiplions-les par deux nombres de l'intervalle [0,0f-1,0f], indiquant le d√©but et la fin de l'intervalle.  D'autres restrictions sont utilis√©es pour garantir que <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Comme vous pouvez le voir, il y a deux cycles ci-dessous.  Le probl√®me avec eux (ou avec leur code assembleur) est qu'il y a d'√©tranges transitions conditionnelles aux extr√©mit√©s des boucles.  Il m'a √©t√© tr√®s difficile de les recr√©er.  Jetez √©galement un ≈ìil √† la ligne 21. Pourquoi y a-t-il "-1"?  Je vais l'expliquer un peu plus bas. <br><br>  La t√¢che du premier cycle est d'√©liminer <i>pixelsToConsiderStart</i> et de nous donner l'index de la cellule tampon dans laquelle <i>pixelsToConsiderStart</i> +1 est pr√©sent (ainsi que le nombre de tous les pixels dans les cellules pr√©c√©dentes). <br><br>  Disons que <i>pixelsToConsiderStart est</i> approximativement √©gal √† 30 000, et dans le tampon, il y a 37 000 pixels dans la cellule ¬´z√©ro¬ª (cela se produit dans le jeu la nuit).  Par cons√©quent, nous voulons commencer l'analyse de la luminosit√© avec approximativement le pixel 30001, qui est pr√©sent dans la cellule "z√©ro".  Dans ce cas, nous quittons imm√©diatement la boucle, obtenant l'index de d√©part ¬´0¬ª et z√©ro pixels ignor√©s. <br><br>  Jetez un ≈ìil au code HLSL: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  Le myst√©rieux nombre "-1" de la ligne 21 du code assembleur est associ√© √† la condition bool√©enne pour l'ex√©cution de la boucle (je l'ai d√©couvert presque par accident). <br><br>  Apr√®s avoir re√ßu le nombre de pixels des cellules <i>lumaValue</i> et <i>lumaValue</i> lui-m√™me, nous pouvons passer au deuxi√®me cycle. <br><br>  La t√¢che du deuxi√®me cycle est de calculer l'influence des pixels et de la luminosit√© moyenne. <br><br>  Nous commen√ßons avec <i>lumaValue</i> calcul√© dans la premi√®re boucle. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  √Ä ce stade, nous avons obtenu la valeur de luminosit√© cod√©e dans l'intervalle [0,0f-255.f]. <br><br>  Le processus de d√©codage est assez simple - vous devez inverser les calculs de l'√©tape de codage. <br><br>  Une br√®ve r√©p√©tition du processus de codage: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Pour d√©coder la luminosit√©, nous inversons le processus d'encodage, par exemple, comme ceci: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Ensuite, nous calculons la distribution en multipliant le nombre de pixels avec une luminosit√© donn√©e par la luminosit√© d√©cod√©e, et en les additionnant jusqu'√† ce que nous <i>arrivions</i> au traitement des pixels <i>pixelsToConsiderEnd</i> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, nous divisons l'effet total sur le nombre de pixels analys√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le reste de la boucle (et le shader): Le </font><font style="vertical-align: inherit;">shader complet est disponible </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ici</font></a><font style="vertical-align: inherit;"> . Il est enti√®rement compatible avec mon programme </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> , sans lequel je ne serais pas en mesure de recr√©er efficacement le calcul de la luminosit√© moyenne dans The Witcher 3 (et tous les autres effets aussi!). </font><font style="vertical-align: inherit;">En conclusion, quelques r√©flexions. En termes de calcul de la luminosit√© moyenne, ce shader √©tait difficile √† recr√©er. Les principales raisons: </font><font style="vertical-align: inherit;">1) D'√©tranges contr√¥les ¬´en attente¬ª sur l'ex√©cution du cycle, cela a pris beaucoup plus de temps que je ne le pensais auparavant. </font><font style="vertical-align: inherit;">2) Probl√®mes de d√©bogage de ce shader de calcul dans RenderDoc (v. 1.2).</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les op√©rations "ld_structured_indexable" ne sont pas enti√®rement prises en charge, bien que le r√©sultat de la lecture de l'index 0 donne la valeur correcte, toutes les autres renvoient des z√©ros, c'est pourquoi les cycles se poursuivent ind√©finiment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que je n'aie pas pu obtenir le m√™me code d'assemblage que dans l'original (voir la capture d'√©cran ci-dessous pour les diff√©rences), en utilisant RenderDoc, j'ai pu injecter ce shader dans le pipeline - et les r√©sultats √©taient les m√™mes!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le r√©sultat de la bataille. </font><font style="vertical-align: inherit;">√Ä gauche, mon shader, √† droite, le code assembleur d'origine.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 8. La lune et ses phases </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la huiti√®me partie de l'article, j'explore le shader de lune de The Witcher 3 (et plus sp√©cifiquement, de l'extension Blood and Wine). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lune est un √©l√©ment important du ciel nocturne, et il peut √™tre difficile de la rendre cr√©dible, mais pour moi, marcher la nuit en TW3 √©tait un vrai plaisir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardez cette sc√®ne!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de passer au pixel shader, je dirai quelques mots sur les nuances du rendu. D'un point de vue g√©om√©trique, la Lune n'est qu'une sph√®re (voir ci-dessous), qui a des coordonn√©es de texture, des vecteurs normaux et tangents. Le vertex shader calcule la position dans l'espace mondial, ainsi que les vecteurs normalis√©s des normales, tangentes et tangentes √† deux points (√† l'aide d'un produit vectoriel), multipli√©s par la matrice mondiale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir que la lune se trouve compl√®tement sur un plan √©loign√©, les champs MinDepth et MaxDepth de la structure D3D11_VIEWPORT se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voient</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribuer la valeur 0,0 (la m√™me astuce utilis√©e pour le d√¥me du ciel). La lune est rendue imm√©diatement apr√®s le ciel.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sph√®re utilis√©e pour dessiner la lune.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eh bien, tout, je pense, vous pouvez continuer. </font><font style="vertical-align: inherit;">Jetons un coup d'≈ìil au pixel shader: La </font><font style="vertical-align: inherit;">principale raison pour laquelle j'ai choisi un shader de Blood and Wine est simple - il est plus court. </font><font style="vertical-align: inherit;">Tout d'abord, nous calculons le d√©calage pour √©chantillonner la texture. </font><font style="vertical-align: inherit;">cb0 [0] .w est utilis√© comme d√©calage le long de l'axe X. Avec cette astuce simple, nous pouvons simuler la rotation de la lune autour de son axe.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples de valeurs du tampon constant.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une texture (1024x512) est attach√©e en entr√©e. </font><font style="vertical-align: inherit;">La carte normale est cod√©e dans les canaux RVB et la couleur de la surface de la lune dans le canal alpha. </font><font style="vertical-align: inherit;">Intelligent!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le canal alpha d'une texture est la couleur de la surface de la lune.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les canaux RVB de texture sont une carte normale.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir re√ßu les coordonn√©es de texture correctes, nous √©chantillonnons les canaux RGBA. Nous devons d√©compresser la carte normale et effectuer une correction gamma de la couleur de la surface. Actuellement, un shader HLSL peut √™tre √©crit comme ceci, par exemple: </font><font style="vertical-align: inherit;">L'√©tape suivante consiste √† effectuer une liaison normale, mais uniquement dans les composants XY. (Dans The Witcher 3, l'axe Z est vers le haut et le canal Z entier de la texture est 1.0). Nous pouvons le faire de cette fa√ßon: </font><font style="vertical-align: inherit;">il est maintenant temps pour ma partie pr√©f√©r√©e de ce shader. </font><font style="vertical-align: inherit;">Regardez </font><font style="vertical-align: inherit;">encore les lignes 15-16: </font><font style="vertical-align: inherit;">Qu'est-ce que ce myst√©rieux 0,033864? Au d√©but, il semble que cela n'a aucun sens, mais si nous calculons la valeur inverse, nous obtenons environ 29,53, ce qui est √©gal √† la dur√©e du </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">mois synodique</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en jours! </font><font style="vertical-align: inherit;">C'est ce que j'attire l'attention aux d√©tails! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons supposer de mani√®re fiable que cb0 [0] .y est le nombre de jours qui se sont √©coul√©s pendant le gameplay. </font><font style="vertical-align: inherit;">Un √©cart suppl√©mentaire est utilis√© ici, utilis√© comme d√©calage le long de l'axe x de la texture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ayant re√ßu ce coefficient, nous le multiplions par 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, en utilisant sincos, nous calculons un autre vecteur 2D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En calculant le produit scalaire entre le vecteur normal et le vecteur "lune", une phase de la lune est simul√©e. </font><font style="vertical-align: inherit;">Regardez les captures d'√©cran avec diff√©rentes phases de la lune:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re √©tape consiste √† effectuer une s√©rie d'op√©rations de multiplication pour calculer la couleur finale. </font><font style="vertical-align: inherit;">Vous ne comprenez probablement pas pourquoi ce shader envoie une valeur alpha de 0,0 √† la sortie. </font><font style="vertical-align: inherit;">En effet, la lune est rendue avec le m√©lange activ√©:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette approche vous permet d'obtenir la couleur d'arri√®re-plan (ciel) si ce shader revient en noir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous √™tes int√©ress√© par un shader complet, vous pouvez le prendre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a de grands tampons constants et devrait d√©j√† √™tre pr√™t pour l'injection dans RenderDoc au lieu du shader d'origine (renommez simplement ¬´MoonPS¬ª en ¬´EditedShaderPS¬ª). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et le dernier: je voulais partager les r√©sultats avec vous: √† </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gauche est mon shader, √† droite est le shader original du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La diff√©rence est minime et n'affecte pas les r√©sultats.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme vous pouvez le voir, ce shader √©tait assez facile √† recr√©er. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 9. G-buffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, je vais r√©v√©ler quelques d√©tails du gbuffer dans The Witcher 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous supposerons que vous connaissez les bases de l'ombrage diff√©r√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√®ve r√©p√©tition: l'id√©e de reporter n'est pas de calculer tous les √©clairages et ombrages finis en une seule fois, mais de diviser les calculs en deux √©tapes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la premi√®re (passe de g√©om√©trie), nous remplissons le GBuffer de donn√©es de surface (position, normales, couleur sp√©culaire, etc. ...), et dans la seconde (passe d'√©clairage), nous combinons tout et calculons l'√©clairage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ombrage diff√©r√© est une approche tr√®s populaire car il vous permet de calculer en un seul passage en plein √©cran par des techniques telles que l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ombrage diff√©r√© des carreaux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui am√©liore consid√©rablement les performances.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, GBuffer est un ensemble de textures aux propri√©t√©s g√©om√©triques. </font><font style="vertical-align: inherit;">Il est tr√®s important de cr√©er la bonne structure pour cela. </font><font style="vertical-align: inherit;">Comme exemple de la vie r√©elle, vous pouvez √©tudier la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technologie de rendu Crysis 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cette br√®ve introduction, regardons un exemple de cadre de The Witcher 3: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des nombreux h√¥tels de Tussent.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le GBuffer principal se compose de trois cibles de rendu plein √©cran au format DXGI_FORMAT_R8G8B8A8_UNORM et d'un tampon de profondeur + stencil au format DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici leurs captures d'√©cran:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu cible 0 - canaux RVB, couleur de surface</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu cible 0 - canal alpha. </font><font style="vertical-align: inherit;">Honn√™tement, je n'ai aucune id√©e de ce que sont ces informations.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu cible 1 - canaux RVB. </font><font style="vertical-align: inherit;">Les vecteurs normaux dans l'intervalle [0-1] sont enregistr√©s ici.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu cible 1 - canal alpha. </font><font style="vertical-align: inherit;">On dirait de la r√©flectivit√©!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu cible 2 - canaux RVB. </font><font style="vertical-align: inherit;">On dirait une couleur sp√©culaire! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette sc√®ne, le canal alpha est noir (mais plus tard, il est utilis√©).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profondeurs de tampon. </font><font style="vertical-align: inherit;">Notez que la profondeur invers√©e est utilis√©e ici.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampon de gabarit utilis√© pour marquer un type sp√©cifique de pixel (par exemple, peau, v√©g√©tation, etc.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce n'est pas le GBuffer entier. </font><font style="vertical-align: inherit;">La passe d'√©clairage utilise √©galement des sondes d'√©clairage et d'autres tampons, mais je n'en discuterai pas dans cet article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de passer √† la partie "principale" du poste, je donnerai des observations g√©n√©rales:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observations g√©n√©rales </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Le seul tampon √† nettoyer est le tampon de profondeur / stencil.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous analysez les textures mentionn√©es ci-dessus dans un bon analyseur d'images, vous serez un peu surpris, car elles n'utilisent pas l'appel ¬´Clear¬ª, √† l'exception de Depth / Stencil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-√†-dire, en r√©alit√©, RenderTarget1 ressemble √† ceci (notez les pixels ¬´flous¬ª sur le plan lointain):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une optimisation simple et intelligente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une le√ßon importante: </font><font style="vertical-align: inherit;">vous devez d√©penser des ressources </font><font style="vertical-align: inherit;">pour les appels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc utilisez-les uniquement lorsque cela est n√©cessaire. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) la </font><font style="vertical-align: inherit;">profondeur Invers√© - il est cool</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombreux </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©j√† </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©crits</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'exactitude de la m√©moire tampon de profondeur avec virgule flottante. Witcher 3 utilise le z invers√©. C'est le choix naturel pour un jeu aussi ouvert avec de longues distances de rendu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le passage √† DirectX ne sera pas difficile: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Nous effa√ßons le tampon de profondeur en √©crivant ¬´0¬ª, pas ¬´1¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'approche traditionnelle, la valeur extr√™me ¬´1¬ª a √©t√© utilis√©e pour effacer le tampon de profondeur. Apr√®s le saut de profondeur, la nouvelle valeur ¬´distante¬ª est devenue 0, vous devez donc tout changer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Inversez les limites proches et √©loign√©es lors du calcul de la matrice de projection </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Changez la v√©rification de la profondeur de ¬´moins¬ª √† ¬´plus¬ª </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour OpenGL, un peu plus de travail doit √™tre fait (voir les articles mentionn√©s ci-dessus), mais √ßa vaut le coup. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Nous ne gardons pas notre position dans le monde</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , oui, tout est si simple. </font><font style="vertical-align: inherit;">Au passage de l'√©clairage, nous recr√©ons une position dans le monde √† partir des profondeurs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, je voulais montrer exactement le pixel shader qui fournit les donn√©es de surface √† GBuffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors maintenant, nous savons d√©j√† comment stocker les couleurs, les normales et les sp√©culaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, tout n'est pas aussi simple qu'on pourrait le penser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me avec le pixel shader est qu'il a de nombreuses options. </font><font style="vertical-align: inherit;">Ils diff√®rent par le nombre de textures qui leur sont transf√©r√©es et le nombre de param√®tres utilis√©s √† partir du tampon constant (probablement du tampon constant d√©crivant le mat√©riau). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'analyse, j'ai d√©cid√© d'utiliser ce beau canon:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre baril h√©ro√Øque! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez accueillir les textures:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc un alb√©do, une carte normale et une couleur sp√©culaire. Bo√Ætier assez standard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer, quelques mots sur l'entr√©e g√©om√©trique: La </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©om√©trie est transmise avec des tampons de position, texcoords, normaux et tangents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le vertex shader produit </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au moins des</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texcoords, vecteurs tangents / normaux / tangents normalis√©s sur deux points, pr√©c√©demment multipli√©s par la matrice mondiale. Pour les mat√©riaux plus complexes (par exemple, avec deux cartes diffuses ou deux cartes normales), le vertex shader peut produire d'autres donn√©es, mais je voulais montrer un exemple simple ici. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader dans le code assembleur: un </font><font style="vertical-align: inherit;">shader se compose de plusieurs √©tapes. Je d√©crirai chaque partie principale de ce shader s√©par√©ment.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais d'abord, comme d'habitude - une capture d'√©cran avec les valeurs du tampon constant: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commencerons par des choses complexes. </font><font style="vertical-align: inherit;">Ce n'est pas seulement </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´OutputColor.rgb = Texture.Sample (uv) .rgb¬ª</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir √©chantillonn√© la texture de couleur RVB (ligne 1), les 14 lignes suivantes sont ce que j'appelle le ¬´tampon de r√©duction de saturation¬ª. </font><font style="vertical-align: inherit;">Permettez-moi de vous montrer le code HLSL: </font><font style="vertical-align: inherit;">pour la plupart des objets, ce code ne fait que renvoyer la couleur d'origine de la texture. </font><font style="vertical-align: inherit;">Ceci est r√©alis√© par les valeurs correspondantes de ¬´tampon de mat√©riau¬ª. </font><font style="vertical-align: inherit;">cb4_v1.x a une valeur de 1,0, qui renvoie un masque de 0,0 et renvoie la couleur d'entr√©e de l'instruction </font><i><font style="vertical-align: inherit;">lerp</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il existe cependant quelques exceptions. </font><font style="vertical-align: inherit;">Le plus grand </font><i><font style="vertical-align: inherit;">facteur de d√©saturation que</font></i><font style="vertical-align: inherit;"> j'ai </font><i><font style="vertical-align: inherit;">trouv√©</font></i><font style="vertical-align: inherit;"> est 4,0 (il n'est jamais inf√©rieur √† 1,0) et </font><i><font style="vertical-align: inherit;">desatur√©Couleur</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©pend du mat√©riau. </font><font style="vertical-align: inherit;">Cela peut √™tre quelque chose comme (0,2, 0,3, 0,4); </font><font style="vertical-align: inherit;">Il n'y a pas de r√®gles strictes. </font><font style="vertical-align: inherit;">Bien s√ªr, je ne pouvais pas aider mais r√©aliser cela dans son propre DX11-cadre, et voici les r√©sultats, o√π toutes les valeurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©gale float3 (0,25, 0,3, 0,45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 1.0 (n'a aucun effet)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 2.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 3.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je suis s√ªr que ce n'est qu'une application de param√®tres mat√©riels, mais pas effectu√©e √† la fin de la partie alb√©do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les lignes 15-20 ajoutent la touche finale: </font><font style="vertical-align: inherit;">v0.z est la sortie du vertex shader, et elles sont nulles. </font><font style="vertical-align: inherit;">N'oubliez pas, car v0.z sera utilis√© plus tard √† quelques reprises. </font><font style="vertical-align: inherit;">Il semble que ce soit une sorte de coefficient, et tout le code ressemble √† un petit alb√©do gradateur, mais comme v0.z vaut 0, la couleur reste inchang√©e. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">En ce qui concerne RT0.a, comme nous pouvons le voir, il est tir√© du tampon de constante mat√©rielle, mais comme le shader n'a pas d'informations de d√©bogage, il est difficile de dire de quoi il s'agit. </font><font style="vertical-align: inherit;">Peut-√™tre la translucidit√©? </font><font style="vertical-align: inherit;">Nous avons termin√© avec la premi√®re cible de rendu!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par d√©baller la carte normale, puis, comme d'habitude, nous lierons les normales: </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, rien de surprenant. </font><i><font style="vertical-align: inherit;">Regardez les lignes 28-33:</font></i><font style="vertical-align: inherit;"> Nous pouvons les √©crire grossi√®rement comme suit: </font><font style="vertical-align: inherit;">Je ne sais pas si c'est correct d'√©crire. </font><font style="vertical-align: inherit;">Si vous savez ce qu'est cette op√©ration math√©matique, faites-le moi savoir. </font><font style="vertical-align: inherit;">Nous voyons que le pixel shader utilise SV_IsFrontFace.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  Qu'est ce que c'est<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vient pour aider </font><font style="vertical-align: inherit;">(je voulais √©crire "msdn", mais ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©termine si le triangle regarde la cam√©ra. </font><font style="vertical-align: inherit;">Pour les lignes et les points, IsFrontFace est vrai. </font><font style="vertical-align: inherit;">Une exception est les lignes trac√©es √† partir de triangles (mode filaire), qui d√©finissent IsFrontFace de mani√®re similaire √† la pixellisation d'un triangle en mode solide. </font><font style="vertical-align: inherit;">L'√©criture peut √™tre effectu√©e par un shader de g√©om√©trie et sa lecture par un shader de pixels.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je voulais le v√©rifier par moi-m√™me. </font><font style="vertical-align: inherit;">Et en fait, l'effet n'est perceptible qu'en mode filaire. </font><font style="vertical-align: inherit;">Je crois que ce morceau de code est n√©cessaire pour le calcul correct des normales (et donc de l'√©clairage) en mode filaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une comparaison: √† la fois les couleurs de l'image de la sc√®ne finie avec cette astuce on / off, ainsi que la texture des normales gbuffer [0-1] avec l'astuce on / off:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couleur de la sc√®ne sans truc</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sc√®ne de couleur avec cascade</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] pas de truc</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] avec une astuce</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avez-vous remarqu√© que chaque cible de rendu dans GBuffer a le format R8G8B8A8_UNORM? Cela signifie qu'il existe 256 valeurs possibles par composant. Est-ce suffisant pour stocker des normales? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le stockage de normales de haute qualit√© avec suffisamment d'octets dans Gbuffer est un probl√®me connu, mais heureusement, il existe de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombreux </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">mat√©riaux </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff√©rents</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">apprendre</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Peut-√™tre que certains d'entre vous savent d√©j√† quelle technique est utilis√©e ici. Je dois dire que dans tout le passage de la g√©om√©trie, il y a une texture suppl√©mentaire attach√©e √† la fente 13 ...:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ha!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Witcher 3 utilise une technique appel√©e ¬´ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normales Best Fit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª. </font><font style="vertical-align: inherit;">Ici je ne l'expliquerai pas en d√©tail (voir pr√©sentation). </font><font style="vertical-align: inherit;">Il a √©t√© invent√© vers 2009-2010 par Crytek, et puisque CryEngine a l'open source, BFN est √©galement </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN donne √† la texture des normales un aspect "granuleux". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir mis √† l'√©chelle les normales √† l'aide de BFN, nous les recodons de l'intervalle [-1; 1] √† [0, 1].</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sp√©culaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par la ligne 34 et √©chantillonnons la texture sp√©culaire: </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, il existe un filtre de ¬´gradation¬ª que nous connaissons chez Albedo: nous </font><font style="vertical-align: inherit;">calculons la composante avec max. </font><font style="vertical-align: inherit;">valeur, puis calculez la couleur ¬´assombrie¬ª et interpolez-la avec la couleur sp√©culaire d'origine, en prenant le param√®tre du vertex shader ... qui est 0, donc √† la sortie, nous obtenons la couleur de la texture. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©flectivit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai aucune id√©e si ce nom convient √† ce param√®tre, car je ne sais pas comment il affecte le passage de l'√©clairage. </font><font style="vertical-align: inherit;">Le fait est que le canal alpha de la carte normale d'entr√©e contient des donn√©es suppl√©mentaires:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture du canal alpha "carte normale". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code assembleur: </font><font style="vertical-align: inherit;">dites bonjour √† notre vieil ami - v0.z! </font><font style="vertical-align: inherit;">Sa signification est similaire √† l'alb√©do et au sp√©culaire:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Super!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est la fin de l'analyse de la premi√®re version du pixel shader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une comparaison de mon shader (√† gauche) avec l'original (√† droite):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ces diff√©rences n'affectent pas les calculs, donc mon travail ici est termin√©. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Option normale </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai d√©cid√© de montrer une option de plus, maintenant uniquement avec l'alb√©do et les cartes normales, sans texture sp√©culaire. Le code assembleur est l√©g√®rement plus long: </font><font style="vertical-align: inherit;">La diff√©rence entre cette option et les options pr√©c√©dentes est la suivante: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">lignes 1, 19</font></b><font style="vertical-align: inherit;"> : le param√®tre d'interpolation v0.z est multipli√© par cb4 [0] .x √† partir du tampon constant, mais ce produit n'est utilis√© que pour l'alp√©do d'interpolation sur la ligne 19. Pour les autres sorties, la valeur "normale" de v0.z est utilis√©e. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">lignes 54-55</font></b><font style="vertical-align: inherit;"> : o2.w est maintenant r√©gl√© √† la condition que (cb4 [7] .x&gt; 0.0) </font><font style="vertical-align: inherit;">Nous reconnaissons d√©j√† ce mod√®le ¬´une sorte de comparaison - ET¬ª √† partir du calcul de l'histogramme de luminosit√©. Cela peut s'√©crire comme suit: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">lignes 34-42</font></b><font style="vertical-align: inherit;"> : un calcul sp√©culaire compl√®tement diff√©rent.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de texture sp√©culaire ici. </font><font style="vertical-align: inherit;">Regardons le code assembleur responsable de cette partie: </font><font style="vertical-align: inherit;">Notez que nous avons utilis√© ici (1 - capacit√© r√©fl√©chie). </font><font style="vertical-align: inherit;">Heureusement, √©crire ceci en HLSL est assez simple: </font><font style="vertical-align: inherit;">j'ajouterai que dans cette version, le tampon constant avec les donn√©es mat√©rielles est l√©g√®rement plus grand. </font><font style="vertical-align: inherit;">Ici, ces valeurs suppl√©mentaires sont utilis√©es pour √©muler la couleur sp√©culaire. </font><font style="vertical-align: inherit;">Le reste du shader est le m√™me que dans la version pr√©c√©dente. </font><font style="vertical-align: inherit;">72 lignes de code assembleur sont trop pour √™tre affich√©es dans WinMerge, alors croyez-moi: mon code s'est av√©r√© √™tre presque le m√™me que dans l'original. </font><font style="vertical-align: inherit;">Ou vous pouvez t√©l√©charger mon </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> et voir par vous-m√™me!</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour r√©sumer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... et si vous le lisez ici, alors vous voudrez probablement aller un peu plus loin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui semble simple dans la vie r√©elle n'est souvent pas le cas, et le transfert de donn√©es vers gbuffer The Witcher 3 n'a pas fait exception. </font><font style="vertical-align: inherit;">Je ne vous ai montr√© que les versions les plus simples des pixel shaders responsables, et j'ai √©galement donn√© des observations g√©n√©rales concernant l'ombrage diff√©r√© en g√©n√©ral. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les plus patients, il existe deux options pour les pixel shaders dans pastebin: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 1 - avec texture sp√©culaire </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 2 - sans texture sp√©culaire</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 10. Rideaux de pluie au loin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous allons examiner un merveilleux effet atmosph√©rique que j'aime beaucoup - </font><font style="vertical-align: inherit;">des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rideaux de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pluie / lumi√®re </font><font style="vertical-align: inherit;">lointains </font><font style="vertical-align: inherit;">pr√®s de l'horizon. </font><font style="vertical-align: inherit;">Dans le jeu, ils sont plus faciles √† rencontrer sur les √Æles Skellig.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personnellement, j'aime vraiment ce ph√©nom√®ne atmosph√©rique et j'√©tais curieux de savoir comment les programmeurs graphiques de CD Projekt Red l'ont impl√©ment√©. </font><font style="vertical-align: inherit;">Voyons √ßa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici deux captures d'√©cran avant et apr√®s l'application des rideaux de pluie:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aux rideaux de pluie</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s les rideaux de pluie</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©om√©trie </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous nous concentrerons sur la g√©om√©trie. </font><font style="vertical-align: inherit;">L'id√©e est d'utiliser un petit cylindre:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cylindre dans l'espace local</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Du point de vue de sa position dans l'espace local, il est assez petit - sa position est dans la plage (0,0 - 1,0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le circuit d'entr√©e de cet appel de tirage ressemble √† ceci ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les √©l√©ments suivants sont importants pour nous ici: Texcoords et Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les Texcoords sont envelopp√©s tout simplement: U des bases sup√©rieure et inf√©rieure sont dans l'intervalle [0,02777 - 1,02734]. V sur la base inf√©rieure est de 1,0 et sur la partie sup√©rieure - 0,0. Comme vous pouvez le voir, vous pouvez tout simplement cr√©er ce maillage m√™me de mani√®re proc√©durale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ayant re√ßu ce petit cylindre dans l'espace local, nous le multiplions par la matrice mondiale fournie pour chaque instance de l'√©l√©ment d'entr√©e INSTANCE_TRANSFORM. V√©rifions les valeurs de cette matrice:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√áa a l'air assez effrayant, non? </font><font style="vertical-align: inherit;">Mais ne vous inqui√©tez pas, nous analyserons cette matrice et verrons ce qu'elle cache! </font><font style="vertical-align: inherit;">Les r√©sultats sont tr√®s int√©ressants: </font><font style="vertical-align: inherit;">il est important de conna√Ætre la position de la cam√©ra dans ce cadre particulier: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, nous avons redimensionn√© le cylindre pour le rendre assez grand dans l'espace mondial (dans TW3, l'axe Z est vers le haut), d√©plac√© par rapport √† la position de la cam√©ra , et se tourna. </font><font style="vertical-align: inherit;">Voici √† quoi ressemble le cylindre apr√®s la conversion avec le vertex shader:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cylindre apr√®s conversion par vertex shader. </font><font style="vertical-align: inherit;">Voyez comment il est situ√© par rapport √† la pyramide de visibilit√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La g√©om√©trie d'entr√©e et le vertex shader d√©pendent strictement l'un de l'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons de plus pr√®s le code assembleur pour le vertex shader: </font><font style="vertical-align: inherit;">avec les Texcoords simples passant (ligne 0) et Instance_LOD_Params (ligne 8), deux autres √©l√©ments sont n√©cessaires pour la sortie: SV_Position (c'est √©vident) et Hauteur (composant .z) de la position dans le monde. </font><font style="vertical-align: inherit;">Rappelez-vous que l'espace local est dans la plage [0-1]? Donc, juste avant d'appliquer la matrice mondiale, le vertex shader utilise l'√©chelle et la d√©viation pour changer la position locale. D√©m√©nagement intelligent! </font><font style="vertical-align: inherit;">Dans ce cas, scale = float3 (4, 4, 2), et bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">Le motif qui se remarque entre les lignes 9 et 28 est la multiplication de deux matrices de rang√©es principales. </font><font style="vertical-align: inherit;">Regardons simplement le vertex shader fini sur HLSL:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparaison de mon shader (√† gauche) et de l'original (√† droite): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les diff√©rences n'affectent pas les calculs. </font><font style="vertical-align: inherit;">J'ai inject√© mon shader dans le cadre et tout allait bien!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin! </font><font style="vertical-align: inherit;">Pour commencer, je vais vous montrer l'entr√©e: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deux textures sont utilis√©es ici: la texture de bruit et le tampon de profondeur:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valeurs des tampons constants: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et le code assembleur pour le pixel shader: </font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br>  Ouah!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup, mais en fait, tout n'est pas si mal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il ici? </font><font style="vertical-align: inherit;">Tout d'abord, nous calculons les UV anim√©s en utilisant le temps √©coul√© depuis cbuffer (cb0 [0] .x) et l'√©chelle / d√©calages. </font><font style="vertical-align: inherit;">Ces texcoords sont utilis√©s pour √©chantillonner √† partir de la texture du bruit (ligne 2). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir re√ßu la valeur de bruit de la texture, nous interpolons entre les valeurs min / max (g√©n√©ralement 0 et 1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous faisons la multiplication, par exemple, par la coordonn√©e de la texture V (rappelez-vous que la coordonn√©e V va de 1 √† 0?) - ligne 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, nous avons calcul√© le "masque de luminosit√©" - il ressemble √† ceci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A noter que des objets √©loign√©s (un phare, des montagnes ...) ont disparu. </font><font style="vertical-align: inherit;">Cela est arriv√© parce que le cylindre r√©ussit le test de profondeur - le cylindre n'est pas sur le plan lointain et est dessin√© au-dessus de ces objets:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test de profondeur</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous voulons simuler que le rideau de pluie est plus √©loign√© (mais pas n√©cessairement sur le plan lointain). </font><font style="vertical-align: inherit;">Pour ce faire, nous calculons un autre masque, le ¬´masque d'objets distants¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est calcul√© par la formule suivante: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0,001 est pris dans le tampon), ce qui nous donne le masque souhait√©:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Dans la partie sur l'effet de nettet√©, j'ai d√©j√† expliqu√© superficiellement comment la profondeur de la pyramide de visibilit√© est extraite du tampon de profondeur.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personnellement, il me semble que cet effet pourrait √™tre r√©alis√© moins cher sans calculer la hauteur dans l'espace mondial en multipliant la profondeur de la pyramide de visibilit√© par un nombre plus petit, par exemple 0,0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les deux masques sont multipli√©s, le dernier est obtenu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir re√ßu ce masque final (ligne 16), nous effectuons une autre interpolation, qui ne fait presque rien (au moins dans le cas test√©), puis multiplions le masque final par la couleur des rideaux (ligne 19), effectuons une correction gamma (lignes 20 -22) et multiplications finales (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä la fin, nous retournons une couleur avec une valeur alpha nulle. En effet, le m√©lange est activ√© sur cette passe: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si vous ne comprenez pas tr√®s bien comment fonctionne le m√©lange, voici une courte explication: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SourceColor est la sortie RVB du pixel shader et DestColor est la couleur RVB actuelle du pixel dans la cible de rendu. . Depuis SourceAlpha toujours √©gal √† 0,0, l'√©quation ci - </font><font style="vertical-align: inherit;">dessus se </font><font style="vertical-align: inherit;">r√©duit √†: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, nous effectuons ici un m√©lange additif. </font><font style="vertical-align: inherit;">Si le pixel shader revient (0, 0, 0), la couleur restera la m√™me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le code HLSL fini - je pense qu'apr√®s l'explication, il sera beaucoup plus facile √† comprendre: </font><font style="vertical-align: inherit;">je peux dire avec plaisir que mon pixel shader cr√©e le m√™me code assembleur que dans l'original. </font><font style="vertical-align: inherit;">J'esp√®re que l'article vous a plu. </font><font style="vertical-align: inherit;">Merci d'avoir lu!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437100/">https://habr.com/ru/post/fr437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437088/index.html">Promotion d'une startup √† l'√©tranger: comment toucher des centaines de milliers de lecteurs anglophones avec Medium</a></li>
<li><a href="../fr437092/index.html">La s√©curit√© des algorithmes d'apprentissage automatique. Attaques Python</a></li>
<li><a href="../fr437094/index.html">Nous avons pomp√© Atlassian Service Desk - l'annonce du mitap et de la diffusion en direct</a></li>
<li><a href="../fr437096/index.html">UDB. Qu'est-ce que c'est? Partie 4. Datapath ALU</a></li>
<li><a href="../fr437098/index.html">6 f√©vrier, Moscou, DI Telegraph - Grande cuisine QIWI sur la conception de produits</a></li>
<li><a href="../fr437102/index.html">Nouvelle rencontre de champions Lego: Lego Boost</a></li>
<li><a href="../fr437104/index.html">Introscope: enfin, tests unitaires tr√®s paresseux</a></li>
<li><a href="../fr437106/index.html">IT dans la zone .it</a></li>
<li><a href="../fr437108/index.html">La plupart des textes sur Internet sont √©crits par des fous.</a></li>
<li><a href="../fr437110/index.html">Les nanomat√©riaux changent notre monde et nous n'avons toujours pas de proc√©dures pour v√©rifier leur s√©curit√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>