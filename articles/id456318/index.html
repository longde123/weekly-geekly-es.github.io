<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‹ ğŸ¤Ÿ ğŸ¿ Dasar-dasar Pointer Pemula ğŸ‘†ğŸ» ğŸ•› ğŸ™ŒğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saat ini, karena peningkatan dan murahnya teknologi, jumlah memori dan daya pemrosesan terus bertambah. 

 Menurut Hukum Moore: 
 Jumlah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar Pointer Pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456318/"><h2>  Pendahuluan </h2><br>  Saat ini, karena peningkatan dan murahnya teknologi, jumlah memori dan daya pemrosesan terus bertambah. <br><br>  Menurut Hukum Moore: <br><blockquote>  Jumlah transistor yang ditempatkan pada chip sirkuit terintegrasi berlipat ganda setiap 24 bulan. </blockquote>  Perlu dicatat bahwa dua parameter diubah: <br><br><ul><li>  Jumlah transistor </li><li>  Dimensi modul </li></ul><br>  Prinsip yang sama diproyeksikan pada jumlah RAM (DRAM). <br><br>  Sekarang masalah memori tidak akut, karena jumlah memori selama 10 tahun terakhir telah meningkat 16 kali per mati. <br><a name="habracut"></a><br>  Kebanyakan Bahasa Pemrograman Tingkat Tinggi (PL) sudah "tersembunyi" bersembunyi dengan memori dari programmer.  Dan, karena pertanyaan ini sedang tidur, muncul kasta baru programmer yang tidak mengerti <s>atau tidak ingin memahami</s> bagaimana kerja dengan memori bekerja. <br><br>  Dalam topik ini, kami akan mempertimbangkan poin utama bekerja dengan memori menggunakan contoh bahasa C ++, karena itu adalah salah satu dari beberapa bahasa imperatif yang mendukung kerja langsung dengan memori dan mendukung OOP. <br><br><h2>  Untuk apa ITU? </h2><br><blockquote>  Perlu disebutkan di sini, artikel ini dirancang untuk orang-orang yang baru memulai perjalanan mereka di C ++ atau hanya ingin memiliki ide tentang memori dinamis. </blockquote><br>  Saat runtime, setiap program menyimpan sebagian memori untuk dirinya sendiri dalam DRAM.  Semua ruang bebas DRAM lainnya disebut <u>"Heap"</u> (Bahasa Inggris "Heap").  Alokasi memori selama eksekusi untuk kebutuhan program terjadi tepat dari heap dan disebut alokasi memori dinamis. <br><br>  Seluruh masalah adalah bahwa jika Anda tidak berhati-hati membersihkan memori yang dialokasikan ketika tidak lagi diperlukan, kebocoran memori yang disebut dapat terjadi, di mana sistem <u>(program) Anda</u> hanya hang.  Mirip dengan mobil yang macet di tengah jalan karena seseorang lupa mengisi bahan bakar tepat waktu. <br><br><div class="spoiler">  <b class="spoiler_title">Apa yang harus Anda ketahui</b> <div class="spoiler_text">  Kebanyakan PL modern dilengkapi dengan pengumpul sampah dan membersihkan ingatan mereka sendiri. <br>  Namun, C ++ telah memantapkan dirinya sebagai salah satu API berkinerja tercepat, sebagian karena semua pekerjaan dengan memori di dalamnya dilakukan secara manual. <br></div></div><br><br><h2>  baru dan hapus </h2><br>  Alokasi memori bisa statis dan dinamis.  Alokasi memori statis disebut alokasi memori satu kali selama kompilasi program, dan jumlah memori statis tidak berubah saat runtime.  Contoh klasik adalah deklarasi variabel atau array integer.  Tetapi bagaimana jika programmer tidak tahu sebelumnya berapa banyak elemen yang dibutuhkan dalam wadah? <br>  Penggunaan memori dinamis disarankan bila perlu mengatur alokasi memori untuk kebutuhan program sebagaimana diperlukan. <br>  Operator <i>baru</i> bertanggung jawab untuk mengalokasikan memori dinamis dalam C ++, dan <i>delete</i> bertanggung jawab untuk menghapusnya. <br>  Operator <i>baru</i> mengembalikan hasil operasi pointer ke instance baru kelas. <br>  Sintaksnya adalah ini: <br><br>  |  <b>pointer tipe data (T1)</b> |  * |  <b>nama penunjuk</b> | = <i>baru</i> |  <b>tipe T1</b> |; <br><br>  Setelah operator <i>baru</i> , Anda dapat menggunakan konstruktor, misalnya, untuk menginisialisasi bidang kelas. <br>  Perlu dicatat bahwa kebocoran memori yang sama terjadi tepat ketika programmer kehilangan kendali atas alokasi. <br><blockquote>  Penting untuk diingat: <br>  Jika Anda lupa tentang menghapus memori dinamis dari elemen-elemen yang "tidak perlu" dihabiskan, maka cepat atau lambat sebuah momen kritis akan datang ketika memori tidak akan diambil. </blockquote><br>  Contoh alokasi memori dan pembersihannya: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main{ <span class="hljs-comment"><span class="hljs-comment">// ,       new int *ptr = new int(); //   cout&lt;&lt;*ptr&lt;&lt;endl; // ,     delete ptr; //  delete     ,         return 0; }</span></span></code> </pre> <br><br>  Artikel ini tidak akan membahas apa yang disebut pointer "pintar", karena topiknya sangat luas, tetapi, singkatnya: "pointer Smart sebagian mengotomatiskan proses pembersihan memori untuk programmer." <br><br><h2>  Pointer </h2><br>  Pointer bertanggung jawab untuk bekerja dengan memori dinamis di C ++.  Ini adalah topik di mana nafsu makan memanjakan pemula. <br><br>  Anda dapat mendeklarasikan pointer menggunakan operator <b>*</b> .  Secara default, ini akan menunjuk ke beberapa wilayah memori acak.  Agar kita dapat mengakses area memori yang kita butuhkan, kita perlu meneruskan tautan (operator <b>&amp;</b> ) ke variabel yang diinginkan. <br><br>  Pointer itu sendiri hanyalah alamat sel memori, dan untuk mengakses data yang disimpan dalam sel ini, ia harus ditinjau ulang. <br><h3>  Retret penting </h3><br><blockquote>  Jika Anda mencoba menampilkan pointer tanpa dereferencing, maka alih-alih nilai dari area memori yang ditunjuknya, alamat area memori ini ditampilkan. <br>  Untuk melakukan dereferensi pointer, cukup letakkan operator <b>*</b> di depan namanya. </blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,          int* pNum= new int(1) ; cout&lt;&lt;*pNum&lt;&lt;endl; //    ,        ,       (   int   ) pNum++; cout&lt;&lt;*pNum&lt;&lt;endl; // ,         return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ka/bg/0k/kabg0kkojm0kefvksto7cye60ps.png"><br><br>  Melihat contoh-contoh seperti itu, saya ingin bertanya: "Mengapa ini bahkan perlu jika Anda dapat langsung mengambil variabel?" <br><br>  Contoh lain: <br><br>  Kami memiliki kelas Pemrogram yang menjelaskan anggota tim pemrogram yang <s>tidak tahu tentang petunjuk.</s> <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Programmers int size = 9; Programmers *prog [size]; //  Programmers Programmers *ptr = nullptr; //     Programmers       //          for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } return 0; }</span></span></code> </pre> <br>  Dengan cara ini, memori dapat dimanipulasi sesuka kita.  Dan itulah sebabnya, ketika bekerja dengan ingatan, Anda dapat "menembak diri Anda sendiri."  Perlu dicatat bahwa bekerja dengan pointer jauh lebih cepat, karena nilai itu sendiri tidak disalin, tetapi hanya tautan ke alamat tertentu yang diberikan padanya. <br><br>  Ngomong-ngomong, kata kunci yang begitu populer <b>ini</b> memberikan pointer ke objek kelas saat ini.  <s>Petunjuk ini ada di mana-mana.</s> <br><br>  <b>Contoh pointer dalam kehidupan sehari-hari:</b> <br><br>  Bayangkan sebuah situasi ketika Anda memesan hidangan di restoran.  Untuk melakukan pemesanan, Anda hanya perlu menunjuk ke hidangan di menu dan Anda akan siap.  Dengan cara yang sama, pengunjung lain ke restoran menunjukkan item yang diinginkan dalam menu.  Dengan demikian, setiap baris dalam menu adalah pointer ke fungsi memasak hidangan, dan pointer ini dibuat pada tahap desain menu ini sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Function Pointer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void Chicken(){ cout&lt;&lt;"Wait 5 min...Chicken is cooking"&lt;&lt;endl; } void JustWater(){ cout&lt;&lt;"Take your water"&lt;&lt;endl; } int main() { //    void   void (*ptr)(); ptr = Chicken; ptr(); ptr=JustWater; ptr(); return 0; }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ja/kn/0p/jakn0pthuo6au9wx9w_uqlfbd00.png"><br></div></div><br>  Kembali ke programer kami.  Misalkan sekarang kita perlu membawa bidang kelas ke bagian <b>pribadi</b> , sebagaimana layaknya prinsip enkapsulasi dari OOP, maka kita perlu <b>rajin rajin</b> mendapatkan akses baca ke bidang ini.  Tapi bayangkan kita tidak memiliki 2 bidang, tetapi 100, dan untuk ini kita perlu menulis accessor kita sendiri untuk masing-masing? <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Yah, tentu saja tidak, saya bahkan tidak mengerti mengapa Anda membuka spoiler ini. <br></div></div><br>  Untuk melakukan ini, kita akan membuat "accessor" dari tipe void dan meneruskan argumen dengan referensi.  Arti melewati argumen dengan referensi adalah bahwa nilai argumen tidak disalin, tetapi hanya alamat dari argumen sebenarnya yang dikirimkan.  Jadi, ketika mengubah nilai argumen semacam itu, data dalam sel memori argumen saat ini juga akan berubah. <br>  Ini juga mempengaruhi kinerja secara keseluruhan, karena melewati argumen dengan referensi lebih cepat daripada melewati nilai.  Dan ini belum lagi koleksi besar elemen. <br><br>  Misalnya, metode <i>getParams</i> di dalam akan mengubah argumen yang masuk dan mereka akan mengubah nilainya, termasuk dalam ruang lingkup, dari tempat ia dipanggil. <br>  Pointer akan membantu kami menavigasi array.  Dari teori struktur data, kita tahu bahwa array adalah wilayah memori yang kontinu yang unsur-unsurnya diatur satu demi satu. <br>  Ini berarti bahwa jika Anda mengubah nilai pointer ke jumlah byte yang menempati elemen dalam array, Anda dapat mencapai setiap elemen hingga pointer melampaui batas array. <br>  Buat pointer lain yang akan menunjuk ke elemen pertama dari array <u>programmer</u> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-comment"><span class="hljs-comment">//    ,   main     void getParams(int &amp;w, int &amp;a){ w=weight; a=age; } private: int weight; int age; }; int main() { int size = 9; Programmers *prog [size]; Programmers *ptr=nullptr; for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } int w,a; int count = 9; //    //        Programmers **iter = prog; for (int i=0;i&lt;count;i++) { ptr = *iter++; ptr-&gt;getParams(w,a); if(*(iter-1) != nullptr){ delete *(iter-1); ptr = nullptr; } cout&lt;&lt;w&lt;&lt;"\t"&lt;&lt;a&lt;&lt;endl; } return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/6q/9v/pi/6q9vpiibfo8zddb4znzbfkqcvuu.png"><br><br>  Dalam contoh ini, saya ingin menyampaikan kepada Anda inti dari fakta bahwa ketika Anda mengubah nilai alamat penunjuk, Anda dapat mengakses area memori lain. <br><br>  Struktur data seperti daftar, vektor, dll.  berdasarkan pointer, dan karenanya disebut struktur data dinamis.  Dan untuk mengulanginya lebih tepat menggunakan iterator.  Iterator adalah penunjuk ke elemen struktur data dan menyediakan akses ke elemen kontainer. <br><br><h3>  Kesimpulannya </h3><br>  Setelah memahami topik petunjuk, bekerja dengan memori menjadi bagian pemrograman yang menyenangkan, dan secara keseluruhan pemahaman terperinci tentang bagaimana mesin bekerja dengan memori dan cara mengelolanya muncul.  Dalam arti tertentu, ada filosofi di balik konsep "Bekerja dengan ingatan".  Di ujung jari Anda, Anda mengubah muatan pada pelat kapasitor yang sangat kecil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456318/">https://habr.com/ru/post/id456318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456304/index.html">Cara menerbitkan utilitas konsol di PyPI dalam 1 menit</a></li>
<li><a href="../id456306/index.html">Teknologi mikroelektronika di jari: Hukum Moore, gerakan pemasaran, dan mengapa nanometer tidak sama sekarang. Bagian 3</a></li>
<li><a href="../id456310/index.html">Logistik aksi untuk pengumpulan terpisah barang daur ulang</a></li>
<li><a href="../id456314/index.html">Saya ada benarnya</a></li>
<li><a href="../id456316/index.html">Frontend Weekly Digest (10 - 16 Juni 2019)</a></li>
<li><a href="../id456320/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 369 (10 - 16 Juni 2019)</a></li>
<li><a href="../id456322/index.html">Cara memanfaatkan konferensi secara maksimal. Instruksi untuk yang terkecil</a></li>
<li><a href="../id456332/index.html">PHP Digest No. 158 (3-17 Juni, 2019)</a></li>
<li><a href="../id456336/index.html">11 tips untuk menggunakan Redux saat mengembangkan Bereaksi aplikasi</a></li>
<li><a href="../id456338/index.html">13 single-liners JavaScript yang bermanfaat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>