<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüåæ ‚òòÔ∏è üë©üèæ‚Äçüöí Windows Notification Facility: la surface d'attaque la plus non document√©e üå¨Ô∏è üë®‚Äçüéì üïê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sous la coupe se trouve une traduction de la pr√©sentation "La fonction de notification Windows: la surface d'attaque de noyau la plus non document√©e √†...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: la surface d'attaque la plus non document√©e</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Sous la coupe se trouve une traduction de la <strong>pr√©sentation</strong> "La fonction de notification Windows: la surface d'attaque de noyau la plus non document√©e √† ce jour" pr√©sent√©e par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alex Ionescu</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gabrielle Viala</a> lors de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la conf√©rence BlackHat 2018</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Ce qui sera discut√© dans la publication</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que la fonction de notification Windows (WNF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi WNF est apparu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Noms des √©tats WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appels syst√®me pour travailler avec WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de mode utilisateur de haut niveau (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de niveau noyau de haut niveau (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilitaires d'analyse WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surface d'attaque WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Noms d'√©tat WNF int√©ressants et sensibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Injection de processus avec WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Orientations pour de nouvelles recherches</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  Qu'est-ce que la fonction de notification Windows (WNF) </h3><br><p>  Windows Notification Facility est un m√©canisme de notification (disponible √† la fois dans le noyau et en mode utilisateur), qui est bas√© sur le mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©diteur-abonn√©</a> ( <em>pubsub</em> , Publisher / Subscriber).  Le m√©canisme a √©t√© ajout√© dans Windows 8: en partie pour r√©soudre certaines limitations de conception de longue date dans le syst√®me d'exploitation, mais aussi pour servir de base √† la mise en ≈ìuvre de notifications push similaires √† iOS / Android. </p><br><p>  Sa principale caract√©ristique est qu'il s'agit d'un mod√®le <em>aveugle</em> (g√©n√©ralement sans enregistrement) qui permet un abonnement et une publication non ordonn√©s.  Cela implique qu'un consommateur peut souscrire √† une notification avant m√™me que la notification ait √©t√© publi√©e par sa source.  Et que celui qui g√©n√®re les √©v√©nements n'est pas tenu de "s'inscrire" √† l'avance. </p><br><p>  De plus, le m√©canisme prend en charge: </p><br><ul><li>  notifications permanentes et temporaires </li><li>  augmenter de fa√ßon monotone les identifiants uniques </li><li>  tampon de charge utile (jusqu'√† 4 kilo-octets) pour chaque √©v√©nement </li><li>  mod√®le de notification de pool de threads avec s√©rialisation bas√©e sur les groupes </li><li>  un mod√®le de s√©curit√© bas√© sur la port√©e qui impl√©mente des descripteurs de s√©curit√© via le m√©canisme <abbr title="Liste de contr√¥le d'acc√®s discr√©tionnaire">DACL</abbr> / <abbr title="Liste de contr√¥le d'acc√®s au syst√®me">SACL</abbr> standard </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  Pourquoi WNF est apparu </h3><br><p>  Prenons un exemple canonique: il y a un pilote qui veut savoir qu'un volume avec acc√®s en lecture et en √©criture a √©t√© connect√©.  Pour vous en informer, Autochk (un analogue de <abbr title="v√©rification de la coh√©rence du syst√®me de fichiers">fsck</abbr> sous Windows) signale un √©v√©nement appel√© VolumesSafeForWriteAccess.  Mais pour signaler un √©v√©nement, vous devez d'abord cr√©er l'objet √©v√©nement lui-m√™me. </p><br><p>  Nous devons √©galement savoir qu'Autochk travaille d√©j√† sur le volume, mais n'a pas encore signal√© l'√©v√©nement que nous attendons.  Mauvaise solution: asseyez-vous en boucle avec sleep (), v√©rifiez la pr√©sence d'un √©v√©nement, et quand l'√©v√©nement est cr√©√© - attendez-le. </p><br><p>  Mais apr√®s avoir quitt√© l'application Windows, tous ses descripteurs sont ferm√©s.  Et lorsque l'objet n'a pas de descripteurs, il est d√©truit.  Alors, qui organisera cet √©v√©nement? </p><br><p>  Sans WNF, la solution consiste pour le noyau du syst√®me d'exploitation √† g√©n√©rer un √©v√©nement avant le chargement des pilotes et √† Autochk de l'ouvrir comme le ferait un consommateur, mais au lieu d'attendre, il devrait signaler cet √©v√©nement. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Noms des √©tats WNF </h3><br><p>  Dans le monde WNF, un nom d'√©tat est un nombre 64 bits.  Mais il y a une astuce - en fait, c'est une structure cod√©e.  Le nom de l'√©tat a une <em>version</em> , <em>une dur√©e de vie</em> , une <em>√©tendue</em> , un <em>indicateur de persistance des donn√©es</em> et un <em>num√©ro de s√©rie unique</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Mais ces donn√©es ne seront disponibles que si nous pro-XOR un nombre 64 bits avec une constante magique: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Dur√©e de vie du nom de l'√âtat </h4><br><p>  Le nom d'√©tat WNF peut √™tre (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bien connu </li><li>  permanent </li><li>  persistant </li><li>  temporaire </li></ul><br><p>  Les trois premiers sont associ√©s aux cl√©s correspondantes dans le registre, o√π les informations d'√©tat seront stock√©es: </p><br><ul><li>  des noms connus se trouvent dans HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notifications </li><li>  les noms persistants vivent dans HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notifications </li><li>  les noms persistants vivent dans HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Les noms connus ont leur particularit√©: ils ne peuvent pas √™tre enregistr√©s.  Un tel nom doit d√©j√† √™tre pr√©sent√© dans le registre au moment du d√©marrage du syst√®me.  Les noms persistants et persistants n√©cessitent le privil√®ge SeCreatePermanentPrivilege inclus (comme les autres objets globaux) pour les cr√©er.  Les noms persistants vivent en dehors du processus d'enregistrement, tandis que les noms persistants survivent √† un red√©marrage du syst√®me. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Port√©e des donn√©es </h4><br><p>  L'√©tendue des donn√©es d√©finit la premi√®re limite de s√©curit√© autour du nom d'√©tat WNF; elle d√©termine qui la voit et y a acc√®s.  La port√©e du nom d'√©tat peut √™tre: </p><br><ul><li>  le syst√®me </li><li>  la voiture </li><li>  session utilisateur </li><li>  l'utilisateur </li><li>  le processus </li></ul><br><p>  En plus de fournir des limites de s√©curit√©, les √©tendues WNF peuvent √™tre utilis√©es pour fournir diff√©rentes instances de donn√©es pour le m√™me nom.  Le noyau (comme avec d'autres m√©canismes de s√©curit√©) contourne les v√©rifications d'acc√®s √† l'√©tat.  Le privil√®ge TCB permet un acc√®s crois√© aux noms d'√©tat WNF. </p><br><p>  L'√©tendue "syst√®me" et l'√©tendue "machine" sont des √©tendues globales.  Ils n'ont pas leurs propres identifiants (ils utilisent diff√©rents conteneurs globaux).  La port√©e de la session utilisateur utilise l'identifiant de session (ID de session) comme ID.  La port√©e d'un utilisateur sp√©cifique utilise le SID de cet utilisateur comme identifiant.  L'adresse de l'objet EPROCESS est l'identifiant de la port√©e du processus. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  Num√©ros de s√©quence </h4><br><p>  Pour garantir l'unicit√©, chaque nom d'√©tat poss√®de un num√©ro de s√©quence unique de 51 bits.  Les noms bien connus incluent une √©tiquette de famille √† 4 caract√®res dans leur num√©ro de s√©rie, et les 21 bits restants sont utilis√©s comme identifiant unique.  Les noms permanents stockent leur num√©ro d'incr√©mentation avec la valeur de registre "SequenceNumber".  Les noms persistants et temporaires utilisent un compteur d'incr√©mentation commun, qui se trouve dans une variable globale.  Ces donn√©es sont stock√©es et trait√©es s√©par√©ment pour chaque conteneur (par silo) et sont disponibles dans PspHostSiloGlobals-&gt; WnfSiloState. </p><br><p>  Dans Microsoft, chaque nom WNF a un identifiant "convivial" qui est utilis√© dans le code, parfois il est stock√© dans l'espace de noms global avec le m√™me nom.  Par exemple, le symbole nt! WNF_BOOT_DIRTY_SHUTDOWN, qui a la valeur 0x1589012fa3bc0875.  Apr√®s XOR avec la constante magique <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY,</abbr> nous obtenons la valeur 0x544f4f4200000801, qui peut √™tre interpr√©t√©e au niveau du bit comme: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Appels syst√®me pour travailler avec WNF </h3><br><p>  Les appels syst√®me du noyau vous permettent d'enregistrer et de supprimer des noms d'√©tat WNF, de publier et de recevoir des donn√©es de nom d'√©tat WNF et de recevoir diverses notifications de WNF. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Enregistrer le nom du statut WNF </h4><br><p>  √Ä l'exception des noms bien connus (comme mentionn√© pr√©c√©demment), le nom d'√©tat WNF peut √™tre enregistr√© pendant que le syst√®me d'exploitation est en cours d'ex√©cution: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Il existe un syst√®me sym√©trique appel√© ZwDeleteWnfStateName avec lequel vous pouvez supprimer le nom d'√©tat enregistr√© (√† nouveau, sauf pour les plus connus). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Publier les donn√©es d'√©tat WNF </h4><br><p>  Pour d√©finir ou modifier les donn√©es de nom d'√©tat WNF, vous pouvez utiliser l'appel syst√®me ZwUpdateWnfStateData: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Il existe un syst√®me sym√©trique appel√© ZwDeleteWnfStateData pour supprimer (nettoyer) les donn√©es du nom d'√©tat WNF. </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Obtention des donn√©es d'√©tat WNF </h4><br><p>  Afin de demander les donn√©es de nom d'√©tat WNF, l'appel syst√®me suivant peut √™tre utilis√© (la plupart des param√®tres sont similaires √† la fonction de mise √† jour): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  La v√©ritable force r√©side dans le fait que les fonctions API de mise √† jour et de requ√™te ne n√©cessitent en fait pas de nom d'√©tat WNF <u>enregistr√©</u> .  Et si le nom n'est pas temporaire (et que le code appelant dispose de privil√®ges suffisants), une instance du nom peut √™tre enregistr√©e en temps r√©el! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  Notifications WNF </h4><br><p>  Jusqu'√† pr√©sent, nous avons suppos√© que le consommateur savait quand appeler la fonction d'acquisition de donn√©es.  Mais il y a aussi la <em>lecture bloquante</em> , qui fonctionne √† l'aide d'un syst√®me de notification (qui est plus proche du vrai mod√®le √©diteur-abonn√©). </p><br><p>  Tout d'abord, le processus doit enregistrer l'√©v√©nement en appelant la fonction ZwSetWnfProcessNotificationEvent.  Ensuite, vous devez appeler la fonction ZwSubscribeWnfStateChange, en sp√©cifiant un masque d'√©v√©nement pour obtenir l'identifiant d'abonnement sur la sortie.  Les √©v√©nements peuvent √™tre de deux types: </p><br><ul><li>  Notifications de donn√©es: <br><ul><li>  0x01 - apparence des donn√©es </li><li>  0x10 - destruction de nom </li></ul></li><li>  M√©ta m√©tanotifications <br><ul><li>  0x02 - apparence d'un abonn√© recevant des notifications de donn√©es (abonn√© aux donn√©es) </li><li>  0x04 - apparition d'un abonn√© recevant des m√©ta-notifications (Meta Subscriber) </li><li>  0x08 - l'apparition d'un abonn√© recevant des notifications de donn√©es et des m√©ta-notifications (abonn√© g√©n√©rique) </li></ul></li></ul><br><p>  Ensuite, vous devez attendre l'√©v√©nement qui a √©t√© enregistr√©.  Et chaque fois que l'√©v√©nement devient un signal, vous devez appeler la fonction ZwGetCompleteWnfStateSubscription, qui renvoie WNF_DELIVERY_DESCRIPTOR. </p><br><p>  Mais ces fonctions API de bas niveau ont un probl√®me (merci √† Gabi de l'avoir √©tudi√©): chaque processus ne peut avoir qu'un seul √©v√©nement enregistr√©. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  API de mode utilisateur de haut niveau (ntdll) </h3><br><p>  En ce qui concerne les notifications, les choses se compliquent, donc la couche rtl de ntdll.dll fournit une interface plus simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  En fait, il n'est pas n√©cessaire d'appeler directement les services syst√®me: il suffit d'utiliser une seule file d'attente d'√©v√©nements g√©r√©e par ntdll.dll. </p><br><p>  Dans les coulisses, le contenu de WNF_DELIVERY_DESCRIPTOR est converti en param√®tres de rappel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Pour chaque nouvel abonnement, une entr√©e est effectu√©e, qui est plac√©e dans la liste point√©e par la variable globale RtlpWnfProcessSubscriptions.  La liste est construite sur l'un des champs WNF_NAME_SUBSCRIPTION, qui est de type LIST_ENTRY.  Chacun de WNF_NAME_SUBSCRIPTION, √† son tour, a un autre champ LIST_ENTRY pour organiser une liste de WNF_USER_SUBSCRIPTION avec un rappel et un contexte. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  API de niveau noyau de haut niveau (Ex) </h3><br><p>  WNF fournit √©galement des fonctions presque identiques pour le code en mode noyau (qui peut √™tre utilis√© √† partir du pilote): √† la fois via des appels syst√®me export√©s et via des fonctions API de haut niveau lors de l'ex√©cution (couche Ex). </p><br><p>  La fonction ExSubscribeWnfStateChange accepte le nom d'√©tat, les masques de type et l'adresse de la fonction de rappel + contexte en tant qu'entr√©e et renvoie un descripteur d'abonnement.  Les fonctions de rappel re√ßoivent le nom cible, le masque d'√©v√©nement, le libell√© de changement, mais pas le tampon ni sa taille. </p><br><p>  La fonction ExQueryWnfStateData, bas√©e sur le descripteur d'abonnement transmis, lit les donn√©es d'√©tat actuelles.  En fait, chaque rappel finit par appeler la fonction ExQueryWnfStateData pour obtenir les donn√©es associ√©es √† la notification. </p><br><p>  Pour les abonnements en mode noyau et les abonnements en mode utilisateur, WNF (pour suivre les abonnements) cr√©e une instance de la structure WNF_SUBSCRIPTION.  Mais pour le mode utilisateur, certains champs ne seront pas remplis, par exemple Callback et Context, car pour le mode utilisateur, les adresses des gestionnaires sont stock√©es et trait√©es par ntdll.dll. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  Structures de donn√©es WNF </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>D'un traducteur</em></u> : voir la section suivante. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  Utilitaires d'analyse WNF </h3><br><p>  <u><em>D'un traducteur</em></u> : ici, il convient de rappeler √† nouveau que la pr√©sentation a √©t√© r√©alis√©e non seulement par Alex, mais aussi par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gabrielle Viala</a> .  En particulier, sa paternit√© appartient au module WnfCom d√©crit ci-dessous.  De plus, Gabrielle a d√©crit les structures internes de WNF avec suffisamment de d√©tails (voir l'illustration dans la section pr√©c√©dente).  La plupart de ses diapositives, malheureusement, sont absentes dans le pdf de la pr√©sentation (indiqu√©e comme l'original) ou indiqu√©es exclusivement par des titres.  Mais: </p><br><ul><li>  C'est une excellente occasion de regarder un enregistrement de leur performance conjointe: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Notification Facility: Peeling the Oignon of the Most Undocumented Kernel Attack Surface Yet</a> (le d√©but de Gabrielle ~ 19: 27).  L√† (en plus des structures de donn√©es), il y aura une histoire sur la fa√ßon dont ils ont corrig√© l'extension du d√©bogueur! Wnf (spoiler - en utilisant la m√©thode d√©crite dans The NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fixing Broken Debugger Extensions</a> ) </li><li>  Gabrielle a un bon article s√©par√© (d√©taill√©, pas comme une pr√©sentation) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jouer avec le Windows Notification Facility (WNF)</a> , qui est √©galement fortement recommand√© pour la lecture √† tous ceux qui sont int√©ress√©s. </li></ul><br><p>  <u><em>Et du traducteur</em></u> : Si quelqu'un veut compl√©ter la traduction actuelle avec le contenu des diapositives de Gabrielle ou √©tendre la traduction de la st√©nographie de n'importe quelle partie de la vid√©o du discours - bienvenue.  Pour la commodit√© d'ajouter / modifier de gros morceaux, je peux publier la source de traduction sur github (ou un autre serveur de contr√¥le de version). </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom est un module python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source github</a> ) qui montre l'interop√©rabilit√© via WNF.  Caract√©ristiques cl√©s: </p><br><ul><li>  vous permet de lire / √©crire des donn√©es √† partir d'instances d'instance existantes </li><li>  vous permet de cr√©er des noms d'√©tat temporaires (en tant que <em>serveur</em> ) </li><li>  vous permet d'obtenir une instance d'un objet c√¥t√© <em>client</em> qui traitera les notifications concernant la modification d'une instance sp√©cifique d'un nom </li></ul><br><p>  Exemple d'utilisation: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump est un utilitaire de ligne de commande √©crit en C. Le fichier ex√©cutable peut √™tre trouv√© √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ionescu007/wnfun</a> en s√©lectionnant le sous-r√©pertoire de la profondeur de bits requise.  L'utilitaire peut √™tre utilis√© pour rechercher des informations sur les noms d'√©tat WNF: </p><br><ul><li>  -d ( <u>D</u> ump) Vide tous les noms d'√©tat WNF √† l'aide d'une √©num√©ration bas√©e sur le registre.  Il peut √™tre compl√©t√© par des options: <br><ul><li>  -v ( <u>V</u> erbose) Une sortie d√©taill√©e qui inclut un vidage hexad√©cimal des donn√©es d'√©tat WNF; </li><li>  -s ( <u>S</u> ecurity) Descripteurs de s√©curit√© - Cha√Ænes SDDL d'autorisations pour le nom d'√©tat WNF. </li></ul></li><li>  -b ( <u>B</u> rute-force) √ânum√©ration directe des noms d'√©tats WNF temporaires (voir ci-dessous) </li><li>  -i (Informations) Affiche des informations sur un seul nom d'√©tat WNF sp√©cifi√© </li><li>  -r (Lire) Lire les donn√©es du nom d'√©tat WNF sp√©cifi√© </li><li>  -w ( <u>W</u> rite) √âcrire des donn√©es dans le nom d'√©tat WNF sp√©cifi√© </li><li>  -n ( <u>N</u> otification) Enregistrer un abonn√© de notification pour le nom d'√©tat WNF sp√©cifi√© (ci-apr√®s sera un cas d'utilisation plus sp√©cifique avec Edge) </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  Surface d'attaque WNF </h3><br><p>  Cette section (plus pr√©cis√©ment, ses sous-sections) discutera des attaques possibles et des donn√©es WNF sensibles int√©ressantes. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Divulgation de donn√©es privil√©gi√©e </h4><br><p>  En lisant les milliers de noms d'√©tats WNF qui existent dans le syst√®me, plusieurs peuvent √™tre not√©s, dont les donn√©es semblent tr√®s int√©ressantes.  Parmi eux, certains dont les donn√©es sont √©trangement similaires √† des pointeurs ou √† d'autres donn√©es privil√©gi√©es. </p><br><p>  Apr√®s avoir jou√© sur plusieurs machines, dans certains cas, il √©tait possible de trouver un groupe, une pile et d'autres informations privil√©gi√©es divulgu√©es au-del√† des limites de privil√®ges.  Des rapports de bogues / vuln√©rabilit√©s ont √©t√© soumis √† MSRC en juillet, mais ont √©t√© corrig√©s en novembre (apr√®s la pr√©sentation).  Par exemple: 4 kilo-octets de pile ont fui lors de l'√©v√©nement WNF_AUDC *! </p><br><p>  Les principaux probl√®mes sont les m√™mes que ceux que nous avons vus dans les √©tudes pr√©c√©dentes de j00ro, taviso et autres.  Certains noms d'√©tat WNF contiennent des structures de donn√©es cod√©es avec divers probl√®mes de remplissage et / ou d'alignement.  Dans certains cas, des fuites de m√©moire non initialis√©es. <br>  <u><em>Du traducteur</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction de la partie introductive du document Detecting Kernel Memory Disclosure with x86 Emulation and Taint Tracking de Mateusz Jurczyk aka j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  D√©couverte des noms d'√©tat et des autorisations </h4><br><p>  La premi√®re approche a consist√© √† d√©couvrir tous les noms d‚Äô√©tats possibles pouvant √™tre manipul√©s avec malveillance.  Pour les noms connus, permanents et persistants, l'√©num√©ration est possible en √©num√©rant les cl√©s de registre.  Ensuite, les valeurs trouv√©es peuvent √™tre compar√©es √† des identifiants conviviaux (il existe plusieurs endroits o√π vous pouvez les trouver :)) </p><br><p>  Ensuite, nous pouvons √©galement regarder le descripteur de s√©curit√© dans le registre (c'est la premi√®re chose dans le tampon de donn√©es).  Le descripteur de s√©curit√© n'est pas canonique: il n'a ni propri√©taire ni groupe, il n'est donc pas techniquement valide.  Mais il n'y a aucun probl√®me √† remplacer un faux propri√©taire et un groupe pour <em>corriger</em> le descripteur de s√©curit√©. </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  D√©tection des noms d'√©tat temporaires et de leurs autorisations </h4><br><p>  Mais avec des noms temporaires, les astuces d√©crites ci-dessus ne fonctionneront pas: elles ne sont pas dans le registre.  Et seul le noyau stocke des structures de donn√©es pour eux (! Wnf) en m√©moire.  Mais les noms temporaires ne sont en fait pas si difficiles √† utiliser brutalement: </p><br><ul><li>  La version compte toujours 1 </li><li>  La dur√©e de vie compte toujours WnfTemporaryStateName </li><li>  Le drapeau permanent est toujours effac√© (le nom d'√©tat temporaire ne peut pas avoir de donn√©es permanentes) </li><li>  La port√©e (port√©e) peut prendre l'une des 4 valeurs </li></ul><br><p>  Oui, mais le num√©ro de s√©quence restant est de 51 bits!  En effet ... mais n'oubliez pas que les num√©ros de s√©rie augmentent de fa√ßon monotone.  Et pour les noms temporaires, la s√©quence est r√©initialis√©e √† 0 √† chaque d√©marrage.  Classiquement, vous pouvez prendre une fen√™tre d'un million de num√©ros de s√©rie: dans une boucle, v√©rifiez l'existence de chaque nom (√† partir de 0) en appelant ZwQueryWnfStateNameInformation avec la classe d'informations demand√©e WnfInfoStateNameExist (√©tant donn√© que l'erreur d'acc√®s indique √©galement l'existence d'un nom).  Si un autre million de noms n'existe pas, vous pouvez arr√™ter la recherche. </p><br><p>  Les descripteurs de s√©curit√© des noms temporaires (comme les autres donn√©es de noms temporaires) sont stock√©s dans le noyau.  Par cons√©quent, la seule fa√ßon de les demander est l'extension! Wnf lors du d√©bogage du mode noyau.  Mais nous pouvons: </p><br><ul><li>  Faites une conclusion sur les autorisations de lecture lorsque vous essayez de lire des donn√©es. </li><li>  Pour conclure que l'enregistrement est autoris√© en tentant d'√©crire des donn√©es.  Mais il vaut la peine de consid√©rer qu'une √©criture r√©ussie, m√™me 0 octet, d√©truit les donn√©es que le v√©ritable consommateur n'a pas encore r√©ussi √† obtenir.  Et encore une fois, il y a une astuce: nous pouvons appliquer le tampon de changement appropri√©.  Nous essayons d'√©crire avec l'√©tiquette 0xFFFFFFFF: l'√©tiquette est v√©rifi√©e apr√®s la v√©rification d'acc√®s, par cons√©quent, la valeur d'erreur entra√Æne une fuite de l'autorisation d'√©criture. </li></ul><br><p>  Cela ne nous donne pas un descripteur de s√©curit√© complet, mais en ex√©cutant le code avec diff√©rents privil√®ges, nous pouvons avoir une id√©e des restrictions pour diff√©rents comptes syst√®me (IL faible / Utilisateur / Admin / SYST√àME). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Inscription des abonn√©s </h4><br><p>  Dans la structure WNF_PROCESS_CONTEXT, l'un des champs est la t√™te de liste (LIST_ENTRY) de tous les abonnements de ce processus.  Chaque abonnement est une instance distincte de WNF_SUBSCRIPTION. </p><br><p>  Les abonn√©s en mode noyau appartiennent principalement au processus syst√®me.  Nous pouvons utiliser la commande! List debugger pour vider les gestionnaires et leurs param√®tres enregistr√©s dans le processus syst√®me WNF_SUBSCRIPTION.  Il convient de noter que dans certains cas, un agr√©gateur d'√©v√©nements (CEA.SYS) est utilis√©, qui masque les adresses de rappel r√©elles dans sa structure de contexte. </p><br><p>  Nous pouvons r√©p√©ter cette approche pour les processus en mode utilisateur, mais l'adresse de rappel sera NULL, car ce sont des abonn√©s en mode utilisateur.  Par cons√©quent, nous devons rejoindre l'espace utilisateur du processus, obtenir la table RtlpWnfProcessSubscriptions, puis vider la liste des instances WNF_USER_SUBSCRIPTION, dont chacune contient d√©j√† l'adresse de rappel.  Malheureusement, ce caract√®re est statique, ce qui signifie qu'il n'est pas en caract√®res ouverts, mais il peut √™tre trouv√© en le d√©sassemblant.  Et encore une fois, il convient de faire attention (par analogie avec le mode noyau CEA.SYS) que de nombreux gestionnaires en mode utilisateur utilisent l'agr√©gateur d'√©v√©nements (EventAggregation.dll), qui stocke le rappel dans son contexte. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Noms d'√©tat WNF int√©ressants et sensibles </h3><br><p>  Cette section fournit des exemples int√©ressants de la fa√ßon dont certains noms d'√©tat WNF r√©v√®lent des informations syst√®me. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  D√©termination de l'√©tat du syst√®me et du comportement de l'utilisateur √† l'aide de WNF </h4><br><p>  Certains identifiants WNF peuvent √™tre utilis√©s pour obtenir des informations sur l'√©tat de la machine qui vous int√©resse: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - √âtat sans fil </li><li>  WNF_BLTH_BLUETOOTH_STATUS - de m√™me, mais pour Bluetooth (√©galement WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE - affiche la source d'alimentation (batterie ou adaptateur secteur) </li><li>  WNF_SEB_BATTERY_LEVEL - contient le niveau de la batterie </li><li>  WNF_CELL_ * - sur Windows Phone contient des informations sur: r√©seau, num√©ro, puissance du signal, EDGE ou 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER ‚Äî   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT ‚Äî    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED ‚Äî    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      ‚Äî       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE ‚Äî     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST ‚Äî   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK ‚Äî ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND ‚Äì   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory ‚Äî    </li><li>   ( ) ‚Äî               </li><li>   (Atom) ‚Äî            </li><li>    ‚Äî  ,   WM_COPYDATA  DDE,       </li><li> GUI  ‚Äî    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Appel de proc√©dure asynchrone">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " ‚Äî  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Contr√¥le de l'√©coulement">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> github</a> )   explorer (  ‚Äî  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restaurer le gestionnaire d'origine dans WNF_USER_SUBSCRIPTION et lib√©rer les ressources allou√©es </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459626/">https://habr.com/ru/post/fr459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459616/index.html">Le MIPT ouvre le premier programme de master avanc√© de Russie en informatique et g√©nie logiciel</a></li>
<li><a href="../fr459618/index.html">Quelques fonctionnalit√©s de composition de docker peu connues</a></li>
<li><a href="../fr459620/index.html">TDDx2, BDD, DDD, FDD, MDD et PDD, ou tout ce que vous voulez savoir sur le d√©veloppement pilot√©</a></li>
<li><a href="../fr459622/index.html">Comme les jeux pour Sega Saturn ont √©t√© √©crits en 1995</a></li>
<li><a href="../fr459624/index.html">Drones militaires</a></li>
<li><a href="../fr459628/index.html">L'Open Invention Network compte plus de trois mille licenci√©s - qu'est-ce que cela signifie pour les logiciels open source</a></li>
<li><a href="../fr459630/index.html">Tic Tac Toe Partie 2: Annuler / R√©tablir sans √©tat</a></li>
<li><a href="../fr459638/index.html">Cr√©ation d'une base de connaissances mondiale sur les batteries</a></li>
<li><a href="../fr459640/index.html">Documents en tant que code. Partie 1: automatiser la mise √† jour</a></li>
<li><a href="../fr459642/index.html">Acc√®s s√©curis√© aux champs d'enregistrement en C ++ sans sacrifier l'efficacit√© (en utilisant CortexM comme exemple)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>