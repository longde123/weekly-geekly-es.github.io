<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦈 🧙 🔄 Buku Masakan Pengembang: Resep DDD (Bagian 3, Arsitektur Aplikasi) 👩🏼‍🏭 🖖 🤴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Dalam artikel sebelumnya, kami mengidentifikasi ruang lingkup pendekatan dan memeriksa prinsip-prinsip metodologis dasar Desain Domain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku Masakan Pengembang: Resep DDD (Bagian 3, Arsitektur Aplikasi)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429750/"><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Dalam artikel sebelumnya, kami mengidentifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang lingkup</a> pendekatan dan memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip-prinsip metodologis dasar Desain Domain Driven</a> . </p><br><p> Dalam artikel ini, saya ingin menguraikan pendekatan modern utama untuk membangun arsitektur sistem perusahaan: Lentur, Menjerit, Bersih dan memberi mereka interpretasi saya yang jelas dalam bentuk solusi turnkey lengkap. </p><br><p><img src="https://habrastorage.org/webt/jw/jt/mr/jwjtmrixh99-s5hje6sn32l-0s4.jpeg" alt="WM"></p><br><p>  Di masa mendatang, kami akan mempertimbangkan setiap pola desain secara terperinci: kami menunjukkan cakupan, memberikan contoh kode, menyoroti praktik yang direkomendasikan.  Sebagai hasilnya, kami akan menulis microservice yang sudah jadi. </p><a name="habracut"></a><br><h1 id="gibkaya-arhitektura">  Arsitektur yang fleksibel </h1><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir,</a> kami fokus pada fakta bahwa DDD mencakup praktik implementasi melalui model.  Area subjek harus dijelaskan melalui kode Anda.  Mari kita coba mencari tahu bagaimana melakukan ini. </p><br><p>  Dalam bukunya, Eric Evans memberikan serangkaian pola desain yang direkomendasikan dan menunjuk pendekatan ini sebagai fleksibel: </p><br><blockquote>  Atas nama fleksibilitas arsitektur, banyak konstruksi yang tidak perlu ditumpuk dalam program.  Tingkat abstraksi yang berlebihan dan hubungan tidak langsung lebih cenderung mengganggu daripada membantu dalam hal ini.  Lihatlah arsitektur yang benar-benar menginspirasi programmer untuk memperbaikinya, dan Anda biasanya akan melihat sesuatu yang sangat sederhana.  Namun sederhana bukan berarti mudah dijalankan.  Untuk menciptakan elemen-elemen seperti itu yang dapat dirangkai menjadi sistem yang kompleks dan pada saat yang sama mudah dipahami, perlu untuk menggabungkan "dedikasi" untuk merancang sesuai model dengan gaya arsitektur yang cukup ketat.  Keterampilan desain tertentu diperlukan tidak hanya untuk membuat sesuatu, tetapi bahkan untuk menggunakan yang sudah jadi. <br><br>  Eric Evans, Desain Berbasis Domain: Mengatasi Kompleksitas di Jantung Perangkat Lunak </blockquote><p>  Rangkaian pola desain yang disajikan bukan arsitektur yang ketat atau solusi siap pakai, melainkan makanan yang dipikirkan. </p><br><h1 id="krichaschaya-arhitektura">  Arsitektur yang mencolok </h1><br><p>  Pikiran serupa muncul di benak banyak pengembang dan perancang sistem yang kompleks. </p><br><p>  Pada tahun 2011, sebuah artikel oleh Robert Martin - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Screaming Architecture</a> diterbitkan, yang mengatakan bahwa kode Anda tidak harus hanya menggambarkan area subjek, tetapi berteriak tentang hal itu, lebih baik tidak sopan. </p><br><blockquote>  Jadi apa yang berteriak dari arsitektur aplikasi Anda?  Ketika Anda melihat struktur direktori tingkat atas, dan file sumber dalam paket tingkat tertinggi;  apakah mereka berteriak: Sistem Perawatan Kesehatan, atau Sistem Akuntansi, atau Sistem Manajemen Inventaris?  Atau apakah mereka berteriak: Rails, atau Spring / Hibernate, atau ASP? <br><br>  Robert C. Martin, 30 September 2011 </blockquote><p>  Robert mengatakan bahwa kode aplikasi Anda harus mencerminkan aktivitas aplikasi, alih-alih beradaptasi dengan aturan kerangka kerja.  Struktur kerangka kerja seharusnya tidak membatasi arsitektur Anda.  Aplikasi, pada gilirannya, tidak boleh dilampirkan ke database atau protokol http, ini hanya mekanisme penyimpanan dan pengiriman.  Kotak pembatas adalah alat.  Anda seharusnya tidak menjadi penganut kerangka kerja tersebut.  Tes aplikasi Anda adalah tes logika operasinya, dan tidak menguji protokol http. </p><br><h1 id="chistaya-arhitektura">  Arsitektur bersih </h1><br><p>  Setahun kemudian, artikel berikutnya oleh Robert Martin - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Bersih</a> .  Di dalamnya, penulis memberi tahu cara membuat kode menjerit.  Setelah mempelajari beberapa arsitektur, ia mengidentifikasi prinsip-prinsip dasar: </p><br><ol><li>  Bingkai Kemerdekaan.  Arsitekturnya tidak tergantung pada perpustakaan yang ada.  Ini memungkinkan Anda untuk menggunakan kerangka kerja sebagai alat, alih-alih kendala yang mengikat tangan Anda. </li><li>  Testabilitas.  Aturan bisnis dapat diuji tanpa antarmuka pengguna, basis data, server web atau cara teknis lainnya. </li><li>  Independensi UI.  Antarmuka pengguna dapat dengan mudah diubah tanpa mengubah sisa sistem.  Misalnya, antarmuka web dapat diganti dengan antarmuka konsol tanpa mengubah logika bisnis. </li><li>  Independensi basis data.  Anda dapat menukar Oracle atau SQL Server dengan Mongo, BigTable, CouchDB atau yang lainnya.  Logika aplikasi Anda tidak boleh terikat database. </li><li>  Bebas dari pengaruh lingkungan.  Bahkan, aturan bisnis Anda tidak tahu apa-apa tentang dunia luar. </li></ol><br><p>  Pada habr sudah menerbitkan artikel yang sangat bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesalahpahaman Arsitektur Bersih</a> .  Penulisnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Jeevuz</a> sangat mengunyah seluk-beluk memahami pendekatan ini.  Saya sangat menyarankan agar Anda membiasakan diri dengan bahan dan materi aslinya. </p><br><h1 id="variativnaya-arhitektura">  Arsitektur Variabel </h1><br><p>  Deskripsi pendekatan di atas tidak terlihat begitu jelas.  Sebagai bagian dari pengembangan arsitektur sejumlah sistem perusahaan yang kompleks, saya dan kolega saya telah mengembangkan interpretasi yang cukup jelas tentang pendekatan yang diuraikan, yang ingin saya sampaikan di bawah ini. </p><br><p>  Sebelum munculnya komputer dan bahasa pemrograman, alur kerja kertas digunakan untuk membangun dan mengelola sistem dengan logika bisnis yang kompleks.  Hasil dari setiap proses adalah dokumen yang pada akhirnya menggambarkan objek bisnis tertentu.  Akibatnya, dokumen menjadi tiga <em>Tindakan</em> sederhana: </p><br><ol><li>  Pembuatan dokumen </li><li>  Pemrosesan dokumen </li><li>  Bekerja dengan arsip dokumen </li><li>  Pengiriman dokumen </li></ol><br><blockquote>  Dokumen - merekam informasi tentang kegiatan ekonomi dari objek bisnis nyata tertentu. </blockquote><p>  Harap dicatat bahwa dokumen itu sendiri bukan objek bisnis nyata, tetapi hanya <em>Modelnya</em> .  Saat ini, dokumen kertas sedang diganti dengan yang elektronik.  Suatu dokumen dapat berupa catatan dalam sebuah tabel, gambar, file, surat yang dikirim atau informasi lain apa pun. <br>  Saya tidak ingin menggunakan kata dokumen di masa depan, karena akan lebih membingungkan, kita akan menggunakan konsep Entity dari terminologi DDD.  Tetapi Anda dapat membayangkan bahwa sekarang seluruh sistem Anda adalah sistem manajemen dokumen elektronik yang melakukan empat <em>Tindakan</em> sederhana. </p><br><ol><li>  Mengumpulkan </li><li>  Pengolahan </li><li>  Penyimpanan </li><li>  Representasi </li></ol><br><blockquote>  Aksi - unit struktural aktivitas model bisnis;  tindakan terpisah yang relatif lengkap dari tujuan sadar, kesewenang-wenangan dan kesengajaan dari aktivitas individu dari objek bisnis, dibedakan oleh pengguna akhir. </blockquote><p>  Contoh yang baik dari <em>Aksi</em> adalah aksi teater.  Teater memodelkan peristiwa dari kehidupan nyata.  Tindakan itu adalah bagian yang berarti dari drama itu.  Tetapi, untuk membuat cerita lengkap, Anda perlu memainkan beberapa aksi dalam urutan yang ditentukan secara ketat.  Perintah seperti itu dalam arsitektur kita akan kita sebut <em>Mode</em> . </p><br><blockquote>  Mode (Konduksi) - serangkaian <em>Tindakan</em> dalam urutan tertentu, memiliki makna lengkap, bermanfaat bagi pengguna akhir. </blockquote><p><img src="https://habrastorage.org/webt/yp/i7/2z/ypi72zofhbqjsziq17lyis6odiw.png" alt="konduksi"></p><br><p>  Untuk <em>Mode</em> Operasi semacam itu, konduktor atau Pemilih selektif ditemukan.  Lebih tepatnya, "Mekanisme pengaturan waktu untuk melakukan yang dipilih dari sejumlah urutan operasi", yang diperoleh paten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">US2870278A</a> .  Kita tahu perangkat ini sebagai "putaran" dari mesin cuci.  Sentuhan arsitektur diberikan pada awal artikel. </p><br><p>  Keragaman pendekatan dimanifestasikan dalam kenyataan bahwa dengan arsitektur ini Anda dapat memilih salah satu dari empat <em>Mode</em> , yang lewat yang Anda tidak akan melakukan <em>Tindakan yang</em> tidak perlu. </p><br><p>  Saat memulai mesin cuci, Anda dapat memilih mode: mencuci, membilas, atau memutar.  Jika Anda memilih untuk mencuci, mesin Anda masih akan membilas cucian, lalu memerasnya.  Dengan bilas di kit Anda yakin akan mendapatkan putaran.  Putar - <em>tindakan</em> terakhir dalam proses pencucian, ini adalah yang paling "sederhana".  Dalam arsitektur kami, <em>Tindakan</em> paling sederhana adalah <em>Representasi</em> , dan kami akan mulai dengannya. </p><br><h2 id="predstavlenie-representation">  Representasi </h2><br><p>  Jika kita berbicara tentang presentasi murni tanpa menggunakan database atau sumber eksternal, maka kita memberikan beberapa informasi statis: halaman html, file, direktori yang terletak dalam bentuk json.  Kami bahkan dapat memberikan <em>respons Kode</em> saja - 200: </p><br><p>  Mari kita menulis "pemeriksa kesehatan" yang paling sederhana </p><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Health</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Endpoints</span></span></span><span class="hljs-class"> &lt; Sinatra::Base </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> '/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Dalam bentuknya yang paling primitif, skema kami akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/-g/b4/ah/-gb4ahfzxvwn1zhxfrrqmoagzcm.png" alt="Representasi"></p><br><div class="spoiler">  <b class="spoiler_title">Penyimpangan liris</b> <div class="spoiler_text"><p>  Saya meminta Anda untuk mencatat bahwa dalam kerangka kerja Sinatra, kelas <em>Endpoints</em> menggabungkan <em>Router</em> dan <em>Controller</em> dalam satu kelas.  Apakah ini melanggar prinsip tanggung jawab tunggal?  Sebenarnya, Endpoint bukan kelas, tetapi lapisan yang diekspresikan melalui kelas, dan area tanggung jawabnya di tingkat yang lebih tinggi. </p><br><p>  Ok, bagaimana dengan <em>Router</em> dan <em>Controller</em> ?  Mereka diwakili bukan oleh satu set kelas, tetapi dengan nama dan implementasi suatu fungsi.  File statis umumnya adalah file.  Satu kelas bertanggung jawab atas satu tanggung jawab, tetapi jangan mencoba untuk mengekspresikan setiap tanggung jawab melalui kelas.  Gunakan kepraktisan, bukan dogmatisme. </p></div></div><br><h2 id="rabota-s-sistemoy-hraneniya-storage">  Bekerja dengan sistem penyimpanan </h2><br><p>  Bisnis menuntut ketersediaan aplikasi Anda.  Mengapa ada orang yang membutuhkan layanan Anda jika kami tidak dapat menggunakannya pada waktu yang tepat?  Untuk memastikan integritas data, kami mencatat perubahan dalam status objek bisnis setelah setiap pemrosesan. </p><br><p>  Untuk mengambil objek dari penyimpanan tidak memerlukan akses ke logika bisnis.  Bayangkan bahwa kita mengotomatiskan kegiatan jaringan hotel dan kita memiliki majalah tamu di resepsi.  Kami memutuskan untuk melihat informasi tentang pengunjung. </p><br><pre> <code class="ruby hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reception</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Endpoints</span></span></span><span class="hljs-class"> &lt; Sinatra::Base </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Show item get '/residents/:id', provides: :json do resident = Repository::Residents.find params[:id] status 200 serialize(resident) end end end</span></span></span></span></code> </pre> <br><p>  <em>Bekerja dengan sistem penyimpanan</em> dalam bentuk diagram grafik: </p><br><p><img src="https://habrastorage.org/webt/dt/1c/ek/dt1cektbpcmlrvz76utwko6tbk4.png" alt="Penyimpanan"></p><br><p>  Seperti yang dapat kita lihat, komunikasi antara lapisan yang bertanggung jawab untuk menyimpan dan lapisan yang bertanggung jawab untuk menyajikan data diimplementasikan melalui model Respon.  Model ini bukan milik salah satu lapisan ini.  Sebenarnya, ini adalah objek bisnis dan terletak di lapisan yang bertanggung jawab atas logika bisnis. </p><br><h2 id="obrabotka-processing">  Pengolahan </h2><br><p>  Jika sampai pada kenyataan bahwa model objek berubah berdasarkan propertinya tanpa memasukkan data baru, maka kita beralih ke lapisan <em>Interactor</em> secara langsung.  Lapisan <em>Interactor</em> adalah kunci dalam aplikasi kita, itu menggambarkan seluruh logika bisnis dalam bentuk Use Use terpisah, dan di atasnya perubahan <em>Entitas</em> . </p><br><p>  Pertimbangkan kasus penggunaan ini.  Pengunjung sudah terdaftar di hotel kami, tetapi kami merayakan setiap kedatangan atau keberangkatannya. </p><br><pre> <code class="ruby hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reception</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Endpoints</span></span></span><span class="hljs-class"> &lt; Sinatra::Base </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Register resident arrival post '/residents/:uid/arrival', provides: :json do result = Interactors::Arrival.call(resident_id: params[:id]) check!(result) do status 201 serialize result.data end end # Register resident departure post '/residents/:uid/departure', provides: :json do result = Interactors::Departure.call(resident_id: params[:id]) check!(result) do status 201 serialize result.data end end end end</span></span></span></span></code> </pre> <br><p>  Mari kita berhenti sebentar.  Mengapa tidak menjadikan implementasi metode tunggal dengan parameter <code>status</code> ?  <em>Para interaktator</em> <code>Arrival</code> dan <code>Departure</code> pada dasarnya berbeda.  Jika seorang tamu datang kepada kami, maka kami harus memeriksa apakah pembersihan sudah selesai, apakah ada pesan baru untuknya, dll.  Dengan kepergiannya, kita, sebaliknya, harus melakukan pembersihan jika perlu.  Pada gilirannya, kami bahkan tidak ingat tentang pesan-pesan itu, karena jika dia berada di sebuah hotel, kami akan segera memanggilnya.  Ini semua logika bisnis yang kami resepkan pada lapisan <em>Interactor</em> . </p><br><p><img src="https://habrastorage.org/webt/of/hk/al/ofhkalijd4o2u3xrwtptgtzjko0.png" alt="Pengolahan"></p><br><p>  Tetapi apa yang harus kita lakukan jika kita memiliki data dari luar?  Di sini aksi <em>Pengumpulan Data</em> terhubung. </p><br><h3 id="sbor-dannyh-collecting">  Mengumpulkan data </h3><br><p>  Selama pendaftaran awal tamu di hotel, ia mengisi formulir pendaftaran.  Formulir ini sedang diverifikasi.  Jika datanya benar, maka proses pendaftaran bisnis berlangsung.  Proses mengembalikan data - model bisnis "penyewa" yang dibuat.  Kami menyajikan model ini kepada tamu dalam bentuk yang dapat dibaca: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reception</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Endpoints</span></span></span><span class="hljs-class"> &lt; Sinatra::Base </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Register new resident post '/residents', provides: [:json] do form = Forms::Registration.new(params) complete! form do check! form.result do status 201 serialize form.result.data end end end end end</span></span></span></span></code> </pre> <br><p>  Secara skematis, tampilannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/fy/ci/dv/fycidvf5npkklovkk6quaatn3oi.png" alt="Mengumpulkan"></p><br><h1 id="pravila-igry-rules">  Aturan main (Aturan) </h1><br><ul><li>  Sistem variatif dari sudut pandang proses dibagi menjadi <em>Tindakan</em> . </li><li>  Urutan <em>Tindakan</em> ditentukan oleh <em>Mode</em> . </li><li>  <em>Mode bersifat</em> inkremental. </li><li>  <em>Mode yang</em> lebih "kompleks" melengkapi yang lebih "sederhana" untuk satu tindakan. </li><li>  Setiap aksi berlangsung dalam kerangka satu <em>Layer</em> . </li><li>  Setiap lapisan diwakili oleh <em>Kelas</em> . </li><li>  Di dalam lapisan, mungkin ada <em>Kelas</em> <em>Lapisan</em> <em>dan Kelas Tanggung Jawab</em> . </li><li>  Komunikasi hanya terjadi antara <em>Layer</em> dan <em>Kelas Interlayer</em> . </li><li>  <em>Model representasi</em> adalah pengecualian. </li><li>  Penanganan kesalahan harus dilakukan di level <em>Class-Layer</em> . </li></ul><br><p><img src="https://habrastorage.org/webt/mb/hz/xk/mbhzxk9rdmqlijg-xsmissqeu1w.png" alt="Pohon"></p><br><h1 id="obschaya-shema">  Skema umum </h1><br><p>  Pendekatan ini memiliki ambang masuk yang tinggi.  Penerapannya membutuhkan banyak pengalaman dari perancang untuk pemahaman yang jelas tentang tugas yang harus diselesaikan.  Kompleksitas juga mewakili beragam pilihan alat yang dibutuhkan.  Tetapi, terlepas dari kompleksitas strukturnya, implementasi pada level kode sangat sederhana dan ekspresif.  Meski mengandung sejumlah konvensi dan surat kuasa.  Di masa mendatang, kami akan menganalisis setiap templat desain secara terpisah, menjelaskan cara membuatnya, mengujinya, dan menentukan cakupannya.  Dan agar tidak bingung dalam keanekaragamannya, ditawarkan peta lengkap: <br><img src="https://habrastorage.org/webt/ln/co/g5/lncog5svcpzab3kc0su-q59aafu.png"></p><br><p>  <a href="">Peta Resolusi Tinggi</a> </p><br><hr><br><div class="spoiler">  <b class="spoiler_title">Sumber inspirasi</b> <div class="spoiler_text"><ul><li>  Desain Berorientasi Masalah, Eric J. Evans </li><li>  Kate Matsudeira: Arsitektur Web Scalable dan Sistem Terdistribusi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/company/mobileup/blog/335382/</a> <br><br></li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429750/">https://habr.com/ru/post/id429750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429732/index.html">Anda akan membenci ini atau dongeng tentang bagaimana kode yang baik seharusnya terlihat</a></li>
<li><a href="../id429734/index.html">Mimpi terbang dengan bias listrik</a></li>
<li><a href="../id429736/index.html">Hogweed dari Sosnowski. Di MO diperkenalkan denda untuk distribusi</a></li>
<li><a href="../id429738/index.html">Pengaturan Shard Optimal dalam Elasticsearch Petabyte Cluster: Linear Programming</a></li>
<li><a href="../id429744/index.html">Pelajari OpenGL. Pelajaran 6.4 - IBL. Paparan specular</a></li>
<li><a href="../id429754/index.html">Kesalahan integrasi perangkat keras fatal</a></li>
<li><a href="../id429756/index.html">Cara mengkonfigurasi instalasi variabel lingkungan Nuxt.js di runtime, atau Cara melakukan semuanya tidak seperti semua orang dan tidak menyesalinya</a></li>
<li><a href="../id429758/index.html">Mengapa dokumentasi SRE penting? Bagian 1</a></li>
<li><a href="../id429762/index.html">Streamer camcorder MiniDV</a></li>
<li><a href="../id429764/index.html">Game "Life" di FPGA Altera Cyclone IV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>