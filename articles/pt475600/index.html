<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèΩ ‚èèÔ∏è üòµ Como conectamos Prometheus üë©üèΩ‚Äçüéì ü§∑üèª üóíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De alguma forma, tive que lidar com as m√©tricas da nossa API, como sempre (sem tempo?!) Para adicionar mais tarde - √© muito dif√≠cil e ainda n√£o foi im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como conectamos Prometheus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475600/"><p> De alguma forma, tive que lidar com as m√©tricas da nossa API, como sempre (sem tempo?!) Para adicionar mais tarde - √© muito dif√≠cil e ainda n√£o foi implementado - significa que √© hora de implement√°-lo.  Depois de algumas andan√ßas na rede, o sistema de monitoramento mais popular, me pareceu, foi o Prometeu. </p><br><p>  Usando o Prometheus, podemos rastrear v√°rios recursos do computador, como: mem√≥ria, processador, disco, carga de rede.  Tamb√©m pode ser importante calcular o n√∫mero de chamadas para os m√©todos de nossa API ou medir o tempo de sua execu√ß√£o, porque quanto maior a carga no sistema, mais caro √© o tempo de inatividade.  E aqui Prometeu vem em nosso aux√≠lio.  Parece-me que este artigo fornece os principais pontos para entender o trabalho do Prometheus e para adicionar uma cole√ß√£o de m√©tricas √† API.  Portanto, come√ßamos com o mais banal, com uma pequena descri√ß√£o. </p><a name="habracut"></a><br><p>  Prometheus √© um sistema de c√≥digo aberto e DBMS de s√©ries temporais escrito em Go e desenvolvido pela SoundCloud.  Possui documenta√ß√£o oficial e suporte para idiomas como: Go, Java ou Scala, Python, Ruby.  H√° suporte n√£o oficial para outros idiomas, como: C #, C ++, C, Bash, Lua para Nginx, Lua para Tarantool e outros; toda a lista est√° no site oficial do Prometheus. </p><br><p>  Todos os servi√ßos do Prometheus est√£o dispon√≠veis como imagens do Docker no Docker Hub ou no Quay.io. </p><br><p> O Prometheus √© iniciado pelo <code>docker run -p 9090:9090 prom/prometheus</code> , que inicia com a configura√ß√£o padr√£o e define a porta <code>localhost:9090</code> Depois disso, a interface do Prometheus estar√° dispon√≠vel no <code>localhost:9090</code> . </p><br><p>  O Prometheus √© um sistema de monitoramento que inclui v√°rias ferramentas para configurar o monitoramento de aplicativos (pontos de extremidade) usando o protocolo HTTP.  Ao se conectar ao Prometheus, a API HTTP n√£o suporta "autentica√ß√£o b√°sica".  Se voc√™ deseja usar a autentica√ß√£o b√°sica para se conectar ao Prometheus, recomendamos que voc√™ use o Prometheus em conjunto com um servidor proxy reverso e use a autentica√ß√£o no n√≠vel do proxy.  Voc√™ pode usar qualquer proxy reverso com o Prometheus. </p><br><p>  <strong><em>Os principais componentes do Prometheus:</em></strong> </p><br><ul><li>  um servidor que coleta m√©tricas, as salva no banco de dados e as limpa; </li><li>  pacotes para coletar m√©tricas na API; </li><li>  Pushgateway - componente para receber m√©tricas de aplicativos para os quais uma solicita√ß√£o Pull n√£o pode ser usada; </li><li>  Exportadores - ferramentas para exportar m√©tricas de aplicativos e servi√ßos de terceiros, instaladas nas m√°quinas de destino; </li><li>  AlertManager - gerenciador de notifica√ß√µes (alertas), os alertas s√£o definidos no arquivo de configura√ß√£o e definidos por um conjunto de regras para m√©tricas. <br>  Se durante a opera√ß√£o houver conformidade com a regra, um alerta ser√° acionado e enviado aos destinat√°rios especificados por e-mail, Slack ou outros. </li></ul><br><p>  Os objetos com os quais o Prometheus trabalha s√£o chamados de m√©tricas recebidas dos destinos pelo Pushgateway ou pelos Exportadores. </p><br><p>  <strong><em>Ao coletar m√©tricas, v√°rios m√©todos de transmiss√£o s√£o usados:</em></strong> </p><br><ul><li>  O Prometheus solicita m√©tricas do destino por meio de uma solicita√ß√£o Pull, cujas configura√ß√µes s√£o especificadas no arquivo de configura√ß√£o na se√ß√£o scrape_config para cada tarefa. <br>  Quando o sistema coleta dados, voc√™ pode controlar a frequ√™ncia da coleta e criar v√°rias configura√ß√µes de coleta de dados para selecionar uma frequ√™ncia diferente para objetos diferentes; </li><li>  Os exportadores permitem coletar m√©tricas de v√°rios objetos, por exemplo: bancos de dados (MongoDB, SQL, etc.), intermedi√°rios de mensagens (RabbitMQ, EMQ, NSQ, etc.), balanceadores de carga HTTP, etc; </li><li>  Pushgateway.  Pode ser usado, se necess√°rio, quando o aplicativo n√£o puder fornecer a m√©trica diretamente ao Prometheus;  ou ao usar tarefas em lote que n√£o t√™m a capacidade de usar a solicita√ß√£o pull do Prometheus. </li></ul><br><p>  Assim, todas as m√©tricas recebidas ser√£o armazenadas pelo Prometheus em um banco de dados com registro de data e hora. </p><br><p>  <strong><strong>Configura√ß√£o</strong></strong> </p><br><p>  O Prometheus √© configurado usando os sinalizadores de linha de comando e os arquivos de configura√ß√£o fornecidos no formato YAML.  Os sinalizadores da linha de comando permitem configurar par√¢metros imut√°veis, como: caminhos, volumes de dados armazenados no disco e na mem√≥ria, etc.  O arquivo de configura√ß√£o permite configurar tudo relacionado a tarefas e configurar arquivos yaml de regra carregados.  Tudo est√° escrito no arquivo de configura√ß√£o global, permite definir configura√ß√µes gerais para todos e destacar configura√ß√µes para diferentes se√ß√µes de configura√ß√£o separadamente.  As configura√ß√µes pesquisadas pelo Prometheus s√£o definidas no arquivo de configura√ß√£o na se√ß√£o scrape_configs. </p><br><p>  O Prometheus pode recarregar os arquivos de configura√ß√£o durante a opera√ß√£o, se a nova configura√ß√£o for inv√°lida, ela n√£o ser√° aplicada.  A reinicializa√ß√£o do arquivo de configura√ß√£o √© acionada enviando o comando SIGHUP Prometheus ou enviando uma solicita√ß√£o HTTP POST para <code>/-/reload</code> , desde que o <code>--web.enable-lifecycle</code> esteja <code>--web.enable-lifecycle</code> .  Tamb√©m recarregar√° todos os arquivos de regras configurados. </p><br><p>  <strong><strong>Que tipos de dados s√£o usados</strong></strong> </p><br><p>  O Prometheus armazena um modelo de dados multidimensionais personalizado e usa uma linguagem de consulta para dados multidimensionais chamada PromQL.  O Prometheus armazena dados na forma de s√©ries temporais; suporta v√°rias op√ß√µes de armazenamento: </p><br><ul><li>  armazenamento em disco local: a cada 2 horas, os dados armazenados em buffer na mem√≥ria s√£o compactados e armazenados em disco.  Por padr√£o, o diret√≥rio ./data √© usado no diret√≥rio de trabalho para salvar arquivos compactados; </li><li>  Reposit√≥rio remoto: O Prometheus suporta a integra√ß√£o com reposit√≥rios de terceiros (por exemplo: Kafka, PostgreSQL, Amazon S3, etc.) atrav√©s do adaptador Protocol Buffer. </li></ul><br><p>  A s√©rie temporal armazenada √© determinada pelas m√©tricas e metadados na forma de pares de valores-chave, embora, se necess√°rio, o nome da m√©trica n√£o possa ser usado e a pr√≥pria m√©trica consistir√° apenas de metadados.  Uma s√©rie temporal pode ser formalmente definida como &lt;nome da m√©trica&gt; {&lt;metadados&gt;}.  <strong><em>A chave</em></strong> √© &lt;nome da m√©trica&gt; {&lt;metadata&gt;} - o que estamos medindo, e o <strong><em>valor</em></strong> √© o valor real como um n√∫mero com o tipo float64 (o Prometheus suporta apenas esse tipo).  A descri√ß√£o da chave cont√©m metadados (r√≥tulos), tamb√©m descritos por pares de valores-chave: &lt;nome do r√≥tulo&gt; = "&lt;valor do r√≥tulo&gt;", &lt;nome do r√≥tulo&gt; = "&lt;valor do r√≥tulo&gt;", ... </p><br><p>  <strong>Ao armazenar m√©tricas, os seguintes tipos de dados s√£o usados:</strong> </p><br><ul><li>  <strong><em>Contador</em></strong> - conta a quantia durante um per√≠odo de tempo.  Esse tipo de m√©trica pode aumentar apenas (voc√™ n√£o pode usar valores negativos) ou redefinir o valor. <br>  Pode ser adequado, por exemplo, para contar o n√∫mero de solicita√ß√µes por minuto ou o n√∫mero de erros por dia, o n√∫mero de pacotes de rede enviados / recebidos etc. </li><li>  <strong><em>Medidor</em></strong> - armazena valores que podem diminuir ou aumentar ao longo do tempo. <br>  O medidor n√£o mostra o desenvolvimento de m√©tricas durante um per√≠odo de tempo.  Usando o Gauge, voc√™ pode perder altera√ß√µes irregulares de m√©trica ao longo do tempo. </li><li>  <strong><em>Histograma</em></strong> - salva v√°rias s√©ries temporais: a soma total de todos os valores observados;  o n√∫mero de eventos que foram observados; <br>  contadores acumulativos (baldes) - s√£o indicados no r√≥tulo como <code>le="&lt;upper inclusive bound&gt;"</code> . <br>  Os valores s√£o coletados em √°reas com limites superiores personalizados (buckets). </li><li>  <strong><em>Resumo</em></strong> - salva v√°rias s√©ries temporais: a soma total de todos os valores observados;  o n√∫mero de eventos que foram observados; <br>  flow-quantis do fluxo (0 ‚â§ œÜ ‚â§ 1) dos eventos observados - s√£o indicados no r√≥tulo como <code>quantile="&lt;œÜ&gt;"</code> . </li></ul><br><p>  <strong><strong>Como os dados s√£o salvos?</strong></strong> </p><br><p>  Prometheus recomenda "dar" 2/3 da RAM a um aplicativo em execu√ß√£o. <br>  Para armazenar dados na mem√≥ria, o Prometheus usa arquivos chamados chunk; cada m√©trica possui seu pr√≥prio arquivo.  Todos os arquivos de partes s√£o imut√°veis, exceto o √∫ltimo no qual os dados s√£o gravados.  Novos dados s√£o salvos em partes e a cada 2 horas o fluxo em segundo plano combina os dados e os grava no disco.  Cada bloco de duas horas consiste em um diret√≥rio que cont√©m um ou mais arquivos de partes que cont√™m todas as amostras de s√©ries temporais para esse per√≠odo, bem como um arquivo de metadados e um arquivo de √≠ndice (que indexa os nomes das m√©tricas e r√≥tulos das s√©ries temporais nos arquivos de partes).  Se em uma hora o Prometheus n√£o gravar dados no chunck, ele ser√° salvo no disco e um novo chunck ser√° criado para gravar os dados.  O per√≠odo m√°ximo de reten√ß√£o de dados no Prometheus √© de ~ 21 dias. </p><br><p>  Porque  Como o tamanho da mem√≥ria √© fixo, o desempenho de grava√ß√£o e leitura do sistema ser√° limitado por essa quantidade de mem√≥ria.  A quantidade de mem√≥ria PTSDB √© determinada pelo per√≠odo m√≠nimo, pelo per√≠odo de coleta e pelo n√∫mero de m√©tricas de tempo. </p><br><p>  O Prometheus tamb√©m possui um mecanismo WAL para evitar a perda de dados. </p><br><p>  <strong><em>O write write log (WAL)</em></strong> serializa opera√ß√µes memorizadas em uma m√≠dia permanente na forma de arquivos de log.  No caso de uma falha, os arquivos WAL podem ser usados ‚Äã‚Äãpara restaurar o banco de dados para seu estado consistente, restaurando a partir dos logs. </p><br><p>  Os arquivos de log s√£o armazenados em um diret√≥rio wal em segmentos de 128 MB.  Esses arquivos cont√™m dados brutos que ainda n√£o foram compactados, portanto, s√£o significativamente maiores que os arquivos de fragmento regulares. </p><br><p>  O Prometheus armazenar√° pelo menos tr√™s arquivos de log, mas os servidores com alto tr√°fego podem ver mais de tr√™s arquivos WAL, pois precisam armazenar pelo menos duas horas de dados brutos. </p><br><p>  O resultado do uso do WAL √© uma redu√ß√£o significativa no n√∫mero de solicita√ß√µes de grava√ß√£o no disco, conforme  apenas um arquivo de log precisa ser gravado no disco e nem todos os dados que foram alterados como resultado da opera√ß√£o.  O arquivo de log √© gravado sequencialmente e, portanto, o custo de sincroniza√ß√£o do log √© muito menor que o custo de grava√ß√£o de fragmentos com dados. </p><br><p>  O Prometheus salva pontos de interrup√ß√£o peri√≥dicos, que por padr√£o s√£o adicionados a cada 2 horas, compactando os logs do per√≠odo anterior e salvando-os em disco. </p><br><p>  Todos os pontos de interrup√ß√£o s√£o armazenados no mesmo diret√≥rio que checkpoint.ddd, em que ddd √© um n√∫mero crescente monotonicamente.  Portanto, ao se recuperar de uma falha, ele pode restaurar pontos de interrup√ß√£o do cat√°logo de pontos de interrup√ß√£o com uma indica√ß√£o da ordem (.ddd). <br>  Ao escrever logs WAL, voc√™ pode retornar a qualquer ponto de verifica√ß√£o para o qual o log de dados est√° dispon√≠vel. </p><br><p>  <strong><strong>O que aconteceu na pr√°tica?</strong></strong> </p><br><p>  Ao adicionar ao projeto (.Net Framework), usamos o pacote Prometheus.Client.3.0.2 para coletar m√©tricas.  Para coletar m√©tricas, os m√©todos e classes necess√°rios foram adicionados ao projeto para armazenar m√©tricas at√© que sejam recebidos pelo Prometheus. </p><br><p>  Uma interface IMetricsService foi originalmente definida que continha m√©todos de timer para medir por quanto tempo os m√©todos funcionaram: </p><br><pre> <code class="plaintext hljs">public interface IMetricsService { Stopwatch StartTimer(); void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST"); }</code> </pre> <br><p>  Adicionamos a classe MetricsService, que implementa a interface IMetricsService e armazena temporariamente as m√©tricas. </p><br><pre> <code class="plaintext hljs">public class MetricsService : IMetricsService { private static Histogram _histogram; static MetricsService() { _histogram = CreateHistogram(); } public Stopwatch StartTimer() { try { var timer = new Stopwatch(); timer.Start(); return timer; } catch (Exception exception) { Logger.Error(exception); } return null; } public void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST") { try { if (timer == null) { throw new ArgumentException($"{nameof(timer)} can't be null."); } timer.Stop(); _histogram .WithLabels(controllerName, actionName, methodName) .Observe(timer.ElapsedMilliseconds, DateTimeOffset.UtcNow); } catch (Exception exception) { Logger.Error(exception); } } public static List&lt;string&gt; GetAllLabels() { var metricsList = new List&lt;string&gt;(); try { foreach (var keyValuePair in _histogram.Labelled) { var controllerName = keyValuePair.Key.Labels[0].Value; var actionName = keyValuePair.Key.Labels[1].Value; var methodName = keyValuePair.Key.Labels[2].Value; var requestDurationSum = keyValuePair.Value.Value.Sum; var requestCount = keyValuePair.Value.Value.Count; metricsList.Add($"http_request_duration_widget_sum{{controller={controllerName},action={actionName},method={methodName}}} {requestDurationSum}"); metricsList.Add($"http_request_duration_widget_count{{controller={controllerName},action={actionName},method={methodName}}} {requestCount}"); } _histogram = CreateHistogram(); } catch (Exception exception) { Logger.Error(exception); } return metricsList; } private static Histogram CreateHistogram() { var newMetrics = Metrics .WithCustomRegistry(new CollectorRegistry()) .CreateHistogram(name: "http_request_duration_web_api", help: "Histogram metrics of Web.Api", includeTimestamp: true, labelNames: new[] { "controller", "action", "method" }); var oldValue = _histogram; for (var i = 0; i &lt; 10; i++) { var oldValue = Interlocked.Exchange&lt;Histogram&gt;(ref oldValue, newMetrics); if (oldValue != null) { return oldValue; } } return null; } }</code> </pre> <br><p>  Agora podemos usar nossa classe para salvar as m√©tricas que planejamos coletar nos m√©todos Application_BeginRequest, Application_Error, Application_EndRequest.  Na classe Global.cs, adicionamos uma cole√ß√£o de m√©tricas aos m√©todos acima. </p><br><pre> <code class="plaintext hljs">private IMetricsService _metricsService; protected virtual void Application_BeginRequest(object sender, EventArgs e) { var context = new HttpContextWrapper(HttpContext.Current); var metricServiceTimer = _metricsService.StartTimer(); context.Items.Add("metricsService", _metricsService); context.Items.Add("metricServiceTimer", metricServiceTimer); } protected virtual void Application_EndRequest(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } protected void Application_Error(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } private void WriteMetrics(HttpContextBase context) { try { _metricsService = context.Items["metricsService"] as IMetricsService; if (_metricsService != null) { var timer = context.Items["metricServiceTimer"] as Stopwatch; string controllerName = null; string actionName = null; var rd = RouteTable.Routes.GetRouteData(context); if (rd != null) { controllerName = rd.GetRequiredString("controller"); actionName = rd.GetRequiredString("action"); } _metricsService.StopTimer(timer, controllerName, actionName, context.Request.HttpMethod); } } catch (Exception exception) { Logger.Error("Can't write metrics.", exception); } }</code> </pre><br><p>  Adicione um novo controlador, que ser√° um ponto de refer√™ncia para o envio das m√©tricas da nossa API para o Prometheus: </p><br><pre> <code class="plaintext hljs">public class MetricsController : Controller { [HttpGet] public string[] GetAllMetrics() { try { var metrics = MetricsService.GetAllLabels(); return metrics.ToArray(); } catch (Exception exception) { Logger.Error(exception); } return new string[] { }; } }</code> </pre> <br><p>  A √∫ltima etapa ser√° configurar a configura√ß√£o do Prometheus para coletar m√©tricas na se√ß√£o scrape_configs, ap√≥s a qual podemos ver as m√©tricas coletadas j√° na interface do usu√°rio do Prometheus ou Grafana. </p><br><p>  <strong><strong>Principais recursos que nos interessavam no Prometheus:</strong></strong> </p><br><p>  Modelo de dados multidimensional: m√©tricas e r√≥tulos. <br>  Linguagem de consulta flex√≠vel do PromQL.  No mesmo operador de consulta, podemos usar opera√ß√µes como multiplica√ß√£o, adi√ß√£o, concatena√ß√£o, etc;  pode ser executado com v√°rias m√©tricas. <br>  Re√∫ne dados baseados em HTTP usando o m√©todo pull. <br>  Compat√≠vel com o m√©todo push via Pushgateway. <br>  √â poss√≠vel coletar m√©tricas de outros aplicativos atrav√©s dos Exportadores. <br>  Fornece um mecanismo para impedir a perda de dados. <br>  Suporta v√°rias representa√ß√µes gr√°ficas de dados. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475600/">https://habr.com/ru/post/pt475600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475588/index.html">Tr√™s paradigmas</a></li>
<li><a href="../pt475590/index.html">Compilando programas com o Notepad ++</a></li>
<li><a href="../pt475594/index.html">JavaScript divertido: Uma equa√ß√£o quase linear</a></li>
<li><a href="../pt475596/index.html">Grandes hip√≥teses de n√∫mero primo comprovadas para pequenos sistemas num√©ricos</a></li>
<li><a href="../pt475598/index.html">Organiza√ß√£o da arquitetura simples em um aplicativo Android com um monte de ViewModel + LiveData, Retrofit + Coroutines</a></li>
<li><a href="../pt475604/index.html">Configurando o modelo oficial do PostgreSQL no Zabbix 4.4</a></li>
<li><a href="../pt475608/index.html">Gerenciador de tags do Google: configura√ß√µes de gatilho n√£o √≥bvias e √∫teis</a></li>
<li><a href="../pt475610/index.html">Candeeiros de mesa LED seguros que mant√™m a vis√£o</a></li>
<li><a href="../pt475612/index.html">Dado, quando, afirma√ß√µes e confian√ßa na implementa√ß√£o</a></li>
<li><a href="../pt475614/index.html">Automa√ß√£o para os mais pequenos. Parte Dois. Projeto de rede</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>