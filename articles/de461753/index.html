<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöã üîÖ ü§ú Globale Transaktionen von InterSystems IRIS üòª üï¶ ü§¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="InterSystems IRIS DBMS unterst√ºtzt kuriose Datenspeicherstrukturen - globale. Tats√§chlich handelt es sich hierbei um mehrstufige Schl√ºssel mit verschi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Globale Transaktionen von InterSystems IRIS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461753/"><img src="https://habrastorage.org/webt/fh/h6/kb/fhh6kbibffqggpvpjk1bpabnj1w.png" alt="InterSystems IRIS und Transaktion" align="left">  InterSystems IRIS DBMS unterst√ºtzt kuriose Datenspeicherstrukturen - globale.  Tats√§chlich handelt es sich hierbei um mehrstufige Schl√ºssel mit verschiedenen zus√§tzlichen Vorteilen in Form von Transaktionen, schnellen Funktionen zum Durchlaufen von Datenb√§umen, Sperren und ihrer eigenen ObjectScript-Sprache. <br><br>  Mehr √ºber Globals in der Artikelserie ‚ÄûGlobals - Swords-Masons for Data Storage‚Äú: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die B√§ume.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die B√§ume.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sp√§rliche Arrays.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br><br>  Es wurde f√ºr mich interessant, wie Transaktionen global implementiert werden, welche Funktionen es gibt.  Immerhin ist dies eine v√∂llig andere Struktur zum Speichern von Daten als die √ºblichen Tabellen.  Viel niedrigeres Niveau. <br><a name="habracut"></a><br>  Wie Sie aus der relationalen Datenbanktheorie wissen, muss eine gute Transaktionsimplementierung die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACID-</a> Anforderungen erf√ºllen: <br><br>  <b>A - Atom (Atomizit√§t).</b>  Alle an der Transaktion vorgenommenen oder gar keine √Ñnderungen werden aufgezeichnet. <br><br>  <b>C - Konsistenz.</b>  Nach Abschluss der Transaktion muss der logische Status der Datenbank intern konsistent sein.  In vielerlei Hinsicht gilt diese Anforderung f√ºr den Programmierer, bei SQL-Datenbanken jedoch auch f√ºr Fremdschl√ºssel. <br><br>  <b>I - Isolieren (Isolieren).</b>  Parallele Transaktionen sollten sich nicht gegenseitig beeinflussen. <br><br>  <b>D - Langlebig.</b>  Nach erfolgreichem Abschluss der Transaktion sollten Probleme auf den unteren Ebenen (z. B. Stromausfall) keine Auswirkungen auf die durch die Transaktion ge√§nderten Daten haben. <br><br>  Globale sind nicht relationale Datenstrukturen.  Sie wurden f√ºr ultraschnelle Arbeiten mit sehr begrenzter Hardware entwickelt.  Lassen Sie uns die Implementierung von Transaktionen in Globals anhand des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen IRIS-Docker-Images</a> verstehen. <br><br>  Zur Unterst√ºtzung von Transaktionen in IRIS werden die folgenden Befehle verwendet: <a href="">TSTART</a> , <a href="">TCOMMIT</a> , <a href="">TROLLBACK</a> . <br><br><h2>  1. Atomizit√§t </h2><br>  Der einfachste Weg, um die Atomizit√§t zu √ºberpr√ºfen.  √úberpr√ºfung √ºber die Datenbankkonsole. <br><br><pre><code class="bash hljs">Kill ^a TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TCOMMIT</code> </pre> <br>  Dann schlie√üen wir: <br><br><pre> <code class="bash hljs">Write ^a(1), ‚Äú ‚Äù, ^a(2), ‚Äú ‚Äù, ^a(3)</code> </pre> <br>  Wir bekommen: <br><br><pre> <code class="bash hljs">1 2 3</code> </pre> <br>  Alles ist in Ordnung.  Atomizit√§t beobachtet: Alle √Ñnderungen werden aufgezeichnet. <br><br>  Wir erschweren die Aufgabe, f√ºhren einen Fehler ein und sehen, wie die Transaktion teilweise oder gar nicht gespeichert wird. <br><br>  Lassen Sie uns die Atomizit√§t noch einmal √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3</code> </pre> <br>  Dann den Container gewaltsam anhalten, starten und sehen. <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  Dieser Befehl entspricht fast dem gewaltsamen Ausschalten der Stromversorgung, da er ein Signal sendet, um den SIGKILL-Prozess sofort zu stoppen. <br><br>  Vielleicht wurde die Transaktion teilweise gespeichert? <br><br><pre> <code class="bash hljs">WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  - Nein, nicht erhalten. <br><br>  Testen Sie den Rollback-Befehl: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TROLLBACK WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  Auch nichts blieb erhalten. <br><br><h2>  2. Konsistenz </h2><br>  Da in Datenbanken auf Globals Schl√ºssel auch auf Globals erstellt werden (ich erinnere mich, dass ein Global eine Struktur auf niedrigerer Ebene zum Speichern von Daten als eine relationale Tabelle ist), m√ºssen Sie die Schl√ºssel√§nderung in dieselbe Transaktion wie die globale √Ñnderung aufnehmen, um die Konsistenzanforderung zu erf√ºllen. <br><br>  Zum Beispiel haben wir eine globale Person, in der wir Pers√∂nlichkeiten speichern und die TIN als Schl√ºssel verwenden. <br><br><pre> <code class="bash hljs">^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ...</span></span></code> </pre> <br>  Um eine schnelle Suche nach Nachname und Vorname zu haben, haben wir den Schl√ºsselindex ^ erstellt. <br><br><pre> <code class="bash hljs">^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) = 1</code> </pre> <br>  Damit die Basis vereinbart werden kann, m√ºssen wir Pers√∂nlichkeiten wie diese hinzuf√ºgen: <br><br><pre> <code class="bash hljs">TSTART ^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ^index('</span></span>Kamenev<span class="hljs-string"><span class="hljs-string">', '</span></span>Sergey<span class="hljs-string"><span class="hljs-string">', 1234567) = 1 TCOMMIT</span></span></code> </pre> <br>  Dementsprechend sollten wir beim L√∂schen auch die Transaktion verwenden: <br><br><pre> <code class="bash hljs">TSTART Kill ^person(1234567) ZKill ^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) TCOMMIT</code> </pre> <br>  Mit anderen Worten, die Erf√ºllung der Konsistenzanforderung liegt vollst√§ndig beim Programmierer.  Aber wenn es um Globale geht, ist dies aufgrund ihrer niedrigen Natur normal. <br><br><h2>  3. Isolierung </h2><br>  Hier beginnt die Wildnis.  Viele Benutzer arbeiten gleichzeitig an derselben Datenbank und √§ndern dieselben Daten. <br><br>  Die Situation ist vergleichbar mit der Situation, in der viele Benutzer gleichzeitig mit demselben Code mit dem Code arbeiten und versuchen, √Ñnderungen an vielen Dateien gleichzeitig zu √ºbernehmen. <br><br>  Die Datenbank sollte dies in Echtzeit beheben.  Angesichts der Tatsache, dass es in seri√∂sen Unternehmen sogar eine spezielle Person gibt, die f√ºr die Versionskontrolle verantwortlich ist (f√ºr das Zusammenf√ºhren von Zweigen, das L√∂sen von Konflikten usw.), und die Datenbank sollte dies alles in Echtzeit tun, die Komplexit√§t der Aufgabe und das korrekte Design der Datenbank und der Code, der es dient. <br><br>  Die Datenbank kann die Bedeutung der von Benutzern ausgef√ºhrten Aktionen nicht verstehen, um Konflikte zu vermeiden, wenn sie mit denselben Daten arbeiten.  Es kann nur eine Transaktion im Gegensatz zu einer anderen abbrechen oder nacheinander ausf√ºhren. <br><br>  Ein weiteres Problem besteht darin, dass w√§hrend der Ausf√ºhrung der Transaktion (vor dem Festschreiben) der Status der Datenbank m√∂glicherweise inkonsistent ist. Daher ist es w√ºnschenswert, dass andere Transaktionen keinen Zugriff auf den inkonsistenten Status der Datenbank haben, der in relationalen Datenbanken auf vielf√§ltige Weise erreicht wird: Erstellen von Snapshots, Multiversionszeilen und usw. <br><br>  Bei der parallelen Ausf√ºhrung von Transaktionen ist es uns wichtig, dass sie sich nicht gegenseitig st√∂ren.  Dies ist die Eigenschaft der Isolation. <br><br>  SQL definiert 4 Isolationsstufen: <br><br><ul><li>  LESEN SIE UNVERPFLICHTET </li><li>  LESEN SIE VERPFLICHTET </li><li>  WIEDERHOLBAR LESEN </li><li>  SERIALISIERBAR </li></ul><br>  Betrachten wir jedes Level einzeln.  Die Kosten f√ºr die Implementierung jeder Ebene steigen fast exponentiell. <br><br>  <b>READ UNCOMMITTED</b> ist die niedrigste Isolationsstufe, aber die schnellste.  Transaktionen k√∂nnen von einander vorgenommene √Ñnderungen lesen. <br><br>  <b>READ COMMITTED</b> ist die n√§chste Stufe der Isolation, die einen Kompromiss darstellt.  Transaktionen k√∂nnen keine √Ñnderungen lesen, die vor einem Commit voneinander vorgenommen wurden, k√∂nnen jedoch alle √Ñnderungen lesen, die nach einem Commit vorgenommen wurden. <br><br>  Wenn wir eine lange Transaktion T1 haben, bei der es Commits in den Transaktionen T2, T3 ... Tn gab, die mit denselben Daten wie T1 arbeiteten, erhalten wir jedes Mal unterschiedliche Ergebnisse, wenn wir Daten in T1 anfordern.  Dieses Ph√§nomen wird als nicht wiederholbares Lesen bezeichnet. <br><br>  <b>WIEDERHOLBARES LESEN</b> - In dieser Isolationsstufe tritt das Ph√§nomen des nicht wiederholbaren Lesens nicht auf, da f√ºr jede Anforderung zum Lesen von Daten ein Snapshot der Ergebnisdaten erstellt wird und bei Wiederverwendung in derselben Transaktion die Daten aus dem Snapshot verwendet werden.  Bei dieser Isolationsstufe k√∂nnen jedoch Phantomdaten gelesen werden.  Dies bezieht sich auf das Lesen neuer Zeilen, die durch gleichzeitig festgeschriebene Transaktionen hinzugef√ºgt wurden. <br><br>  <b>SERIALIZABLE</b> ist die h√∂chste Isolationsstufe.  Es zeichnet sich dadurch aus, dass die in der Transaktion in irgendeiner Weise verwendeten Daten (Lesen oder √Ñndern) erst nach Abschluss der ersten Transaktion anderen Transaktionen zur Verf√ºgung stehen. <br><br>  Lassen Sie uns zun√§chst herausfinden, ob Operationen in einer Transaktion vom Hauptthread isoliert sind.  Lassen Sie uns 2 Terminalfenster √∂ffnen. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs">Kill ^t Write ^t(1) 2</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=2</code> </pre> </td></tr></tbody></table></div><br>  Es gibt keine Isolation.  Ein Thread sieht, was der zweite, der die Transaktion ge√∂ffnet hat, tut. <br><br>  Mal sehen, ob Transaktionen mit unterschiedlichen Fl√ºssen sehen, was in ihnen passiert. <br><br>  Wir √∂ffnen 2 Terminalfenster und √∂ffnen 2 Transaktionen parallel. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> ^t TSTART Write ^t(1) 3</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=3</code> </pre></td></tr></tbody></table></div><br>  Gleichzeitige Transaktionen sehen die Daten des jeweils anderen.  So haben wir die einfachste, aber auch die schnellste Isolationsstufe READ UNCOMMITED. <br><br>  Im Prinzip ist dies f√ºr Globals zu erwarten, bei denen Geschwindigkeit immer an erster Stelle stand. <br><br>  Aber was ist, wenn wir ein h√∂heres Ma√ü an Isolation bei globalen Operationen ben√∂tigen? <br><br>  Hier m√ºssen Sie dar√ºber nachdenken, warum Isolationsstufen ben√∂tigt werden und wie sie funktionieren. <br><br>  Die h√∂chste Isolationsstufe von SERIALIZE bedeutet, dass das Ergebnis gleichzeitig ausgef√ºhrter Transaktionen ihrer sequentiellen Ausf√ºhrung entspricht, wodurch das Fehlen von Kollisionen garantiert wird. <br><br>  Wir k√∂nnen dies mithilfe kompetenter Sperren in ObjectScript tun, die viele verschiedene Anwendungsm√∂glichkeiten haben: Mit dem Befehl <a href="">LOCK</a> k√∂nnen Sie regelm√§√üige, inkrementelle Mehrfachsperren durchf√ºhren. <br><br>  Niedrigere Isolationsstufen sind Kompromisse, um die Geschwindigkeit der Datenbank zu erh√∂hen. <br><br>  Mal sehen, wie wir mit Sperren unterschiedliche Isolationsstufen erreichen k√∂nnen. <br><br>  Mit diesem Operator k√∂nnen Sie nicht nur die exklusiven Sperren verwenden, die zum √Ñndern von Daten erforderlich sind, sondern auch die sogenannten freigegebenen Sperren, die mehrere Threads gleichzeitig ben√∂tigen, wenn sie Daten lesen m√ºssen, die w√§hrend des Lesens nicht von anderen Prozessen ge√§ndert werden sollen. <br><br>  Weitere Informationen zur Zwei-Phasen-Verriegelungsmethode in Russisch und Englisch: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiphasensperre</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiphasenverriegelung</a> <br><br>  Die Schwierigkeit besteht darin, dass w√§hrend der Transaktion der Status der Datenbank inkonsistent sein kann, diese inkonsistenten Daten jedoch f√ºr andere Prozesse sichtbar sind.  Wie vermeide ich das? <br><br>  Mithilfe von Sperren erstellen wir solche Sichtbarkeitsfenster, in denen der Status der Datenbank vereinbart wird.  Und alle Anrufe an solche Sichtfenster des vereinbarten Zustands werden durch Schl√∂sser kontrolliert. <br><br>  Gemeinsame Sperren derselben Daten k√∂nnen wiederverwendet werden - mehrere Prozesse k√∂nnen sie verwenden.  Diese Sperren verhindern, dass andere Prozesse Daten √§ndern, d. H.  Sie werden verwendet, um die Fenster des koordinierten Status der Datenbank zu bilden. <br><br>  Exklusive Sperren werden zum √Ñndern von Daten verwendet - nur ein Prozess kann eine solche Sperre durchf√ºhren.  Exklusives Blockieren kann dauern: <br><br><ol><li>  Jeder Prozess, wenn Daten frei sind </li><li>  Nur der Prozess, der eine gemeinsame Sperre f√ºr diese Daten hat, und der erste haben eine exklusive Sperre angefordert. </li></ol><br><img src="https://habrastorage.org/webt/ba/pu/mx/bapumxoivygurvclagw-mkw9p8w.png"><br><br>  Je enger das Sichtbarkeitsfenster ist, desto l√§nger dauert es, bis andere Prozesse warten, aber desto konsistenter kann der Status der darin enthaltenen Datenbank sein. <br><br>  <b>READ_COMMITED</b> - Das Wesentliche dieser Ebene ist, dass nur Daten aus anderen gesperrten Streams <b>angezeigt</b> werden.  Wenn die Daten in einer anderen Transaktion noch nicht festgeschrieben sind, sehen wir ihre alte Version. <br><br>  Dies erm√∂glicht es uns, die Arbeit zu parallelisieren, anstatt darauf zu warten, dass die Sperre freigegeben wird. <br><br>  Ohne spezielle Tricks k√∂nnen wir die alte Version der Daten in IRIS nicht sehen, daher haben wir es mit Sperren zu tun. <br><br>  Dementsprechend m√ºssen wir gemeinsam genutzte Sperren verwenden, um das Lesen von Daten nur in Momenten der Konsistenz zu erm√∂glichen. <br><br>  Angenommen, wir haben eine Benutzerbasis ^ Person, die Geld untereinander √ºberweist. <br><br>  Der Zeitpunkt der √úbertragung von Person 123 auf Person 242: <br><br><pre> <code class="bash hljs">LOCK +^person(123), +^person(242) Set ^person(123, amount) = ^person(123, amount) - amount Set ^person(242, amount) = ^person(242, amount) + amount LOCK -^person(123), -^person(242)</code> </pre> <br>  Der Zeitpunkt der Anforderung des Geldbetrags von Person 123 vor der Abbuchung muss von einer exklusiven Sperre (standardm√§√üig) begleitet sein: <br><br><pre> <code class="bash hljs">LOCK +^person(123) Write ^person(123)</code> </pre> <br>  Und wenn Sie den Kontostatus in Ihrem Konto anzeigen m√ºssen, k√∂nnen Sie die gemeinsame Sperre verwenden oder sie √ºberhaupt nicht verwenden: <br><br><pre> <code class="bash hljs">LOCK +^person(123)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù Write ^person(123)</span></span></code> </pre> <br>  Wenn wir jedoch davon ausgehen, dass Datenbankoperationen fast sofort ausgef√ºhrt werden (ich erinnere mich, dass Globals eine viel niedrigere Struktur als eine relationale Tabelle haben), sinkt der Bedarf f√ºr diese Ebene. <br><br>  <b>REPEATABLE READ</b> - In dieser Isolationsstufe wird davon <b>ausgegangen,</b> dass mehrere Lesevorg√§nge von Daten m√∂glich sind, die durch gleichzeitige Transaktionen ge√§ndert werden k√∂nnen. <br><br>  Dementsprechend m√ºssen wir das Lesen der Daten, die wir √§ndern, gemeinsam sperren und die Daten, die wir √§ndern, exklusiv sperren. <br><br>  Gl√ºcklicherweise erm√∂glicht der LOCK-Operator einem Operator, alle erforderlichen Sperren, die sehr viele sein k√∂nnen, detailliert aufzulisten. <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù  ^person(123, amount)</span></span></code> </pre> <br>  andere Operationen (zu diesem Zeitpunkt versuchen parallele Threads, ^ person (123, Betrag) zu √§ndern, k√∂nnen dies jedoch nicht) <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù</span></span></code> </pre> <br>  Wenn Sie durch Kommas getrennte Sperren auflisten, werden diese nacheinander ausgef√ºhrt. Wenn Sie dies tun: <br><br><pre> <code class="bash hljs">LOCK +(^person(123),^person(242))</code> </pre> <br>  dann werden sie alle auf einmal atomar genommen. <br><br>  <b>SERIALISIEREN</b> - Wir m√ºssen die Sperren setzen, damit letztendlich alle Transaktionen mit gemeinsamen Daten nacheinander ausgef√ºhrt werden.  F√ºr diesen Ansatz m√ºssen die meisten Sperren exklusiv sein und f√ºr die Leistung in die kleinsten Bereiche der Welt gebracht werden. <br><br>  Wenn wir √ºber Abschreibungen in der globalen Person sprechen, ist nur die Isolationsstufe SERIALIZE f√ºr sie akzeptabel, da das Geld streng nacheinander ausgegeben werden muss, andernfalls ist es m√∂glich, denselben Betrag mehrmals auszugeben. <br><br><h2>  4. Haltbarkeit </h2><br>  Ich f√ºhrte Tests durch, bei denen der Beh√§lter hart durchgeschnitten wurde <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  Die Basis vertrug sie gut.  Es wurden keine Probleme festgestellt. <br><br><h2>  Fazit </h2><br>  F√ºr Globals bietet InterSystems IRIS Transaktionsunterst√ºtzung.  Sie sind wirklich atomar, zuverl√§ssig.  Um die Datenbankkonsistenz auf globalen Daten zu gew√§hrleisten, sind die Bem√ºhungen des Programmierers und die Verwendung von Transaktionen erforderlich, da keine komplexen integrierten Konstruktionen wie Fremdschl√ºssel vorhanden sind. <br><br>  Die Isolationsstufe von Globals ohne Verwendung von Sperren ist READ UNCOMMITED und kann bei Verwendung von Sperren bis zur SERIALIZE-Ebene sichergestellt werden. <br><br>  Die Richtigkeit und Geschwindigkeit von Transaktionen auf globalen Daten h√§ngt stark von den F√§higkeiten des Programmierers ab: Je h√§ufiger gemeinsam genutzte Sperren beim Lesen verwendet werden, desto h√∂her ist die Isolationsstufe und je mehr exklusive Sperren verwendet werden, desto h√∂her ist die Geschwindigkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461753/">https://habr.com/ru/post/de461753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461743/index.html">Sicherheitswoche 31: VLC-Sicherheitsl√ºcke und defektes Telefon</a></li>
<li><a href="../de461745/index.html">DeviceLock DLP: Preise des russischen Schwarzmarktes f√ºr das Durchbrechen personenbezogener Daten (plus eine Antwort auf die Antwort der Tinkoff Bank)</a></li>
<li><a href="../de461747/index.html">Wie wir ML in einer Anwendung mit fast 50 Millionen Benutzern implementiert haben. Sberbank Erfahrung</a></li>
<li><a href="../de461749/index.html">Sch√∂nheit im Auge des Betrachters</a></li>
<li><a href="../de461751/index.html">Designerbeitrag zur Entwicklung mobiler Apps</a></li>
<li><a href="../de461755/index.html">Die Psychologie des Schallbildes. Svetlana Lebedeva erz√§hlte, wie den Menschen eine neue Art der Wahrnehmung beigebracht wird</a></li>
<li><a href="../de461759/index.html">Abh√∂ren verschl√ºsselter VoIP-Kommunikation</a></li>
<li><a href="../de461761/index.html">DPKI: Beseitigung der Nachteile einer zentralisierten PKI mit Blockchain</a></li>
<li><a href="../de461763/index.html">K√∂nnen Werbeagenturen zu Beginn der Reise das Gesch√§ft t√∂ten?</a></li>
<li><a href="../de461765/index.html">Wir kreuzen k8s mit Kafka, retten Container, entkommen dem M√ºll in Ansible: Top 10 Berichte von DevOops 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>