<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 🚶 🍤 Kurir: Migrasi Dropbox ke gRPC 🍿 🤙 ✌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan Penerjemah 
 Sebagian besar produk perangkat lunak modern tidak monolitik, tetapi terdiri dari banyak bagian yang saling berinteraksi. Dalam s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurir: Migrasi Dropbox ke gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Catatan Penerjemah </h1><br>  Sebagian besar produk perangkat lunak modern tidak monolitik, tetapi terdiri dari banyak bagian yang saling berinteraksi.  Dalam situasi ini, penting bahwa komunikasi bagian-bagian yang berinteraksi dari sistem berlangsung dalam satu bahasa (terlepas dari kenyataan bahwa bagian-bagian ini sendiri dapat ditulis dalam bahasa pemrograman yang berbeda dan dijalankan pada mesin yang berbeda).  Untuk menyederhanakan solusi untuk masalah ini, membantu gRPC - open-source-framework dari Google, dirilis pada 2015.  Dia segera memecahkan sejumlah masalah, memungkinkan: <br><br><ul><li>  menggunakan bahasa Protokol Buffer untuk menggambarkan interaksi layanan; <br></li><li>  menghasilkan kode program berdasarkan protokol yang dijelaskan untuk 11 bahasa yang berbeda untuk bagian klien dan bagian server; <br></li><li>  menerapkan otorisasi antara komponen yang berinteraksi; <br></li><li>  gunakan interaksi sinkron dan asinkron. <br></li></ul><br>  Bagi saya, gRPC merupakan kerangka kerja yang cukup menarik, dan saya tertarik untuk belajar tentang pengalaman nyata Dropbox dalam membangun sistem yang didasarkan padanya.  Artikel ini memiliki banyak detail terkait dengan penggunaan enkripsi, membangun sistem yang andal, dapat diamati, dan produktif, proses migrasi dari solusi RPC lama ke yang baru. <br><br><div class="spoiler">  <b class="spoiler_title">Penafian</b> <div class="spoiler_text">  Artikel asli tidak mengandung deskripsi gRPC, dan beberapa poin mungkin tidak jelas bagi Anda.  Jika Anda tidak terbiasa dengan gRPC atau kerangka kerja serupa lainnya (misalnya, Apache Thrift), saya sarankan Anda membiasakan diri dengan ide-ide utama (cukup membaca dua artikel kecil dari situs web resmi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Apa itu gRPC?"</a> Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Konsep gRPC"</a> ). <br><br>  Terima kasih kepada Aleksey Ivanov alias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SaveTheRbtz</a> untuk menulis artikel asli dan membantu menerjemahkan tempat-tempat sulit. <br></div></div><a name="habracut"></a><br>  Dropbox mengelola banyak layanan yang ditulis dalam berbagai bahasa dan melayani jutaan permintaan per detik.  Di pusat arsitektur berorientasi layanan kami adalah Courier, kerangka kerja RPC berbasis gPC.  Dalam proses pengembangannya, kami belajar banyak tentang ekstensibilitas gRPC, optimalisasi kinerja, dan transisi dari sistem RPC sebelumnya. <br><br>  <i>Catatan: pos berisi cuplikan kode untuk Python dan Go.</i>  <i>Kami juga menggunakan Rust dan Java.</i> <br><br><h1>  Jalan menuju gRPC </h1><br>  Courier bukan kerangka kerja Dropbox RPC pertama.  Bahkan sebelum kami mulai membagi sistem Python monolitik menjadi layanan terpisah, kami membutuhkan dasar yang dapat diandalkan untuk bertukar data antara layanan - terutama karena memilih kerangka kerja akan memiliki konsekuensi jangka panjang. <br><br>  Sebelum itu, Dropbox bereksperimen dengan kerangka kerja RPC yang berbeda.  Pertama, kami memiliki protokol individual untuk serialisasi manual dan deserialisasi.  Beberapa layanan, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logging berbasis Scribe</a> , menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Thrift</a> .  Pada saat yang sama, kerangka kerja RPC utama kami adalah protokol HTTP / 1.1 dengan pesan-pesan berseri menggunakan Protobuf. <br><br>  Membuat kerangka kerja, kami memilih dari beberapa opsi.  Kita bisa memperkenalkan Swagger (sekarang dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenAPI</a> ) ke dalam kerangka kerja RPC lama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperkenalkan standar baru,</a> atau membangun kerangka kerja berdasarkan hemat atau gRPC.  Argumen utama yang mendukung gRPC adalah kemungkinan menggunakan protobuf yang sudah ada sebelumnya.  Juga, multiplex HTTP / 2 dan transfer data dua arah berguna untuk tugas kami. <br><br>  <i>Catatan: jika fbthrift ada pada saat itu, kami mungkin akan melihat lebih dekat solusi Thrift.</i> <br><br><h1>  Apa yang dibawa oleh Courier ke gRPC </h1><br>  Kurir bukan protokol RPC;  ini adalah cara mengintegrasikan gRPC ke dalam infrastruktur yang ada.  Kerangka kerja ini seharusnya kompatibel dengan perangkat otentikasi, otorisasi, dan penemuan layanan kami, serta pengumpulan statistik, pencatatan, dan pelacakan.  Jadi kami menciptakan Kurir. <br><br>  <i>Meskipun dalam beberapa kasus kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bandaid</a> sebagai proksi gRPC, sebagian besar layanan kami berkomunikasi langsung satu sama lain untuk meminimalkan dampak RPC pada latensi.</i> <br><br>  Penting bagi kami untuk mengurangi jumlah kode rutin yang perlu ditulis.  Karena Courier berfungsi sebagai kerangka kerja umum untuk mengembangkan layanan, Courier berisi fitur yang dibutuhkan semua orang.  Sebagian besar dari mereka diaktifkan secara default dan dapat dikontrol oleh argumen baris perintah, dan beberapa dicentang dengan kotak centang. <br><br><h2>  Keamanan: Identitas Layanan dan TLS Mutual Authentication </h2><br>  Courier mengimplementasikan mekanisme identifikasi layanan standar kami.  Setiap server dan klien diberi sertifikat TLS individu yang dikeluarkan oleh otoritas sertifikasi kami sendiri.  Sertifikat pengidentifikasi pribadi yang disandikan, yang digunakan untuk otentikasi bersama - server memverifikasi klien, klien memverifikasi server. <br><br>  Di TLS, tempat kami mengontrol kedua sisi koneksi, kami telah menerapkan batasan ketat.  Semua RPC internal memerlukan enkripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PFS</a> .  Versi TLS yang diperlukan adalah 1.2 dan lebih tinggi.  Kami juga membatasi jumlah algoritma simetris dan asimetris, lebih memilih <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  Setelah melewati identifikasi dan dekripsi permintaan, server memeriksa apakah klien memiliki izin yang diperlukan.  Daftar kontrol akses (ACL) dan batas kecepatan dapat dikonfigurasi baik untuk layanan secara umum maupun untuk metode individual.  Parameter mereka juga dapat diubah melalui sistem file terdistribusi kami (AFS).  Berkat ini, pemilik layanan dapat menjatuhkan beban dalam hitungan detik, bahkan tanpa memulai kembali prosesnya.  Courier akan mengurus berlangganan pemberitahuan dan memperbarui konfigurasi. <br><br>  <i>Layanan Identity adalah pengidentifikasi global untuk ACL, batas kecepatan, statistik, dll. Selain itu, layanan ini aman secara kriptografis.</i> <br><br>  Berikut adalah contoh konfigurasi ACL dan batas kecepatan yang digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan pengenalan pola optik</a> kami: <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Kami sedang mempertimbangkan kemungkinan beralih ke format SVID ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPIFFE</a> dokumen yang diverifikasi secara kriptografis), yang akan membantu menggabungkan kerangka kerja kami dengan banyak proyek sumber terbuka.</i> <br><br><h2>  Observabilitas: statistik dan pelacakan </h2><br>  Dengan hanya satu pengidentifikasi, Anda dapat dengan mudah menemukan log, statistik, melacak file, dan data lainnya tentang Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  Selama pembuatan kode, pengumpulan statistik ditambahkan untuk setiap layanan dan setiap metode baik di sisi klien maupun di sisi server.  Statistik sisi server dibagi dengan ID klien.  Dalam konfigurasi standar, Anda akan menerima data terperinci tentang beban, kesalahan dan waktu tunda untuk setiap layanan menggunakan Kurir. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Statistik kurir mencakup data tentang ketersediaan dan latensi di sisi klien, serta jumlah permintaan dan ukuran antrian di sisi server.  Ada grafik lain yang bermanfaat, khususnya histogram waktu respons untuk setiap metode dan waktu jabat tangan TLS untuk setiap klien. <br><br>  <i>Salah satu keuntungan dari pembuatan kode kami adalah kemungkinan inisialisasi statis struktur data, seperti histogram dan grafik jejak.</i>  <i>Ini meminimalkan dampak kinerja.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  Sistem RPC lama hanya mendistribusikan <i>request_id</i> melalui API.  Ini memungkinkan untuk menggabungkan data dari log layanan yang berbeda.  Di Courier, kami memperkenalkan API berdasarkan subset dari spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenTracing</a> .  Kami menulis perpustakaan kami sendiri di sisi klien, dan di sisi server kami menerapkan solusi berdasarkan Cassandra dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  Tracing memungkinkan kami untuk menghasilkan diagram dependensi dari suatu layanan saat runtime.  Ini membantu insinyur melihat semua dependensi transitif dari layanan tertentu.  Selain itu, fungsi ini berguna untuk melacak dependensi yang tidak diinginkan setelah penyebaran. <br><br><h2>  Keandalan: tenggat waktu dan pemutusan </h2><br>  Courier menyediakan tempat sentral untuk mengimplementasikan fungsi-fungsi klien umum (misalnya, batas waktu) dalam berbagai bahasa.  Kami secara bertahap menambahkan berbagai fitur, seringkali berdasarkan hasil analisis "anumerta" dari masalah yang muncul. <br><br><h3>  Tenggat waktu </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Setiap permintaan gRPC memiliki tenggat waktu yang</a> menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batas waktu</a> klien.  Karena bertopik Courier secara otomatis mendistribusikan metadata yang diketahui, batas waktu permintaan bahkan ditransfer di luar API.  Dalam proses tersebut, tenggat waktu menerima tampilan asli.  Misalnya, di Go, mereka diwakili oleh hasil <i>konteks</i> . <i>Konteks dari</i> metode <i>WithDeadline</i> . <br><br>  Bahkan, kami dapat memperbaiki seluruh kelas masalah keandalan dengan memaksa insinyur untuk menetapkan tenggat waktu dalam menentukan layanan yang sesuai. <br><br>  Pendekatan ini bahkan melampaui RPC.  Sebagai contoh, MySQL ORM kami membuat serial konteks RPC bersama dengan tenggat waktu dalam komentar permintaan SQL.  Proxy SQL kami dapat menguraikan komentar dan "membunuh" kueri saat tenggat waktu terjadi.  Dan sebagai bonus ketika melakukan debug panggilan basis data, kami memiliki kueri SQL yang mengikat ke kueri RPC tertentu. <br><br><h3>  Putuskan sambungan </h3><br>  Masalah umum lain yang dihadapi klien dari sistem RPC sebelumnya adalah penerapan algoritma dari keterlambatan eksponensial individu dan fluktuasi atas permintaan berulang. <br><br>  Kami mencoba menemukan solusi cerdas untuk masalah pemutusan di Courier, dimulai dengan implementasi buffer LIFO (terakhir masuk, keluar pertama) antara layanan dan kumpulan tugas. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  Jika terjadi kelebihan, LIFO akan otomatis terputus.  Antrian, yang penting, dibatasi tidak hanya berdasarkan ukuran, tetapi juga <b>berdasarkan waktu</b> (permintaan dapat menghabiskan dalam antrian hanya pada waktu tertentu). <br><br>  <i>Minus LIFO - mengubah urutan permintaan pemrosesan.</i>  <i>Jika Anda ingin mempertahankan pesanan awal, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoDel</a> .</i>  <i>Di sana juga, ada kemungkinan pemutusan, dan urutan permintaan pemrosesan akan tetap sama.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Introspeksi: titik akhir debugging </h2><br>  Meskipun debugging titik akhir tidak secara langsung menjadi bagian dari Courier, mereka banyak digunakan di seluruh Dropbox dan terlalu berguna untuk tidak disebutkan. <br><br>  <i>Untuk alasan keamanan, Anda dapat membukanya di port terpisah atau pada soket Unix (untuk mengontrol akses menggunakan izin file).</i>  <i>Anda juga harus mempertimbangkan otentikasi timbal balik TLS, yang pengembang harus memberikan sertifikat mereka untuk akses ke titik akhir (terutama tidak hanya baca-saja).</i> <br><br><h3>  Eksekusi </h3><br>  Kemampuan untuk menganalisis status suatu layanan selama operasinya sangat berguna untuk debugging.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://golang.org/pkg/net/">memori dinamis dan profil CPU dapat diakses melalui titik akhir HTTP atau gRPC</a> . <br><br>  <i>Kami berencana untuk menggunakan kesempatan ini dalam prosedur verifikasi kenari - untuk mengotomatiskan pencarian perbedaan antara versi kode lama dan baru.</i> <br><br>  Endpoint memungkinkan untuk mengubah keadaan layanan saat runtime.  Secara khusus, layanan berbasis Golang dapat secara dinamis mengkonfigurasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GCPercent</a> . <br><br><h3>  Perpustakaan </h3><br>  Ekspor otomatis data khusus perpustakaan sebagai titik akhir RPC mungkin berguna untuk pengembang perpustakaan.  Misalnya, perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malloc dapat membuang statistik internal ke dump</a> .  Contoh lain: titik akhir debugging dapat mengubah tingkat layanan log on the fly. <br><br><h3>  Rpc </h3><br>  Tentu saja, pemecahan masalah dalam protokol terenkripsi dan disandikan tidak mudah.  Oleh karena itu, memperkenalkan alat sebanyak mungkin di tingkat RPC adalah ide yang bagus.  Salah satu contoh dari API introspektif tersebut <a href="">adalah solusi Channelz</a> . <br><br><h3>  Tingkat aplikasi </h3><br>  Mampu mempelajari opsi tingkat aplikasi juga dapat bermanfaat.  Contoh yang baik adalah titik akhir dengan informasi umum tentang aplikasi (dengan hash file sumber atau rakitan, baris perintah, dll.).  Ini dapat digunakan oleh sistem orkestrasi untuk memverifikasi integritas ketika menggunakan layanan. <br><br><h1>  Optimalisasi kinerja </h1><br>  Dengan memperluas kerangka kerja gRPC kami ke skala yang diperlukan, kami menemukan beberapa kemacetan khusus untuk Dropbox. <br><br><h3>  Konsumsi Sumber Daya Jabat Tangan TLS </h3><br>  Dalam layanan yang melayani banyak hubungan, sebagai hasil dari jabat tangan TLS, beban CPU gabungan bisa sangat serius (terutama ketika me-reboot layanan populer). <br><br>  Untuk meningkatkan kinerja saat menandatangani, kami mengganti pasangan kunci RSA-2048 dengan ECDSA P-256.  Berikut adalah contoh kinerja mereka (catatan: dengan RSA, verifikasi tanda tangan lebih cepat). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Karena verifikasi dengan RSA-2048 sekitar tiga kali lebih cepat daripada dengan ECDSA P-256, Anda dapat memilih RSA untuk sertifikat root dan akhir untuk meningkatkan kecepatan operasi.  Tetapi dari sudut pandang keamanan, tidak semuanya begitu sederhana: Anda akan membangun rantai berbagai kriptografi primitif, dan oleh karena itu, tingkat parameter keamanan yang dihasilkan akan menjadi yang terendah.  Dan jika Anda ingin meningkatkan kinerja, kami tidak menyarankan menggunakan sertifikat versi RSA-4096 (dan lebih tinggi) sebagai sertifikat root dan akhir. <br><br>  Kami juga menemukan bahwa memilih perpustakaan TLS (dan bendera kompilasi) memiliki dampak signifikan pada kinerja dan keamanan.  Bandingkan, misalnya, LibreSSL dibangun di atas macOS X Mojave dengan OpenSSL yang ditulis sendiri pada perangkat keras yang sama. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  Namun, cara tercepat untuk membuat jabat tangan TLS adalah dengan tidak membuatnya sama sekali!  Kami telah menyertakan dukungan untuk dimulainya kembali sesi di gRPC-core dan gRPC-python, sehingga mengurangi beban pada CPU selama penyebaran. <br><br><h3>  Enkripsi tidak mahal </h3><br>  Banyak yang secara keliru percaya bahwa enkripsi itu mahal.  Bahkan, bahkan komputer modern paling sederhana pun melakukan enkripsi simetris hampir secara instan.  Prosesor standar dapat mengenkripsi dan mengotentikasi data pada kecepatan 40 Gb / s per inti: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  Namun demikian, kami masih harus mengonfigurasi gRPC untuk blok memori kami, yang beroperasi pada kecepatan 50 Gb / s.  Kami menemukan bahwa jika kecepatan enkripsi kira-kira sama dengan kecepatan salin, maka penting untuk meminimalkan jumlah operasi <i>memcpy.</i>  Selain itu, kami membuat beberapa perubahan pada gRPC itu sendiri. <br><br>  <i>Protokol yang diautentikasi dan terenkripsi menghindari banyak masalah yang tidak menyenangkan (misalnya, kerusakan data oleh prosesor, DMA atau pada jaringan).</i>  <i>Bahkan jika Anda tidak menggunakan gRPC, kami menyarankan untuk menggunakan TLS untuk kontak internal.</i> <br><br><h2>  Saluran Data Latensi Tinggi (BDP) </h2><br>  Catatan Penerjemah: subtitle asli menggunakan istilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">produk bandwidth-delay</a> , yang tidak memiliki terjemahan mapan ke dalam bahasa Rusia. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jaringan backbone Dropbox mencakup banyak pusat data</a> .  Kadang-kadang node yang berada di berbagai daerah harus berkomunikasi melalui RPC, misalnya, untuk replikasi.  Saat menggunakan TCP, kernel sistem bertanggung jawab untuk membatasi jumlah data yang dikirimkan dalam koneksi tertentu (dalam / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), meskipun gRPC berdasarkan HTTP / 2 memiliki alat sendiri kontrol aliran.  Batas atas BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di grpc-go terbatas pada 16 MB</a> , yang dapat memicu kemacetan. <br><br><h2>  net.Server Golang atau grpc.Server </h2><br>  Awalnya, dalam kode Go kami, kami mendukung HTTP / 1.1 dan gRPC dengan satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://golang.org/pkg/net/">net.Server</a> .  Solusinya masuk akal dalam hal mempertahankan kode program, tetapi tidak berhasil sama sekali.  Mendistribusikan HTTP / 1.1 dan gRPC di seluruh server dan memigrasikan gRPC ke grpc.Server secara signifikan meningkatkan bandwidth Courier dan penggunaan memori. <br><br><h2>  golang / protobuf atau gogo / protobuf </h2><br>  Beralih ke gRPC dapat meningkatkan biaya marshaling dan unmarshaling.  Untuk kode Go, kami dapat secara signifikan mengurangi beban CPU pada server Kurir dengan beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gogo / protobuf</a> . <br><br>  <i>Seperti biasa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transisi ke gogo / protobuf disertai oleh beberapa masalah</a> , tetapi jika Anda cukup membatasi fungsionalitasnya, seharusnya tidak ada masalah.</i> <br><br><h1>  Detail Implementasi </h1><br>  Pada bagian ini, kami akan menembus lebih dalam ke perangkat Courier, mempertimbangkan skema protobuf dan contoh stub dari berbagai bahasa.  Semua contoh diambil dari layanan Uji, yang kami gunakan selama pengujian integrasi Kurir. <br><br><h2>  Deskripsi Layanan </h2><br>  Lihatlah kutipan dari definisi layanan Uji: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Sebagaimana disebutkan di atas, batas waktu diperlukan untuk semua metode Kurir.  Dengan menggunakan opsi berikut, Anda dapat mengatur batas waktu untuk seluruh layanan: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Pada saat yang sama, setiap metode dapat diatur ke batas waktunya sendiri, membatalkan batas waktu seluruh layanan (jika ada): <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  Dalam kasus yang jarang terjadi ketika tenggat waktu tidak masuk akal (misalnya, saat melacak sumber daya), pengembang dapat menonaktifkannya: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  Selain itu, deskripsi layanan harus berisi dokumentasi API terperinci, mungkin dengan contoh penggunaan. <br><br><h2>  Generasi rintisan </h2><br>  Untuk memberikan fleksibilitas yang lebih besar, Courier menghasilkan bertopik sendiri tanpa bergantung pada fungsi pencegat yang disediakan oleh gRPC (dengan pengecualian Java, di mana API pencegat memiliki daya yang cukup).  Mari kita bandingkan bertopik kita dengan bertopik standar Golang. <br><br>  Ini adalah apa yang tampak seperti rintisan server gRPC standar: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Semua pemrosesan terjadi di dalam: decoding protobuf, meluncurkan pencegat (lihat variabel <code>interceptor</code> dalam kode), meluncurkan penangan UnaryUnary. <br><br>  Sekarang lihat bertopik Courier: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  Ada sedikit kode di sini, jadi mari kita uraikan. <br><br>  Pertama, kami menunda panggilan ke panic handler, yang bertanggung jawab untuk mengumpulkan kesalahan secara otomatis.  Ini akan memungkinkan kami untuk mengumpulkan semua pengecualian yang tidak tertangkap dalam repositori pusat untuk pengumpulan dan pelaporan selanjutnya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Alasan lain kami menjalankan panic handler kami sendiri adalah untuk memastikan bahwa aplikasi mogok jika terjadi kesalahan.  Golang / net HTTP handler standar dalam kasus ini akan mengabaikan masalah dan terus melayani permintaan baru (bahkan rusak dan tidak konsisten). <br><br>  Lalu kami meneruskan konteks, mendefinisikan ulang nilai berdasarkan metadata dari permintaan yang masuk: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Kami juga membuat (dan cache untuk efisiensi yang lebih besar) statistik klien sisi server untuk agregasi yang lebih rinci: <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Baris ini membuat statistik untuk setiap klien (yaitu, pengidentifikasi TLS) selama eksekusi.  Kami juga memiliki statistik tentang semua metode untuk setiap layanan.  Karena stub generator memiliki akses ke semua metode selama pembuatan kode, kita dapat membuatnya secara statis sebelumnya, sehingga tidak memperlambat program. <br><br>  Setelah itu, kami membuat struktur permintaan, mentransfernya ke kumpulan tugas dan menunggu eksekusi: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Harap dicatat bahwa pada titik ini kami tidak memecahkan kode protobuf, atau meluncurkan pencegat.  Sebelum ini, kumpulan akses, penentuan prioritas dan batasan jumlah permintaan yang dieksekusi harus melalui kumpulan tugas. <br><br>  <i>Perhatikan bahwa pustaka gRPC mendukung antarmuka TAP, yang memungkinkan Anda mencegat permintaan dengan kecepatan luar biasa.</i>  <i>Antarmuka menyediakan infrastruktur untuk membangun pembatas kecepatan yang efektif dengan konsumsi sumber daya minimal.</i> <br><br><h2>  Kode kesalahan khusus untuk aplikasi yang berbeda </h2><br>  Generator rintisan kami juga memungkinkan pengembang untuk menetapkan kode kesalahan khusus aplikasi menggunakan opsi khusus: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Baik gRPC dan kesalahan aplikasi menyebar dalam layanan, dan di perbatasan API, semua kesalahan diganti oleh UNKNOWN.  Berkat ini, kami dapat menghindari mentransfer masalah ke layanan lain, yang dapat mengakibatkan perubahan dalam semantik mereka. <br><br><h2>  Perubahan Python </h2><br>  Rintisan python menambahkan parameter konteks eksplisit ke semua penangan Courier: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  Pada awalnya itu terlihat aneh, tetapi seiring waktu, para pengembang terbiasa dengan <i>ctx</i> eksplisit seperti dulu. <br><br>  Harap dicatat bahwa stub kami sepenuhnya diketik untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mypy</a> , yang diimbangi selama refactoring utama.  Selain itu, integrasi dengan beberapa IDE (mis. PyCharm) disederhanakan. <br><br>  Terus mengikuti tren pengetikan statis, kami menambahkan anotasi mypy ke protokol itu sendiri: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Anotasi ini akan menghindari banyak bug umum, misalnya menetapkan nilai <i>Tidak Ada pada</i> bidang <i>string</i> jenis, misalnya <i>.</i> <br><br>  Kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tersedia di sini</a> . <br><br><h1>  Proses migrasi </h1><br>  Membuat tumpukan-RPC baru bukanlah tugas yang mudah, tetapi bahkan tidak berada di samping proses transisi penuh ke sana, jika Anda melihat dari sudut pandang kerumitan operasi.  Oleh karena itu, kami mencoba membuatnya semudah mungkin bagi pengembang untuk beralih dari RPC lama ke Courier.  Karena migrasi sering disertai dengan kesalahan, kami memutuskan untuk mengimplementasikannya secara bertahap. <br><br><h2>  Langkah 0: bekukan RPC lama </h2><br>  Pertama-tama, kami membekukan RPC lama agar tidak menembak target yang bergerak.  Itu juga mendorong orang untuk beralih ke Courier, karena semua fitur baru seperti tracing hanya tersedia dalam layanan di Courier. <br><br><h2>  Langkah 1: antarmuka umum untuk RPC dan Kurir lama </h2><br>  Kami mulai dengan mendefinisikan antarmuka umum untuk RPC dan Kurir yang lama.  Pembuatan kode kami seharusnya memastikan bahwa kedua versi bertopik sesuai dengan antarmuka ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Langkah 2: bermigrasi ke antarmuka baru </h2><br>  Setelah itu, kami mulai mengalihkan setiap layanan ke antarmuka baru, sambil terus menggunakan RPC yang lama.  Seringkali, perubahan kode sangat berbeda, yang memengaruhi semua metode layanan dan kliennya.  Karena tahap ini adalah yang paling bermasalah, kami ingin sepenuhnya menghilangkan risiko dengan mengubah hanya satu hal pada satu waktu. <br><br>  <i>Layanan sederhana dengan sejumlah kecil metode dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hak untuk melakukan kesalahan</a> dapat dimigrasikan secara bersamaan, tanpa memperhatikan peringatan kami.</i> <br><br><h2>  Langkah 3: memigrasikan pelanggan ke Kurir RPC </h2><br>  Selama proses migrasi, kami mulai meluncurkan server lama dan baru secara bersamaan di berbagai port dari mesin yang sama.  Mengalihkan implementasi RPC sisi klien dilakukan dengan mengubah satu baris: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Harap dicatat bahwa dengan model ini, Anda dapat mentransfer satu klien pada suatu waktu, dimulai dengan yang memiliki tingkat SLA yang lebih rendah. <br><br><h2>  Langkah 4: membersihkan </h2><br>       ,   ,   RPC    (               ).       —   . <br><br><h1>  Kesimpulan </h1><br> , Courier —  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  —  .           . <br></li><li>      —    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       —  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438474/">https://habr.com/ru/post/id438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438464/index.html">SciPy, algoritma grafik</a></li>
<li><a href="../id438466/index.html">Kruk untuk laser Cina</a></li>
<li><a href="../id438468/index.html">Koloni. Bab 23: Test Drive</a></li>
<li><a href="../id438470/index.html">Penjualan di seluruh dunia pada bulan Desember dan 2018: 2 juta kendaraan listrik plug-in yang terjual</a></li>
<li><a href="../id438472/index.html">Lingkungan arsitektur modular yang canggih di UE4</a></li>
<li><a href="../id438476/index.html">Untuk pertanyaan tentang buffer (dering)</a></li>
<li><a href="../id438478/index.html">GitLab 11.7 dirilis dengan Rilis, epik bertingkat multi-level dan registri paket NPM</a></li>
<li><a href="../id438480/index.html">Tempatkan dengan benar: 7 tempat ideal untuk menempatkan konten video</a></li>
<li><a href="../id438482/index.html">Reputasi, kerja, dan emigrasi: cara menggunakan alat promosi perusahaan untuk menyelesaikan masalah pribadi</a></li>
<li><a href="../id438486/index.html">Kartu memori yang tak tertembus - tenggelam, membeku, dan membakar High Endurance microSD Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>