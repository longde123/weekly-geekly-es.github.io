<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎭 🧘🏿 🏇🏿 Life Cycle ML 💃🏿 🧝 😅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En una implementación real de ML, el aprendizaje en sí requiere una cuarta parte del esfuerzo. Los tres trimestres restantes son preparación de datos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Life Cycle ML</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455648/">  En una implementación real de ML, el aprendizaje en sí requiere una cuarta parte del esfuerzo.  Los tres trimestres restantes son preparación de datos a través del dolor y la burocracia, un despliegue complejo a menudo en un circuito cerrado sin acceso a Internet, configuración de infraestructura, pruebas y monitoreo.  Documentos en cientos de hojas, modo manual, conflictos de versión de modelo, código abierto y empresa dura: todo esto le espera a un científico de datos.  Pero no está interesado en estos problemas operativos "aburridos", quiere desarrollar un algoritmo, lograr alta calidad, retribuir y no recordar más. <br><br>  Quizás, en algún lugar, ML se implemente más fácil, más simple, más rápido y con un solo botón, pero no hemos visto tales ejemplos.  Todo lo que está arriba es la experiencia de Front Tier en fintech y telecomunicaciones.  Sergey Vinogradov, experto en arquitectura de sistemas altamente cargados, en grandes almacenes y en análisis de datos pesados, habló sobre él en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> . <br><br><img src="https://habrastorage.org/webt/ss/7n/cm/ss7ncmtdsij0wncwt-uuzxneit8.jpeg"><br><a name="habracut"></a><br><h2>  Ciclo de vida modelo </h2><br>  Por lo general, el ciclo de vida en nuestra área temática consta de tres partes.  En el primero <strong>, una tarea proviene del negocio</strong> .  En el segundo, un <strong>ingeniero de datos y / o científico de datos prepara datos</strong> , construye un modelo.  En la tercera parte, comienza el <strong>caos</strong> .  En los dos últimos, suceden diferentes situaciones interesantes. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7GM9ac6ojtw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3>  Jack de todos los oficios </h3><br>  La primera situación frecuente es que un científico de datos o ingeniero de datos tiene acceso a los productos, por lo que le dicen: "Hiciste todo esto, lo apostaste". <br><br>  Una persona toma un <strong>cuaderno Jupyter</strong> o un paquete de cuadernos, los considera únicamente como un artefacto de una implementación y comienza a replicarse con alegría en algunos servidores. <br><br>  Todo parece estar bien, pero no siempre.  Más tarde te diré por qué. <br><br><h3>  Explotación despiadada </h3><br>  La segunda historia es más compleja, y generalmente ocurre en empresas donde la explotación ha alcanzado un estado de locura leve.  El científico de datos trae su solución a la operación.  Abren esta caja negra y ven algo terrible: <br><br><ul><li>  cuadernos </li><li>  pepinillo de diferentes versiones; </li><li>  montón de scripts: no está claro dónde y cuándo ejecutarlos, dónde guardar los datos que generan. </li></ul><br>  En este rompecabezas, la explotación encuentra incompatibilidad de versiones.  Por ejemplo, un científico de datos no especificó una versión específica de la biblioteca, y la operación tomó la última.  Después de un tiempo, el científico de datos recurre: <br><br>  <em>- Estableciste scikit-learn en la versión incorrecta, ¡ahora todas las métricas se han ido!</em>  <em>Necesita volver a la versión anterior.</em> <br><br>  Esto rompe completamente la producción y la explotación sufre. <br><br><h3>  Burocracia </h3><br>  En las empresas con logotipos verdes, cuando el científico de datos entra en funcionamiento y trae el modelo, generalmente recibe un documento de 800 hojas en respuesta: "Siga estas instrucciones, de lo contrario su producto nunca verá la luz del día". <br><br>  El triste científico de datos se va, tira todo a la mitad y luego renuncia: no está interesado en hacer esto. <br><br><h3>  Implementar </h3><br>  Supongamos que un científico de datos ha pasado por todos los círculos y al final todo se ha implementado.  Pero no podrá entender que todo funciona como debería.  En mi experiencia, en los mismos bancos bendecidos no hay monitoreo de productos de ciencia de datos. <br><br>  Es bueno si el especialista escribe los resultados de su trabajo en la base de datos.  Después de un tiempo, los recibirá y verá qué sucede dentro.  Pero esto no siempre sucede.  Cuando una empresa y un científico de datos simplemente creen que todo está funcionando bien y es maravilloso, se traduce en casos fallidos. <br><br><h3>  IMF </h3><br>  De alguna manera, desarrollamos un motor de puntuación para una gran organización de microfinanzas.  No los dejaron ir al producto, sino que simplemente nos quitaron una cascada de modelos, la instalaron y la lanzaron.  Los resultados de las pruebas de los modelos los satisfacen.  Pero después de 6 meses volvieron: <br><br>  <em>- Todo está mal.</em>  <em>El negocio no va, estamos empeorando cada vez más.</em>  <em>Parece que los modelos son excelentes, pero los resultados están cayendo, el fraude y el incumplimiento cada vez más, y menos dinero.</em>  <em>¿Por qué te pagamos?</em>  <em>Vamos a hacerlo bien.</em> <br><br>  Al mismo tiempo, el acceso al modelo nuevamente no se da.  Los registros se descargaron durante un mes, además, hace seis meses.  Estudiamos la descarga durante otro mes y llegamos a la conclusión de que en algún momento el departamento de TI de la IMF cambió los datos de entrada y, en lugar de documentos en json, comenzaron a enviar documentos en xml.  El modelo esperaba json, pero recibió xml, estaba triste y pensó que no había datos en la entrada. <br><br><blockquote>  Si no hay datos, entonces la evaluación de lo que está sucediendo es diferente.  Sin monitoreo, esto no se puede detectar. </blockquote><br><h3>  Nueva versión, cascada y pruebas. </h3><br>  A menudo nos enfrentamos al hecho de que el modelo funciona bien, pero por alguna razón <strong>se ha</strong> desarrollado una <strong>nueva versión</strong> .  El modelo nuevamente necesita ser traído de alguna manera, y nuevamente para atravesar todos los círculos del infierno.  Es bueno si las versiones de la biblioteca son las mismas que en el modelo anterior, y si no, la implementación comienza de nuevo ... <br><br>  A veces, antes de poner una nueva versión en la batalla, queremos <strong>probarla</strong> : ponerla en el producto, mirar el mismo flujo de tráfico, asegurarnos de que sea bueno.  Esta es nuevamente la cadena de implementación completa.  Además, configuramos los sistemas para que, de acuerdo con este modelo, no se produzcan resultados reales, si se trata de puntuación, sino que solo hubo monitoreo y análisis de los resultados para un análisis posterior. <br><br>  Hay situaciones en las <strong>que se usa</strong> una <strong>cascada de modelos.</strong>  Cuando los resultados de los siguientes modelos dependen de los anteriores, de alguna manera debe establecer la interacción entre ellos y, en algún lugar, todo esto debe guardarse. <br><br><h2>  ¿Cómo resolver tales problemas? </h2><br>  A menudo, una persona resuelve problemas <strong>manualmente</strong> , especialmente en pequeñas empresas.  Sabe cómo funciona todo, tiene en cuenta todas las versiones de modelos y bibliotecas, sabe dónde y qué scripts funcionan, qué escaparates construyen.  Todo esto es maravilloso  Particularmente hermosas son las historias que deja el modo manual. <br><br>  <strong>La historia de la herencia</strong> .  Un buen hombre trabajaba en un pequeño banco.  Una vez fue a un país del sur y no regresó.  Después de eso, obtuvimos una herencia: un montón de código que genera escaparates en los que funcionan los modelos de modelos.  El código es hermoso, funciona, pero no sabemos la versión exacta del script que genera este o aquel escaparate.  En la batalla, todos los escaparates están presentes y todos se lanzan.  Pasamos dos meses tratando de distinguir esta intrincada maraña y estructurarla de alguna manera. <br><br>  <strong>En una empresa dura, las</strong> personas no quieren molestarse con todo tipo de Python, Júpiter, etc. Dicen: <br><br>  <em>- Compremos IBM SPSS, instálelo y todo estará genial.</em>  <em>Problemas con el control de versiones, con las fuentes de datos, con la implementación allí resuelta de alguna manera.</em> <br><br>  Este enfoque tiene derecho a existir, pero no todos pueden permitírselo.  En cualquier caso, esta es una aguja dentada de alta calidad.  Se sientan en él, pero no funciona para salir - muescas.  Y generalmente cuesta mucho. <br><br>  <strong>El código abierto es lo</strong> opuesto al enfoque anterior.  Los desarrolladores navegaron por Internet, encontraron muchas soluciones de código abierto que resuelven sus tareas en diversos grados.  Esta es una excelente manera, pero para nosotros no encontramos soluciones que satisfagan nuestros requisitos al 100%. <br><br>  Por lo tanto, hemos elegido la opción clásica: <strong>nuestra decisión</strong> .  Sus muletas, bicicletas, todas propias, nativas. <br><br><h2>  ¿Qué queremos de nuestra decisión? </h2><br><br>  <strong>No escribas todo tú mismo</strong> .  Queremos tomar componentes, especialmente los de infraestructura, que han demostrado ser buenos y están familiarizados con la operación en las instituciones con las que trabajamos.  Simplemente escribimos un entorno que aislará fácilmente el trabajo del científico de datos del trabajo de DevOps. <br><br>  <strong>Procese datos en dos modos: ambos en modo por lotes: lote y en tiempo real</strong> .  Nuestras tareas incluyen ambos modos de operación. <br><br>  <strong>Facilidad de despliegue, y en un perímetro cerrado</strong> .  Cuando se trabaja con datos privados confidenciales, no hay conexión a Internet.  En este momento, todo debería llegar rápida y exactamente a la producción.  Por lo tanto, comenzamos a mirar hacia Gitlab, la tubería de CI / CD dentro de él y Docker. <br><br><blockquote>  Un modelo no es un fin en sí mismo.  No resolvemos el problema de construir un modelo, resolvemos un problema de negocios. </blockquote><br>  Dentro de la tubería, debe haber reglas y un conglomerado de modelos con soporte para <strong>versionar todos los</strong> componentes de la tubería. <br><br>  ¿Qué se entiende por tubería?  En Rusia, la Ley Federal 115 sobre la lucha contra el lavado de dinero y la financiación del terrorismo está en vigor.  Solo el índice de las recomendaciones del Banco Central ocupa 16 pantallas.  Estas son reglas simples que un banco puede cumplir si tiene tales datos, o no puede hacerlo si no tiene datos. <br><br>  La evaluación de un prestatario, una transacción financiera u otro proceso comercial es un flujo de datos que procesamos.  Una secuencia debe pasar por este tipo de regla.  Estas reglas son descritas de manera fácil por el analista.  No es un científico de datos, pero conoce bien la ley u otras instrucciones.  El analista se sienta y, en lenguaje sencillo, describe las comprobaciones de los datos. <br><br>  <strong>Construye cascadas de modelos</strong> .  A menudo surge una situación cuando el siguiente modelo utiliza para su trabajo los valores obtenidos en modelos anteriores. <br><br>  <strong>Probar hipótesis rápidamente.</strong>  Repito la tesis anterior: un científico de datos hizo algún tipo de modelo, gira en la batalla y funciona bien.  Por alguna razón, el especialista encontró una solución mejor, pero no quiere arruinar el flujo de trabajo establecido.  El científico de datos está colgando un nuevo modelo en el mismo tráfico de combate en el sistema de combate.  Ella no participa directamente en la toma de decisiones, pero sirve el mismo tráfico, considera algunas conclusiones y estas conclusiones se almacenan en algún lugar. <br><br>  <strong>Función de reutilización fácil.</strong>  Muchas tareas tienen el mismo tipo de componentes, especialmente los relacionados con la extracción de características o reglas.  Queremos arrastrar estos componentes a otras tuberías. <br><br><h2>  ¿Qué decidiste hacer? </h2><br>  Primero queremos monitoreo.  Y dos de su tipo. <br><br><h3>  Monitoreo </h3><br>  <strong>Monitoreo técnico.</strong>  Si se implementan componentes de la tubería, en funcionamiento deberían ver qué sucede con el componente: cómo consume memoria, CPU, disco. <br><br>  <strong>Monitoreo de negocios.</strong>  Esta es una herramienta científica de datos que le permite abstraerse de los matices técnicos de la implementación.  A nivel de diseño, la construcción ayuda a determinar qué métricas del modelo deberían estar disponibles en el monitoreo, por ejemplo, distribución de características o resultados de servicios de puntuación. <br><br>  Un científico de datos define las métricas y no debe preocuparse por cómo ingresan al sistema de monitoreo.  Lo único importante es que definió estas métricas y la apariencia del panel en el que se mostrarán las métricas.  Luego, el especialista lanzó todo lo relacionado con la producción, la implementación y, después de un tiempo, las métricas se volcaron en el monitoreo.  Entonces, un científico de datos sin acceso al producto puede ver lo que está sucediendo dentro del modelo. <br><br><h3>  Prueba </h3><br>  Probar la <strong>tubería para la consistencia</strong> .  Dados los detalles de la tubería, este es un tipo de gráfico de computación.  Queremos entender que estamos implementando un gráfico, podemos evitarlo y encontrar una manera de salir de él. <br><br>  El gráfico tiene componentes - módulos.  Todos los módulos deben pasar la unidad y las pruebas de integración.  El proceso debe ser transparente y fácil para un científico de datos. <br><br>  El desarrollador describe el modelo y las pruebas por sí solo o con la ayuda de otra persona.  Pone todo en Gitlab, la canalización configurada por Continuous Integration aumenta, prueba, ve resultados.  Si todo está bien, va más allá, no, comienza de nuevo. <br><br>  El científico de datos se centra en el modelo y no sabe qué hay debajo del capó.  Para esto, se le dan varias cosas. <br><br><ul><li>  <strong>Una API para la integración con el núcleo del</strong> <strong>sistema a</strong> través del bus de datos - bus de mensajes.  En este caso, el especialista debe describir qué está entrando y qué está saliendo de su modelo, el punto de entrada y la unión con diferentes componentes dentro de la tubería. </li><li>  Después de entrenar al modelo, aparece un <strong>artefacto: un archivo XGBoost</strong> o <strong>pickle</strong> .  El científico de datos tiene un ejecutor para trabajar con artefactos: debe integrar los componentes de la tubería en su interior. </li><li>  API fácil y transparente para el científico de datos para monitorear el funcionamiento de los componentes de la tubería: monitoreo técnico y comercial. </li><li>  <strong>Una infraestructura simple y transparente</strong> para integrarse con fuentes de datos y preservar los resultados del trabajo. </li></ul><br>  A menudo, los modelos funcionan para nosotros, y después de un tiempo llega una auditoría que quiere elevar toda la historia del servicio.  La auditoría quiere verificar la corrección del trabajo, la ausencia de fraude de nuestra parte.  Se necesitan herramientas simples para que cualquier auditor que conozca SQL pueda ingresar a un repositorio especial y ver cómo funciona todo, qué decisiones se tomaron y por qué. <br><br>  Pusimos las bases para dos historias importantes para nosotros. <br><br>  <strong>Viaje del cliente.</strong>  Esta es una oportunidad para utilizar los mecanismos para preservar todo el historial del cliente, lo que le sucedió como parte de los procesos comerciales que se implementan en este sistema. <br><br>  Es posible que tengamos fuentes de datos externas, por ejemplo, plataformas DMP.  De ellos obtenemos información sobre el comportamiento humano en la red y en dispositivos móviles.  Esto puede afectar el LTV de su modelo y los modelos de puntuación.  Si el prestatario se atrasa en el pago, podemos predecir que esta no es una intención maliciosa, simplemente hay problemas.  En este caso, aplicamos métodos suaves de exposición al prestatario.  Cuando se resuelven los problemas, el cliente cerrará el préstamo.  Cuando venga la próxima vez, sabremos toda su historia.  El científico de datos obtendrá una historia visual del modelo y realizará una puntuación en modo de luz. <br><br>  <strong>Identificación de anomalías</strong> .  Nos enfrentamos constantemente a un mundo muy complejo.  Por ejemplo, los puntos débiles dentro de la evaluación acelerada de las IMF pueden ser una fuente de fraude automático. <br><br>  Customer Journey es un concepto de acceso rápido y fácil al flujo de datos que atraviesa el modelo.  El modelo facilita la detección de anomalías que son características del fraude en el momento de su ocurrencia masiva. <br><br><h2>  ¿Cómo se arregla todo? </h2><br>  Sin dudarlo, tomamos <strong>Kafka</strong> como un parche de Message Bus.  Esta es una buena solución que utilizan muchos de nuestros clientes, la operación puede trabajar con ella. <br><br><img src="https://habrastorage.org/webt/uu/5k/3r/uu5k3rnxw7lu4iulruewhzmif8w.jpeg"><br><br><blockquote>  Es posible que algunos componentes del sistema ya se utilicen en la propia empresa.  No estamos construyendo el sistema nuevamente, sino reutilizando lo que ya tienen. </blockquote><br>  <strong>El almacenamiento de datos</strong> en este caso es el almacenamiento que el cliente generalmente ya tiene.  Puede ser Hadoop, bases de datos relacionales y no relacionales.  Podemos trabajar de forma nativa con HDFS, Hive, Impala, Greenplum y PostgreSQL.  Consideramos estos almacenes como una fuente de escaparates. <br><br>  Los datos llegan al almacén, pasan a través de nuestro ETL o el ETL del cliente, si tiene uno.  Estamos construyendo escaparates que se utilizan aún más dentro de los modelos.  El almacenamiento de datos se usa en modo de solo lectura. <br><br><h3>  Nuestros desarrollos </h3><br>  <strong>Pizarra</strong>  El nombre se toma de una práctica bastante extraña de matemáticos de los años 30-40.  Este es el administrador de las tuberías que viven en el sistema de administración.  Blackboard tiene algún tipo de Meta Storage.  Almacena las tuberías en sí y las configuraciones necesarias para inicializar todos los componentes. <br><br>  Todo el trabajo del sistema comienza con Blackboard.  Por algún milagro, la tubería terminó en Meta Storage, Blackboard después de un tiempo comprende esto, saca la versión actual de la tubería, la inicializa y envía una señal dentro de Kafka. <br><br>  Hay un <strong>entorno de tiempo de ejecución</strong> .  Está construido en Dockers y se puede replicar en servidores, incluso en la nube privada del cliente. <br><br>  Fuera de la caja viene el <strong>Actor</strong> principal <strong>:: Init</strong> - este es el inicializador.  Este es un genio que solo puede hacer dos cosas: <strong>construir</strong> y <strong>destruir componentes</strong> .  Recibe un comando de Blackboard: "Aquí está la canalización, debe iniciarse en tales servidores con tales recursos en cantidades tales, ¡trabajo!"  Entonces el actor comienza todo. <br><br>  Matemáticamente, un actor es una función que toma uno o más objetos como entrada, en su interior cambia el estado de los objetos según algún algoritmo, en la salida crea un nuevo objeto o cambia el estado de uno existente. <br><br>  Técnicamente, un actor es un programa de Python.  Se ejecuta en un contenedor Docker con su entorno. <br><br>  El actor no sabe sobre la existencia de otros actores.  La única entidad que sabe que, además del actor, existe toda la tubería en su conjunto: esto es Blackboard.  Monitorea el estado de ejecución de todos los actores dentro del sistema y mantiene el estado actual, que se expresa en el monitoreo como una imagen de todo el proceso comercial en su conjunto. <br><br>  Actor :: Init genera muchos contenedores Docker.  Además, los actores pueden trabajar con el almacenamiento de datos. <br><br>  El sistema en sí tiene un componente de <strong>almacenamiento de eventos</strong> .  Como almacenamiento de eventos usamos <strong>ClickHouse</strong> .  Su tarea es simple: toda la información intercambiada entre el actor a través de Kafka se almacena en ClickHouse.  Esto se hace <strong>para una auditoría adicional</strong> .  Este es el registro de operaciones de canalización. <br><br>  Los actores también se pueden desarrollar para <strong>Customer Journey</strong> .  Ven cambios en el registro de la tubería y pueden reconstruir sobre la marcha las ventanas necesarias para que los modelos o componentes trabajen con las reglas, que ya están dentro de la tubería.  Este es un proceso continuo de cambio de datos. <br><br>  El monitoreo se construye de manera bastante primitiva en <strong>Prometeo</strong> .  El actor recibe una API básica, y en un modo cerrado, pero lo suficientemente transparente para el desarrollador, envía mensajes con métricas a Kafka.  Prometheus lee las métricas de Kafka y las guarda en su repositorio. <br><br>  Para la visualización usamos <strong>Grafana</strong> . <br><br><h3>  Dos puntos de integracion </h3><br>  El primero es el punto de integración con las fuentes de datos que pasan por ETL al almacén de datos.  El segundo punto de integración cuando un consumidor de datos ya utiliza un servicio, por ejemplo, un servicio de puntuación. <br><br>  Tomamos <strong>Apache ServiceMix.</strong>  Por experiencia, estos puntos de integración son del mismo tipo con el mismo tipo de protocolos: SOAP, RESTful, colas con menos frecuencia.  Cada vez que no queremos desarrollar nuestro propio constructor o servicio para generar el próximo servicio SOAP.  Por lo tanto, tomamos ServiceMix, lo describimos en el SDL, en el que se construyen los modelos de datos de este servicio y los métodos que existen en él.  Luego empujamos a través del enrutador dentro de ServiceMix, y genera el servicio en sí. <br><br>  De nosotros mismos, agregamos una difícil conversión síncrono-asíncrona.  Todas las solicitudes que viven dentro del sistema son asíncronas y pasan por el bus de mensajes. <br><br>  La mayoría de los servicios de puntuación son sincrónicos.  Las solicitudes de ServiceMix vienen a través de REST o SOAP.  En este punto, pasa a través de nuestro Gateway, que retiene el conocimiento de la sesión HTTP.  Luego envía un mensaje a Kafka, se ejecuta a través de una tubería y se genera una solución. <br><br>  Sin embargo, aún puede no haber solución.  Por ejemplo, algo se cayó, o hay un SLA difícil de tomar una decisión, y Gateway monitorea: "OK, recibí una solicitud, él vino a mí en otro tema de Kafka, o no me llegó nada, pero mi disparador de tiempo de espera funcionó".  Por otra parte, la conversión de síncrono a asíncrono continúa, y dentro de la misma sesión HTTP, hay una respuesta al consumidor con el resultado del trabajo.  Esto puede ser un error o un pronóstico normal. <br><br>  En este lugar, por cierto, comimos un perro sin sabor gracias al gran y poderoso Open Source.  Utilizamos ServiceMix de una de las últimas versiones y Kafka de versiones anteriores y todo funcionó perfectamente.  Escribimos en este Gateway, basado en esos cubos que ya estaban en ServiceMix.  Cuando salió la nueva versión de Kafka, la agarramos felizmente, pero resultó que el apoyo a los encabezados dentro del mensaje en Kafka que existía anteriormente había cambiado.  Gateway dentro de ServiceMix ya no puede trabajar con ellos.  Para entender esto, pasamos mucho tiempo.  Como resultado, creamos nuestro Gateway, que puede funcionar con nuevas versiones de Kafka.  Escribimos sobre el problema a los desarrolladores de ServiceMix y recibimos la respuesta: "¡Gracias, definitivamente lo ayudaremos en las próximas versiones!" <br><br>  Por lo tanto, nos vemos obligados a monitorear las actualizaciones y cambiar regularmente algo. <br><br>  <strong>La infraestructura es Gitlab.</strong>  Usamos casi todo lo que contiene. <br><br><ul><li>  Repositorio de código. </li><li>  Continúa la integración / Continúa la entrega de la tubería. </li><li>  Registro para mantener un registro de contenedores Docker. </li></ul><br><h3>  Componentes </h3><br>  Hemos desarrollado 5 componentes: <br><br><ul><li>  <strong>Pizarra</strong> : gestión del ciclo de vida de la tubería.  Dónde, qué y con qué parámetros ejecutar desde la tubería. </li><li>  <strong>El extractor de características</strong> funciona de manera simple: informamos al extractor de características que obtenemos tal o cual modelo de datos en la entrada, seleccionamos los campos necesarios de los datos y los asignamos a ciertos valores.  Por ejemplo, obtenemos la fecha de nacimiento del cliente, la convertimos a la edad, la usamos como una característica en nuestro modelo.  El extractor de funciones es responsable del enriquecimiento de datos. </li><li>  <strong>Motor basado en reglas</strong> : verificación de datos de acuerdo con las reglas.  Este es un lenguaje de descripción simple que le permite a una persona familiarizada con la construcción de &lt;code&gt; if, si no, &lt;code /&gt; bloquea describir las reglas para verificar dentro del sistema. </li><li>  <strong>Motor de aprendizaje automático</strong> : le permite ejecutar el ejecutor, inicializar el modelo entrenado y enviarlo a los datos de entrada.  En la salida, el modelo toma datos. </li><li>  <strong>Motor de</strong> decisión: motor de decisión, salir del gráfico.  Al tener una cascada de modelos, por ejemplo, diferentes ramas de la evaluación del prestatario, debe decidir sobre el tema del dinero en alguna parte.  El conjunto de reglas para la solución debe ser simple. ,     LTV- —     ,     ,  . </li></ul><br><br><h3>   </h3><br>         .  —  ,    .  —      ,      . <br><br>   pipeline    . <br><img src="https://habrastorage.org/webt/o7/vy/dj/o7vydjrruyfittwhwzumh_gc_rq.jpeg"><br><ul><li>   <strong>Feature extractor</strong> :  ,        ,      . </li><li> <strong> </strong> . ,  -:  , ,       18. </li><li>  <strong> .</strong>    ,    .     ,      ,        pipeline. </li><li>  <strong>Decision engine</strong> .             . </li><li>  <strong></strong> . </li></ul><br>      yaml.         .    ,  ,        .           yaml. <br><br>  pipeline,   ,   : feature extractor, rules, models, decision engine,    .   — <strong>      Docker-</strong> .    Registry,   Docker-. -,   ,    . ,  ,      Docker-       . <br><br><h3>  Tubería </h3><br>     ,     <strong>Python</strong> —         . Feature extractor, ,   decision engine   Python. <br><br> Pipeline   <strong>yaml.</strong>      meta storage     —   <strong></strong> . <br><br>  Runtime environment   10 ,  Blackboard  ,    pipeline    10 .  ,      : , , IP-    Kafka, , .       . <br><br>     GitLab.      Ansible. ,    .           ,      50 000    Ansible  . <br><br><h2>   ? </h2><br>  GitLab  pipeline.    GitLab. CI  ,   ,  ,  .   <strong>GitLab Runner</strong> ,    Docker-  ,    pipeline.    —    Registry. <br><br><img src="https://habrastorage.org/webt/gz/dx/hr/gzdxhruymhjm2_wejqybqizdp0i.jpeg"><br><br>  Docker  ,       .   Docker-        .   CI pipeline    pipeline  -  Meta Storage,    Blackboard. <br><br> Blackboard    Meta Storage —   , , ,   -.   Docker-     , , . <br><br> -   Blackboard  Meta Storage      :   ,  Kafka,   .  ,    ,   Docker-    ,     . <br><br>  ,    Docker-,  — pipeline ! <br><br>      DigitalOcean.     AWS  Scaleway,     . <br><br>    ,        .  pipeline         . ,    . <br><br><h3>    ? </h3><br>   —   .  ,   pipeline,     real-time   . <br><br><ul><li> 2 Feature extractor  .     1 , .. json    . </li><li> 8  — 8  ML engine.      XGBoost. </li><li> 18     RB engine (115 ).   1000     . </li><li> 1 decision engine. </li></ul><br>       200   .  2 Feature extractor, 8 , 18   1 decision engine      1,2 . <br><br><h3>  </h3><br> <strong>Discovery .</strong>  ,   -   .  ,      ,    .    .      Meta Storage. <br><br> <strong>  pipeline</strong> .    ,  <strong>BPM</strong> .        yaml      ,     ,      . <br><br> <strong>    .</strong>       Java, Scala, R.    Python,       ,     .    API   ,   pipeline      . <br><br><h2>  Cual es el resultado? </h2><br>    —     .    —   .   <strong> </strong> ,      .  ,         .     —     2018 . <br><br>         ,      .    —    ,   ,    . <br><br> <strong>    ,   </strong> .     ,    ,    notebook   ,     . <br><br><blockquote> , -      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,           .  ,     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UseData Conf</a> .  ,    ,       ,   16 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455648/">https://habr.com/ru/post/455648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455638/index.html">Alan Kay no inventó objetos</a></li>
<li><a href="../455640/index.html">"La máquina de la emoción" de Marvin Minsky: Capítulo 4. "Cómo reconocemos la conciencia"</a></li>
<li><a href="../455642/index.html">La arquitectura del servicio de cola de mensajes distribuidos en Yandex.Cloud</a></li>
<li><a href="../455644/index.html">Usamos datos en la práctica.</a></li>
<li><a href="../455646/index.html">Semana de la seguridad 24: puertas traseras de fábrica en teléfonos inteligentes Android</a></li>
<li><a href="../455650/index.html">Cómo entrenamos una red neuronal para clasificar tornillos</a></li>
<li><a href="../455652/index.html">Aprendizaje profundo vs sentido común: desarrollar un bot de chat</a></li>
<li><a href="../455658/index.html">El legendario Intel Core i7-2600K: prueba de Sandy Bridge en 2019 (parte 3)</a></li>
<li><a href="../455662/index.html">Gran pantalla mecánica con mecanismo de leva como decodificador.</a></li>
<li><a href="../455666/index.html">Creación de ventas salientes en una empresa de servicios de TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>