<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ ğŸ”¯ ğŸ‘©ğŸ»â€âœˆï¸ Dalam situasi yang tidak dapat dipahami - tulis skrip ğŸ”º ğŸ¤œ ğŸ¤º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Skrip adalah salah satu cara paling umum untuk membuat aplikasi lebih fleksibel, dengan kemampuan untuk memperbaiki sesuatu saat dalam perjalanan. Ten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dalam situasi yang tidak dapat dipahami - tulis skrip</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/431084/"><img src="https://habrastorage.org/webt/a5/ng/5b/a5ng5b6thpfbxpcasm51swkuzgk.jpeg" alt="gambar"><br><br>  Skrip adalah salah satu cara paling umum untuk membuat aplikasi lebih fleksibel, dengan kemampuan untuk memperbaiki sesuatu saat dalam perjalanan.  Tentu saja, pendekatan ini juga memiliki kelemahan, Anda harus selalu ingat keseimbangan antara fleksibilitas dan pengelolaan.  Tetapi dalam artikel ini kami tidak akan membahas "secara umum" tentang pro dan kontra dari menggunakan skrip, kami akan mempertimbangkan cara praktis untuk menerapkan pendekatan ini, dan juga memperkenalkan perpustakaan yang menyediakan infrastruktur yang nyaman untuk menambahkan skrip ke aplikasi yang ditulis dalam Kerangka Kerja Musim Semi. <br><a name="habracut"></a><br><h2>  Beberapa kata pengantar </h2><br>  Ketika Anda ingin menambahkan kemampuan untuk mengubah logika bisnis dalam suatu aplikasi tanpa kompilasi dan penyebaran berikutnya, maka skrip adalah salah satu cara yang muncul di pikiran di tempat pertama.  Seringkali, skrip muncul bukan karena dimaksudkan, tetapi karena itu terjadi.  Misalnya, dalam spesifikasi ada bagian dari logika yang tidak sepenuhnya jelas sekarang, tetapi agar tidak menghabiskan beberapa hari ekstra (dan kadang-kadang lebih lama) untuk analisis, Anda dapat membuat titik ekstensi dan memanggil skrip - sebuah rintisan.  Dan kemudian, tentu saja, skrip ini akan ditulis ulang ketika persyaratan menjadi jelas. <br><br>  Metode ini bukan hal baru, dan kelebihan dan kekurangannya sudah diketahui: fleksibilitas - Anda dapat mengubah logika pada aplikasi yang sedang berjalan dan menghemat waktu untuk menginstal ulang, tetapi, di sisi lain, skrip lebih sulit untuk diuji, sehingga kemungkinan masalah dengan keamanan, kinerja, dll. <br><br>  Trik-trik yang akan dibahas nanti dapat bermanfaat baik bagi pengembang yang sudah menggunakan skrip dalam aplikasi mereka, dan bagi mereka yang hanya memikirkannya. <br><br><h2>  Bukan masalah pribadi, hanya scripting </h2><br>  Dengan JSR-233, scripting di Java menjadi sangat sederhana.  Ada cukup mesin skrip berdasarkan API ini (Nashorn, JRuby, Jython, dan lainnya), jadi menambahkan sedikit keajaiban skrip ke kode Anda bukan masalah: <br><br><pre><code class="java hljs">Map&lt;String, Object&gt; parameters = createParametersMap(); ScriptEngineManager manager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptEngineManager(); ScriptEngine scriptEngine = manager.getEngineByName(<span class="hljs-string"><span class="hljs-string">"groovy"</span></span>); Object result = scriptEngine.eval(script.getScriptAsString(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBindings(parameters));</code> </pre> <br>  Jelas, jika kode seperti itu tersebar di seluruh aplikasi, maka itu akan berubah menjadi sesuatu yang tidak dapat dipahami.  Dan, tentu saja, jika Anda memiliki lebih dari satu panggilan skrip di aplikasi Anda, Anda perlu membuat kelas terpisah untuk bekerja dengannya.  Kadang-kadang Anda dapat melangkah lebih jauh dan membuat kelas khusus yang akan membungkus panggilan <code>evaluateGroovy()</code> dalam metode Java yang diketik secara reguler.  Metode-metode ini akan memiliki kode utilitas yang cukup seragam, seperti dalam contoh: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"cust"</span></span>, customer); params.put(<span class="hljs-string"><span class="hljs-string">"amount"</span></span>, orderAmount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (BigDecimal)scripting.evalGroovy(getScriptSrc(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), params); }</code> </pre><br>  Pendekatan ini sangat meningkatkan transparansi saat memanggil skrip dari kode aplikasi - Anda dapat segera melihat parameter apa yang diterima skrip, apa jenisnya dan apa yang dikembalikan.  Hal utama adalah jangan lupa untuk menambah standar penulisan kode larangan memanggil skrip bukan dari metode yang diketik! <br><br><h2>  Kami memompa skrip </h2><br>  Terlepas dari kenyataan bahwa skrip itu sederhana, jika Anda memiliki banyak skrip dan menggunakannya secara intensif, ada peluang nyata untuk mengalami masalah kinerja.  Misalnya, jika Anda menggunakan sekelompok templat groovy untuk menghasilkan laporan dan Anda menjalankannya pada saat yang sama, cepat atau lambat ini akan menjadi salah satu hambatan dalam kinerja aplikasi. <br>  Oleh karena itu, banyak kerangka kerja membuat berbagai tambahan pada API standar untuk meningkatkan kecepatan kerja, caching, pemantauan eksekusi, menggunakan bahasa skrip yang berbeda dalam satu aplikasi, dll. <br><br>  Misalnya, mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip yang</a> agak cerdik dibuat di CUBA yang mendukung fitur tambahan, seperti: <br><br><ol><li>  Kemampuan untuk menulis skrip di Jawa dan Groovy </li><li>  Cache kelas agar tidak mengkompilasi ulang skrip </li><li>  Tempat JMX untuk mengontrol mesin </li></ol><br>  Semua ini, tentu saja, meningkatkan kinerja dan kegunaan, tetapi tetap saja mesin tingkat rendah tetap tingkat rendah, dan Anda masih perlu membaca teks skrip, meneruskan parameter dan memanggil API untuk menjalankan skrip.  Jadi Anda masih perlu melakukan semacam pembungkus di setiap proyek untuk membuat pengembangan lebih efisien. <br><br>  Dan tidak adil untuk tidak menyebutkan GraalVM - mesin eksperimental yang dapat menjalankan program dalam berbagai bahasa (JVM dan non-JVM) dan memungkinkan Anda untuk memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul dalam bahasa ini</a> ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi Java</a> .  Saya berharap bahwa Nashorn akan turun dalam sejarah cepat atau lambat, dan kita akan memiliki kesempatan untuk menulis bagian kode dalam berbagai bahasa dalam satu sumber.  Tapi ini hanya mimpi. <br><br><h2>  Kerangka Kerja Musim Semi: tawaran yang sulit ditolak? </h2><br>  Spring memiliki dukungan pelaksanaan skrip bawaan yang dibangun di atas API JDK.  Dalam <code>org.springframework.scripting.*</code> Paket, Anda dapat menemukan banyak kelas yang berguna - semua sehingga Anda dapat dengan mudah menggunakan API tingkat rendah untuk skrip dalam aplikasi Anda. <br><br>  Selain itu, ada tingkat dukungan yang lebih tinggi, hal ini dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Singkatnya - Anda perlu membuat kelas dalam bahasa scripting (misalnya, Groovy) dan menerbitkannya sebagai kacang melalui deskripsi XML: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messenger"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script-source</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"classpath:Messenger.groovy"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"I Can Do The Frug"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Setelah kacang diterbitkan, kacang dapat ditambahkan ke kelasnya menggunakan IoC.  Spring menyediakan pembaruan skrip otomatis saat mengubah teks dalam file, Anda dapat menggantung aspek pada metode, dll. <br><br>  Ini terlihat bagus, tetapi Anda perlu membuat kelas "nyata" untuk mempublikasikannya, Anda tidak dapat menulis fungsi reguler dalam skrip.  Selain itu, skrip hanya dapat disimpan dalam sistem file, untuk menggunakan database Anda harus naik di dalam Spring.  Ya, dan banyak yang menganggap konfigurasi XML sudah ketinggalan zaman, terutama jika aplikasi sudah memiliki segalanya pada anotasi.  Ini, tentu saja, rasanya, tetapi orang sering harus memperhitungkannya. <br><br><h2>  Script: Kesulitan dan Gagasan </h2><br>  Jadi, setiap solusi memiliki harganya sendiri, dan jika kita berbicara tentang skrip dalam aplikasi Java, maka ketika memperkenalkan teknologi ini, kita mungkin menghadapi beberapa kesulitan: <br><br><ol><li>  Kelola.  Seringkali, panggilan skrip tersebar di seluruh aplikasi, dan dengan perubahan kode, cukup sulit untuk melacak panggilan skrip yang diperlukan. </li><li>  Kemampuan untuk menemukan rekan panggilan.  Jika terjadi kesalahan pada skrip tertentu, maka menemukan semua <code>evaluateGroovy()</code> panggilannya akan menjadi masalah, kecuali jika Anda menerapkan pencarian berdasarkan nama file atau panggilan metode seperti <code>evaluateGroovy()</code> </li><li>  Transparansi  Menulis skrip bukanlah tugas yang mudah, dan bahkan lebih sulit bagi mereka yang menyebut skrip ini.  Anda perlu mengingat apa yang disebut parameter input, tipe data apa yang mereka miliki dan apa hasil dari eksekusi.  Atau lihat kode sumber skrip setiap kali. </li><li>  Menguji dan memperbarui - tidak selalu mungkin untuk menguji skrip di lingkungan kode aplikasi, dan bahkan setelah mengunggahnya ke server "pertempuran", Anda harus dapat memutar kembali semuanya jika terjadi kesalahan. </li></ol><br>  Tampaknya membungkus panggilan skrip dalam metode Java akan membantu menyelesaikan sebagian besar masalah di atas.  Sangat bagus jika kelas seperti itu dapat dipublikasikan dalam wadah IoC dan metode panggilan dengan nama normal dan bermakna dalam layanan mereka, alih-alih memanggil <code>eval(â€œdisc_10_cl.groovyâ€)</code> dari beberapa kelas utilitas.  Kelebihan lainnya adalah bahwa kode menjadi mendokumentasikan diri sendiri, pengembang tidak perlu memikirkan jenis algoritma apa yang tersembunyi di balik nama file. <br><br>  Selain itu, jika setiap skrip akan dikaitkan dengan hanya satu metode, Anda dapat dengan cepat menemukan semua rekan panggilan dalam aplikasi menggunakan menu "Temukan Penggunaan" dari IDE dan memahami tempat skrip dalam setiap algoritma logika bisnis tertentu. <br><br>  Pengujian disederhanakan - ini berubah menjadi pengujian kelas "normal", menggunakan kerangka kerja yang akrab, mengejek, dan banyak lagi. <br><br>  Semua hal di atas sangat sesuai dengan ide yang disebutkan di awal artikel - kelas "khusus" untuk metode yang diterapkan oleh skrip.  Tetapi bagaimana jika Anda mengambil satu langkah lagi dan menyembunyikan semua kode layanan dari jenis yang sama untuk memanggil mesin skrip dari pengembang sehingga ia bahkan tidak memikirkannya (well, hampir)? <br><br><h2>  Gudang naskah - konsep </h2><br>  Idenya cukup sederhana dan harus akrab bagi mereka yang setidaknya pernah bekerja dengan Spring, terutama dengan Spring JPA.  Yang Anda butuhkan adalah membuat antarmuka Java dan memanggil skrip saat memanggil metode-metodenya.  Di JPA, omong-omong, pendekatan yang identik digunakan - panggilan ke CrudRepository dicegat, berdasarkan nama metode dan parameter, permintaan dibuat, yang kemudian dieksekusi oleh mesin database. <br><br>  Apa yang dibutuhkan untuk mengimplementasikan konsep tersebut? <br><br>  Pertama, anotasi tingkat kelas sehingga Anda dapat menemukan antarmuka - repositori dan membuat bin berdasarkannya. <br><br>  Juga, penjelasan tentang metode antarmuka ini mungkin akan berguna untuk menyimpan metadata yang diperlukan untuk memanggil metode.  Misalnya - di mana mendapatkan teks skrip dan mesin mana yang digunakan. <br><br>  Tambahan yang berguna adalah kemampuan untuk menggunakan metode dengan implementasi di antarmuka (alias default) - kode ini akan berfungsi sampai analis bisnis menampilkan versi algoritma yang lebih lengkap, dan pengembang membuat skrip berdasarkan <br>  informasi ini.  Atau biarkan analis menulis skrip, dan pengembang kemudian cukup menyalinnya ke server.  Ada banyak pilihan :-) <br><br>  Jadi, anggaplah bahwa untuk toko online Anda perlu membuat layanan untuk menghitung diskon berdasarkan profil pengguna.  Tidak jelas sekarang bagaimana melakukan ini, tetapi analis bisnis bersumpah bahwa semua pengguna terdaftar berhak atas diskon 10%, ia akan mengetahui sisanya dari pelanggan dalam waktu seminggu.  Servis dibutuhkan besok - musim tentunya.  Seperti apa kode untuk kasus ini? <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  Dan kemudian algoritma itu sendiri, ditulis, misalnya, di asyik, akan tiba pada waktunya, di sana diskon akan sedikit berbeda: <br><br><pre> <code class="plaintext hljs">def age = 50 if ((Calendar.YEAR - customer.birthday.year) &gt;= age) { return orderAmount.multiply(0.75) } else { return orderAmount.multiply(0.9) }</code> </pre><br>  Tujuan dari semua ini adalah untuk memberikan pengembang kemampuan untuk menulis hanya kode antarmuka dan kode skrip, dan tidak dipusingkan dengan semua panggilan ini untuk mendapatkan <code>getEngine</code> , <code>eval</code> , dan lainnya.  Perpustakaan untuk bekerja dengan skrip harus melakukan semua keajaiban - mencegat permohonan metode antarmuka, mendapatkan teks skrip, mengganti nilai parameter, mendapatkan mesin skrip yang diinginkan, menjalankan skrip (atau memanggil metode default jika tidak ada teks skrip) dan mengembalikan nilai.  Idealnya, selain kode yang telah ditulis, program harus memiliki sesuatu seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerServiceBean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PricingRepository pricingRepository; <span class="hljs-comment"><span class="hljs-comment">//Other injected beans here @Override public BigDecimal applyCustomerDiscount(Customer cust, BigDecimal orderAmnt) { if (customer.isRegistered()) { return pricingRepository.applyCustomerDiscount(cust, orderAmnt); } else { return orderAmnt; } //Other service methods here }</span></span></code> </pre><br>  Tantangannya bisa dibaca, dimengerti, dan untuk membuatnya, seseorang tidak perlu memiliki keterampilan khusus. <br><br>  Ini adalah ide-ide yang menjadi dasar dibuatnya perpustakaan kecil untuk mengerjakan skrip.  Ini dimaksudkan untuk aplikasi Spring, kerangka kerja ini digunakan untuk membuat perpustakaan.  Ini menyediakan API yang dapat diperluas untuk memuat skrip dari berbagai sumber dan mengeksekusinya, yang menyembunyikan pekerjaan rutin dengan mesin skrip. <br><br><h2>  Bagaimana cara kerjanya </h2><br>  Untuk semua antarmuka yang ditandai dengan <code>@ScriptRepository</code> , objek proxy dibuat selama inisialisasi konteks Spring menggunakan metode <code>newProxyInstance</code> dari kelas <code>Proxy</code> .  Proxy ini diterbitkan dalam konteks Spring sebagai kacang singleton, sehingga Anda dapat mendeklarasikan bidang kelas dengan jenis antarmuka dan meletakkan <code>@Autowired</code> atau <code>@Inject</code> annotation di atasnya.  Tepat seperti yang direncanakan. <br><br>  Pemindaian dan pemrosesan antarmuka skrip diaktifkan menggunakan anotasi <code>@EnableSriptRepositories</code> , seperti di Spring, JPA atau repositori untuk MongoDB diaktifkan (masing-masing <code>@EnableJpaRepositories</code> dan <code>@EnableMongoRepositories</code> ).  Sebagai parameter anotasi, Anda perlu menentukan array dengan nama paket yang ingin Anda pindai. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableScriptRepositories</span></span>(basePackages = {<span class="hljs-string"><span class="hljs-string">"com.example"</span></span>, <span class="hljs-string"><span class="hljs-string">"com.sample"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//More configuration here. }</span></span></code> </pre><br>  Metode harus dijelaskan dengan <code>@ScriptMethod</code> (ada juga <code>@GroovyScript</code> dan <code>@JavaScript</code> , dengan spesialisasi yang sesuai) untuk menambahkan metadata untuk memanggil skrip.  Tentu saja, metode standar di antarmuka didukung. <br><br>  Struktur umum perpustakaan ditunjukkan dalam diagram.  Komponen yang disorot biru perlu dikembangkan, putih - yang sudah ada di perpustakaan.  Ikon Pegas menandai komponen yang tersedia dalam konteks Pegas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/h0/xc/rzh0xc48cr_kw1d97y2i3wrbdvu.png"></div><br>  Ketika metode antarmuka disebut (pada kenyataannya, objek proxy), penangan panggilan diluncurkan, yang dalam konteks aplikasi mencari dua kacang: penyedia, yang akan mencari teks skrip, dan pelaksana, yang pada kenyataannya, teks yang ditemukan akan mengeksekusi.  Kemudian pawang mengembalikan hasilnya ke metode panggilan. <br><br>  Nama <code>@ScriptMethod</code> penyedia dan pelaksana ditentukan dalam anotasi <code>@ScriptMethod</code> , di mana Anda juga dapat menetapkan batas waktu pada eksekusi metode.  Di bawah ini adalah contoh kode penggunaan perpustakaan: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> (providerBeanName = <span class="hljs-string"><span class="hljs-string">"resourceProvider"</span></span>, evaluatorBeanName = <span class="hljs-string"><span class="hljs-string">"groovyEvaluator"</span></span>, timeout = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @ScriptParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cust"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Customer customer, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScriptParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"amount"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> BigDecimal orderAmount) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  Anda dapat melihat anotasi <code>@ScriptParam</code> - mereka diperlukan untuk menunjukkan nama parameter saat meneruskannya ke skrip, karena kompiler Java menghapus nama asli dari sumber (ada cara untuk membuatnya tidak melakukan ini, tetapi lebih baik tidak bergantung padanya).  Anda dapat menghilangkan nama parameter, tetapi dalam kasus ini, Anda harus menggunakan "arg0", "arg1" dalam skrip, yang tidak sangat meningkatkan keterbacaan. <br><br>  Secara default, perpustakaan memiliki penyedia untuk membaca file .groovy dan .js dari disk dan pelaksana yang terkait, yang merupakan pembungkus API JSR-233 standar.  Anda dapat membuat kacang Anda sendiri untuk sumber skrip yang berbeda dan untuk mesin yang berbeda, untuk ini Anda perlu mengimplementasikan antarmuka yang sesuai: <code>ScriptProvider</code> dan <code>SpringEvaluator</code> .  Antarmuka pertama menggunakan <code>org.springframework.scripting.ScriptSource</code> dan yang kedua adalah <code>org.springframework.scripting.ScriptEvaluator</code> .  API Musim Semi digunakan sehingga kelas yang sudah jadi dapat digunakan jika sudah ada dalam aplikasi. <br>  Penyedia dan artis dicari berdasarkan nama untuk fleksibilitas yang lebih besar - Anda dapat mengganti kacang standar dari perpustakaan di aplikasi Anda dengan memberi nama komponen Anda dengan nama yang sama. <br><br><h2>  Pengujian dan versi </h2><br>  Karena skrip sering berubah dan mudah, Anda perlu memiliki cara untuk memastikan bahwa perubahan tidak merusak apa pun.  Perpustakaan kompatibel dengan JUnit, repositori dapat dengan mudah diuji sebagai kelas reguler sebagai bagian dari tes unit atau integrasi.  Pustaka tiruan juga didukung, dalam tes untuk pustaka Anda dapat menemukan contoh bagaimana membuat tiruan pada metode repositori skrip. <br><br>  Jika diperlukan versi, maka Anda dapat membuat penyedia yang akan membaca berbagai versi skrip dari sistem file, dari database, atau dari Git, misalnya.  Jadi akan mudah untuk mengatur rollback ke versi script sebelumnya jika ada masalah di server utama. <br><br><h2>  Total </h2><br>  Perpustakaan yang disajikan akan membantu mengatur skrip dalam aplikasi Musim Semi: <br><br><ol><li>  Pengembang akan selalu memiliki informasi tentang parameter apa yang dibutuhkan skrip dan apa yang dikembalikan.  Dan jika metode antarmuka diberi nama secara bermakna, lalu apa yang dilakukan skrip. </li><li>  Penyedia dan pelaksana akan membantu menjaga kode untuk menerima skrip dan berinteraksi dengan mesin skrip di satu tempat dan panggilan ini tidak akan tersebar di seluruh kode aplikasi. </li><li>  Semua panggilan skrip dapat dengan mudah ditemukan menggunakan Temukan Penggunaan. </li></ol><br>  Konfigurasi semi Boot, pengujian unit, tiruan didukung.  Anda bisa mendapatkan data tentang metode "skrip" dan parameternya melalui API.  Dan Anda juga dapat membungkus hasil eksekusi dengan objek ScriptResult khusus, di mana akan ada hasil atau contoh pengecualian jika Anda tidak ingin repot dengan mencoba ... menangkap ketika memohon skrip.  Konfigurasi XML didukung jika diperlukan karena satu dan lain alasan.  Dan akhirnya - Anda dapat menentukan batas waktu untuk metode skrip, jika perlu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber perpustakaan ada di sini.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431084/">https://habr.com/ru/post/id431084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431074/index.html">Panduan JavaScript Bagian 8: Tinjauan Umum Fitur ES6</a></li>
<li><a href="../id431076/index.html">Kerangka Node.js paling populer tahun 2018</a></li>
<li><a href="../id431078/index.html">Panduan penanganan kesalahan JavaScript</a></li>
<li><a href="../id431080/index.html">Bagaimana mengatur kantor jarak jauh dan tidak kehilangan tim di ruang angkasa</a></li>
<li><a href="../id431082/index.html">Kotlin: mencari Kepala Pemasaran</a></li>
<li><a href="../id431086/index.html">Semua yang ingin Anda ketahui tentang PVS-Studio dan tidak ragu untuk bertanya</a></li>
<li><a href="../id431088/index.html">Manajemen file salah dilakukan - Bagian 1: Awalnya dari tahun 90-an</a></li>
<li><a href="../id431090/index.html">Satu VK bot, satu C # dan sebuah jeruk</a></li>
<li><a href="../id431092/index.html">ROS: peta kedalaman pada Raspberry Pi "darah rendah"</a></li>
<li><a href="../id431094/index.html">Sortir Solitaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>