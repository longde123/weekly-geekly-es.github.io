<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóº üòñ üßìüèº Buat shader air kartun untuk web. Bagian 3 üôåüèº ‚úãüèΩ üë©üèª‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian kedua, kami memeriksa garis apung dan busa. Pada bagian terakhir ini, kami menerapkan distorsi bawah air sebagai efek pasca pemrosesan. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat shader air kartun untuk web. Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417091/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif" alt="gambar"></div><br>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">kedua,</a> kami memeriksa garis apung dan busa.  Pada bagian terakhir ini, kami menerapkan distorsi bawah air sebagai efek pasca pemrosesan. <br><br><h2>  Efek refraksi dan pasca pemrosesan </h2><br>  Tujuan kami adalah untuk menyampaikan pembiasan cahaya dalam air secara visual.  Kami sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">bicara tentang</a> cara membuat distorsi jenis ini dalam fragmen shader untuk adegan 2D.  Di sini satu-satunya perbedaan adalah bahwa kita perlu memahami area layar di bawah air dan hanya menerapkan distorsi. <br><br><h3>  Pemrosesan pos </h3><br>  Dalam kasus umum, efek pasca pemrosesan adalah efek apa pun yang diterapkan ke seluruh adegan setelah rendering, misalnya, nuansa warna atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">efek layar CRT lama</a> .  Alih-alih merender adegan langsung ke layar, kami pertama-tama merendernya ke buffer atau tekstur, dan kemudian, melewati adegan melalui shader kami, kami merender ke layar. <br><a name="habracut"></a><br>  Di PlayCanvas, Anda dapat menyesuaikan efek pasca pemrosesan ini dengan membuat skrip baru.  Sebut saja <strong>Refraction.js</strong> dan salin templat ini ke dalamnya sebagai kosong: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------   ------------------------// pc.extend(pc, function () { //  -      var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //      this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.buffer = buffer; }; //      pc.PostEffect RefractionPostEffect = pc.inherits(RefractionPostEffect, pc.PostEffect); RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { //      render, //    ,    , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } }); return { RefractionPostEffect: RefractionPostEffect }; }()); //---------------  ------------------------// var Refraction = pc.createScript('refraction'); Refraction.attributes.add('vs', { type: 'asset', assetType: 'shader', title: 'Vertex Shader' }); Refraction.attributes.add('fs', { type: 'asset', assetType: 'shader', title: 'Fragment Shader' }); //  initialize       Refraction.prototype.initialize = function() { var effect = new pc.RefractionPostEffect(this.app.graphicsDevice, this.vs.resource, this.fs.resource); //     postEffects var queue = this.entity.camera.postEffects; queue.addEffect(effect); this.effect = effect; //       this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; }; Refraction.prototype.update = function(){ if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ this.swap(this); } }; Refraction.prototype.swap = function(old){ this.entity.camera.postEffects.removeEffect(old.effect); this.initialize(); };</span></span></code> </pre> <br>  Ini mirip dengan skrip biasa, tetapi kami mendefinisikan kelas <code>RefractionPostEffect</code> yang dapat diterapkan pada kamera.  Untuk rendering, perlu shader vertex dan fragmen.  Atribut sudah dikonfigurasi, jadi mari kita buat <strong>Refraction.frag</strong> dengan konten berikut: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec4 color = texture2D(uColorBuffer, vUv0); gl_FragColor = color; }</code> </pre> <br>  Dan <strong>Refraction.vert</strong> dengan vertex shader dasar: <br><br><pre> <code class="javascript hljs">attribute vec2 aPosition; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = vec4(aPosition, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); vUv0 = (aPosition.xy + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; }</code> </pre> <br>  Sekarang lampirkan skrip <strong>Refraction.js</strong> ke kamera dan tetapkan atribut yang sesuai untuk shader.  Saat Anda memulai permainan, Anda akan melihat pemandangannya dengan cara yang sama seperti sebelumnya.  Ini adalah efek pasca-kosong yang hanya merender ulang adegan.  Untuk memastikan itu bekerja, mari kita coba berikan adegan warna merah. <br><br>  Alih-alih mengembalikan warna ke Refraction.frag, coba atur komponen merah ke 1.0, yang akan memberi gambar gambar yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/981/b78/937/981b78937b536280aeacdb3ef8c33897.png"></div><br><h3>  Shader distorsi </h3><br>  Untuk membuat distorsi animasi, kita perlu menambahkan variabel waktu yang seragam, jadi mari kita buat di dalam konstruktor pasca-efek ini di Refraction.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RefractionPostEffect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">graphicsDevice, vs, fs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">"precision "</span></span> + graphicsDevice.precision + <span class="hljs-string"><span class="hljs-string">" float;\n"</span></span>; fragmentShader = fragmentShader + fs; <span class="hljs-comment"><span class="hljs-comment">//       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    this.time = 0; };</span></span></code> </pre> <br>  Sekarang di dalam fungsi render, kami meneruskannya ke shader kami untuk meningkatkannya: <br><br><pre> <code class="javascript hljs">RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { <span class="hljs-comment"><span class="hljs-comment">//      render, //      , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); /// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniform-  scope.resolve("uTime").setValue(this.time); this.time += 0.1; //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } });</span></span></code> </pre> <br>  Sekarang kita dapat menggunakan kode shader yang sama dari tutorial distorsi air, mengubah shader fragmen penuh kami menjadi sebagai berikut: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec2 pos = vUv0; float X = pos.x*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; float Y = pos.y*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; pos.y += cos(X+Y)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*cos(Y); pos.x += sin(XY)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*sin(Y); vec4 color = texture2D(uColorBuffer, pos); gl_FragColor = color; }</code> </pre> <br>  Jika semuanya dilakukan dengan benar, maka seluruh gambar akan terlihat seperti benar-benar di bawah air. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif"></div><br><blockquote>  <em>Tugas 1: Pastikan distorsi hanya berlaku di bagian bawah layar.</em> </blockquote><br><h3>  Masker kamera </h3><br>  Kami hampir selesai.  Tetap bagi kita untuk menerapkan efek distorsi ini ke bagian bawah air layar.  Cara termudah yang saya pikirkan adalah membuat kembali pemandangan dengan permukaan air yang berwarna putih pekat, seperti yang ditunjukkan pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/06f/284/41e06f284290afbf768f6f615360c8bf.png"></div><br>  Ini akan membuat tekstur yang kita gunakan sebagai topeng.  Kemudian kami akan mentransfer tekstur ini ke shader refraksi kami, yang akan mendistorsi piksel pada gambar yang sudah jadi hanya ketika piksel yang sesuai dalam topeng berwarna putih. <br><br>  Mari kita tambahkan atribut boolean ke permukaan air untuk mengetahui apakah itu digunakan sebagai topeng.  Tambahkan yang berikut ke Water.js: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'isMask'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>,<span class="hljs-attr"><span class="hljs-attr">title</span></span>:<span class="hljs-string"><span class="hljs-string">"Is Mask?"</span></span>});</code> </pre> <br>  Kemudian, seperti biasa, kita bisa meneruskannya ke shader menggunakan <code>material.setParameter('isMask',this.isMask);</code>  .  Kemudian nyatakan dalam Water.frag dan warnai piksel putih jika atributnya benar. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    uniform uniform bool isMask; //      ,    //    true if(isMask){ color = vec4(1.0); }</span></span></code> </pre> <br>  Pastikan ini berfungsi dengan menyalakan properti "Is Mask?".  di editor dan memulai kembali game.  Seharusnya terlihat putih, seperti pada gambar di atas. <br><br>  Sekarang, untuk merender ulang adegan itu, kita perlu kamera kedua.  Buat kamera baru di editor dan sebut saja <strong>CameraMask</strong> .  Kami juga menduplikasi entitas Air di editor dan memberi nama <strong>WaterMask</strong> duplikat.  Pastikan untuk entitas "Water Is Is Mask?"  salah, dan WaterMask benar. <br><br>  Untuk memesan kamera baru agar dirender menjadi tekstur, bukan ke layar, buat skrip <strong>CameraMask.js</strong> baru dan pasangkan ke kamera baru.  Kami membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">Target Render</a> untuk menangkap output dari kamera ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize       CameraMask.prototype.initialize = function() { //  512x512x24-      var colorBuffer = new pc.Texture(this.app.graphicsDevice, { width: 512, height: 512, format: pc.PIXELFORMAT_R8_G8_B8, autoMipmap: true }); colorBuffer.minFilter = pc.FILTER_LINEAR; colorBuffer.magFilter = pc.FILTER_LINEAR; var renderTarget = new pc.RenderTarget(this.app.graphicsDevice, colorBuffer, { depth: true }); this.entity.camera.renderTarget = renderTarget; };</span></span></code> </pre> <br>  Sekarang setelah meluncurkan aplikasi, Anda akan melihat bahwa kamera ini tidak lagi menampilkan layar.  Kita bisa mendapatkan output dari target render di <strong>Refraction.js</strong> sebagai berikut: <br><br><pre> <code class="javascript hljs">Refraction.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cameraMask = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'CameraMask'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskBuffer = cameraMask.camera.renderTarget.colorBuffer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.RefractionPostEffect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.graphicsDevice, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vs.resource, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fs.resource, maskBuffer); <span class="hljs-comment"><span class="hljs-comment">// ... //     ,    };</span></span></code> </pre> <br>  Perhatikan bahwa saya meneruskan tekstur topeng ini sebagai argumen ke konstruktor pasca-efek.  Kita perlu membuat tautan di konstruktor kita, sehingga akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">////       var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.time = 0; //// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;    this.buffer = buffer; };</span></span></code> </pre> <br>  Akhirnya, dalam fungsi render, kami meneruskan buffer ke shader kami: <br><br><pre> <code class="javascript hljs">scope.resolve(<span class="hljs-string"><span class="hljs-string">"uMaskBuffer"</span></span>).setValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer);</code> </pre> <br>  Sekarang, untuk memastikan bahwa semua ini berfungsi, saya akan menyerahkannya kepada Anda sebagai tugas. <br><br><blockquote>  Tugas 2: render uMaskBuffer di layar untuk memastikan bahwa itu adalah output dari kamera kedua. </blockquote><br>  Yang berikut harus dipertimbangkan: target render dikonfigurasikan dalam inisialisasi skrip CameraMask.js, dan harus siap pada saat Refraction.js dipanggil.  Jika skrip bekerja secara berbeda, maka kami mendapatkan kesalahan.  Untuk memastikan mereka bekerja dalam urutan yang benar, seret CameraMask ke atas daftar entitas di editor, seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/093/747/2d80937472cd112108f303959c35d4c1.png"></div><br>  Kamera kedua harus selalu terlihat dengan tampilan yang sama seperti yang asli, jadi mari kita membuatnya selalu mengikuti posisi dan rotasi skrip CameraMask.js dalam pembaruan: <br><br><pre> <code class="javascript hljs">CameraMask.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getPosition(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getRotation(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setPosition(pos.x,pos.y,pos.z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setRotation(rot); };</code> </pre> <br>  Dalam inisialisasi, tentukan <code>CameraToFollow</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'Camera'</span></span>);</code> </pre> <br><h3>  Masker kliping </h3><br>  Kedua kamera sekarang memberikan hal yang sama.  Kami ingin kamera topeng membuat semuanya kecuali air sungguhan, dan kamera nyata membuat semuanya kecuali air topeng. <br><br>  Untuk melakukan ini, kita dapat menggunakan topeng kliping bit kamera.  Ia bekerja mirip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">dengan topeng tabrakan</a> .  Objek akan dipotong (mis., Tidak dirender) jika hasil bitwise <code>AND</code> antara mask-nya dan mask kamera adalah 1. <br><br>  Misalkan Air memiliki bit 2 dan WaterMask memiliki bit 3. Semua bit kecuali 3 harus ditetapkan untuk kamera nyata, dan semua bit kecuali 2 untuk kamera topeng. Cara termudah untuk mengatakan "semua bit kecuali N" adalah sebagai berikut cara: <br><br><pre> <code class="javascript hljs">~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; N) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Baca lebih lanjut tentang operasi bitwise di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> . <br><br>  Untuk mengonfigurasi topeng kliping kamera, kita dapat memasukkan yang berikut di bagian bawah inisialisasi skrip <strong>CameraMask.js</strong> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   ,  2 this.entity.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 2) &gt;&gt;&gt; 0; //   ,  3 this.CameraToFollow.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 3) &gt;&gt;&gt; 0; //      ,   : // console.log((this.CameraToFollow.camera.camera.cullingMask &gt;&gt;&gt; 0).toString(2));</span></span></code> </pre> <br>  Sekarang di Water.js kita akan menetapkan bit 2 dari topeng jala air, dan dan versi topeng itu pada bit 3: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      initialize  Water.js //    var bit = this.isMask ? 3 : 2; meshInstance.mask = 0; meshInstance.mask |= (1 &lt;&lt; bit);</span></span></code> </pre> <br>  Sekarang satu spesies akan dengan air biasa, dan yang kedua dengan air putih solid.  Gambar di sebelah kiri menunjukkan tampilan dari kamera asli, dan di sebelah kanan tampilan dari kamera topeng. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/e1b/271/d55e1b271351df16edab549ca065837f.png"></div><br><h3>  Aplikasi topeng </h3><br>  Dan sekarang langkah terakhir!  Kita tahu bahwa area bawah laut ditandai dengan piksel putih.  Kami hanya perlu memeriksa apakah kami memiliki piksel putih, dan jika tidak, matikan distorsi di <strong>Refraction.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      vec4 maskColor = texture2D(uMaskBuffer, pos); vec4 maskColor2 = texture2D(uMaskBuffer, vUv0); //     ? if(maskColor != vec4(1.0) || maskColor2 != vec4(1.0)){ //      pos = vUv0; }</span></span></code> </pre> <br>  Dan ini harus menyelesaikan masalah kita! <br><br>  <em>Perlu juga dicatat bahwa karena tekstur untuk topeng diinisialisasi pada saat startup, ketika Anda mengubah ukuran jendela pada waktu berjalan, itu tidak akan lagi sesuai dengan ukuran layar.</em> <br><br><h3>  Menghaluskan </h3><br>  Anda mungkin memperhatikan bahwa tepi adegan sekarang terlihat agak tajam.  Ini terjadi karena setelah menerapkan efek pasca, kami kehilangan perataan. <br><br>  Kita dapat menerapkan perataan tambahan di atas efek kita sebagai efek-pos lain.  Untungnya, ada variabel lain di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">toko PlayCanvas</a> yang bisa kita gunakan.  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">halaman aset skrip</a> , klik tombol unduhan besar berwarna hijau, dan pilih proyek Anda dari daftar yang muncul.  Skrip akan muncul di root jendela Aset sebagai <strong>posteffect-fxaa.js</strong> .  Cukup pasangkan ke entitas Kamera dan adegan Anda akan mulai terlihat jauh lebih baik! <br><br><h2>  Pikiran dalam kesimpulan </h2><br>  Jika Anda sampai di sini, Anda bisa memuji diri sendiri!  Dalam tutorial ini kami membahas beberapa teknik.  Sekarang Anda harus merasa percaya diri ketika bekerja dengan vertex shader, rendering dalam tekstur, menerapkan efek post-processing, kliping objek selektif, menggunakan buffer kedalaman dan bekerja dengan blending dan transparansi.  Meskipun kami telah menerapkan semua ini di PlayCanvas, Anda dapat memenuhi semua konsep umum grafis komputer ini dalam satu atau lain bentuk pada platform apa pun. <br><br>  Semua teknik ini juga berlaku untuk banyak efek lainnya.  Satu aplikasi yang sangat menarik ditemukan untuk vertex shaders, saya temukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">laporan pada grafik Abzu</a> , di mana pengembang menjelaskan bagaimana mereka menggunakan vertex shaders untuk secara efektif menggerakkan puluhan ribu ikan di layar. <br><br>  Sekarang Anda memiliki efek air yang indah yang dapat Anda terapkan dalam gim Anda!  Anda dapat menyesuaikannya dan menambahkan detail Anda sendiri.  Jauh lebih banyak yang dapat dilakukan dengan air (saya bahkan tidak menyebutkan jenis refleksi apa pun).  Di bawah ini adalah beberapa ide. <br><br><h4>  Gelombang kebisingan </h4><br>  Alih-alih hanya menggerakkan gelombang dengan kombinasi cosinus dan sinus, Anda dapat mencicipi teksturnya sehingga ombak terlihat sedikit lebih alami dan kurang dapat diprediksi. <br><br><h4>  Jejak busa dinamis </h4><br>  Alih-alih garis air yang benar-benar statis di permukaan, Anda dapat menarik ke tekstur saat memindahkan objek untuk membuat jejak busa yang dinamis.  Ini dapat dilakukan dengan berbagai cara, sehingga tugas ini sendiri dapat menjadi proyek. <br><br><h2>  Kode sumber </h2><br>  Proyek PlayCanvas yang sudah selesai dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">sini</a> .  Repositori kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">port proyek di bawah Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417091/">https://habr.com/ru/post/id417091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417081/index.html">Utara, akan, berharap, negara tanpa batas, atau Bagaimana proyek dibuat dalam kondisi Siberia yang parah</a></li>
<li><a href="../id417083/index.html">Banyak sekali Piala Dunia 2018</a></li>
<li><a href="../id417085/index.html">Browser membisukan suara dalam aplikasi WebRTC Anda. Hentikan apa?</a></li>
<li><a href="../id417087/index.html">HPE Digitize 2018: acara dan siaran langsung</a></li>
<li><a href="../id417089/index.html">Komputer kuantum: satu foton untuk memerintah semua</a></li>
<li><a href="../id417093/index.html">Sakelar sentuh dengan Modbus: mengapa diperlukan dan bagaimana menerapkannya di apartemen pintar</a></li>
<li><a href="../id417097/index.html">Pemrograman JavaScript</a></li>
<li><a href="../id417099/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 2</a></li>
<li><a href="../id417101/index.html">Definisi Ready - Yang Kami Lupa Memberitahu Tentang</a></li>
<li><a href="../id417103/index.html">Spark SQL. Sedikit tentang pengoptimal permintaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>