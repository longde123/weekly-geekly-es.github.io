<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💋 🚵🏾 🚙 O processamento de erros irrecuperáveis ​​no Swift 🗝️ 👨🏼‍🤝‍👨🏻 🌇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefácio 


 Este artigo é um exemplo de como podemos fazer pesquisas sobre o comportamento das funções da Swift Standard Library, construindo nosso c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O processamento de erros irrecuperáveis ​​no Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440884/"><h2 id="preface">  Prefácio </h2><br><p> Este artigo é um exemplo de como podemos fazer pesquisas sobre o comportamento das funções da Swift Standard Library, construindo nosso conhecimento não apenas na documentação da Biblioteca, mas também em seu código-fonte. </p><br><h2 id="unrecoverable-errors">  Erros irrecuperáveis </h2><br><p>  Todos os eventos que os programadores chamam de "erros" podem ser separados em dois tipos. </p><br><ul><li>  Eventos causados ​​por fatores externos, como uma falha na conexão de rede. </li><li>  Eventos causados ​​por erro de um programador, como chegar a um caso de operador de switch que deve estar inacessível. </li></ul><a name="habracut"></a><br><p>  Os eventos do primeiro tipo são processados ​​em um fluxo de controle regular.  Por exemplo, reagimos à falha de rede mostrando uma mensagem para um usuário e configurando um aplicativo para aguardar a recuperação da conexão de rede. </p><br><p>  Tentamos descobrir e eliminar eventos do segundo tipo o mais cedo possível antes que o código seja produzido.  Uma das abordagens aqui é executar algumas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verificações em tempo de execução, encerrando a execução do programa</a> em um estado depurável e imprimir uma mensagem com uma indicação de onde no erro ocorreu o código. </p><br><p>  Por exemplo, um programador pode encerrar a execução se o inicializador necessário não foi fornecido, mas foi chamado.  Isso será notado e corrigido invariavelmente durante a primeira execução de teste. </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) }</code> </pre> <br><p>  Outro exemplo é a alternância entre índices (vamos supor que, por algum motivo, você não possa usar a enumeração). </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> index { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">// something is done here case 1: // other thing is done here case 2: // and other thing is done here default: assertionFailure("Impossible index") }</span></span></code> </pre> <br><p>  Novamente, um programador causará falha durante a depuração aqui, a fim de observar inevitavelmente um erro na indexação. </p><br><p>  Existem cinco funções de terminação na Swift Standard Library (como no Swift 4.2). </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">precondition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition: @autoclosure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> message: <span class="hljs-meta"><span class="hljs-meta">@autoclosure</span></span> () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, file: <span class="hljs-type"><span class="hljs-type">StaticString</span></span> = #file, line: <span class="hljs-type"><span class="hljs-type">UInt</span></span> = #line)</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">preconditionFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message: @autoclosure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, file: <span class="hljs-type"><span class="hljs-type">StaticString</span></span> = #file, line: <span class="hljs-type"><span class="hljs-type">UInt</span></span> = #line) -&gt; <span class="hljs-type"><span class="hljs-type">Never</span></span></code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition: @autoclosure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> message: <span class="hljs-meta"><span class="hljs-meta">@autoclosure</span></span> () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, file: <span class="hljs-type"><span class="hljs-type">StaticString</span></span> = #file, line: <span class="hljs-type"><span class="hljs-type">UInt</span></span> = #line)</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertionFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message: @autoclosure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, file: <span class="hljs-type"><span class="hljs-type">StaticString</span></span> = #file, line: <span class="hljs-type"><span class="hljs-type">UInt</span></span> = #line)</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fatalError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message: @autoclosure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, file: <span class="hljs-type"><span class="hljs-type">StaticString</span></span> = #file, line: <span class="hljs-type"><span class="hljs-type">UInt</span></span> = #line) -&gt; <span class="hljs-type"><span class="hljs-type">Never</span></span></code> </pre> <br><p>  <strong>Qual das cinco funções de terminação devemos preferir?</strong> </p><br><h2 id="source-code-vs-documentation">  Código-fonte vs documentação </h2><br><p>  Vamos dar uma olhada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código fonte</a> .  Podemos ver o seguinte imediatamente: </p><br><ol><li>  Cada uma dessas cinco funções finaliza a execução do programa ou não faz nada. </li><li>  Possível encerramento ocorre de duas maneiras. <br><ul><li>  Com a impressão de uma mensagem de depuração conveniente chamando <code>_assertionFailure(_:_:file:line:flags:)</code> . </li><li>  Sem a mensagem de depuração, chamando <code>Builtin.condfail(error._value)</code> ou <code>Builtin.int_trap()</code> . </li></ul></li><li>  A diferença entre as cinco funções de terminação está nas condições sob as quais todas as opções acima acontecem. </li><li>  <code>fatalError(_:file:line)</code> chama <code>_assertionFailure(_:_:file:line:flags:)</code> incondicionalmente. </li><li>  As outras quatro funções finais avaliam as condições chamando as seguintes funções de avaliação da configuração.  (Eles começam com um sublinhado, o que significa que são internos e não devem ser chamados diretamente por um programador que usa a Swift Standard Library). <br><ul><li> <code>_isReleaseAssertConfiguration()</code> </li> <li> <code>_isDebugAssertConfiguration()</code> </li> <li> <code>_isFastAssertConfiguration()</code> </li> </ul></li></ol><br><p>  Agora vamos olhar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> .  Podemos ver o seguinte imediatamente. </p><br><ol><li>  <code>fatalError(_:file:line)</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imprime incondicionalmente uma determinada mensagem e interrompe a execução</a> . </li><li>  Os efeitos das outras quatro funções de terminação variam dependendo do sinalizador de compilação usado: <code>-Onone</code> , <code>-O</code> , <code>-Ounchecked</code> .  Por exemplo, consulte a documentação <code>preconditionFailure(_:file:line:)</code> . </li><li>  Podemos definir esses sinalizadores de compilação no Xcode através da <code>SWIFT_OPTIMIZATION_LEVEL</code> compilação do <code>SWIFT_OPTIMIZATION_LEVEL</code> . </li><li>  Também sabemos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do Xcode 10 que mais um sinalizador de otimização - <code>-Osize</code> - é introduzido. </li><li>  Portanto, temos os quatro sinalizadores de otimização a serem considerados. <br><ul><li>  <code>-Onone</code> (não otimize) </li><li>  <code>-O</code> (otimizar velocidade) </li><li>  <code>-Osize</code> (otimizar para tamanho) </li><li>  <code>-Ounchecked</code> (desative muitas verificações do compilador) </li></ul></li></ol><br><p>  Podemos concluir que a configuração avaliada nas quatro funções de terminação é definida por esses sinalizadores de construção. </p><br><h2 id="running-configuration-evaluation-functions">  Executando funções de avaliação de configuração </h2><br><p>  Embora as funções de avaliação de configuração sejam projetadas para uso interno, algumas delas são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">públicas para fins de teste</a> , e podemos testá-las através da CLI, fornecendo os seguintes comandos no Bash. </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'print(_isFastAssertConfiguration())'</span></span> &gt;conf.swift $ swift conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -Onone conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -O conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -Osize conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -Ounchecked conf.swift <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'print(_isDebugAssertConfiguration())'</span></span> &gt;conf.swift $ swift conf.swift <span class="hljs-literal"><span class="hljs-literal">true</span></span> $ swift -Onone conf.swift <span class="hljs-literal"><span class="hljs-literal">true</span></span> $ swift -O conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -Osize conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ swift -Ounchecked conf.swift <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Esses testes e a inspeção do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código fonte</a> nos levam às seguintes conclusões aproximadas. </p><br><p>  Existem três configurações mutuamente exclusivas. </p><br><ul><li>  <em>A</em> configuração da <em>liberação</em> é definida fornecendo um <code>-Osize</code> construção <code>-O</code> ou <code>-Osize</code> . </li><li>  <em>A</em> configuração de <em>depuração</em> é definida fornecendo um <code>-Onone</code> construção <code>-Onone</code> ou nenhum sinalizador de otimização. </li><li>  <code>_isFastAssertConfiguration()</code> é avaliado como <code>true</code> se um <code>-Ounchecked</code> construção <code>-Ounchecked</code> estiver definido.  Embora essa função tenha uma palavra "rápido" em seu nome, ela não tem nada a ver com a otimização do sinalizador de velocidade-O build. </li></ul><br><p>  <strong>Nota:</strong> essas conclusões não são a definição estrita de quando as compilações de <em>depuração</em> ou compilação ocorrem.  É uma questão mais complexa.  Mas essas conclusões estão corretas para o contexto de finalização do uso de funções. </p><br><h2 id="simplifying-the-picture">  Simplificando a imagem </h2><br><h3 id="-ounchecked"> <code>-Ounchecked</code> </h3> <br><p>  Não vamos ver para <strong>que <code>-Ounchecked</code> sinalizador <code>-Ounchecked</code></strong> (é irrelevante aqui), mas <strong>qual é o seu papel</strong> no contexto de finalização do uso de funções. </p><br><ul><li>  A documentação para a <code>precondition(_:_:file:line:)</code> - <code>precondition(_:_:file:line:)</code> e <code>assert(_:_:file:line:)</code> diz: "Nas compilações <code>-Ounchecked</code> , a condição não é avaliada, mas o otimizador pode assumir que sempre avalia como verdadeiro. Não atender a essa suposição é um erro de programação grave ". </li><li>  A documentação para <code>preconditionFailure(_:file:line)</code> e <code>assertionFailure(_:file:line:)</code> diz: "Nas compilações <code>-Ounchecked</code> , o otimizador pode assumir que essa função nunca é chamada. Falha em satisfazer essa suposição é um erro de programação grave. " </li><li>  Podemos ver no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código fonte</a> que a avaliação de <code>_isFastAssertConfiguration()</code> como <code>true</code> <strong>não deve ocorrer</strong> .  (Se isso acontecer, estranho <code>_conditionallyUnreachable()</code> é chamado. Consulte as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linhas 136 e</a> <code>_conditionallyUnreachable()</code> ) </li></ul><br><p>  Falando mais diretamente, você <strong>não deve permitir a acessibilidade</strong> das quatro funções de encerramento a seguir com o <code>-Ounchecked</code> build <code>-Ounchecked</code> definido para o seu programa. </p><br><ul><li> <code>precondition(_:_:file:line:)</code> </li> <li> <code>preconditionFailure(_:file:line)</code> </li> <li> <code>assert(_:_:file:line:)</code> </li> <li> <code>assertionFailure(_:file:line:)</code> </li> </ul><br><p>  Use apenas <code>fatalError(_:file:line)</code> ao aplicar <code>-Ounchecked</code> e ao mesmo tempo permitindo que o ponto do seu programa com a <code>fatalError(_:file:line)</code> possa ser alcançada. </p><br><h3 id="the-role-of-a-condition-check">  O papel de uma verificação de condição </h3><br><p>  Duas das funções de terminação permitem verificar condições.  A inspeção do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código-fonte</a> nos permite ver que, se a condição falhar, o comportamento da função é o mesmo que o de seu respectivo primo: </p><br><ul><li>  <code>precondition(_:_:file:line:)</code> se torna <code>preconditionFailure(_:file:line)</code> , </li><li>  <code>assert(_:_:file:line:)</code> torna-se <code>assertionFailure(_:file:line:)</code> . </li></ul><br><p>  Esse conhecimento facilita análises adicionais. </p><br><h3 id="release-vs-debug-configurations">  Configurações de versão versus depuração </h3><br><p>  Eventualmente, mais documentação e inspeção do código-fonte nos permitem formular a tabela a seguir. </p><br><p><img src="https://habrastorage.org/webt/x3/tq/vs/x3tqvsckgpqpyxso3flqfhyyddo.png" alt="Terminando funções"></p><br><p>  Agora está claro que a escolha mais importante para um programador é como deve ser o comportamento do programa <strong>no <em>lançamento,</em></strong> se uma verificação em tempo de execução revelar um erro. </p><br><p>  O principal argumento aqui é que <code>assert(_:_:file:line:)</code> e <code>assertionFailure(_:file:line:)</code> tornam o impacto da falha do programa menos grave.  Por exemplo, um aplicativo iOS pode ter corrompido a interface do usuário (desde que algumas verificações importantes de tempo de execução falharam), mas não falha. </p><br><p>  Mas esse cenário pode não ser o desejado.  Você tem uma escolha. </p><br><h2 id="never-return-type">  <code>Never</code> retornar tipo </h2><br><p>  <code>Never</code> é usado como um tipo de função de retorno que lança incondicionalmente um erro, interceptações ou não termina normalmente.  Na verdade, esses tipos de funções não retornam, <strong>nunca</strong> retornam. </p><br><p>  Entre as cinco funções de terminação, apenas <code>preconditionFailure(_:file:line)</code> e <code>fatalError(_:file:line)</code> retornam <code>Never</code> porque apenas essas duas funções interrompem incondicionalmente as execuções de programas e, portanto, nunca retornam. </p><br><p>  Aqui está um bom exemplo de como usar <code>Never</code> digite um aplicativo de linha de comando.  (Embora este exemplo não use as funções de encerramento da Swift Standard Library, mas a função C <code>exit()</code> padrão). </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printUsagePromptAndExit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Never</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: command directory"</span></span>) exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">CommandLine</span></span>.argc == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { printUsagePromptAndExit() } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Se <code>printUsagePromptAndExit()</code> retornar <code>Void</code> vez de <code>Never</code> , você receberá um erro de compilação com a mensagem " <em>o corpo do 'guard' não deve cair, considere usar um 'return' ou 'throw' para sair do escopo</em> ".  Ao usar <code>Never</code> você está dizendo antecipadamente que <strong>nunca</strong> sai do escopo e, portanto, o compilador não fornecerá um erro no momento da criação.  Caso contrário, você deve adicionar <code>return</code> no final do bloco do código de guarda, o que não parece agradável. </p><br><h2 id="takeaways">  Para viagem </h2><br><ul><li>  Não importa qual função de término usar se você tiver certeza de que todas as suas verificações de tempo de execução são relevantes apenas para a configuração de <em>Depuração</em> . </li><li>  Use apenas <code>fatalError(_:file:line)</code> ao aplicar <code>-Ounchecked</code> e ao mesmo tempo permitindo que o ponto do seu programa com a <code>fatalError(_:file:line)</code> possa ser alcançada. </li><li>  Use <code>assert(_:_:file:line:)</code> e <code>assertionFailure(_:file:line:)</code> se você estiver preocupado que as verificações de tempo de execução possam falhar de alguma forma no lançamento.  Pelo menos seu aplicativo não trava. </li><li>  Use <code>Never</code> para tornar seu código organizado. </li></ul><br><h2 id="useful-links">  Links úteis </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vídeo da WWDC "What's New in Swift",</a> que <code>SWIFT_OPTIMIZATION_LEVEL</code> sobre a configuração de compilação <code>SWIFT_OPTIMIZATION_LEVEL</code> (a partir de 11 minutos). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como nunca funciona internamente no Swift</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>NSHipster's article about nature of Never</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Discussão dos Fóruns Swift</a> sobre a sugestão de descontinuar <code>-Ounchecked</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440884/">https://habr.com/ru/post/pt440884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440872/index.html">PostGIS e JPA</a></li>
<li><a href="../pt440874/index.html">Implementando o movimento livre de partículas no ReactJS</a></li>
<li><a href="../pt440878/index.html">Análise da Web para empresas</a></li>
<li><a href="../pt440880/index.html">Os 10 principais sensores de IoT em 2019</a></li>
<li><a href="../pt440882/index.html">Fuja do Crypto Pro. Edição GOST 34.10-2012</a></li>
<li><a href="../pt440886/index.html">Exclusão suave na API REST</a></li>
<li><a href="../pt440888/index.html">Testes independentes do Baikal-T1 - o primeiro SoC russo de 28 nm - e do Conselho de Avaliação BFK 3.1</a></li>
<li><a href="../pt440890/index.html">Patriotismo em jogos de computador: a opinião de um ex-jogador</a></li>
<li><a href="../pt440892/index.html">A inesperada eficiência de sequências quase aleatórias</a></li>
<li><a href="../pt440894/index.html">Criando som para o Pathfinder: Kingmaker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>