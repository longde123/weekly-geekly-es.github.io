<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ´ ü§≥üèæ üë®üèª‚Äçüè≠ TrustZone: sistema operativo de confianza y sus aplicaciones üôé üì∏ ‚ù§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art√≠culos anteriores, analizamos el dispositivo de hardware TrustZone y el funcionamiento del mecanismo Secure Monitor. Hoy nos centraremos en el s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TrustZone: sistema operativo de confianza y sus aplicaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aladdinrd/blog/428311/">  En art√≠culos anteriores, analizamos el dispositivo de hardware TrustZone y el funcionamiento del mecanismo Secure Monitor.  Hoy nos centraremos en el sistema operativo de confianza (TEE) y sus aplicaciones.  Y si la √∫ltima vez hubo cosas de nivel bastante bajo, ahora todo estar√° en un nivel muy alto, en el nivel del sistema operativo. <a name="habracut"></a><br><br><h2>  ¬øQu√© es la ETE? </h2><br>  ¬øQu√© es la ETE?  Este es el entorno de ejecuci√≥n de confianza (Trusted Execution Environment), en primer lugar, este es el entorno de ejecuci√≥n de los programas.  Lo describimos en t√©rminos de funci√≥n y propiedades, pero no en el sentido de la programaci√≥n, sino en un sentido filos√≥fico. <br><br>  Por ejemplo, un tren de larga distancia, un tren y un taxi tienen una de las funciones m√°s importantes: transportar personas.  Pero seg√∫n sus propiedades, difieren, por ejemplo: un tren lleva entre ciudades, un tren el√©ctrico, fuera de la ciudad, y un taxi, principalmente en la ciudad.  Tren y tren para boletos, taxi - no.  Y as√≠ sucesivamente. <br><br>  La funci√≥n TEE es almacenar de forma segura algunos datos para nosotros y lanzar aplicaciones para nosotros.  Queremos transmitir comandos TEE: iniciar tal o cual aplicaci√≥n, tomar tal y tal informaci√≥n y hacer esto y aquello con ellos.  Al mismo tiempo, no podemos ver el c√≥digo de la aplicaci√≥n ni los datos.  Solo obtendremos el resultado.  La interacci√≥n con TEE es muy similar a RPC. <br><br>  Esta funci√≥n es ideal para varias criptograf√≠as, por ejemplo, para la firma electr√≥nica: las claves se almacenan en TEE, y le pedimos a TEE que firme los datos transmitidos con una clave almacenada en TEE.  Obtenemos el resultado, pero no tenemos acceso a la clave. <br><br>  TEE tiene una serie de propiedades, pero las principales son: a) confiamos en su implementaci√≥n, yb) est√° separado de manera confiable del sistema operativo principal del dispositivo, protegido, es dif√≠cil de romper o romper.  Hay otras propiedades, pero lo llamamos un sistema operativo confiable para eso.  Propiedad b) lo m√°s importante es que TEE est√° separado y es dif√≠cil de romper, es decir, est√° protegido. <br><br>  Si observa TEE a trav√©s del prisma de funciones y propiedades, queda claro que TEE ni siquiera se trata de TrustZone.  TrustZone es una de las formas de separar TEE del sistema operativo principal (invitado). <br><br><h2>  Opciones de implementaci√≥n de TEE </h2><br>  Si las principales propiedades de TEE son que es independiente y dif√≠cil de romper, entonces podemos encontrar diferentes opciones para implementar TEE: <br><br><ul><li>  Use TrustZone: obtenemos la separaci√≥n de TEE y el sistema operativo principal dentro del mismo n√∫cleo del procesador. </li><li>  Ejecute TEE en un n√∫cleo separado dentro del sistema en un chip y comun√≠quese con √©l a trav√©s de una interfaz de hardware.  Algunos procesadores especializados tienen n√∫cleos de confianza separados para ejecutar TEE, pero, por desgracia, no puede comprarlos en la tienda.  Pero puede tomar un cristal de doble n√∫cleo, por ejemplo, Cortex-A + Cortex-M0 / M4 y ejecutarlo en Cortex-M TEE. </li><li>  Ejecute TEE en un chip separado y establezca una conexi√≥n segura con √©l a trav√©s de una interfaz externa, por ejemplo, SPI o SMbus.  Para proteger la comunicaci√≥n, use m√©todos criptogr√°ficos. <br>  Este m√©todo se utiliza cuando establece una conexi√≥n con una tarjeta inteligente, como una tarjeta de pago de pl√°stico chip-on-chip.  En cierto sentido, TEE se ejecuta en el chip, porque a petici√≥n nuestra, realiza transacciones financieras con confianza, almacena datos, etc. <br>  El mismo m√©todo se utiliza en TPM (Trusted Platform Module) de la arquitectura moderna de PC. </li></ul><br>  Solo hablaremos sobre la implementaci√≥n de TEE en TrustZone, porque esta es una versi√≥n muy com√∫n de la implementaci√≥n de TEE.  Pero gran parte de lo anterior se aplicar√° a TEE en general. <br><br><h2>  TEE como OS </h2><br>  En art√≠culos anteriores, siempre llamamos a TEE un sistema operativo confiable y decimos que es muy parecido a los sistemas operativos reales. <br><br>  Sin pretender ser general, decimos que la mayor parte de TEE tiene: <br><ul><li>  aplicaciones y procesos: TEE puede descargar aplicaciones y ejecutarlas; </li><li> separaci√≥n del proceso y la memoria del n√∫cleo: utilizada por la MMU para proteger el espacio de la memoria del proceso y para proteger la memoria central del TEE; </li><li>  hilos, interacciones de proceso; </li><li>  almacenamiento de datos </li></ul><br>  Puede crear versiones m√°s truncadas de TEE, por ejemplo, sin carga din√°mica de aplicaciones, sin interacci√≥n de procesos, sin hilos, pero las aplicaciones mismas, el almacenamiento de datos y la separaci√≥n de la memoria de procesos y el espacio del kernel permanecer√°n. <div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text">  Un ejemplo de un TEE truncado se puede ver ahora en el proyecto ARM Trusted Firmware-M para la nueva generaci√≥n de microcontroladores Cortex-M en la plataforma ARMv8-M.  Este es un TEE simplificado, ahora hay soporte para microcontroladores en los n√∫cleos Cortex-M23 y Cortex-M33.  Estos son microcontroladores basados ‚Äã‚Äãen flash, aproximadamente equivalentes a Cortex-M0 y Cortex-M3, pero con soporte de TrustZone.  Tienen poca RAM, el programa se ejecuta principalmente desde Flash y, por lo tanto, en TEE no hay carga din√°mica de programas.  Por el momento, TF-M tambi√©n tiene un solo subproceso. <br></div></div><br><h2>  Interfaz de software TEE </h2><br>  Para interactuar con otros componentes de software, TEE tiene una API: <br><br><ul><li>  TEE proporciona una API para programas a trav√©s de llamadas al sistema (Supervisor Call, comando SVC); </li><li>  TEE proporciona la API para Mundo Normal a trav√©s de llamadas a Secure Monitor (comando SMC). </li></ul><br>  A trav√©s de las llamadas al sistema, los programas guardan datos y llaman a las funciones del sistema operativo.  Al igual que cualquier sistema operativo decente, TEE intenta abstraer programas del hardware en un grado u otro. <br>  Por ejemplo, los res√∫menes de Linux funcionan con archivos a trav√©s de llamadas abiertas, de lectura, de escritura, cerradas: todas las funciones est√°ndar b√°sicamente se incluyen en las llamadas del sistema operativo.  Y TEE tambi√©n permite que sus aplicaciones trabajen con datos almacenados a trav√©s de llamadas que almacenan y cargan objetos (bloques de datos) de forma abstracta en el almacenamiento.  TEE tambi√©n puede proporcionar algunas funciones criptogr√°ficas a nivel del sistema, etc. <br><br>  Existe un conjunto de especificaciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GlobalPlatform</a> para TEE, que describen API, requisitos, escenarios de uso, etc. <br>  Las API principales de TEE para sus programas se describen en la Especificaci√≥n interna de la API interna de TEE.  Describe funciones de almacenamiento de datos, funciones criptogr√°ficas, etc. Y la "API de cliente TEE" describe c√≥mo llamar a aplicaciones desde Normal World. <br><br>  Si su TEE implementa estas API, escribir una aplicaci√≥n para √©l ser√° bastante f√°cil.  Gracias a una API, tambi√©n se implementa la portabilidad de los programas. <br><br><h2>  Diferencias entre TEE y SO normal </h2><br>  Las dos diferencias principales entre TEE y Linux y otros sistemas operativos comunes que nos son familiares son: <br><br><ol><li>  TEE realiza acciones no en el comando del usuario, sino en el comando del Mundo Normal; </li><li>  TEE en TrustZone no tiene su propio planificador. </li></ol><br>  En un sistema operativo normal, el usuario genera alguna entrada: ingresa comandos, hace clic en los iconos y el sistema operativo procesa esta entrada, la transfiere a los programas y los programas la procesan.  En la versi√≥n del servidor, la entrada no proviene del usuario, sino de ciertos clientes, probablemente a trav√©s de la red.  Pero el sistema operativo, sin embargo, act√∫a sobre la base de una entrada externa. <br><br>  TEE no procesa datos externos ni los transfiere a aplicaciones.  En cambio, procesa los comandos y los datos transmitidos desde Normal World a trav√©s de la API del cliente TEE, y eso es casi todo.  Resulta que TEE act√∫a para el sistema operativo como una biblioteca con una interfaz RPC, cuyas funciones se llaman.  Despu√©s de procesar las funciones, TEE no puede hacer nada. <br><br>  La segunda diferencia se sigue de la primera.  El TEE del administrador comparte el tiempo de CPU con Normal World y se llama como una biblioteca.  TEE no asigna constantemente el tiempo del procesador por s√≠ mismo, dedica todo el tiempo que sea necesario para completar la solicitud y luego transfiere el control al Mundo Normal.  Y si es as√≠, entonces no deber√≠a tener su propio programador, necesita un programador invitado del sistema operativo. <br><br>  El programador principal del sistema operativo transfiere el control a TEE indirectamente: <br><br><ul><li>  el planificador establece la tarea que se completar√°; </li><li>  la tarea llama a la llamada del sistema kernel; </li><li>  una llamada al sistema llama a TEE, si es necesario; </li><li>  TEE funciona todo el tiempo que sea necesario para completar la solicitud y devuelve el control a Mundo Normal. </li></ul><br><h2>  Aplicaciones TEE </h2><br>  Las aplicaciones que se ejecutan en TEE se denominan trustlets, similares a los applets que se ejecutan en tarjetas inteligentes. <br>  Cita de Wikipedia: <br><blockquote>  Applet (Eng. Applet de la aplicaci√≥n - aplicaci√≥n y -let - sufijo diminutivo) es un componente de software no aut√≥nomo que funciona en el contexto de otra aplicaci√≥n ponderada, dise√±ada para una tarea estrecha y que no tiene un valor aislado de la aplicaci√≥n base. </blockquote><br>  Trustlet es un applet de confianza.  Este es un programa para TEE, como ya hemos descubierto, se comunica con TEE a trav√©s de llamadas al sistema, tiene un ciclo de vida, etc. <br><br>  Pero a√∫n as√≠, el nombre indica que es un componente no aut√≥nomo.  Aqu√≠, la independencia se expresa en el hecho de que el trustlet har√° llamadas desde Mundo Normal y luego se desconectar√° junto con TEE.  Si gira en un bucle infinito, el n√∫cleo del procesador dejar√° de funcionar como un sistema operativo y todo se bloquear√° eventualmente.  Pero el programa para un sistema operativo normal puede girar en un bucle sin fin y el m√≠o para contar algunas tareas, esto es completamente normal para el programa.  En este sentido, es independiente del trustlet. <br><br>  El trustlet debe tener alg√∫n tipo de identificador para que Normal World pueda llamarlo.  Es habitual dar los trustlets como UUID, identificadores √∫nicos. <br><br><h2>  Ciclo de vida de Trustlet </h2><br>  Considere c√≥mo se inicia el trastlet y se ejecutan los comandos. <br><br>  Ser√≠a l√≥gico cargar el trustlet en la memoria y comenzar a trabajar, pero en la API de cliente de GlobalPlatform TEE, para iniciar el trustlet, debe crear un contexto y establecer una sesi√≥n con el trustlet. <br><br>  Crear un contexto es el establecimiento de una conexi√≥n entre Normal World y TEE.  En este caso, la especificaci√≥n GlobalPlatform supone que el dispositivo puede tener varios TEE y, al momento de crear el contexto, puede elegir con qu√© TEE contactar. <br><br>  En la API de cliente de GlobalPlatform TEE, se proporciona una funci√≥n para esto: <br><br><pre> TEEC_Result TEEC_InitializeContext (const char * name, TEEC_Context * context)
</pre><br>  Esta funci√≥n se llama desde la aplicaci√≥n Mundo Normal.  Aqu√≠ el nombre indica el TEE seleccionable.  Si queremos TEE por defecto o estamos seguros de que solo tenemos un TEE, sustituimos NULL.  En contexto, el contexto creado se guarda. <br><br>  Despu√©s de crear el contexto, debe establecer una sesi√≥n con la confianza.  Aqu√≠ el UUID del trustlet es √∫til para nosotros.  Para hacer esto, la funci√≥n se llama: <br><br><pre> TEEC_Result TEEC_OpenSession (
	 TEEC_Context * context, TEEC_Session * session,
	 const TEEC_UUID * destino, uint32_t connectionMethod,
	 const void * connectionData, operaci√≥n TEEC_Operation *,
	 uint32_t * returnOrigin)
</pre><br>  Una sesi√≥n es equivalente a trabajar con una instancia de programa en un sistema operativo normal: puede haber muchas instancias del mismo programa en el sistema operativo y funcionar√°n de forma independiente.  Pero hay muchas sesiones en TEE, y en esencia, estas son conexiones a instancias √∫nicas del trustlet en la memoria.  En este caso, el √°rea de c√≥digo probablemente ser√° la misma, asignada a trav√©s de MMU a la memoria de diferentes procesos.  Pero cada proceso tendr√° su propia √°rea de datos, permitiendo que las instancias trabajen independientemente.  Al igual que en Linux. <br><br>  Cuando se llama a TEEC_OpenSession, el contexto y el UUID de la confianza de destino se transmiten como entrada.  La sesi√≥n establecida se guardar√° en "sesi√≥n".  Algunos par√°metros de aqu√≠ en adelante no los consideraremos, no son tan importantes para su comprensi√≥n. <br><br>  En el momento en que se crea la sesi√≥n, el trustlet se puede cargar en la memoria.  Esto es lo que sucede con las aplicaciones en el sistema operativo.  En TEE grande, el enlazador es responsable de esto, descarga la imagen binaria del trustlet, este es un archivo ELF firmado.  Si se trata de un TEE peque√±o, el trustlet ya deber√≠a estar cargado en la memoria; puede estar vinculado est√°ticamente o, para microcontroladores flash, escrito en la memoria flash en la direcci√≥n especificada. <br><br>  Supongamos que tenemos un TEE grande y necesitamos cargar el trustlet en la memoria.  ¬øDe donde viene?  En principio, la TEE en el momento de la carga necesita un objeto con un determinado UUID, y el mecanismo para obtener este objeto puede ser cualquiera: <br><br><ul><li>  el objeto ya puede estar en la memoria; </li><li>  el objeto puede colocarse est√°ticamente en la memoria flash (para microcontroladores flash); </li><li>  el objeto se puede vincular est√°ticamente con TEE, para los trustlets del sistema; </li><li>  finalmente, puede descargar el archivo a la RAM desde el sistema de archivos, o incluso a trav√©s de la red. </li></ul><br>  Preg√∫ntese m√°s tarde, ¬øc√≥mo descarga este TEE datos de un sistema de archivos o de una red? <br><br>  Despu√©s de descargar la imagen del trustlet, se verifica su firma digital.  Se utiliza un sistema de certificado y TEE verificar√° que la confianza est√© firmada por una parte en la que TEE conf√≠a.  Esto es muy importante porque elimina la posibilidad de descargar un trustlet falso con alg√∫n malware. <br><br>  Cuando se recibe la imagen del trustlet y se verifica la firma, TEE crea el espacio de direcciones para la instancia de trustlet en la MMU, y el vinculador carga el √°rea de c√≥digo en la memoria, la asigna al espacio de direcciones del trustlet e inicializa el √°rea de datos.  El resultado es una instancia completamente inicializada del trustlet para trabajar con la aplicaci√≥n de llamada espec√≠fica: esta es la creaci√≥n de la sesi√≥n. <br><br>  Despu√©s de crear la sesi√≥n, el trustlet est√° en plena preparaci√≥n y puede ejecutar solicitudes desde la aplicaci√≥n que realiza la llamada.  Para llamar a las funciones de confianza desde el sistema operativo, se utiliza la funci√≥n: <br><br><pre> TEEC_Result TEEC_InvokeCommand (
	 Sesi√≥n de TEEC_Session *,
	 uint32_t commandID,
	 Operaci√≥n TEEC_Operation *,
	 uint32_t * returnOrigin) 
</pre><br>  Aqu√≠, "sesi√≥n" indica nuestra sesi√≥n, es decir, la instancia de TEE y la instancia de trustlet con la que estamos trabajando. <br><br>  "CommandID" indica la funci√≥n llamada del trustlet.  Esta es la funci√≥n trustlet, no la funci√≥n TEE.  Todo lo que le importa a TEE es iniciar el trustlet y enviar comandos, y qu√© n√∫meros de ID de comando asignar para comunicarse con el trustlet depende de usted, no existe una regla o una lista global de funciones. <br><br>  Si necesita pasar par√°metros a la funci√≥n llamada, se pasan a trav√©s de la operaci√≥n; este es un puntero a la estructura TEEC_Operation.  No entraremos en demasiada profundidad ahora, solo observe que esta estructura contiene hasta 4 par√°metros de funci√≥n (tipo TEEC_Parameter).  Los par√°metros pueden ser un simple TEEC_Value o un puntero a la memoria.  Los par√°metros tambi√©n tienen tipificaci√≥n en la direcci√≥n: TEEC_VALUE_INPUT (entrada), TEEC_VALUE_OUTPUT (salida) o TEEC_VALUE_INOUT (bidireccional). <br><br>  Si pasamos un puntero a la estructura TEEC_Operation, primero debemos inicializarlo: establecer todos los valores y direcciones.  Al finalizar la llamada, podemos verificar los valores devueltos en esta estructura (para TEEC_VALUE_OUTPUT y TEEC_VALUE_INOUT). <br><br>  Durante la sesi√≥n, podemos llamar a las funciones de confianza tantas veces como sea necesario.  Al final del trabajo, deber√° finalizar la sesi√≥n y liberar el contexto llamando a TEEC_CloseSession y TEEC_FinalizeContext. <br><br>  Todo esto recuerda mucho a RPC, ¬øverdad?  En principio, todas las operaciones con TEE est√°n dise√±adas como RPC, y gracias a esto, puede trabajar con una variedad de implementaciones de TEE: en TrustZone, en un n√∫cleo separado, en un chip separado. <br><br><h2>  Suplicante </h2><br>  Arriba, nos preguntamos: ¬øc√≥mo descarga TEE datos de un sistema de archivos o de una red? <br>  Si lo piensa, TEE en s√≠ no tiene acceso al sistema de archivos del sistema operativo.  Es decir, TEE implementado en TrustZone podr√≠a tener dicho acceso, pero luego tendr√≠a que compartirlo con Normal World, y esto no es tan simple.  Por ejemplo, Linux trabaja constantemente con el sistema de archivos, y su estado actual solo est√° en la memoria del kernel de Linux y no en el disco.  Si TEE quiere intervenir y trabajar con el sistema de archivos en paralelo, ser√° muy dif√≠cil.  Con la red compartiendo lo mismo. <br><br>  Adem√°s, TEE es un sistema operativo bastante peque√±o, y no ser√≠a rentable implementar controladores de bajo nivel para trabajar con medios, con un controlador de red y admitir una pila de red o un controlador FS.  Adem√°s, esto aumenta enormemente la superficie de ataque: habr√≠a una posibilidad de romper TEE al deslizar un inodo inusual en ext2 o algo as√≠.  No queremos eso. <br>  Por lo tanto, cuando se inicia el sistema operativo, se carga el llamado Suplicante, un programa asistente.  Siempre est√° conectado a TEE, y TEE lo usa para acceder a los recursos del Mundo Normal. <br><br>  Por lo tanto, si TEE desea descargar la imagen del trustlet del sistema de archivos, llama al Solicitante: <br><br>  <i>TEE: ¬øQu√© pasa con un objeto con tal UUID?</i> <i><br></i>  <i>Solicitante: (Carga un objeto del sistema de archivos) ¬°Lo siento, se√±or!</i> <br><br>  Por supuesto, tales llamadas deben verificarse por seguridad.  En este caso, verificamos la firma en el trustlet y casi no nos arriesgamos: la firma es correcta y el trustlet funciona o la firma es incorrecta.  Es decir, lo arriesgamos: puede que no haya un trustlet, es posible que no se lance Supplicant, pero esta es otra parte del modelo de amenaza. <br><br><h2>  Biblioteca de espacio de usuario </h2><br>  La interfaz del programa (llamadas a TEEC_OpenSession, etc.) se implementa utilizando una biblioteca que transmite una llamada desde el nivel de aplicaci√≥n a TEE. <br><br>  Al implementar TEE en TrustZone, para esto, la biblioteca primero debe transferir la llamada al nivel del kernel del SO, ya que solo el kernel del SO puede llamar a SMC (Secure Monitor Call). <br>  En el paquete Linux + OP-TEE, la biblioteca del espacio de usuario es libteec.  Traduce las llamadas de la API del cliente GlobalPlatform TEE al controlador del n√∫cleo a trav√©s de operaciones ioctl en el archivo del dispositivo: cuando se inicia el sistema operativo, se carga el m√≥dulo del n√∫cleo (controlador), el controlador crea el archivo del dispositivo.  Al abrir el archivo del dispositivo con libteec, el programa de usuario puede trabajar con la API del cliente TEE. <br><br>  Es decir, este dise√±o funciona: <br><blockquote>  <b>Aplicaci√≥n&gt; libteec&gt; archivo de dispositivo&gt; controlador de kernel&gt; SMC&gt; TEE&gt; confianza.</b> </blockquote><br><h2>  Un ejemplo de un trustlet </h2><br>  As√≠ es como funciona en una aplicaci√≥n real: <br><img src="https://habrastorage.org/webt/td/yg/s6/tdygs6hnze62ralshuabjivepr4.png" alt="imagen"><br>  Aqu√≠, el trustlet se utiliza para firmar documentos electr√≥nicamente.  Un programa de Linux llama al trustlet, para lo cual se crea un contexto TEE, una sesi√≥n con el trustlet, se transmiten los datos para la firma y se devuelve la firma electr√≥nica. <br><br><h2>  Conclusi√≥n </h2><br>  En este art√≠culo, descubrimos qu√© son TEE y trustlets.  Nos reunimos con la API TEE y aprendimos c√≥mo se llaman los trustlets. <br><br>  Deliberadamente dejamos de lado muchas cosas, como el uso de la memoria compartida y la escritura de trastlets, porque el art√≠culo no pretende ser una gu√≠a exhaustiva. <br><br>  Si est√° interesado en el tema de TEE, contin√∫e estudiando por su cuenta: puede comenzar estudiando las especificaciones de GlobalPlatform o explorando OP-TEE.  Tambi√©n puede enviarnos un curr√≠culum marcado como "TrustZone". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428311/">https://habr.com/ru/post/es428311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428299/index.html">Mensajeros vs redes sociales vs ... - Continuaci√≥n</a></li>
<li><a href="../es428301/index.html">Kaspersky Start Russia: concurso de proyectos del futuro</a></li>
<li><a href="../es428303/index.html">Un d√≠a en la vida de un ingeniero de sistemas.</a></li>
<li><a href="../es428305/index.html">Estudias ingles Comics al rescate</a></li>
<li><a href="../es428307/index.html">Java Challengers # 1: sobrecarga de m√©todos en la JVM</a></li>
<li><a href="../es428313/index.html">Telegram en MacOS [presumiblemente] tambi√©n almacena localmente la correspondencia en una forma accesible</a></li>
<li><a href="../es428315/index.html">5 temores de desarrolladores que hemos superado</a></li>
<li><a href="../es428317/index.html">Reaccionar ganchos: ¬øganar o perder?</a></li>
<li><a href="../es428321/index.html">An√°lisis predictivo de datos: modelado y validaci√≥n</a></li>
<li><a href="../es428327/index.html">A qu√© mirar: Reglamento Europeo de Identificaci√≥n Electr√≥nica eIDAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>