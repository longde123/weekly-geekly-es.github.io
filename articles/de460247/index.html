<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêç üëÉüèª üåà Rezepte f√ºr ELFs üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üßòüèª ü¶Ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf Russisch gibt es nicht gen√ºgend Informationen zum Arbeiten mit ELF-Dateien (ausf√ºhrbares und verkn√ºpfbares Format - das Hauptformat f√ºr ausf√ºhrbar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rezepte f√ºr ELFs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/460247/"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="Bild"></p><br><p>  Auf Russisch gibt es nicht gen√ºgend Informationen zum Arbeiten mit ELF-Dateien (ausf√ºhrbares und verkn√ºpfbares Format - das Hauptformat f√ºr ausf√ºhrbare Dateien von Linux und vielen Unix-Systemen).  Wir behaupten nicht, alle m√∂glichen Szenarien der Arbeit mit Elfen vollst√§ndig abzudecken, hoffen jedoch, dass die Informationen in Form eines Nachschlagewerks und einer Sammlung von Rezepten f√ºr Programmierer und Reverse Engineers n√ºtzlich sein werden. </p><br><p>  Es versteht sich, dass der Leser auf einer grundlegenden Ebene mit dem ELF-Format vertraut ist (andernfalls empfehlen wir die Artikelserie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Executable and Linkable Format 101</a> ). </p><br><p>  Unter dem Schnitt werden die Werkzeuge f√ºr die Arbeit aufgelistet, beschriebene Techniken zum Lesen von Metainformationen, Modifizieren, Verifizieren und <del>  Zucht </del>  Erstellen von Elfen sowie Links zu n√ºtzlichen Materialien. </p><a name="habracut"></a><br><blockquote>  ‚ÄûIch bin auch ein Elf ... Blau in Rot ... Elfen sind sehr geduldig ... Blau in Rot ... Und wir sind Elfen! ... Blau in Rot ... Es gibt nur Probleme durch Magie ... <br>  (c) Das kleine K√∂nigreich von Ben und Holly </blockquote><br><h1 id="instrumenty">  Die Werkzeuge </h1><br><p>  In den meisten F√§llen k√∂nnen die Beispiele sowohl unter Linux als auch unter Windows ausgef√ºhrt werden. </p><br><p>  In Rezepten verwenden wir die folgenden Werkzeuge: </p><br><ul><li>  Dienstprogramme aus dem Binutils-Set (objcopy, objdump, readelf, strip); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">radare2 Framework</a> ; </li><li>  Hex-Editor mit Unterst√ºtzung f√ºr Dateivorlagen (Beispiele zeigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">010Editor</a> , Sie k√∂nnen jedoch beispielsweise kostenlose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veles verwenden</a> ); </li><li>  Python und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LIEF-</a> Bibliothek; </li><li>  andere Dienstprogramme (Links sind im Rezept enthalten). </li></ul><br><h1 id="testovye-elfy">  Testelfen </h1><br><p>  Als "Experiment" werden wir die <em>einfache</em> ELF-Datei aus der PieIsMyFav <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Aufgabe</a> von nutcake auf crackmes.one verwenden, aber jeder Vertreter der "Elven" -Familie wird dies tun.  Wenn die fertige Datei mit den erforderlichen Merkmalen nicht gemeinfrei gefunden wurde, wird eine Methode zum Erstellen eines solchen Elfen angegeben. </p><br><p>  Freie Elfen finden Sie auch unter den folgenden Links: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele f√ºr Elfen f√ºr verschiedene Plattformen</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testelfen auf radare2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ElfHacks-Projekt auf Github</a> - eine Auswahl kleiner Elfen mit unterschiedlichen Einstellungen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crackme f√ºr Unix / Linux</a> - aber denken Sie daran, dass hier knifflige Beispiele auftreten k√∂nnen. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Lesen, Informationen bekommen </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  Dateityp, Titel, Abschnitt </h2><br><p>  Abh√§ngig von der Aufgabe kann Folgendes von Interesse sein: </p><br><ul><li>  Dateityp (DYN - Bibliothek, EXEC - ausf√ºhrbare Datei, RELOC - verkn√ºpfbar); </li><li>  Zielarchitektur (E_MACHINE - x86_64, x86, ARM usw.); </li><li>  Anwendungseinstiegspunkt (Einstiegspunkt); </li><li>  Abschnittsinformationen. </li></ul><br><h3 id="010editor">  010Editor </h3><br><p> HEX Editor 010Editor bietet ein Vorlagensystem.  Bei ELF-Dateien hei√üt die Vorlage seltsamerweise <em>ELF.bt</em> und befindet sich in der Kategorie <em>Ausf√ºhrbare</em> <em>Datei</em> (Men√º Vorlagen - Ausf√ºhrbare <em>Datei</em> ). <br>  Von Interesse kann beispielsweise der Einstiegspunkt in die ausf√ºhrbare Datei (Einstiegspunkt) sein (im Dateikopf aufgezeichnet). </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="Bild"></p><br><h3 id="readelf">  lesen Sie sich </h3><br><p>  Das Readelf-Dienstprogramm kann als De-facto-Standard zum Abrufen von Informationen zu einer ELF-Datei angesehen werden. </p><br><ul><li>  Lesen Sie den Dateikopf: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Lesen Sie Informationen zu Segmenten und Abschnitten: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><p>  Zur besseren Lesbarkeit werden Adressen in das 32-Bit-Format konvertiert: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Informationen zum Abschnitt lesen: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><p>  Zur besseren Lesbarkeit werden Adressen in das 32-Bit-Format konvertiert: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Symbolinformationen lesen: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><p>  Die Ausgabe wird zur besseren Lesbarkeit gek√ºrzt: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  Die Option <code>-W</code> wird ben√∂tigt, um die Breite der Konsolenausgabe zu erh√∂hen (Standard 80 Zeichen). </p><br><h3 id="lief">  Lief </h3><br><p>  Sie k√∂nnen die Header- und Abschnittsinformationen mit Python-Code und der LIEF-Bibliothek lesen (bietet eine API nicht nur f√ºr Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Compiler-Informationen </h2><br><p>  Informationen zum Compiler und Build finden Sie in den <code>.note</code> <code>.comment</code> und <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  lesen Sie sich </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  Ich werde dich berechnen mit ... RPATH </h2><br><p>  Elfen k√∂nnen Pfade speichern, um dynamisch verbundene Bibliotheken zu finden.  Um die Systemvariable <code>LD_LIBRARY_PATH</code> vor dem Starten der Anwendung nicht <code>LD_LIBRARY_PATH</code> , k√∂nnen Sie diesen Pfad einfach in die ELF-Datei ‚Äûeinbetten‚Äú. </p><br><p>  Verwenden Sie dazu den Eintrag im Abschnitt <code>.dynamic</code> vom Typ <code>DT_RPATH</code> oder <code>DT_RUNPATH</code> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel Verzeichnisse, die vom Runtime Linker</a> <code>DT_RUNPATH</code> in der Dokumentation). </p><br><p>  <strong>Und seien Sie vorsichtig, junger Entwickler, schlafen Sie Ihr Projektverzeichnis nicht!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  Wie erscheint RPATH? </h3><br><p>  Der Hauptgrund f√ºr das Erscheinen eines RPATH-Datensatzes in einem Elfen ist die Option linker <code>-rpath</code> , um nach einer dynamischen Bibliothek zu suchen.  Ungef√§hr so: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Ein solcher Befehl erstellt einen RPATH-Datensatz im Abschnitt <code>.dynamic</code> mit dem Wert <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  lesen Sie sich </h3><br><p>  Sie k√∂nnen Elemente aus dem Abschnitt <code>.dynamic</code> (unter denen sich RPATH befindet) wie folgt anzeigen: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Teamergebnis</b> <div class="spoiler_text"><p>  Zur Vereinfachung des Lesens wird das Ergebnis des Befehls gek√ºrzt: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  Lief </h3><br><p>  Mit der LIEF-Bibliothek k√∂nnen Sie auch den RPATH-Datensatz im Elfen lesen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie mehr √ºber den Abschnitt .dynamic</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Elf auf Sicherheit pr√ºfen </h2><br><p>  Das Sicherheits√ºberpr√ºfungsskript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">checksec.sh</a> des Forschers Tobias Klein (Autor von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A Bug Hunter's Diary</a> ) wurde seit 2011 nicht aktualisiert.  Dieses ELF-Dateiskript pr√ºft die Verf√ºgbarkeit der Optionen RelRO (schreibgesch√ºtzte Verschiebungen), NX (nicht ausf√ºhrbarer Stapel), Stapelkanarien, PIE (positionunabh√§ngige ausf√ºhrbare Dateien) und verwendet das Dienstprogramm readelf f√ºr seine Arbeit. </p><br><h3 id="lief-3">  Lief </h3><br><p>  Sie k√∂nnen Ihr eigenes Analogon erstellen <del>  Knie </del>  Python und LIEF (etwas k√ºrzer als der Vorl√§ufer und mit zus√§tzlicher √úberpr√ºfung der Option f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Code</a> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h3 id="radare2">  Radare2 </h3><br><p>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dukebarman</a> f√ºr die zus√§tzliche Verwendung von Radare2 zur Anzeige von Informationen √§hnlich wie bei <em>checksec</em> : </p><br><pre> <code class="bash hljs">&gt; r2 -ci~pic,canary,nx,crypto,stripped,static,relocs test_stack_proteck</code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  Rohcode von Elf (bin√§r von ELF) </h2><br><p>  Es gibt Situationen, in denen ‚ÄûElfenkleidung‚Äú in Form einer ELF-Struktur nicht ben√∂tigt wird, sondern nur der ‚Äûnackte‚Äú ausf√ºhrbare Anwendungscode. </p><br><h3 id="objcopy">  Objekt </h3><br><p>  Die Verwendung von <em>objcopy ist</em> wahrscheinlich denjenigen bekannt, die Firmware schreiben: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - um Zeicheninformationen zu l√∂schen; </li><li>  <code>-g</code> - um Debugging-Informationen zu entfernen. </li></ul><br><h3 id="lief-4">  Lief </h3><br><p>  Keine Magie.  Nehmen Sie einfach den Inhalt der geladenen Abschnitte und erstellen Sie daraus ein Binar: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Verst√ºmmelte - entwirrte Funktionsnamen </h2><br><p>  In ELFs, die aus C ++ - Code erstellt wurden, werden Funktionsnamen dekoriert (entstellt), um die Suche nach der entsprechenden Klassenfunktion zu vereinfachen.  Das Lesen solcher Namen in der Analyse ist jedoch nicht sehr bequem. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testelfe</a> </p><br><h3 id="nm">  nm </h3><br><p>  Um Namen in lesbarer Form darzustellen, k√∂nnen Sie das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nm</a> aus dem binutils-Set verwenden: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-5">  Lief </h3><br><p>  Anzeigen von Symbolnamen in demangulierter Form mithilfe der LIEF-Bibliothek: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Montage, Aufnahme, Modifikation des Elfen </h1><br><h2 id="elf-bez-metainformacii">  Elf ohne Metainformationen </h2><br><p>  Nachdem die Anwendung debuggt und in der wilden Welt ver√∂ffentlicht wurde, ist es sinnvoll, die Metainformationen zu entfernen: </p><br><ul><li>  Debug-Abschnitte - in den meisten F√§llen nutzlos; </li><li>  Namen von Variablen und Funktionen - haben f√ºr den Endbenutzer keinerlei Auswirkungen (erschwert das Gegenteil geringf√ºgig); </li><li>  Abschnittstabelle - wird zum Ausf√ºhren der Anwendung absolut nicht ben√∂tigt (das Fehlen erschwert das Gegenteil geringf√ºgig). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Zeicheninformationen l√∂schen </h2><br><p>  Zeicheninformationen sind die Namen von Objekten und Funktionen.  Ohne sie ist die Umkehrung der Anwendung etwas komplizierter. </p><br><h3 id="strip">  Streifen </h3><br><p>  Im einfachsten Fall k√∂nnen Sie das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strip</a> aus dem Binutils-Set verwenden.  Um alle Zeicheninformationen zu l√∂schen, f√ºhren Sie einfach den folgenden Befehl aus: </p><br><ul><li>  f√ºr ausf√ºhrbare Datei: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  f√ºr dynamische Bibliothek: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  sstrip </h3><br><p>  Um Zeicheninformationen (einschlie√ülich unn√∂tiger Null-Bytes am Ende der Datei) sorgf√§ltig zu entfernen, k√∂nnen Sie das Dienstprogramm sstrip aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ELFkickers-Suite verwenden</a> .  Um alle Zeicheninformationen zu l√∂schen, f√ºhren Sie einfach den folgenden Befehl aus: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-6">  Lief </h3><br><p>  Mit der LIEF-Bibliothek k√∂nnen Sie auch einen kurzen Streifen <code>.symtab</code> (die Symboltabelle wird gel√∂scht - Abschnitt <code>.symtab</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Partitionstabelle l√∂schen </h2><br><p>  Wie oben erw√§hnt, hat das Vorhandensein / Fehlen einer Abschnittstabelle keinen Einfluss auf den Betrieb der Anwendung.  Gleichzeitig wird ohne eine Abschnitts√ºbersicht die Umkehrung der Anwendung etwas komplizierter. <br>  Wir werden die LIEF-Bibliothek unter Python und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel zum L√∂schen der Abschnittstabelle verwenden</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  RPATH √§ndern und l√∂schen </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  Um RPATH unter Linux zu √§ndern, k√∂nnen Sie die Dienstprogramme <em>chrpath</em> (auf den meisten Distributionen verf√ºgbar) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PatchELF verwenden</a> . </p><br><ul><li><p>  RPATH √§ndern: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  oder </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  RPATH entfernen: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  oder </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-7">  Lief </h3><br><p>  Mit der LIEF-Bibliothek k√∂nnen Sie auch einen RPATH-Datensatz √§ndern und l√∂schen. </p><br><ul><li><p>  RPATH √§ndern: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  RPATH entfernen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Verschleierung von Zeicheninformationen </h2><br><p>  Um die Umkehrung der Anwendung zu erschweren, k√∂nnen Sie Zeicheninformationen speichern, aber die Namen von Objekten verwechseln.  Wir verwenden den Elfen <em>crackme01_32bit</em> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">crackme01 von seveb</a> als Testperson. </p><br><p>  Eine vereinfachte Version eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiels</a> aus der LIEF-Bibliothek k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  Als Ergebnis erhalten wir: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Funktionsersetzung √ºber PLT / GOT </h2><br><p>  Auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ELF PLT INFECTION bekannt</a> . </p><br><p>  Um nicht zu kopieren und einzuf√ºgen, hinterlassen Sie einfach Links zum Thema: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsumleitung in gemeinsam genutzten ELF-Bibliotheken</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Infizieren des plt / bekam mit LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Einstiegspunkt √§ndern </h2><br><p>  Dies kann n√ºtzlich sein, wenn Sie Patches erstellen, Hooks und andere dynamische Instrumente installieren oder versteckte Funktionen aufrufen.  Als Experiment verwenden wir den Elfen crackme01_32bit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">crackme01 von seveb</a> </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  radare2 startet im Aufnahmemodus (Option <code>-w</code> ) - √Ñnderungen werden an der Originaldatei vorgenommen: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-8">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Code-Patch </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nehmen Sie</a> als einfachen Test den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crackmepal des Novn91 mit dem Crack</a> .  Beim Start ohne Parameter zeigt das Programm Folgendes an: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  Beim Start mit einem beliebigen String-Parameter wird Folgendes angezeigt: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Wir werden einen Patch erstellen, damit das Programm sofort beim Start die Meldung ‚ÄûGute Arbeit!  jetzt keygen mich! " </p><br><h3 id="radare2-2">  radare2 </h3><br><p>  radare2 kann alle Formate patchen, die es selbst unterst√ºtzt.  In diesem Fall k√∂nnen die Patches im Textformat beschrieben werden: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Sie k√∂nnen einen solchen Patch mit dem folgenden Befehl anwenden: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Lesen Sie mehr √ºber das Patchen von Code √ºber radare2: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bin√§res Patchen mit Radare2 von wolfshirtz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Radare2-Erkundungen.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial 1 - Einfacher Patch</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ground Zero: Teil 3-2 - Reverse Engineering - Patchen von Bin√§rdateien mit Radare2 - ARM64</a> </li></ul><br><h3 id="lief-9">  Lief </h3><br><p>  Mit LIEF k√∂nnen Sie den Elfen (Bytes √ºberschreiben) an der angegebenen virtuellen Adresse patchen.  Der Patch kann in Form eines Bytearrays oder als ganzzahliger Wert vorliegen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  Nach dem Anwenden des Patches gibt das Programm Folgendes aus: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Abschnitt zu ELF hinzuf√ºgen </h2><br><h3 id="objcopy-1">  Objekt </h3><br><p>  <em>Mit objcopy</em> k√∂nnen Sie einen Abschnitt hinzuf√ºgen, dieser Abschnitt geh√∂rt jedoch keinem Segment an und wird beim Start der Anwendung nicht in den Arbeitsspeicher geladen: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-10">  Lief </h3><br><p>  Mit der LIEF-Bibliothek k√∂nnen Sie einem vorhandenen ELF einen neuen Abschnitt und das entsprechende Segment ( <strong><code>loaded=True</code></strong> Flag) hinzuf√ºgen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Abschnitt √§ndern </h2><br><h3 id="objcopy-2">  Objekt </h3><br><p>  <em>Mit objcopy</em> k√∂nnen <em>Sie</em> den Inhalt eines Abschnitts durch Daten aus einer Datei ersetzen sowie die virtuelle Adresse eines Abschnitts und der Flags √§ndern: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-11">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Abschnitt l√∂schen </h2><br><h3 id="objcopy-3">  Objekt </h3><br><p>  <em>Mit objcopy</em> k√∂nnen <em>Sie</em> einen bestimmten Abschnitt nach Namen l√∂schen: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-12">  Lief </h3><br><p>  Das L√∂schen eines Abschnitts mithilfe der LIEF-Bibliothek sieht folgenderma√üen aus: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Elfenbeh√§lter </h2><br><p>  Das Rezept ist von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gremlins und ELF-Magie</a> inspiriert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">: Was ist, wenn die ELF-Datei ein Container ist?</a>  .  Es gibt auch Informationen √ºber das aus Solaris stammende Dienstprogramm elfwrap, mit dem Sie eine ELF-Datei aus beliebigen Daten erstellen k√∂nnen, und das ELF-Format wird einfach als Container verwendet. </p><br><p>  Versuchen wir, dasselbe in Python und LIEF zu tun. <br>  Leider kann die LIEF-Bibliothek derzeit keine Elf-Datei von Grund auf neu erstellen. Sie m√ºssen also helfen - erstellen Sie eine leere ELF-Vorlage: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Jetzt k√∂nnen Sie diese Vorlage verwenden, um Daten zu f√ºllen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elf "mit Anh√§nger" </h2><br><p>  Das ELF-Format legt keine Einschr√§nkungen f√ºr die Daten in der Datei fest, geh√∂rt jedoch zu keinem Segment.  Somit ist es m√∂glich, eine ausf√ºhrbare Datei zu erstellen, die nach der ELF-Struktur gespeichert wird.  Dies wird zur Laufzeit nicht in den Arbeitsspeicher geladen, sondern auf die Festplatte geschrieben und kann jederzeit von der Festplatte gelesen werden. </p><br><ul><li>  <em>IDA Pro ber√ºcksichtigt diese Daten bei der Analyse nicht</em> </li></ul><br><p>  <em>Beispiel einer Dateistruktur mit einem Trailer</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="Bild"></p><br><h3 id="radare2-3">  radare2 </h3><br><p>  Das Vorhandensein eines ‚ÄûTrailers‚Äú kann durch Vergleichen der tats√§chlichen und berechneten Dateigr√∂√üe festgestellt werden: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  lesen Sie sich </h3><br><p>  <em>readelf</em> zeigt keine Informationen √ºber das Vorhandensein eines "Trailers" an, kann jedoch manuell berechnet werden: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-13">  Lief </h3><br><p>  In der LIEF-Bibliothek k√∂nnen Sie sowohl das Vorhandensein eines ‚ÄûTrailers‚Äú √ºberpr√ºfen als auch hinzuf√ºgen.  Mit LIEF sieht alles ziemlich pr√§gnant aus: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  Leerer Elf (ELF von Grund auf neu) </h2><br><p>  Im Internet finden Sie Projekte zum ‚Äûmanuellen‚Äú Erstellen einer ELF-Datei - ohne Verwendung eines Compilers und Linkers unter dem allgemeinen Namen ‚ÄûELF von Grund auf neu‚Äú: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projekt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elf von Grund auf neu</a> Artikel </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elf_from_scratch-</a> Zweig im LIEF-Bibliotheksrepository </li></ul><br><p>  Die Vertrautheit mit diesen Projekten wirkt sich positiv auf die Absorption des ELF-Formats aus. </p><br><h2 id="samyy-malenkiy-elf">  Kleinster Elf </h2><br><p>  Interessante Experimente zur Minimierung der Gr√∂√üe des Elfen sind in den Artikeln beschrieben: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Wirbelwind-Tutorial zum Erstellen von wirklich teensy ELF Executables f√ºr Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Wirbelwind-Tutorial zum Erstellen von etwas teensy ELF Executables f√ºr Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minimalistisches Programm im ELF-Format</a> </li></ul><br><p>  Kurz gesagt, der Elf Loader im Betriebssystem verwendet nicht alle Headerfelder und Segmenttabellen, und ein minimaler ausf√ºhrbarer Code kann direkt in die ELF-Headerstruktur eingef√ºgt werden (der Code stammt aus dem ersten Artikel): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Stellen Sie einen ELF mit einer Gr√∂√üe von <strong>45 Bytes zusammen und erhalten Sie ihn</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Musterelfe </h2><br><p>  Um einen Elfen mit der LIEF-Bibliothek zu erstellen, k√∂nnen Sie die folgenden Schritte ausf√ºhren (siehe Rezept "Elfen-Container"): </p><br><ul><li>  Nehmen Sie eine einfache ELF-Datei als Vorlage. </li><li>  Ersetzen Sie den Inhalt von Abschnitten, f√ºgen Sie neue Abschnitte hinzu. </li><li>  Konfigurieren Sie die erforderlichen Parameter (Einstiegspunkt, Flags). </li></ul><br><h1 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h1><br><p>  Als wir den Artikel hinzuf√ºgten, stellten wir fest, dass es so etwas wie eine Ode an die LIEF-Bibliothek war.  Dies war jedoch nicht geplant - ich wollte zeigen, wie mit ELF-Dateien mit verschiedenen Tools gearbeitet wird. </p><br><p>  Sicher gibt es oder braucht Skripte, die hier nicht erw√§hnt wurden - schreiben Sie dar√ºber in den Kommentaren. </p><br><h1 id="ssylki-i-literatura">  Referenzen und Literatur </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ELF-Formatspezifikation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine weitere Formatspezifikation in der Oracle-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten mit ELFs mit radare2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LIEF-Bibliotheksdokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele f√ºr LIEF-Bibliotheken</a> </li><li>  Buch "PRAKTISCHE BIN√ÑRE ANALYSE", Dennis Andriesse </li><li>  Lernen der bin√§ren Linux-Analyse von Ryan "elfmaster" O'Neill </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460247/">https://habr.com/ru/post/de460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460231/index.html">OpenGear - Reduzieren Sie Gesch√§ftsausf√§lle mithilfe eines Konsolenservers mit Out-of-Band-Verwaltung</a></li>
<li><a href="../de460233/index.html">Das Spiel Cities: Skylines erwies sich als Turing-vollst√§ndig: Wir erstellen einen 4-Bit-Addierer</a></li>
<li><a href="../de460237/index.html">EBay-Betr√ºger (eine betr√ºgerische Geschichte)</a></li>
<li><a href="../de460239/index.html">So bringen Sie die NextGen Firewall absolut kostenlos nach Hause</a></li>
<li><a href="../de460241/index.html">H√∂lle oder Hochwasser: Geschichte der russischen popul√§rwissenschaftlichen Literatur</a></li>
<li><a href="../de460249/index.html">L√∂sung der Aufgabe mit pwnable.kr 07 - Eingabe. Pwntools verstehen</a></li>
<li><a href="../de460251/index.html">K√ºnstliche Dummheit: Ein Bot, der mir nicht geholfen hat</a></li>
<li><a href="../de460253/index.html">10 Gr√ºnde, Ihre F√§higkeiten als Sprachassistent zu verbessern</a></li>
<li><a href="../de460255/index.html">Backdoor auf Node.js: warum, warum und wie es funktioniert</a></li>
<li><a href="../de460257/index.html">Hallo Welt! Tiefes Eintauchen in Terminals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>