<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚕️ ⁉️ 🌶️ Serverless PHP 🧔🏻 👲 📹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am Vorabend des Starts des Backend PHP Developer Kurses hatten wir eine traditionelle offene Stunde . Dieses Mal haben wir uns mit dem Serverless-Konz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serverless PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/477370/"><p>  Am Vorabend des Starts des <a href="https://otus.pw/PjYz/">Backend PHP Developer</a> Kurses <a href="https://otus.pw/PjYz/">hatten</a> wir eine <a href="https://www.youtube.com/watch%3Fv%3DcGBggTdDmKI">traditionelle offene Stunde</a> .  Dieses Mal haben wir uns mit dem Serverless-Konzept vertraut gemacht, über die Implementierung in AWS gesprochen, die Funktionsweise, den Zusammenbau und den Start besprochen und einen einfachen PHP-TG-Bot auf der Basis von AWS Lambda erstellt. </p><br><p>  Dozent - <a href="https://otus.ru/teacher/491/">Alexander Pryakhin</a> , CTO von Westwing Russland. </p><br><hr><br><p><img src="https://habrastorage.org/webt/fm/-y/de/fm-yde0vvpixphwgwoqfsumq-n4.jpeg"></p><a name="habracut"></a><br><h2 id="kratkiy-ekskurs-v-istoriyu">  Ein kurzer Ausflug in die Geschichte </h2><br><p><img src="https://habrastorage.org/webt/w7/jh/mk/w7jhmkufvziqczxd8ppmbgjylpy.png"></p><br><p>  Wie sind wir zu einem solchen Leben gekommen, dass Serverless Computing auftauchte?  Natürlich sahen sie nicht nur so aus, sondern wurden zu einer logischen Fortsetzung bestehender Virtualisierungstechnologien. </p><br><p><img src="https://habrastorage.org/webt/am/jv/dt/amjvdt02rv2bv7_-yhbexlhejm0.png"></p><br><p>  Was virtualisieren wir normalerweise?  Zum Beispiel ein Prozessor.  Sie können den Speicher auch virtualisieren, indem Sie bestimmte Speicherbereiche markieren und für einige Benutzer zugänglich und für andere nicht zugänglich machen.  Sie können ein VPN-Netzwerk virtualisieren.  Usw. </p><br><p><img src="https://habrastorage.org/webt/il/2o/p_/il2op_dxfloq7om6r_czugnhebq.png"></p><br><p>  Virtualisierung ist gut, weil wir Ressourcen besser nutzen und die Produktivität steigern.  Es gibt aber auch Nachteile, zum Beispiel gab es einmal Kompatibilitätsprobleme.  Es gibt jedoch praktisch keine Architekturen, die mit modernen virtuellen Maschinen nicht kompatibel wären. </p><br><p>  Das nächste Minus ist, dass wir eine zusätzliche Abstraktionsebene hinzufügen, einen Hypervisor hinzufügen, eine virtuelle Maschine selbst hinzufügen und natürlich etwas an Geschwindigkeit verlieren können.  Etwas kompliziert und die Nutzung des Servers. </p><br><p><img src="https://habrastorage.org/webt/yh/on/4j/yhon4j0ial2rlrdfq_grqgx6yjw.png"></p><br><p>  Wenn wir eine standardmäßige virtuelle Maschine mitnehmen, sieht diese ungefähr so ​​aus: </p><br><p><img src="https://habrastorage.org/webt/rq/ii/at/rqiiat114asa0rziaowjsjp1amg.png"></p><br><p> Erstens haben wir einen Eisenserver und zweitens das Betriebssystem, auf dem sich unser Hypervisor drehen wird.  Darüber hinaus drehen sich unsere virtuellen Maschinen, in denen sich ein Gastbetriebssystem, Bibliotheken und Anwendungen befinden.  Wenn Sie logisch denken, sehen wir bei Vorhandensein des Gastbetriebssystems einen gewissen Overhead, da wir in der Tat zusätzliche Ressourcen ausgeben. </p><br><p>  Wie kann ich das Overhead-Problem lösen?  Ablehnen von virtuellen Maschinen und Hinzufügen eines Containerverwaltungssystems zum Hauptbetriebssystem.  Das derzeit beliebteste System ist natürlich die Docker Engine.  Dann verwenden die Bibliotheken im Container den Host-Kernel des Betriebssystems. </p><br><p><img src="https://habrastorage.org/webt/rb/wv/ce/rbwvceyh5h8mrsgsst9bu8acadk.png"></p><br><p>  Auf diese Weise entfernen wir den Overhead, aber Docker ist auch nicht ideal und es hat seine eigenen Probleme und Arbeitsfunktionen, die nicht jedem gefallen. </p><br><p>  Das Wichtigste ist, dass Docker und virtuelle Maschine unterschiedliche Ansätze sind und nicht gleichgesetzt werden müssen.  Docker ist keine Mikrovirtualität, mit der Sie wie mit einer virtuellen Maschine arbeiten können, denn der Container ist dafür und der Container.  Der Container ermöglicht uns jedoch Flexibilität und einen völlig anderen Ansatz für die kontinuierliche Lieferung, wenn wir Dinge an die Produktion liefern und verstehen, dass sie bereits getestet wurden und funktionieren. </p><br><h2 id="oblachnye-tehnologii">  Cloud-Technologie </h2><br><p>  Mit der Weiterentwicklung der Virtualisierung begannen sich auch Cloud-Technologien zu entwickeln.  Dies ist eine gute Lösung, aber es ist erwähnenswert, dass Wolken kein Wundermittel und kein Allheilmittel für alle Übel sind.  Hier kann man sich nur an ein berühmtes Zitat erinnern: </p><br><blockquote>  „Wenn ich jemanden höre, der die Cloud als Wundermittel für alle Computerprobleme ankündigt, ersetze ich„ Cloud “stillschweigend durch„ Clown “und mache mit einem zenartigen Lächeln weiter.“ <br>  Amy reich </blockquote><p>  Für mittelständische Unternehmen, die ein gewisses Maß an Service und Fehlertoleranz ohne große finanzielle Mittel erhalten möchten, sind die Clouds jedoch eine gute Option.  Und für viele Unternehmen ist es viel teurer, ihr Rechenzentrum mit demselben SLA zu betreiben, als in der Cloud bedient zu werden.  Darüber hinaus können wir die Clouds für unsere Bedürfnisse verwenden, da sie einige Dinge mit nur wenigen Mausklicks bereitstellen, was sehr praktisch ist.  Zum Beispiel die Möglichkeit, eine virtuelle Maschine oder ein Netzwerk mit wenigen Klicks zu heben. <br>  Ja, es gibt Einschränkungen, zum Beispiel das 152. Bundesgesetz, das die Speicherung personenbezogener Daten im Ausland verbietet, so dass derselbe Amazon für uns während eines Audits nicht geeignet sein wird.  Vendor-lock nicht vergessen.  Viele Cloud-Lösungen lassen sich nicht miteinander portieren, obwohl die meisten Anbieter denselben S3-kompatiblen Speicher unterstützen. </p><br><p>  Clouds bieten uns die Möglichkeit, ohne eng fokussiertes Wissen unterschiedliche Servicelevels zu erhalten.  Je weniger Wissen Sie benötigen, desto mehr werden wir bezahlen.  In der folgenden Abbildung sehen Sie die Pyramide, in der von unten nach oben der Rückgang des technischen Wissensbedarfs bei Verwendung der Cloud angezeigt wird: </p><br><p><img src="https://habrastorage.org/webt/ro/hi/aj/rohiajoeei87pirilzujxcaelqs.png"></p><br><h2 id="serverless-i-faas-function-as-a-service">  Serverless und FaaS (Funktion als Service) </h2><br><p>  Serverless ist eine relativ junge Methode zum Ausführen von Skripten in den Clouds, z. B. AWS (in Bezug auf AWS ist der Server in Lambda implementiert).  * Die in der obigen Pyramide aufgelisteten AaS-Ansätze sind bereits bekannt: IaaS (EC2, VDS), PaaS (Shared Hosting), SaaS (Office 365, Tilda).  Serverless ist also eine Implementierung des FaaS-Ansatzes.  Und dieser Ansatz besteht darin, dem Benutzer eine vorgefertigte Plattform für die Entwicklung, den Start und die Verwaltung bestimmter Funktionen zur Verfügung zu stellen, ohne sich selbst vorbereiten und konfigurieren zu müssen. </p><br><p>  Stellen Sie sich vor, Sie haben ein Gerät, das nachts Dokumente verarbeitet, von 00:00 bis 6:00 Uhr Aufgaben ausführt und in den restlichen Stunden nicht verwendet wird.  Die Frage ist: Warum tagsüber bezahlen?  Und warum nicht kostenlose Ressourcen für etwas anderes nutzen?  Dieser Wunsch nach Optimierung und der Wunsch, Geld nur für das auszugeben, was Sie wirklich nutzen, führten zur Entstehung von FaaS. </p><br><p>  Serverless ist eine Ressource zum Ausführen von Code und sonst nichts.  Dies bedeutet nicht, dass sich hinter unserem Skript kein Server befindet - dies ist der Fall, aber wir haben tatsächlich keine speziell zugewiesene Ressource, auf der unser Lambda gestartet wird.  Wenn wir unser Skript ausführen, entfaltet sich die Mikroinfrastruktur sofort darunter, und dies ist im Prinzip nicht Ihr Problem - Sie denken nur, dass Sie den Code ausgeführt haben, und Sie brauchen sich um nichts anderes zu kümmern. <br>  Dies erfordert natürlich eine bestimmte Herangehensweise an die Entwicklung Ihres Codes.  Beispielsweise können Sie in dieser Umgebung nichts speichern, sondern müssen alles herausnehmen.  Handelt es sich um Daten, wird eine externe Datenbank benötigt. Handelt es sich um ein Protokoll, handelt es sich um einen externen Protokolldienst, handelt es sich um eine Datei, handelt es sich um einen externen Dateispeicher.  Glücklicherweise bietet jeder Serverless-Anbieter die Möglichkeit, eine Verbindung zu externen Systemen herzustellen. </p><br><p>  Sie haben nur Code, Sie arbeiten im zustandslosen Paradigma, Sie haben keinen Zustand.  Für die gleiche Welt von PHP bedeutet dies beispielsweise, dass Sie den Standard-Sitzungsmechanismus vergessen können.  Im Prinzip können Sie sogar Ihre Serverless bauen, und kürzlich gab es auf Habré <a href="https://habr.com/ru/company/southbridge/blog/475044/">einen Artikel zu diesem Thema</a> . </p><br><p>  Die Grundidee von Serverless ist, dass die Infrastruktur keine Unterstützung durch das Team erfordert.  Alles fällt auf die Schultern der Plattform, für die Sie tatsächlich Geld bezahlen.  Von den Minuspunkten - Sie haben keine Kontrolle über die Ausführungsumgebung und wissen nicht, wo was ausgeführt wird. </p><br><p>  So serverlos: </p><br><ul><li>  bedeutet nicht die physische Abwesenheit des Servers; </li><li>  kein Killer von Virtualoks und Docker; </li><li>  kein Hype hier und jetzt. <br>  Serverless sollte bewusst und bewusst vorangetrieben werden.  Zum Beispiel, wenn Sie schnell eine Hypothese testen müssen, ohne die Hälfte des Teams einzubeziehen.  So erhalten Sie Function As A Service.  Die Funktion reagiert auf einige Ereignisse, und da es eine Reaktion auf Ereignisse gibt, müssen diese Ereignisse von etwas aufgerufen werden - dafür gibt es in derselben AWS viele Trigger. </li></ul><br><p>  FaaS-Funktionen: </p><br><ul><li>  Infrastruktur erfordert keine Konfiguration; </li><li>  "Out of the Box" -Ereignismodell; </li><li>  Staatenlos; </li><li>  Die Skalierung ist sehr einfach und wird automatisch entsprechend den Benutzeranforderungen durchgeführt. </li></ul><br><h2 id="aws-lambda">  AWS Lambda </h2><br><p>  Die erste und öffentlich verfügbare Implementierung von FaaS ist AWS Lambda.  Wenn es sich um eine Diplomarbeit handelt, hat sie folgende Eigenschaften: <br>  - verfügbar seit 2014; <br>  - unterstützt standardmäßig Java, Node.js, Python, Go und benutzerdefinierte Laufzeiten; <br>  - wir bezahlen für: <br>  Anzahl der Anrufe; <br>  Vorlaufzeit. <br>  AWS Lambda: Warum wird es benötigt: <br>  Entsorgung  Sie zahlen nur für die Zeit, in der der Dienst ausgeführt wird. <br>  Geschwindigkeit.  Lambda selbst steigt auf und arbeitet sehr schnell. <br>  Funktional.  Lambda bietet viele Funktionen für die Integration in AWS-Services. <br>  Leistung.  Ein Lambda zu setzen ist ziemlich schwer.  Parallel dazu können je nach Region maximal 1000 bis 3000 Exemplare erstellt werden.  Falls gewünscht, kann dieses Limit durch Schreiben in den Support erhöht werden. </p><br><p>  Wir haben den Körper eines Lambda, einen Online-Editor, VPC als virtuelles Rechengitter, die Protokollierung, den Code selbst, Umgebungsvariablen und Trigger, die ein Lambda verursachen (die Versionierung funktioniert übrigens sehr gut).  In <a href="https://habr.com/ru/post/457100/">diesem Artikel</a> wird die ausgezeichnete Lambda-Anatomie <a href="https://habr.com/ru/post/457100/">beschrieben</a> . </p><br><p>  Der Code wird entweder im Hauptteil (sofern diese Sprachen standardmäßig unterstützt werden) oder in Ebenen gespeichert.  Wir haben einen Trigger, der das Lambda aufruft, das Lambda liest die temporären Umgebungen, zieht sie zu sich selbst und führt unseren Code aus: </p><br><p><img src="https://habrastorage.org/webt/sr/py/zu/srpyzu9gzq6gfkekd-tbo5zkmyq.png"></p><br><p>  Wenn wir eine benutzerdefinierte Laufzeit haben, müssen wir den Code in einer Ebene platzieren.  Wenn Sie mit Docker gearbeitet haben, ist die Docker-Ebene der Lambda-Ebene sehr ähnlich - eine Art Quasi-Speicher, in dem sich unsere erforderliche Bindung befindet.  Dort haben wir die ausführbare Datei der Umgebung (wenn es sich um PHP handelt, sollten Sie die kompilierte PHP-Binärdatei im Voraus platzieren), die Lambda-Bootstrap-Datei (standardmäßig gespeichert) und die direkt aufgerufenen Skripte, die ausgeführt werden. </p><br><p><img src="https://habrastorage.org/webt/pj/es/fp/pjesfpgl0xix6psx4tqwegms_4m.png"></p><br><p>  Bei der Lieferung ist nicht alles so rosig: </p><br><p><img src="https://habrastorage.org/webt/xg/qt/km/xgqtkmwgjqrisunlmvwtgym2nkk.png"></p><br><p>  Das heißt, wir können Dateien mit dem Code aufnehmen, in das ZIP-Archiv hochladen, in die Ebene hochladen und unseren Code ausführen.  Es ist absolut cool, dass dies in der offiziellen Dokumentation von Amazon angeboten wird. </p><br><p><img src="https://habrastorage.org/webt/w2/ls/vr/w2lsvrvdjcbta6km5boxp3ntsgw.png"></p><br><p>  Natürlich entspricht dies nicht den modernen Realitäten und dem Geruch von zweitausendstel in der Luft.  Glücklicherweise haben freundliche Leute versucht, verschiedene Frameworks zu erstellen. Daher verwenden wir das auf Node.js entwickelte Serverless Framework, mit dem wir Anwendungen auf Basis von AWS Lambda verwalten können.  Wenn wir über Bereitstellung und Entwicklung sprechen, möchte ich natürlich nicht wirklich manuell bereitstellen, aber es besteht der Wunsch, etwas Flexibles und Automatisiertes zu tun. </p><br><p>  Also brauchen wir: <br>  - AWS CLI - Befehlszeilenschnittstelle für die Arbeit mit AWS-Diensten; <br>  - das oben bereits erwähnte Serverless-Framework (die Entwicklungsversion ist kostenlos und die Funktionalität ist für die Augen ausreichend); <br>  - Die Bref-Bibliothek, die zum Schreiben von Code benötigt wird.  Diese Bibliothek wird mit Composer installiert, sodass der Code mit jedem Framework kompatibel ist.  Eine großartige Lösung, insbesondere angesichts der Tatsache, dass AWS Lambda das Aufrufen von PHP-Skripten nicht direkt unterstützt. </p><br><p><img src="https://habrastorage.org/webt/ke/de/4w/kede4wq7a7kupqj4zheld7ifkp0.png"></p><br><h2 id="nastraivaem-okruzhenie-i-aws">  Passen Sie Ihre Umgebung und AWS an </h2><br><h3 id="aws-cli">  AWS CLI </h3><br><p>  Beginnen wir mit der Erstellung eines Kontos und der Installation von AWS CLI.  Die AWS-Konsolen-Shell basiert auf Python 2.7+ oder 3.4+.  Da AWS Version 3 von Python empfiehlt, werden wir nicht streiten. <br>  Die folgenden Beispiele gelten für Ubuntu. </p><br><pre><code class="plaintext hljs">sudo apt-get -y install python3-pip</code> </pre> <br><p>  Dann installieren Sie direkt AWS CLI: </p><br><pre> <code class="plaintext hljs">pip3 install awscli --upgrade --user</code> </pre> <br><p>  Überprüfen Sie die Installation: </p><br><pre> <code class="plaintext hljs">aws --version</code> </pre> <br><p>  Jetzt müssen Sie AWS CLI mit Ihrem Konto verbinden.  Sie können Ihren vorhandenen Benutzernamen und Ihr Kennwort verwenden. Es ist jedoch besser, wenn Sie einen separaten Benutzer über AWS IAM erstellen und ihm nur die erforderlichen Zugriffsrechte zuweisen.  Das Aufrufen der Konfiguration verursacht keine Probleme: </p><br><pre> <code class="plaintext hljs">aws configure</code> </pre> <br><p>  Als Nächstes benötigen Sie AWS Secret und AWS Access Key.  Sie können in ASW IAM auf der Registerkarte "Sicherheitsanmeldeinformationen" (auf der Seite des gewünschten Benutzers) abgerufen werden.  Die Schaltfläche "Zugriffsschlüssel erstellen" hilft bei der Erstellung von Zugriffsschlüsseln.  Behalte sie bei dir. </p><br><p><img src="https://habrastorage.org/webt/yn/t3/0q/ynt30qaych_hosd73v0bl3yb51q.png"></p><br><p>  Um einen neuen Bot in Telegram zu registrieren, verwenden Sie @BotFather und den Befehl / newbot.  Infolgedessen erhalten Sie das für die Verbindung zu Ihrem Bot erforderliche Token zurück.  Schließe es auch ab. </p><br><p><img src="https://habrastorage.org/webt/mn/db/6_/mndb6_yarkg6ssd1cmfaykayuam.png"></p><br><h3 id="serverless-framework">  Serverloses Framework </h3><br><p>  Zur Installation von Serverless Framework benötigen Sie ein Konto unter <a href="https://serverless.com/">https://serverless.com/</a> . <br>  Nach Abschluss der Registrierung fahren wir mit der Installation auf unserer Workstation fort.  Node.js 6. und höher wird benötigt. </p><br><pre> <code class="plaintext hljs">sudo apt-get -y install nodejs</code> </pre> <br><p>  Um den korrekten Start in unserer Umgebung sicherzustellen, befolgen wir die empfohlenen Schritte: </p><br><pre> <code class="plaintext hljs">mkdir ~/.npm-global export PATH=~/.npm-global/bin:$PATH source ~/.profile npm config set prefix '~/.npm-global'</code> </pre> <br><p>  Fügen Sie außerdem hinzu: </p><br><pre> <code class="plaintext hljs">~/.npm-global/bin:$PATH</code> </pre> <br><p>  in die Datei / etc / environment. <br>  Setzen Sie nun Serverless: </p><br><pre> <code class="plaintext hljs">npm install -g serverless</code> </pre> <br><h3 id="aws">  Aws </h3><br><p>  Nun, es ist Zeit, zur AWS-Oberfläche zu wechseln und einen Domainnamen hinzuzufügen.  Wir erstellen eine AWS Route 53-Zone, einen DNS-Eintrag und ein SSL-Zertifikat dafür. <br>  Außerdem benötigen Sie den ELB, den wir im Service EC2 -&gt; Load Balancer erstellen.  Übrigens müssen Sie beim Erstellen einer ELB alle Schritte des Assistenten durchlaufen und das erstellte Zertifikat angeben. </p><br><p>  Der Balancer kann mit dem folgenden Befehl über die AWS-CLI erstellt werden: </p><br><pre> <code class="plaintext hljs">aws elb create-load-balancer --load-balancer-name my-load-balancer --listeners "Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=80" "Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80,SSLCertificateId=arn:aws:iam::123456789012:server-certificate/my-server-cert" --subnets subnet-15aaab61 --security-groups sg-a61988c3</code> </pre> <br><p>  Nach der ersten Bereitstellung wird ein Balancer benötigt.  In diesem Fall müssen Sie Anfragen an unsere Domain an diese senden.  Um dies zu implementieren, geben Sie in den Einstellungen des DNS-Eintrags (Feld „Alias-Ziel“) den Namen der erstellten ELB ein.  Infolgedessen wird eine Dropdown-Liste angezeigt, sodass der gewünschte Eintrag ausgewählt und gespeichert werden muss. </p><br><p><img src="https://habrastorage.org/webt/-i/yr/8g/-iyr8gsoknvxwk0nsjvwtiolca0.png"></p><br><p>  Gehen Sie jetzt zum Code. </p><br><h3 id="pishem-kod">  Einen Code schreiben </h3><br><p>  Wir werden Bref verwenden, um den Code zu schreiben.  Wie bereits erwähnt, wird diese Bibliothek mit Composer installiert, sodass der Code mit jedem Framework kompatibel ist.  Übrigens haben die Entwickler bereits den Prozess der Verwendung von Bref mit <a href="https://bref.sh/docs/frameworks/laravel.html">Laravel</a> und <a href="https://bref.sh/docs/frameworks/symfony.html">Symfony beschrieben</a> .  Es ist jedoch ratsam, an dem "bloßen" PHP zu arbeiten - dies hilft, das Wesentliche besser zu verstehen. <br>  Wir beginnen mit den Abhängigkeiten: </p><br><pre> <code class="plaintext hljs">{ "require": { "php": "&gt;=7.2", "bref/bref": "^0.5.9", "telegram-bot/api": "*" }, "autoload": { "psr-4": { "App\": "src/" } } }</code> </pre> <br><p>  Wir werden in PHP 7.2 und höher schreiben und für die Arbeit mit Telegram ist diese Shell für die API für uns geeignet - <a href="https://github.com/TelegramBot/Api">https://github.com/TelegramBot/Api</a> .  Der Code selbst wird im Verzeichnis src abgelegt. </p><br><p>  Die serverlose Umgebung durchläuft also einen Konsolendialog.  Eine HTTP-Anwendung ist erforderlich. Aus Sicht von Lambda bedeutet dies, dass Skriptaufrufe auf die gleiche Weise ausgeführt werden, wie dies bei Nginx der Fall ist.  Die Interpretation wird von PHP-FPM durchgeführt.  Im Allgemeinen ähnelt dies eher einem Standard-Konsolenskriptaufruf.  Dies ist ein wichtiger Punkt, da wir ohne Berücksichtigung dieser Funktion keine Skripte über HTTP aufrufen können. <br>  Wir führen aus: </p><br><pre> <code class="plaintext hljs">vendor/bin/bref init</code> </pre> <br><p>  Wählen Sie im Dialogfeld den Punkt "HTTP-Anwendung" und vergessen Sie nicht, die Region anzugeben, da die Anwendung in derselben Region arbeiten sollte, in der der Balancer arbeitet. <br>  Nach der Initialisierung erscheinen 2 neue Dateien: <br>  index.php - die aufgerufene Datei; <br>  serverless.yml - Bereitstellungskonfigurationsdatei. <br>  Der .serverless-Ordner muss sofort zum .gitignore hinzugefügt werden (er wird nach dem ersten Bereitstellungsversuch angezeigt). </p><br><p>  Sobald wir eine Webanwendung haben, legen wir index.php im öffentlichen Ordner ab und wechseln sofort zu serverless.yml.  So könnte es in unserer Implementierung aussehen: </p><br><pre> <code class="plaintext hljs">#  lambda- service: app #    provider: name: aws #   ! region: eu-central-1 #    runtime: provided # ,  bref  1024.         memoryLimit: 256 #   stage: dev #    environment: BOT_TOKEN: ${ssm:/app/bot-token} #  bref plugins: - ./vendor/bref/bref #  Lambda- functions: #       php-api-dev # service-function-stage api: handler: public/index.php description: '' # in seconds (API Gateway has a timeout of 29 seconds) timeout: 28 layers: - ${bref:layer.php-73-fpm} #     API Gateway events: - http: 'ANY /' - http: 'ANY /{proxy+}' #    environment: MY_VARIABLE: ${ssm:/app/my_variable}</code> </pre> <br><p>  Analysieren wir nun die nicht offensichtlichen Linien.  Wir brauchen meistens Umgebungsvariablen.  Wir möchten keine Datenbankverbindungen, externen APIs usw. fest codieren. Wenn wir eine Verbindung zu Telegram herstellen, verfügen wir über ein eigenes Token, das von BotFather empfangen wird.  Es wird nicht empfohlen, dieses Token in serverless.yml zu speichern. Es ist daher besser, es an den AWS ssm-Speicher zu senden: </p><br><pre> <code class="plaintext hljs">aws ssm put-parameter --region eu-central-1 --name '/app/my_variable' --type String --value '___BOTFATHER'</code> </pre> <br><p>  Wir verweisen übrigens in der Konfiguration darauf. <br>  Diese Variablen sind als Umgebungsvariablen verfügbar, und Sie können mit der Funktion getenv in PHP darauf zugreifen.  Wenn wir über unser Beispiel sprechen, behalten wir das Bot-Token der Einfachheit halber im globalen Rahmen.  Wir können das Token auch in den Bereich einer einzelnen Funktion übertragen, und der Aufruf selbst wird sich dadurch nicht ändern. </p><br><p>  Lass uns weitermachen.  Erstellen wir nun eine einfache BotApp-Klasse, die für die Generierung einer Antwort für den Bot verantwortlich ist und auf Befehle reagiert.  Telegrammentwickler empfehlen, die Befehle / help und / start für alle Bots zu unterstützen.  Fügen wir zum Spaß einen weiteren Befehl hinzu.  Die Klasse selbst ist recht einfach und ermöglicht es, Front-Controller in index.php zu implementieren, ohne die Aufrufdatei selbst zu laden.  Um eine komplexere Logik zu erhalten, sollte die Architektur entwickelt und kompliziert sein. </p><br><pre> <code class="plaintext hljs">&lt;?php namespace App; use TelegramBot\Api\Client; use Telegram\Bot\Objects\Update; class BotApp { function run(): void{ $token = getenv('BOT_TOKEN'); $bot = new Client($token); //   start $bot-&gt;command('start', function ($message) use ($bot) { $answer = ' !'; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); //    $bot-&gt;command('help', function ($message) use ($bot) { $answer = ': /help -  '; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); //   $bot-&gt;command('hello', function ($message) use ($bot) { $answer = '-,  - ,   Serverless '; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); $bot-&gt;run(); } }</code> </pre> <br><p>  Und hier ist die Auflistung von index.php: </p><br><pre> <code class="plaintext hljs">&lt;?php require_once('../vendor/autoload.php'); use App\BotApp; try{ $botApp = new BotApp(); $botApp-&gt;run(); } catch (Exception $e){ echo $e-&gt;getMessage(); print_r($e-&gt;getTrace(), 1); }</code> </pre> <br><p>  Es mag seltsam erscheinen, aber alles ist bereit für uns, in die Produktion zu gehen.  Führen Sie dazu den folgenden Befehl im Ordner serverless.yml aus: </p><br><pre> <code class="plaintext hljs">sls deploy</code> </pre> <br><p>  Im normalen Modus packt serverless die Dateien in ZIP-Archive, erstellt einen S3-Bucket, in dem sie abgelegt werden, erstellt oder aktualisiert die an Lambda angehängte AWS-Anwendung und legt den Code und die Laufzeit in einer separaten Ebene ab. </p><br><p>  Während des ersten Starts wird die Gateway-API erstellt (wir haben sie verlassen, um das Testen von Anrufen zu vereinfachen, aber dann ist es ratsam, sie zu löschen).  Sie müssen auch den Lambda-Aufruf über ELB konfigurieren, für den wir im Funktionssteuerungsfenster "Trigger hinzufügen" und in der Dropdown-Liste "Application Load Balancer" auswählen.  Sie müssen die zuvor erstellte ELB angeben, die Verbindung über HTTPS einrichten, den Host leer lassen und unter Pfad den Pfad angeben, den Lambda aufruft (z. B. / lambda / mytgbot).  Infolgedessen ist Ihr Lambda unter der URL mit dem angegebenen Pfad verfügbar. </p><br><p>  Jetzt können Sie den Antwortteil des Bot in Telegram registrieren, damit der Messenger versteht, wo er Nachrichten abrufen kann.  Rufen Sie dazu die folgende URL im Browser auf, aber vergessen Sie nicht, Ihre eigenen Parameter einzutragen: </p><br><pre> <code class="plaintext hljs">https://api.telegram.org/bot_/setWebhook?url=https://my-elb-host.com/lambda/mytgbot</code> </pre> <br><p>  Infolgedessen gibt die API "OK" zurück, woraufhin der Bot verfügbar wird. </p><br><p><img src="https://habrastorage.org/webt/g-/rd/kl/g-rdkldh57hxw-sbbcl_ci9nmyk.png"></p><br><h2 id="testiruem-bota-na-lokali">  Testen Sie den Bot auf Gebietsschemas </h2><br><p>  Der Bot kann vor dem Einsatz getestet werden.  Tatsache ist, dass das Serverless Framework das Starten in Gebietsschemas mit Docker-Containern unterstützt.  Befehl aufrufen: </p><br><pre> <code class="plaintext hljs">sls invoke local --docker -f myFunction</code> </pre> <br><p>  Vergessen Sie nicht, dass wir Umgebungsvariablen verwendet haben, daher sollten diese während des Aufrufs auch im folgenden Format festgelegt werden: </p><br><pre> <code class="plaintext hljs">sls invoke local --docker -f myFunction --env VAR1=val1</code> </pre> <br><h2 id="logi">  Protokolle </h2><br><p>  Standardmäßig wird die Anrufausgabe in CloudWatch protokolliert. Sie ist im Überwachungsbereich der entsprechenden Lambda-Funktion verfügbar.  Hier können Sie die Call Traces im Falle eines Dumps auf der PHP-Seite auslesen.  Darüber hinaus können Sie erweiterte Überwachungsdienste anschließen, die jedoch zusätzlich einige Cent pro Monat kosten. </p><br><h2 id="itogo">  Total </h2><br><p>  Als Ergebnis haben wir eine relativ schnelle, flexible, skalierbare und auch relativ kostengünstige Lösung erhalten.  Ja, Lambda gewinnt nicht immer im Vergleich zu Standard-VMs und -Containern, aber es gibt Situationen, in denen die Anwendung ohne Server dabei hilft, schnell und effizient zu „schießen“.  Und das Beispiel des erstellten Bots zeigt dies nur. <br>  Nützliche Materialien zum Thema: </p><br><ul><li>  <a href="http.html">Bref Dokumentation</a> </li><li>  <a href="https://habr.com/ru/post/457100/">Lambda-Theorie</a> ; </li><li>  <a href="https://dev.to/sosnowski/anatomy-of-aws-lambda-1i1e">Lambda-Anatomie</a> ; </li><li>  <a href="https://serverless.com/">Serverloses Framework</a> </li><li>  <a href="https://devenergy.ru/archives/941">Serverloser Telegramm-Bot basierend auf PHP und AWS Lambda</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477370/">https://habr.com/ru/post/de477370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477358/index.html">Wir laden Sie am 5. Dezember zu DINS DevOps EVENING ein: Wir sprechen über ein Ereignisverarbeitungssystem, das Erfahrungen mit Influx austauscht</a></li>
<li><a href="../de477360/index.html">Was ist neu in SOLIDWORKS Simulation 2020?</a></li>
<li><a href="../de477362/index.html">Mehr als nur Anti-Spam: So holen Sie das Beste aus Ihrem Security Email Gateway heraus</a></li>
<li><a href="../de477364/index.html">Wie werde ich Java-Entwickler? Oder vielleicht Python wählen?</a></li>
<li><a href="../de477366/index.html">Fünf Fragen zum Entwerfen von Programmiersprachen</a></li>
<li><a href="../de477372/index.html">Amazon verliert den Krieg gegen Fälschungen</a></li>
<li><a href="../de477374/index.html">Fuzzing Z-Maschinen</a></li>
<li><a href="../de477378/index.html">Mixed Agile - Waterfall-Ansatz bei der Implementierung von Geschäftsanwendungen (auch bekannt als Agile-like)</a></li>
<li><a href="../de477382/index.html">Esport - Profit machen: Mercedes, Megaphon, Wetten und Branding für den Esport</a></li>
<li><a href="../de477384/index.html">Konferenz „Informationssicherheit. Bedrohungen der Gegenwart und Zukunft “</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>