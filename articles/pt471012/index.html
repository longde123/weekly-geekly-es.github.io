<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèº üí∂ üòß Abordagem de engenharia para desenvolvimento de software. Da teoria √† pr√°tica üßñüèø üêº üì∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como testar id√©ias, arquitetura e algoritmos sem escrever c√≥digo? Como formular e verificar suas propriedades? O que s√£o verificadores de modelos e lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abordagem de engenharia para desenvolvimento de software. Da teoria √† pr√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/471012/"><p> Como testar id√©ias, arquitetura e algoritmos sem escrever c√≥digo?  Como formular e verificar suas propriedades?  O que s√£o verificadores de modelos e localizadores de modelos?  O que fazer quando os recursos dos testes n√£o s√£o suficientes? </p><br><p>  Oi  Meu nome √© Vasil Dyadov, agora trabalho como programador em Yandex.Mail, antes de trabalhar na Intel, desenvolvia c√≥digo RTL (n√≠vel de transfer√™ncia de registro) no Verilog / VHDL para ASIC / FPGA ainda mais cedo.  H√° muito tempo que gosto do t√≥pico de confiabilidade de software e hardware, matem√°tica, ferramentas e m√©todos usados ‚Äã‚Äãpara desenvolver software e l√≥gica com propriedades predefinidas garantidas. </p><br><p>  Este √© o segundo artigo de uma s√©rie (o primeiro artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ), projetado para chamar a aten√ß√£o de desenvolvedores e gerentes para a abordagem de engenharia do desenvolvimento de software.  Recentemente, ele foi imerecidamente ignorado, apesar das mudan√ßas revolucion√°rias em sua abordagem e ferramentas de suporte. </p><a name="habracut"></a><br><p>  O primeiro artigo pareceu a alguns leitores muito abstrato.  Muitos gostariam de ver um exemplo do uso de uma abordagem de engenharia e especifica√ß√µes formais em condi√ß√µes pr√≥ximas √† realidade. </p><br><p>  Neste artigo, veremos um exemplo da aplica√ß√£o real do TLA + para resolver um problema pr√°tico. </p><br><p>  Estou sempre aberto para discutir quest√µes relacionadas ao desenvolvimento de software e terei prazer em conversar com os leitores (as coordenadas de comunica√ß√£o est√£o no meu perfil). </p><br><h1 id="chto-takoe-tla">  O que √© o TLA +? </h1><br><p>  Para come√ßar, quero dizer algumas palavras sobre o TLA + e o TLC. </p><br><p>  TLA + (L√≥gica Temporal de A√ß√µes + Dados) √© um formalismo que se baseia em um tipo de l√≥gica temporal.  Desenhado por Leslie Lamport. </p><br><p>  Dentro da estrutura desse formalismo, pode-se descrever o espa√ßo das variantes de comportamento do sistema e as propriedades desses comportamentos. </p><br><p>  Por uma quest√£o de simplicidade, podemos assumir que o comportamento do sistema √© representado por uma sequ√™ncia de seus estados (como mi√ßangas infinitas, bolas em uma corda), e a f√≥rmula TLA + define uma classe de cadeias que descrevem todas as variantes poss√≠veis do comportamento do sistema (um grande n√∫mero de mi√ßangas). </p><br><p>  O TLA + √© adequado para descrever m√°quinas de estados finitos n√£o determin√≠sticos em intera√ß√£o (por exemplo, a intera√ß√£o de servi√ßos em um sistema), embora sua expressividade seja suficiente para descrever muitas outras coisas (que podem ser expressas na l√≥gica de primeira ordem). </p><br><p>  E o TLC √© um verificador de modelo de estado expl√≠cito: um programa que, de acordo com uma dada descri√ß√£o do sistema TLA + e f√≥rmulas de propriedades, itera pelos estados do sistema e determina se o sistema atende √†s propriedades especificadas. </p><br><p>  Normalmente, trabalhar com o TLA + / TLC √© constru√≠do desta maneira: descrevemos o sistema no TLA +, formalizamos propriedades interessantes no TLA +, executamos o TLC para verifica√ß√£o. </p><br><p>  Como n√£o √© f√°cil descrever diretamente um sistema mais ou menos complexo no TLA +, foi inventada uma linguagem de n√≠vel superior - o PlusCal, que se traduz em TLA +.  O PlusCal existe de duas maneiras: com Pascal e sintaxe do tipo C.  No artigo que usei a sintaxe semelhante ao Pascal, parece-me melhor ler.  O PlusCal em rela√ß√£o ao TLA + √© aproximadamente o mesmo que C em rela√ß√£o ao montador. </p><br><p>  Aqui n√£o vamos nos aprofundar na teoria.  Literatura para imers√£o em TLA + / PlusCal / TLC √© fornecida no final do artigo. </p><br><p>  Minha principal tarefa √© mostrar a aplica√ß√£o do TLA + / TLC em um exemplo simples e compreens√≠vel da vida real. </p><br><p>  Em alguns coment√°rios ao artigo anterior, fui criticado por n√£o ter pintado os fundamentos te√≥ricos das ferramentas, mas o objetivo desta s√©rie de artigos era mostrar a aplica√ß√£o pr√°tica de ferramentas para a abordagem de engenharia no desenvolvimento de software. </p><br><p>  Eu acho que uma imers√£o profunda na teoria √© de pouco interesse para qualquer pessoa, mas se voc√™ estiver interessado, sempre poder√° ir ao PM para obter links e explica√ß√µes e, tanto quanto eu tiver conhecimento suficiente (afinal, eu n√£o sou um matem√°tico te√≥rico, mas um engenheiro de software), tentarei responder . </p><br><h1 id="postanovka-zadachi">  Declara√ß√£o do problema </h1><br><p>  Primeiro, falarei um pouco sobre a tarefa para a qual o TLA + foi usado. </p><br><p>  A tarefa est√° relacionada ao processamento do fluxo de eventos.  Ou seja, para criar uma fila para armazenar eventos e enviar notifica√ß√µes sobre esses eventos. </p><br><p>  O data warehouse √© fisicamente organizado com base no DBMS do PostgreSQL. </p><br><p>  A principal coisa que voc√™ precisa saber: </p><br><ol><li>  Existem fontes de eventos.  Para nossos prop√≥sitos, podemos nos limitar ao fato de que cada evento √© caracterizado pelo tempo em que seu processamento √© planejado.  Essas fontes gravam eventos no banco de dados.  Normalmente, o tempo de grava√ß√£o no banco de dados e o tempo do processamento planejado n√£o est√£o relacionados de forma alguma. </li><li>  Existem processos de coordena√ß√£o que l√™em eventos do banco de dados e enviam notifica√ß√µes dos pr√≥ximos eventos para os componentes do sistema que devem responder a essas notifica√ß√µes. </li><li>  Requisito fundamental: n√£o devemos perder eventos.  A notifica√ß√£o do evento em casos extremos pode ser repetida, ou seja, deve haver uma garantia <em>pelo menos uma vez</em> .  Em sistemas distribu√≠dos, √© extremamente dif√≠cil obter uma garantia <em>apenas uma vez</em> (pode at√© ser imposs√≠vel, mas precisa ser comprovada) sem mecanismos de consenso, e eles (pelo menos tudo o que sei) t√™m um efeito muito forte no sistema em termos de atraso e taxa de transfer√™ncia. </li></ol><br><p>  Agora, alguns detalhes: </p><br><ol><li>  Existem muitos processos de origem; eles podem gerar milh√µes (no pior caso) de eventos que caem em um intervalo de tempo estreito. </li><li>  Eventos podem ser gerados para o futuro e para o tempo passado (por exemplo, se o processo de origem diminuiu a velocidade e registrou um evento por um momento que j√° passou). </li><li>  A prioridade do processamento de eventos √© a tempo, ou seja, devemos primeiro processar os eventos mais antigos. </li><li>  Para cada evento, o processo de origem gera um n√∫mero aleat√≥rio <em>worker_id</em> , devido ao qual os eventos s√£o distribu√≠dos entre os coordenadores. </li><li>  Existem v√°rios processos de coordena√ß√£o (escalas de acordo com as necessidades com base na carga do sistema). </li><li>  Cada processo do coordenador processa eventos para seu pr√≥prio conjunto <em>worker_id</em> , ou seja, devido ao <em>worker_id,</em> evitamos a concorr√™ncia entre coordenadores e a necessidade de bloqueios. </li></ol><br><p>  Como pode ser visto na descri√ß√£o, podemos considerar apenas um processo de coordena√ß√£o e n√£o considerar o <em>worker_id</em> em nossa tarefa. </p><br><p>  Ou seja, por simplicidade, assumimos que: </p><br><ol><li>  Existem muitos processos de origem. </li><li>  O processo de coordena√ß√£o √© um. </li></ol><br><p>  Descreverei a evolu√ß√£o da id√©ia de resolver esse problema em etapas, para que seja mais compreens√≠vel como o pensamento evoluiu de uma implementa√ß√£o simples para uma otimizada. </p><br><h1 id="reshenie-v-lob">  Decis√£o na testa </h1><br><p>  Criaremos uma placa para eventos em que armazenaremos eventos na forma de apenas um <em>carimbo de data</em> / <em>hora</em> (n√£o estamos interessados ‚Äã‚Äãem outros par√¢metros nesta tarefa).  Vamos criar um √≠ndice no campo <em>timestamp</em> . </p><br><p>  Parece ser uma solu√ß√£o perfeitamente normal. </p><br><p>  S√≥ h√° um problema com a escalabilidade: quanto mais eventos, mais lentas as opera√ß√µes do banco de dados. </p><br><p>  Os eventos podem ocorrer no passado, portanto o coordenador ter√° que revisar constantemente toda a linha do tempo. </p><br><p>  O problema pode ser resolvido extensivamente dividindo o banco de dados em fragmentos por tempo, etc. Mas essa √© uma maneira que consome muitos recursos. </p><br><p>  Como resultado, o trabalho dos coordenadores ser√° mais lento, pois voc√™ precisar√° ler e combinar dados de v√°rios bancos de dados. </p><br><p>  √â dif√≠cil implementar o cache de eventos no coordenador para n√£o ir √†s bases para processar cada evento. </p><br><p>  Mais bancos de dados - mais problemas de toler√¢ncia a falhas. </p><br><p>  E assim por diante </p><br><p>  N√£o vamos nos aprofundar nessa solu√ß√£o frontal em detalhes, pois ela √© trivial e desinteressante. </p><br><h1 id="pervaya-optimizaciya">  Primeira otimiza√ß√£o </h1><br><p>  Vamos ver como melhorar a solu√ß√£o frontal. </p><br><p>  Para otimizar o acesso ao banco de dados, voc√™ pode complicar um pouco o √≠ndice, adicionar um identificador monotonicamente crescente aos eventos que ser√£o gerados ao confirmar uma transa√ß√£o no banco de dados.  Ou seja, o evento agora √© caracterizado pelo par <em>{time, id}</em> , em que <em>time</em> √© o hor√°rio em que o evento est√° agendado, <em>id</em> √© um contador que aumenta monotonamente.  H√° uma garantia da exclusividade do <em>id</em> para cada evento, mas n√£o h√° garantia de que os valores do <em>id</em> fiquem sem falhas (ou seja, pode haver uma sequ√™ncia: <em>1</em> , <em>2</em> , <em>7</em> , <em>15</em> ). </p><br><p>  Parece que agora podemos armazenar o identificador do √∫ltimo evento de leitura no processo do coordenador e, ao buscar, selecionar eventos com identificadores maiores que o √∫ltimo evento processado. </p><br><p>  Mas aqui o problema aparece imediatamente: os processos de origem podem gravar um evento com um carimbo de data / hora no futuro.  Em seguida, teremos que levar constantemente em conta o conjunto de eventos com pequenos identificadores no processo de coordena√ß√£o, cujo tempo de processamento ainda n√£o chegou. </p><br><p>  Voc√™ pode perceber que os eventos relativos ao hor√°rio atual s√£o divididos em duas classes: </p><br><ol><li>  Eventos com registro de data e hora no passado, mas com um identificador grande.  Eles foram gravados no banco de dados recentemente, depois que processamos esse intervalo de tempo.  Esses s√£o eventos de alta prioridade e precisam ser processados ‚Äã‚Äãprimeiro para que a notifica√ß√£o - que j√° esteja atrasada - n√£o esteja atrasada. </li><li>  Eventos registrados uma vez com carimbos de data e hora pr√≥ximos ao momento atual.  Tais eventos ter√£o um valor baixo de identificador. </li></ol><br><p>  Assim, o estado atual do processo do coordenador √© caracterizado pelo par {state.time, state.id}. </p><br><p>  Acontece que os eventos de alta prioridade est√£o √† esquerda e acima deste ponto (regi√£o rosa) e os eventos normais est√£o √† direita (azul claro): </p><br><p><img src="https://habrastorage.org/webt/n3/x3/q-/n3x3q-kjbxuerrkffffqqnh6hh8.png"></p><br><h2 id="blok-shema">  Fluxograma </h2><br><p>  O algoritmo de trabalho do coordenador √© o seguinte: </p><br><p><img src="https://habrastorage.org/webt/j6/4d/ge/j64dgeq_jubcbyn4e3zu9ekfasy.png"></p><br><p><img src="https://habrastorage.org/webt/8y/ux/si/8yuxsi4nubi7q5yvclqizezo6xq.png"></p><br><p>  Ao estudar o algoritmo, podem surgir perguntas: </p><br><ol><li>  E se o processamento de eventos normais come√ßar e nesse momento chegarem novos eventos no passado (na regi√£o rosa), eles n√£o ser√£o perdidos?  Resposta: eles ser√£o processados ‚Äã‚Äãno pr√≥ximo ciclo de processamento de eventos de alta prioridade.  Eles n√£o podem se perder, pois <em>√©</em> garantido que seu <em>ID</em> seja maior que state.id. </li><li>  E se, ap√≥s o processamento de todos os eventos normais - no momento da mudan√ßa para o processamento de eventos de alta prioridade - chegarem novos eventos com registros de data e hora do intervalo [state.time, state.time + Delta], n√£o os perderemos?  Resposta: eles cair√£o na √°rea rosa, pois ter√£o <em>tempo</em> &lt;state.time e <em>id</em> &gt; state.id: chegaram recentemente e o <em>id est√°</em> aumentando monotonicamente. </li></ol><br><h2 id="primer-raboty-algoritma">  Exemplo de Opera√ß√£o de Algoritmo </h2><br><p>  Vejamos algumas etapas do algoritmo: </p><br><p><img src="https://habrastorage.org/webt/jl/lf/5v/jllf5vhoz843at6gfrtmjmasppw.png"></p><br><p><img src="https://habrastorage.org/webt/z-/ri/zx/z-rizxhocuxtepr7_wnflvgqm14.png"></p><br><p><img src="https://habrastorage.org/webt/oc/dr/pv/ocdrpv4ozmf-pq_itridvcjookc.png"></p><br><p><img src="https://habrastorage.org/webt/uv/xt/aw/uvxtawqbs5ftd8uzebcwqosdrvw.png"></p><br><p><img src="https://habrastorage.org/webt/uo/_s/cg/uo_scglk7ucb_yze8he8b___wro.png"></p><br><p><img src="https://habrastorage.org/webt/ko/8q/24/ko8q24qizzqz5ddew4jbodavvts.png"></p><br><p><img src="https://habrastorage.org/webt/iw/-f/el/iw-felnslp1mdme-thbu_nicbly.png"></p><br><p><img src="https://habrastorage.org/webt/vf/vs/tz/vfvstz05jy9aowpndr-okgajxpk.png"></p><br><h2 id="model">  Modelo </h2><br><p>  Garantiremos que o algoritmo n√£o perca eventos e todas as notifica√ß√µes ser√£o enviadas: comporemos um modelo simples e o verificaremos. </p><br><p>  Para o modelo, usamos o TLA +, mais precisamente o PlusCal, que se traduz em TLA +. </p><br><pre><code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*      \*   (by Daniel Jackson) \* small-scope hypothesis,   \*  ,  ÃÅ   \*     \*   \*  : \* Events -   - ,   \*    [time, id], \*     \*      \*   \* Event_Id -    \*   id \* MAX_TIME -  ,   \*   \* TIME_DELTA -   Delta, \*     \*  variables Events = {}, Event_Id = 0, MAX_TIME = 5, TIME_DELTA \in 1..3 define \*   \*   ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x \*  fold_left/fold_right    RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) (*     (  ) *) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) (* :    *) ToSet(S) == {S[i] : i \in DOMAIN(S)} (*  map    *) MapSet(Op(_), S) == {Op(x) : x \in S} (*   *) \*   id  GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) \*   time  GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) (*   SQL  *) \*     \*   ORDER BY EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \*   time, id \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt;= max_id \* ORDER BY time, id SELECT_HIGH_PRIO(state) == LET \*      \* time &lt;= curr_time \* AND id &gt;= maxt_id selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } IN selected \* SELECT * FROM events \* WHERE time &gt; current_time AND time - Time &lt;= delta_time \* ORDER BY time, id SELECT_NORMAL(state, delta_time) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } IN selected \* Safety predicate \*       ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; \*  -   fair process inserter = "Sources" variable n, t; begin forever: while TRUE do \*      get_time: \*     \* ,     , \*    with evt_time \in 0..MAX_TIME do t := evt_time; end with; \*     ; \*   : \* 1.   . \* 2.  ,    \* Event_Id -   , \*     commit: \* either -     either Events := Events \cup {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process coordinator = "Coordinator" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do \*    high_prio: events := SELECT_HIGH_PRIO(state); \*   process_high_prio: \*          , \*    Events, \*       state.id := MAX({state.id} \union GetIds(events)) || \*      , \*      Events := Events \ events || \*  events  , \*      events := {}; \*  -   normal: events := SELECT_NORMAL(state, TIME_DELTA); process_normal: state.time := MAX({state.time} \union GetTimes(events)) || Events := Events \ events || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ================================</code> </pre> <br><p>  Como voc√™ pode ver, a descri√ß√£o √© relativamente pequena, apesar da se√ß√£o bastante volumosa de defini√ß√µes (define), que pode ser retirada em um m√≥dulo separado e depois reutilizada. </p><br><p>  Nos coment√°rios, tentei explicar o que est√° acontecendo no modelo.  Espero que isso <br>  Eu consegui e n√£o h√° necessidade de pintar o modelo com mais detalhes. </p><br><p>  Gostaria apenas de esclarecer um ponto sobre a atomicidade das transi√ß√µes entre estados e recursos de modelagem. </p><br><p>  A modelagem √© realizada executando etapas at√¥micas dos processos.  Em uma transi√ß√£o, uma etapa at√¥mica de um processo √© realizada, na qual essa etapa pode ser realizada.  A escolha da etapa e do processo √© n√£o determin√≠stica: durante a modelagem, todas as cadeias poss√≠veis de etapas at√¥micas de todos os processos s√£o classificadas. </p><br><p>  A quest√£o pode surgir: o que dizer da modelagem do verdadeiro paralelismo, quando realizamos simultaneamente v√°rias etapas at√¥micas em diferentes processos? </p><br><p>  Esta quest√£o, Leslie Lamport, tem sido respondida h√° muito tempo no livro Especificando Sistemas e outros trabalhos. </p><br><p>  N√£o vou citar a resposta completamente, em resumo a ess√™ncia √© esta: se n√£o houver escala de tempo exata em que cada evento esteja vinculado a um momento espec√≠fico, n√£o haver√° diferen√ßa na modelagem de eventos paralelos como sequenciais de ocorr√™ncia n√£o determin√≠stica, porque sempre podemos assumir que um evento ocorreu antes de outro valor infinitesimal. </p><br><p>  Mas o que √© realmente importante √© a aloca√ß√£o competente de etapas at√¥micas.  Se houver muitos deles, ocorrer√° uma explos√£o combinat√≥ria do espa√ßo de estados.  Se voc√™ executar menos etapas do que o necess√°rio ou selecion√°-las incorretamente, ou seja, a probabilidade de perder um estado / transi√ß√£o inv√°lido (ou seja, perderemos os erros no modelo). </p><br><p>  Para decompor corretamente os processos em etapas at√¥micas, voc√™ precisa ter uma boa id√©ia de como o sistema funciona em termos da depend√™ncia dos processos nos dados e nos mecanismos de sincroniza√ß√£o. </p><br><p>  Como regra, dividir processos em etapas at√¥micas n√£o causa grandes problemas.  E, se sim, indica uma falta de entendimento do problema, e n√£o de problemas com a compila√ß√£o do modelo e a grava√ß√£o da especifica√ß√£o TLA +.  Essa √© outra caracter√≠stica muito √∫til das especifica√ß√µes formais: elas exigem um estudo e an√°lise aprofundados. <br>  um problema  Como regra, se a tarefa for significativa e bem compreendida, n√£o haver√° problemas com sua formaliza√ß√£o. </p><br><h2 id="proverka-modeli">  Verifica√ß√£o do modelo </h2><br><p>  Para modelagem, usarei o TLA-toolbox.  Obviamente, voc√™ pode executar tudo na linha de comando, mas o <em>IDE</em> ainda √© mais conveniente, especialmente para come√ßar a aprender sobre modelagem usando o TLA +. </p><br><p>  A cria√ß√£o do projeto est√° bem descrita em manuais, artigos e livros, os links que citei no final do artigo, para n√£o me repetir.  A √∫nica coisa que chamarei sua aten√ß√£o s√£o as configura√ß√µes de simula√ß√£o. </p><br><p>  O TLC √© um <em>verificador de modelo</em> com <em>verifica√ß√£o</em> expl√≠cita de estado.  √â claro que o espa√ßo de estado deve ser limitado por limites razo√°veis.  Por um lado, deve ser grande o suficiente para poder verificar propriedades que nos interessam e, por outro lado, pequeno o suficiente para que a simula√ß√£o seja conclu√≠da em um per√≠odo de tempo razo√°vel, usando recursos aceit√°veis. </p><br><p>  Este √© um ponto bastante delicado, aqui voc√™ precisa entender as propriedades do sistema e do modelo.  Mas rapidamente vem com a experi√™ncia.  Para iniciantes, voc√™ pode simplesmente definir os limites m√°ximos poss√≠veis que ainda s√£o aceit√°veis ‚Äã‚Äãem termos de tempo e recursos de simula√ß√£o consumidos. </p><br><p>  H√° tamb√©m um modo de verificar n√£o todo o espa√ßo de estados, mas cadeias seletivas at√© uma certa profundidade.  √Äs vezes tamb√©m √© poss√≠vel e necess√°rio usar. </p><br><p>  Retornamos √†s configura√ß√µes de simula√ß√£o. </p><br><p>  Primeiro, definimos as restri√ß√µes no espa√ßo de estados do sistema.  As limita√ß√µes s√£o definidas na se√ß√£o Configura√ß√µes <em>avan√ßadas da</em> simula√ß√£o <em>Op√ß√µes / restri√ß√£o de estado</em> . </p><br><p>  A√≠ indiquei uma express√£o TLA +: <code>Cardinality(Events) &lt;= 5 /\ Event_Id &lt;= 5</code> , <br>  em que Event_Id √© o limite superior do valor do identificador de evento, <code>Cardinality(Events)</code> √© o tamanho do conjunto de registros de eventos (limitado ao modelo base <br>  dados por cinco registros em uma placa). </p><br><p>  Na simula√ß√£o, o TLC examinar√° apenas os estados em que essa f√≥rmula √© verdadeira. </p><br><p>  Voc√™ ainda pode permitir transi√ß√µes de estado v√°lidas ( <em>op√ß√µes avan√ßadas / restri√ß√£o de a√ß√£o</em> ), <br>  mas n√£o precisamos disso. </p><br><p>  Em seguida, indicamos a f√≥rmula TLA + que descreve nosso sistema: <em>Vis√£o geral do modelo / f√≥rmula temporal</em> = <code>Spec</code> , em que <em>Spec</em> √© o nome da f√≥rmula TLA + gerada automaticamente pelo PlusCal (no c√≥digo do modelo acima, n√£o √©: para economizar espa√ßo, n√£o citei o resultado da tradu√ß√£o do PlusCal em TLA +) . </p><br><p>  A pr√≥xima configura√ß√£o que vale a pena prestar aten√ß√£o √© a verifica√ß√£o do impasse. <br>  (marca de sele√ß√£o em <em>Vis√£o geral do modelo / Impasse</em> ).  Quando esse sinalizador √© ativado, o TLC verificar√° o modelo quanto a estados "paralisados", ou seja, aqueles dos quais n√£o h√° transi√ß√µes de sa√≠da.  Se houver tais estados no espa√ßo de estados, isso significa um erro claro no modelo.  Ou no TLC, que, como qualquer outro programa n√£o trivial, n√£o est√° imune a erros :) Na minha pr√°tica (n√£o t√£o grande), ainda n√£o encontrei impasses. </p><br><p>  E, finalmente, para o in√≠cio de todos esses testes, a f√≥rmula de seguran√ßa em <em>Vis√£o geral do modelo / Invariantes</em> = <code>ALL_EVENTS_PROCESSED(state)</code> . </p><br><p>  O TLC verificar√° a validade da f√≥rmula em cada estado e, se ela se tornar falsa, <br>  exibir√° uma mensagem de erro e mostrar√° a sequ√™ncia de estados que levaram ao erro. </p><br><p>  Depois de iniciar o TLC, depois de trabalhar por cerca de 8 minutos, ele relatou "Sem erros".  Isso significa que o modelo √© testado e atende √†s propriedades especificadas. </p><br><p>  O TLC tamb√©m exibe muitas estat√≠sticas interessantes.  Por exemplo, para este modelo, foram obtidos 7 677 824 estados √∫nicos; no total, a TLC analisou 27 109 029 estados; o di√¢metro do espa√ßo de estados √© 47 (este √© o comprimento m√°ximo da cadeia de estados antes da repeti√ß√£o, <br>  dura√ß√£o m√°xima do ciclo de estados n√£o repetidos no gr√°fico de estado e de transi√ß√£o). </p><br><p>  Se dividirmos 27 milh√µes de estados em 8 minutos, obteremos cerca de 56 mil estados por segundo, o que pode n√£o parecer muito r√°pido.  Mas lembre-se de que eu executei a simula√ß√£o em um laptop que funcionava no modo de economia de energia (forcei a frequ√™ncia do n√∫cleo para 800 MHz, porque estava viajando naquele momento em um trem el√©trico) e n√£o otimizei o modelo para a velocidade da simula√ß√£o. </p><br><p>  Existem v√°rias maneiras de acelerar a simula√ß√£o: desde transportar parte do c√≥digo do modelo TLA + para Java e conectar-se ao TLC em tempo real (√© √∫til acelerar todos os tipos de fun√ß√µes auxiliares) at√© executar o TLC nas nuvens e nos clusters (o suporte √† nuvem da Amazon e Azure est√° embutido no pr√≥prio TLC). </p><br><h1 id="vtoraya-optimizaciya">  Segunda otimiza√ß√£o </h1><br><p>  No algoritmo anterior, est√° tudo bem, exceto por alguns problemas: </p><br><ol><li>  At√© processarmos todos os eventos da zona azul no intervalo <code>[state.time, state.time + Delta]</code> , n√£o podemos passar para eventos de alta prioridade.  Ou seja, eventos tardios se atrasar√£o ainda mais.  E geralmente o atraso √© imprevis√≠vel.  Por esse motivo, state.time pode ficar muito atr√°s do hor√°rio atual e essa √© a causa do pr√≥ximo problema. </li><li>  Eventos chegando na regi√£o de eventos normais podem estar atrasados ‚Äã‚Äã( <em>id</em> &gt; state.id).  Eles j√° s√£o de alta prioridade e devem ser considerados eventos da regi√£o rosa, e ainda os consideramos normais e os tratamos como normais. </li><li>  √â dif√≠cil organizar o cache de eventos e a reposi√ß√£o de cache (leitura do banco de dados). </li></ol><br><p>  Se os dois primeiros pontos forem √≥bvios, o terceiro provavelmente levantar√° o maior n√∫mero de perguntas.  Vamos insistir nisso com mais detalhes. </p><br><p>  Suponha que desejemos primeiro ler um n√∫mero fixo de eventos na mem√≥ria e depois process√°-los. </p><br><p>  Ap√≥s o processamento, queremos marcar os eventos no banco de dados com as consultas de bloco como processadas, pois se voc√™ trabalhar n√£o com blocos, mas com eventos √∫nicos, n√£o haver√° grande ganho com o cache. </p><br><p>  Suponha que tenhamos processado parte dos blocos e desejamos complementar o cache.  Ent√£o, se eventos atrasados ‚Äã‚Äãde alta prioridade chegarem durante o processamento, podemos process√°-los mais cedo. </p><br><p>  Ou seja, √© muito desej√°vel poder ler eventos em pequenos blocos para processar os atrasados ‚Äã‚Äão mais r√°pido poss√≠vel, mas atualizar o atributo de processamento no banco de dados com grandes blocos de uma s√≥ vez - para obter efici√™ncia. </p><br><p>  O que fazer neste caso? </p><br><p>  Tente trabalhar com o banco de dados em pequenos blocos com uma √°rea azul e rosa e mova o ponto de estado em pequenas etapas. </p><br><p>  Assim, o cache foi introduzido e lido nos dados do banco de dados; ap√≥s cada leitura, o ponto de estado foi deslocado para n√£o reler os eventos j√° lidos. </p><br><p>  Agora, o algoritmo se tornou um pouco mais complicado, come√ßamos a ler em por√ß√µes limitadas. </p><br><h2 id="blok-shema-1">  Fluxograma </h2><br><p><img src="https://habrastorage.org/webt/as/8n/qk/as8nqk0dmos8bsiwiigzphb7gns.png"></p><br><p><img src="https://habrastorage.org/webt/wn/9x/yx/wn9xyxfi4j2021hibcqxe3abhn8.png"></p><br><p>  Nesse algoritmo, pode-se observar que, devido √† restri√ß√£o de blocos de eventos leg√≠veis, o atraso m√°ximo na transi√ß√£o do processamento de baixa prioridade para o processamento de alta prioridade ser√° igual ao tempo m√°ximo de processamento do bloco. </p><br><p>  Ou seja, agora podemos ler eventos no cache em pequenos blocos e controlar o atraso m√°ximo na transi√ß√£o para o processamento de eventos de alta prioridade atrav√©s do controle do tamanho m√°ximo do bloco para leitura. </p><br><h2 id="primer-raboty-algoritma-1">  Exemplo de Opera√ß√£o de Algoritmo </h2><br><p>  Vejamos o algoritmo no trabalho, em etapas.  Por conveni√™ncia, tome <code>LIMIT = 2</code> . </p><br><p><img src="https://habrastorage.org/webt/-i/u8/qz/-iu8qzxfabbn9gcig_ekb1xhabu.png"></p><br><p><img src="https://habrastorage.org/webt/3x/if/ju/3xifju7ktzac6eyyutbhfanpufs.png"></p><br><p><img src="https://habrastorage.org/webt/ab/dg/o7/abdgo7ieinh8ddx6tnthfcsrwre.png"></p><br><p><img src="https://habrastorage.org/webt/ei/qg/al/eiqgal0lfwfiwtdltnb-e1bjyc0.png"></p><br><p><img src="https://habrastorage.org/webt/hp/2i/kd/hp2ikd4mgcqsswoiwwexz_kmp-e.png"></p><br><p><img src="https://habrastorage.org/webt/tq/ct/fv/tqctfvtnrqo939zqut2-8lwjale.png"></p><br><p><img src="https://habrastorage.org/webt/yk/3j/jk/yk3jjkf9htxfmdvwsa1dyrogqqo.png"></p><br><p><img src="https://habrastorage.org/webt/ym/9d/vt/ym9dvt1_ykho82n4xhxwtlbkeow.png"></p><br><p>  Acontece que o problema est√° resolvido?  Mas n√£o.  (√â claro que, se o problema foi completamente resolvido nesta fase, ent√£o <br>  este artigo n√£o teria sido :)) </p><br><h2 id="oshibka">  O erro? </h2><br><p>  Nesta forma, o algoritmo funcionou por um longo tempo.  Todos os testes foram bem.  Tamb√©m n√£o houve problemas na produ√ß√£o. </p><br><p>  Mas o desenvolvedor do algoritmo e sua implementa√ß√£o (meu colega Peter Reznikov) √© muito experiente e, intuitivamente, sentiu que havia algo errado aqui.  Portanto, um verificador foi feito pr√≥ximo ao c√≥digo principal, que verificava de vez em quando em um cron√¥metro para ver se havia algum evento perdido, e <br>  se houver, eu os processei. </p><br><p>  Nesta forma, o sistema funcionou com sucesso.  √â verdade que ningu√©m mantinha estat√≠sticas sobre o n√∫mero de eventos selecionados pelo verificador.  Infelizmente, n√£o sabemos quantas falhas foram associadas ao processamento prematuro de eventos. </p><br><p>  Eu implementei uma fila semelhante de objetos com limite de tempo.  Discutindo a implementa√ß√£o e otimiza√ß√£o de algoritmos com Peter Reznikov, falamos sobre esse algoritmo para trabalhar com eventos.  Eles duvidaram que o algoritmo esteja correto.  Decidimos fazer um modelo pequeno para confirmar ou dissipar d√∫vidas.  Como resultado, encontramos um erro. </p><br><h2 id="model-1">  Modelo </h2><br><p>  Antes de desmontar o rastreamento com um erro, fornecerei o c√≥digo fonte do modelo no qual o erro foi detectado. </p><br><p>  As diferen√ßas em rela√ß√£o ao modelo anterior s√£o muito pequenas, h√° apenas um limite no tamanho dos blocos de leitura: o operador Limit √© adicionado e, portanto, os operadores de sele√ß√£o de eventos s√£o alterados. </p><br><p>  Para economizar espa√ßo, deixei coment√°rios apenas nas partes alteradas do modelo. </p><br><pre> <code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*    LIMIT, \*     \*     \*   variables Events = {}, Event_Id = 0, MAX_TIME = 5, LIMIT \in 1..3, TIME_DELTA \in 1..2 define ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) Limit(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt; max_id \* ORDER BY id \* LIMIT limit SELECT_HIGH_PRIO(state, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } \*   Id sorted == SortSeq(ToSeq(selected), EventsOrderById) \*    limited == Limit(sorted, limit) IN ToSet(limited) \* SELECT * FROM events \* WHERE time &gt; current_time \* AND time - Time &lt;= delta_time \* ORDER BY time, id \* LIMIT limit SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events: /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } \*   sorted == SortSeq(ToSeq(selected), EventsOrder) \*   limited == Limit(sorted, limit) IN ToSet(limited) ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, LIMIT) new_limit == LIMIT - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, TIME_DELTA, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events))] || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Um leitor atento pode perceber que, al√©m de introduzir Limit, os r√≥tulos em event_processor tamb√©m foram alterados.  O objetivo √© um pouco melhor para simular c√≥digo real que duas sele√ß√µes executam em uma transa√ß√£o, ou seja, pode-se dizer que a sele√ß√£o de eventos √© realizada atomicamente. </p><br><p>  Bem, se encontrarmos um erro em um modelo com opera√ß√µes at√¥micas maiores, isso praticamente garante que o mesmo erro ocorra no mesmo modelo, mas com etapas at√¥micas menores (uma afirma√ß√£o bastante forte, mas acho que √© intuitiva; embora deve ser bom se n√£o for provado e depois verificado em uma ampla sele√ß√£o de modelos). </p><br><h2 id="proverka-modeli-1">  Verifica√ß√£o do modelo </h2><br><p>  Iniciamos a simula√ß√£o com os mesmos par√¢metros da primeira modalidade. </p><br><p>  E temos uma viola√ß√£o da propriedade ALL_EVENTS_PROCESSED na 19¬™ etapa da simula√ß√£o ao pesquisar em largura. </p><br><p>  Para dados iniciais fornecidos (esse √© um espa√ßo de estado muito pequeno), o erro na 19¬™ etapa indica que o erro √© muito raro e dif√≠cil de detectar, pois antes disso todas as cadeias de estados com comprimento inferior a 19 eram examinadas. </p><br><p>  Portanto, esse erro √© dif√≠cil de detectar nos testes.  Somente se voc√™ souber onde procurar e selecione especificamente testes e cabanas tempor√°rias. </p><br><p>  N√£o trago a rota inteira para economizar espa√ßo e tempo.  Aqui est√° um segmento de v√°rios estados junto com um erro: </p><br><p><img src="https://habrastorage.org/webt/1g/xq/en/1gxqen3cvdftawczsxb5apskzlc.png"></p><br><p><img src="https://habrastorage.org/webt/5r/b6/ml/5rb6mlga8u0rfalc1_3klnb6-ky.png"></p><br><p><img src="https://habrastorage.org/webt/5_/cz/n4/5_czn4pqrkbkhy6uocf3zllz39w.png"></p><br><p><img src="https://habrastorage.org/webt/_v/s8/d6/_vs8d6feegcimnw9bla8ylm-878.png"></p><br><p><img src="https://habrastorage.org/webt/wo/0j/qu/wo0jquth7jszanamlk7l3dpkspc.png"></p><br><h2 id="analiz-i-ispravlenie">  An√°lise e Corre√ß√£o </h2><br><p>  O que aconteceu? </p><br><p>  Como voc√™ pode ver, o erro se manifestou no fato de termos perdido o evento {2, 3} devido ao fato de que o limite terminou no evento {2, 1} e, depois disso, alteramos o estado do coordenador.  Isso pode acontecer apenas se em um momento houver v√°rios eventos. </p><br><p>  √â por isso que o erro foi ilus√≥rio nos testes.  Para sua manifesta√ß√£o, √© necess√°rio que coisas muito raras coincidam: </p><br><ol><li>  V√°rios eventos atingiram o mesmo ponto no tempo. </li><li>  O limite na sele√ß√£o de eventos terminou antes do momento de ler todos esses eventos. </li></ol><br><p>  O erro pode ser corrigido com relativa facilidade se o estado do coordenador for expandido um pouco: adicione a hora e o identificador do √∫ltimo evento de leitura da √°rea normal do evento com o ID m√°ximo se o hor√°rio desse evento corresponder ao pr√≥ximo valor state.time. </p><br><p>  Se n√£o houver esse evento, definimos o estado extra (extra_state) para um estado inv√°lido (UNDEF_EVT) e n√£o o levamos em considera√ß√£o ao trabalhar. </p><br><p>  Os eventos da regi√£o normal que n√£o foram processados ‚Äã‚Äãna etapa anterior do coordenador, consideraremos j√° alta prioridade e, portanto, corrigiremos a sele√ß√£o do predicado de alta prioridade e seguran√ßa. </p><br><p>  Seria poss√≠vel introduzir outra √°rea intermedi√°ria entre alta prioridade e normal e alterar o algoritmo.  Primeiro, ele processa os de alta prioridade, depois os intermedi√°rios, e depois passa para os normais com a subsequente mudan√ßa de estado. </p><br><p>  Mas essas mudan√ßas levariam a um volume maior de refatora√ß√£o com benef√≠cios n√£o √≥bvios (o algoritmo ser√° um pouco mais claro; outras vantagens n√£o s√£o vis√≠veis imediatamente). </p><br><p>  Portanto, decidimos ajustar apenas levemente o estado atual e a sele√ß√£o de eventos do banco de dados. </p><br><h2 id="skorrektirovannaya-model">  Modelo ajustado </h2><br><p>  Aqui est√° o modelo corrigido. </p><br><pre> <code class="plaintext hljs">------------------- MODULE events ------------------- EXTENDS Naturals, FiniteSets, Sequences, TLC \*        CONSTANTS MAX_TIME, LIMIT, TIME_DELTA (* --algorithm Events variables Events = {}, Limit \in LIMIT, Delta \in TIME_DELTA, Event_Id = 0 define \*    \*  ,   extra_state UNDEF_EVT == [time |-&gt; MAX_TIME + 1, id |-&gt; 0] ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) TakeN(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result (* SELECT * FROM events WHERE time &lt;= curr_time AND id &gt; max_id ORDER BY id Limit limit *) SELECT_HIGH_PRIO(state, limit, extra_state) == LET \*      \* time &lt;= curr_time \* AND id &gt; maxt_id selected == {e \in Events : \/ /\ e.time &lt;= state.time /\ e.id &gt;= state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id} sorted == \*  SortSeq(ToSeq(selected), EventsOrderById) limited == TakeN(sorted, limit) IN ToSet(limited) SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } sorted == SortSeq(ToSeq(selected), EventsOrder) limited == TakeN(sorted, limit) IN ToSet(limited) \*    extra_state UpdateExtraState(events, state, extra_state) == LET exact == {evt \in events : evt.time = state.time} IN IF exact # {} THEN CHOOSE evt \in exact : \A e \in exact: e.id &lt;= evt.id ELSE UNDEF_EVT \*    extra_state ALL_EVENTS_PROCESSED(state, extra_state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt; state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable events = {}, state = ZERO_EVT, extra_state = UNDEF_EVT; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, Limit, extra_state) new_limit == Limit - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, Delta, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events)) ]; extra_state := UpdateExtraState(events, state, extra_state) || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Como voc√™ pode ver, as altera√ß√µes s√£o muito pequenas: </p><br><ol><li>  Dados extras adicionados ao estado extra_state. </li><li>  Alterada a sele√ß√£o de eventos de alta prioridade. </li><li>   UpdateExtraState   extra_state. </li><li>  <em>safety</em> -    . </li></ol><br><h2 id="modelirovanie">  </h2><br><p>    ,   . ,      (,  ,    ,     ). <br>       ,       ,  TLA+/TLC .  :) </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>     , ,     ( , ,  ,    ). </p><br><p>  ,            ,        TLA+/TLC,     . ,    . </p><br><p>         TLA+/TLC  ,   ,           ( ,     )  . </p><br><p>  ,     ,     ,  TLA+/TLC                . </p><br><h1 id="bibliografiya">  </h1><br><h2 id="knigi">  Livros </h2><br><h3 id="dlya-pogruzheniya-v-oblast">     </h3><br><p>   ,    ,   ,    .      . </p><br><ol><li><p> Michael Jackson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problem Frames: Analysing &amp; Structuring Software Development Problems</a> </p><br><p>      (  !),     .   ,   .      ,        . </p><br></li><li><p> Hillel Wayne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Practical TLA+: Planning Driven Development</a> </p><br><p>     TLA+/PlusCal     .  ,    .      .         :    . </p><br></li><li><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MODEL CHECKING.      </a> </p><br><p>     .  ,    ,  .      ,            . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers</a> </p><br><p>    TLA+.   ,   .      :     ,   .  ,     TLA+  ,    . </p><br></li></ol><br><h3 id="primery-iz-promyshlennosti">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Formal Development of a Network-Centric RTOS</a> </p><br><p>    TLA+          ( <em>RTOS</em> )       TLC. </p><br><p>      ,      .   ,   TLA+      ,             ,    <em>RTOS</em>   ‚Äî Virtuoso.       ,       . </p><br><p>          ,           (, ,  ,  ,    ). </p><br></li><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">w Amazon Web Services Uses Formal Methods</a> </p><br><p>   TLA+      AWS.        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://lamport.azurewebsites.net/tla/amazon-excerpt.html</a> </p><br></li></ol><br><h2 id="internet">  </h2><br><h3 id="blogi">  </h3><br><ol><li><p> Hillel Wayne (  "Practical TLA+") <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br><p>     .  ,  .   ,  -   . </p><br></li><li><p> Ron Pressler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br><p>   .        .  ,      TLA+.       TLA+,    <em>computer</em> <em>science</em>    . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br><p>      TLA+  <em>computer</em> <em>science</em> .  <em>TLA+</em>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br></li></ol><br><h3 id="prezentacii-i-videokursy">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">. . , . . , . . .      </a> </p><br><p>  ,   ,       . </p><br></li><li><p>   TLA+,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br><p>   ,     TLA+. ,       TLA+. </p><br></li><li><p> Hillel Wayne </p><br><p>      Hillel Wayne  .      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Two Hardest Problems in CS (June 5, 2018)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Everything about distributed systems is terrible | Code Mesh LDN 18</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Designing Distributed Systems with TLA+ | √òredev 2018</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tackling Concurrency Bugs with TLA+</a> </li></ul><br></li><li><p> Ron Pressler </p><br><p>  ,   Hillel Wayne,     .  ,    . Ron Pressler      . ÃÅ       ,    ,     . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Practice and Theory of TLA+</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Why Writing Correct Software Is Hard and Why Math (Alone) Won't Help Us</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">On the Nature of Abstraction</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Finite of sense &amp; infinite of thought | Code Mesh LDN 18</a> </li></ul><br></li></ol><br><h3 id="modelirovanie-1">  </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLA toolbox</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLAPS</a> :        TLA+  <br>           .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alloy Analyzer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471012/">https://habr.com/ru/post/pt471012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471000/index.html">Brinquedos de madeira, a √∫ltima parte - 1997</a></li>
<li><a href="../pt471004/index.html">Brinquedos de madeira - um ep√≠logo que permanece pregado no teto</a></li>
<li><a href="../pt471006/index.html">US $ 500 por m√™s: em que os benefici√°rios da renda b√°sica incondicional gastam seu dinheiro?</a></li>
<li><a href="../pt471008/index.html">Vamos falar sobre monitoramento: grava√ß√£o ao vivo do podcast Devops Deflope com a New Relic na reuni√£o de 23 de outubro</a></li>
<li><a href="../pt471010/index.html">Algoritmo de Grover e pesquisa de dados</a></li>
<li><a href="../pt471014/index.html">Estamos fazendo um drone de √°gua aut√¥nomo, ou como eu sonhava em ajudar Baikal, mas n√£o sou uma Gazprom. Parte 1</a></li>
<li><a href="../pt471016/index.html">Design de banco de dados. Melhores pr√°ticas</a></li>
<li><a href="../pt471018/index.html">Compara√ß√£o do desempenho de PC e smartphone, incluindo o iPhone 11</a></li>
<li><a href="../pt471020/index.html">Como encontrar um bug em um microprocessador lan√ßado h√° 35 anos</a></li>
<li><a href="../pt471022/index.html">Revelando um segredo de 140 anos em f√≠sica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>