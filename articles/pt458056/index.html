<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòØ üë®üèø‚Äçüî¨ üöè A grande entrevista com Martin Kleppmann: ‚ÄúDescobrindo o futuro dos sistemas de dados distribu√≠dos‚Äù ü§™ üï∏Ô∏è ü§∏üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dr. Martin Kleppmann √© pesquisador em sistemas distribu√≠dos da Universidade de Cambridge e autor do aclamado "Designing Data-Intensive Applications" (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A grande entrevista com Martin Kleppmann: ‚ÄúDescobrindo o futuro dos sistemas de dados distribu√≠dos‚Äù</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/458056/"><img src="https://habrastorage.org/webt/ad/ax/dn/adaxdnyqcoiagri2sgsuibdstpy.jpeg"><br><br>  <b>Dr.</b>  <b>Martin Kleppmann</b> √© pesquisador em sistemas distribu√≠dos da Universidade de Cambridge e autor do aclamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Designing Data-Intensive Applications"</a> (O'Reilly Media, 2017). <br><br>  Kevin Scott, CTO da Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse uma vez</a> : ‚ÄúEste livro deve ser leitura obrigat√≥ria para engenheiros de software.  "Projetar aplicativos com uso intensivo de dados √© um recurso raro que conecta teoria e pr√°tica para ajudar os desenvolvedores a tomar decis√µes inteligentes ao projetar e implementar a infraestrutura e os sistemas de dados". <br><br>  Os principais interesses de pesquisa de Martin incluem software de colabora√ß√£o, CRDTs e verifica√ß√£o formal de algoritmos distribu√≠dos.  Anteriormente, ele era engenheiro de software e empreendedor de v√°rias empresas de Internet, incluindo LinkedIn e Rapportive, onde trabalhou em infraestrutura de dados em larga escala. <br><br>  <b>Vadim Tsesko</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@incubos</a> ) √© um engenheiro de software l√≠der da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Odnoklassniki</a> que trabalha na equipe da Plataforma Principal.  Os interesses cient√≠ficos e de engenharia da Vadim incluem sistemas distribu√≠dos, data warehouses e verifica√ß√£o de sistemas de software. <br><br><h2>  Conte√∫do: </h2><br><ul><li>  Mudando de neg√≥cios para pesquisa acad√™mica; <br></li><li>  Discuss√£o sobre "Design de aplicativos intensivos em dados"; <br></li><li>  Bom senso contra exageros artificiais e marketing agressivo; <br></li><li>  Armadilhas do teorema da PAC e outros erros da ind√∫stria; <br></li><li>  Benef√≠cios da descentraliza√ß√£o; <br></li><li>  Blockchains, Dat, IPFS, Filecoin, WebRTC; <br></li><li>  Novos CRDTs.  Verifica√ß√£o formal com Isabelle; <br></li><li>  Origem do evento.  Abordagem de baixo n√≠vel.  Transa√ß√µes XA <br></li><li>  Apache Kafka, PostgreSQL, Memcached, Redis, Elasticsearch; <br></li><li>  Como aplicar todas essas ferramentas √† vida real; <br></li><li>  P√∫blico-alvo esperado das palestras de Martin e da confer√™ncia Hydra. <br></li></ul><br><a name="habracut"></a><br><hr><br><h2>  Passando da pesquisa comercial para a acad√™mica </h2><br>  <b>Vadim</b> : A primeira pergunta que gostaria de fazer √© realmente importante para mim.  Voc√™ fundou o Go Test It e o Rapportive e projetava e projetava sistemas de grande escala no LinkedIn h√° um tempo.  Ent√£o voc√™ decidiu mudar da engenharia industrial para a academia.  Poderia explicar a motiva√ß√£o para essa decis√£o?  O que voc√™ ganhou e o que teve que sacrificar? <br><br>  <b>Martin</b> : Tem sido um processo muito interessante.  Como voc√™ parece sugerir, poucas pessoas mudam nessa dire√ß√£o.  Muitas pessoas v√£o da academia para a ind√∫stria, mas n√£o muitas.  O que √© compreens√≠vel, porque eu tive que fazer um corte salarial bastante grande para voltar √† academia.  Mas o que eu realmente amo em pesquisa √© a liberdade de trabalhar em t√≥picos que acho interessantes e que considero importantes, mesmo que esses t√≥picos n√£o levem imediatamente a um produto comercialmente vi√°vel nos pr√≥ximos 6 meses.  Obviamente, em uma empresa, o material que voc√™ cria precisa se transformar em um produto que pode ser vendido de uma forma ou de outra.  Por outro lado, as coisas nas quais estou trabalhando agora s√£o t√≥picos realmente importantes para o futuro de como constru√≠mos software e como a Internet funciona.  Mas ainda n√£o entendemos esses t√≥picos o suficiente para come√ßar a criar produtos comerciais: ainda estamos tentando descobrir, fundamentalmente, como essas tecnologias devem ser.  E como essa √© uma pesquisa fundamental, percebi que √© melhor fazer isso em uma universidade do que tentar fazer isso em uma empresa, porque em uma universidade sou livre para trabalhar em coisas que podem n√£o se tornar comercialmente vi√°veis ‚Äã‚Äãpor mais dez anos, e tudo bem  N√£o h√° problema em trabalhar com um horizonte de tempo muito maior quando voc√™ estiver pesquisando. <br><br><hr><br><h2>  "Projetando aplicativos intensivos em dados" </h2><br>  <b>Vadim</b> : Definitivamente voltaremos aos seus interesses atuais de pesquisa.  Enquanto isso, vamos falar sobre seu √∫ltimo livro, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Designing Data-Intensive Applications</a> .  Sou um grande f√£ do seu livro e acredito que seja um dos melhores guias para a constru√ß√£o de sistemas distribu√≠dos modernos.  Voc√™ cobriu quase todas as realiza√ß√µes not√°veis ‚Äã‚Äãatualizadas. <br><br>  <b>Martin</b> : Obrigado, fico feliz que voc√™ ache √∫til. <br><br>  <b>Vadim</b> : Apenas para aqueles leitores azarados que ainda n√£o leram seu livro, voc√™ poderia citar v√°rias realiza√ß√µes importantes no campo de sistemas distribu√≠dos hoje em dia? <br><br>  <b>Martin</b> : Bem, o objetivo do livro n√£o √© tanto explicar uma tecnologia espec√≠fica;  o objetivo √© fornecer um guia para todo o cen√°rio de diferentes sistemas que s√£o usados ‚Äã‚Äãpara armazenar e processar dados.  Existem muitos bancos de dados, processadores de fluxo, ferramentas de processamento em lote, todos os tipos de ferramentas de replica√ß√£o e assim por diante, e √© realmente dif√≠cil obter uma vis√£o geral.  Se voc√™ est√° tentando criar um aplicativo espec√≠fico, √© realmente dif√≠cil saber qual banco de dados voc√™ deve usar e quais ferramentas s√£o as mais apropriadas para o problema que voc√™ est√° tentando resolver.  Muitos livros de computa√ß√£o existentes simplesmente n√£o responderam a esse problema de maneira satisfat√≥ria.  Descobri que, se voc√™ est√° lendo um livro sobre Cassandra, por exemplo, ele explica por que Cassandra √© maravilhosa, mas geralmente n√£o fala sobre coisas para as quais n√£o √© um bom ajuste.  Ent√£o, o que eu realmente queria fazer neste livro foi identificar as principais perguntas que voc√™ precisa se perguntar se est√° tentando construir algum tipo de sistema em grande escala.  E, respondendo a essas perguntas, voc√™ pode ajudar a descobrir quais tecnologias s√£o apropriadas e quais s√£o menos apropriadas para o problema espec√≠fico que voc√™ est√° tentando resolver - porque, em geral, n√£o existe uma tecnologia perfeita para tudo.  E assim, o livro est√° tentando ajud√°-lo a descobrir os pr√≥s e contras de diferentes tecnologias em diferentes configura√ß√µes. <br><br><hr><br><h2>  Bom senso contra hype artificial e marketing agressivo </h2><br>  <b>Vadim</b> : De fato, muitas vezes - se n√£o sempre - existem muitas tecnologias com fun√ß√µes, recursos e modelos de dados sobrepostos.  E voc√™ n√£o pode acreditar em todas essas chav√µes de marketing.  Voc√™ precisa ler os white papers para aprender os internos e at√© tentar ler o c√≥digo-fonte para entender como ele funciona exatamente. <br><br>  <b>Martin</b> : E eu descobri que voc√™ frequentemente tem que ler nas entrelinhas, porque muitas vezes a documenta√ß√£o realmente n√£o diz para quais coisas um determinado banco de dados √© ruim.  A verdade √© que todo banco de dados √© p√©ssimo em algum tipo de carga de trabalho, a quest√£o √© apenas saber quais s√£o eles.  Ent√£o, sim, √†s vezes voc√™ precisa ler as diretrizes de implanta√ß√£o para as pessoas das opera√ß√µes e tentar fazer engenharia reversa a partir daquilo que realmente est√° acontecendo no sistema. <br><br>  <b>Vadim</b> : Voc√™ acha que o setor n√£o possui o vocabul√°rio comum ou um conjunto de crit√©rios para comparar solu√ß√µes diferentes para o mesmo problema?  Coisas semelhantes s√£o chamadas por nomes diferentes, algumas coisas s√£o omitidas que devem sempre ser claras e declaradas explicitamente, como garantias de transa√ß√£o.  O que voc√™ acha? <br><br>  <b>Martin</b> : Sim, acho que um problema que nossa ind√∫stria tem √© que, frequentemente, quando as pessoas falam sobre uma ferramenta espec√≠fica, h√° muita publicidade sobre tudo.  O que √© compreens√≠vel, porque as ferramentas s√£o feitas por v√°rias empresas e, obviamente, essas empresas querem promover seus produtos; portanto, essas empresas enviar√£o pessoas para confer√™ncias para falar sobre o qu√£o maravilhoso √© seu produto.  Ser√° disfar√ßado de conversa sobre tecnologia, mas essencialmente ainda √© uma atividade de vendas.  Como ind√∫stria, poder√≠amos realmente fazer com mais honestidade as vantagens e desvantagens de algum produto.  E parte disso requer uma terminologia comum, porque, caso contr√°rio, voc√™ simplesmente n√£o pode comparar as coisas em p√© de igualdade.  Mas, al√©m de uma terminologia compartilhada, precisamos de maneiras de raciocinar sobre coisas nas quais certas tecnologias s√£o boas ou ruins. <br><br><hr><br><h2>  Armadilhas do teorema da PAC e outros erros da ind√∫stria </h2><br>  <b>Vadim</b> : Minha pr√≥xima pergunta √© bastante controversa.  Voc√™ poderia citar algum erro grave no setor em que se deparou durante sua carreira?  Talvez tecnologias supervalorizadas ou solu√ß√µes amplamente praticadas das quais dev√≠amos nos livrar h√° muito tempo?  Pode ser um mau exemplo, mas compare o JSON sobre HTTP / 1.1 com o gRPC muito mais eficiente sobre HTTP / 2.  Ou existe um ponto de vista alternativo? <br><br>  <b>Martin</b> : Eu acho que em muitos casos existem boas raz√µes para uma tecnologia fazer uma coisa e n√£o outra.  Ent√£o, eu estou muito hesitante em chamar as coisas de erros, porque na maioria dos casos √© uma quest√£o de trade-offs.  No seu exemplo de JSON sobre HTTP / 1.1 versus buffers de protocolo sobre HTTP / 2, acho que existem argumentos bastante razo√°veis ‚Äã‚Äãpara os dois lados.  Por exemplo, se voc√™ deseja usar Buffers de Protocolo, precisa definir seu esquema, e um esquema pode ser uma coisa maravilhosa, pois ajuda a documentar exatamente qual comunica√ß√£o est√° acontecendo.  Mas algumas pessoas acham os esquemas irritantes, especialmente se est√£o nos est√°gios iniciais de desenvolvimento e est√£o mudando os formatos de dados com muita frequ√™ncia.  Ent√£o a√≠ est√°, h√° uma quest√£o de trade-offs;  em algumas situa√ß√µes, uma √© melhor, em outras, a outra √© melhor. <br><br>  Em termos de erros reais que considero simplesmente ruins, h√° apenas um n√∫mero bastante pequeno de coisas.  Uma opini√£o que tenho √© que o teorema da PAC √© fundamentalmente ruim e simplesmente n√£o √© √∫til.  Sempre que as pessoas usam o Teorema do CAP para justificar decis√µes de design, acho que muitas vezes est√£o interpretando mal o que o CAP est√° realmente dizendo ou afirmando o √≥bvio de uma maneira.  A CAP como teorema tem um problema de que est√° realmente apenas afirmando o √≥bvio.  Al√©m disso, ele fala sobre apenas um modelo de consist√™ncia muito definido, ou seja, linearizabilidade, e um modelo de disponibilidade muito definido, que √©: voc√™ deseja que cada r√©plica esteja totalmente dispon√≠vel para leitura e grava√ß√£o, mesmo que n√£o possa se comunicar com outras r√©plicas.  Essas s√£o defini√ß√µes razo√°veis, mas s√£o muito estreitas e muitos aplicativos simplesmente n√£o caem no caso de precisar precisamente dessa defini√ß√£o de consist√™ncia ou precisamente dessa defini√ß√£o de disponibilidade.  E para todos os aplicativos que usam uma defini√ß√£o diferente dessas palavras, o Teorema do CAP n√£o diz nada.  √â simplesmente uma declara√ß√£o vazia.  Para mim, isso √© um erro. <br><br>  E enquanto estamos reclamando, se voc√™ est√° me pedindo para citar erros, outro grande erro que eu vejo na ind√∫stria de tecnologia √© a minera√ß√£o de criptomoedas, que eu acho que √© um desperd√≠cio t√£o flagrante de eletricidade.  Eu simplesmente n√£o consigo entender por que as pessoas pensam que √© uma boa ideia. <br><br>  <b>Vadim</b> : Falando sobre o teorema do CAP, muitas tecnologias de armazenamento s√£o realmente ajust√°veis, em termos de coisas como AP ou CP.  Voc√™ pode escolher o modo em que operam. <br><br>  <b>Martin</b> : Sim.  Al√©m disso, existem muitas tecnologias que n√£o s√£o consistentes nem dispon√≠veis sob a defini√ß√£o estrita do Teorema da PAC.  Eles s√£o literalmente apenas P!  Nem CP, nem CA, nem AP, apenas P. Ningu√©m diz isso, porque isso pareceria ruim, mas honestamente, essa poderia ser uma decis√£o de design perfeitamente razo√°vel a ser tomada.  Existem muitos sistemas para os quais isso √© realmente totalmente bom.  Essa √© realmente uma das raz√µes pelas quais eu acho que o CAP √© uma maneira in√∫til de falar sobre as coisas: porque h√° uma grande parte do espa√ßo de design que ele simplesmente n√£o captura, onde h√° bons projetos perfeitamente razo√°veis ‚Äã‚Äãpara o software que ele usa. simplesmente n√£o permite que voc√™ fale. <br><hr><br><h2>  Benef√≠cios da descentraliza√ß√£o </h2><br>  <b>Vadim</b> : Falando sobre aplicativos com uso intensivo de dados hoje, que outros grandes desafios, problemas n√£o resolvidos ou t√≥picos importantes de pesquisa voc√™ pode citar?  At√© onde eu sei, voc√™ √© um dos principais defensores da computa√ß√£o e armazenamento descentralizados. <br><br>  <b>Martin</b> : Sim.  Uma das teses por tr√°s da minha pesquisa √© que, no momento, confiamos demais em servidores e centraliza√ß√£o.  Se voc√™ pensar em como a Internet foi originalmente projetada no dia em que evoluiu da ARPANET, ela foi concebida como uma rede muito resiliente, na qual os pacotes poderiam ser enviados por v√°rias rotas diferentes e ainda assim chegariam ao destino.  E se uma bomba nuclear atingisse uma cidade americana em particular, o restante da rede continuaria funcionando, pois apenas trafegaria pelas partes com falha do sistema.  Este foi um projeto da Guerra Fria. <br><br>  E ent√£o decidimos colocar tudo na nuvem, e agora basicamente tudo tem que passar por um dos datacenters da AWS, como us-east-1 em algum lugar da Virg√≠nia.  N√≥s retiramos esse ideal de poder usar descentralmente v√°rias partes diferentes da rede, e colocamos nesses servidores nos quais tudo depende, e agora √© extremamente centralizado.  Por isso, estou interessado em descentraliza√ß√£o, no sentido de transferir parte do poder e controle dos dados desses servidores e voltar aos usu√°rios finais. <br><br>  Uma coisa que quero acrescentar neste contexto √© que muitas pessoas falando sobre descentraliza√ß√£o est√£o falando sobre coisas como criptomoedas, porque tamb√©m est√£o tentando uma forma de descentraliza√ß√£o pela qual o controle √© desviado de uma autoridade central como um banco e para uma rede de n√≥s cooperantes.  Mas esse n√£o √© realmente o tipo de descentraliza√ß√£o que me interessa: acho que essas criptomoedas ainda s√£o extremamente centralizadas, no sentido de que se voc√™ deseja fazer uma transa√ß√£o Bitcoin, precisa faz√™-lo na rede Bitcoin - voc√™ precisa usar a rede do Bitcoin, para que tudo seja centralizado nessa rede espec√≠fica.  O modo como ele √© constru√≠do √© descentralizado no sentido de que n√£o possui um √∫nico n√≥ de controle, mas a rede como um todo √© extremamente centralizada, pois qualquer transa√ß√£o que voc√™ precise fazer deve fazer atrav√©s dessa rede.  Voc√™ n√£o pode fazer isso de outra maneira.  Eu sinto que ainda √© uma forma de centraliza√ß√£o. <br><br>  No caso de uma criptomoeda, essa centraliza√ß√£o pode ser inevit√°vel, porque voc√™ precisa fazer coisas como evitar gastos duplos, e isso √© dif√≠cil sem uma rede que alcance consenso sobre exatamente quais transa√ß√µes ocorreram e quais n√£o ocorreram.  E √© exatamente isso que a rede Bitcoin faz.  Mas existem muitos aplicativos que n√£o exigem algo como uma blockchain, que podem realmente lidar com um modelo de dados muito mais flex√≠vel que flui pelo sistema.  E esse √© o tipo de sistema descentralizado no qual estou mais interessado. <br><br>  <b>Vadim</b> : Voc√™ poderia citar alguma tecnologia promissora ou subvalorizada no campo de sistemas descentralizados, al√©m da blockchain?  Uso o IPFS h√° algum tempo. <br><br>  <b>Martin</b> : Para o IPFS, examinei-o um pouco, embora ainda n√£o o tenha usado.  N√≥s fizemos algum trabalho com o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dat</a> , que √© um pouco semelhante ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPFS</a> no sentido de que tamb√©m √© uma tecnologia de armazenamento descentralizada.  A diferen√ßa √© que o IPFS possui o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filecoin</a> , uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criptomoeda</a> , anexada a ele como uma forma de pagar pelos recursos de armazenamento, enquanto o Dat n√£o possui nenhuma blockchain anexada a ele - √© apenas uma maneira de replicar dados em v√°rias m√°quinas de maneira P2P. <br><br>  Para o projeto em que estou trabalhando, o Dat se encaixou perfeitamente, porque quer√≠amos criar um software de colabora√ß√£o no qual v√°rios usu√°rios diferentes pudessem editar documentos ou bancos de dados, e quaisquer altera√ß√µes nesses dados seriam enviadas a qualquer pessoa mais quem precisa ter uma c√≥pia desses dados.  Podemos usar o Dat para fazer essa replica√ß√£o de maneira P2P, e o Dat cuida de todas as coisas no n√≠vel da rede, como passagem NAT e passagem por firewalls - √© um problema bastante complicado apenas para obter os pacotes de uma extremidade √† outra .  E ent√£o constru√≠mos uma camada sobre isso, usando CRDTs, que √© uma maneira de permitir que v√°rias pessoas editem algum documento ou conjunto de dados e troquem essas edi√ß√µes de maneira eficiente.  Eu acho que voc√™ provavelmente tamb√©m pode criar esse tipo de coisa no IPFS: voc√™ provavelmente pode ignorar o aspecto Filecoin e usar o aspecto de replica√ß√£o P2P, e provavelmente tamb√©m far√° o trabalho. <br><br>  <b>Vadim</b> : Claro, embora o uso do IPFS possa levar a uma menor capacidade de resposta, porque o Dat subjacente do WebRTC conecta os n√≥s P2P diretamente, e o IPFS funciona como uma tabela de hash distribu√≠da. <br><br>  <b>Martin</b> : Bem, o WebRTC est√° em um n√≠vel diferente da pilha, pois se destina principalmente a conectar duas pessoas que podem estar fazendo uma v√≠deo chamada;  de fato, o software que estamos usando para esta entrevista agora pode estar usando o WebRTC.  E o WebRTC fornece um canal de dados que voc√™ pode usar para enviar dados bin√°rios arbitr√°rios sobre ele, mas criar um sistema de replica√ß√£o completo ainda √© um pouco de trabalho.  E isso √© algo que Dat ou IPFS j√° fazem. <br><br>  Voc√™ mencionou a capacidade de resposta - certamente √© uma coisa a se pensar.  Digamos que voc√™ queira criar o pr√≥ximo Google Docs de maneira descentralizada.  Com o Google Docs, a unidade de altera√ß√µes que voc√™ faz √© uma √∫nica tecla.  Cada letra que voc√™ digita no teclado pode ser enviada em tempo real aos seus colaboradores, o que √© √≥timo do ponto de vista da r√°pida colabora√ß√£o em tempo real.  Mas tamb√©m significa que, ao longo da escrita de um documento grande, voc√™ poder√° ter centenas de milhares dessas edi√ß√µes de caracteres √∫nicos que se acumulam, e muitas dessas tecnologias no momento n√£o s√£o muito boas para compactar esse tipo de edi√ß√£o de dados.  Voc√™ pode manter todas as edi√ß√µes que j√° fez no seu documento, mas mesmo se voc√™ enviar apenas cem bytes para cada pressionamento de tecla que voc√™ fizer e escrever um documento um pouco maior com, digamos, 100.000 pressionamentos de tecla, voc√™ repentinamente agora possui 10 MB de dados para um documento que seria apenas algumas dezenas de kilobytes normalmente.  Portanto, temos essa enorme sobrecarga para a quantidade de dados que precisa ser enviada, a menos que sejamos mais inteligentes na compacta√ß√£o e empacotamento de altera√ß√µes. <br><br>  Em vez de enviar a algu√©m a lista completa de todos os caracteres que j√° foram digitados, podemos apenas enviar o estado atual do documento e depois enviar as atualiza√ß√µes que ocorreram desde ent√£o.  Mas muitos desses sistemas ponto a ponto ainda n√£o t√™m uma maneira de fazer instant√¢neos de estado de uma maneira que seja eficiente o suficiente para us√°-los para algo como o Google Docs.  Na verdade, essa √© uma √°rea na qual estou trabalhando ativamente, tentando encontrar algoritmos melhores para sincronizar usu√°rios diferentes para algo como um documento de texto, onde n√£o queremos manter cada pressionamento de tecla porque isso seria muito caro e queremos para fazer um uso mais eficiente da largura de banda da rede. <br><br><hr><br><h2>  Novos CRDTs.  Verifica√ß√£o formal com isabelle </h2><br>  <b>Vadim</b> : Voc√™ conseguiu compactar esses dados de pressionamento de tecla substancialmente?  Voc√™ inventou novos CRDTs ou algo semelhante? <br><br>  <b>Martin</b> : Sim.  At√© o momento, temos apenas prot√≥tipos para isso, ainda n√£o foi totalmente implementado e ainda precisamos fazer mais algumas experi√™ncias para medir a efici√™ncia da pr√°tica.  Mas desenvolvemos alguns esquemas de compacta√ß√£o que parecem muito promissores.  No meu prot√≥tipo, reduzi-o de cerca de 100 bytes por edi√ß√£o para algo como 1,7 bytes de sobrecarga por edi√ß√£o.  E isso √© muito mais razo√°vel, √© claro.  Mas, como eu disse, essas experi√™ncias ainda est√£o em andamento, e o n√∫mero ainda pode mudar um pouco.  Mas acho que a quest√£o √© que ainda h√° muito espa√ßo para otimiza√ß√£o, para que possamos melhorar ainda mais. <br><br>  <b>Vadim</b> : Ent√£o √© sobre isso que sua palestra ser√° realizada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confer√™ncia Hydra</a> , estou certo? <br><br>  <b>Martin</b> : Sim, exatamente.  Darei uma r√°pida introdu√ß√£o √† √°rea de CRDTs, software colaborativo e alguns dos problemas que surgem nesse contexto.  Depois, descreverei algumas das pesquisas que estamos fazendo nesta √°rea.  Tem sido muito divertido, porque a pesquisa que estamos fazendo tem uma s√©rie de preocupa√ß√µes diferentes.  No lado mais aplicado, temos uma implementa√ß√£o JavaScript desses algoritmos, e estamos usando isso para criar pe√ßas reais de software, tentando us√°-lo para ver como ele se comporta.  No outro extremo, temos trabalhado com m√©todos formais para provar que esses algoritmos est√£o corretos, porque alguns desses algoritmos s√£o bastante sutis e queremos ter certeza de que os sistemas que estamos criando est√£o realmente corretos, ou seja, que eles sempre atingem um estado consistente.  No passado, havia muitos algoritmos que realmente n√£o conseguiram fazer isso, que estavam simplesmente errados, ou seja, em certos casos extremos, eles permaneceriam permanentemente inconsistentes.  E assim, para evitar esses problemas que os algoritmos tiveram no passado, usamos m√©todos formais para provar que nossos algoritmos est√£o corretos. <br><br>  <b>Vadim</b> : Uau.  Voc√™ realmente usa provadores de teoremas, como Coq ou Isabelle ou qualquer outra coisa? <br><br>  <b>Martin</b> : Exatamente, estamos usando Isabelle para isso. <br><br><blockquote>  Voc√™ pode assistir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√† palestra de Martin</a> "Prova de corre√ß√£o de sistemas distribu√≠dos com Isabelle" na confer√™ncia The Strange Loop, em setembro. </blockquote><br>  <b>Vadim</b> : Parece √≥timo!  Essas provas ser√£o publicadas? <br><br>  <b>Martin</b> : Sim, nosso primeiro conjunto de provas j√° √© p√∫blico.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Publicamos</a> isso h√° um ano e meio: era uma estrutura para verificar CRDTs e verificamos tr√™s CRDTs espec√≠ficas nessa estrutura, sendo a principal delas a RGA ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Replicated Growable Array</a> ), que √© uma CRDT para edi√ß√£o de texto colaborativa.  Embora n√£o seja muito complicado, √© um algoritmo bastante sutil e, portanto, √© um bom caso em que √© necess√°ria prova, porque n√£o √© √≥bvio, apenas olhando para ele, que realmente est√° correto.  E assim a prova nos d√° a certeza adicional de que realmente est√° correta.  Nosso trabalho anterior foi sobre a verifica√ß√£o de alguns CRDTs existentes, e nosso trabalho mais recente nesta √°rea √© sobre nossos pr√≥prios CRDTs para novos modelos de dados que estamos desenvolvendo e provando que nossos pr√≥prios CRDTs tamb√©m est√£o corretos. <br><br>  <b>Vadim</b> : Qual √© o tamanho da prova comparada √† descri√ß√£o do algoritmo?  Porque √†s vezes pode ser um problema. <br><br>  <b>Martin</b> : Sim, isso √© um problema - as provas costumam dar muito trabalho.  Penso no nosso exemplo mais recente ... Na verdade, deixe-me dar uma r√°pida olhada no c√≥digo.  A descri√ß√£o do algoritmo e das estruturas de dados √© de cerca de 60 linhas de c√≥digo.  Portanto, √© um algoritmo bastante pequeno.  A prova tem mais de 800 linhas.  Portanto, temos uma propor√ß√£o aproximada de 12: 1 entre a prova e o c√≥digo.  E isso √© infelizmente bastante t√≠pico.  A prova √© uma grande quantidade de trabalho adicional.  Por outro lado, uma vez que temos a prova, ganhamos uma certeza muito forte na corre√ß√£o do algoritmo.  Al√©m disso, como seres humanos, entendemos o algoritmo muito melhor.  Muitas vezes, acho que, ao tentar formaliz√°-lo, acabamos entendendo o que estamos tentando formalizar muito melhor do que antes.  E isso por si s√≥ √© realmente um resultado √∫til deste trabalho: al√©m da pr√≥pria prova, obtemos um entendimento mais profundo, e isso geralmente √© muito √∫til para criar melhores implementa√ß√µes. <br><br>  <b>Vadim</b> : Voc√™ poderia descrever o p√∫blico-alvo da sua palestra, qu√£o duro ser√°?  Qual √© o conhecimento preliminar que voc√™ espera que o p√∫blico tenha? <br><br>  <b>Martin</b> : Eu gosto de tornar minhas palestras acess√≠veis com o m√≠nimo de conhecimento pr√©vio poss√≠vel e tento elevar todos ao mesmo n√≠vel.  Cubro muito material, mas come√ßo com uma base baixa.  Eu esperaria que as pessoas tivessem alguma experi√™ncia geral em sistemas distribu√≠dos: como voc√™ envia alguns dados atrav√©s de uma rede usando TCP, ou talvez uma id√©ia aproximada de como o Git funciona, que √© um modelo bastante bom para essas coisas.  Mas isso √© tudo o que voc√™ precisa, realmente.  Ent√£o, entender o trabalho que estamos realizando ainda n√£o √© muito dif√≠cil.  Eu explico tudo pelo exemplo, usando figuras para ilustrar tudo.  Felizmente, todos ser√£o capazes de acompanhar. <br><br><hr><br><h2>  Origem do evento.  Abordagem de baixo n√≠vel.  Transa√ß√µes XA </h2><br>  <b>Vadim</b> : Parece realmente √≥timo.  Na verdade, temos algum tempo e gostaria de discutir um de seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos recentes</a> sobre o processamento de eventos on-line.  Voc√™ √© um grande defensor da ideia de fornecimento de eventos, est√° correto? <br><br>  <b>Martin</b> : Sim, claro. <br><br>  <b>Vadim</b> : Atualmente, essa abordagem est√° ganhando for√ßa e, em busca de todas as vantagens do log de opera√ß√µes globalmente ordenado, muitos engenheiros tentam implant√°-la em qualquer lugar.  Voc√™ poderia descrever alguns casos em que a fonte de eventos n√£o √© a melhor op√ß√£o?  Apenas para evitar seu uso indevido e poss√≠vel decep√ß√£o com a pr√≥pria abordagem. <br><br>  <b>Martin</b> : Existem duas camadas diferentes da pilha sobre as quais precisamos falar primeiro.  A fonte de eventos, conforme proposta por Greg Young e alguns outros, √© um mecanismo para modelagem de dados, ou seja: se voc√™ possui um esquema de banco de dados e est√° come√ßando a perder o controle, porque existem muitas tabelas diferentes e eles ' todos s√£o modificados por transa√ß√µes diferentes - a fonte de eventos √© uma maneira de trazer melhor clareza a esse modelo de dados, porque os eventos podem expressar muito diretamente o que est√° acontecendo no n√≠vel comercial.  Qual √© a a√ß√£o que o usu√°rio executou?  Efetivamente, o que voc√™ est√° fazendo com o sourcing de eventos √© separar a a√ß√£o (o evento) dos seus efeitos, que acontecem em algum ponto a jusante. <br><br>  Eu vim para essa √°rea de um √¢ngulo um pouco diferente, que √© um ponto de vista de n√≠vel inferior do uso de sistemas como o Kafka para a constru√ß√£o de sistemas altamente escalon√°veis.  Essa vis√£o √© semelhante no sentido de que, se voc√™ estiver usando algo como Kafka, est√° usando eventos, mas isso n√£o significa que voc√™ esteja necessariamente usando a fonte de eventos.  E, inversamente, voc√™ n√£o precisa usar o Kafka para fazer a fonte do evento;  voc√™ pode fazer a fonte de eventos em um banco de dados regular ou pode usar um banco de dados especial projetado especificamente para a fonte de eventos.  Portanto, essas duas id√©ias s√£o semelhantes, mas nenhuma exige a outra, elas apenas t√™m alguma sobreposi√ß√£o. <br><br>  O caso de querer usar um sistema como o Kafka √© principalmente o argumento de escalabilidade: nesse caso, voc√™ simplesmente recebe tantos dados que n√£o pode process√°-los de maneira realista em um banco de dados de n√≥ √∫nico; portanto, √© necess√°rio particion√°-lo em alguns e usar um log de eventos como o Kafka oferece uma boa maneira de espalhar esse trabalho por v√°rias m√°quinas.  Ele fornece uma maneira boa e baseada em princ√≠pios para dimensionar sistemas.  √â especialmente √∫til se voc√™ deseja integrar v√°rios sistemas de armazenamento diferentes.  Portanto, se, por exemplo, voc√™ deseja atualizar n√£o apenas seu banco de dados relacional, mas tamb√©m, digamos, um √≠ndice de pesquisa de texto completo como o Elasticsearch, ou um sistema de armazenamento em cache como Memcached ou Redis ou algo assim, e voc√™ deseja que um evento tenha um atualizando o efeito em todos esses sistemas diferentes, algo como Kafka √© muito √∫til. <br><br>  Em termos da pergunta que voc√™ fez (quais s√£o as situa√ß√µes em que eu n√£o usaria essa abordagem de fornecimento de eventos ou log de eventos) - acho dif√≠cil dizer com precis√£o, mas como regra geral, eu diria: use o que for mais simples .  Ou seja, o que estiver mais pr√≥ximo do dom√≠nio que voc√™ est√° tentando implementar.  E assim, se a coisa que voc√™ est√° tentando implementar √© muito bem mapeada para um banco de dados relacional, no qual voc√™ apenas insere, atualiza e exclui algumas linhas, use um banco de dados relacional e insira, atualize e exclua algumas linhas.  N√£o h√° nada errado com os bancos de dados relacionais e us√°-los como est√£o.  Eles funcionaram bem para n√≥s por um longo tempo e continuam a faz√™-lo.  Mas se voc√™ estiver em uma situa√ß√£o em que est√° realmente lutando para usar esse tipo de banco de dados, por exemplo, porque a complexidade do modelo de dados est√° ficando fora de controle, faz sentido mudar para algo como uma fonte de eventos abordagem. <br><br>  Da mesma forma, no n√≠vel mais baixo (escalabilidade), se o tamanho dos seus dados for tal que voc√™ possa coloc√°-los no PostgreSQL em uma √∫nica m√°quina - provavelmente isso √© bom, basta usar o PostgreSQL em uma √∫nica m√°quina.  Mas se voc√™ est√° no ponto em que n√£o h√° como uma √∫nica m√°quina lidar com sua carga, voc√™ precisa escalar um sistema grande, ent√£o faz sentido procurar em sistemas mais distribu√≠dos como o Kafka.  Eu acho que o princ√≠pio geral aqui √©: use o que for mais simples para a tarefa espec√≠fica que voc√™ est√° tentando resolver. <br><br>  <b>Vadim</b> : √â realmente um bom conselho.  Conforme seu sistema evolui, voc√™ n√£o pode prever com precis√£o a dire√ß√£o do desenvolvimento, todas as consultas, padr√µes e fluxos de dados. <br><br>  <b>Martin</b> : Exatamente, e para esse tipo de situa√ß√£o, os bancos de dados relacionais s√£o incr√≠veis, porque s√£o muito flex√≠veis, especialmente se voc√™ incluir o suporte JSON que eles t√™m agora.  O PostgreSQL agora tem um suporte muito bom para JSON.  Voc√™ pode adicionar um novo √≠ndice se desejar consultar de uma maneira diferente.  Voc√™ pode simplesmente alterar o esquema e continuar executando os dados em uma estrutura diferente.  Portanto, se o tamanho do conjunto de dados n√£o for muito grande e a complexidade n√£o for muito grande, os bancos de dados relacionais funcionar√£o bem e fornecer√£o uma grande flexibilidade. <br><br>  <b>Vadim</b> : Vamos falar um pouco mais sobre o fornecimento de eventos.  Voc√™ mencionou um exemplo interessante com v√°rios consumidores consumindo eventos de uma fila baseada em Kafka ou algo semelhante.  Imagine que novos documentos sejam publicados e v√°rios sistemas estejam consumindo eventos: um sistema de pesquisa baseado no Elasticsearch, que torna os documentos pesquis√°veis, um sistema de cache que os coloca no cache de valor-chave baseado no Memcached e um sistema de banco de dados relacional que atualiza alguns tabelas em conformidade.  Um documento pode ser uma oferta de venda de carros ou um an√∫ncio imobili√°rio.  Todos esses sistemas de consumo funcionam simultaneamente e simultaneamente. <br><br>  <b>Martin</b> : Ent√£o, sua pergunta √© como voc√™ lida com o fato de que, se voc√™ tiver esses v√°rios consumidores, alguns deles podem ter sido atualizados, mas outros ainda n√£o viram uma atualiza√ß√£o e ainda est√£o um pouco atrasados? <br><br>  <b>Vadim</b> : Sim, exatamente.  Um usu√°rio acessa seu site, entra em uma consulta de pesquisa, obt√©m alguns resultados de pesquisa e clica em um link.  Mas ela obt√©m o c√≥digo de status HTTP 404 porque n√£o existe essa entidade no banco de dados, que ainda n√£o foi capaz de consumir e persistir o documento. <br><br>  <b>Martin</b> : Sim, isso √© realmente um desafio.  Idealmente, o que voc√™ deseja √© o que chamar√≠amos de "consist√™ncia causal" nesses diferentes sistemas de armazenamento.  Se um sistema contiver alguns dados dos quais voc√™ depende, os outros sistemas analisados ‚Äã‚Äãtamb√©m conter√£o essas depend√™ncias.  Infelizmente, reunir esse tipo de consist√™ncia causal em diferentes tecnologias de armazenamento √© realmente muito dif√≠cil, e isso n√£o √© culpa da fonte de eventos, porque, independentemente da abordagem ou sistema usado para enviar as atualiza√ß√µes para os v√°rios sistemas diferentes, voc√™ sempre pode acabar com algum tipo de problema de simultaneidade. <br><br>  No seu exemplo de grava√ß√£o de dados no Memcached e no Elasticsearch, mesmo se voc√™ tentar fazer as grava√ß√µes nos dois sistemas simultaneamente, poder√° haver um pouco de atraso na rede, o que significa que eles chegam em momentos ligeiramente diferentes nesses sistemas diferentes, e processado com um tempo ligeiramente diferente.  E, portanto, algu√©m que est√° lendo esses dois sistemas pode ver um estado inconsistente.  Agora, existem alguns projetos de pesquisa que est√£o trabalhando pelo menos para alcan√ßar esse tipo de consist√™ncia causal, mas ainda √© dif√≠cil se voc√™ quiser usar algo como Elasticsearch ou Memcached ou algo assim. <br><br>  Uma boa solu√ß√£o aqui seria que voc√™ seja apresentado, conceitualmente, com um instant√¢neo consistente no momento exato, tanto no √≠ndice de pesquisa quanto no cache e no banco de dados.  Se voc√™ trabalha apenas dentro de um banco de dados relacional, obt√©m algo chamado isolamento de instant√¢neo, e o ponto de isolamento de instant√¢neo √© que, se voc√™ estiver lendo no banco de dados, parece que voc√™ tem sua pr√≥pria c√≥pia privada de todo banco de dados.  Qualquer coisa que voc√™ olhar no banco de dados, todos os dados que voc√™ consultar ser√£o o estado a partir desse momento, de acordo com o instant√¢neo.  Portanto, mesmo que os dados tenham sido alterados posteriormente por outra transa√ß√£o, voc√™ realmente ver√° os dados mais antigos, porque esses dados mais antigos fazem parte de um instant√¢neo consistente. <br><br>  E agora, no caso em que voc√™ tem o Elasticsearch e o Memcached, realmente o que voc√™ idealmente deseja √© um instant√¢neo consistente entre esses dois sistemas.  Infelizmente, por√©m, nem o Memcached, nem o Redis, nem o Elasticsearch t√™m um mecanismo eficiente para criar esses tipos de instant√¢neos que podem ser coordenados com diferentes sistemas de armazenamento.  Cada sistema de armazenamento apenas pensa por si e normalmente apresenta o valor mais recente de cada chave, e n√£o possui esse recurso para olhar para tr√°s e apresentar uma vers√£o um pouco mais antiga dos dados, porque a vers√£o mais recente dos dados ainda n√£o est√° dispon√≠vel. consistente. <br><br>  Eu realmente n√£o tenho uma boa resposta para como seria a solu√ß√£o.  Receio que a solu√ß√£o exija altera√ß√µes de c√≥digo em qualquer sistema de armazenamento que participe desse tipo de coisa.  Portanto, ser√£o necess√°rias altera√ß√µes no Elasticsearch e no Redis, no Memcached e em qualquer outro sistema.  E eles teriam que adicionar algum tipo de mecanismo para snapshots point-in-time que sejam baratos o suficiente para que voc√™ possa us√°-lo o tempo todo, porque voc√™ pode querer o snapshot v√°rias vezes por segundo - n√£o √© apenas uma vez dia-instant√¢neo, √© muito refinado.  No momento, os sistemas subjacentes n√£o existem em termos de capacidade de fazer esses tipos de instant√¢neos em diferentes sistemas de armazenamento.  √â um t√≥pico de pesquisa realmente interessante.  Espero que algu√©m trabalhe nisso, mas ainda n√£o vi respostas realmente convincentes para esse problema. <br><br>  <b>Vadim</b> : Sim, precisamos de algum tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Controle de Concorr√™ncia Multivers√£o</a> compartilhado. <br><br>  <b>Martin</b> : Exatamente, como os sistemas de transa√ß√µes distribu√≠das.  As transa√ß√µes distribu√≠das do XA o levar√£o at√© l√°, mas infelizmente o XA, como est√°, n√£o √© muito adequado porque funciona apenas se voc√™ estiver usando o controle de concorr√™ncia baseado em bloqueio.  Isso significa que, se voc√™ ler alguns dados, precisar√° travar um bloqueio para que ningu√©m possa modificar esses dados enquanto voc√™ tiver esse bloqueio.  E esse tipo de controle de simultaneidade baseado em bloqueio tem um desempenho terr√≠vel; portanto, nenhum sistema realmente usa isso na pr√°tica atualmente.  Mas se voc√™ n√£o tiver esse bloqueio, n√£o obter√° o comportamento de isolamento necess√°rio em um sistema como transa√ß√µes distribu√≠das XA.  Talvez o que precisamos seja de um novo protocolo para transa√ß√µes distribu√≠das que permita o isolamento de instant√¢neos como o mecanismo de isolamento em diferentes sistemas.  Mas acho que ainda n√£o vi nada que implemente isso. <br><br>  <b>Vadim</b> : Sim, espero que algu√©m esteja trabalhando nisso. <br><br>  <b>Martin</b> : Sim, seria realmente importante.  Tamb√©m no contexto de microsservi√ßos, por exemplo: a maneira como as pessoas promovem que voc√™ deve criar microsservi√ßos √© que cada microsservi√ßo tenha seu pr√≥prio armazenamento, seu pr√≥prio banco de dados e voc√™ n√£o tenha um servi√ßo acessando diretamente o banco de dados de outro servi√ßo, porque isso quebraria o encapsulamento do servi√ßo.  Portanto, cada servi√ßo gerencia apenas seus pr√≥prios dados. <br><br>  Por exemplo, voc√™ tem um servi√ßo para gerenciar usu√°rios, e ele possui um banco de dados para os usu√°rios, e todo mundo que deseja descobrir algo sobre os usu√°rios precisa passar pelo servi√ßo do usu√°rio.  Do ponto de vista do encapsulamento, isso √© bom: voc√™ est√° ocultando detalhes do esquema do banco de dados de outros servi√ßos, por exemplo. <br><br> But from the point of view of consistency across different services ‚Äî well, you've got a huge problem now, because of exactly the thing we were discussing: we might have data in two different services that depends upon each other in some way, and you could easily end up with one service being slightly ahead of or slightly behind the other in terms of timing, and then you could end up with someone who reads across different services, getting inconsistent results. And I don't think anybody building microservices currently has an answer to that problem. <br><br> <b>Vadim</b> : It is somewhat similar to workflows in our society and government, which are inherently asynchronous and there are no guarantees of delivery. You can get your passport number, then you can change it, and you need to prove that you changed it, and that you are the same person. <br><br> <b>Martin</b> : Yes, absolutely. As humans we have ways of dealing with this, for example, we might know that oh, sometimes that database is a bit outdated, I'll just check back tomorrow. And then tomorrow it's fine. But if it's software that we're building, we have to program all that kind of handling into the software. The software can't think for itself. <br><br> <b>Vadim</b> : Definitely, at least not yet. I have another question about the advantages of event sourcing. Event sourcing gives you the ability to stop processing events in case of a bug, and resume consuming events having deployed the fix, so that the system is always consistent. It's a really strong and useful property, but it might not be acceptable in some cases like banking where you can imagine a system that continues to accept financial transactions, but the balances are stale due to suspended consumers waiting for a bugfix from developers. What might be a workaround in such cases? <br><br> <b>Martin</b> : I think it's a bit unlikely to stop the consumer, deploying the fix and then restart it, because, as you say, the system has got to continue running, you can't just stop it. I think what is more likely to happen is: if you discover a bug, you let the system continue running, but while it continues running with the buggy code, you produce another version of the code that is fixed, you deploy that fixed version separately and run the two in parallel for a while. In the fixed version of the code you might go back in history and reprocess all of the input events that have happened since the buggy code was deployed, and maybe write the results to a different database. Once you've caught up again you've got two versions of the database, which are both based on the same event inputs, but one of the two processed events with the buggy code and the other processed the events with the correct code. At that point you can do the switchover, and now everyone who reads the data is going to read the correct version instead of the buggy version, and you can shut down the buggy version. That way you never need to stop the system from running, everything keeps working all the time. And you can take the time to fix the bug, and you can recover from the bug because you can reprocess those input events again. <br><br> <b>Vadim</b> : Indeed, it's a really good option if the storage systems are under your control, and we are not talking about side effects applied to external systems. <br><br> <b>Martin</b> : Yes, you're right, once we send the data to external systems it gets more difficult because you might not be able to easily correct it. But this is again something you find in financial accounting, for example. In a company, you might have quarterly accounts. At the end of the quarter, everything gets frozen, and all of the revenue and profit calculations are based on the numbers for that quarter. But then it can happen that actually, some delayed transaction came in, because somebody forgot to file a receipt in time. The transaction comes in after the calculations for the quarter have been finalized, but it still belongs in that earlier quarter. <br><br> What accountants do in this case is that in the next quarter, they produce corrections to the previous quarter's accounts. And typically those corrections will be a small number, and that's no problem because it doesn't change the big picture. But at the same time, everything is still accounted for correctly. At the human level of these accounting systems that has been the case ever since accounting systems were invented, centuries ago. It's always been the case that some late transactions would come in and change the result for some number that you thought was final, but actually, it wasn't because the correction could still come in. And so we just build the system with the mechanism to perform such corrections. I think we can learn from accounting systems and apply similar ideas to many other types of data storage systems, and just accept the fact that sometimes they are mostly correct but not 100% correct and the correction might come in later. <br><br> <b>Vadim</b> : It's a different point of view to building systems. <br><br> <b>Martin</b> : It is a bit of a new way of thinking, yes. It can be disorienting when you come across it at first. But I don't think there's really a way round it, because this impreciseness is inherent in the fact that we do not know the entire state of the world ‚Äî it is fundamental to the way distributed systems work. We can't just hide it, we can't pretend that it doesn't happen, because that imprecision is necessarily exposed in the way we process the data. <br><br><hr><br><h2> Professional growth and development </h2><br> <b>Vadim</b> : Do you think that conferences like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hydra</a> are anticipated? Most distributed systems are quite different, and it is hard to imagine that many attendees will get to work and will start applying what they have learned in day-to-day activities. <br><br> <b>Martin</b> : It is broad, but I think that a lot of the interesting ideas in distributed systems are conceptual. So the insights are not necessarily like ¬´use this database¬ª or ¬´use this particular technology¬ª. They are more like ways of thinking about systems and about software. And those kinds of ideas can be applied quite widely. My hope is that when attendees go away from this conference, the lessons they take away are not so much what piece of software they should be using or which programming language they should be using ‚Äì really, I don't mind about that ‚Äì but more like how to <i>think</i> about the systems they are building. <br><br> <b>Vadim</b> : Why do you think it's important to give conference talks on such complex topics as your talk, compared to publishing papers, covering all their details and intricacies? Or should anyone do both? <br><br> <b>Martin</b> : I think they serve different purposes. When we write papers, the purpose is to have a very definitive, very precise analysis of a particular problem, and to go really deep in that. On the other hand, the purpose of a talk is more to get people interested in a topic and to start a conversation around it. I love going to conferences partly because of the discussions I then have around the talk, where people come to me and say: ¬´oh, we tried something like this, but we ran into this problem and that problem, what do you think about that?¬ª Then I get to think about other people's problems, and that's really interesting because I get to learn a lot from that. <br><br> So, from my point of view, the selfish reason for going to conferences is really to learn from other people, what their experiences have been, and to help share the experiences that we've made in the hope that other people will find them useful as well. But fundamentally, a conference talk is often an introduction to a subject, whereas a paper is a deep analysis of a very narrow question. I think those are different genres and I think we need both of them. <br><br> <b>Vadim</b> : And the last question. How do you personally grow as a professional engineer and a researcher? Could you please recommend any conferences, blogs, books, communities for those who wish to develop themselves in the field of distributed systems? <br><br> <b>Martin</b> : That's a good question. Certainly, there are things to listen to and to read. There's no shortage of conference talks that have been recorded and put online. There are books like my own book for example, which provides a bit of an introduction to the topic, but also lots of references to further reading. So if there are any particular detailed questions that you're interested in, you can follow those references and find the original papers where these ideas were discussed. They can be a very valuable way of learning about something in greater depth. <br><br> A really important part is also trying to implement things and seeing how they work out in practice, and talking to other people and sharing your experiences. Part of the value of a conference is that you get to talk to other people as well, live. But you can have that through other mechanisms as well; for example, there's a Slack channel that people have set up for people <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interested in distributed systems</a> . If that's your thing you can join that. You can, of course, talk to your colleagues in your company and try to learn from them. I don't think there's one right way of doing this ‚Äî there are many different ways through which you can learn and get a deeper experience, and different paths will work for different people. <br><br> <b>Vadim</b> : Thank you very much for your advice and interesting discussion! It has been a pleasure talking to you. <br><br> <b>Martin</b> : No problem, yeah, it's been nice talking to you. <br><br> <b>Vadim</b> : Let's meet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">at the conference</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458056/">https://habr.com/ru/post/pt458056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458044/index.html">Seguran√ßa provincial da informa√ß√£o - estagna√ß√£o ou desenvolvimento?</a></li>
<li><a href="../pt458046/index.html">Folha de dicas de Gradle</a></li>
<li><a href="../pt458048/index.html">Delega√ß√£o como ferramenta de gerente</a></li>
<li><a href="../pt458050/index.html">Como foi o Mobius 2019 Piter (e um pouco sobre o pr√≥ximo Mobius)</a></li>
<li><a href="../pt458052/index.html">AMA com Habr.10. √öltima * Edi√ß√£o</a></li>
<li><a href="../pt458060/index.html">Criando um shader de grama no mecanismo Unity</a></li>
<li><a href="../pt458062/index.html">Vis√£o geral da plataforma UserGate</a></li>
<li><a href="../pt458064/index.html">PVS-Studio nas nuvens - Executando a an√°lise no Travis CI</a></li>
<li><a href="../pt458068/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../pt458070/index.html">PVS-Studio para Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>