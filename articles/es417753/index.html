<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéüÔ∏è ü•ö üë®üèø‚Äç‚öñÔ∏è Compresi√≥n de grandes matrices de primos ü§∏üèæ üß° üëØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las propiedades de los n√∫meros primos rara vez le permiten trabajar con ellos de manera diferente que en forma de una matriz precalculada, y preferibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compresi√≥n de grandes matrices de primos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="caja de arena" align="left"><br><p>  Las propiedades de los n√∫meros primos rara vez le permiten trabajar con ellos de manera diferente que en forma de una matriz precalculada, y preferiblemente lo m√°s voluminoso posible.  El formato de almacenamiento natural en forma de enteros de una u otra capacidad de d√≠gitos sufre al mismo tiempo algunas desventajas que se vuelven significativas con el crecimiento del volumen de datos. <br></p><p></p><p>  Entonces, el formato de enteros sin signo de 16 bits con el tama√±o de una tabla de este tipo es de aproximadamente 13 kilobytes, contiene solo 6542 primos: seguido del n√∫mero 65531 son los valores de mayor profundidad de bits.  Tal mesa es adecuada solo como un juguete. <br></p><p></p><p>  El formato entero m√°s popular de 32 bits en la programaci√≥n parece mucho m√°s s√≥lido: le permite almacenar alrededor de 203 millones de simples.  Pero esa mesa ya ocupa unos 775 megabytes. <br></p><p></p><p>  El formato de 64 bits tiene a√∫n m√°s perspectivas.  Sin embargo, con una potencia te√≥rica del orden de los valores 1e + 19, la tabla tendr√≠a un tama√±o de 64 exabytes. <br></p><br><a name="habracut"></a><br><p></p><p>  Realmente no se cree que nuestra humanidad progresiva alguna vez en el futuro previsible calcule una tabla de n√∫meros primos de tal volumen.  Y el punto aqu√≠ no es tanto en vol√∫menes como en el tiempo de conteo de los algoritmos disponibles.  Digamos, si la tabla de todos los simples de 32 bits todav√≠a se puede calcular de forma independiente en unas pocas horas (Fig. 1), entonces para la tabla al menos un orden de magnitud mayor tomar√° varios d√≠as.  Pero tales vol√∫menes hoy: este es solo el nivel inicial. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="la figura 1"><br><br><p>  Como se puede ver en el diagrama, el tiempo de c√°lculo espec√≠fico despu√©s del tir√≥n inicial pasa suavemente al crecimiento asint√≥tico.  El es bastante lento.  pero esto es crecimiento, lo que significa que extraer cada siguiente dato a lo largo del tiempo ser√° cada vez m√°s dif√≠cil.  Si desea hacer un avance significativo, tendr√° que paralelizar el trabajo a trav√©s de los n√∫cleos (y se paraleliza bien) y colgarlo en las supercomputadoras.  Con la perspectiva de obtener los primeros 10 mil millones simples en una semana, y 100 mil millones, solo en un a√±o.  Por supuesto, hay algoritmos m√°s r√°pidos para el c√°lculo simple que el busto trivial utilizado en mi tarea, pero, en esencia, esto no cambia el asunto: despu√©s de dos o tres √≥rdenes de magnitud, la situaci√≥n se vuelve similar. <br></p><p></p><p>  Por lo tanto, ser√≠a bueno haber realizado el trabajo de conteo una vez, almacenar su resultado en una forma tabular lista para usar y usarlo seg√∫n sea necesario. <br></p><p></p><p>  Debido a lo obvio de la idea, la red se encuentra con muchos enlaces a listas preparadas de primos ya calculados por alguien.  Por desgracia, en la mayor√≠a de los casos solo son adecuados para manualidades de los estudiantes: uno de ellos, por ejemplo, va de un sitio a otro e incluye 50 millones de simples.  Esta cantidad solo puede sorprender a los no iniciados: ya se mencion√≥ anteriormente que en una computadora dom√©stica en unas pocas horas puede calcular de forma independiente la tabla de todas las simples de 32 bits, y es cuatro veces m√°s grande.  Probablemente hace unos 15-20 a√±os, tal lista fue de hecho un logro heroico para la comunidad laica.  Hoy, en la era de los dispositivos multi-core multi-gigahercios y multi-gigabytes, esto ya no es impresionante. <br></p><p></p><p>  Tuve la suerte de familiarizarme con el acceso a una tabla mucho m√°s representativa de las simples, que utilizar√© m√°s como ilustraci√≥n y sacrificio para mis experimentos de campo.  Con el prop√≥sito de conspirar, la llamar√© <b>1TPrimo</b> .  Contiene todos los n√∫meros primos menos de un bill√≥n. <br></p><p></p><p>  Usando 1TPrimo como ejemplo, es f√°cil ver con qu√© vol√∫menes tiene que lidiar.  Con una capacidad de alrededor de 37,6 mil millones de valores en formato entero de 64 bits, esta lista es de 280 gigabytes.  Por cierto, esa parte que podr√≠a caber en 32 d√≠gitos representa solo el 0.5% del n√∫mero de n√∫meros representados en √©l.  Esto deja absolutamente claro que cualquier trabajo serio con primos inevitablemente tiende a una profundidad total de 64 bits (o m√°s). <br></p><p></p><p>  Por lo tanto, la tendencia sombr√≠a es obvia: una tabla seria de n√∫meros primos inevitablemente tiene un volumen tit√°nico.  Y de alguna manera debemos luchar contra esto. <br></p><p></p><p>  Lo primero que viene a la mente al mirar una tabla (Fig. 2) es que consiste en valores consecutivos casi id√©nticos que difieren solo en uno o dos de los √∫ltimos lugares decimales: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="la figura 2"><br><br></p><br><p>  Simplemente, a partir de las consideraciones abstractas m√°s generales: si el archivo tiene muchos datos duplicados, entonces el archivador deber√≠a comprimirlo bien.  De hecho, la compresi√≥n de la tabla 1TPrimo con la popular utilidad 7-zip en configuraciones est√°ndar dio una relaci√≥n de compresi√≥n bastante alta: 8.5.  Es cierto que el tiempo de procesamiento, con el gran tama√±o de la tabla de origen, en un servidor de 8 n√∫cleos, con una carga promedio de todos los n√∫cleos de aproximadamente 80-90%, fue de 14 horas 12 minutos.  Los algoritmos de compresi√≥n universal est√°n dise√±ados para algunas ideas abstractas y generalizadas sobre datos.  En algunos casos especiales, los algoritmos de compresi√≥n especializados basados ‚Äã‚Äãen las caracter√≠sticas conocidas del conjunto de datos entrantes pueden demostrar indicadores mucho m√°s efectivos, a los que se dedica este trabajo.  Y cu√°n efectivo se volver√° claro a continuaci√≥n. <br></p><p></p><p>  Los valores num√©ricos cercanos de los n√∫meros primos vecinos requieren una decisi√≥n de no almacenar estos valores por s√≠ mismos, sino los intervalos (diferencias) entre ellos.  En este caso, se pueden lograr ahorros significativos debido al hecho de que la profundidad de bits de los intervalos es mucho menor que la profundidad de bits de los datos iniciales (Fig. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="Fig.  3"><br><br></p><br><p>  Y parece que no depende de la profundidad de bits de los simples que generan el intervalo.  Una b√∫squeda exhaustiva muestra que los valores t√≠picos de intervalos para primos tomados de varios lugares en la tabla 1TPrimo se encuentran dentro de unidades, decenas, a veces cientos y, como la primera oraci√≥n de trabajo, probablemente podr√≠an caber en el rango de 8 bits enteros sin signo, es decir, bytes.  Ser√≠a muy conveniente, y en comparaci√≥n con el formato de 64 bits, esto conducir√≠a inmediatamente a una compresi√≥n de datos de 8 veces, justo en alg√∫n lugar al nivel demostrado por el archivador de 7 zip.  Adem√°s, la simplicidad de los algoritmos de compresi√≥n y descompresi√≥n deber√≠a tener, en principio, un gran impacto en la velocidad de compresi√≥n y acceso a los datos en comparaci√≥n con 7-zip.  Suena tentador <br></p><p></p><p>  Est√° absolutamente claro que los datos convertidos de sus valores absolutos a los intervalos relativos entre ellos son adecuados solo para restaurar una serie de valores que vienen en una fila desde el comienzo de la tabla principal.  Pero si agregamos una estructura m√≠nima de √≠ndice de bloque a dicha tabla de intervalos, entonces con costos indirectos adicionales insignificantes, esto nos permitir√° restaurar, pero ya bloque por bloque, tanto el elemento de la tabla por su n√∫mero y el elemento m√°s cercano por un valor establecido arbitrariamente, y estas operaciones, junto con la operaci√≥n principal muestras de secuencia: en general, agota la mayor parte de las posibles consultas a dichos datos.  El procesamiento estad√≠stico, por supuesto, se volver√° m√°s complicado, pero seguir√° siendo bastante transparente, ya que  no hay ning√∫n truco en particular para recuperarlo "sobre la marcha" de los intervalos disponibles al acceder al bloque de datos requerido. <br></p><p></p><p>  Pero por desgracia.  Un experimento num√©rico simple en datos de 1TPrimo muestra que ya al final de las terceras decenas de millones (esto es menos de una cent√©sima parte del volumen de 1TPrimo), y en cualquier otro lugar, los intervalos entre primos vecinos regularmente van m√°s all√° del rango de 0..255. <br></p><p></p><p>  Sin embargo, un experimento num√©rico ligeramente complicado revela que el crecimiento del intervalo m√°ximo entre primos vecinos con el crecimiento de la tabla en s√≠ es muy, muy lento, lo que significa que la idea sigue siendo buena de alguna manera. <br></p><p></p><p>  La segunda mirada m√°s cercana a la tabla de intervalos sugiere que es posible almacenar no la diferencia en s√≠, sino su mitad.  Como todos los n√∫meros primos mayores que 2 son obviamente impares, respectivamente, sus diferencias son obviamente pares.  En consecuencia, las diferencias pueden reducirse en 2 sin p√©rdida de valor;  y para completar, tambi√©n se puede restar uno del cociente obtenido para usar de manera √∫til el valor cero que no se reivindica de otra manera (Fig. 4).  Tal reducci√≥n de intervalos se denominar√° en adelante monol√≠tica, en contraste con la forma inicial porosa y suelta, en la que todos los valores impares y cero resultaron no reclamados. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="la figura 4"><br><br></p><br><p>  Cabe se√±alar que dado que el intervalo entre los dos primeros simples (2 y 3) no encaja en este esquema, entonces 2 deber√° excluirse de la tabla de intervalos y tener este hecho en mente todo el tiempo. <br></p><p></p><p>  Esta t√©cnica simple le permite codificar intervalos de 2 a 512 en el rango de valores 0..255. Una vez m√°s, la esperanza se hace realidad de que el m√©todo de diferencia nos permitir√° empacar una secuencia de primos mucho m√°s poderosa.  Y con raz√≥n: una serie de 37,6 mil millones de valores presentados en la lista 1TPrimo revel√≥ solo 6 (¬°seis!) Intervalos que no est√°n en el rango de 2..512. <br></p><p></p><p>  Pero eso fue una buena noticia;  Lo malo es que estos seis intervalos se encuentran dispersos en la lista con bastante libertad, y el primero de ellos ocurre ya al final del primer tercio de la lista, lo que convierte los dos tercios restantes en lastre inadecuado para este m√©todo de compresi√≥n (Fig. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="la figura 5"><br><br></p><br><p>  Tal rubor (¬°unas desafortunadas seis piezas por casi cuarenta mil millones! - y en ti ...) incluso con una mosca en la pomada para comparar - para mostrar el honor del alquitr√°n.  Pero, por desgracia, este es un patr√≥n, no un accidente.  Si rastreamos la primera aparici√≥n de intervalos entre n√∫meros primos seg√∫n la longitud de los datos, queda claro que este fen√≥meno radica en la gen√©tica de los n√∫meros primos, aunque progresa extremadamente lentamente (Fig. 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="la figura 6"><br><br></p><br><p>  * Calendario compilado seg√∫n el sitio tem√°tico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thomas R. Nisley</a> , <br>  que son varios √≥rdenes de magnitud superiores al poder de la lista 1TPrimo </p><br><p></p><p>  Pero incluso este progreso muy lento sugiere inequ√≠vocamente: uno puede limitarse a una determinada profundidad de bits predeterminada de un intervalo solo a una determinada potencia predeterminada de la lista.  Es decir, no es adecuado como soluci√≥n universal. <br></p><p></p><p>  Sin embargo, el hecho de que el m√©todo propuesto para comprimir una secuencia de n√∫meros primos le permite implementar una tabla compacta simple con una capacidad de casi 12 mil millones de valores ya es un resultado.  Dicha tabla ocupa un volumen de 11,1 gigabytes, frente a 89,4 gigabytes en un formato trivial de 64 bits.  Seguramente para una serie de aplicaciones, tal soluci√≥n puede ser suficiente. <br></p><p></p><p>  Y lo que es interesante: el procedimiento para traducir una tabla 1TPrimo de 64 bits al formato de intervalos de 8 bits con una estructura de bloques, utilizando solo un n√∫cleo de procesador (para la paralelizaci√≥n, tendr√≠a que recurrir a una complicaci√≥n significativa del programa, y ‚Äã‚Äãno vali√≥ la pena) y no m√°s de 5 El% de la carga del procesador (la mayor parte del tiempo dedicado a las operaciones de archivo) tom√≥ solo 19 minutos Contra, recuerdo, 14 horas en ocho n√∫cleos al 80-90% de la carga gastada por el archivador 7-zip. <br></p><p></p><p>  Por supuesto, solo el primer tercio de la tabla se someti√≥ a esta traducci√≥n, en la que el rango de intervalos no excede de 512. Por lo tanto, si lleva las 14 horas completas al mismo tercio, entonces se deben comparar 19 minutos con casi 5 horas del archivador de 7 zip.  Con una cantidad comparable de compresi√≥n (8 y 8.5), la diferencia es de aproximadamente 15 veces.  Teniendo en cuenta que la mayor parte del tiempo de trabajo del programa de transmisi√≥n estaba ocupado por operaciones de archivos, la diferencia ser√≠a a√∫n mayor en un sistema de disco m√°s r√°pido.  E intelectualmente, el tiempo de funcionamiento de 7-zip en ocho n√∫cleos a√∫n debe contarse en un hilo, y luego la comparaci√≥n ser√° realmente adecuada. <br></p><p></p><p>  La selecci√≥n de dicha base de datos difiere muy poco en el tiempo de la selecci√≥n de la tabla de datos desempaquetados y est√° determinada casi por completo por el tiempo de las operaciones de archivo.  Los n√∫meros espec√≠ficos dependen en gran medida del hardware espec√≠fico, en mi servidor, en promedio, el acceso a un bloque de datos arbitrario tom√≥ 37.8 Œºs, mientras que la lectura secuencial de bloques - 4.2 Œºs por bloque, para el desempaquetado completo del bloque - menos de 1 Œºs.  Es decir, no tiene sentido comparar la descompresi√≥n de datos con el trabajo de un archivador est√°ndar.  Y esta es una gran ventaja. <br></p><p></p><p>  Y, finalmente, las observaciones ofrecen otra tercera soluci√≥n que elimina cualquier restricci√≥n sobre el poder de los datos: codificaci√≥n de intervalos con valores de longitud variable.  Esta t√©cnica ha sido ampliamente utilizada en aplicaciones relacionadas con la compresi√≥n.  Su significado es que si se encuentra en la entrada que a menudo se encuentran algunos valores, algunos son menos comunes y otros son muy raros, entonces podemos codificar el primero con c√≥digos cortos, el segundo con c√≥digos m√°s aut√©nticos y el tercero - muy largo (tal vez incluso muy largo, porque no importa: de todos modos, estos datos son muy raros).  Como resultado, la longitud total de los c√≥digos recibidos puede ser mucho m√°s corta que los datos de entrada. <br></p><p></p><p>  Ya observando el gr√°fico de la aparici√≥n de los intervalos en la figura 7, podemos suponer que si los intervalos son 2, 4, 6, etc.  aparecen antes de los intervalos, digamos, 100, 102, 104, etc., entonces el primero deber√≠a continuar ocurriendo con mucha m√°s frecuencia que el segundo.  Y viceversa, si los intervalos 514 se encuentran solo a partir de 11.99 mil millones, 516 - a partir de 16.2 mil millones y 518 - generalmente a partir de solo 87.7 mil millones, entonces se encontrar√°n muy raramente.  Es decir, a priori, podemos asumir la relaci√≥n inversa entre el tama√±o del intervalo y su frecuencia en una secuencia de n√∫meros primos.  Y eso significa que puede construir una estructura simple que implemente c√≥digos de longitud variable para ellos. <br></p><p></p><p>  Por supuesto, las estad√≠sticas sobre la frecuencia de los intervalos deber√≠an ser determinantes para la elecci√≥n de un m√©todo de codificaci√≥n particular.  Afortunadamente, en contraste con los datos arbitrarios, la frecuencia de los intervalos entre los n√∫meros primos, que en s√≠ mismos son una secuencia estrictamente determinada, de una vez por todas, tambi√©n es una caracter√≠stica estrictamente determinada, de una vez por todas. <br></p><p></p><p>  La Figura 7 muestra la respuesta de frecuencia de los intervalos para toda la lista 1TPrimo: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="fig.7"><br><br></p><br><p>  Aqu√≠ es necesario mencionar nuevamente que el intervalo entre los primeros primos 2 y 3 est√° excluido del gr√°fico: este intervalo es 1 y ocurre exactamente una vez en la secuencia de primos, independientemente de la potencia de la lista.  Este intervalo es tan peculiar que es m√°s f√°cil eliminar 2 de la lista de simples que desviarse constantemente a las reservas.  El sim se declara que el <b>n√∫mero 2 es primo virtual</b> : no est√° visible en las listas, pero est√° all√≠.  Como esa gopher. <br></p><p></p><p>  A primera vista, el gr√°fico de frecuencia confirma completamente la suposici√≥n a priori dada por un par de p√°rrafos anteriores.  Muestra claramente la heterogeneidad estad√≠stica de los intervalos y la alta frecuencia de valores peque√±os en comparaci√≥n con los grandes.  Sin embargo, en la segunda vista, m√°s convexa, el gr√°fico resulta ser mucho m√°s interesante (Fig. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="Fig.  8"><br><br></p><br><p>  Muy inesperadamente, resulta que los intervalos m√°s frecuentes no son 2 y 4, como parece ser por consideraciones generales, sino 6, 12 y 18, seguidos por 10, y solo entonces 2 y 4 con una frecuencia casi igual (diferencia en 7 d√≠gitos) despu√©s del punto decimal).  Y adem√°s, la multiplicidad de valores m√°ximos del n√∫mero 6 se traza en todo el gr√°fico. <br></p><p></p><p>  A√∫n m√°s interesante, esta naturaleza inadvertidamente revelada del gr√°fico es universal, y, en todos los detalles, con todas sus torceduras, en toda la secuencia de intervalos simples representados por la lista 1TPrimo, es probable que sea universal para cualquier secuencia de intervalos simples (por supuesto, una declaraci√≥n tan audaz necesita prueba, que con mucho gusto transfiero a los hombros de especialistas en teor√≠a de n√∫meros).  La Figura 10 muestra una comparaci√≥n de las estad√≠sticas de intervalo completo (l√≠nea escarlata) con muestras de intervalo limitado tomadas en varios lugares arbitrarios en la lista 1TPrimo (l√≠neas de otros colores): <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="Fig.  9 9"><br></p><br><p>  Se puede ver en este gr√°fico que todas estas muestras se repiten exactamente, con solo una ligera diferencia en las partes izquierda y derecha de la figura: parecen estar ligeramente giradas en sentido contrario a las agujas del reloj alrededor del punto de intervalo con un valor de 24. Esta rotaci√≥n probablemente se deba al hecho de que la m√°s alta en la izquierda partes de los gr√°ficos se basan en muestras con profundidades de bits m√°s bajas.  En tales muestras, todav√≠a no existen, o son raros los intervalos grandes, que se vuelven frecuentes en muestras con profundidades de bits m√°s altas.  En consecuencia, su ausencia est√° a favor de la frecuencia de los intervalos con valores m√°s bajos.  En muestras con profundidades de bits m√°s altas, aparecen muchos intervalos nuevos con valores grandes; por lo tanto, la frecuencia de intervalos m√°s peque√±os disminuye ligeramente.  Lo m√°s probable es que el punto de pivote, con un aumento en el poder de la lista, cambie hacia valores m√°s grandes.  En alg√∫n lugar, al lado, est√° el punto de equilibrio de la gr√°fica, donde la suma de todos los valores de la derecha es aproximadamente igual a la suma de todos los valores de la izquierda. <br></p><p></p><p>  Esta naturaleza interesante de la frecuencia de los intervalos sugiere abandonar la estructura trivial de los c√≥digos de longitud variable.  T√≠picamente, dicha estructura consiste en un paquete de bits de varias longitudes y prop√≥sitos.  Por ejemplo, primero viene un cierto n√∫mero de bits de prefijo establecidos en un valor espec√≠fico, por ejemplo, 0. Hay un bit de detenci√≥n detr√°s de ellos, que debe indicar la finalizaci√≥n del prefijo y, en consecuencia, debe diferir del prefijo: 1 en este caso.  El prefijo puede no tener ninguna longitud, es decir, una y otra vez, el muestreo puede comenzar inmediatamente con un bit de parada, determinando as√≠ la secuencia m√°s corta.  El bit de detenci√≥n suele ir seguido de un sufijo, cuya longitud est√° determinada de alguna manera predeterminada por la longitud del prefijo.      ,       ,      ‚Äî        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> Y aqu√≠ deber√≠a mencionarse una cosa m√°s importante.  A primera vista, la ciclicidad observada implica la divisi√≥n de los intervalos en triples: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> y as√≠ sucesivamente (los valores con la frecuencia m√°xima en cada triple est√°n marcados en negrita) .  Sin embargo, de hecho, el ciclo aqu√≠ es ligeramente diferente. <br></p><p></p><p>  No citar√© toda la l√≠nea de razonamiento, que, de hecho, no existe: era una suposici√≥n intuitiva, complementada por un m√©todo de enumeraci√≥n contundente de opciones, c√°lculos y muestras que tom√≥ varios d√≠as de forma intermitente.  La ciclicidad revelada como resultado consiste en <b>seis</b> intervalos <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> y etc. (los intervalos de frecuencia m√°xima se resaltan nuevamente en negrita). <br></p><p></p><p>  En pocas palabras, el algoritmo de empaquetado propuesto es el siguiente. <br></p><p></p><p>  Dividir los intervalos en seis de n√∫meros pares nos permite representar cualquier intervalo <code>g</code> en la forma <code>g = i * 12 + t</code> , donde <code>i</code> es el √≠ndice de los seis a los que pertenece este intervalo ( <code>i = {0,1,2,3, ...}</code> ) y <code>t</code> es una cola que representa uno de los valores de una definici√≥n r√≠gida, acotada e id√©ntica para cualquiera de los seis del conjunto <code>{2,4,6,8,10,12}</code> .  La respuesta de frecuencia del √≠ndice resaltado anteriormente es casi exactamente inversamente proporcional a su valor, por lo que es l√≥gico convertir el √≠ndice seis en una estructura trivial de un c√≥digo de longitud variable, un ejemplo del cual se da arriba.  Las caracter√≠sticas de frecuencia de la pinza le permiten dividirlo en dos grupos que pueden codificarse con cadenas de bits de diferentes longitudes: los valores 6 y 12, que se encuentran con mayor frecuencia, est√°n codificados con un bit, los valores 2, 4, 8 y 10, que se encuentran con mucha menos frecuencia, est√°n codificados con dos bits.  Por supuesto, se necesita un bit m√°s para distinguir entre estas dos opciones. <br></p><p></p><p>  Una matriz que contiene paquetes de bits se complementa con campos fijos que especifican los valores iniciales de los datos presentados en el bloque y otras cantidades requeridas para restaurar una secuencia arbitraria simple o secuencial de los simples almacenados en el bloque. <br></p><p></p><p>  Adem√°s de esta estructura de √≠ndice de bloque, el uso de c√≥digos de longitud variable se complica por los costos adicionales en comparaci√≥n con los intervalos de bits fijos. <br></p><p></p><p>  Cuando se utilizan intervalos de tama√±o fijo, determinar el bloque en el que buscar un n√∫mero primo por su n√∫mero de serie es una tarea bastante simple, porque el n√∫mero de intervalos por bloque se conoce de antemano.  Pero la b√∫squeda de una soluci√≥n simple al valor m√°s cercano no tiene una soluci√≥n directa.  Alternativamente, puede usar alguna f√≥rmula emp√≠rica que le permita encontrar el n√∫mero de bloque aproximado con el intervalo requerido, despu√©s de lo cual tendr√° que buscar el bloque deseado mediante una b√∫squeda exhaustiva. <br></p><p></p><p>  Para una tabla con c√≥digos de longitud variable, se requiere el mismo enfoque para ambas tareas: tanto para obtener un valor por n√∫mero como para buscar por valor.  Como la longitud de los c√≥digos var√≠a, nunca se sabe de antemano cu√°ntas diferencias se almacenan en un bloque en particular y en qu√© bloque reside el valor deseado.  Se determin√≥ experimentalmente que con un tama√±o de bloque de 512 bytes (que incluye algunos bytes de encabezado), la capacidad del bloque puede llegar hasta el 10-12 por ciento del valor promedio.  Los bloques m√°s peque√±os dan una dispersi√≥n relativa a√∫n mayor.  Al mismo tiempo, el valor promedio de la capacidad del bloque en s√≠ mismo tiende a disminuir lentamente a medida que crece la tabla.  La selecci√≥n de f√≥rmulas emp√≠ricas para la determinaci√≥n inexacta del bloque inicial para buscar el valor deseado tanto por n√∫mero como por valor es una tarea no trivial.  Alternativamente, puede usar indexaci√≥n m√°s compleja y sofisticada. <br></p><p></p><p>  Eso, de hecho, es todo. <br></p><p></p><p>  A continuaci√≥n, las sutilezas de compresi√≥n de una tabla principal utilizando c√≥digos de longitud variable y las estructuras asociadas con ella se describen de manera m√°s formal y detallada, y se proporciona el c√≥digo para las funciones de empaquetar y desempaquetar intervalos en C. <br></p><p></p><p>  El resultado <br></p><p></p><p>  La cantidad de datos traducidos de la Tabla 1TPrimo a c√≥digos de longitud variable, complementada por una estructura de √≠ndice de bloque, tambi√©n descrita a continuaci√≥n, ascendi√≥ a 26,309,295,104 bytes (24.5 GB), es decir, la relaci√≥n de compresi√≥n alcanza 11.4.  Obviamente, al aumentar la profundidad de bits, la relaci√≥n de compresi√≥n aumentar√°. <br></p><p></p><p>  El tiempo de transmisi√≥n de 280 GB de la tabla 1TPrimo en el nuevo formato fue de 1 hora.  Este es el resultado esperado despu√©s de los experimentos con intervalos de empaquetado en enteros de un solo byte.  En ambos casos, la traducci√≥n de la tabla fuente consiste principalmente en operaciones de archivos y casi no carga el procesador (en el segundo caso, la carga es a√∫n mayor debido a la mayor complejidad computacional del algoritmo).  El tiempo de acceso a los datos tampoco es muy diferente de los intervalos de un solo byte, pero el tiempo para desempaquetar un bloque completo del mismo tama√±o tom√≥ 1.5 Œºs, debido a la mayor complejidad del algoritmo para extraer c√≥digos de longitud variable. <br></p><p></p><p>  La tabla (Fig. 10) resume las caracter√≠sticas volum√©tricas de las tablas de n√∫meros primos mencionadas en este texto. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="figura 10"></p><br><p></p><p><br></p><h3>  Descripci√≥n del algoritmo de compresi√≥n </h3><br><h4>  T√©rminos y notaci√≥n </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> son n√∫meros primos de acuerdo con sus n√∫meros de serie.  Una vez m√°s (y por √∫ltima vez) enfatizo que <code>P0=2</code> es un n√∫mero primo virtual;  en aras de la uniformidad formal, este n√∫mero est√° f√≠sicamente excluido de la lista de n√∫meros primos. <br><p></p><p>  <code>G (gap)</code> - el intervalo entre dos primos consecutivos <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> : reducido a un intervalo de forma monol√≠tica: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Los seis intervalos en la forma monol√≠tica se parecen a <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> etc. <br></p><p></p><p>  <code>Q (quotient)</code> - √≠ndice de los seis reducido a una forma monol√≠tica, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> : el resto de los seis monol√≠ticos <code>R = D mod 6. R</code> siempre tiene un valor en el rango <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Los valores <code>Q</code> y <code>R</code> obtenidos por el m√©todo anterior de cualquier intervalo arbitrario <code>G</code> , debido a sus caracter√≠sticas de frecuencia estables, est√°n sujetos a compresi√≥n y almacenamiento en forma de paquetes de bits de longitud variable, que se describen a continuaci√≥n.  Las cadenas de bits que codifican los valores <code>Q</code> y <code>R</code> en un paquete se crean de diferentes maneras: para codificar el √≠ndice <code>Q</code> , <code>S</code> la cadena de bits del prefijo <code>H</code> , el flujo <code>F</code> y el bit auxiliar <code>S</code> , y el grupo de bits del infijo <code>X</code> y el bit auxiliar <code>A</code> se utilizan para codificar el resto <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> : un bit que determina el tama√±o del infijo <code>X</code> : 0: infijo de un bit, 1: dos bits. <br></p><p></p><p>  <code>X (infix)</code> : <code>X (infix)</code> 1 o 2 bits, junto con el bit de √°rbitro <code></code> , determinando mutuamente el valor de <code>R</code> tabular (la tabla tambi√©n muestra la frecuencia de los primeros seis con dichos infijos como referencia): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="bits de infijo"><br><br></p><br><p>  <code>F (fluxion)</code> es una fluxion, una derivada del √≠ndice <code>Q</code> longitud variable <code>L={0,1,2...}</code> , dise√±ada para distinguir entre la sem√°ntica de cadenas de bits <code>(), 0, 00, 000,</code> o <code>1, 01, 001</code> , etc. d. <br></p><p></p><p>  Una cadena de unidades de longitud <code>L</code> se expresa como <code>2^L - 1</code> (el signo <code>^</code> significa exponenciaci√≥n).  En notaci√≥n C, se puede obtener el mismo valor con la expresi√≥n <code>1&lt;&lt;L - 1</code> .  Entonces el valor de fluxia de longitud <code>L</code> se puede obtener de <code>Q</code> expresi√≥n <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  y restaurar <code>Q</code> de fluxia por expresi√≥n <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Como ejemplo, para las cantidades <code>Q = {0..15}</code> , se obtendr√°n las siguientes cadenas de bits de fluxia: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="bits de flujo"><br><br></p><br><p>  Los √∫ltimos dos campos de bit necesarios para empaquetar / restaurar valores son: <br></p><p></p><p>  <code>H (header)</code> : prefijo, una cadena de bits establecida en 0. <br></p><p></p><p>  <code>S (stop)</code> : bit de detenci√≥n establecido en 1, que finaliza el prefijo. <br></p><p></p><p>  De hecho, estos bits se procesan primero en cadenas de bits, le permiten determinar durante el desempaquetado o establecer durante el empaquetado el tama√±o del flujo y el comienzo de los campos de √°rbitro y flujo, inmediatamente despu√©s del bit de detenci√≥n. <br></p><p></p><p>  <code>W (width)</code> : el ancho del c√≥digo completo en bits. <br></p><p></p><p>  La estructura completa del paquete de bits se muestra en la Fig. 11: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="fig.11"><br><br></p><br><p>  Los valores de <code>Q</code> y <code>R</code> recuperados de estas cadenas nos permiten restaurar el valor inicial del intervalo: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  y la secuencia de intervalos restaurados le permite restaurar los n√∫meros primos originales a partir de un valor base dado del bloque (bloque inicial de intervalos) al agregarle todos los intervalos de este bloque en secuencia. <br></p><p></p><p>  Para trabajar con cadenas de bits, se utiliza una variable entera de 32 bits, en la que se procesan los bits menos significativos y despu√©s de usarlos, los bits se desplazan hacia la izquierda al empaquetar o hacia la derecha al desempacar. <br></p><p></p><br><h4>  Estructura de bloque </h4><br><p></p><p>  Adem√°s de las cadenas de bits, un bloque contiene informaci√≥n necesaria para buscar o agregar bits, as√≠ como para determinar el contenido de un bloque. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Mejoras </h4><br><p></p><p>  Si alimentamos la base de intervalos obtenida al mismo archivador de 7 zip, luego de una hora y media de trabajo intensivo en un servidor de 8 n√∫cleos, logra comprimir el archivo de entrada en casi un 5%.  Es decir, en la base de datos de intervalos de longitud variable desde el punto de vista del archivador, todav√≠a hay algo de redundancia.  Por lo tanto, hay razones para especular un poco (en el buen sentido de la palabra) sobre el tema de reducir a√∫n m√°s la redundancia de datos. <br></p><p></p><p>  El determinismo fundamental de la secuencia de intervalos entre los n√∫meros primos permite hacer c√°lculos exactos de la eficiencia de codificaci√≥n por un m√©todo u otro.  En particular, los bocetos peque√±os (y bastante ca√≥ticos) permitieron sacar una conclusi√≥n fundamental acerca de las ventajas de codificar seises sobre triples, y sobre las ventajas del m√©todo propuesto sobre los c√≥digos triviales de longitud variable (Fig. 12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="Fig.  12"><br><br></p><br><p>  Sin embargo, los molestos m√°ximos del gr√°fico rojo insin√∫an de manera transparente que puede haber otros m√©todos de codificaci√≥n que har√≠an el gr√°fico a√∫n m√°s suave. <br></p><p></p><p>  Otra direcci√≥n sugiere verificar la frecuencia de intervalos consecutivos.  Por consideraciones generales: dado que los intervalos 6, 12 y 18 son los m√°s comunes en una poblaci√≥n de n√∫meros primos, es probable que se encuentren con mayor frecuencia en pares (dobletes), triples (trillizos) y combinaciones similares de intervalos.  Si la repetibilidad de los duplets (y tal vez incluso los tripletes ... ¬°bueno, de repente!) Resulta ser estad√≠sticamente significativa en la masa total de intervalos, entonces tiene sentido traducirlos en alg√∫n c√≥digo separado. <br></p><p></p><p>  El experimento a gran escala revela un cierto predominio de dobletes individuales sobre otros.  Sin embargo, si se espera un liderazgo absoluto para el par <code>(6,6)</code> - 1.37% de todos los dobletes - entonces los otros ganadores de esta calificaci√≥n son mucho menos obvios: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="estad√≠sticas de doblete"><br><br></p><br><p>  Y, dado que el doblete <code>(6,6)</code> sim√©trico, y todos los otros dobletes se√±alados son asim√©tricos y se encuentran en la clasificaci√≥n de dobles espejo con la misma frecuencia, parece que el registro r√©cord del doblete <code>(6,6)</code> en esta serie deber√≠a dividirse a la mitad entre dobles no distinguibles <code>(6,6)</code> y <code>(6,6)</code> , lo que los lleva 0.68% hasta el borde de la lista de premios.  Y esto una vez m√°s confirma la observaci√≥n de que no se pueden realizar conjeturas verdaderas sobre los n√∫meros primos sin sorpresas. <br></p><p></p><p>  Las estad√≠sticas de los trillizos tambi√©n demuestran el liderazgo de tales triples de intervalos, que no encajan del todo en el supuesto especulativo que procede de la frecuencia m√°s alta de los intervalos 6, 12, 18. En orden decreciente de popularidad, los l√≠deres de frecuencia entre los trillizos son los siguientes: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="estad√≠sticas triples"><br><br></p><p>  etc. <br></p><p></p><p>  Sin embargo, me temo que los resultados de mis especulaciones ser√°n de menor inter√©s para los programadores que para los matem√°ticos, tal vez debido a las correcciones inesperadas hechas por la pr√°ctica en conjeturas intuitivas.  Es poco probable que sea posible exprimir cualquier dividendo sustancial del porcentaje mencionado de frecuencia a favor de un aumento adicional en la relaci√≥n de compresi√≥n, mientras que la complejidad del algoritmo amenaza con crecer de manera muy significativa. <br></p><p></p><p></p><h4>  Limitaciones </h4><br><p></p><p>  Ya se se√±al√≥ anteriormente que el aumento en el valor m√°ximo de los intervalos en relaci√≥n con la capacidad de los primos es muy, muy lento.  En particular, se puede ver en la Fig. 6 que el intervalo entre cualquier primo que se puede representar en el formato de un entero sin signo de 64 bits obviamente ser√° menor que 1600. <br></p><p></p><p>  La implementaci√≥n descrita le permite empaquetar y desempaquetar correctamente cualquier valor de intervalo de 18 bits (de hecho, el primer error de empaquetado ocurre con un intervalo de entrada de 442358).  No tengo suficiente imaginaci√≥n para suponer que la base de datos de intervalos primos puede crecer a tales valores: por casualidad, est√° en alg√∫n lugar alrededor de enteros de 100 bits, y para calcular con mayor precisi√≥n la pereza.  En un caso de incendio, expandir el rango de intervalos a veces no ser√° dif√≠cil. <br></p><p></p><p>  Gracias por leer este lugar :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417753/">https://habr.com/ru/post/es417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417743/index.html">Amplificadores legendarios - Anatom√≠a de la tendencia hist√≥rica: sonido de transistor fr√≠o</a></li>
<li><a href="../es417745/index.html">Experiencia personal: ingenier√≠a de datos en Upwork</a></li>
<li><a href="../es417747/index.html">Re: "Comparaci√≥n de marcos JS: React, Vue e Hyperapp"</a></li>
<li><a href="../es417749/index.html">Proyecto Loon como proyecto comercial: se firma el primer contrato</a></li>
<li><a href="../es417751/index.html">Kunstkamera: E-meter - Dispositivo de Scientology para medir thetanes</a></li>
<li><a href="../es417755/index.html">Estudio: 80% de las ICO de 2017 consideradas fraudulentas</a></li>
<li><a href="../es417757/index.html">Crear un bot para participar en la mini copa AI. Experiencia GPU</a></li>
<li><a href="../es417759/index.html">Se mi pato de goma</a></li>
<li><a href="../es417761/index.html">GitLab se est√° moviendo de Azure a Google Cloud Platform. Noticias de reubicaci√≥n y fechas de mantenimiento</a></li>
<li><a href="../es417763/index.html">MVIDroid: una revisi√≥n de la nueva biblioteca MVI (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>