<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèº üßó ‚öíÔ∏è ConfigureAwait: Foire aux questions üë≥üèø üåÇ üè†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l' article FAQ ConfigureAwait de Stephen Taub. 



 Async / await ajout√© √† .NET il y a plus de sept a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait: Foire aux questions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"> Bonjour, Habr!  Je vous pr√©sente la traduction de <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">l'</a> article <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">FAQ ConfigureAwait</a> de Stephen Taub. <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="image"><br><br>  <code>Async</code> / <code>await</code> ajout√© √† .NET il y a plus de sept ans.  Cette d√©cision a eu un impact significatif non seulement sur l'√©cosyst√®me .NET - elle se refl√®te √©galement dans de nombreux autres langages et cadres.  Actuellement, de nombreuses am√©liorations dans .NET ont √©t√© mises en ≈ìuvre en termes de constructions de langage suppl√©mentaires utilisant asynchronie, des API avec prise en charge asynchrone ont √©t√© mises en ≈ìuvre, des am√©liorations fondamentales ont √©t√© apport√©es √† l'infrastructure gr√¢ce √† laquelle <code>async</code> / <code>await</code> fonctionne comme une horloge (en particulier, les performances et les capacit√©s de diagnostic ont √©t√© am√©lior√©es dans .NET Core). <br><br>  <code>ConfigureAwait</code> est un aspect de l' <code>async</code> / <code>await</code> qui continue de soulever des questions.  J'esp√®re pouvoir r√©pondre √† bon nombre d'entre eux.  Je vais essayer de rendre cet article lisible du d√©but √† la fin, et en m√™me temps de l'ex√©cuter dans le style des r√©ponses aux questions fr√©quemment pos√©es (FAQ) afin qu'il puisse √™tre r√©f√©renc√© √† l'avenir. <a name="habracut"></a><br><br>  Pour traiter r√©ellement avec <code>ConfigureAwait</code> , nous y reviendrons un peu. <br><br><h3>  Qu'est-ce qu'un SynchronizationContext? </h3><br>  Selon la documentation <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext</a> "Fournit des fonctionnalit√©s de base pour distribuer le contexte de synchronisation dans divers mod√®les de synchronisation."  Cette d√©finition n'est pas tout √† fait √©vidente. <br><br>  Dans 99,9% des cas, le <code>SynchronizationContext</code> utilis√© simplement comme un type avec une m√©thode <code>Post</code> virtuelle qui accepte un d√©l√©gu√© pour une ex√©cution asynchrone (il existe d'autres membres virtuels dans le <code>SynchronizationContext</code> , mais ils sont moins courants et ne seront pas abord√©s dans cet article).  La m√©thode <code>Post</code> du type de base <a href="" rel="nofollow">appelle</a> litt√©ralement <a href="" rel="nofollow">simplement</a> <code>ThreadPool.QueueUserWorkItem</code> pour ex√©cuter de mani√®re asynchrone le d√©l√©gu√© fourni.  Les types d√©riv√©s remplacent <code>Post</code> afin que le d√©l√©gu√© puisse s'ex√©cuter au bon endroit au bon moment. <br><br>  Par exemple, Windows Forms a un <a href="" rel="nofollow">type</a> d√©riv√© de SynchronizationContext qui red√©finit <code>Post</code> pour faire l'√©quivalent de <code>Control.BeginInvoke</code> .  Cela signifie que tout appel √† cette m√©thode <code>Post</code> entra√Ænera un appel au d√©l√©gu√© √† un stade ult√©rieur du thread associ√© au contr√¥le correspondant - le soi-disant thread d'interface utilisateur.  Au c≈ìur de Windows Forms se trouve le traitement des messages Win32.  La boucle de message est ex√©cut√©e dans un thread d'interface utilisateur qui n'attend que le traitement des nouveaux messages.  Ces messages sont d√©clench√©s par le mouvement de la souris, les clics, la saisie au clavier, les √©v√©nements syst√®me qui sont disponibles pour √™tre ex√©cut√©s par les d√©l√©gu√©s, etc. Par cons√©quent, si vous avez une instance <code>SynchronizationContext</code> pour un thread d'interface utilisateur dans une application Windows Forms, vous devez transmettre le d√©l√©gu√© √† la m√©thode <code>Post</code> afin d'y effectuer une op√©ration. <br><br>  Windows Presentation Foundation (WPF) poss√®de √©galement un <a href="" rel="nofollow">type</a> d√©riv√© de <code>SynchronizationContext</code> avec une m√©thode <code>Post</code> remplac√©e qui "dirige" de la m√™me mani√®re le d√©l√©gu√© vers le flux d'interface utilisateur (√† l'aide de <code>Dispatcher.BeginInvoke</code> ), avec le contr√¥le WPF Dispatcher, pas le contr√¥le Windows Forms. <br><br>  Et Windows RunTime (WinRT) a son propre <a href="" rel="nofollow">type</a> d√©riv√© de <code>SynchronizationContext</code> , qui place √©galement le d√©l√©gu√© dans la <code>CoreDispatcher</code> threads de l'interface utilisateur √† l'aide de <code>CoreDispatcher</code> . <br><br>  C'est ce qui se cache derri√®re l'expression ¬´ex√©cuter le d√©l√©gu√© dans le thread d'interface utilisateur¬ª.  Vous pouvez √©galement impl√©menter votre <code>SynchronizationContext</code> avec la m√©thode <code>Post</code> et une certaine impl√©mentation.  Par exemple, je n'ai pas √† me soucier du thread dans lequel s'ex√©cute le d√©l√©gu√©, mais je veux √™tre s√ªr que tous <code>Post</code> d√©l√©gu√©s de la m√©thode <code>Post</code> dans mon <code>SynchronizationContext</code> s'ex√©cutent avec un certain degr√© de parall√©lisme limit√©.  Vous pouvez impl√©menter un <code>SynchronizationContext</code> personnalis√© de cette fa√ßon: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  Le framework xUnit a une <a href="" rel="nofollow">impl√©mentation</a> similaire <a href="" rel="nofollow">de</a> SynchronizationContext.  Ici, il est utilis√© pour r√©duire la quantit√© de code associ√©e aux tests parall√®les. <br><br>  Les avantages ici sont les m√™mes que pour toute abstraction: une seule API est fournie qui peut √™tre utilis√©e pour mettre en file d'attente le d√©l√©gu√© pour l'ex√©cution de la mani√®re souhait√©e par le programmeur, sans avoir √† conna√Ætre les d√©tails de l'impl√©mentation.  Supposons que j'√©crive une biblioth√®que o√π j'ai besoin de faire un peu de travail, puis que j'attende un d√©l√©gu√© dans le contexte d'origine.  Pour ce faire, j'ai besoin de capturer son <code>SynchronizationContext</code> , et lorsque j'aurai termin√© ce qui est n√©cessaire, je n'aurai qu'√† appeler la m√©thode <code>Post</code> de ce contexte et lui passer un d√©l√©gu√© pour l'ex√©cution.  Je n'ai pas besoin de savoir que pour Windows Forms, vous devez prendre le <code>Control</code> et utiliser son <code>BeginInvoke</code> , pour WPF utiliser <code>BeginInvoke</code> de <code>Dispatcher</code> , ou obtenir le contexte et sa file d'attente pour xUnit.  Tout ce que je dois faire est de saisir le <code>SynchronizationContext</code> actuel et de l'utiliser plus tard.  Pour ce faire, le <code>SynchronizationContext</code> a une propri√©t√© <code>Current</code> .  Cela peut √™tre impl√©ment√© comme suit: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br>  Vous pouvez d√©finir un contexte sp√©cial √† partir de la propri√©t√© <code>Current</code> √† l'aide de la m√©thode <code>SynchronizationContext.SetSynchronizationContext</code> . <br><br><h3>  Qu'est-ce qu'un planificateur de t√¢ches? </h3><br>  <code>SynchronizationContext</code> est une abstraction courante pour le ¬´planificateur¬ª.  Certains frameworks utilisent leurs propres abstractions pour cela, et <code>System.Threading.Tasks</code> ne <code>System.Threading.Tasks</code> pas exception.  Lorsqu'il existe des d√©l√©gu√©s dans la <code>Task</code> qui peuvent √™tre mis en file d'attente et ex√©cut√©s, ils sont associ√©s √† <code>System.Threading.Tasks.TaskScheduler</code> .  Il existe √©galement une m√©thode <code>Post</code> virtuelle pour mettre en file d'attente un d√©l√©gu√© (un appel de d√©l√©gu√© est impl√©ment√© √† l'aide de m√©canismes standard), <code>TaskScheduler</code> fournit une m√©thode <code>QueueTask</code> abstraite (un appel de t√¢che est impl√©ment√© √† l'aide de la m√©thode <code>ExecuteTask</code> ). <br><br>  Le planificateur par d√©faut qui renvoie <code>TaskScheduler.Default</code> est un pool de threads.  √Ä partir de <code>TaskScheduler</code> il est √©galement possible d'obtenir et de remplacer des m√©thodes pour d√©finir l'heure et le lieu de l'appel de <code>Task</code> .  Par exemple, les biblioth√®ques principales incluent le type <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> .  Une instance de cette classe fournit deux propri√©t√©s <code>TaskScheduler</code> : <code>ExclusiveScheduler</code> et <code>ConcurrentScheduler</code> .  Les t√¢ches planifi√©es dans <code>ConcurrentScheduler</code> peuvent √™tre ex√©cut√©es en parall√®le, mais en tenant compte de la restriction d√©finie par <code>ConcurrentExclusiveSchedulerPair</code> lors de sa cr√©ation (similaire √† <code>MaxConcurrencySynchronizationContext</code> ).  Aucune t√¢che <code>ConcurrentScheduler</code> ne sera ex√©cut√©e si la t√¢che est ex√©cut√©e dans <code>ExclusiveScheduler</code> et qu'une seule t√¢che exclusive est autoris√©e √† s'ex√©cuter √† la fois.  Ce comportement est tr√®s similaire √† un verrou en lecture / √©criture. <br><br>  Comme <code>SynchronizationContext</code> , <code>TaskScheduler</code> a une propri√©t√© <code>Current</code> qui renvoie le <code>TaskScheduler</code> actuel.  Cependant, contrairement √† <code>SynchronizationContext</code> , il manque une m√©thode pour d√©finir le planificateur actuel.  Au lieu de cela, le planificateur est associ√© √† la t√¢che en cours.  Ainsi, par exemple, ce programme affichera <code>True</code> , car le lambda utilis√© dans <code>StartNew</code> est ex√©cut√© dans l'instance <code>ExclusiveScheduler</code> de <code>ConcurrentExclusiveSchedulerPair</code> , et <code>TaskScheduler.Current</code> install√© sur ce planificateur: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br>  Fait int√©ressant, <code>TaskScheduler</code> fournit une m√©thode <code>FromCurrentSynchronizationContext</code> statique.  La m√©thode cr√©e un nouveau <code>TaskScheduler</code> et met en <code>TaskScheduler</code> les t√¢ches √† ex√©cuter dans le contexte <code>SynchronizationContext.Current</code> renvoy√© √† l'aide de la m√©thode <code>Post</code> . <br><br><h3>  Comment le SynchronizationContext et le TaskScheduler sont-ils li√©s √† l'attente? </h3><br>  Disons que vous devez √©crire une application d'interface utilisateur avec un bouton.  Une pression sur le bouton lance le t√©l√©chargement du texte du site Web et le d√©finit sur le bouton <code>Content</code> .  Le bouton ne doit √™tre accessible qu'√† partir de l'interface utilisateur du flux dans lequel il se trouve.Par cons√©quent, lorsque nous chargeons avec succ√®s la date et l'heure et que nous voulons les placer dans le <code>Content</code> du bouton, nous devons le faire √† partir du flux qui le contr√¥le.  Si cette condition n'est pas remplie, nous obtiendrons une exception: <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br>  Nous pouvons utiliser manuellement le <code>SynchronizationContext</code> pour d√©finir le <code>Content</code> dans le contexte source, par exemple via <code>TaskScheduler</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br>  Et nous pouvons utiliser le <code>SynchronizationContext</code> directement: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br>  Cependant, ces deux options utilisent explicitement un rappel.  Au lieu de cela, nous pouvons utiliser <code>async</code> / <code>await</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  Tout cela ¬´fonctionne tout simplement¬ª et configure avec succ√®s le <code>Content</code> dans le thread d'interface utilisateur, car dans le cas de la version impl√©ment√©e manuellement ci-dessus, par d√©faut, l'attente d'une t√¢che fait r√©f√©rence √† <code>SynchronizationContext.Current</code> et <code>TaskScheduler.Current</code> .  Lorsque vous ¬´attendez¬ª quelque chose en C #, le compilateur convertit le code d'interrogation (en appelant <code>GetAwaiter</code> ) le ¬´attendu¬ª (dans ce cas, la t√¢che) en ¬´en attente¬ª ( <code>TaskAwaiter</code> ).  L '¬´attente¬ª est responsable de l'attachement d'un rappel (souvent appel√© ¬´continuation¬ª) qui rappelle √† la machine d'√©tat lorsque l'attente est termin√©e.  Il impl√©mente cela en utilisant le contexte / planificateur qu'il a captur√© lors de l'enregistrement du rappel.  Nous allons optimiser et configurer un peu, c'est quelque chose comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br>  Ici, il est d'abord v√©rifi√© si le <code>SynchronizationContext</code> , et sinon, s'il <code>TaskScheduler</code> non standard.  S'il y en a un, alors lorsque le rappel est pr√™t pour l'appel, l'ordonnanceur captur√© sera utilis√©;  sinon, le rappel sera ex√©cut√© dans le cadre de l'op√©ration qui termine la t√¢che attendue. <br><br><h3>  Que fait ConfigureAwait (faux) </h3><br>  La m√©thode <code>ConfigureAwait</code> n'est pas sp√©ciale: elle n'est reconnue d'aucune mani√®re particuli√®re par le compilateur ou le runtime.  Il s'agit d'une m√©thode normale qui renvoie une structure ( <code>ConfiguredTaskAwaitable</code> - encapsule la t√¢che d'origine) et prend une valeur bool√©enne.  N'oubliez pas que l' <code>await</code> peut √™tre utilis√©e avec n'importe quel type qui impl√©mente le mod√®le correct.  Si un autre type est renvoy√©, cela signifie que lorsque le compilateur obtient l'acc√®s √† la m√©thode <code>GetAwaiter</code> (partie du mod√®le) des instances, mais le fait √† partir du type renvoy√© par <code>ConfigureAwait</code> , et non directement √† partir de la t√¢che.  Cela vous permet de modifier le comportement d' <code>await</code> de ce serveur sp√©cial. <br><br>  Attendre le type renvoy√© par <code>ConfigureAwait(continueOnCapturedContext: false)</code> au lieu d'attendre la <code>Task</code> affecte directement l'impl√©mentation de capture de contexte / planificateur d√©crite ci-dessus.  La logique devient quelque chose comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br>  En d'autres termes, la sp√©cification de <code>false</code> , m√™me s'il existe un contexte ou un planificateur actuel pour le rappel, implique qu'il est absent. <br><br><h3>  Pourquoi dois-je utiliser ConfigureAwait (false)? </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code> utilis√© pour emp√™cher le rappel d'√™tre forc√© d'appeler dans le contexte source ou le planificateur.  Cela nous donne plusieurs avantages: <br><br>  <b>Am√©lioration des performances.</b>  Il y a une surcharge de mise en file d'attente d'un rappel, contrairement √† un simple appel, car cela n√©cessite un travail suppl√©mentaire (et g√©n√©ralement une allocation suppl√©mentaire).  De plus, nous ne pouvons pas utiliser l'optimisation lors de l'ex√©cution (nous pouvons optimiser davantage lorsque nous savons exactement comment le rappel sera appel√©, mais s'il est transmis √† une impl√©mentation arbitraire d'abstraction, cela impose parfois des restrictions).  Pour les sections fortement charg√©es, m√™me les co√ªts suppl√©mentaires li√©s √† la v√©rification du <code>SynchronizationContext</code> actuel et du <code>TaskScheduler</code> actuel (qui impliquent tous deux l'acc√®s aux flux statiques) peuvent augmenter consid√©rablement les frais g√©n√©raux.  Si le code apr√®s <code>await</code> ne n√©cessite pas d'ex√©cution dans le contexte d'origine, √† l'aide de <code>ConfigureAwait(false)</code> , toutes ces d√©penses peuvent √™tre √©vit√©es, car il n'a pas besoin d'√™tre mis en file d'attente inutilement, il peut utiliser toutes les optimisations disponibles et peut √©galement √©viter un acc√®s inutile aux statiques du flux. <br><br>  <b>Pr√©vention de l'impasse.</b>  Consid√©rez la m√©thode de biblioth√®que qui <code>await</code> utilisations pour t√©l√©charger quelque chose √† partir du r√©seau.  Vous appelez cette m√©thode et bloquez de mani√®re synchrone, en attendant que la t√¢che se termine, par exemple, en utilisant <code>.Wait()</code> ou <code>.Result</code> ou <code>.GetAwaiter()</code> <code>.GetResult()</code> .  Consid√©rez maintenant ce qui se passe si l'appel se produit lorsque le <code>SynchronizationContext</code> actuel limite le nombre d'op√©rations qu'il <code>MaxConcurrencySynchronizationContext</code> √† 1 en utilisant explicitement <code>MaxConcurrencySynchronizationContext</code> , ou implicitement, s'il s'agit d'un contexte avec un seul thread √† utiliser (par exemple, un thread d'interface utilisateur).  Ainsi, vous appelez la m√©thode dans un seul thread, puis la bloquez, en attendant que l'op√©ration se termine.  Le t√©l√©chargement d√©marre sur le r√©seau et attend sa fin.  Par d√©faut, l'attente d'une <code>Task</code> capturera le <code>SynchronizationContext</code> (et dans ce cas), et lorsque le t√©l√©chargement √† partir du r√©seau sera termin√©, il sera mis en file d'attente vers le rappel <code>SynchronizationContext</code> , qui appellera le reste de l'op√©ration.  Mais le seul thread qui peut g√©rer le rappel dans la file d'attente est actuellement bloqu√© en attendant la fin de l'op√©ration.  Et cette op√©ration ne sera pas termin√©e tant que le rappel n'aura pas √©t√© trait√©.  Impasse!  Cela peut se produire m√™me lorsque le contexte ne limite pas la simultan√©it√© √† 1, mais que les ressources sont limit√©es d'une mani√®re ou d'une autre.  Imaginez la m√™me situation, uniquement avec une valeur de 4 pour <code>MaxConcurrencySynchronizationContext</code> .  Au lieu d'ex√©cuter l'op√©ration une fois, nous mettons en file d'attente 4 appels au contexte.  Chaque appel est effectu√© et se verrouille en pr√©vision de son ach√®vement.  Toutes les ressources sont d√©sormais bloqu√©es en attendant la fin des m√©thodes asynchrones, et la seule chose qui leur permettra de se terminer est si leurs rappels sont trait√©s par ce contexte.  Cependant, il est d√©j√† pleinement occup√©.  Impasse √† nouveau.  Si la m√©thode de biblioth√®que utilisait <code>ConfigureAwait(false)</code> place, elle ne mettrait pas en file d'attente le rappel au contexte d'origine, ce qui √©viterait les scripts de blocage. <br><br><h3>  Dois-je utiliser ConfigureAwait (vrai)? </h3><br>  Non, sauf si vous devez indiquer explicitement que vous n'utilisez pas <code>ConfigureAwait(false)</code> (par exemple, pour masquer les avertissements d'analyse statique, etc.).  <code>ConfigureAwait(true)</code> ne fait rien de significatif.  Si vous comparez la <code>await task</code> et la <code>await task</code> <code>await task.ConfigureAwait(true)</code> , ils seront fonctionnellement identiques.  Ainsi, si <code>ConfigureAwait(true)</code> pr√©sent dans le code, il peut √™tre supprim√© sans aucune cons√©quence n√©gative. <br><br>  La m√©thode <code>ConfigureAwait</code> prend une valeur bool√©enne, car dans certaines situations, il peut √™tre n√©cessaire de transmettre une variable pour contr√¥ler la configuration.  Mais dans 99% des cas, la valeur est d√©finie sur false, <code>ConfigureAwait(false)</code> . <br><br><h3>  Quand utiliser ConfigureAwait (faux)? </h3><br>  Cela d√©pend de l'impl√©mentation du code au niveau de l'application ou du code de biblioth√®que √† usage g√©n√©ral. <br><br>  Lors de l'√©criture d'applications, un comportement par d√©faut est g√©n√©ralement requis.  Si le mod√®le / environnement d'application (par exemple, Windows Forms, WPF, ASP.NET Core) publie un <code>SynchronizationContext</code> sp√©cial, il y a presque certainement une bonne raison √† cela: cela signifie que le code vous permet de prendre soin du contexte de synchronisation pour une interaction correcte avec le mod√®le / environnement d'application.  Par exemple, si vous √©crivez un gestionnaire d'√©v√©nements dans une application Windows Forms, un test dans xUnit ou du code dans un contr√¥leur ASP.NET MVC, que le mod√®le d'application ait ou non publi√© un <code>SynchronizationContext</code> , vous devez utiliser <code>SynchronizationContext</code> s'il en existe un.  Cela signifie que si <code>ConfigureAwait(true)</code> et <code>await</code> , les rappels / continuations sont renvoy√©s au contexte d'origine - tout se passe comme il se doit.  De l√†, vous pouvez formuler une r√®gle g√©n√©rale: <b>si vous √©crivez du code de niveau application, <i>n'utilisez pas</i> <code>ConfigureAwait(false)</code></b> .  Revenons au gestionnaire de clics: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code> doit √™tre ex√©cut√© dans le contexte d'origine.  Si le code a viol√© cette r√®gle et utilis√© √† la place <code>ConfigureAwait (false)</code> , il ne sera pas utilis√© dans le contexte d'origine: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br>  cela conduira √† un comportement inappropri√©.  La m√™me chose s'applique au code dans une application ASP.NET classique qui d√©pend de <code>HttpContext.Current</code> .  Lors de l'utilisation de <code>ConfigureAwait(false)</code> tentative ult√©rieure d'utilisation de la fonction <code>Context.Current</code> est susceptible de provoquer des probl√®mes. <br><br>  C'est ce qui distingue les biblioth√®ques √† usage g√©n√©ral.  Ils sont universels en partie parce qu'ils ne se soucient pas de l'environnement dans lequel ils sont utilis√©s.  Vous pouvez les utiliser √† partir d'une application Web, d'une application client ou d'un test - cela n'a pas d'importance, car le code de la biblioth√®que est ind√©pendant du mod√®le d'application dans lequel il peut √™tre utilis√©.  Agnostic signifie √©galement que la biblioth√®que ne fera rien pour interagir avec le mod√®le d'application, par exemple, elle n'aura pas acc√®s aux contr√¥les de l'interface utilisateur, car la biblioth√®que √† usage g√©n√©ral n'en sait rien.  Puisqu'il n'est pas n√©cessaire d'ex√©cuter le code dans un environnement particulier, nous pouvons √©viter de forcer les continuations / rappels √† √™tre forc√©s dans le contexte d'origine, et nous le faisons en utilisant <code>ConfigureAwait(false)</code> , ce qui nous donne des avantages de performance et augmente la fiabilit√©.  Cela nous am√®ne √† ce qui suit: <b>si vous √©crivez du code de biblioth√®que √† usage g√©n√©ral, utilisez <code>ConfigureAwait(false)</code></b> .  C'est pourquoi chaque (ou presque) attente dans les biblioth√®ques d'ex√©cution .NET Core utilise ConfigureAwait (false);  √Ä quelques exceptions pr√®s, qui sont probablement des bogues, ils seront corrig√©s.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, </font></font><a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le PR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corrig√© aucun appel </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HttpClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, cela n'a pas de sens partout. Par exemple, l'une des grandes exceptions (ou du moins les cas o√π vous devez y penser) dans les biblioth√®ques √† usage g√©n√©ral est lorsque ces biblioth√®ques ont des API qui acceptent les d√©l√©gu√©s √† un appel. Dans de tels cas, la biblioth√®que accepte le code potentiel au niveau de l'application de l'appelant, ce qui rend ces hypoth√®ses pour la biblioth√®que √† usage g√©n√©ral tr√®s controvers√©es. Imaginez, par exemple, la version asynchrone de la m√©thode Where LINQ:. </font></font><code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doit-elle </font></font><code>predicate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√™tre appel√©e dans la source du </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code appelant? Cela d√©pend de l'impl√©mentation </font></font><code>WhereAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et c'est la raison pour laquelle il peut d√©cider de ne pas l'utiliser </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√™me dans des cas particuliers, suivez la recommandation g√©n√©rale: utilisez </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si vous √©crivez un code agnostique de biblioth√®que / app-model-agnostic √† usage g√©n√©ral.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ConfigureAwait (false) garantit-il que le rappel ne sera pas ex√©cut√© dans le contexte d'origine? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non, cela garantit qu'il ne sera pas mis en file d'attente dans le contexte d'origine. </font><font style="vertical-align: inherit;">Mais cela ne signifie pas que le code suivant </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sera pas ex√©cut√© dans le contexte d'origine. </font><font style="vertical-align: inherit;">Cela est d√ª au fait que les op√©rations d√©j√† termin√©es sont renvoy√©es de mani√®re synchrone et ne sont pas forc√©ment renvoy√©es dans la file d'attente. </font><font style="vertical-align: inherit;">Par cons√©quent, si vous attendez une t√¢che qui a d√©j√† √©t√© termin√©e au moment o√π vous attendez, que vous l'utilisiez ou non </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le code imm√©diatement apr√®s continuera √† s'ex√©cuter dans le thread en cours dans un contexte toujours valide.</font></font><br><br><h3>    ConfigureAwait (false)       ,    ‚Äî ? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, non. N'oubliez pas la FAQ pr√©c√©dente. S'il </font></font><code>await task.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inclut une t√¢che qui a d√©j√† √©t√© termin√©e au moment de l'attente (ce qui se produit en fait assez souvent), alors l'utilisation </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera inutile, car le thread continue d'ex√©cuter le code suivant dans la m√©thode et est toujours dans le m√™me contexte qu'auparavant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une exception notable est que la premi√®re </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se terminera toujours de mani√®re asynchrone et que l'op√©ration attendue la rappellera dans un environnement exempt de sp√©cial </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par exemple, </font></font><code>CryptoStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans les biblioth√®ques d'ex√©cution, .NET v√©rifie que son code potentiellement intensif en calcul n'est pas ex√©cut√© dans le cadre d'une invocation synchrone du code appelant. Pour ce faire, il utilise un</font></font><code><a href="" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour vous assurer que le code apr√®s la premi√®re attente est ex√©cut√© dans le thread du pool de threads. </font><font style="vertical-align: inherit;">Cependant, m√™me dans ce cas, vous remarquerez que la prochaine attente utilise toujours </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">Techniquement, cela n'est pas n√©cessaire, mais cela simplifie consid√©rablement la r√©vision du code, car il n'est pas n√©cessaire de comprendre pourquoi il n'a pas √©t√© utilis√© </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est-il possible d'utiliser Task.Run pour √©viter d'utiliser ConfigureAwait (false)? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui, si vous √©crivez: </font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puis </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>SomethingAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serait superflue, comme le d√©l√©gu√© pass√© √† </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ex√©cuter dans un pool de threads de flux, de </font><font style="vertical-align: inherit;">sorte qu'aucune modification du code ci - </font><font style="vertical-align: inherit;">dessus, </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie la valeur </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De plus, il </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise implicitement </font></font><code>TaskScheduler.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par cons√©quent, </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'int√©rieur du d√©l√©gu√© retournera √©galement une valeur </font></font><code>Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela signifie qu'il </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura le m√™me comportement, qu'il ait √©t√© utilis√© ou non </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il ne peut pas non plus garantir ce que le code √† l'int√©rieur de ce lambda peut faire. Si vous avez un code:</font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alors le code √† l'int√©rieur </font></font><code>SomethingAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verra r√©ellement l' </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instance </font></font><code>SomeCoolSyncCtx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. et cela </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et toutes les attentes non configur√©es dans SomethingAsync seront renvoy√©es dans ce contexte. Ainsi, pour utiliser cette approche, il est n√©cessaire de comprendre ce que tout le code que vous mettez dans la file d'attente peut ou ne peut pas faire, et si ses actions peuvent devenir un obstacle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette approche se produit √©galement en raison de la n√©cessit√© de cr√©er / mettre en file d'attente un objet de t√¢che suppl√©mentaire. Cela peut ou non √™tre important pour l'application / la biblioth√®que, selon les exigences de performances.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gardez √©galement √† l'esprit que ces solutions de contournement peuvent causer plus de probl√®mes que d'avantages et avoir des cons√©quences inattendues diff√©rentes. </font><font style="vertical-align: inherit;">Par exemple, certains outils d'analyse statique </font></font><code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signalent les</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attentes qui n'utilisent pas </font><a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;">CA2007</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous allumez l'analyseur, puis utilisez une telle astuce pour √©viter l'utilisation </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il y a une forte probabilit√© que l'analyseur le marque. </font><font style="vertical-align: inherit;">Cela peut impliquer encore plus de travail, par exemple, vous pouvez d√©sactiver l'analyseur en raison de son importunit√©, ce qui impliquera de sauter d'autres endroits de la base de code o√π vous devez vraiment l'utiliser </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est-il possible d'utiliser SynchronizationContext.SetSynchronizationContext pour √©viter d'utiliser ConfigureAwait (false)? </font></font></h3><br>  Non.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que ce soit possible. </font><font style="vertical-align: inherit;">Cela d√©pend de l'impl√©mentation utilis√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains d√©veloppeurs le font:</font></font><br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'espoir que cela forcera le code √† l'int√©rieur √† </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voir le contexte actuel comme </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il en sera ainsi. </font><font style="vertical-align: inherit;">Cependant, cette option n'affectera pas celle qu'elle </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voit </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par cons√©quent, si le code est ex√©cut√© dans un sp√©cial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est √† </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'int√©rieur </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'il verra et fera la queue pour ce sp√©cial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans la </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ, les m√™mes mises en garde s'appliquent ici: il y a certaines cons√©quences de cette approche, et le code √† l'int√©rieur du bloc </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √©galement interf√©rer avec ces tentatives en d√©finissant un contexte diff√©rent (ou en appelant le code √† l'aide d'un planificateur de t√¢ches non standard). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec ce mod√®le, vous devez √©galement faire attention aux modifications mineures:</font></font><br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voyez quel est le probl√®me? </font><font style="vertical-align: inherit;">Un peu difficile √† remarquer, mais c'est impressionnant. </font><font style="vertical-align: inherit;">Il n'y a aucune garantie que l'attente finira par provoquer un rappel / continuer dans le thread d'origine. </font><font style="vertical-align: inherit;">Cela signifie que le retour </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'original peut ne pas se produire dans le thread d'origine, ce qui peut conduire au fait que les √©l√©ments de travail suivants dans ce thread verront le mauvais contexte. </font><font style="vertical-align: inherit;">Pour contrer cela, des mod√®les d'application bien √©crits qui d√©finissent un contexte sp√©cial ajoutent g√©n√©ralement du code pour le r√©initialiser manuellement avant d'appeler un code personnalis√© suppl√©mentaire. </font><font style="vertical-align: inherit;">Et m√™me si cela se produit dans un thread, cela peut prendre un certain temps pendant lequel le contexte peut ne pas √™tre correctement restaur√©. </font><font style="vertical-align: inherit;">Et si cela fonctionne dans un thread diff√©rent, cela peut conduire √† l'installation du mauvais contexte.</font></font> Et ainsi de suite.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assez loin d'√™tre id√©al. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dois-je utiliser ConfigureAwait (false) si j'utilise GetAwaiter () .GetResult ()? </font></font></h3><br>  Non. <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">affecte uniquement les rappels. </font><font style="vertical-align: inherit;">En particulier, le mod√®le </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite que vous </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fournissiez la propri√©t√© </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les m√©thodes </font></font><code>GetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(√©ventuellement avec la m√©thode UnsafeOnCompleted). </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">affecte uniquement le comportement </font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donc si vous appelez directement </font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que vous le fassiez </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou qu'il n'y ait </font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aucune diff√©rence de comportement. </font><font style="vertical-align: inherit;">Par cons√©quent, si vous voyez, </font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez le remplacer par </font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en plus, pensez si vous avez vraiment besoin d'une telle impl√©mentation).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais que le code s'ex√©cute dans un environnement dans lequel il n'y aura jamais de SynchronizationContext sp√©cial ou de TaskScheduler sp√©cial. </font><font style="vertical-align: inherit;">Puis-je ne pas utiliser ConfigureAwait (faux)?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est possible. </font><font style="vertical-align: inherit;">Cela d√©pend de la confiance que vous avez √† l'√©gard du ¬´jamais¬ª. </font><font style="vertical-align: inherit;">Comme mentionn√© dans les questions pr√©c√©dentes, ce n'est pas parce que le mod√®le de l'application dans laquelle vous travaillez ne sp√©cifie pas une application sp√©ciale </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et n'appelle pas votre code dans une application sp√©ciale </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le code d'un autre utilisateur ou biblioth√®que ne les utilise pas. </font><font style="vertical-align: inherit;">Il faut donc en √™tre s√ªr, ou du moins reconna√Ætre le risque qu'une telle option soit possible.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai entendu dire que dans .NET Core, il n'est pas n√©cessaire d'appliquer ConfigureAwait (false). </font><font style="vertical-align: inherit;">En est-il ainsi?</font></font></h3><br>  Pas comme √ßa.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est n√©cessaire lorsque vous travaillez dans .NET Core pour les m√™mes raisons que lorsque vous travaillez dans .NET Framework. Rien n'a chang√© √† cet √©gard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela a chang√© si certains environnements publient le leur </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particulier, alors qu'ASP.NET classique dans le .NET Framework a le sien </font></font><code><a href="" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ASP.NET Core n'en a pas. Cela signifie que le code ex√©cut√© dans l'application ASP.NET Core ne verra pas de code sp√©cial par d√©faut </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui r√©duit le besoin </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cet environnement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cela ne signifie pas qu'il n'y aura jamais de coutume </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si un code utilisateur (ou un autre code de biblioth√®que utilis√© par l'application) d√©finit le contexte utilisateur et appelle votre code ou appelle votre code dans la t√¢che planifi√©e dans le planificateur de t√¢ches sp√©ciales, </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASP.NET Core verra un contexte ou un planificateur non standard, ce qui peut n√©cessiter une utilisation </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bien s√ªr, dans les situations o√π vous √©vitez les verrous synchrones (ce que vous devez faire dans les applications Web de toute fa√ßon) et si vous n'√™tes pas contre la faible surcharge de performances dans certains cas, vous pouvez le faire sans utiliser </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puis-je utiliser ConfigureAwait lors de ¬´l'attente de la fin de chaque t√¢che¬ª sur IAsyncEnumerable? </font></font></h3><br>  Oui<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voir l' </font></font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article MSDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour </font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;">un</font></a><font style="vertical-align: inherit;"> exemple </font><font style="vertical-align: inherit;">. </font></font><br><br> <code>Await foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correspond au mod√®le et peut donc √™tre utilis√© pour r√©pertorier </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il peut √©galement √™tre utilis√© pour r√©pertorier les √©l√©ments qui repr√©sentent la port√©e correcte de l'API. </font><font style="vertical-align: inherit;">biblioth√®ques d'ex√©cution .NET comprennent un proc√©d√© </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'expansion</font></font></a> <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laquelle renvoie un type sp√©cial, qui enveloppe </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correspond au mod√®le correct. </font><font style="vertical-align: inherit;">Lorsque le compilateur g√©n√®re des appels √† </font></font><code>MoveNextAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l' </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©num√©rateur. </font><font style="vertical-align: inherit;">Ces appels sont li√©s au type de structure d'√©num√©rateur configur√© retourn√©, qui √† son tour r√©pond aux attentes selon les besoins.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puis-je utiliser ConfigureAwait avec 'wait using' IAsyncDisposable? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui, mais avec une petite complication. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme avec </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les biblioth√®ques d'ex√©cution .NET fournissent une m√©thode d'extension </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>await using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionneront tr√®s bien car elles impl√©mentent le mod√®le appropri√© (√† savoir, elles fournissent la m√©thode appropri√©e </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me ici est que le type </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est plus </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais plut√¥t </font></font><code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, celui renvoy√© par la m√©thode d'extension </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour contourner cela, ajoutez la ligne:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le type est √† </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau souhait√© </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ce qui a √©galement pour effet d'augmenter les possibilit√©s de </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">si n√©cessaire, vous pouvez tout envelopper dans des accolades.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai utilis√© ConfigureAwait (false), mais mon AsyncLocal est toujours entr√© dans le code apr√®s avoir attendu. </font><font style="vertical-align: inherit;">Est-ce un bug?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non, c'est assez attendu. </font><font style="vertical-align: inherit;">Le flux de donn√©es </font></font><code>AsyncLocal&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est une partie </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distincte de </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si vous ne le </font><font style="vertical-align: inherit;">faites pas explicitement flux d√©connect√©s √† l' </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aide </font></font><code>ExecutionContext.SuppressFlow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(et donc des </font><font style="vertical-align: inherit;">donn√©es </font></font><code>AsyncLocal &lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passe) toujours par </font></font><code>awaits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quel que </font><font style="vertical-align: inherit;">soit qu'il soit utilis√© </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour √©viter de </font><font style="vertical-align: inherit;">capturer la source </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Plus de d√©tails sont discut√©s dans cet </font></font><a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les outils linguistiques peuvent-ils m'aider √† √©viter d'avoir √† utiliser explicitement ConfigureAwait (false) dans ma biblioth√®que? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les d√©veloppeurs de biblioth√®ques se plaignent parfois de la n√©cessit√© d'utiliser </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et demandent des alternatives moins invasives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuellement, ils ne le sont pas, du moins ils ne sont pas int√©gr√©s dans le langage / compilateur / runtime. </font><font style="vertical-align: inherit;">Cependant, il existe de nombreuses suggestions sur la fa√ßon dont cela peut √™tre mis en ≈ìuvre, par exemple: </font></font><a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le sujet qui vous int√©resse, si vous avez des id√©es nouvelles et int√©ressantes, l'auteur de l' </font></font><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous invite √† une discussion.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482354/">https://habr.com/ru/post/fr482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482338/index.html">Visual Studio pour Mac: contr√¥lez votre IDE avec des cl√©s</a></li>
<li><a href="../fr482340/index.html">De Junior'a √† Middle'a: Parser</a></li>
<li><a href="../fr482344/index.html">Pr√©parez-vous √† l'introduction d'un classement social en Russie</a></li>
<li><a href="../fr482346/index.html">ASP.NET MVC - travailler avec MySQL via ADO.NET</a></li>
<li><a href="../fr482352/index.html">Comme j'ai jet√© presque 150k dans le vent ou l'histoire de l'installation de la ventilation forc√©e dans l'appartement</a></li>
<li><a href="../fr482356/index.html">Utilisation de Windows Server sans explorateur du point de vue d'un utilisateur Windows classique</a></li>
<li><a href="../fr482358/index.html">Comment fonctionne la panique √† Rust</a></li>
<li><a href="../fr482360/index.html">D√©tective Habra: ils sont amis avec les OVNIS</a></li>
<li><a href="../fr482364/index.html">Choses que vous [peut-√™tre] ne saviez pas sur Java</a></li>
<li><a href="../fr482366/index.html">Ce que les experts en robotique pensent du pilote automatique Tesla</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>