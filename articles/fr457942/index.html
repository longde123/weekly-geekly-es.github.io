<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèΩ ‚ú® ‚óΩÔ∏è Ce que j'ai appris sur l'optimisation en Python üë©üèΩ‚Äçüè≠ üöù üéâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous. Aujourd'hui, nous voulons partager une autre traduction pr√©par√©e √† la veille du lancement du cours Python Developer . C'est parti! 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ce que j'ai appris sur l'optimisation en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/">  Bonjour √† tous.  Aujourd'hui, nous voulons partager une autre traduction pr√©par√©e √† la veille du lancement du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours Python Developer</a> .  C'est parti! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  J'ai utilis√© Python plus souvent que tout autre langage de programmation au cours des 4 √† 5 derni√®res ann√©es.  Python est le langage pr√©dominant pour les builds sous Firefox, les tests et l'outil CI.  Mercurial est √©galement principalement √©crit en Python.  J'ai √©galement √©crit un grand nombre de mes projets tiers dessus. <br><br>  Au cours de mon travail, j'ai acquis un peu de connaissances sur les performances de Python et ses outils d'optimisation.  Dans cet article, je voudrais partager cette connaissance. <br><br>  Mon exp√©rience avec Python est principalement li√©e √† l'interpr√©teur CPython, en particulier CPython 2.7.  Toutes mes observations ne sont pas universelles pour toutes les distributions Python, ou pour celles qui ont les m√™mes caract√©ristiques dans des versions similaires de Python.  Je vais essayer de le mentionner dans le r√©cit.  Gardez √† l'esprit que cet article n'est pas un aper√ßu d√©taill√© des performances Python.  Je ne parlerai que de ce que j'ai rencontr√© par moi-m√™me. <a name="habracut"></a><br><br><h2>  La charge due aux particularit√©s du d√©marrage et de l'importation des modules </h2><br>  Le d√©marrage de l'interpr√©teur Python et l'importation des modules est un processus assez long en millisecondes. <br><br>  Si vous devez d√©marrer des centaines ou des milliers de processus Python dans l'un de vos projets, ce d√©lai en millisecondes se transformera en un d√©lai pouvant aller jusqu'√† plusieurs secondes. <br><br>  Si vous utilisez Python pour fournir des outils CLI, la surcharge peut provoquer un gel notable pour l'utilisateur.  Si vous avez besoin instantan√©ment d'outils CLI, l'ex√©cution de l'interpr√©teur Python avec chaque appel rendra plus difficile l'obtention de cet outil complexe. <br><br>  J'ai d√©j√† √©crit sur ce probl√®me.  Quelques-unes de mes notes ant√©rieures en parlent, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en 2014</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en mai 2018</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octobre 2018</a> . <br><br>  Il n'y a pas beaucoup de choses que vous pouvez faire pour r√©duire le d√©lai de d√©marrage: la correction de ce cas fait r√©f√©rence √† la manipulation de l'interpr√©teur Python, car c'est lui qui contr√¥le l'ex√©cution du code, ce qui prend trop de temps.  La meilleure chose que vous puissiez faire est de d√©sactiver l'importation du module de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> dans les appels pour √©viter d'ex√©cuter du code Python suppl√©mentaire au d√©marrage.  D'un autre c√¥t√©, de nombreuses applications utilisent les fonctionnalit√©s du module site.py, vous pouvez donc l'utiliser √† vos risques et p√©rils. <br><br>  Nous devons √©galement consid√©rer le probl√®me de l'importation de modules.  √Ä quoi sert l'interpr√©teur Python s'il ne traite aucun code?  Le fait est que le code est mis √† la disposition de l'interpr√®te plus souvent gr√¢ce √† l'utilisation de modules. <br><br>  Pour importer des modules, vous devez suivre plusieurs √©tapes.  Et dans chacun d'eux, il existe une source potentielle de charges et de retards. <br><br>  Un certain retard se produit en raison de la recherche de modules et de la lecture de leurs donn√©es.  Comme je l'ai d√©montr√© avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PyOxidizer</a> , en rempla√ßant la recherche et le chargement d'un module d'un syst√®me de fichiers par une solution architecturale plus simple, qui consiste √† lire les donn√©es du module √† partir d'une structure de donn√©es en m√©moire, vous pouvez importer la biblioth√®que Python standard pour 70 √† 80% du temps de solution initial pour cette t√¢che.  Avoir un module par fichier de syst√®me de fichiers augmente la charge sur le syst√®me de fichiers et peut ralentir une application Python pendant les premi√®res millisecondes critiques d'ex√©cution.  Des solutions comme PyOxidizer peuvent aider √† √©viter cela.  J'esp√®re que la communaut√© Python voit ces co√ªts de l'approche actuelle et envisage la transition vers les m√©canismes de distribution des modules, qui ne d√©pendent pas tant des fichiers individuels du module. <br><br>  Une autre source de co√ªts d'importation suppl√©mentaires pour un module est l'ex√©cution de code dans ce module lors de l'importation.  Certains modules contiennent des parties du code dans une zone en dehors des fonctions et des classes du module, qui est ex√©cut√©e lors de l'importation du module.  L'ex√©cution d'un tel code augmente le co√ªt de l'importation.  Solution: n'ex√©cutez pas tout le code au moment de l'importation, mais ex√©cutez-le uniquement si n√©cessaire.  Python 3.7 prend en charge le module <code>__getattr__</code> , qui sera appel√© si l'attribut d'un module n'a pas √©t√© trouv√©.  Cela peut √™tre utilis√© pour remplir paresseusement les attributs de module lors du premier acc√®s. <br><br>  Une autre fa√ßon de se d√©barrasser du ralentissement de l'importation consiste √† importer paresseusement le module.  Au lieu de charger le module directement lors de l'importation, vous enregistrez un module d'importation personnalis√© qui renvoie un stub √† la place.  Lorsque vous acc√©dez pour la premi√®re fois √† ce talon, il charge le module r√©el et ¬´mute¬ª pour devenir ce module. <br><br>  Vous pouvez √©conomiser des dizaines de millisecondes avec des applications qui importent plusieurs dizaines de modules si vous contournez le syst√®me de fichiers et √©vitez d'ex√©cuter des parties inutiles du module (les modules sont g√©n√©ralement import√©s globalement, mais seules certaines fonctions de module sont utilis√©es). <br><br>  L'importation paresseuse de modules est une chose fragile.  De nombreux modules ont des mod√®les qui ont les choses suivantes: <code>try: import foo</code> ;  <code>except ImportError:</code>  Un importateur de module paresseux ne peut jamais lancer une importation d'erreur, car s'il le fait, il devra chercher dans le syst√®me de fichiers un module pour voir s'il existe en principe.  Cela ajoutera une charge suppl√©mentaire et augmentera le temps pass√©, donc les importateurs paresseux ne le font pas en principe!  Ce probl√®me est assez ennuyeux.  Importateur de modules paresseux Mercurial traite une liste de modules qui ne peuvent pas √™tre import√©s paresseusement et doit les contourner.  Un autre probl√®me est la syntaxe <code>from foo import x, y</code> , qui interrompt √©galement l'importation du module paresseux dans les cas o√π foo est un module (par opposition √† un package), car le module doit toujours √™tre import√© pour renvoyer une r√©f√©rence √† x et y. <br><br>  PyOxidizer a un ensemble fixe de modules c√¢bl√©s dans le binaire, il peut donc √™tre efficace pour augmenter ImportError.  Le module __getattr__ de Python 3.7 offre une flexibilit√© suppl√©mentaire pour les importateurs de modules paresseux.  J'esp√®re int√©grer un importateur paresseux fiable dans PyOxidizer pour automatiser certains processus. <br><br>  La meilleure solution pour √©viter de d√©marrer l'interpr√©teur et de provoquer des retards est de d√©marrer le processus d'arri√®re-plan en Python.  Si vous d√©marrez le processus Python en tant que processus d√©mon, par exemple pour un serveur Web, vous pouvez le faire.  La solution propos√©e par Mercurial consiste √† d√©marrer un processus d'arri√®re-plan qui fournit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protocole de serveur de commandes</a> .  hg est l'ex√©cutable C (ou maintenant Rust), qui se connecte √† ce processus d'arri√®re-plan et envoie une commande.  Pour trouver une approche du serveur de commandes, vous devez faire beaucoup de travail, il est extr√™mement instable et a des probl√®mes de s√©curit√©.  J'envisage l'id√©e de fournir un serveur de commandes √† l'aide de PyOxidizer afin que l'ex√©cutable ait ses avantages, et le probl√®me du co√ªt de la solution logicielle elle-m√™me a √©t√© r√©solu en cr√©ant le projet PyOxidizer. <br><br><h2>  D√©lai d'appel de fonction </h2><br>  L'appel de fonctions en Python est un processus relativement lent.  (Cette observation est moins applicable √† PyPy, qui peut ex√©cuter du code JIT.) <br><br>  J'ai vu des dizaines de correctifs pour Mercurial, ce qui a permis d'aligner et de combiner le code de mani√®re √† √©viter une charge inutile lors de l'appel de fonctions.  Dans le cycle de d√©veloppement actuel, certains efforts ont √©t√© faits pour r√©duire le nombre de fonctions appel√©es lors de la mise √† jour de la barre de progression.  (Nous utilisons des barres de progression pour toutes les op√©rations qui peuvent prendre un certain temps, afin que l'utilisateur comprenne ce qui se passe).  Obtenir les r√©sultats de l'appel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions</a> et √©viter les recherches simples parmi les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions</a> permet d'√©conomiser des dizaines de centaines de millisecondes lors de l'ex√©cution, lorsque nous parlons d'un million d'ex√©cutions, par exemple. <br><br>  Si vous avez des boucles serr√©es ou des fonctions r√©cursives en Python o√π des centaines de milliers ou plus d'appels de fonctions peuvent se produire, vous devez √™tre conscient de la surcharge d'appeler une seule fonction, car cela est d'une grande importance.  Gardez √† l'esprit les fonctions int√©gr√©es simples et la possibilit√© de combiner des fonctions pour √©viter les frais g√©n√©raux. <br><br><h2>  Frais g√©n√©raux de recherche d'attribut </h2><br>  Ce probl√®me est similaire √† la surcharge due √† un appel de fonction, car la signification est presque la m√™me! <br><br>  La recherche d'attributs de r√©solution en Python peut √™tre lente.  (Et encore une fois, dans PyPy, c'est plus rapide).  Cependant, g√©rer ce probl√®me est ce que nous faisons souvent dans Mercurial. <br><br>  Disons que vous avez le code suivant: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  Nous omettons qu'il existe des moyens plus efficaces d'√©crire cet exemple (par exemple, <code>total = sum(obj.member)</code> ), et notons que la boucle doit d√©finir obj.member √† chaque it√©ration.  Python poss√®de un m√©canisme relativement sophistiqu√© pour d√©finir des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attributs</a> .  Pour les types simples, cela peut √™tre assez rapide.  Mais pour les types complexes, cet acc√®s aux attributs peut appeler automatiquement <code>__getattr__</code> , <code>__getattribute__</code> , diverses m√©thodes de <code>dunder</code> et m√™me des fonctions d√©finies par l'utilisateur <code>@property</code> .  Ceci est similaire √† une recherche rapide d'un attribut qui peut effectuer plusieurs appels de fonction, ce qui entra√Ænera une charge suppl√©mentaire.  Et cette charge peut √™tre aggrav√©e si vous utilisez des choses comme <code>obj.member1.member2.member3</code> , etc. <br><br>  Chaque d√©finition d'attribut entra√Æne une charge suppl√©mentaire.  Et comme presque tout en Python est un dictionnaire, nous pouvons dire que chaque recherche d'attribut est une recherche de dictionnaire.  D'apr√®s les concepts g√©n√©raux sur les structures de donn√©es de base, nous savons que la recherche par dictionnaire n'est pas aussi rapide que, disons, la recherche d'index.  Oui, bien s√ªr, il existe quelques astuces dans CPython qui peuvent se d√©barrasser des frais g√©n√©raux dus aux recherches dans les dictionnaires.  Mais le sujet principal que je veux aborder est que toute recherche d'attributs est une fuite potentielle de performances. <br><br>  Pour les boucles serr√©es, en particulier celles qui d√©passent potentiellement des centaines de milliers d'it√©rations, vous pouvez √©viter ces frais g√©n√©raux mesurables pour trouver des attributs en affectant une valeur √† une variable locale.  Regardons l'exemple suivant: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  Bien s√ªr, cela ne peut √™tre fait en toute s√©curit√© que s'il n'est pas remplac√© dans un cycle.  Si cela se produit, l'it√©rateur gardera un lien vers l'ancien √©l√©ment et tout pourrait exploser. <br>  La m√™me astuce peut √™tre effectu√©e lors de l'appel de la m√©thode de l'objet.  Au lieu de cela <br><br><pre> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  Vous pouvez effectuer les op√©rations suivantes: <br><br><pre> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  Il convient √©galement de noter que dans le cas o√π la recherche d'attributs doit appeler une m√©thode (comme dans l'exemple pr√©c√©dent), alors Python 3.7 est relativement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus rapide</a> que les versions pr√©c√©dentes.  Mais je suis s√ªr qu'ici, la charge excessive est li√©e, tout d'abord, √† l'appel de fonction, et non √† la charge sur la recherche d'attributs.  Par cons√©quent, tout fonctionnera plus rapidement si vous abandonnez la recherche suppl√©mentaire d'attributs. <br><br>  Enfin, comme une recherche d'attribut appelle une fonction pour cela, on peut dire que la recherche d'attribut pose g√©n√©ralement moins de probl√®me qu'une charge due √† un appel de fonction.  En r√®gle g√©n√©rale, pour remarquer des changements importants de vitesse, vous devrez √©liminer un grand nombre de recherches d'attributs.  Dans ce cas, d√®s que vous donnez acc√®s √† tous les attributs √† l'int√©rieur de la boucle, vous ne pouvez parler de 10 ou 20 attributs que dans la boucle avant d'appeler la fonction.  Et les boucles avec aussi peu que des milliers ou moins de dizaines de milliers d'it√©rations peuvent rapidement fournir des centaines de milliers ou des millions de recherches d'attributs.  Soyez donc prudent! <br><br><h2>  Charge d'objet </h2><br>  Du point de vue de l'interpr√©teur Python, toutes les valeurs sont des objets.  En CPython, chaque √©l√©ment est une structure PyObject.  Chaque objet contr√¥l√© par l'interpr√©teur se trouve sur le tas et poss√®de sa propre m√©moire contenant le nombre de r√©f√©rences, le type d'objet et d'autres param√®tres.  Chaque objet est √©limin√© par le garbage collector.  Cela signifie que chaque nouvel objet ajoute une surcharge en raison du comptage des r√©f√©rences, de la r√©cup√©ration de place, etc.  (Et encore une fois, PyPy peut √©viter ce fardeau inutile, car il ¬´s'attache plus soigneusement¬ª √† la dur√©e de vie des valeurs √† court terme.) <br><br>  G√©n√©ralement, plus vous cr√©ez de valeurs et d'objets Python uniques, plus les choses fonctionnent lentement pour vous. <br><br>  Disons que vous parcourez une collection d'un million d'objets.  Vous appelez une fonction pour collecter cet objet dans un tuple: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  Dans cet exemple, <code>process()</code> renverra un tuple √† 8 tuples.  Peu importe que nous d√©truisions la valeur de retour ou non: ce tuple n√©cessite de cr√©er au moins 9 valeurs en Python: 1 pour le tuple lui-m√™me et 8 pour ses membres internes.  Eh bien, dans la vie r√©elle, il peut y avoir moins de valeurs si <code>process()</code> renvoie une r√©f√©rence √† un objet existant.  Ou, au contraire, il peut y en avoir plus si leurs types ne sont pas simples et n√©cessitent de nombreux PyObjects √† repr√©senter.  Je veux juste dire que sous le capot de l'interpr√®te il y a un vrai jonglage d'objets pour la pr√©sentation compl√®te de certaines constructions. <br><br>  D'apr√®s ma propre exp√©rience, je peux dire que ces frais g√©n√©raux ne sont pertinents que pour les op√©rations qui fournissent des gains de vitesse lorsqu'ils sont impl√©ment√©s dans une langue native comme C ou Rust.  Le probl√®me est que l'interpr√©teur CPython est tout simplement incapable d'ex√©cuter le bytecode si rapidement que la charge suppl√©mentaire due au nombre d'objets compte.  Au lieu de cela, vous √™tes le plus susceptible de r√©duire les performances en appelant une fonction, ou par des calculs lourds, etc.  avant de remarquer la charge suppl√©mentaire due aux objets.  Il y a bien s√ªr quelques exceptions, √† savoir la construction de tuples ou de dictionnaires de plusieurs valeurs. <br><br>  Comme exemple concret de surcharge, vous pouvez citer Mercurial avec du code C qui analyse les structures de donn√©es de bas niveau.  Pour une plus grande vitesse d'analyse, le code C s'ex√©cute un ordre de grandeur plus rapidement que CPython.  Mais d√®s que le code C cr√©e PyObject pour repr√©senter le r√©sultat, la vitesse chute plusieurs fois.  En d'autres termes, la charge implique la cr√©ation et la gestion d'√©l√©ments Python afin qu'ils puissent √™tre utilis√©s dans du code. <br><br>  Un moyen de contourner ce probl√®me est de produire moins d'√©l√©ments en Python.  Si vous devez vous r√©f√©rer √† un seul √©l√©ment, d√©marrez la fonction et renvoyez-la, et non un tuple ou un dictionnaire de N √©l√©ments.  Cependant, n'arr√™tez pas de surveiller la charge possible due aux appels de fonction! <br><br>  Si vous avez beaucoup de code qui fonctionne assez rapidement √† l'aide de l'API CPython C, et des √©l√©ments qui doivent √™tre distribu√©s entre diff√©rents modules, faites sans les types Python qui repr√©sentent diff√©rentes donn√©es en tant que structures C et ont d√©j√† compil√© du code pour acc√©der √† ces structures au lieu de passer par l'API CPython C.  En √©vitant l'API CPython C pour acc√©der aux donn√©es, vous vous d√©barrasserez de beaucoup de charge suppl√©mentaire. <br><br>  Traiter les √©l√©ments comme des donn√©es (au lieu d'avoir des fonctions pour acc√©der √† tout dans une rang√©e) serait la meilleure approche pour un pythoniste.  Une autre solution de contournement pour le code d√©j√† compil√© consiste √† instancier paresseusement PyObject.  Si vous cr√©ez un type personnalis√© en Python (PyTypeObject) pour repr√©senter des √©l√©ments complexes, vous devez d√©finir les <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">champs</a></i> <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tp_members</a></i> ou <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tp_getset</a></i> pour cr√©er des fonctions C personnalis√©es afin de rechercher la valeur de l'attribut.  Si vous, par exemple, √©crivez un analyseur et savez que les clients n'auront acc√®s qu'√† un sous-ensemble des champs analys√©s, vous pouvez rapidement cr√©er un type contenant des donn√©es brutes, renvoyer ce type et appeler une fonction C pour rechercher des attributs Python qui traitent PyObject.  Vous pouvez m√™me retarder l'analyse jusqu'√† ce que la fonction soit appel√©e pour √©conomiser des ressources si l'analyse n'est jamais n√©cessaire!  Cette technique est assez rare, car elle n√©cessite d'√©crire du code non trivial, mais elle donne un r√©sultat positif. <br><br><h2>  D√©termination pr√©liminaire de la taille de la collection </h2><br>  Cela s'applique √† l'API CPython C. <br><br>  Lors de la cr√©ation de collections, telles que des listes ou des dictionnaires, utilisez <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> pour remplir une nouvelle collection si sa taille a d√©j√† √©t√© d√©termin√©e au moment de la cr√©ation.  Cela permettra de d√©terminer √† l'avance la taille de la collection pour pouvoir y contenir un nombre fini d'√©l√©ments.  Cela permet d'√©viter de rechercher une taille de collection suffisante lors de l'insertion d'√©l√©ments.  Lorsque vous cr√©ez une collection de milliers d'articles, cela vous fera √©conomiser des ressources! <br><br><h2>  Utilisation de Zero-copy dans l'API C </h2><br>  L'API Python C aime vraiment cr√©er des copies d'objets plut√¥t que de leur renvoyer des r√©f√©rences.  Par exemple, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PyBytes_FromStringAndSize ()</a></i> copie <code>char*</code> dans la m√©moire r√©serv√©e par Python.  Si vous faites cela pour un grand nombre de valeurs ou de m√©gadonn√©es, alors nous pourrions parler de gigaoctets d'E / S de m√©moire et de la charge associ√©e sur l'allocateur. <br><br>  Si vous avez besoin d'√©crire du code haute performance sans API C, vous devez vous familiariser avec le <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protocole tampon</a></i> et les types associ√©s, tels que <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> est int√©gr√© aux types Python et permet aux interpr√®tes de convertir le type de / en octets.  Il permet √©galement √† l'interpr√©teur de code C de recevoir un descripteur <code>void*</code> d'une certaine taille.  Cela vous permet d'associer n'importe quelle adresse en m√©moire √† PyObject.  De nombreuses fonctions qui fonctionnent avec des donn√©es binaires acceptent de mani√®re transparente tout objet qui impl√©mente le <code>buffer protocol</code> .  Et si vous souhaitez accepter tout objet pouvant √™tre consid√©r√© comme des octets, vous devez utiliser des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">unit√©s au format</a> <code>s*</code> , <code>y*</code> ou <code>w*</code> lors de la r√©ception des arguments de fonction. <br><br>  En utilisant le <code>buffer protocol</code> , vous donnez √† l'interpr√©teur la meilleure opportunit√© disponible pour utiliser <code>zero-copy</code> op√©rations de <code>zero-copy</code> et refuser de copier des octets suppl√©mentaires dans la m√©moire. <br><br>  En utilisant des types en Python de la forme <code>memoryview</code> , vous autoriserez √©galement Python √† acc√©der aux niveaux de m√©moire par r√©f√©rence, au lieu de faire des copies. <br><br>  Si vous avez des gigaoctets de code qui passent par votre programme Python, l'utilisation perspicace des types Python qui prennent en charge la copie z√©ro vous √©vitera des diff√©rences de performances.  J'ai remarqu√© une fois que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">python-zstandard</a> s'est av√©r√© √™tre plus rapide que toutes les liaisons Python LZ4 (bien que ce devrait √™tre l'inverse), car j'ai trop utilis√© le <code>buffer protocol</code> et √©vit√© les E / S de m√©moire excessives dans <code>python-zstandard</code> ! <br><br><h2>  Conclusion </h2><br>  Dans cet article, j'ai cherch√© √† parler de certaines des choses que j'ai apprises tout en optimisant mes programmes Python pendant plusieurs ann√©es.  Je r√©p√®te et dis que ce n'est en aucun cas un aper√ßu complet des m√©thodes d'am√©lioration des performances Python.  J'avoue que j'utilise probablement Python plus exigeant que les autres, et mes recommandations ne peuvent pas √™tre appliqu√©es √† tous les programmes.  <b>Vous ne devez en aucun cas corriger massivement votre code Python et supprimer, par exemple, la recherche d'attributs apr√®s avoir lu cet article</b> .  Comme toujours, en mati√®re d'optimisation des performances, corrigez d'abord o√π le code est particuli√®rement lent.    <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">py-spy</a></i>     Python.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   ‚Äì     PyPy,        .  Python      .    ,     Python  ,     .      ,          ¬´  ¬ª.   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457942/">https://habr.com/ru/post/fr457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457928/index.html">Classement d√©taill√© pour comparer deux images</a></li>
<li><a href="../fr457930/index.html">Saisie dynamique statiquement s√©curis√©e √† la Python</a></li>
<li><a href="../fr457932/index.html">Analyse du concours IDS Bypass aux Positive Hack Days 9</a></li>
<li><a href="../fr457936/index.html">Nous vous invitons √† la premi√®re conf√©rence Zabbix en Russie</a></li>
<li><a href="../fr457940/index.html">Comment scruter la contrepartie</a></li>
<li><a href="../fr457946/index.html">10 meilleures biblioth√®ques JavaScript pour visualiser les donn√©es sur des graphiques et des tableaux</a></li>
<li><a href="../fr457948/index.html">Jeux de soci√©t√© dans lesquels vous devez vous casser la t√™te</a></li>
<li><a href="../fr457952/index.html">Conception et fabrication des processeurs: fabrication de puces</a></li>
<li><a href="../fr457954/index.html">Pourquoi Swift peut devenir un grand √©v√©nement dans le Deep Learning</a></li>
<li><a href="../fr457956/index.html">Comment choisir le stockage sans se tirer une balle dans le pied</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>