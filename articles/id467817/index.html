<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘® ğŸ‘©ğŸ¾â€ğŸŒ¾ ğŸ˜± Sedikit tentang pola desain generatif ğŸ§’ğŸ» ğŸº ğŸ‘„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tema pola desain cukup populer. Banyak video direkam dan artikel ditulis. Gabungkan semua bahan ini dengan â€œanti-pola.â€ Kompleksitas tidak disengaja. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang pola desain generatif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467817/"><p>  Tema pola desain cukup populer.  Banyak video direkam dan artikel ditulis.  Gabungkan semua bahan ini dengan â€œanti-pola.â€ Kompleksitas tidak disengaja.  Akibatnya, contoh-contohnya musykil, deskripsinya membingungkan, cara mendaftarnya tidak jelas.  Dan tugas utama pola desain - penyederhanaan (kode, dan pekerjaan secara umum) tidak tercapai.  Bagaimanapun, penggunaan templat membutuhkan upaya tambahan.  Kira-kira sama dengan pengujian Unit. </p><br><p>  Saya akan mencoba menjelaskan pola desain dalam hal cara menerapkannya, di mana dan mengapa. </p><a name="habracut"></a><br><p>  Enam generator dapat dikaitkan dengan: </p><br><ul><li>  Prototipe </li><li>  Pabrik Abstrak, </li><li>  Metode Pabrik </li><li>  Pembangun </li><li>  Singleton </li><li>  Inisialisasi malas. </li></ul><br><p>  Semua pola lain yang berhubungan dengan generator adalah kasus aplikasi khusus dan tidak ada gunanya memikirkannya. </p><br><p>  Membangkitkan pola dapat dibagi menjadi tiga kelompok, pada pertanyaan yang mereka jawab.  Jadi, tiga pertanyaan: </p><br><ul><li>  Dimana? </li><li>  Bagaimana? </li><li>  Kapan? </li></ul><br><h2>  Dimana? </h2><br><p>  Tiga pola menjawab pertanyaan ini: Prototipe, Pabrik Abstrak, dan Metode Pabrik. </p><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang ketentuannya</b> <div class="spoiler_text"><p>  Dalam kerangka konsep OOP, hanya ada tiga tempat di mana secara teoritis dimungkinkan untuk menghasilkan contoh baru. </p><br><ul><li>  Produk adalah kelas yang dipakai. </li><li>  Klien adalah kelas yang akan menggunakan instance instantiated. </li><li>  Mitra - setiap kelas ketiga di bidang visibilitas Klien. </li></ul><br></div></div><br><p>  Sebenarnya, pola-pola ini menentukan tempat generasi.  Selain itu, mereka terhubung secara hierarkis dan memiliki cakupan yang berbeda.  Koneksi ditunjukkan pada gambar, panah menentukan arah panggilan. </p><br><img src="https://github.com/mtemp123/Design-Patterns/raw/master/img/Creational_patterns1.png" alt="Hirarki pola generatif"><br><p>  Dalam implementasinya, "Metode Pabrik" dapat mendelegasikan pembuatan instance ke "Pabrik" yang ada atau "Prototipe".  "Prototipe", bagaimanapun, tidak harus bergantung pada siapa pun dan melakukan semuanya sendiri.  Sekarang lebih detail. </p><br><h3>  "Prototipe" </h3><br><p>  Templat ini sesuai dengan tempat "Produk", pada kenyataannya, adalah pembangun kelas.  Dengan demikian, turunan dari kelas tertentu (yang sebelumnya dikenal) selalu dihasilkan. <br>  Dalam kerangka templat ini, perancang hanya tahu parameter yang diteruskan langsung ke sana (jumlah parameter cenderung ke jumlah bidang kelas).  Tentu saja, ada akses penuh ke semua bidang dan properti dari kelas yang dibuat. </p><br><p>  Metode "Prototipe" yang diterapkan dengan benar memungkinkan Anda untuk menyingkirkan metode inisialisasi tambahan di depan umum.  Pada gilirannya, antarmuka eksternal kelas menjadi lebih mudah dan kurang menggoda untuk menggunakan kelas untuk tujuan lain. </p><br><p>  Apa yang diberikan template ini kepada kami: </p><br><ul><li>  Konektivitas rendah - kelas hanya tahu sendiri, tidak tergantung pada data eksternal; </li><li>  Extensibility - konstruktor dapat didefinisikan ulang atau ditambahkan ke turunan; </li></ul><br><p>  Dari minus: </p><br><ul><li>  Untuk kelas kompleks, Anda mungkin perlu melewati banyak parameter untuk inisialisasi.  Meski ada solusi sepele. </li><li>  Penggunaan langsung pada Klien dapat mengganggu keterbacaan dan secara praktis memblokir kemungkinan mengganti jenis instance yang dihasilkan dalam turunan Klien. </li></ul><br><p>  Template paling populer.  Semua orang menggunakannya, tetapi sedikit yang tahu apa yang digunakannya.  Itu bagus sampai model kerja pertama diperoleh, sampai kelas dan hubungannya benar-benar ditentukan.  Setelah itu, pemrosesan dan peningkatan abstraksi adalah wajib. </p><br><h3>  "Pabrik abstrak" </h3><br><p>  Beberapa mitra kelas.  Itu bisa khusus, atau "menggabungkan".  Mungkin statis (tidak ada instance).  Contoh "menggabungkan" bisa menjadi kelas konfigurasi.  Mungkin juga tersembunyi di balik Fasad. </p><br><p>  "Factory" biasanya melihat semua pengaturan global aplikasi (atau subsistem terpisah).  Generasi segera dapat didelegasikan ke Prototipe.  Dalam hal ini, jumlah parameter input dalam metode Pabrik akan kurang dari pada konstruktor Prototipe yang sama.  Pabrik tidak memutuskan siapa yang akan dibuat berdasarkan parameter yang masuk. </p><br><p>  Template ini sangat nyaman dan mudah diimplementasikan, tetapi membutuhkan desain awal.  Jika Anda membuat pabrik untuk semuanya, ini akan menyulitkan kode.  Faktanya, kita mendapatkan analog dari Prototipe, tetapi pindah ke kelas pihak ketiga. </p><br><p>  Dari pro: </p><br><ul><li>  Redefinisi yang baik dalam keturunan </li><li>  Panggilan yang disederhanakan </li><li>  Atas dasar Pabrik, mudah untuk menerapkan substitusi (template Negara) </li></ul><br><p>  Namun ada juga kelemahannya: </p><br><br><ul><li>  Ini membutuhkan desain, terutama untuk pabrik universal (yang digunakan dalam banyak proyek).  Dengan kata lain, mendapatkan pabrik yang baik segera tidak mudah. </li><li>  Sangat mudah untuk mengacaukan kode, ada dua area utama: <br><ul><li>  Geser ke arah Prototipe, tetapi di kelas luar.  Metode kelebihan beban dengan parameter, ada banyak metode sendiri.  Akibatnya, warisan sulit, baik di Pabrik itu sendiri maupun di Klien. </li><li>  Pabrik dengan metode universal.  Metode ini mengembalikan contoh apa pun tergantung pada parameter yang dikirimkan.  Hasilnya, seperti pada kasus pertama. </li></ul><br></li></ul><br><p>  Sangat populer  Template ini digunakan oleh mereka yang menghadiri kursus GoF.  Sebagai aturan, kode menjadi lebih buruk daripada "sebelum menerapkan templat". </p><br><p>  Masuk akal ketika Pabrik muncul selama pengerjaan ulang kode pertama.  Pada tahap ini, kombinasi parameter untuk instance yang dibuat sudah diketahui, dan tidak akan sulit untuk menulis metode Pabrik umum.  Akibatnya, panggilan di Klien akan disederhanakan. </p><br><p>  Dalam beberapa kasus, lebih mudah menyembunyikan pabrik di belakang fasad.  Misalnya, aplikasi memiliki selusin pabriknya, dan selusin perpustakaan.  Bagi mereka, Anda dapat membangun fasad.  Ini akan memungkinkan tidak menghubungkan perpustakaan ke setiap modul, dan juga mudah untuk mengganti satu pabrik dengan yang lain. </p><br><h3>  Metode Pabrik </h3><br><p>  Bagian atas abstraksi dalam pola generatif.  Tempat Pelanggan asal.  Kelas di mana setiap produk ditempatkan di Metode Pabrik memiliki setiap kesempatan seumur hidup.  Jika tanpa fanatisme, maka poros pengembangan yang diasumsikan harus berdasarkan pada templat ini. </p><br><p>  Metode pabrik tidak melihat di luar kelasnya.  Jumlah parameter yang ditransmisikan secara langsung harus minimal (dalam batas nol).  Metode itu sendiri harus dibangun dengan mempertimbangkan kemungkinan tumpang tindih pada keturunan. </p><br><p>  Kesalahan umum adalah inisialisasi yang rumit dalam satu metode.  Misalnya, saat membuat turunan yang kompleks (Templat pembuat), pembuatan semua bagian dari objek masa depan ditempatkan dalam satu metode.  Akibatnya, metode seperti itu sulit untuk tumpang tindih dalam keturunan. </p><br><p>  Dari pro: </p><br><ul><li>  Akan mudah untuk mencocokkan metode templat templat </li><li>  Kami mendapatkan kode ringkas di mana logika terlihat jelas (tidak perlu dilihat di antara tumpukan metode dan parameter) </li></ul><br><p>  Pada dasarnya tidak ada kontra. </p><br><p>  Template ini hampir tidak pernah digunakan.  Sebagai aturan, itu hanya dapat dilihat dalam proyek dengan elaborasi awal yang mendalam.  Ideal ketika Metode Pabrik mendelegasikan pembuatan ke "Pabrik" atau "Prototipe." </p><br><h3>  Contoh kecil </h3><br><p>  Kami memiliki kelas untuk masuk ke file di hard drive.  Ini adalah bagaimana metode umum dalam Pola "Di mana?" Mungkin terlihat: </p><br><h4>  Prototipe: </h4><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aFilename: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; aLogLevel: TLogLevel)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p>  Semua yang harus diketahui oleh perancang diteruskan kepadanya dalam bentuk parameter. </p><br><h4>  Pabrik: </h4><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aLogLevel: TLogLevel)</span></span></span><span class="hljs-function">:</span></span> ILogger;</code> </pre> <br><p>  Pabrik tahu file yang akan ditulis, seperti ditentukan dalam pengaturan aplikasi. </p><br><h4>  Metode pabrik: </h4><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewLogger</span></span></span><span class="hljs-function">:</span></span> ILogger;</code> </pre> <br><p>  Di kelas Klien, diketahui dengan detail apa yang dicatat. </p><br><p>  Dalam desain ini, untuk mengganti kelas logging dengan sebuah rintisan, itu sudah cukup untuk mendefinisikan kembali NewLogger di keturunan klien.  Ini berguna saat melakukan tes Unit. </p><br><p>  Untuk masuk ke basis data, cukup dengan mengganti metode GetLogger di turunan dari Pabrik. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467817/">https://habr.com/ru/post/id467817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467803/index.html">Simulasi dasar interaksi fisik khusus dalam python + matplotlib</a></li>
<li><a href="../id467807/index.html">Membeli dan menjual cryptocurrency di Rusia: metode, legalisasi, risiko</a></li>
<li><a href="../id467811/index.html">Arsitektur dan pemrograman Fairchild Channel F</a></li>
<li><a href="../id467813/index.html">Tinjau perubahan dalam urutan 17 FSTEC</a></li>
<li><a href="../id467815/index.html">Media menimbulkan kepanikan bahwa "alamat IP kehabisan di Rusia." Bagaimana bisa?</a></li>
<li><a href="../id467821/index.html">Sederhanakan dan Potong yang Dibutuhkan: Wawancara dengan John Romero, pencipta Doom</a></li>
<li><a href="../id467823/index.html">Parsing: OOM di Kubernetes</a></li>
<li><a href="../id467825/index.html">Algoritma pembelajaran mesin harus dimiliki</a></li>
<li><a href="../id467827/index.html">Bagaimana kami melakukan Unity kecil kami dari awal</a></li>
<li><a href="../id467831/index.html">Jalan Berduri menuju Pemrograman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>