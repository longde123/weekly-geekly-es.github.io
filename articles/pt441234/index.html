<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅿️ 🏐 👨🏾‍💻 Efeitos de filtragem SVG. Parte 6. Criando texturas com feTurbulence 💇🏿 🌠 🏏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aprenda a usar o poderoso primitivo de filtro feTurbulence SVG para criar suas próprias texturas e efeitos de distorção. 





 A série de artigos pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efeitos de filtragem SVG. Parte 6. Criando texturas com feTurbulence</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441234/"><p>  Aprenda a usar o poderoso <strong>primitivo de</strong> filtro <strong>feTurbulence</strong> SVG para criar suas próprias texturas e efeitos de distorção. </p><br><p><img src="https://habrastorage.org/webt/eq/sn/t8/eqsnt8noyajxh4ljl8xf8l1j8vw.png"></p><br><p>  A série de artigos proposta, " <strong>SVG Filtering Effects</strong> " <strong>,</strong> de Sara Soueidan, desenvolvedora de interfaces UI / UX freelancer e autora de muitos artigos técnicos com base no Líbano, concentra-se no trabalho de filtros SVG e consiste nos seguintes artigos: </p><br><h1 id="effekty-filtracii-svg">  Efeitos de filtragem SVG </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeitos de filtragem SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1. Filtros SVG 101</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeitos de filtragem SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. Texto de estrutura de tópicos com <strong>feMorphology</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeitos de filtragem SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3. Efeito de posterização de imagem usando <strong>feComponentTransfer</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeitos de filtragem SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4. Imagens em duas cores com <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efeitos de filtragem SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5. Correspondendo o texto à superfície da textura com <strong>feDisplacementMap</strong></a> </li><li>  Efeitos de filtragem SVG.  Parte 6. Criando texturas com feTurbulence </li></ol><br><hr><a name="habracut"></a><br><p>  <strong>feTurbulence</strong> é uma das primitivas de filtro SVG mais poderosas.  A especificação define essa primitiva da seguinte maneira: </p><br><blockquote>  Esse filtro primitivo cria uma imagem usando a função de turbulência Perlin.  Permite a síntese de texturas artificiais como nuvens ou mármore.  [...] <br>  A imagem resultante preencherá toda a sub-região da primitiva de filtro para essa primitiva de filtro. </blockquote><p>  Em outras palavras, o filtro <strong>primitivo de feTurbulence</strong> gera e exibe o ruído Perlin.  Esse tipo de ruído é útil para simular vários fenômenos naturais, como nuvens, fogo e fumaça, e gerar texturas complexas, como mármore ou granito.  E, como o <strong>feFlood</strong> , a primitiva <strong>feTurbulence</strong> preenche a área de filtragem com novo conteúdo. </p><br><p>  Neste artigo, veremos como você pode criar ruído usando <strong>feTurbulence</strong> e como esse ruído pode ser usado para distorcer imagens e texto, como fizemos com a textura <strong>feDisplacementMap</strong> no artigo anterior.  Em seguida, veremos como o ruído gerado pode ser usado em combinação com os efeitos de iluminação SVG para criar uma textura simples para papel áspero. </p><br><p>  Mas primeiro, vamos revisar a <strong>feTurbulence</strong> e seus atributos e ver como cada um deles afeta o ruído gerado. </p><br><h2 id="sozdanie-turbulentnosti-i-fraktalnogo-shuma-pri-pomoschi-feturbulence">  Criando turbulência e ruído fractal com feTurbulence </h2><br><p>  Quando pretendia escrever esta série, decidi evitar o máximo possível os detalhes técnicos brutos sobre primitivas de filtro.  É por isso que não entraremos em detalhes técnicos das funções usadas para gerar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>ruído Perlin</strong></a> . </p><br><p>  Depois de ler sobre a função subjacente à geração de ruído, descobri que ela não me ajuda em nada quando montei uma primitiva para o experimento.  No final, trabalhamos com um gerador de ruído aleatório.  Assim, na maioria dos casos, você descobrirá que criar uma textura será um tópico para experimentação e ajuste até obter o resultado desejado.  Com o tempo, ficará um pouco mais fácil prever como uma textura pode parecer. </p><br><p>  Descobri que brincar com o primitivo <strong>feTurbulence</strong> e visualizar seus atributos era a melhor maneira de descobrir sobre eles e me ajudou a entender o que cada um desses atributos faz.  Portanto, estamos usando uma abordagem visual para entender a <strong>feTurbulência</strong> com algumas demos interativas. </p><br><p>  <strong>O FeTurbulence</strong> agora gera ruído usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>a função de turbulência de Perlin</strong></a> .  Possui 5 atributos principais que controlam a função e, portanto, seu resultado visual: </p><br><ul><li>  <strong>tipo</strong> ; </li><li>  <strong>baseFrequency</strong> ; </li><li>  <strong>numOctaves</strong> ; </li><li>  <strong>semente</strong> ; </li><li>  <strong>stitchTiles</strong> . </li></ul><br><p>  Examinaremos como cada um desses atributos afeta o resultado visual sem entrar nos detalhes técnicos da função.  Você descobrirá que, na maioria dos casos, você só precisa se preocupar com três desses atributos: <strong>type</strong> , <strong>baseFrequency</strong> e <strong>numOctaves</strong> . </p><br><h3 id="basefrequency">  baseFrequency </h3><br><p>  Para gerar ruído, apenas o atributo <strong>baseFrequency</strong> é <strong>necessário</strong> .  <strong>baseFrequency</strong> afeta o tamanho (ou escala) e granulação do ruído gerado. </p><br><p>  O efeito da frequência base é melhor compreendido quando é visualizado e animado.  Foi por isso que criei a próxima demonstração.  Usando o controle deslizante, você pode alterar o valor da frequência base usada e ver como isso afeta o ruído gerado em tempo real.  Você notará que, quando você aumenta ou diminui o valor do atributo <strong>baseFrequency, o</strong> padrão gerado <strong>permanece sólido, ficando menor ou maior,</strong> respectivamente, e <strong>parece que ele é dimensionado e sai da fonte no canto superior esquerdo</strong> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oJKObg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Reduzir os valores de <strong>baseFrequency</strong> , como 0,001, gera padrões grandes, enquanto valores maiores, 0,5+, criam padrões menores.  Os valores começam em 0 (sem frequência == sem padrão) e mais alto.  Valores negativos não são permitidos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Como observa Michael Mullani</strong></a> , "valores que variam de 0,02 a 0,2 são pontos de partida úteis para a maioria das texturas". </p><br><p>  Observe que o ruído gerado não tem uma cor de fundo.  Isso significa que, se você remover a cor de fundo branco do SVG, poderá ver o fundo do corpo escuro através de ruído. </p><br><p>  O atributo <strong>baseFrequency</strong> também aceita dois valores.  Se você especificar dois valores, o primeiro será usado para a frequência base ao longo do eixo X e o segundo corresponderá ao eixo Y. Ao fornecer dois valores diferentes, você pode gerar ruído vertical ou horizontal, que pode ser usado para implementar alguns efeitos fantásticos, como veremos na próxima seção. </p><br><p>  <strong>Brinque</strong> com os valores <strong>baseFrequency</strong> nesta demonstração novamente e observe como ele muda nos eixos X e Y, se você fornecer valores diferentes.  A demonstração começa com um belo ruído horizontal.  O <strong>valor</strong> de <strong>x-baseFrequency</strong> de 0,01 é relativamente pequeno, o que torna o padrão horizontal grande (conforme estendido).  Se você reduzi-lo ainda mais, por exemplo, para 0,001, verá que o padrão horizontal se tornará mais parecido com linhas.  Experimente. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/yZBBzN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="type">  tipo </h3><br><p>  Como o próprio nome sugere, o atributo <strong>type</strong> é usado para indicar o tipo de ruído gerado pela primitiva <strong>feTurbulence</strong> .  Existem dois tipos: </p><br><ul><li>  <strong>turbulência</strong> , que é o padrão; </li><li>  <strong>fractalNoise</strong> . </li></ul><br><p>  <strong>O fractalNoise</strong> cria padrões mais nebulosos e suaves; essa é uma boa base para criar texturas gasosas como nuvens.  <strong>a turbulência</strong> produz mais linhas que simulam ondulações e, portanto, é adequada como base para texturas fluidas. </p><br><p><img src="https://habrastorage.org/webt/qy/zw/3g/qyzw3gv0j-yz9g1q5ymzhuc7skm.png" alt="Ruído de turbulência à esquerda e ruído fractal à direita"><br>  Fig_1.  Barulho como turbulência à esquerda e ruído fractal à direita. </p><br><p>  Altere o valor do atributo <strong>type</strong> na seguinte demonstração para ver como o padrão criado é alterado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/GzKeeg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="numoctaves">  numOctaves </h3><br><p>  <strong>numOctaves</strong> abreviado como "número da oitava", que representa o nível de detalhe do ruído. </p><br><p>  Na música, uma oitava é a diferença de tons entre duas notas quando uma tem uma frequência duas vezes maior que a outra.  Assim, quanto maior a oitava, maior a frequência.  Na <strong>feTurbulência</strong> , quanto maior o número de oitavas, mais detalhes você pode ver no ruído que ela cria.  Por padrão, o ruído gerado é uma oitava, o que significa que o valor padrão para o atributo <strong>numOctaves</strong> é 1. </p><br><p>  Arraste o controle deslizante na seguinte demonstração para ver o efeito de aumentar o número de oitavas na textura gerada: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/YdmmBV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Você notará que, começando com <strong>numOctaves</strong> = "5", o efeito de adicionar oitavas se torna quase invisível. </p><br><h3 id="seed">  semente </h3><br><p>  O grão, conforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>definido na especificação</strong></a> , é o "número inicial do gerador de números pseudo-aleatórios".  Em outras palavras, fornece uma semente diferente para a função aleatória usada para gerar nosso ruído aleatório. </p><br><p>  Visualmente, você verá que isso afeta onde e como as "linhas onduladas" são geradas.  Isso também é melhor entendido quando você vê como isso afeta o ruído gerado em dois retângulos adjacentes. </p><br><p>  Quando o mesmo valor inicial é usado para dois retângulos adjacentes, a função usada para criar ruído através dos dois retângulos é contínua e isso será refletido visualmente pela continuidade das "linhas onduladas" ao longo das bordas desses dois retângulos. </p><br><p><img src="https://habrastorage.org/webt/f4/ns/yz/f4nsyz3yza-bxpo5gynia5vl188.png" alt="A continuidade de uma função que gera ruído aleatório pode ser vista nas bordas de dois retângulos usando o mesmo valor inicial"><br>  Fig_2.  A continuidade de uma função que gera ruído aleatório pode ser vista nas bordas de dois retângulos usando o mesmo valor inicial. </p><br><p>  Brinque com o valor do atributo <strong>seed</strong> na próxima demonstração, veja como ele afeta o ruído gerado e observe que o ruído é contínuo ao longo das bordas de dois retângulos usando o mesmo valor inicial. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/XovQEv" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="stitchtiles">  stitchTiles </h3><br><p>  <strong>O stitchTiles</strong> pode ser usado para criar um efeito de costura entre os “ladrilhos” do ruído.  O efeito desse atributo é muito semelhante ao efeito da semente, o que significa que é mais óbvio quando você tem duas áreas adjacentes (ou "ladrilhos") de ruído. </p><br><p>  Como a especificação menciona, algumas vezes o resultado da geração de ruído mostra quebras claras nas bordas do ladrilho.  Você pode dizer ao navegador para tentar nivelar os resultados para que os dois blocos apareçam "unidos" .Eu realmente gosto que o atributo e seu efeito sejam comparados à costura. </p><br><p>  Por padrão, nenhuma tentativa é feita para obter transições suaves na borda das folhas que contêm uma função de turbulência, pois o valor padrão para <strong>stitchTiles</strong> é <strong>noStitch</strong> .  Se você deseja criar um efeito de costura, pode alterar o valor para <strong>costurar</strong> . </p><br><p>  Para comparar o resultado de <strong>stitchTiles</strong> com o resultado de <strong>semente</strong> , apliquei o mesmo valor de <strong>semente</strong> ao ruído gerado nos dois retângulos na próxima demonstração.  Você já pode ver que o barulho parece contínuo entre eles.  Mude a opção <strong>stitchTiles</strong> para “ <strong>on</strong> ”, alterando seu valor para <strong>stitch</strong> para ver como o ruído altera sua localização nas bordas. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VqoOwz" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como mencionei anteriormente, existem apenas três atributos, você provavelmente usará <strong>type</strong> , <strong>baseFrequency</strong> e <strong>numOctaves</strong> .  Então, vamos nos concentrar nesses três, avançando. </p><br><h2 id="ispolzuem-shum-feturbulence-dlya-iskazheniya-kontenta">  Usando ruído feTurbulence para distorcer o conteúdo </h2><br><p>  Aqui a diversão começa.  E como começamos a usar o ruído gerado.  De fato, apenas encher a área de filtragem com ruído é inútil. </p><br><p>  Em um artigo anterior, usamos <strong>feDisplacementMap</strong> para alinhar um pedaço de texto com a textura da imagem externa.  E mencionamos que o <strong>feDisplacementMap</strong> usa as informações de cores de uma imagem para distorcer a outra.  A imagem usada como um mapa de deslocamento pode ser qualquer.  Isso significa que pode ser uma imagem externa ou uma imagem gerada em SVG, por exemplo, uma imagem gradiente ou um padrão ... bem, ou uma textura de ruído. </p><br><p>  Em outras palavras, o ruído que geramos com o <strong>feTurbulence</strong> também pode ser usado para distorcer o conteúdo se aplicado em conjunto com o <strong>feDisplacementMap</strong> .  No exemplo a seguir, usamos a saída de <strong>feTurbulence</strong> para deslocar a imagem junto com <strong>feDisplacementMap</strong> .  Eu uso o modelo de ruído horizontal fornecendo dois valores diferentes para o atributo <strong>baseFrequency</strong> , semelhante ao que fizemos anteriormente. </p><br><pre><code class="plaintext hljs">&lt;svg viewBox="0 0 180 100"&gt; &lt;filter id="noise" x="0%" y="0%" width="100%" height="100%"&gt; &lt;feTurbulence baseFrequency="0.01 0.4" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="20" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#noise)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VgZZqB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A intensidade com que a turbulência distorce a imagem é indicada no atributo de <strong>venda</strong> em <strong>feDisplacementMap</strong> .  Eu usei muita importância para tornar o efeito mais dramático. </p><br><p>  Agora, com base neste aplicativo simples, podemos abrir muito mais possibilidades para combinar esses fatos: </p><br><ul><li>  Os filtros SVG também podem ser aplicados ao conteúdo HTML; </li><li>  <strong>Os</strong> valores <strong>baseFrequency</strong> são números e, portanto, podem ser animados. </li></ul><br><p>  Há pouco menos de dois anos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Adrien Denat</strong></a> escreveu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>artigo correto</strong></a> no qual experimentou um efeito semelhante aplicado aos botões HTML.  Vamos interromper e recriar o seguinte efeito de clique no botão: </p><br><p><img src="https://habrastorage.org/webt/zc/j1/1u/zcj11uzosfkidw_nhs51icwucn0.gif"></p><br><p>  Vamos começar criando uma textura de ruído.  Esse é o estado em que o botão está distorcido e, assim que o obtivermos, animaremos o estado inicial do botão para esse estado distorcido e voltaremos clicando. </p><br><p>  Nosso objetivo aqui é distorcer o botão horizontalmente.  I.e.  usaremos e ajustaremos o ruído horizontal da demonstração anterior.  Seu efeito de distorção na imagem é muito forte, então, para começar, discarei o código alterando o valor da turbulência de (0,01 0,4) para (0 0,2): </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="turbulence" baseFrequency="0 0.2" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  O efeito se tornou um pouco melhor, mas o botão ainda está distorcido mais do que gostaríamos: </p><br><p><img src="https://habrastorage.org/webt/zc/3k/ef/zc3kefcfi1uifcdsaqskvyh8rya.png"></p><br><p>  Queremos que a distorção seja menos dramática.  Lembre-se de que podemos reduzir instantaneamente o efeito do ruído alternando o tipo de ruído da turbulência padrão para um <strong>fractalNoise</strong> mais suave.  Assim que fizermos isso, veremos que o efeito de distorção também será suavizado: </p><br><p><img src="https://habrastorage.org/webt/od/7-/3u/od7-3ubszs7r5_axgrbdzx1lixi.png"></p><br><p>  Parece muito melhor. </p><br><p>  Agora que temos o efeito de distorção com o qual estamos satisfeitos, começaremos nossa demonstração com um filtro que inicialmente não faz quase nada: </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="fractalNoise" baseFrequency="0 0.000001" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  Vamos aplicar esse filtro ao nosso botão em CSS: </p><br><pre> <code class="plaintext hljs">button { -webkit-filter: url(#noise); filter: url(#noise); }</code> </pre> <br><p>  Neste ponto, o botão ainda não aparece distorcido. </p><br><p>  Em seguida, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>o código de Adrien</strong></a> , apesar de uma versão ligeiramente modificada que usa o GSAP para animar o valor do atributo <strong>baseFrequency</strong> para (0 0,2) e vice-versa dentro da primitiva <strong>feTurbulence</strong> clicando em: </p><br><pre> <code class="plaintext hljs">var bt = document.querySelectorAll('.button')[0], turbVal = { val: 0.000001 }, turb = document.querySelectorAll('#noise feTurbulence')[0], btTl = new TimelineLite({ paused: true, onUpdate: function() { turb.setAttribute('baseFrequency', '0 ' + turbVal.val); } }); btTl.to(turbVal, 0.2, { val: 0.2 }) .to(turbVal, 0.2, { val: 0.000001 }); bt.addEventListener('click', function() { btTl.restart(); });</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>E isso é realmente tudo o que é necessário.</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Você pode jogar com a demo aqui</strong></a> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/rPBmOa" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  No momento da redação deste artigo, a demonstração funciona no Chrome e Firefox.  Esses são erros na versão atual do Safari, mas o problema será resolvido na próxima versão, pois o Safari Tech Preview mostra que a demonstração funciona bem. </p><br><p>  Embora isso não funcione no MS Edge, o botão não está distorcido, o que significa que a falta de suporte não afeta a capacidade de usá-lo.  Isso é ótimo porque <strong>você ainda pode usar esse efeito como um aprimoramento</strong> .  Se o efeito não for suportado, o botão parecerá e se comportará como um botão normal sem efeito. </p><br><p>  O artigo de Adrian inclui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>mais alguns efeitos de distorção de botão</strong></a> que usam os mesmos princípios que acabamos de ver e que definitivamente valem a pena conferir.  Existem um ou dois bons truques que todos precisam aprender. </p><br><h2 id="volnistyy-tekst-s-ispolzovaniem-feturbulence">  Texto ondulado usando feTurbulence </h2><br><p>  Um dos meus usos favoritos da <strong>feTurbulence</strong> é o efeito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>texto ondulado</strong></a> de Lucas Beber.  Em sua demo, Lucas usa várias funções de <strong>feTurbulence</strong> : </p><br><pre> <code class="plaintext hljs">&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;defs&gt; &lt;filter id="squiggly-0"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="0" /&gt; &lt;feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-1"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="1" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-2"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-3"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="3" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-4"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="4" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;/svg&gt;</code> </pre> <br><p>  ... e aplicá-los por meio de CSS a um pedaço de texto HTML usando animação CSS, anima de um para o outro: </p><br><pre> <code class="plaintext hljs">@keyframes squiggly-anim { 0% { -webkit-filter: url("#squiggly-0"); filter: url("#squiggly-0"); } 25% { -webkit-filter: url("#squiggly-1"); filter: url("#squiggly-1"); } 50% { -webkit-filter: url("#squiggly-2"); filter: url("#squiggly-2"); } 75% { -webkit-filter: url("#squiggly-3"); filter: url("#squiggly-3"); } 100% { -webkit-filter: url("#squiggly-4"); filter: url("#squiggly-4"); } }</code> </pre> <br><p>  ... criando assim um efeito ondulado. </p><br><p>  Novamente, o texto usado é real, ou seja,  está disponível para pesquisa, seleção, acesso e edição (usando o atributo <strong>contenteditable</strong> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Confira a demonstração ao vivo</strong></a> , mas tenha cuidado, pois  Esta demonstração consome muitos recursos e talvez você não precise abrir o Codepen no seu celular. </p><br><p><img src="https://habrastorage.org/webt/zu/24/_o/zu24_ohstp_gwe4srzy80dxv8ig.gif"></p><br><p>  Portanto, algumas conclusões úteis desta seção: </p><br><ul><li>  O ruído gerado pela <strong>feTurbulence</strong> pode ser usado para distorcer o conteúdo SVG e HTML. </li><li>  O valor de <strong>baseFrequency</strong> pode ser animado. </li><li>  Você pode discar a quantidade de distorção, ajustando os valores em <strong>baseFrequency</strong> e suavizando o ruído com o tipo <strong>fractalNoise</strong> . </li><li>  Embora você possa animar filtros SVG em geral, geralmente é recomendável não exagerar, porque eles podem consumir muitos recursos.  Tente manter a animação limitada a pequenas áreas;  quanto maior a área animada, mais recursos ela consumirá. </li></ul><br><p>  O primitivo <strong>feTurbulence é</strong> muito raramente, se é que alguma vez, usado sozinho.  É quase sempre usado por outras primitivas de filtro para obter efeitos individuais. </p><br><p>  Nesta seção, nós o usamos como um mapa de deslocamento no <strong>feDisplacementMap</strong> .  Vamos ver o que mais você pode fazer com isso. </p><br><h2 id="imitaciya-prirodnoy-tekstury-pri-pomoschi-feturbulence">  Imitação de textura natural com feTurbulência </h2><br><p>  Outra maneira útil de usar o ruído gerado pela <strong>feTurbulence</strong> é simular uma textura natural.  Se você já usou plug-ins de geração de ruído no <strong>After Effects</strong> , talvez já tenha encontrado essa funcionalidade e exemplos disso. </p><br><p><img src="https://habrastorage.org/webt/iy/cd/-k/iycd-kxtpu0ac7be_d6ooscwlmk.png"><br>  Fig_7.  Amostras de texturas criadas no After Effects usando o plug-in <strong>Fractal Noise</strong> .  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fonte</a> ) </p><br><p>  <strong>feTurbulence</strong> gera ruído (valores aleatórios) para cada um dos componentes R, G, B e A. Você pode alterar os valores de cada um desses componentes para obter diferentes variações de ruído.  Para simular uma textura, geralmente precisamos fazer exatamente isso: ajuste os componentes R / G / B / A (cancelando componentes, saturando outros etc.).) Para obter o resultado desejado.  Em outros casos, tudo o que precisamos fazer é lançar alguma luz sobre isso.  Literalmente. </p><br><p>  Nesta seção, veremos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>efeito de textura de papel áspero</strong></a> criado por Michael Mullany.  Para criar essa textura, precisamos iluminar a textura do ruído gerado pela <strong>feTurbulence</strong> usando fontes de iluminação SVG. </p><br><h3 id="istochniki-sveta-v-svg">  Fontes de luz em SVG </h3><br><p>  O SVG fornece convenientemente várias primitivas que você pode usar para iluminar objetos ou imagens. </p><br><p>  Existem duas primitivas de filtro usadas para indicar o tipo de luz que você deseja: </p><br><ul><li>  <strong>feDiffuseLighting</strong> , que indica luz indireta de uma fonte externa e é melhor usado para efeitos da luz solar; </li><li>  <strong>feSpecularLighting</strong> , definindo a luz secundária que retorna das superfícies refletivas. </li></ul><br><p>  Ambas as primitivas iluminam um objeto ou imagem usando o canal alfa dessa imagem como um mapa do terreno.  Valores transparentes permanecem planos, enquanto valores opacos aumentam para formar picos que são iluminados mais visivelmente. </p><br><p>  Em outras palavras, o filtro da fonte de luz usa o canal alfa de entrada para obter informações de profundidade: áreas com maior opacidade sobem para o observador e áreas com menos opacidade se afastam dele.  Isso significa que o valor alfa de um pixel na entrada é usado como a altura desse pixel na dimensão z, e o filtro usa essa altura para calcular uma superfície virtual que refletirá uma certa quantidade de luz da fonte de luz.  Isso é uma coisa muito poderosa! </p><br><p>  Ambos os tipos de luz aceitam um atributo chamado <strong>surfaceScale</strong> , que é praticamente um fator de índice z.  À medida que esse valor aumenta, as “inclinações” da textura da superfície se tornam mais íngremes. </p><br><blockquote>  “Como a <strong>feTurbulence</strong> gera um canal alfa cheio de valores de ruído de 0 a 1, forma uma boa variável de superfície Z que cria brilho quando brilhamos nele.”  Michael Mullany </blockquote><p>  Depois de decidir sobre o tipo de luz, você precisa escolher uma fonte de luz.  Existem <strong>três tipos de fontes de luz</strong> no SVG: </p><br><ul><li>  <strong>feDistantLight</strong> : é uma fonte de luz remota que está tão longe quanto desejado e, portanto, é determinada em termos de seu ângulo de inclinação do alvo.  Esta é a maneira mais adequada de representar a luz solar. </li><li>  <strong>fePointLight</strong> : representa a luz pontual que emana de um ponto específico, representado como uma coordenada tridimensional X / Y / Z.  Parece uma fonte de luz dentro de uma sala ou dentro de uma cena. </li><li>  <strong>feSpotLight</strong> : Este é um holofote que se comporta como uma luz pontual, mas seu feixe pode ser reduzido a um cone e a luz pode se voltar para outros alvos. </li></ul><br><p>  Cada uma dessas três fontes de luz possui seus próprios atributos, que são usados ​​para ajustar a luz que gera, indicando a localização da fonte no espaço 3D.  Os atributos estão além do escopo deste artigo, mas você pode aprender mais sobre eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>nesta especificação</strong></a> . </p><br><p>  Para criar e aplicar um efeito de iluminação, você precisa anexar uma fonte de luz ao tipo de iluminação.  Então, você começa escolhendo o tipo de iluminação que deseja e, em seguida, escolhe a fonte de onde virá.  E então, finalmente, você precisa especificar a cor da sua iluminação.  A propriedade <strong>cor da iluminação</strong> é usada para determinar a cor da fonte de luz para <strong>feDiffuseLighting</strong> e <strong>feSpecularLighting</strong> . </p><br><p>  Tendo considerado o básico das fontes de iluminação, passamos agora ao nosso exemplo. </p><br><p>  Para a textura do papel áspero, usaremos a luz solar.  Isso significa que usaremos iluminação difusa branca proveniente de uma fonte distante.  Traduzida em código, nossa luz fica assim: </p><br><pre> <code class="plaintext hljs">&lt;feDiffuseLighting lighting-color="white" surfaceScale="2" in=".." result=".."&gt; &lt;feDistantLight azimuth="45" elevation="60" /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Os atributos <strong>azimute</strong> e <strong>elevação</strong> determinam a posição da fonte de luz no espaço tridimensional.  Há <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>um artigo de Rafael Pons</strong></a> que é simplesmente incrível ao explicar esses dois conceitos de maneira simples e fácil de entender, além de ilustrações bonitas e convenientes que ajudam na explicação.  Eu recomendo olhar para ele. </p><br><p>  Agora que temos a luz, precisamos criar nosso ruído para iluminá-lo com esta luz.  Dividiremos a demonstração em etapas para descobrir como ela é criada. </p><br><p>  Precisamos começar em algum lugar, e começaremos gerando ruídos básicos e aleatórios como base de nossa textura: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt;</code> </pre> <br><p>  Nosso barulho é assim: </p><br><p><img src="https://habrastorage.org/webt/x3/s1/nc/x3s1nczn8xxc_3nndnn0dnzp474.png"></p><br><p>  Então lançamos nossa luz sobre ele e depois a tiramos de lá: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  A iluminação brilhante do nosso ruído nos dá a seguinte textura: </p><br><p><img src="https://habrastorage.org/webt/wn/tv/ax/wntvaxtgh5kv1s3k4e8ouexcyzm.png"></p><br><p>  Este não é o resultado da textura que estamos procurando.  A primeira coisa que notamos aqui é a presença de muitas linhas nítidas na textura.  Queremos nos livrar deles, porque não há linhas nítidas na superfície do papel.  Precisamos suavizar essas linhas.  Isso pode ser feito alterando o tipo de ruído gerado para <strong>fractalNoise</strong> : </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Isso remove todas essas arestas alinhadas da nossa textura: </p><br><p><img src="https://habrastorage.org/webt/x0/ql/iy/x0qliy7petifqf1j6j3t0uiwkpg.png"></p><br><p>  Agora estamos um passo mais perto da nossa textura áspera de papel. </p><br><p>  No entanto, a textura acima não é suficientemente áspera.  Ela não tem a "rugosidade" necessária.  Um aumento no número de peças pequenas deve torná-lo mais grosso.  Para fazer isso, aumentaremos o valor de <strong>numOctaves</strong> .  Descobrimos que cerca de 5 é um grande número para obter o nível desejado de rugosidade: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' numOctaves="5" result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  E nossa textura de papel agora fica assim: </p><br><p><img src="https://habrastorage.org/webt/2l/us/_c/2lus_co5ckpwdne52rnmqochozq.png"></p><br><p>  Ótimo! </p><br><p>  Você pode jogar com a demo aqui: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oppeJM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Esta demonstração funciona em todos os principais navegadores, incluindo o MS Edge. </p><br><p>  Se desejar, você pode ajustar um pouco mais o efeito, brincando com a fonte e a distância da luz.  Por exemplo, diminuir a <strong>elevação de uma</strong> fonte de luz de 60 para 40 deve aumentar o contraste entre as pequenas colinas na textura.  Então a textura ficará mais ou menos assim: </p><br><p><img src="https://habrastorage.org/webt/nt/kh/o-/ntkho-s-ilzh9lzzwchmrtvqktm.png"></p><br><p>  Eu recomendo brincar com os valores dos atributos das fontes de luz e ruído e ver como eles afetam a textura resultante. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  A primitiva <strong>feTurbulence</strong> é uma das operações SVG mais interessantes e poderosas.  Em combinação com outras primitivas e animações, ele é capaz de criar efeitos, texturas e interações realmente interessantes e atraentes. </p><br><p>  Presumo que a <strong>feTurbulência</strong> seja um daqueles filtros com os quais você gostaria de experimentar ou analisar o código de outras pessoas para estudá-lo melhor.  No entanto, acho que estou adivinhando como a textura ficará depois de um tempo.  E como podemos fazer muito com apenas uma textura, se você a usar com outras primitivas, existem quase incontáveis ​​efeitos possíveis que você pode criar com ela.  Eu recomendo que você examine o trabalho de outras pessoas e o desmonte para aprender melhor. </p><br><p>  Yoksel está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>experimentando os filtros</strong></a> Codepen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>SVG</strong></a> depois que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>eu falei sobre filtros SVG há</strong></a> alguns meses atrás.  Assim, você pode encontrar alguns efeitos para analisar e aprender em seu perfil do Codepen. </p><br><p><img src="https://habrastorage.org/webt/ou/d2/yi/oud2yi8fduvtdb8exyqibtbos0w.gif" alt="Uma das experiências mais recentes da Yoksel com filtros SVG usando ** feTurbulence **"><br>  Fig_13.  Um dos mais recentes experimentos de Yoksel com filtros SVG usando <strong>feTurbulence</strong> . </p><br><p>  Espero que este artigo tenha inspirado você e aberto uma nova porta à sua imaginação para que você possa ver o que pode fazer com os filtros SVG. </p><br><p>  No último artigo desta série, compartilharei alguns recursos e ferramentas adicionais para ajudá-lo a avançar com os filtros SVG e começar a construir por conta própria.  Fique conosco. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441234/">https://habr.com/ru/post/pt441234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441218/index.html">OpenAI Gym + ROS + Gazebo: treinando um robô autônomo em casa. Parte 1</a></li>
<li><a href="../pt441220/index.html">Análise de recentes ataques em massa com captura de DNS</a></li>
<li><a href="../pt441222/index.html">Por que o Kubernetes é tão complicado com repositórios?</a></li>
<li><a href="../pt441224/index.html">Crie um exemplo do ARCore de faces aumentadas no Unity</a></li>
<li><a href="../pt441226/index.html">A Forbes publicou uma lista das empresas russas de Internet mais caras em 2019</a></li>
<li><a href="../pt441236/index.html">Habraiting 2018: os melhores materiais para 2018</a></li>
<li><a href="../pt441238/index.html">Programação de inglês</a></li>
<li><a href="../pt441240/index.html">Eles perderam evidências de uma nova física no Large Hadron Collider?</a></li>
<li><a href="../pt441242/index.html">Centro de Monitoramento de Redes de Comunicação: o novo “defensor” do estado de Runet</a></li>
<li><a href="../pt441244/index.html">A vulnerabilidade do WinRar, fechada por 19 anos, permite colocar o arquivo descompactado em qualquer lugar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>