<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¸ğŸ¼ ğŸ‘¨ğŸ»â€ğŸ« ğŸ™†ğŸ» Kinerja aplikasi jaringan Linux. Pendahuluan ğŸŒµ ğŸ™ŒğŸ¿ ğŸ”¯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi web sekarang banyak digunakan, dan HTTP adalah bagian terbesar dari semua protokol transportasi. Mempelajari nuansa mengembangkan aplikasi we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kinerja aplikasi jaringan Linux. Pendahuluan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455212/"> Aplikasi web sekarang banyak digunakan, dan HTTP adalah bagian terbesar dari semua protokol transportasi.  Mempelajari nuansa mengembangkan aplikasi web, kebanyakan dari mereka sangat sedikit memperhatikan sistem operasi di mana aplikasi ini benar-benar dijalankan.  Pemisahan pengembangan (Dev) dan operasi (Ops) hanya memperburuk keadaan.  Tetapi dengan penyebaran budaya DevOps, pengembang mulai mengambil tanggung jawab untuk meluncurkan aplikasi mereka di cloud, sehingga sangat berguna bagi mereka untuk benar-benar berkenalan dengan sistem operasi backend.  Ini sangat berguna jika Anda mencoba menggunakan sistem untuk ribuan atau puluhan ribu koneksi bersamaan. <br><br>  Keterbatasan dalam layanan web sangat mirip dengan keterbatasan dalam aplikasi lain.  Baik itu memuat penyeimbang atau server basis data, semua aplikasi ini memiliki masalah serupa di lingkungan berkinerja tinggi.  Memahami batasan mendasar ini dan cara mengatasinya secara umum akan membantu Anda mengevaluasi kinerja dan skalabilitas aplikasi web Anda. <br><br>  Saya menulis seri artikel ini sebagai jawaban atas pertanyaan dari pengembang muda yang ingin menjadi arsitek sistem informasi.  Tidak mungkin untuk secara jelas memahami metode mengoptimalkan aplikasi Linux tanpa masuk ke dasar-dasar bagaimana mereka bekerja di tingkat sistem operasi.  Meskipun ada banyak jenis aplikasi, dalam seri ini saya ingin menjelajahi aplikasi jaringan, bukan yang desktop seperti browser atau editor teks.  Materi ini ditujukan untuk pengembang dan arsitek yang ingin memahami cara kerja program Linux atau Unix dan bagaimana menyusunnya untuk kinerja tinggi. <br><a name="habracut"></a><br>  Linux adalah sistem operasi <i>server</i> , dan paling sering aplikasi Anda berjalan pada OS khusus ini.  Meskipun saya mengatakan "Linux," sebagian besar waktu Anda dapat dengan aman mengasumsikan bahwa semua sistem operasi mirip Unix secara umum dimaksudkan.  Namun, saya belum menguji kode yang menyertainya pada sistem lain.  Jadi, jika Anda tertarik dengan FreeBSD atau OpenBSD, hasilnya dapat bervariasi.  Ketika saya mencoba sesuatu yang spesifik untuk Linux, saya menunjukkannya. <br><br>  Meskipun Anda dapat menggunakan pengetahuan ini untuk membuat aplikasi dari awal, dan itu akan dioptimalkan dengan sempurna, lebih baik tidak melakukannya.  Jika Anda menulis server web baru dalam C atau C ++ untuk aplikasi bisnis organisasi Anda, ini mungkin hari terakhir Anda di kantor.  Namun, pengetahuan tentang struktur aplikasi ini akan membantu dalam pemilihan program yang ada.  Anda dapat membandingkan sistem berbasis proses dengan sistem berbasis thread dan sistem berbasis acara.  Anda akan memahami dan menghargai mengapa Nginx bekerja lebih baik daripada Apache httpd, mengapa aplikasi Python berbasis Tornado dapat melayani lebih banyak pengguna daripada aplikasi Python berbasis Django. <br><br><h1>  ZeroHTTPd: Alat Belajar </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/shuveb/zero">ZeroHTTPd</a> adalah server web yang saya tulis dari awal di C sebagai alat pelatihan.  Ia tidak memiliki dependensi eksternal, termasuk akses ke Redis.  Kami menjalankan rutinitas Redis kami sendiri.  Lihat di bawah untuk detail lebih lanjut. <br><br>  Meskipun kita dapat mendiskusikan teori ini untuk waktu yang lama, tidak ada yang lebih baik daripada menulis kode, menjalankannya, dan membandingkan semua arsitektur server secara bersamaan.  Ini adalah metode yang paling jelas.  Oleh karena itu, kami akan menulis server web ZeroHTTPd sederhana menggunakan masing-masing model: berdasarkan pada proses, utas dan acara.  Mari kita periksa masing-masing server ini dan melihat bagaimana mereka bekerja dibandingkan satu sama lain.  ZeroHTTPd diimplementasikan dalam satu file C. Server berbasis peristiwa mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uthash</a> , implementasi tabel hash yang sangat baik yang dikirimkan dalam file header tunggal.  Dalam kasus lain, tidak ada ketergantungan, sehingga tidak menyulitkan proyek. <br><br>  Ada banyak komentar dalam kode untuk membantu mengatasinya.  Menjadi server web sederhana dalam beberapa baris kode, ZeroHTTPd juga kerangka kerja pengembangan web minimal.  Ini memiliki fungsi terbatas, tetapi mampu menghasilkan file statis dan halaman "dinamis" yang sangat sederhana.  Saya harus mengatakan bahwa ZeroHTTPd sangat cocok untuk mempelajari cara membuat aplikasi Linux berkinerja tinggi.  Pada umumnya, sebagian besar layanan web menunggu permintaan, memeriksa dan memprosesnya.  Inilah yang akan dilakukan ZeroHTTPd.  Ini adalah alat belajar, bukan alat produksi.  Dia tidak pandai menangani kesalahan dan tidak mungkin membanggakan praktik-praktik keamanan terbaik (oh ya, saya menggunakan <code>strcpy</code> ) atau trik-trik muslihat C. Tapi saya harap dia melakukan tugasnya dengan baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd0/fd7/c03/cd0fd7c03567dcb48c1e615a63a19c48.png"><br>  <i><font color="gray">Beranda ZeroHTTPd.</font></i>  <i><font color="gray">Itu dapat menghasilkan berbagai jenis file, termasuk gambar</font></i> <br><br><h1>  Aplikasi Buku Tamu </h1><br>  Aplikasi web modern biasanya tidak terbatas pada file statis.  Mereka memiliki interaksi yang kompleks dengan berbagai database, cache, dll. Oleh karena itu, kami akan membuat aplikasi web sederhana yang disebut "Buku Tamu", di mana pengunjung meninggalkan entri dengan nama mereka.  Buku tamu menyimpan entri yang tersisa sebelumnya.  Ada juga penghitung pengunjung di bagian bawah halaman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/997/b6b/39e/997b6b39e116c216a13422e1a3fcd7b6.png"><br>  <i><font color="gray">Aplikasi Web Buku Tamu ZeroHTTPd</font></i> <br><br>  Konter pengunjung dan entri buku tamu disimpan di Redis.  Untuk komunikasi dengan Redis, prosedur sendiri diterapkan, mereka independen dari perpustakaan eksternal.  Saya bukan penggemar berat kode yang dikembangkan di rumah ketika ada solusi yang tersedia untuk umum dan teruji.  Tetapi tujuan ZeroHTTPd adalah untuk mempelajari kinerja Linux dan akses ke layanan eksternal, sementara melayani permintaan HTTP secara serius mempengaruhi kinerja.  Kami harus sepenuhnya mengendalikan komunikasi dengan Redis di setiap arsitektur server kami.  Dalam satu arsitektur, kami menggunakan panggilan pemblokiran, di arsitektur lain kami menggunakan prosedur berbasis acara.  Menggunakan pustaka klien Redis eksternal tidak akan memberikan kontrol seperti itu.  Selain itu, klien Redis kecil kami hanya melakukan beberapa fungsi (mendapatkan, mengatur, dan meningkatkan kunci; mendapatkan dan menambah array).  Selain itu, protokol Redis sangat elegan dan sederhana.  Dia bahkan tidak perlu diajar secara khusus.  Fakta bahwa protokol melakukan semua pekerjaan dalam sekitar seratus baris kode menunjukkan seberapa baik dipikirkan. <br><br>  Gambar berikut menunjukkan aplikasi ketika klien (browser) meminta <code>/guestbookURL</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f4/6cc/bb0/9f46ccbb030a53a1822678afac4e518f.png"><br>  <i><font color="gray">Mekanisme aplikasi buku tamu</font></i> <br><br>  Saat Anda perlu menerbitkan halaman buku tamu, ada satu panggilan ke sistem file untuk membaca templat ke dalam memori dan tiga panggilan jaringan ke Redis.  File template berisi sebagian besar konten HTML untuk halaman dalam screenshot di atas.  Ada juga tempat penampung khusus untuk bagian dinamis dari konten: catatan dan konter pengunjung.  Kami mendapatkannya dari Redis, menyisipkannya di halaman dan memberikan konten yang sepenuhnya dibentuk klien.  Panggilan ketiga ke Redis dapat dihindari karena Redis mengembalikan nilai kunci baru ketika ditambahkan.  Namun, untuk server kami dengan arsitektur berbasis peristiwa yang tidak sinkron, banyak panggilan jaringan merupakan ujian yang baik untuk tujuan pelatihan.  Dengan demikian, kami membuang nilai pengembalian Redis tentang jumlah pengunjung dan memintanya dalam panggilan terpisah. <br><br><h1>  Arsitektur Server ZeroHTTPd </h1><br>  Kami sedang membangun tujuh versi ZeroHTTPd dengan fungsi yang sama tetapi arsitektur yang berbeda: <br><br><ul><li>  Berulang <br></li><li>  Server garpu (proses satu anak per permintaan) <br></li><li>  Server pre-fork (proses pre-fork) <br></li><li>  Server dengan utas (satu utas per permintaan) <br></li><li>  Server dengan pra-threading <br></li><li>  Arsitektur berbasis <code>poll()</code> <br></li><li>  Arsitektur epoll </li></ul><br>  Kami mengukur kinerja setiap arsitektur dengan memuat server dengan permintaan HTTP.  Tetapi ketika membandingkan arsitektur dengan tingkat paralelisme yang tinggi, jumlah permintaan meningkat.  Kami menguji tiga kali dan mempertimbangkan rata-rata. <br><br><h1>  Metodologi uji </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d37/97d/a33/d3797da3301e7b3d8b9e93fbfb3aeafa.png"><br>  <i><font color="gray">Instalasi untuk pengujian stres ZeroHTTPd</font></i> <br><br>  Penting bahwa ketika melakukan pengujian semua komponen tidak bekerja pada mesin yang sama.  Dalam hal ini, OS membawa overhead perencanaan tambahan, karena komponen bersaing untuk CPU.  Mengukur overhead sistem operasi dari masing-masing arsitektur server yang dipilih adalah salah satu tujuan paling penting dari latihan ini.  Menambahkan lebih banyak variabel akan merusak proses.  Oleh karena itu, pengaturan pada gambar di atas berfungsi paling baik. <br><br><h3>  Apa yang dilakukan masing-masing server ini </h3><br><ul><li>  load.unixism.net: di sini kita menjalankan <code>ab</code> , utilitas Apache Benchmark.  Ini menghasilkan beban yang diperlukan untuk menguji arsitektur server kami. <br></li><li>  nginx.unixism.net: kadang-kadang kita ingin menjalankan lebih dari satu contoh program server.  Untuk ini, server Nginx dengan pengaturan yang sesuai berfungsi sebagai penyeimbang beban yang berasal dari <i>ab</i> ke proses server kami. <br></li><li>  zerohttpd.unixism.net: di sini kita menjalankan program server kami pada tujuh arsitektur yang berbeda, satu per satu. <br></li><li>  redis.unixism.net: daemon Redis berjalan di server ini, tempat entri disimpan di buku tamu dan konter pengunjung. </li></ul><br>  Semua server berjalan pada satu inti prosesor.  Idenya adalah untuk mengevaluasi kinerja maksimum setiap arsitektur.  Karena semua program server diuji pada perangkat keras yang sama, ini adalah tingkat dasar untuk membandingkannya.  Setup pengujian saya terdiri dari server virtual yang disewa dari Digital Ocean. <br><br><h3>  Apa yang kita ukur? </h3><br>  Anda dapat mengukur berbagai indikator.  Kami mengevaluasi kinerja setiap arsitektur dalam konfigurasi ini, memuat server dengan permintaan pada berbagai tingkat konkurensi: beban bertambah dari 20 menjadi 15.000 pengguna secara bersamaan. <br><br><h1>  Hasil tes </h1><br>  Diagram berikut menunjukkan kinerja server pada arsitektur yang berbeda di berbagai tingkat concurrency.  Sumbu y adalah jumlah permintaan per detik, sumbu x adalah koneksi paralel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f5/01a/a17/4f501aa1794e1d9eddc4f57fad5e96d3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff7/9bc/306/ff79bc306edde1b6f1bc39b4d2aeaa38.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b30/b9b/322/b30b9b322ec0d8fa20bfc5e7010a7a5d.png"><br><br>  Di bawah ini adalah tabel dengan hasilnya. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td colspan="7">  permintaan per detik </td></tr><tr><td>  <strong>konkurensi</strong> </td><td>  <strong>berulang</strong> </td><td>  <strong>garpu</strong> </td><td>  <strong>garpu pra</strong> </td><td>  <strong>streaming</strong> </td><td>  <strong>pra-streaming</strong> </td><td>  <strong>jajak pendapat</strong> </td><td>  <strong>epoll</strong> </td></tr><tr><td>  20 </td><td>  7 </td><td>  112 </td><td>  2100 </td><td>  1800 </td><td>  2250 </td><td>  1900 </td><td>  2050 </td></tr><tr><td>  50 </td><td>  7 </td><td>  190 </td><td>  2200 </td><td>  1700 </td><td>  2200 </td><td>  2000 </td><td>  2000 </td></tr><tr><td>  100 </td><td>  7 </td><td>  245 </td><td>  2200 </td><td>  1700 </td><td>  2200 </td><td>  2150 </td><td>  2100 </td></tr><tr><td>  200 </td><td>  7 </td><td>  330 </td><td>  2300 </td><td>  1750 </td><td>  2300 </td><td>  2200 </td><td>  2100 </td></tr><tr><td>  300 </td><td>  - </td><td>  380 </td><td>  2200 </td><td>  1800 </td><td>  2400 </td><td>  2250 </td><td>  2150 </td></tr><tr><td>  400 </td><td>  - </td><td>  410 </td><td>  2200 </td><td>  1750 </td><td>  2600 </td><td>  2000 </td><td>  2000 </td></tr><tr><td>  500 </td><td>  - </td><td>  440 </td><td>  2300 </td><td>  1850 </td><td>  2700 </td><td>  1900 </td><td>  2212 </td></tr><tr><td>  600 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1800 </td><td>  2500 </td><td>  1700 </td><td>  2519 </td></tr><tr><td>  700 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1600 </td><td>  2490 </td><td>  1550 </td><td>  2607 </td></tr><tr><td>  800 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1600 </td><td>  2540 </td><td>  1400 </td><td>  2553 </td></tr><tr><td>  900 </td><td>  - </td><td>  460 </td><td>  2300 </td><td>  1600 </td><td>  2472 </td><td>  1200 </td><td>  2567 </td></tr><tr><td>  1000 </td><td>  - </td><td>  475 </td><td>  2300 </td><td>  1700 </td><td>  2485 </td><td>  1150 </td><td>  2439 </td></tr><tr><td>  1500 </td><td>  - </td><td>  490 </td><td>  2400 </td><td>  1550 </td><td>  2620 </td><td>  900 </td><td>  2479 </td></tr><tr><td>  2000 </td><td>  - </td><td>  350 </td><td>  2400 </td><td>  1400 </td><td>  2396 </td><td>  550 </td><td>  2200 </td></tr><tr><td>  2500 </td><td>  - </td><td>  280 </td><td>  2100 </td><td>  1300 </td><td>  2453 </td><td>  490 </td><td>  2262 </td></tr><tr><td>  3000 </td><td>  - </td><td>  280 </td><td>  1900 </td><td>  1250 </td><td>  2502 </td><td>  penyebaran luas </td><td>  2138 </td></tr><tr><td>  5000 </td><td>  - </td><td>  penyebaran luas </td><td>  1600 </td><td>  1100 </td><td>  2519 </td><td>  - </td><td>  2235 </td></tr><tr><td>  8000 </td><td>  - </td><td>  - </td><td>  1200 </td><td>  penyebaran luas </td><td>  2451 </td><td>  - </td><td>  2100 </td></tr><tr><td>  10.000 </td><td>  - </td><td>  - </td><td>  penyebaran luas </td><td>  - </td><td>  2200 </td><td>  - </td><td>  2200 </td></tr><tr><td>  11.000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  2200 </td><td>  - </td><td>  2122 </td></tr><tr><td>  12.000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  970 </td><td>  - </td><td>  1958 </td></tr><tr><td>  13.000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  730 </td><td>  - </td><td>  1897 </td></tr><tr><td>  14.000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  590 </td><td>  - </td><td>  1466 </td></tr><tr><td>  15.000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  532 </td><td>  - </td><td>  1281 </td></tr></tbody></table></div><br>  Dapat dilihat dari grafik dan tabel bahwa di atas 8000 permintaan simultan, kita hanya memiliki dua pemain tersisa: pre-fork dan epoll.  Ketika beban bertambah, server berbasis polling berkinerja lebih buruk daripada streaming.  Arsitektur pra-threading bersaing dengan epoll: ini adalah bukti seberapa baik kernel Linux merencanakan sejumlah besar utas. <br><br><h1>  Kode Sumber ZeroHTTPd </h1><br>  Kode sumber untuk ZeroHTTPd ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/shuveb/zero">sini</a> .  Setiap arsitektur memiliki direktori terpisah. <br><br><pre>  ZeroHTTPd
 â”‚
 â”œâ”€â”€ 01_iterative
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 02_pekerjaan
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 03_preforking
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 04_threading
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 05_ interprethreading
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 06_poll
 â”‚ â”œâ”€â”€ main.c
 â”œâ”€â”€ 07_epoll
 â”‚ â””â”€â”€ main.c
 â”œâ”€â”€ Makefile
 â”œâ”€â”€ publik
 â”‚ â”œâ”€â”€ index.html
 â”‚ â””â”€â”€ tux.png
 â””â”€â”€ templat
     â””â”€â”€ buku tamu
         â””â”€â”€ index.html </pre><br>  Selain tujuh direktori untuk semua arsitektur, ada dua lagi di direktori tingkat atas: publik dan template.  Yang pertama berisi file index.html dan gambar dari screenshot pertama.  File dan folder lain dapat ditempatkan di sana, dan ZeroHTTPd harus mengeluarkan file statis ini tanpa masalah.  Jika path di browser cocok dengan path di folder publik, maka ZeroHTTPd mencari file index.html di direktori ini.  Konten buku tamu dibuat secara dinamis.  Ini hanya memiliki halaman utama, dan isinya didasarkan pada file 'templates / guestbook / index.html'.  ZeroHTTPd dengan mudah menambahkan halaman dinamis untuk ekspansi.  Idenya adalah bahwa pengguna dapat menambahkan template ke direktori ini dan memperluas ZeroHTTPd sesuai kebutuhan. <br><br>  Untuk membangun ketujuh server, jalankan <code>make all</code> dari direktori tingkat atas - dan semua build akan muncul di direktori ini.  Yang dapat dieksekusi mencari publik dan template direktori dalam direktori dari mana mereka dijalankan. <br><br><h1>  API Linux </h1><br>  Untuk memahami informasi dalam seri artikel ini, tidak perlu berpengalaman dalam Linux API.  Namun, saya sarankan membaca lebih lanjut tentang topik ini, ada banyak sumber referensi di Web.  Meskipun kami akan membahas beberapa kategori API Linux, fokus kami terutama pada proses, utas, acara, dan tumpukan jaringan.  Selain buku dan artikel tentang Linux API, saya juga merekomendasikan membaca mana untuk panggilan sistem dan fungsi perpustakaan yang digunakan. <br><br><h1>  Performa dan skalabilitas </h1><br>  Satu catatan tentang kinerja dan skalabilitas.  Secara teoritis, tidak ada hubungan di antara mereka.  Anda mungkin memiliki layanan web yang bekerja dengan sangat baik, dengan waktu respons beberapa milidetik, tetapi tidak berskala sama sekali.  Demikian pula, mungkin ada aplikasi web yang berjalan kurang baik yang membutuhkan waktu beberapa detik untuk merespons, tetapi ia menskala hingga puluhan untuk menangani puluhan ribu pengguna secara bersamaan.  Namun, kombinasi kinerja tinggi dan skalabilitas adalah kombinasi yang sangat kuat.  Aplikasi berkinerja tinggi umumnya menggunakan sumber daya secara ekonomis dan karenanya secara efektif melayani lebih banyak pengguna secara bersamaan di server, mengurangi biaya. <br><br><h1>  CPU dan I / O Tasks </h1><br>  Akhirnya, selalu ada dua jenis tugas yang mungkin dalam komputasi: untuk I / O dan CPU.  Menerima permintaan melalui Internet (I / O jaringan), pemeliharaan file (I / O jaringan dan disk), komunikasi dengan basis data (I / O jaringan dan disk) adalah semua tindakan I / O.  Beberapa permintaan basis data dapat memuat CPU sedikit (menyortir, menghitung rata-rata satu juta hasil, dll.).  Sebagian besar aplikasi web dibatasi oleh I / O maksimum yang mungkin, dan prosesor jarang digunakan pada kapasitas penuh.  Ketika Anda melihat bahwa beberapa CPU menggunakan banyak CPU, ini kemungkinan besar merupakan tanda arsitektur aplikasi yang buruk.  Ini mungkin berarti bahwa sumber daya CPU dihabiskan untuk kontrol proses dan pengalihan konteks - dan ini tidak sepenuhnya berguna.  Jika Anda melakukan sesuatu seperti pemrosesan gambar, konversi audio atau pembelajaran mesin, maka aplikasi tersebut membutuhkan sumber daya CPU yang kuat.  Tetapi untuk sebagian besar aplikasi ini tidak demikian. <br><br><h1>  Lebih lanjut tentang arsitektur server </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian I. Arsitektur Iteratif</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian II</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server garpu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian III.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server pre-fork</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian IV</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server dengan Utas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian V. Server dengan pra-pembuatan utas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian VI.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur berbasis jajak pendapat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian VII.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur epoll</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455212/">https://habr.com/ru/post/id455212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455200/index.html">Impor Dinamis dalam JavaScript</a></li>
<li><a href="../id455202/index.html">Data besar dalam manajemen hotel: penggunaan tidak dapat diabaikan</a></li>
<li><a href="../id455204/index.html">Menetas pesawat ruang angkasa Soyuz MS-14 ternyata sempit untuk robot FEDOR</a></li>
<li><a href="../id455206/index.html">5 pertanyaan tes untuk pencarian pekerjaan cepat di Jerman</a></li>
<li><a href="../id455210/index.html">Carding dan kotak hitam: bagaimana ATM diretas hari ini</a></li>
<li><a href="../id455214/index.html">Stanford, kita tampaknya memiliki masalah ...</a></li>
<li><a href="../id455216/index.html">Pengukur kecepatan Doppler</a></li>
<li><a href="../id455218/index.html">Pendekatan Ekosistem untuk Teknologi Bisnis</a></li>
<li><a href="../id455224/index.html">Musik Jari: Mainkan Apa Pun Dengan Sphero's SpecDrums</a></li>
<li><a href="../id455226/index.html">Mengapa menerapkan ahli bahasa terapan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>