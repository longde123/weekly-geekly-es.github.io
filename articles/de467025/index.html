<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏽 💈 🔳 Über das Netzwerkmodell in Spielen für Anfänger 🔱 🚣 ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zwei Wochen habe ich an einer Netzwerk-Engine für mein Spiel gearbeitet. Vorher wusste ich nichts über Netzwerktechnologien in Spielen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über das Netzwerkmodell in Spielen für Anfänger</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="Bild"></div><br>  In den letzten zwei Wochen habe ich an einer Netzwerk-Engine für mein Spiel gearbeitet.  Vorher wusste ich nichts über Netzwerktechnologien in Spielen, deshalb las ich viele Artikel und führte viele Experimente durch, um alle Konzepte zu verstehen und meine eigene Netzwerk-Engine schreiben zu können. <br><br>  In diesem Handbuch möchte ich Ihnen verschiedene Konzepte vorstellen, die Sie lernen müssen, bevor Sie Ihre eigene Spiel-Engine schreiben, sowie die besten Ressourcen und Artikel, um sie zu lernen. <br><br>  Im Allgemeinen gibt es zwei Haupttypen von Netzwerkarchitekturen: Peer-to-Peer und Client-Server.  In der Peer-to-Peer-Architektur (p2p) werden Daten zwischen einem beliebigen Paar verbundener Player übertragen, und in der Client-Server-Architektur werden Daten nur zwischen den Playern und dem Server übertragen. <br><br>  Obwohl die Peer-to-Peer-Architektur in einigen Spielen immer noch verwendet wird, ist der Standard Client-Server: Sie ist einfacher zu implementieren, erfordert eine geringere Kanalbreite und erleichtert den Schutz vor Betrug.  Daher konzentrieren wir uns in diesem Handbuch auf die Client-Server-Architektur. <br><a name="habracut"></a><br>  Insbesondere sind wir am meisten an autoritären Servern interessiert: In solchen Systemen hat der Server immer Recht.  Wenn ein Spieler beispielsweise denkt, dass er sich in Koordinaten befindet (10, 5) und der Server ihm mitteilt, dass er sich in Koordinaten befindet (5, 3), sollte der Client seine Position durch die vom Server übertragene Position ersetzen und nicht umgekehrt.  Die Verwendung autoritärer Server erleichtert die Erkennung von Betrügern. <br><br>  Gaming-Netzwerksysteme bestehen aus drei Hauptkomponenten: <br><br><ul><li>  Transportprotokoll: Wie Daten zwischen Clients und Server übertragen werden. </li><li>  Anwendungsprotokoll: Was wird von Clients zum Server und vom Server zu Clients übertragen und in welchem ​​Format. </li><li>  Anwendungslogik: Wie übertragene Daten verwendet werden, um den Status von Clients und Servern zu aktualisieren. </li></ul><br>  Es ist sehr wichtig, die Rolle jedes Teils und die damit verbundenen Schwierigkeiten zu verstehen. <br><br><h1>  Transportprotokoll </h1><br>  Der erste Schritt besteht darin, ein Protokoll für den Datentransport zwischen Server und Clients auszuwählen.  Hierfür gibt es zwei Internetprotokolle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCP</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP</a> .  Sie können jedoch Ihr eigenes Transportprotokoll basierend auf einem von ihnen erstellen oder die Bibliothek verwenden, in der sie verwendet werden. <br><br><h2>  Vergleich von TCP und UDP </h2><br>  Sowohl TCP als auch UDP sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IP-</a> basiert.  IP ermöglicht es Ihnen, ein Paket von der Quelle zum Empfänger zu übertragen, garantiert jedoch nicht, dass das gesendete Paket früher oder später den Empfänger erreicht, dass es mindestens einmal erreicht wird und dass die Reihenfolge der Pakete in der richtigen Reihenfolge ankommt.  Darüber hinaus kann ein Paket nur eine begrenzte Datengröße enthalten, die durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MTU-</a> Wert angegeben wird. <br><br>  UDP ist nur eine dünne Schicht über IP.  Daher hat es die gleichen Einschränkungen.  Im Gegensatz dazu verfügt TCP über viele Funktionen.  Es bietet eine zuverlässige, geordnete Verbindung zwischen zwei Knoten mit Fehlerprüfung.  Daher ist TCP sehr praktisch und wird in vielen anderen Protokollen verwendet, beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTP</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMTP</a> .  Aber all diese Funktionen haben ihren Preis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Verzögerung</em></a> . <br><br>  Um zu verstehen, warum diese Funktionen zu Verzögerungen führen können, müssen Sie wissen, wie TCP funktioniert.  Wenn der sendende Knoten das Paket an den empfangenden Knoten weiterleitet, erwartet er eine Bestätigung (ACK).  Wenn er es nach einer bestimmten Zeit nicht erhält (weil das Paket oder die Bestätigung verloren gegangen ist oder aus anderen Gründen), sendet er das Paket erneut.  Darüber hinaus stellt TCP sicher, dass Pakete in der richtigen Reihenfolge empfangen werden. Daher können bis zum Empfang eines verlorenen Pakets alle anderen Pakete nicht verarbeitet werden, selbst wenn sie bereits vom empfangenden Knoten empfangen wurden. <br><br>  Aber wie Sie wahrscheinlich verstehen, ist die Verzögerung bei Multiplayer-Spielen sehr wichtig, insbesondere bei aktiven Genres wie FPS.  Aus diesem Grund verwenden viele Spiele UDP mit einem eigenen Protokoll. <br><br>  Ein natives UDP-basiertes Protokoll kann aus verschiedenen Gründen effizienter sein als TCP.  Beispielsweise können einige Pakete als vertrauenswürdig und andere als nicht vertrauenswürdig markiert werden.  Daher ist es ihm egal, ob das nicht vertrauenswürdige Paket den Empfänger erreicht hat.  Oder es können mehrere Datenströme verarbeitet werden, sodass ein in einem Stream verlorenes Paket die verbleibenden Streams nicht verlangsamt.  Beispielsweise kann es einen Stream für Spielereingaben und einen anderen Stream für Chat-Nachrichten geben.  Wenn eine Chat-Nachricht verloren geht, bei der es sich nicht um dringende Daten handelt, wird die dringende Eingabe nicht verlangsamt.  Oder ein proprietäres Protokoll kann die Zuverlässigkeit anders als in TCP implementieren, um in Videospielen effizienter zu sein. <br><br>  Also, wenn TCP so beschissen ist, werden wir unser eigenes Transportprotokoll basierend auf UDP erstellen? <br><br>  Alles ist etwas komplizierter.  Obwohl TCP für Gaming-Netzwerksysteme fast nicht optimal ist, kann es in Ihrem Spiel einwandfrei funktionieren und wertvolle Zeit sparen.  Beispielsweise ist Verzögerung möglicherweise kein Problem für ein rundenbasiertes Spiel oder ein Spiel, das nur in LANs gespielt werden kann, in denen es viel weniger Verzögerungen und Paketverluste gibt als im Internet. <br><br>  Viele erfolgreiche Spiele, darunter World of Warcraft, Minecraft und Terraria, verwenden TCP.  Die meisten FPS verwenden jedoch proprietäre UDP-basierte Protokolle, daher werden wir im Folgenden näher darauf eingehen. <br><br>  Wenn Sie sich für die Verwendung von TCP entscheiden, stellen Sie sicher, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Nagle-Algorithmus</a> deaktiviert ist, da er Pakete vor dem Senden puffert, was bedeutet, dass die Verzögerung erhöht wird. <br><br>  Um mehr über die Unterschiede zwischen UDP und TCP im Zusammenhang mit Multiplayer-Spielen zu erfahren, lesen Sie den Artikel von Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Eigenes Protokoll </h2><br>  Sie möchten also Ihr eigenes Transportprotokoll erstellen, wissen aber nicht, wo Sie anfangen sollen?  Sie haben Glück, denn Glenn Fiedler hat zwei erstaunliche Artikel darüber geschrieben.  Sie werden viele kluge Gedanken in ihnen finden. <br><br>  Der erste Artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmers</em></a> 2008, ist einfacher als der zweite, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Ich empfehle Ihnen, mit einem älteren zu beginnen. <br><br>  Denken Sie daran, dass Glenn Fiedler ein großer Befürworter der Verwendung seines eigenen UDP-Protokolls ist.  Und nachdem Sie seine Artikel gelesen haben, werden Sie sicherlich über seine Meinung hinwegkommen, dass TCP schwerwiegende Mängel bei Videospielen aufweist und Sie Ihr eigenes Protokoll implementieren möchten. <br><br>  Wenn Sie neu im Networking sind, tun Sie sich selbst einen Gefallen und verwenden Sie TCP oder eine Bibliothek.  Um Ihr eigenes Transportprotokoll erfolgreich zu implementieren, müssen Sie zunächst viel lernen. <br><br><h2>  Netzwerkbibliotheken </h2><br>  Wenn Sie etwas Effizienteres als TCP benötigen, sich aber nicht mit der Implementierung Ihres eigenen Protokolls befassen und auf viele Details eingehen möchten, können Sie die Netzwerkbibliothek verwenden.  Es gibt viele von ihnen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RakNet</a> , das nicht mehr unterstützt wird, dessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SLikeNet-</a> Gabel jedoch noch aktiv zu sein scheint. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ENet</a> ist eine Bibliothek, die für den Mehrbenutzer-FPS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cube erstellt wurde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GameNetworkingSockets von Valve</a> </li></ul><br>  Ich habe nicht alle ausprobiert, aber ich bevorzuge ENet, weil es einfach zu bedienen und zuverlässig ist.  Darüber hinaus verfügt sie über eine klare Dokumentation und ein Tutorial für Anfänger. <br><br><h2>  Transportprotokoll: Schlussfolgerung </h2><br>  Zusammenfassend: Es gibt zwei Haupttransportprotokolle: TCP und UDP.  TCP bietet viele nützliche Funktionen: Zuverlässigkeit, Paketreihenfolge, Fehlererkennung.  UDP hat nicht all dies, aber TCP hat naturgemäß vermehrt Verzögerungen, die für einige Spiele nicht akzeptabel sind.  Um niedrige Latenzen zu gewährleisten, können Sie Ihr eigenes UDP-basiertes Protokoll erstellen oder eine Bibliothek verwenden, die das UDP-Transportprotokoll implementiert und für Videospiele für mehrere Spieler geeignet ist. <br><br>  Die Wahl zwischen TCP, UDP und der Bibliothek hängt von mehreren Faktoren ab.  Erstens aus den Anforderungen des Spiels: Benötigt es geringe Latenzen?  Zweitens aus den Anforderungen des Anwendungsprotokolls: Benötigt es ein zuverlässiges Protokoll?  Wie wir im nächsten Teil sehen werden, können Sie ein Anwendungsprotokoll erstellen, für das ein unzuverlässiges Protokoll gut geeignet ist.  Schließlich müssen Sie noch die Erfahrung des Entwicklers der Netzwerk-Engine berücksichtigen. <br><br>  Ich habe zwei Tipps: <br><br><ul><li>  Maximieren Sie das Transportprotokoll aus dem Rest der Anwendung, damit es problemlos ersetzt werden kann, ohne den gesamten Code neu zu schreiben. </li><li>  Führen Sie keine vorzeitige Optimierung durch.  Wenn Sie kein Netzwerkspezialist sind und nicht sicher sind, ob Sie ein eigenes UDP-basiertes Transportprotokoll benötigen, können Sie mit TCP oder einer Bibliothek beginnen, die Zuverlässigkeit bietet, und dann die Leistung testen und messen.  Wenn Sie Probleme haben und sicher sind, dass der Grund im Transportprotokoll liegt, ist es möglicherweise an der Zeit, Ihr eigenes Transportprotokoll zu erstellen. </li></ul><br>  Am Ende dieses Teils empfehle ich Ihnen, Brian Hooks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190519135537/"><em>Einführung in die Multiplayer</em></a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190519135537/"><em>Spielprogrammierung zu</em></a> lesen, die viele der hier behandelten Themen abdeckt. <br><br><h1>  Anwendungsprotokoll </h1><br>  Jetzt, da wir Daten zwischen Clients und dem Server austauschen können, müssen wir entscheiden, welche Daten in welchem ​​Format übertragen werden sollen. <br><br>  Das klassische Schema besteht darin, dass Clients Eingaben oder Aktionen an den Server senden und der Server den aktuellen Spielstatus an Clients sendet. <br><br>  Der Server sendet keinen vollständigen, sondern gefilterten Status mit Entitäten, die sich neben dem Player befinden.  Er tut dies aus drei Gründen.  Erstens kann der Gesamtzustand für eine Hochfrequenzübertragung zu groß sein.  Zweitens interessieren sich Kunden hauptsächlich für visuelle und akustische Daten, da der größte Teil der Spielelogik auf dem Spieleserver simuliert wird.  Drittens muss der Spieler in einigen Spielen bestimmte Daten nicht kennen, beispielsweise die Position des Gegners am anderen Ende der Karte, da er sonst Pakete schnüffeln und genau wissen kann, wohin er sich bewegen muss, um ihn zu töten. <br><br><h2>  Serialisierung </h2><br>  Der erste Schritt besteht darin, die zu sendenden Daten (Eingabe oder Spielstatus) in ein für die Übertragung geeignetes Format zu konvertieren.  Dieser Vorgang wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Serialisierung bezeichnet</em></a> . <br><br>  Der Gedanke kommt sofort in den Sinn, ein für Menschen lesbares Format wie JSON oder XML zu verwenden.  Aber es wird völlig unwirksam sein und vergebens den größten Teil des Kanals einnehmen. <br><br>  Stattdessen wird empfohlen, ein viel kompakteres Binärformat zu verwenden.  Das heißt, Pakete enthalten nur wenige Bytes.  Hier müssen Sie das Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>der Bytereihenfolge</em></a> berücksichtigen, das auf verschiedenen Computern unterschiedlich sein kann. <br><br>  Sie können eine Bibliothek zum Serialisieren von Daten verwenden, zum Beispiel: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlatBuffers</a> </li><li>  Sandsturm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Müsli von</a> Shane Grant und Randolph Voorhees </li></ul><br>  Stellen Sie einfach sicher, dass die Bibliothek tragbare Archive erstellt und sich um die Bytereihenfolge kümmert. <br><br>  Eine unabhängige Lösung kann eine unabhängige Implementierung sein. Sie ist nicht besonders kompliziert, insbesondere wenn Sie im Code einen datenorientierten Ansatz verwenden.  Darüber hinaus können Sie Optimierungen durchführen, die bei Verwendung der Bibliothek nicht immer möglich sind. <br><br>  Glenn Fiedler hat zwei Artikel zur Serialisierung geschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004533/"><em>Lesen und Schreiben von Paketen</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015044/"><em>Serialisierungsstrategien</em></a> . <br><br><h2>  Komprimierung </h2><br>  Die zwischen Clients und Server übertragene Datenmenge wird durch die Bandbreite des Kanals begrenzt.  Mit der Datenkomprimierung können Sie mehr Daten in jedem Snapshot übertragen, die Aktualisierungsrate erhöhen oder einfach die Kanalanforderungen reduzieren. <br><br><h3>  Bitverpackung </h3><br>  Die erste Technik ist das Bitpacken.  Es besteht darin, genau die Anzahl der Bits zu verwenden, die zur Beschreibung des gewünschten Werts erforderlich sind.  Wenn Sie beispielsweise eine Aufzählung mit 16 verschiedenen Werten haben, können Sie anstelle eines ganzen Bytes (8 Bit) nur 4 Bit verwenden. <br><br>  Glenn Fiedler erklärt im zweiten Teil des Artikels über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004533/"><em>Lesen und Schreiben von Paketen</em></a> , wie dies implementiert wird. <br><br>  Das Packen von Bits eignet sich besonders gut für die Abtastung, die im nächsten Abschnitt behandelt wird. <br><br><h3>  Diskretisierung </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Die Diskretisierung</em></a> ist eine verlustbehaftete Komprimierungstechnik, bei der nur eine Teilmenge der möglichen Werte zum Codieren eines Werts verwendet wird.  Der einfachste Weg, die Diskretisierung zu implementieren, ist das Abrunden von Gleitkommazahlen. <br><br>  Glenn Fiedler (wieder!) Zeigt in seinem Artikel zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/">Snapshot-Komprimierung,</a> wie Sampling in der Praxis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/">angewendet wird</a> . <br><br><h3>  Komprimierungsalgorithmen </h3><br>  Die nächste Technik werden verlustfreie Komprimierungsalgorithmen sein. <br><br>  Hier sind meiner Meinung nach die drei interessantesten Algorithmen, die Sie kennen müssen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Huffman-Codierung</a> mit vorberechnetem Code, der extrem schnell ist und gute Ergebnisse liefern kann.  Es wurde verwendet, um Pakete in der Quake3-Netzwerk-Engine zu komprimieren. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zlib</a> ist ein universeller Komprimierungsalgorithmus, der die Datenmenge niemals erhöht.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu sehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> , wurde es in vielen Anwendungen verwendet.  Das Aktualisieren von Status kann redundant sein.  Dies kann jedoch nützlich sein, wenn Sie Assets, Langtexte oder Erleichterungen vom Server an Clients senden müssen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Kopieren von Serienlängen</a> ist wahrscheinlich der einfachste Komprimierungsalgorithmus, aber für bestimmte Datentypen sehr effektiv und kann als Vorverarbeitungsschritt vor zlib verwendet werden.  Es eignet sich besonders zum Komprimieren von Gelände aus Kacheln oder Voxeln, in denen sich viele benachbarte Elemente wiederholen. </li></ul><br><h3>  Delta-Komprimierung </h3><br>  Die neueste Komprimierungstechnik ist die Delta-Komprimierung.  Es liegt in der Tatsache, dass nur Unterschiede zwischen dem aktuellen Spielstatus und dem letzten vom Client empfangenen Status übertragen werden. <br><br>  Es wurde erstmals in der Quake3-Netzwerk-Engine verwendet.  Hier sind zwei Artikel, die erklären, wie man es benutzt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190628180906/"><em>Das Quake3-Netzwerkmodell von</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Quake 3 Source Code Review: Netzwerkmodell</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung des</a> Artikels über Habré, siehe Abschnitt "Netzwerkmodell"] </li></ul><br>  Glenn Fiedler verwendete es auch im zweiten Teil seines Artikels zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/"><em>Snapshot-Komprimierung</em></a> . <br><br><h2>  Verschlüsselung </h2><br>  Darüber hinaus müssen Sie möglicherweise die Übertragung von Informationen zwischen Clients und dem Server verschlüsseln.  Dafür gibt es mehrere Gründe: <br><br><ul><li>  Datenschutz / Vertraulichkeit: Nachrichten können nur vom Empfänger gelesen werden, und keine andere Person, die am Netzwerk schnüffelt, kann sie lesen. </li><li>  Authentifizierung: Eine Person, die die Rolle eines Spielers spielen möchte, muss ihren Schlüssel kennen. </li><li>  Betrugsprävention: Es wird für böswillige Spieler viel schwieriger sein, ihre eigenen Betrugspakete zu erstellen. Sie müssen das Verschlüsselungsschema reproduzieren und den Schlüssel finden (der sich mit jeder Verbindung ändert). </li></ul><br>  Ich empfehle dringend, die Bibliothek dafür zu verwenden.  Ich schlage vor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libsodium zu verwenden,</a> da es besonders einfach ist und großartige Tutorials enthält.  Von besonderem Interesse ist das Tutorial zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlüsselaustausch</a> , mit dem Sie bei jeder neuen Verbindung neue Schlüssel generieren können. <br><br><h2>  Anwendungsprotokoll: Schlussfolgerung </h2><br>  Wir werden mit dem Anwendungsprotokoll enden.  Ich glaube, dass die Komprimierung völlig optional ist und die Entscheidung, sie zu verwenden, nur vom Spiel und der erforderlichen Bandbreite abhängt.  Die Verschlüsselung ist meiner Meinung nach obligatorisch, aber im ersten Prototyp können Sie darauf verzichten. <br><br><h1>  Anwendungslogik </h1><br>  Jetzt können wir den Status im Client aktualisieren, es können jedoch Probleme mit Verzögerungen auftreten.  Nach der Eingabe muss der Spieler auf die Aktualisierung des Spielstatus vom Server warten, um zu sehen, welche Auswirkungen er auf die Welt hatte. <br><br>  Darüber hinaus ist die Welt zwischen zwei Statusaktualisierungen vollständig statisch.  Wenn die Bildwiederholfrequenz der Zustände niedrig ist, sind die Bewegungen sehr zuckend. <br><br>  Es gibt verschiedene Techniken, um die Auswirkungen dieses Problems zu verringern, und im nächsten Abschnitt werde ich darüber sprechen. <br><br><h2>  Glättungstechniken verzögern </h2><br>  Alle in diesem Abschnitt beschriebenen Techniken werden in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Fast-Paced Multiplayer-</em></a> Reihe von Gabriel Gambetta ausführlich beschrieben.  Ich empfehle dringend, diese großartige Artikelserie zu lesen.  Es gibt auch eine interaktive Demo, mit der Sie sehen können, wie diese Techniken in der Praxis funktionieren. <br><br>  Die erste Technik besteht darin, die Eingabe direkt anzuwenden, ohne auf eine Antwort vom Server zu warten.  Dies wird als <em>clientseitige Vorhersage bezeichnet</em> .  Wenn der Client das Update jedoch vom Server erhält, muss er sicherstellen, dass seine Prognose korrekt war.  Wenn dies nicht der Fall ist, muss er nur seinen Status entsprechend dem vom Server empfangenen ändern, da der Server autoritär ist.  Diese Technik wurde erstmals bei Quake angewendet.  Weitere Informationen finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Quake Engine Code Review von</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré]. <br><br>  Der zweite Satz von Techniken wird verwendet, um die Bewegung anderer Entitäten zwischen zwei Statusaktualisierungen zu glätten.  Es gibt zwei Möglichkeiten, um dieses Problem zu lösen: Interpolation und Extrapolation.  Bei der Interpolation werden die letzten beiden Zustände genommen und der Übergang von einem zum anderen gezeigt.  Der Nachteil ist, dass es einen kleinen Teil der Verzögerung verursacht, da der Client immer sieht, was in der Vergangenheit passiert ist.  Die Extrapolation sagt voraus, wo Entitäten jetzt basierend auf dem letzten vom Client empfangenen Status basieren sollen.  Sein Nachteil ist, dass, wenn die Entität die Bewegungsrichtung vollständig ändert, ein großer Fehler zwischen der Prognose und der realen Position auftritt. <br><br>  Die letzte, fortschrittlichste Technik, die nur bei FPS nützlich ist, ist die <em>Verzögerungskompensation</em> .  Bei Verwendung der Verzögerungskompensation berücksichtigt der Server Clientverzögerungen, wenn er auf ein Ziel schießt.  Wenn ein Spieler beispielsweise einen Kopfschuss auf seinem Bildschirm ausgeführt hat, sein Ziel jedoch in Wirklichkeit auf eine Verzögerung an anderer Stelle zurückzuführen ist, wäre es unehrlich, einem Spieler das Recht zu verweigern, aufgrund einer Verzögerung zu töten.  Daher spult der Server die Zeit zurück zu dem Moment, in dem der Spieler geschossen hat, um zu simulieren, was der Spieler auf seinem Bildschirm gesehen hat, und um die Kollision zwischen seinem Schuss und dem Ziel zu überprüfen. <br><br>  Glenn Fiedler (wie immer!) Schrieb 2004 einen Artikel in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823005028/"><em>Network Physics (2004)</em></a> , der den Grundstein für die Synchronisation von Physiksimulationen zwischen einem Server und einem Client legte.  2014 schrieb er eine neue Reihe von Artikeln zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004853/"><em>Netzwerkphysik</em></a> , in denen andere Techniken zur Synchronisation von Physiksimulationen beschrieben wurden. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch zwei Artikel im Valve-Wiki, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Multiplayer Networking</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latency Compensating Methods im Client / Server In-Game-Protokolldesign und -optimierung</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in denen die Verzögerungskompensation behandelt wird.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrugsprävention </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Haupttechniken, um Betrug zu verhindern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens: Das Versenden von Schadpaketen durch Betrüger wird erschwert. </font><font style="vertical-align: inherit;">Wie oben erwähnt, ist die Verschlüsselung ein guter Weg, um sie zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens: Ein autoritärer Server sollte nur Befehle / Eingaben / Aktionen empfangen. </font><font style="vertical-align: inherit;">Der Client sollte den Status auf dem Server nur durch Senden von Eingaben ändern können. </font><font style="vertical-align: inherit;">Jedes Mal, wenn die Eingabe empfangen wird, muss der Server sie vor dem Anwenden auf Gültigkeit überprüfen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anwendungslogik: Fazit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle Ihnen, eine Methode zur Simulation großer Verzögerungen und niedriger Aktualisierungsraten zu implementieren, um das Verhalten Ihres Spiels unter schlechten Bedingungen testen zu können, selbst wenn Client und Server auf demselben Computer ausgeführt werden. </font><font style="vertical-align: inherit;">Dies wird die Implementierung von Verzögerungsglättungstechniken erheblich vereinfachen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere nützliche Ressourcen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie andere Ressourcen in Netzwerkmodellen untersuchen möchten, finden Sie diese hier: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190328001900/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glenn Fiedlers Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - es lohnt sich, seinen gesamten Blog zu lesen, er enthält viele großartige Artikel. </font><font style="vertical-align: inherit;">Alle Artikel zu Netzwerktechnologien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesammelt.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awesome Game Networking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von M. Fatih MAR ist eine detaillierte Liste von Artikeln und Videos zu Videospiel-Netzwerk-Engines.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / gamedev subreddit Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat auch viele nützliche Links.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467025/">https://habr.com/ru/post/de467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467015/index.html">JWT: Digital Signature Attack VS MAC Attack</a></li>
<li><a href="../de467017/index.html">Was ist HED / MRSD und wofür ist es?</a></li>
<li><a href="../de467019/index.html">Entwerfen von Dashboards für die E-Commerce-Website für Webanalysen. Teil 3: SEO Channel</a></li>
<li><a href="../de467021/index.html">Wie der Gewissensroboter mit Kunden kommuniziert</a></li>
<li><a href="../de467023/index.html">Wir haben in Grafana ein Plugin zur Überwachung von k8s erstellt: bereits im offiziellen Grafana-Store</a></li>
<li><a href="../de467029/index.html">Grigory Petrov: Arbeiten mit einem Netzwerk in Ruby</a></li>
<li><a href="../de467033/index.html">Eine Auswahl cooler technischer Dokumente aus dem Chaos Communication Camp 2019</a></li>
<li><a href="../de467035/index.html">Entwerfen von Dashboards für die E-Commerce-Website für Webanalysen. Teil 4: Youtube Channel</a></li>
<li><a href="../de467037/index.html">Factoring: Wie man Geld für Stühle bekommt</a></li>
<li><a href="../de467039/index.html">So führen Sie eine Codeüberprüfung durch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>