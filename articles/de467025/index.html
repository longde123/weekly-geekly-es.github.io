<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üíà üî≥ √úber das Netzwerkmodell in Spielen f√ºr Anf√§nger üî± üö£ ‚ú¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zwei Wochen habe ich an einer Netzwerk-Engine f√ºr mein Spiel gearbeitet. Vorher wusste ich nichts √ºber Netzwerktechnologien in Spielen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber das Netzwerkmodell in Spielen f√ºr Anf√§nger</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="Bild"></div><br>  In den letzten zwei Wochen habe ich an einer Netzwerk-Engine f√ºr mein Spiel gearbeitet.  Vorher wusste ich nichts √ºber Netzwerktechnologien in Spielen, deshalb las ich viele Artikel und f√ºhrte viele Experimente durch, um alle Konzepte zu verstehen und meine eigene Netzwerk-Engine schreiben zu k√∂nnen. <br><br>  In diesem Handbuch m√∂chte ich Ihnen verschiedene Konzepte vorstellen, die Sie lernen m√ºssen, bevor Sie Ihre eigene Spiel-Engine schreiben, sowie die besten Ressourcen und Artikel, um sie zu lernen. <br><br>  Im Allgemeinen gibt es zwei Haupttypen von Netzwerkarchitekturen: Peer-to-Peer und Client-Server.  In der Peer-to-Peer-Architektur (p2p) werden Daten zwischen einem beliebigen Paar verbundener Player √ºbertragen, und in der Client-Server-Architektur werden Daten nur zwischen den Playern und dem Server √ºbertragen. <br><br>  Obwohl die Peer-to-Peer-Architektur in einigen Spielen immer noch verwendet wird, ist der Standard Client-Server: Sie ist einfacher zu implementieren, erfordert eine geringere Kanalbreite und erleichtert den Schutz vor Betrug.  Daher konzentrieren wir uns in diesem Handbuch auf die Client-Server-Architektur. <br><a name="habracut"></a><br>  Insbesondere sind wir am meisten an autorit√§ren Servern interessiert: In solchen Systemen hat der Server immer Recht.  Wenn ein Spieler beispielsweise denkt, dass er sich in Koordinaten befindet (10, 5) und der Server ihm mitteilt, dass er sich in Koordinaten befindet (5, 3), sollte der Client seine Position durch die vom Server √ºbertragene Position ersetzen und nicht umgekehrt.  Die Verwendung autorit√§rer Server erleichtert die Erkennung von Betr√ºgern. <br><br>  Gaming-Netzwerksysteme bestehen aus drei Hauptkomponenten: <br><br><ul><li>  Transportprotokoll: Wie Daten zwischen Clients und Server √ºbertragen werden. </li><li>  Anwendungsprotokoll: Was wird von Clients zum Server und vom Server zu Clients √ºbertragen und in welchem ‚Äã‚ÄãFormat. </li><li>  Anwendungslogik: Wie √ºbertragene Daten verwendet werden, um den Status von Clients und Servern zu aktualisieren. </li></ul><br>  Es ist sehr wichtig, die Rolle jedes Teils und die damit verbundenen Schwierigkeiten zu verstehen. <br><br><h1>  Transportprotokoll </h1><br>  Der erste Schritt besteht darin, ein Protokoll f√ºr den Datentransport zwischen Server und Clients auszuw√§hlen.  Hierf√ºr gibt es zwei Internetprotokolle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCP</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP</a> .  Sie k√∂nnen jedoch Ihr eigenes Transportprotokoll basierend auf einem von ihnen erstellen oder die Bibliothek verwenden, in der sie verwendet werden. <br><br><h2>  Vergleich von TCP und UDP </h2><br>  Sowohl TCP als auch UDP sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IP-</a> basiert.  IP erm√∂glicht es Ihnen, ein Paket von der Quelle zum Empf√§nger zu √ºbertragen, garantiert jedoch nicht, dass das gesendete Paket fr√ºher oder sp√§ter den Empf√§nger erreicht, dass es mindestens einmal erreicht wird und dass die Reihenfolge der Pakete in der richtigen Reihenfolge ankommt.  Dar√ºber hinaus kann ein Paket nur eine begrenzte Datengr√∂√üe enthalten, die durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MTU-</a> Wert angegeben wird. <br><br>  UDP ist nur eine d√ºnne Schicht √ºber IP.  Daher hat es die gleichen Einschr√§nkungen.  Im Gegensatz dazu verf√ºgt TCP √ºber viele Funktionen.  Es bietet eine zuverl√§ssige, geordnete Verbindung zwischen zwei Knoten mit Fehlerpr√ºfung.  Daher ist TCP sehr praktisch und wird in vielen anderen Protokollen verwendet, beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTP</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMTP</a> .  Aber all diese Funktionen haben ihren Preis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Verz√∂gerung</em></a> . <br><br>  Um zu verstehen, warum diese Funktionen zu Verz√∂gerungen f√ºhren k√∂nnen, m√ºssen Sie wissen, wie TCP funktioniert.  Wenn der sendende Knoten das Paket an den empfangenden Knoten weiterleitet, erwartet er eine Best√§tigung (ACK).  Wenn er es nach einer bestimmten Zeit nicht erh√§lt (weil das Paket oder die Best√§tigung verloren gegangen ist oder aus anderen Gr√ºnden), sendet er das Paket erneut.  Dar√ºber hinaus stellt TCP sicher, dass Pakete in der richtigen Reihenfolge empfangen werden. Daher k√∂nnen bis zum Empfang eines verlorenen Pakets alle anderen Pakete nicht verarbeitet werden, selbst wenn sie bereits vom empfangenden Knoten empfangen wurden. <br><br>  Aber wie Sie wahrscheinlich verstehen, ist die Verz√∂gerung bei Multiplayer-Spielen sehr wichtig, insbesondere bei aktiven Genres wie FPS.  Aus diesem Grund verwenden viele Spiele UDP mit einem eigenen Protokoll. <br><br>  Ein natives UDP-basiertes Protokoll kann aus verschiedenen Gr√ºnden effizienter sein als TCP.  Beispielsweise k√∂nnen einige Pakete als vertrauensw√ºrdig und andere als nicht vertrauensw√ºrdig markiert werden.  Daher ist es ihm egal, ob das nicht vertrauensw√ºrdige Paket den Empf√§nger erreicht hat.  Oder es k√∂nnen mehrere Datenstr√∂me verarbeitet werden, sodass ein in einem Stream verlorenes Paket die verbleibenden Streams nicht verlangsamt.  Beispielsweise kann es einen Stream f√ºr Spielereingaben und einen anderen Stream f√ºr Chat-Nachrichten geben.  Wenn eine Chat-Nachricht verloren geht, bei der es sich nicht um dringende Daten handelt, wird die dringende Eingabe nicht verlangsamt.  Oder ein propriet√§res Protokoll kann die Zuverl√§ssigkeit anders als in TCP implementieren, um in Videospielen effizienter zu sein. <br><br>  Also, wenn TCP so beschissen ist, werden wir unser eigenes Transportprotokoll basierend auf UDP erstellen? <br><br>  Alles ist etwas komplizierter.  Obwohl TCP f√ºr Gaming-Netzwerksysteme fast nicht optimal ist, kann es in Ihrem Spiel einwandfrei funktionieren und wertvolle Zeit sparen.  Beispielsweise ist Verz√∂gerung m√∂glicherweise kein Problem f√ºr ein rundenbasiertes Spiel oder ein Spiel, das nur in LANs gespielt werden kann, in denen es viel weniger Verz√∂gerungen und Paketverluste gibt als im Internet. <br><br>  Viele erfolgreiche Spiele, darunter World of Warcraft, Minecraft und Terraria, verwenden TCP.  Die meisten FPS verwenden jedoch propriet√§re UDP-basierte Protokolle, daher werden wir im Folgenden n√§her darauf eingehen. <br><br>  Wenn Sie sich f√ºr die Verwendung von TCP entscheiden, stellen Sie sicher, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Nagle-Algorithmus</a> deaktiviert ist, da er Pakete vor dem Senden puffert, was bedeutet, dass die Verz√∂gerung erh√∂ht wird. <br><br>  Um mehr √ºber die Unterschiede zwischen UDP und TCP im Zusammenhang mit Multiplayer-Spielen zu erfahren, lesen Sie den Artikel von Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Eigenes Protokoll </h2><br>  Sie m√∂chten also Ihr eigenes Transportprotokoll erstellen, wissen aber nicht, wo Sie anfangen sollen?  Sie haben Gl√ºck, denn Glenn Fiedler hat zwei erstaunliche Artikel dar√ºber geschrieben.  Sie werden viele kluge Gedanken in ihnen finden. <br><br>  Der erste Artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmers</em></a> 2008, ist einfacher als der zweite, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Ich empfehle Ihnen, mit einem √§lteren zu beginnen. <br><br>  Denken Sie daran, dass Glenn Fiedler ein gro√üer Bef√ºrworter der Verwendung seines eigenen UDP-Protokolls ist.  Und nachdem Sie seine Artikel gelesen haben, werden Sie sicherlich √ºber seine Meinung hinwegkommen, dass TCP schwerwiegende M√§ngel bei Videospielen aufweist und Sie Ihr eigenes Protokoll implementieren m√∂chten. <br><br>  Wenn Sie neu im Networking sind, tun Sie sich selbst einen Gefallen und verwenden Sie TCP oder eine Bibliothek.  Um Ihr eigenes Transportprotokoll erfolgreich zu implementieren, m√ºssen Sie zun√§chst viel lernen. <br><br><h2>  Netzwerkbibliotheken </h2><br>  Wenn Sie etwas Effizienteres als TCP ben√∂tigen, sich aber nicht mit der Implementierung Ihres eigenen Protokolls befassen und auf viele Details eingehen m√∂chten, k√∂nnen Sie die Netzwerkbibliothek verwenden.  Es gibt viele von ihnen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RakNet</a> , das nicht mehr unterst√ºtzt wird, dessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SLikeNet-</a> Gabel jedoch noch aktiv zu sein scheint. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ENet</a> ist eine Bibliothek, die f√ºr den Mehrbenutzer-FPS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cube erstellt wurde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GameNetworkingSockets von Valve</a> </li></ul><br>  Ich habe nicht alle ausprobiert, aber ich bevorzuge ENet, weil es einfach zu bedienen und zuverl√§ssig ist.  Dar√ºber hinaus verf√ºgt sie √ºber eine klare Dokumentation und ein Tutorial f√ºr Anf√§nger. <br><br><h2>  Transportprotokoll: Schlussfolgerung </h2><br>  Zusammenfassend: Es gibt zwei Haupttransportprotokolle: TCP und UDP.  TCP bietet viele n√ºtzliche Funktionen: Zuverl√§ssigkeit, Paketreihenfolge, Fehlererkennung.  UDP hat nicht all dies, aber TCP hat naturgem√§√ü vermehrt Verz√∂gerungen, die f√ºr einige Spiele nicht akzeptabel sind.  Um niedrige Latenzen zu gew√§hrleisten, k√∂nnen Sie Ihr eigenes UDP-basiertes Protokoll erstellen oder eine Bibliothek verwenden, die das UDP-Transportprotokoll implementiert und f√ºr Videospiele f√ºr mehrere Spieler geeignet ist. <br><br>  Die Wahl zwischen TCP, UDP und der Bibliothek h√§ngt von mehreren Faktoren ab.  Erstens aus den Anforderungen des Spiels: Ben√∂tigt es geringe Latenzen?  Zweitens aus den Anforderungen des Anwendungsprotokolls: Ben√∂tigt es ein zuverl√§ssiges Protokoll?  Wie wir im n√§chsten Teil sehen werden, k√∂nnen Sie ein Anwendungsprotokoll erstellen, f√ºr das ein unzuverl√§ssiges Protokoll gut geeignet ist.  Schlie√ülich m√ºssen Sie noch die Erfahrung des Entwicklers der Netzwerk-Engine ber√ºcksichtigen. <br><br>  Ich habe zwei Tipps: <br><br><ul><li>  Maximieren Sie das Transportprotokoll aus dem Rest der Anwendung, damit es problemlos ersetzt werden kann, ohne den gesamten Code neu zu schreiben. </li><li>  F√ºhren Sie keine vorzeitige Optimierung durch.  Wenn Sie kein Netzwerkspezialist sind und nicht sicher sind, ob Sie ein eigenes UDP-basiertes Transportprotokoll ben√∂tigen, k√∂nnen Sie mit TCP oder einer Bibliothek beginnen, die Zuverl√§ssigkeit bietet, und dann die Leistung testen und messen.  Wenn Sie Probleme haben und sicher sind, dass der Grund im Transportprotokoll liegt, ist es m√∂glicherweise an der Zeit, Ihr eigenes Transportprotokoll zu erstellen. </li></ul><br>  Am Ende dieses Teils empfehle ich Ihnen, Brian Hooks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190519135537/"><em>Einf√ºhrung in die Multiplayer</em></a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190519135537/"><em>Spielprogrammierung zu</em></a> lesen, die viele der hier behandelten Themen abdeckt. <br><br><h1>  Anwendungsprotokoll </h1><br>  Jetzt, da wir Daten zwischen Clients und dem Server austauschen k√∂nnen, m√ºssen wir entscheiden, welche Daten in welchem ‚Äã‚ÄãFormat √ºbertragen werden sollen. <br><br>  Das klassische Schema besteht darin, dass Clients Eingaben oder Aktionen an den Server senden und der Server den aktuellen Spielstatus an Clients sendet. <br><br>  Der Server sendet keinen vollst√§ndigen, sondern gefilterten Status mit Entit√§ten, die sich neben dem Player befinden.  Er tut dies aus drei Gr√ºnden.  Erstens kann der Gesamtzustand f√ºr eine Hochfrequenz√ºbertragung zu gro√ü sein.  Zweitens interessieren sich Kunden haupts√§chlich f√ºr visuelle und akustische Daten, da der gr√∂√üte Teil der Spielelogik auf dem Spieleserver simuliert wird.  Drittens muss der Spieler in einigen Spielen bestimmte Daten nicht kennen, beispielsweise die Position des Gegners am anderen Ende der Karte, da er sonst Pakete schn√ºffeln und genau wissen kann, wohin er sich bewegen muss, um ihn zu t√∂ten. <br><br><h2>  Serialisierung </h2><br>  Der erste Schritt besteht darin, die zu sendenden Daten (Eingabe oder Spielstatus) in ein f√ºr die √úbertragung geeignetes Format zu konvertieren.  Dieser Vorgang wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Serialisierung bezeichnet</em></a> . <br><br>  Der Gedanke kommt sofort in den Sinn, ein f√ºr Menschen lesbares Format wie JSON oder XML zu verwenden.  Aber es wird v√∂llig unwirksam sein und vergebens den gr√∂√üten Teil des Kanals einnehmen. <br><br>  Stattdessen wird empfohlen, ein viel kompakteres Bin√§rformat zu verwenden.  Das hei√üt, Pakete enthalten nur wenige Bytes.  Hier m√ºssen Sie das Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>der Bytereihenfolge</em></a> ber√ºcksichtigen, das auf verschiedenen Computern unterschiedlich sein kann. <br><br>  Sie k√∂nnen eine Bibliothek zum Serialisieren von Daten verwenden, zum Beispiel: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlatBuffers</a> </li><li>  Sandsturm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√ºsli von</a> Shane Grant und Randolph Voorhees </li></ul><br>  Stellen Sie einfach sicher, dass die Bibliothek tragbare Archive erstellt und sich um die Bytereihenfolge k√ºmmert. <br><br>  Eine unabh√§ngige L√∂sung kann eine unabh√§ngige Implementierung sein. Sie ist nicht besonders kompliziert, insbesondere wenn Sie im Code einen datenorientierten Ansatz verwenden.  Dar√ºber hinaus k√∂nnen Sie Optimierungen durchf√ºhren, die bei Verwendung der Bibliothek nicht immer m√∂glich sind. <br><br>  Glenn Fiedler hat zwei Artikel zur Serialisierung geschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004533/"><em>Lesen und Schreiben von Paketen</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823015044/"><em>Serialisierungsstrategien</em></a> . <br><br><h2>  Komprimierung </h2><br>  Die zwischen Clients und Server √ºbertragene Datenmenge wird durch die Bandbreite des Kanals begrenzt.  Mit der Datenkomprimierung k√∂nnen Sie mehr Daten in jedem Snapshot √ºbertragen, die Aktualisierungsrate erh√∂hen oder einfach die Kanalanforderungen reduzieren. <br><br><h3>  Bitverpackung </h3><br>  Die erste Technik ist das Bitpacken.  Es besteht darin, genau die Anzahl der Bits zu verwenden, die zur Beschreibung des gew√ºnschten Werts erforderlich sind.  Wenn Sie beispielsweise eine Aufz√§hlung mit 16 verschiedenen Werten haben, k√∂nnen Sie anstelle eines ganzen Bytes (8 Bit) nur 4 Bit verwenden. <br><br>  Glenn Fiedler erkl√§rt im zweiten Teil des Artikels √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004533/"><em>Lesen und Schreiben von Paketen</em></a> , wie dies implementiert wird. <br><br>  Das Packen von Bits eignet sich besonders gut f√ºr die Abtastung, die im n√§chsten Abschnitt behandelt wird. <br><br><h3>  Diskretisierung </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Die Diskretisierung</em></a> ist eine verlustbehaftete Komprimierungstechnik, bei der nur eine Teilmenge der m√∂glichen Werte zum Codieren eines Werts verwendet wird.  Der einfachste Weg, die Diskretisierung zu implementieren, ist das Abrunden von Gleitkommazahlen. <br><br>  Glenn Fiedler (wieder!) Zeigt in seinem Artikel zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/">Snapshot-Komprimierung,</a> wie Sampling in der Praxis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/">angewendet wird</a> . <br><br><h3>  Komprimierungsalgorithmen </h3><br>  Die n√§chste Technik werden verlustfreie Komprimierungsalgorithmen sein. <br><br>  Hier sind meiner Meinung nach die drei interessantesten Algorithmen, die Sie kennen m√ºssen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Huffman-Codierung</a> mit vorberechnetem Code, der extrem schnell ist und gute Ergebnisse liefern kann.  Es wurde verwendet, um Pakete in der Quake3-Netzwerk-Engine zu komprimieren. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zlib</a> ist ein universeller Komprimierungsalgorithmus, der die Datenmenge niemals erh√∂ht.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu sehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> , wurde es in vielen Anwendungen verwendet.  Das Aktualisieren von Status kann redundant sein.  Dies kann jedoch n√ºtzlich sein, wenn Sie Assets, Langtexte oder Erleichterungen vom Server an Clients senden m√ºssen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Kopieren von Serienl√§ngen</a> ist wahrscheinlich der einfachste Komprimierungsalgorithmus, aber f√ºr bestimmte Datentypen sehr effektiv und kann als Vorverarbeitungsschritt vor zlib verwendet werden.  Es eignet sich besonders zum Komprimieren von Gel√§nde aus Kacheln oder Voxeln, in denen sich viele benachbarte Elemente wiederholen. </li></ul><br><h3>  Delta-Komprimierung </h3><br>  Die neueste Komprimierungstechnik ist die Delta-Komprimierung.  Es liegt in der Tatsache, dass nur Unterschiede zwischen dem aktuellen Spielstatus und dem letzten vom Client empfangenen Status √ºbertragen werden. <br><br>  Es wurde erstmals in der Quake3-Netzwerk-Engine verwendet.  Hier sind zwei Artikel, die erkl√§ren, wie man es benutzt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190628180906/"><em>Das Quake3-Netzwerkmodell von</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Quake 3 Source Code Review: Netzwerkmodell</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung des</a> Artikels √ºber Habr√©, siehe Abschnitt "Netzwerkmodell"] </li></ul><br>  Glenn Fiedler verwendete es auch im zweiten Teil seines Artikels zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823021121/"><em>Snapshot-Komprimierung</em></a> . <br><br><h2>  Verschl√ºsselung </h2><br>  Dar√ºber hinaus m√ºssen Sie m√∂glicherweise die √úbertragung von Informationen zwischen Clients und dem Server verschl√ºsseln.  Daf√ºr gibt es mehrere Gr√ºnde: <br><br><ul><li>  Datenschutz / Vertraulichkeit: Nachrichten k√∂nnen nur vom Empf√§nger gelesen werden, und keine andere Person, die am Netzwerk schn√ºffelt, kann sie lesen. </li><li>  Authentifizierung: Eine Person, die die Rolle eines Spielers spielen m√∂chte, muss ihren Schl√ºssel kennen. </li><li>  Betrugspr√§vention: Es wird f√ºr b√∂swillige Spieler viel schwieriger sein, ihre eigenen Betrugspakete zu erstellen. Sie m√ºssen das Verschl√ºsselungsschema reproduzieren und den Schl√ºssel finden (der sich mit jeder Verbindung √§ndert). </li></ul><br>  Ich empfehle dringend, die Bibliothek daf√ºr zu verwenden.  Ich schlage vor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libsodium zu verwenden,</a> da es besonders einfach ist und gro√üartige Tutorials enth√§lt.  Von besonderem Interesse ist das Tutorial zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schl√ºsselaustausch</a> , mit dem Sie bei jeder neuen Verbindung neue Schl√ºssel generieren k√∂nnen. <br><br><h2>  Anwendungsprotokoll: Schlussfolgerung </h2><br>  Wir werden mit dem Anwendungsprotokoll enden.  Ich glaube, dass die Komprimierung v√∂llig optional ist und die Entscheidung, sie zu verwenden, nur vom Spiel und der erforderlichen Bandbreite abh√§ngt.  Die Verschl√ºsselung ist meiner Meinung nach obligatorisch, aber im ersten Prototyp k√∂nnen Sie darauf verzichten. <br><br><h1>  Anwendungslogik </h1><br>  Jetzt k√∂nnen wir den Status im Client aktualisieren, es k√∂nnen jedoch Probleme mit Verz√∂gerungen auftreten.  Nach der Eingabe muss der Spieler auf die Aktualisierung des Spielstatus vom Server warten, um zu sehen, welche Auswirkungen er auf die Welt hatte. <br><br>  Dar√ºber hinaus ist die Welt zwischen zwei Statusaktualisierungen vollst√§ndig statisch.  Wenn die Bildwiederholfrequenz der Zust√§nde niedrig ist, sind die Bewegungen sehr zuckend. <br><br>  Es gibt verschiedene Techniken, um die Auswirkungen dieses Problems zu verringern, und im n√§chsten Abschnitt werde ich dar√ºber sprechen. <br><br><h2>  Gl√§ttungstechniken verz√∂gern </h2><br>  Alle in diesem Abschnitt beschriebenen Techniken werden in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Fast-Paced Multiplayer-</em></a> Reihe von Gabriel Gambetta ausf√ºhrlich beschrieben.  Ich empfehle dringend, diese gro√üartige Artikelserie zu lesen.  Es gibt auch eine interaktive Demo, mit der Sie sehen k√∂nnen, wie diese Techniken in der Praxis funktionieren. <br><br>  Die erste Technik besteht darin, die Eingabe direkt anzuwenden, ohne auf eine Antwort vom Server zu warten.  Dies wird als <em>clientseitige Vorhersage bezeichnet</em> .  Wenn der Client das Update jedoch vom Server erh√§lt, muss er sicherstellen, dass seine Prognose korrekt war.  Wenn dies nicht der Fall ist, muss er nur seinen Status entsprechend dem vom Server empfangenen √§ndern, da der Server autorit√§r ist.  Diese Technik wurde erstmals bei Quake angewendet.  Weitere Informationen finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Quake Engine Code Review von</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©]. <br><br>  Der zweite Satz von Techniken wird verwendet, um die Bewegung anderer Entit√§ten zwischen zwei Statusaktualisierungen zu gl√§tten.  Es gibt zwei M√∂glichkeiten, um dieses Problem zu l√∂sen: Interpolation und Extrapolation.  Bei der Interpolation werden die letzten beiden Zust√§nde genommen und der √úbergang von einem zum anderen gezeigt.  Der Nachteil ist, dass es einen kleinen Teil der Verz√∂gerung verursacht, da der Client immer sieht, was in der Vergangenheit passiert ist.  Die Extrapolation sagt voraus, wo Entit√§ten jetzt basierend auf dem letzten vom Client empfangenen Status basieren sollen.  Sein Nachteil ist, dass, wenn die Entit√§t die Bewegungsrichtung vollst√§ndig √§ndert, ein gro√üer Fehler zwischen der Prognose und der realen Position auftritt. <br><br>  Die letzte, fortschrittlichste Technik, die nur bei FPS n√ºtzlich ist, ist die <em>Verz√∂gerungskompensation</em> .  Bei Verwendung der Verz√∂gerungskompensation ber√ºcksichtigt der Server Clientverz√∂gerungen, wenn er auf ein Ziel schie√üt.  Wenn ein Spieler beispielsweise einen Kopfschuss auf seinem Bildschirm ausgef√ºhrt hat, sein Ziel jedoch in Wirklichkeit auf eine Verz√∂gerung an anderer Stelle zur√ºckzuf√ºhren ist, w√§re es unehrlich, einem Spieler das Recht zu verweigern, aufgrund einer Verz√∂gerung zu t√∂ten.  Daher spult der Server die Zeit zur√ºck zu dem Moment, in dem der Spieler geschossen hat, um zu simulieren, was der Spieler auf seinem Bildschirm gesehen hat, und um die Kollision zwischen seinem Schuss und dem Ziel zu √ºberpr√ºfen. <br><br>  Glenn Fiedler (wie immer!) Schrieb 2004 einen Artikel in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823005028/"><em>Network Physics (2004)</em></a> , der den Grundstein f√ºr die Synchronisation von Physiksimulationen zwischen einem Server und einem Client legte.  2014 schrieb er eine neue Reihe von Artikeln zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823004853/"><em>Netzwerkphysik</em></a> , in denen andere Techniken zur Synchronisation von Physiksimulationen beschrieben wurden. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch zwei Artikel im Valve-Wiki, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Multiplayer Networking</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latency Compensating Methods im Client / Server In-Game-Protokolldesign und -optimierung</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in denen die Verz√∂gerungskompensation behandelt wird.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrugspr√§vention </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Haupttechniken, um Betrug zu verhindern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens: Das Versenden von Schadpaketen durch Betr√ºger wird erschwert. </font><font style="vertical-align: inherit;">Wie oben erw√§hnt, ist die Verschl√ºsselung ein guter Weg, um sie zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens: Ein autorit√§rer Server sollte nur Befehle / Eingaben / Aktionen empfangen. </font><font style="vertical-align: inherit;">Der Client sollte den Status auf dem Server nur durch Senden von Eingaben √§ndern k√∂nnen. </font><font style="vertical-align: inherit;">Jedes Mal, wenn die Eingabe empfangen wird, muss der Server sie vor dem Anwenden auf G√ºltigkeit √ºberpr√ºfen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anwendungslogik: Fazit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle Ihnen, eine Methode zur Simulation gro√üer Verz√∂gerungen und niedriger Aktualisierungsraten zu implementieren, um das Verhalten Ihres Spiels unter schlechten Bedingungen testen zu k√∂nnen, selbst wenn Client und Server auf demselben Computer ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Dies wird die Implementierung von Verz√∂gerungsgl√§ttungstechniken erheblich vereinfachen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere n√ºtzliche Ressourcen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie andere Ressourcen in Netzwerkmodellen untersuchen m√∂chten, finden Sie diese hier: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20190328001900/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glenn Fiedlers Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - es lohnt sich, seinen gesamten Blog zu lesen, er enth√§lt viele gro√üartige Artikel. </font><font style="vertical-align: inherit;">Alle Artikel zu Netzwerktechnologien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20180823014743/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesammelt.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awesome Game Networking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von M. Fatih MAR ist eine detaillierte Liste von Artikeln und Videos zu Videospiel-Netzwerk-Engines.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / gamedev subreddit Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat auch viele n√ºtzliche Links.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467025/">https://habr.com/ru/post/de467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467015/index.html">JWT: Digital Signature Attack VS MAC Attack</a></li>
<li><a href="../de467017/index.html">Was ist HED / MRSD und wof√ºr ist es?</a></li>
<li><a href="../de467019/index.html">Entwerfen von Dashboards f√ºr die E-Commerce-Website f√ºr Webanalysen. Teil 3: SEO Channel</a></li>
<li><a href="../de467021/index.html">Wie der Gewissensroboter mit Kunden kommuniziert</a></li>
<li><a href="../de467023/index.html">Wir haben in Grafana ein Plugin zur √úberwachung von k8s erstellt: bereits im offiziellen Grafana-Store</a></li>
<li><a href="../de467029/index.html">Grigory Petrov: Arbeiten mit einem Netzwerk in Ruby</a></li>
<li><a href="../de467033/index.html">Eine Auswahl cooler technischer Dokumente aus dem Chaos Communication Camp 2019</a></li>
<li><a href="../de467035/index.html">Entwerfen von Dashboards f√ºr die E-Commerce-Website f√ºr Webanalysen. Teil 4: Youtube Channel</a></li>
<li><a href="../de467037/index.html">Factoring: Wie man Geld f√ºr St√ºhle bekommt</a></li>
<li><a href="../de467039/index.html">So f√ºhren Sie eine Code√ºberpr√ºfung durch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>