<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💠 👨‍👩‍👦‍👦 🧑🏿‍🤝‍🧑🏽 WASI标准：在Web之外启动WebAssembly 🎮 ♍️ 🦖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="3月27日，我们在Mozilla宣布了WASI（WebAssembly系统接口，WebAssembly系统接口）的标准化。 

 原因：开发人员开始在浏览器之外使用WebAssembly，因为WASM提供了一种快速，可扩展，安全的方式来在所有计算机上运行相同的代码。 但是，我们尚未为这种发展奠定坚实...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WASI标准：在Web之外启动WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446764/">  3月27日，我们在Mozilla宣布了WASI（WebAssembly系统接口，WebAssembly系统接口）的标准化。 <br><br>  <b>原因：</b>开发人员开始在浏览器之外使用WebAssembly，因为WASM提供了一种快速，可扩展，安全的方式来在所有计算机上运行相同的代码。 但是，我们尚未为这种发展奠定坚实的基础。 在浏览器之外，您需要某种方式与系统进行通信，即系统界面。 但是WebAssembly平台还没有它。 <br><br>  <b>内容：</b> WebAssembly是概念计算机而非物理计算机的汇编程序。 它可以在各种体系结构上工作，因此，概念性OS在不同的操作系统上工作需要系统接口。 <br><br> 这就是WASI：这是WebAssembly平台的系统接口。 <br><a name="habracut"></a><br> 我们努力创建一个系统界面，该界面将成为WebAssembly的真正伴侣，并具有最大的可移植性和安全性。 <br><br>  <b>谁：</b>作为WebAssembly开发团队的一部分，我们组织了一个分组，将标准化<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WASI</a> 。 我们已经收集了感兴趣的合作伙伴，并正在寻找新的合作伙伴。 <br><br> 我们，合作伙伴和支持者认为这很重要的原因如下： <br><br>  <b>Mozilla研发总监Sean White：</b> <br><blockquote>  “ WebAssembly已经在改变人们交付新型引人入胜的内容的方式。它可以帮助内容开发人员和创作者。 到目前为止，所有内容都可以通过浏览器工作，但是有了WASI，WebAssembly将使更多用户和不同地方的更多设备受益。” </blockquote><br>  <b>首席技术官Tyler McMullen迅速：</b> <br><blockquote>  “我们将WebAssembly视为在边缘云上快速安全地执行代码的平台。 尽管有不同的环境（边缘和浏览器），但由于有了WASI，您不必将代码移植到每个平台上。” </blockquote><br>  <b>Node指导委员会CTO Miles Borins：</b> <br><blockquote>  “ WebAssembly可以解决Node的最大问题之一：如何在保持可移植性和安全性的同时，达到接近本机的速度并重用用其他语言（例如C和C ++）编写的代码。  WASI标准化是朝着这一目标迈出的第一步。” </blockquote><br>  <b>npm的联合创始人Lori Voss：</b> <br><blockquote>  “ Npm对npm生态系统的潜在WebAssembly功能感到非常兴奋，因为它使获取本机代码在服务器端JavaScript应用程序中运行变得更加容易。 我们期待这一过程的结果。” </blockquote><br> 所以这是一个大事件！ <br><br> 当前有三种WASI实现： <br><br><ul><li>  Mozilla WebAssembly运行时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wasmtime</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lucet</a> ，快速WebAssembly运行时 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">polyfill浏览器</a> </li></ul><br>  WASI示范行动： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ggtEJC0Jv8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 接下来，我们将讨论Mozilla关于该系统界面应如何工作的建议。 <br><br><h1> 什么是系统接口？ </h1><br> 许多人说像C这样的语言可以直接访问系统资源。 但这并非完全正确。 在大多数系统上，这些语言无法直接访问诸如打开或创建文件之类的内容。 为什么不呢 <br><br> 因为这些系统资源（文件，内存和网络连接）对于稳定性和安全性来说非常重要。 <br><br> 如果一个程序意外破坏了另一个程序的资源，则可能导致崩溃。 更糟糕的是，如果程序（或用户）专门入侵他人的资源，则它可能窃取敏感数据。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/18d/7df/5a518d7df32af2b475047a1fc7c73958.png"><br><br> 因此，您需要一种方法来控制哪些程序和用户可以访问资源。 长期以来，系统开发人员想出了一种提供这种控制的方法：保护环。 <br><br> 通过保护环，OS实质上在系统资源周围设置了保护屏障。 这是核心。 只有它才能执行诸如创建文件，打开文件或打开网络连接之类的操作。 <br><br> 用户程序在称为用户空间的内核外部运行。 如果程序要打开文件，则应请求内核。 <br><br> <a href=""><img src="https://habrastorage.org/webt/1x/6e/vi/1x6evigsjy_wlsk1dk5gei1r5ky.png"></a> <br><br> 这就是系统调用概念出现的地方。 当程序需要向内核请求某些操作时，它将发送系统调用。 内核检查联系用户，并查看他是否有权访问该文件。 <br><br> 在大多数设备上，访问系统资源的唯一方法是通过系统调用。 <br><br> <a href=""><img src="https://habrastorage.org/webt/td/1s/e7/td1se7jsbqiagsgy6nid_csyick.png"></a> <br><br> 操作系统提供对系统调用的访问。 但是，如果每个操作系统都有自己的系统调用，那么它们是否不需要编写不同版本的代码？ 幸运的不是。 该问题使用抽象解决。 <br><br> 大多数语言都有一个标准库。 进行编码时，程序员无需知道他为哪个系统编写。 它只是使用接口。 然后，在编译时，您的工具链会选择要用于哪个系统的接口实现。 此实现使用来自操作系统API的功能，因此它是特定于它的。 <br><br> 这是出现系统接口概念的地方。 例如，如果您为Windows机器编译<code>printf</code> ，它将使用Windows API。 如果是为Mac或Linux编译的，则使用POSIX。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cdc/5c0/587cdc5c03ff566a88a9794dc314fa72.png"><br><br> 但是，这给WebAssembly带来了问题。 即使在编译过程中，我们也不知道要针对哪个OS优化程序。 因此，您不能在WebAssembly上的标准库的实现内使用任何一个OS的系统接口。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/443/c36/730/443c3673072b36942ff28f1992ad2095.png"></a> <br><br> 我已经说过WebAssembly是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">概念计算机</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">汇编程序</a> ，而不是实际计算机的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">汇编程序</a> 。 类似地，WebAssembly需要用于概念性而非真实OS的系统接口。 <br><br> 但是，即使没有此系统界面，也已经有可以在浏览器外部运行WebAssembly的运行时。 他们是如何做到的？ 让我们看看。 <br><br><h1>  WebAssembly现在如何在浏览器之外工作？ </h1><br> 生成WebAssembly代码的第一个工具是Emscripten。 它在网络上模拟特定的OS系统接口POSIX。 这意味着程序员可以使用标准C库（libc）中的函数。 <br><br> 为此，Emscripten使用其自己的libc实现。 它分为两部分：第一部分被编译为WebAssembly模块，第二部分以JS-glue代码实现。 这种JS胶水将调用发送到与OS通讯的浏览器。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/a59/857/971a59857adc62742dde95b413cc613a.png"><br><br> 大多数早期的WebAssembly代码都是使用Emscripten编译的。 因此，当人们开始想在没有浏览器的情况下运行WebAssembly时，他们开始运行Emscripten代码。 <br><br> 因此，在这些运行时中，您应该为JS-glue代码中的所有功能创建自己的实现。 <br><br> 但是有一个问题。  JS胶水代码提供的接口尚未设计为标准甚至公共接口。 例如，要像调用普通API一样进行调用，JS胶水代码将使用<code>_system3(which, varargs)</code>调用。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/2de/7a8/52e2de7a84456993baeb32b1852c8da5.png"><br><br> 第一个参数是一个始终与名称中的数字匹配的整数（在本例中为3）。 <br><br> 第二个参数<code>varargs</code>列出参数。 之所以称为<code>varargs</code> ，是因为我们可以有不同数量的参数。 但是WebAssembly不允许将可变数量的参数传递给函数。 因此，它们是通过线性存储器传输的，这是不安全的，并且比通过寄存器要慢。 <br><br> 对于浏览器中的Emscripten，这是正常的。 但是现在运行时将其视为事实上的标准，实现了自己的JS胶水版本。 他们模拟POSIX模拟层的内部细节。 <br><br> 这意味着它们重新实现了代码（例如，将参数作为堆值传递），这在给定Emscripten约束的情况下是有意义的，但在这些运行时环境中没有此类约束。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e31/181/541/e31181541c0b666d54e43d5c10756088.png"></a> <br><br> 如果数十年来我们一直在构建WebAssembly生态系统，则它需要坚实的基础，而不是cru脚。 这意味着我们的实际标准不能是仿真仿真。 <br><br> 但是在这种情况下适用什么原则？ <br><br><h1>  WebAssembly系统界面应遵循哪些原则？ </h1><br>  WebAssembly的两个基本原则： <br><br><ul><li> 便携性 <br></li><li> 安全性 </li></ul><br> 我们超越了浏览器，但保留了这些关键原则。 <br><br> 但是，POSIX方法和Unix访问控制系统无法提供期望的结果。 让我们看看问题出在哪里。 <br><br><h3> 可携性 </h3><br>  POSIX提供源代码的可移植性。 您可以为不同的计算机使用不同版本的libc编译相同的源代码。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/255/eb7/51f/255eb751f342075453a6a30ea9f5bd98.png"></a> <br><br> 但是WebAssembly必须超越此范围。 我们需要编译一次才能在很多不同的系统上运行。 我们需要可移植的二进制文件。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/07e/06d/94c/07e06d94c4aca3ab4f5599c0c9ac3e10.png"></a> <br><br> 这简化了代码分配。 <br><br> 例如，如果本机节点模块是用WebAssembly编写的，则用户在安装具有本机模块的应用程序时无需运行node-gyp，并且开发人员无需配置和分发数十个二进制文件。 <br><br><h3> 安全性 </h3><br> 当代码要求操作系统进行输入或输出时，操作系统通常应使用基于所有权和组的访问控制系统来评估此操作的安全性。 <br><br> 例如，一个程序要求打开文件。 用户具有他有权访问的一组特定文件。 <br><br> 当用户启动程序时，该程序代表该用户启动。 如果用户有权访问文件（他是文件所有者，或者是有权访问文件的组的成员），则程序具有相同的访问权。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d93/8b9/b2a/d938b9b2af13c33b21ab11057331c413.png"></a> <br><br> 这可以保护用户彼此之间的相互保护，这在过去很有意义，当时很多人在一台计算机上工作，而管理员则控制该软件。 然后，主要威胁是其他用户正在查看您的文件。 <br><br> 一切都变了。 当前，系统通常是单用户，但使用可靠性未知的第三方代码。 现在，主要威胁来自您自己运行的代码。 <br><br> 例如，对于应用程序中的库，已经启动了一个新的维护程序（在开放源代码中通常如此）。 他可能是一个真诚的活动家……或一个入侵者。 而且，如果他具有访问您的系统的权限（例如，打开任何文件并通过网络发送文件的能力），那么此代码可能会造成很大的破坏。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/948/478/dc2/948478dc22fbebc0db26d763782be7a0.png"></a> <br>  <i><font color="gray"><b>可疑应用程序</b> ：我为用户Bob工作。</font></i>  <i><font color="gray">我可以打开他的比特币钱包吗？</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>核心</b> ：对于鲍勃？</font></i>  <i><font color="gray">当然可以！</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>可疑应用程序</b> ：太好了！</font></i>  <i><font color="gray">网络连接如何？</font></i> <br><br> 这就是使用第三方库很危险的原因。  WebAssembly通过沙盒以不同的方式提供安全性。 在这里，代码无法直接与操作系统对话。 但是那怎么访问系统资源呢？ 代码可以使用的主机（浏览器或wasm运行时）沙箱功能。 <br><br> 这意味着主机基于软件限制了程序的功能，不允许您仅代表用户执行操作，从而导致具有完全用户权限的任何系统调用。 <br><br> 本身具有沙箱并不能保证系统安全-主机仍可以将全部功能转移到沙箱，在这种情况下，主机不提供任何保护。 但是沙盒至少为主机提供了一个理论上的机会来构建更安全的系统。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/68f/bdc/2d7/68fbdc2d7bf44565e5923226bc2a9004.png"></a> <br>  <i><font color="gray"><b>WA</b> ：请注意，这里有一些与OS交互的安全玩具（safe_write，safe_read）。</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>可疑的应用程序</b> ：该死的...我的网络访问哪里？</font></i> <br><br> 在任何系统界面中，您都必须遵守这两个原则。 可移植性使软件开发和分发更加容易，并且绝对需要保护主机和用户的工具。 <br><br><h1> 这样的系统界面应该是什么样的？ </h1><br> 鉴于这两个关键原则，WebAssembly系统界面应该是什么？ <br><br> 我们将在标准化过程中找到这一点。 但是，我们有个建议： <br><br><ul><li> 创建一组标准接口 <br></li><li> 让我们从标准化wasi-core核心模块开始。 </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/597/a99/2e1597a9959ff7666a3e77db9d63f12d.png"><br><br>  wasi-core将会是什么？ 这些是所有程序所需的基础。 该模块将涵盖大多数POSIX功能，包括文件，网络连接，时钟和随机数。 <br><br> 许多基本功能将需要非常相似的方法。 例如，为POSIX文件提供了打开，关闭，读取和写入系统调用的方法，其他所有操作都是上面的附加组件。 <br><br> 但是wasi-core并未涵盖所有POSIX功能。 例如，流程的概念显然不适合WebAssembly。 另外，很明显，每个WebAssembly引擎都必须支持流程操作，例如<code>fork</code> 。 但是我们也希望使<code>fork</code>标准化成为可能。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9c9/771/11a/9c977111a2def0f6ae4d5b93b1592d91.png"></a> <br><br> 像Rust这样的语言将直接在其标准库中使用wasi-core。 例如，当编译为WebAssembly时，通过调用<code>__wasi_path_open</code>来实现从Rust <code>open</code> 。 <br><br> 对于C和C ++，我们创建了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wasi-sysroot</a> ，它根据wasi-core函数实现了libc。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/878/2a0/fa2/8782a0fa23e8d4890cb1964c896db84c.png"></a> <br><br> 我们希望像Clang这样的编译器能够与WASI API进行交互，并且像Rust编译器和Emscripten这样的完整工具链都将WASI用作其系统实现的一部分。 <br><br> 定制代码如何调用这些WASI函数？ <br><br> 执行代码的运行时通过wasi-core函数，将对象放置在沙箱中。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/371/e44/995/371e44995aa3c88a2c1886ceb27fab19.png"></a> <br><br> 这提供了可移植性，因为每个主机都可以有专门针对其平台的wasi-core实现：从WebAssembly运行时（例如Mozilla Wasmtime和Fastly Lucet）到Node甚至是浏览器。 <br><br> 它还提供了可靠的隔离，因为主机会根据软件选择将wasi-core功能转移到沙箱（即应允许的系统调用）。 这就是安全性。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e0a/3a6/28b/e0a3a628b861e321db36d64a647bdfd7.png"></a> <br><br>  WASI通过将基于授权的安全概念引入系统来增强和扩展安全性。 <br><br> 通常，如果代码需要打开文件，它会在行中使用路径名调用<code>open</code> 。 然后，操作系统检查代码是否有权执行此操作（基于启动程序的用户的权限）。 <br><br> 对于WASI，在调用函数访问文件时，必须传递文件描述符，该文件描述符必须附加文件本身或包含该文件的目录的权限。 <br><br> 因此，您不能拥有偶然要求您打开<code>/etc/passwd</code> 。 相反，代码只能使用其自己的目录。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/92f/b27/cb0/92fb27cb09092b74fd1ba46d661867c4.png"></a> <br><br> 由于这些系统调用的功能受到限制，因此可以将各种系统调用安全地解析为隔离的代码。 <br><br> 在每个模块中，依此类推。 默认情况下，该模块无权访问文件描述符。 但是，如果一个模块中的代码具有文件描述符，则可以将其传递给其他模块中调用的函数。 或者创建文件描述符的更多受限版本以传递给其他功能。 <br><br> 因此，运行时传递应用程序可以在顶级代码中使用的文件描述符，然后根据需要在整个系统的其余部分分发文件描述符。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d80/cb2/f63/d80cb2f63dd1cfa855fc096f36e96ba1.png"></a> <br><br> 这使WebAssembly更接近最小特​​权原则，在该原则下，模块仅获得完成其工作所需的最少资源集。 <br><br> 与CloudABI和Capsicum中一样，此概念基于基于特权的安全性。 这些系统的问题之一是代码难于移植。 但是我们认为这个问题可以解决。 <br><br> 如果代码已经使用带有相对文件路径的<code>openat</code> ，则编译代码就可以了。 <br><br> 如果代码使用<code>open</code>且openat样式的迁移过于激烈，则WASI将提供增量解决方案。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libpreopen，</a>可以创建应用程序具有合法访问权限的文件路径列表。 然后使用<code>open</code> ，但仅对这些路径使用。 <br><br><h1> 接下来是什么？ </h1><br> 我们相信wasi-core是一个好的开始。 它保留了WebAssembly的可移植性和安全性，为生态系统提供了坚实的基础。 <br><br> 但是在wasi-core完全标准化之后，还需要解决其他问题，包括： <br><br><ul><li> 异步输入输出 <br></li><li> 文件监控 <br></li><li> 文件锁 </li></ul><br> 这仅仅是开始，因此，如果您有任何想法，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参与其中</a> ！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446764/">https://habr.com/ru/post/zh-CN446764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446752/index.html">跟踪服务，OpenTracing和Jaeger</a></li>
<li><a href="../zh-CN446754/index.html">云未来</a></li>
<li><a href="../zh-CN446756/index.html">VR武器-[RAILGUN教程]</a></li>
<li><a href="../zh-CN446760/index.html">2019年3D博览会主题：3D金属印刷，安东·索托夫，萨马拉大学</a></li>
<li><a href="../zh-CN446762/index.html">6. Check Point入门R80.20。 SmartConsole入门</a></li>
<li><a href="../zh-CN446768/index.html">标称键入TypeScript或如何保护界面不受外来标识符的影响</a></li>
<li><a href="../zh-CN446770/index.html">大多数教程中找不到12个JavaScript技巧</a></li>
<li><a href="../zh-CN446772/index.html">不要打开通往世界的港口-它们会破坏您（有风险）</a></li>
<li><a href="../zh-CN446774/index.html">低聚角色设计</a></li>
<li><a href="../zh-CN446776/index.html">工作量证明有效</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>