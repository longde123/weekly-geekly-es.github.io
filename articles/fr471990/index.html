<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÖ üïç üó°Ô∏è M√©ta grammaire pour l'analyseur PEG üë®üèº‚Äçüåæ üèòÔ∏è üòé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette semaine, nous rendons le g√©n√©rateur d'analyseur ¬´ind√©pendant¬ª, c'est-√†-dire qu'il g√©n√©rera son propre analyseur. 
 Contenu de la s√©rie Python PE...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©ta grammaire pour l'analyseur PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Cette semaine, nous rendons le g√©n√©rateur d'analyseur ¬´ind√©pendant¬ª, c'est-√†-dire qu'il g√©n√©rera son propre analyseur. </p><br><div class="spoiler">  <b class="spoiler_title">Contenu de la s√©rie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseurs de cheville</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©ration de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grammaire r√©cursive gauche du PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajout d'actions √† la grammaire PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©ta grammaire pour l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation des fonctionnalit√©s restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEG sur Core Developer Sprint</a> </li></ul></div></div><br><p> Donc, nous avons d√©j√† un g√©n√©rateur d'analyseur, dont une partie est un analyseur de grammaire.  Nous pourrions l'appeler un m√©ta-analyseur.  Le m√©ta-analyseur fonctionne de mani√®re similaire √† celui g√©n√©r√©: <code>GrammarParser</code> h√©rite de l' <code>Parser</code> et utilise le m√™me m√©canisme <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  Cependant, tout √©tait √©crit √† la main.  Mais est-ce vrai? </p><a name="habracut"></a><br><p>  Lors de la conception d'un compilateur, il est habituel que le compilateur soit √©crit dans le langage qu'il compile.  Je me souviens avec amour que le compilateur Pascal que j'ai utilis√© lorsque j'ai appris √† programmer √©tait √©crit en Pascal lui-m√™me, GCC est √©crit en C et le compilateur Rust est √©crit en Rust. </p><br><p>  Comment faire  Au tout d√©but, impl√©mentez un compilateur pour un sous-ensemble ou une version ant√©rieure d'une langue dans une autre langue.  (Permettez-moi de vous rappeler que le compilateur Pascal d'origine a √©t√© √©crit en FORTRAN!) Ensuite, le nouveau compilateur est √©crit dans le langage cible et compil√© √† l'aide du compilateur de d√©marrage impl√©ment√© au tout d√©but.  D√®s que le nouveau compilateur commence √† fonctionner suffisamment bien, le compilateur d'amor√ßage est supprim√© et chaque version ult√©rieure du langage ou du compilateur est limit√©e √† ce qui peut √™tre compil√© √† l'aide de la version pr√©c√©dente du compilateur. </p><br><p>  Faisons-le pour notre m√©ta analyseur.  Nous allons √©crire une grammaire pour les grammaires (m√©ta-grammaire) puis g√©n√©rer un nouveau m√©ta-analyseur √† partir de cela.  Heureusement, j'ai planifi√© ce mouvement d√®s le d√©but, donc ce sera assez simple.  Les actions que nous avons ajout√©es dans l'√©pisode pr√©c√©dent sont un √©l√©ment important car nous n'avons pas besoin de changer le g√©n√©rateur, nous devons donc cr√©er une structure de donn√©es compatible. </p><br><p>  Voici une version simplifi√©e du m√©tagramme sans actions: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Je vais vous montrer comment ajouter une action de bas en haut.  Rappelez-vous de la partie 3 qu'il existe des objets <code>Rule</code> qui ont les <code>alts</code> <code>name</code> et <code>alts</code> .  Initialement, <code>alts</code> n'√©tait qu'une liste de listes de lignes (une liste externe pour les alternatives et une liste interne pour chaque √©l√©ment de l'alternative), mais pour impl√©menter des actions, je l'ai chang√© de sorte que les alternatives soient repr√©sent√©es par des objets <code>Alt</code> avec des <code>items</code> et <code>action</code> attributs d' <code>action</code> .  Les √©l√©ments sont toujours repr√©sent√©s comme de simples cha√Ænes.  Pour l' <code>item</code> nous obtenons: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Cela n√©cessite une petite explication: lorsque l'analyseur traite le jeton, il renvoie un objet <code>TokenInfo</code> qui a le <code>type</code> , la <code>string</code> et d'autres attributs.  Nous ne voulons pas que le g√©n√©rateur traite les objets <code>TokenInfo</code> , donc les actions ici extraient la cha√Æne du jeton.  Notez que pour tous les jetons en majuscules, tels que <code>NAME</code> , l'analyseur g√©n√©r√© utilise la version de cha√Æne (ici <code>name</code> ) comme nom de la variable. </p><br><p>  Les <code>items</code> doivent renvoyer une liste de cha√Ænes: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Ici, j'utilise des r√®gles r√©cursives √† droite, donc nous ne d√©pendons pas du traitement de la r√©cursion √† gauche, ajout√© dans la partie 5. (Pourquoi pas? Il est toujours bon de garder les choses aussi simples que possible, et cette grammaire ne b√©n√©ficiera pas grandement d'un changement sous la r√©cursion √† gauche). <code>item</code> r√©pertori√©, mais les <code>items</code> ne le sont pas r√©cursivement, car il s'agit d√©j√† d'une liste. </p><br><p>  R√®gle <code>alt</code> pour cr√©er un objet <code>Alt</code> : </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Je vais omettre les actions pour les <code>rules</code> et <code>start</code> , car elles sont d√©finies de cette fa√ßon. </p><br><p>  Cependant, il y a deux questions ouvertes.  Tout d'abord, comment trouver la d√©finition des classes <code>Rule</code> et <code>Alt</code> ?  Pour ce faire, nous devons ajouter plusieurs instructions d' <code>import</code> au code g√©n√©r√©.  Le moyen le plus simple serait de passer le drapeau au g√©n√©rateur, qui dit "c'est une m√©ta-grammaire", et de laisser le g√©n√©rateur ins√©rer une <code>import</code> suppl√©mentaire au d√©but du programme g√©n√©r√©.  Mais maintenant que nous avons les actions, de nombreux autres analyseurs voudront √©galement personnaliser leur importation, alors pourquoi ne pas voir si nous pouvons impl√©menter une approche plus g√©n√©rale. </p><br><p>  Il existe de nombreuses fa√ßons de le mettre en ≈ìuvre.  Un m√©canisme simple et g√©n√©ral consiste √† ajouter une section ¬´d√©finitions de variables¬ª en haut de la grammaire et √† permettre au g√©n√©rateur d'utiliser ces variables pour contr√¥ler divers aspects du code g√©n√©r√©.  J'ai d√©cid√© d'utiliser le symbole <code>@</code> pour commencer √† d√©finir la variable, suivi du nom de la variable ( <code>NAME</code> ) et de la valeur ( <code>STRING</code> ).  Par exemple, nous pouvons mettre le bloc de code suivant en haut de la m√©ta-grammaire: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  Le g√©n√©rateur d'analyseur imprimera la valeur de la variable de sous-en- <code>subheader</code> apr√®s l'importation standard, qui est ajout√©e par d√©faut (par exemple, pour importer la <code>memoize</code> ).  Si vous souhaitez plusieurs √©l√©ments d' <code>import</code> , vous pouvez utiliser une cha√Æne avec des guillemets triples, par exemple, </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  Ceci est facile √† ajouter √† la m√©ta-grammaire: nous allons casser la r√®gle de <code>start</code> comme suit: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (Je ne me souviens pas pourquoi je l'ai appel√© "m√©ta", mais j'ai choisi ce nom quand j'ai √©crit le code, et je m'en tiendrai. :-) </p><br><p>  Nous devons l'ajouter au m√©taparser de bootstrap.  Maintenant que la grammaire n'est pas seulement une liste de r√®gles, ajoutons un objet de grammaire avec les attributs <code>metas</code> et <code>rules</code> .  Nous pouvons d√©finir les actions suivantes: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Notez que la <code>meta</code> retourne un tuple; et aussi qu'il utilise <code>eval()</code> pour traiter les guillemets de cha√Æne.) </p><br><p>  Je n'ai pas mentionn√© la mise en place d'actions dans les r√®gles pour <code>alt</code> !  La raison en est qu'ils sortent un peu en d√©sordre.  Mais cela n'a aucun sens de reporter plus loin, alors voici: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  La salet√© dans la d√©finition est caus√©e par mon d√©sir de rendre le code Python arbitraire valide entre des crochets d'action boucl√©s, y compris imbriqu√©s dans un autre accolades boucl√©s.  √Ä cette fin, nous utilisons un jeton <code>OP</code> sp√©cial qui g√©n√®re notre tokenizer pour toutes les ponctuations reconnues par Python (renvoyant un seul jeton de type <code>OP</code> pour les op√©rateurs √† plusieurs caract√®res tels que <code>&lt;=</code> ou <code>**</code> ).  Les seuls autres jetons pouvant appara√Ætre dans les expressions Python sont les noms, les nombres et les cha√Ænes.  Ainsi, le code entre les accolades ext√©rieures de l'action, semble-t-il, peut √™tre exprim√© par des r√©p√©titions de <code>NAME | NUMBER | STRING | OP</code> <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  H√©las, cela ne fonctionnera pas car l' <code>OP</code> correspond √©galement aux accolades, et puisque l'analyseur PEG est toujours gourmand, cela capturera le crochet de fermeture et nous ne verrons jamais la fin de l'action.  Par cons√©quent, nous ajoutons un petit ajustement, permettant √† l'action de renvoyer une erreur de choix alternatif, renvoyant None.  Je ne sais pas si c'est un ph√©nom√®ne standard dans d'autres analyseurs PEG - je l'ai trouv√© sur place quand j'ai d√ª r√©soudre le probl√®me de reconnaissance de la parenth√®se fermante (m√™me sans paires imbriqu√©es).  Cela semble bien fonctionner et je pense que cela correspond √† la philosophie globale de l'analyse PEG.  Cela peut √™tre consid√©r√© comme une forme sp√©ciale de prospective (dont je parlerai ci-dessous). </p><br><p>  En utilisant ce petit hack, nous pouvons faire la comparaison sur l' <code>OP</code> tomber sur une accolade boucl√©e.  Ensuite, une comparaison des <code>stuff</code> et de l' <code>action</code> sera possible. </p><br><p>  Avec ces choses, une m√©ta-grammaire peut √™tre analys√©e par un m√©taparser de bootstrap, et le g√©n√©rateur peut la transformer en un nouveau m√©ta-analyseur qui peut s'analyser.  Et, chose importante, le nouveau m√©ta-analyseur peut toujours analyser la m√™me m√©ta-grammaire.  Si nous compilons la m√©ta grammaire avec le nouveau compilateur de m√©ta, le r√©sultat est le m√™me: cela prouve que le m√©ta analyseur g√©n√©r√© fonctionne correctement. </p><br><p>  Voici la m√©ta grammaire de l'action compl√®te.  Il peut s'analyser, car il sait combiner de longues lignes: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Maintenant que nous avons une m√©ta-grammaire fonctionnelle, nous sommes presque pr√™ts √† apporter quelques am√©liorations. </p><br><p>  Mais vous devez d'abord r√©fl√©chir un peu: des lignes vides!  Il s'av√®re que le module de jeton <code>tokenize</code> cr√©e des jetons suppl√©mentaires pour suivre les <code>tokenize</code> ligne insignifiants (jeton <code>NL</code> ) et les commentaires (jeton <code>COMMENT</code> ).  Au lieu de les inclure dans la grammaire (je l'ai essay√©, il n'y a pas beaucoup de plaisir!), Il y a un morceau de code tr√®s simple que nous pouvons ajouter √† notre classe tokenizer pour les filtrer.  Voici la m√©thode <code>peek_token</code> am√©lior√©e: </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Cela supprime compl√®tement les jetons <code>NL</code> et <code>COMMENT</code> , donc nous n'avons plus besoin de nous en pr√©occuper dans la grammaire. </p><br><p>  Enfin, am√©liorons la m√©ta-grammaire!  Ils seront purement cosm√©tiques: je n'aime pas quand je suis oblig√© d'√©crire toutes les alternatives sur une seule ligne.  La m√©ta grammaire que j'ai montr√©e ci-dessus ne s'analyse pas r√©ellement √† cause de telles choses: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Cela est d√ª au fait que le tokenizer cr√©e un token <code>NEWLINE</code> √† la fin de la premi√®re ligne, et √† ce moment le m√©ta-analyseur consid√©rera que c'est la fin de la r√®gle.  De plus, cette <code>NEWLINE</code> sera suivie du jeton <code>INDENT</code> , car la ligne suivante est en retrait.  Jusqu'au d√©but de la prochaine r√®gle, un jeton <code>DEDENT</code> sera √©galement pr√©sent. </p><br><p>  Voici comment le g√©rer.  Pour comprendre le comportement du module <code>tokenize</code> , nous pouvons regarder la s√©quence de jetons g√©n√©r√©s pour les blocs en retrait en ex√©cutant le module <code>tokenize</code> tant que script et en lui passant du texte: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Nous voyons que cela produit la s√©quence de jetons suivante (j'ai un peu simplifi√© la sortie du code ci-dessus): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Ainsi, un groupe s√©lectionn√© de cha√Ænes est indiqu√© par les <code>DEDENT</code> et <code>DEDENT</code> .  Maintenant, nous pouvons r√©√©crire la <code>rule</code> m√©ta-grammaire pour la <code>rule</code> comme suit: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Je d√©compose les actions en lignes pour qu'elles se lisent normalement dans une √©troite colonne de texte. Ceci est possible car le tokenizer ignore les sauts de ligne √† l'int√©rieur des accolades correspondantes.) </p><br><p>  La beaut√© de ceci est que nous n'avons m√™me pas besoin de changer le g√©n√©rateur: la structure de donn√©es cr√©√©e par cette m√©ta-grammaire am√©lior√©e est la m√™me qu'auparavant.  Faites √©galement attention √† la troisi√®me option pour la <code>rule</code> : cela nous permet d'√©crire: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  que certains peuvent trouver plus propre que la version que j'ai montr√©e plus t√¥t.  Les deux formes sont faciles √† r√©soudre, nous n'avons donc pas besoin de discuter de style. </p><br><p>  Dans le prochain article, je montrerai comment j'ai impl√©ment√© diverses fonctions PEG, telles que des √©l√©ments facultatifs, des r√©p√©titions et des info-bulles.  (Pour √™tre honn√™te, j'avais pr√©vu d'en parler dans cet article, mais il est d√©j√† trop volumineux. Je vais donc le diviser en deux parties.) </p><br><p>  Licence pour cet article et code cit√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471990/">https://habr.com/ru/post/fr471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471978/index.html">Nous ne pouvons pas faire confiance aux syst√®mes d'IA bas√©s uniquement sur le deep learning</a></li>
<li><a href="../fr471980/index.html">Escrocs au t√©l√©phone. Acte quatre, final ...</a></li>
<li><a href="../fr471982/index.html">Discuter de l'avenir de PHP</a></li>
<li><a href="../fr471986/index.html">Grammaire r√©cursive gauche du PEG</a></li>
<li><a href="../fr471988/index.html">Ajout d'actions √† la grammaire PEG</a></li>
<li><a href="../fr471992/index.html">Impl√©mentation des fonctionnalit√©s restantes de PEG</a></li>
<li><a href="../fr471994/index.html">Travail sur PEG sur Core Developer Sprint</a></li>
<li><a href="../fr471998/index.html">F # 10: Listes</a></li>
<li><a href="../fr472000/index.html">¬´Il est essentiel que la communaut√© √©tablisse des normes¬ª: Marchin Moskala √† propos de Kotlin</a></li>
<li><a href="../fr472002/index.html">Paquetage √† Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>