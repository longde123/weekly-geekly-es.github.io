<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïã üõçÔ∏è üë®üèº‚Äç‚öïÔ∏è Enkapsulasi untuk samurai asli, atau nuansa yang terkait dengan kata kunci internal di C # ü§∑ üì£ üöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog: internal adalah publik baru 


 Masing-masing dari kami memimpikan sebuah proyek di mana semuanya akan dilakukan dengan benar. Sepertinya cuku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enkapsulasi untuk samurai asli, atau nuansa yang terkait dengan kata kunci internal di C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Prolog: internal adalah publik baru </h2><br><p>  Masing-masing dari kami memimpikan sebuah proyek di mana semuanya akan dilakukan dengan benar.  Sepertinya cukup alami.  Segera setelah Anda belajar tentang kemungkinan untuk menulis kode yang baik, segera setelah Anda mendengar legenda tentang kode yang sama yang dapat dengan mudah dibaca dan dimodifikasi, Anda segera menerangi dengan demikian, "Baiklah, sekarang saya akan melakukannya dengan benar, saya pintar dan saya membaca McConnell." </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="gambar"><br><br><p>  Proyek semacam itu terjadi dalam hidup saya.  Satu lagi  Dan saya melakukannya di bawah pengawasan sukarela, di mana setiap baris saya ikuti.  Karena itu, saya tidak hanya ingin, tetapi saya harus melakukan semuanya dengan benar.  Salah satu "benar" adalah "menghormati enkapsulasi dan mendekati maksimum, karena Anda selalu punya waktu untuk membuka, dan kemudian akan terlambat untuk menutup kembali".  Dan karena itu, di mana pun saya bisa, saya mulai menggunakan pengubah akses internal daripada publik untuk kelas.  Dan, tentu saja, ketika Anda mulai aktif menggunakan fitur bahasa baru untuk Anda, beberapa nuansa muncul.  Saya ingin membicarakannya secara berurutan. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Bantuan dasar ofensif</b> <div class="spoiler_text"><p>  Hanya untuk mengingatkan dan memberi label. </p><br><ul><li>  Majelis adalah unit penyebaran terkecil di .NET dan salah satu unit kompilasi dasar.  Seperti ini, ini bisa berupa .dll atau .exe.  Mereka mengatakan itu dapat dibagi menjadi beberapa file yang disebut modul. </li><li>  pengubah akses publik, yang berarti dapat diakses oleh semua orang yang ditandai dengannya. </li><li>  pengubah akses internal, yang artinya hanya ditandai di dalam rakitan. </li><li>  protected - pengubah akses yang menunjukkan bahwa itu ditandai hanya tersedia untuk ahli waris kelas di mana yang ditandai berada. </li><li>  private - pengubah akses yang menunjukkan bahwa itu ditandai hanya tersedia untuk kelas di mana ia berada.  Dan tidak ada orang lain. </li></ul><br></div></div><br><h2>  Tes Unit dan Build Friendly </h2><br><p>  Di C ++, ada fitur aneh seperti kelas ramah.  Kelas dapat ditetapkan sebagai teman, dan kemudian batas enkapsulasi di antara mereka dihapus.  Saya menduga bahwa ini bukan fitur paling aneh di C ++.  Mungkin bahkan sepuluh yang paling aneh tidak termasuk.  Tetapi untuk menembak diri sendiri dengan menghubungkan beberapa kelas dengan erat, entah bagaimana terlalu mudah, dan sangat sulit untuk membuat case yang cocok untuk fitur ini. </p><br><p>  Yang lebih mengejutkan adalah mengetahui bahwa di .NET ada majelis yang ramah, semacam pemikiran ulang.  Artinya, Anda dapat membuat satu rakitan melihat apa yang tersembunyi di balik kunci internal di rakitan lain.  Ketika saya mengetahui hal ini, saya agak terkejut.  Nah, bagaimana, mengapa?  Apa gunanya  Siapa yang akan mengikat erat dua majelis yang terlibat dalam pemisahan mereka?  Kasus-kasus ketika dalam situasi yang tidak dapat dipahami mereka membentuk publik, kami tidak mempertimbangkan dalam artikel ini. </p><br><p>  Dan kemudian dalam proyek yang sama, saya mulai belajar salah satu cabang dari jalur samurai sejati: pengujian unit.  Dan dalam unit tes Feng Shui harus dalam majelis terpisah.  Untuk Feng Shui yang sama, semua yang bisa disembunyikan di dalam rakitan, Anda harus bersembunyi di dalam rakitan.  Saya menghadapi pilihan yang sangat, sangat tidak menyenangkan.  Entah tes akan berbaring berdampingan dan pergi ke klien bersama dengan kode yang berguna baginya, atau semuanya akan dicakup oleh kata kunci publik, berapa lama roti telah berbaring di kelembaban. </p><br><p>  Dan di sini, dari suatu tempat di ingatanku, sesuatu diperoleh tentang pertemuan ramah.  Ternyata jika Anda memiliki majelis "YourAssemblyName", maka Anda dapat menulis seperti ini: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  Dan majelis "YourAssemblyName.Tests" akan melihat apa yang ditandai dengan kata kunci internal di "YourAssemblyName".  Baris ini dapat dimasukkan, sedikit saja, di AssemblyInfo.cs, yang VS buat secara khusus untuk menyimpan atribut tersebut. </p><br><div class="spoiler">  <b class="spoiler_title">Kembali kasar ke bantuan dasar</b> <div class="spoiler_text">  Di .NET, selain atribut atau kata kunci yang sudah bawaan seperti abstrak, publik, internal, statis, Anda dapat membuatnya sendiri.  Dan gantungkan pada apa pun yang Anda inginkan: bidang, properti, kelas, metode, acara, dan seluruh majelis.  Dalam C #, untuk ini Anda cukup menulis nama atribut dalam tanda kurung sebelum apa yang Anda tunggu.  Pengecualian adalah rakitan itu sendiri, karena tidak ada indikasi langsung di mana pun dalam kode bahwa "Majelis dimulai di sini".  Di sana, sebelum nama atribut, Anda perlu menambahkan rakitan: <br></div></div><br><p>  Dengan demikian, serigala tetap penuh, domba-domba aman, segala sesuatu yang mungkin masih bersembunyi di dalam rakitan, tes unit hidup dalam rakitan terpisah, sebagaimana mestinya, dan fitur yang saya hampir tidak ingat mendapat alasan untuk menggunakannya.  Mungkin satu-satunya alasan yang ada. </p><br><p>  Saya hampir lupa satu poin penting.  Tindakan atribut InternalsVisibleTo adalah satu arah. </p><br><h2>  dilindungi &lt;internal? </h2><br><p>  Jadi situasinya: A dan B sedang duduk di atas pipa. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A hancur dalam proses peninjauan kode, karena tidak digunakan di luar majelis, tetapi karena alasan tertentu memungkinkan dirinya untuk memiliki pengubah akses publik, B menyebabkan kesalahan kompilasi, yang dapat menyebabkan pingsan di menit-menit pertama. </p><br><p>  Pada dasarnya, pesan kesalahan itu logis.  Accessor properti tidak dapat mengungkapkan lebih dari properti itu sendiri.  Siapa pun akan bereaksi dengan pengertian jika kompiler memberikan header untuk ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Namun klaim terhadap garis ini segera menghancurkan otak: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Saya perhatikan bahwa tidak akan ada keluhan tentang baris ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Jika Anda tidak banyak berpikir, hierarki berikut ada di kepala Anda: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Dan hierarki ini tampaknya berfungsi.  Kecuali satu tempat.  Di mana internal&gt; dilindungi.  Untuk memahami esensi dari klaim kompiler, mari kita ingat pembatasan apa yang diberlakukan oleh internal dan dilindungi.  internal - hanya di dalam majelis.  dilindungi - hanya ahli waris.  Perhatikan setiap ahli waris.  Dan jika kelas B ditandai sebagai publik, maka di majelis lain Anda dapat menentukan turunannya.  Dan kemudian set accessor benar-benar mendapatkan akses ke mana seluruh properti tidak memilikinya.  Karena kompiler C # adalah paranoid, ia bahkan tidak bisa membiarkan kemungkinan seperti itu. </p><br><p>  Terima kasih padanya untuk ini, tetapi kita perlu memberikan akses kepada pewaris aksesor.  Dan khusus untuk kasus seperti itu, ada pengubah akses internal yang dilindungi. </p><br><div class="spoiler">  <b class="spoiler_title">Bantuan ini tidak terlalu ofensif</b> <div class="spoiler_text"><ul><li>  protected internal - pengubah akses yang menunjukkan bahwa yang ditandai tersedia di dalam rakitan <strong>atau ke</strong> ahli waris kelas di mana yang ditandai berada. </li></ul><br></div></div><br><p>  Jadi jika kita ingin kompiler mengizinkan kita untuk menggunakan properti ini dan mengaturnya dalam ahli waris, kita perlu melakukan ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Dan hierarki pengubah akses yang benar terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Antarmuka </h2><br><p>  Jadi, situasinya: A, I, B sedang duduk di atas pipa. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Kami duduk persis dan tidak ikut campur di luar majelis.  Tetapi mereka ditolak oleh kompiler.  Di sini esensi klaim jelas dari pesan kesalahan.  Implementasi antarmuka harus terbuka.  Bahkan jika antarmuka itu sendiri ditutup.  Akan logis untuk mengikat akses ke implementasi antarmuka dengan ketersediaannya, tetapi apa yang tidak, tidak.  Implementasi antarmuka harus bersifat publik. </p><br><p>  Dan kita punya dua jalan keluar.  Pertama: melalui derak dan kertakan gigi, gantung pengubah akses publik pada implementasi antarmuka.  Kedua: implementasi eksplisit dari antarmuka.  Ini terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Harap dicatat bahwa dalam kasus kedua tidak ada pengubah akses.  Kepada siapa dalam hal ini penerapan metode ini tersedia?  Anggap saja tidak ada.  Lebih mudah ditunjukkan dengan contoh: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  Implementasi eksplisit dari antarmuka I berarti bahwa sampai kita secara eksplisit melemparkan variabel ke tipe I, tidak ada metode yang mengimplementasikan antarmuka ini.  Menulis (b seperti saya) .Beberapa Metode () setiap kali bisa menjadi kelebihan.  Seperti ((I) b) .Beberapa Metode ().  Dan saya menemukan dua cara untuk mengatasi ini.  Saya memikirkan satu sendiri, dan jujur ‚Äã‚Äãgoogled yang kedua. </p><br><p>  Cara pertama adalah pabrik: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Nah, atau pola lain yang memungkinkan Anda menyembunyikan nuansa ini. </p><br><p>  Metode dua - metode ekstensi: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  Anehnya, itu berhasil.  Baris-baris ini berhenti membuat kesalahan: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Setelah semua, panggilan itu datang, seperti IntelliSense memberitahu kita di Visual Studio, bukan untuk metode untuk secara eksplisit mengimplementasikan antarmuka, tetapi untuk metode ekstensi.  Dan tidak ada yang melarang untuk menoleh ke mereka.  Dan metode ekstensi antarmuka dapat dipanggil pada semua implementasinya. </p><br><p>  Tetapi masih ada satu peringatan.  Di dalam kelas itu sendiri, Anda perlu mengakses metode ini melalui kata kunci ini, jika tidak kompiler tidak akan mengerti bahwa kami ingin merujuk ke metode ekstensi: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Jadi, dan sebagainya, kita memiliki atau publik, di mana seharusnya tidak, tetapi <em>tampaknya</em> tidak ada salahnya, atau sedikit kode tambahan untuk setiap antarmuka internal.  Pilih kejahatan yang tidak terlalu Anda sukai. </p><br><h2>  Refleksi </h2><br><p>  Saya memukul ini dengan menyakitkan ketika saya mencoba untuk menemukan konstruktor melalui refleksi, yang, tentu saja, ditandai sebagai internal di kelas internal.  Dan ternyata refleksi itu tidak akan memberikan apa pun yang tidak akan dipublikasikan.  Dan ini, pada prinsipnya, logis. </p><br><p>  Pertama, refleksi, jika saya ingat dengan benar apa yang ditulis oleh orang-orang pintar dalam buku-buku pintar, ini tentang mencari informasi dalam metadata majelis.  Yang, secara teori, seharusnya tidak memberi terlalu banyak (saya pikir begitu, setidaknya).  Kedua, penggunaan refleksi yang utama adalah membuat program Anda bisa diperluas.  Anda menyediakan semacam antarmuka untuk orang luar (mungkin bahkan dalam bentuk antarmuka, fiy-ha!).  Dan mereka mengimplementasikannya dan menyediakan plugins, mods, ekstensi dalam bentuk rakitan yang dimuat saat bepergian, dari mana refleksi mendapatkannya.  Dan dengan sendirinya, API Anda akan menjadi publik.  Artinya, melihat internal melalui refleksi tidak secara teknis dan tidak ada gunanya dari sudut pandang praktis. </p><br><p>  <strong>Perbarui</strong>  Di sini, di komentar, ternyata refleksi memungkinkan, jika Anda secara eksplisit memintanya, untuk mencerminkan segalanya.  Baik itu internal, bahkan pribadi.  Jika Anda tidak menulis semacam alat analisis kode, tolong jangan lakukan itu.  Teks di bawah ini masih relevan untuk kasus ketika kami mencari tipe anggota terbuka.  Dan secara umum, jangan lewat komentar, ada banyak hal menarik. </p><br><p>  Ini bisa diselesaikan dengan refleksi, tetapi mari kita kembali ke contoh sebelumnya, di mana A, I, B duduk di atas pipa: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Penulis kelas A memutuskan bahwa tidak ada hal buruk yang akan terjadi jika metode kelas internal ditandai sebagai publik, sehingga kompiler tidak sakit, dan sehingga tidak perlu repot kode.  Antarmuka ditandai sebagai internal, kelas yang mengimplementasikannya ditandai sebagai internal, dari luar tampaknya tidak ada cara untuk sampai ke metode yang ditandai sebagai publik. </p><br><p>  Dan kemudian pintu terbuka dan refleksi perlahan merayap masuk: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Pelajari kode ini, masukkan ke studio, jika diinginkan.  Di sini kami mencoba menggunakan refleksi untuk menemukan semua metode dari semua jenis pipa kami (Pipa namespace).  Dan inilah hasil yang diberikannya kepada kita: </p><br><blockquote>  Dalam tipe I kami menemukan Void SomeMethod () <br>  NULL!  Tidak dapat menemukan metode SomeMethod dalam tipe IExtensions <br>  Dalam tipe A kami menemukan Void SomeMethod () <br>  NULL!  Tidak dapat menemukan metode OtherMetode dalam tipe A <br>  NULL!  Tidak dapat menemukan metode SomeMethod dalam tipe B <br>  NULL!  Tidak dapat menemukan metode OtherMetode dalam tipe B <br></blockquote><br><p>  Saya harus mengatakan segera bahwa menggunakan objek tipe MethodInfo, metode yang ditemukan dapat dipanggil.  Artinya, jika refleksi menemukan sesuatu, maka enkapsulasi dapat dilanggar murni secara teoritis.  Dan kami telah menemukan sesuatu.  Pertama, publik yang sama membatalkan SomeMethod () dari kelas A. Diharapkan, apa lagi yang harus dikatakan.  Kegemaran ini mungkin masih memiliki konsekuensi.  Kedua, batal SomeMethod () dari antarmuka I. Ini sudah lebih menarik.  Tidak peduli bagaimana kita mengunci diri kita, metode abstrak yang ditempatkan di antarmuka (atau apa yang sebenarnya ditempatkan CLR di sana) sebenarnya terbuka.  Oleh karena itu kesimpulannya dibuat dalam paragraf terpisah: </p><br><p>  <em>Perhatikan dengan cermat pada siapa dan jenis System.Type apa yang Anda berikan.</em> </p><br><p>  Tetapi ada satu nuansa lagi dengan dua metode ini yang ditemukan, yang ingin saya pertimbangkan.  Metode antarmuka internal dan metode publik dari kelas internal dapat ditemukan menggunakan refleksi.  Sebagai orang yang masuk akal, saya akan menyimpulkan bahwa mereka jatuh ke dalam metadata.  Sebagai orang yang berpengalaman, saya akan memverifikasi kesimpulan ini.  Dan dalam ILDasm ini akan membantu kita. </p><br><div class="spoiler">  <b class="spoiler_title">Mengintip lubang kelinci di metadata pipa kami</b> <div class="spoiler_text"><p>  Majelis dikumpulkan dalam rilis </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Pandangan cepat menunjukkan bahwa <strong>semuanya</strong> masuk ke metadata, tidak peduli bagaimana itu ditandai.  Refleksi masih dengan hati-hati menyembunyikan dari kita bahwa orang luar tidak seharusnya melihatnya.  Jadi mungkin saja bahwa lima baris kode tambahan untuk setiap metode antarmuka internal bukanlah kejahatan besar.  Namun, kesimpulan utamanya tetap sama: </p><br><p>  <em>Perhatikan dengan cermat pada siapa dan jenis System.Type apa yang Anda berikan.</em> </p><br><p>  Tapi ini, tentu saja, tingkat berikutnya, setelah aksesi kata kunci internal di semua tempat di mana tidak perlu untuk umum. </p><br><h2>  PS </h2><br><p>  Anda tahu hal paling keren tentang penggunaan kata kunci internal di mana-mana di dalam rakitan?  Ketika tumbuh, Anda harus membaginya menjadi dua atau lebih.  Dan dalam proses ini Anda harus istirahat untuk membuat beberapa jenis terbuka.  Dan Anda harus berpikir tentang jenis apa yang layak menjadi terbuka.  Setidaknya sebentar. </p><br><p>  Ini berarti yang berikut: <em>praktik penulisan kode ini akan membuat Anda berpikir lagi tentang apa bentuk batas arsitektural antara majelis yang baru lahir.</em>  Apa yang bisa lebih cantik? </p><br><h2>  PPS </h2><br><p>  Dimulai dengan versi C # 7.2, pengubah akses baru, yang dilindungi pribadi, telah muncul.  Dan saya masih tidak tahu apa itu dan dengan apa itu dimakan.  Karena tidak ditemui dalam latihan.  Tapi saya akan senang mengetahui di komentar.  Tapi bukan copy-paste dari dokumentasi, tetapi kasus nyata ketika pengubah akses ini mungkin diperlukan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445804/">https://habr.com/ru/post/id445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445794/index.html">Raksasa IT mengungkap solusi penyebaran cloud hybrid hybrid</a></li>
<li><a href="../id445796/index.html">Fintech Digest: Dorsey membayar dengan bitcoin, strategi blockchain Australia, Levi's IPO, walikota Chicago dan bitcoin yang tak terhindarkan</a></li>
<li><a href="../id445798/index.html">Badak di dalam kucing - jalankan firmware di emulator Kopycat</a></li>
<li><a href="../id445800/index.html">Monads dalam 15 menit</a></li>
<li><a href="../id445802/index.html">5 Hal Tren Internet yang Harus Diketahui Setiap Orang</a></li>
<li><a href="../id445806/index.html">Bagaimana kecerdasan buatan mengubah ilmu pengetahuan</a></li>
<li><a href="../id445808/index.html">Kami membenci dan memburu: kehidupan berbahaya seorang cracker virus yang membuat musuh yang kuat</a></li>
<li><a href="../id445814/index.html">Bagaimana robot pengiriman telah mengubah kebiasaan kuliner siswa Amerika</a></li>
<li><a href="../id445816/index.html">Bagaimana kami melihat rendering server dan apa yang terjadi</a></li>
<li><a href="../id445820/index.html">MVCC-3. Versi baris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>