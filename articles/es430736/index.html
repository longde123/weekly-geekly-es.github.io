<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüè´ üë©üèΩ‚Äçüî¨ üè¢ Desarrolle su navegador desde cero. Primera parte: HTML üë∏ üìì üåÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 


 Continuamos la serie de art√≠culos sobre el desarrollo del motor del navegador. 


 En este art√≠culo explicar√© c√≥mo crear el analizad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrolle su navegador desde cero. Primera parte: HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Hola a todos! </p><br><p>  Continuamos la serie de art√≠culos sobre el desarrollo del motor del navegador. </p><br><p>  En este art√≠culo explicar√© c√≥mo crear el analizador HTML m√°s r√°pido con DOM.  Analizaremos la especificaci√≥n HTML y por qu√© es malo con respecto al rendimiento y al consumo de recursos al analizar HTML. </p><br><p>  Con este tema, inform√© sobre el pasado HighLoad ++.  No todos pueden asistir a la conferencia, adem√°s el art√≠culo tiene m√°s detalles. </p><br><p>  Supongo que el lector tiene conocimientos b√°sicos de HTML: etiquetas, nodos, elementos, espacio de nombres. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  Especificaci√≥n HTML </h2><br><p>  Antes de comenzar a tocar la implementaci√≥n del analizador HTML, debe comprender qu√© especificaciones HTML debe creer. </p><br><p>  Hay dos especificaciones HTML: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WHATWG</a> <br><ul><li>  Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">W3c</a> <br><ul><li>  Amplia lista de empresas </li></ul></li></ol><br><p> Naturalmente, la elecci√≥n recay√≥ en los l√≠deres de la industria: <strong><code>WHATWG</code></strong> .  Nivel de vida, grandes empresas, cada una con su propio navegador / motor de b√∫squeda. </p><br><p>  ACTUALIZACI√ìN: Desafortunadamente, los enlaces dados a las especificaciones no se abren desde Rusia.  Aparentemente, el "eco de la guerra" con telegramas. </p><br><h2 id="process-parsinga-html">  Proceso de an√°lisis HTML </h2><br><p>  El proceso de construcci√≥n de un √°rbol HTML se puede dividir en cuatro partes: </p><br><ol><li>  Decodificador </li><li>  Pretratamiento </li><li>  Tokenizer </li><li>  Construir un √°rbol </li></ol><br><p>  Consideramos cada etapa por separado. </p><br><h3 id="dekoder">  Decodificador </h3><br><p>  El tokenizer acepta caracteres Unicode (puntos de c√≥digo) como entrada.  Por consiguiente, necesitamos convertir la secuencia de bytes actual a caracteres Unicode.  Para hacer esto, use la especificaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">codificaci√≥n</a> . </p><br><p>  Si tenemos HTML con una codificaci√≥n desconocida (sin encabezado HTTP), entonces debemos determinarlo antes de que comience la decodificaci√≥n.  Para hacer esto, utilizaremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo de codificaci√≥n sniffing</a> . </p><br><p>  Si es muy breve, la esencia del algoritmo es que esperamos <strong><code>500</code></strong> o los primeros <strong><code>1024 </code></strong> del flujo de bytes y ejecutamos el algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preescaneo de flujo de bytes para determinar su codificaci√≥n</a> que intenta encontrar la <strong><code>&lt;meta&gt;</code></strong> con los atributos <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> o <strong><code>charset</code></strong> e intenta entienda qu√© codificaci√≥n indic√≥ el desarrollador HTML. </p><br><p>  La especificaci√≥n de <strong><code>Encoding</code></strong> estipula el conjunto m√≠nimo de codificaciones admitidas por el motor del navegador (21 en total): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows -1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE y x-user -definido. </p><br><h3 id="predvaritelnaya-obrabotka">  Pretratamiento </h3><br><p>  Despu√©s de decodificar los bytes en caracteres Unicode, necesitamos "limpiar".  Es decir, reemplace todos los caracteres de retorno de carro ( <strong><code>\r</code></strong> ) seguidos de un car√°cter de avance de l√≠nea ( <strong><code>\n</code></strong> ) con un car√°cter de retorno de carro ( <strong><code>\r</code></strong> ).  Luego, reemplace todos los caracteres de retorno de carro con un car√°cter de nueva l√≠nea ( <strong><code>\n</code></strong> ). </p><br><p>  As√≠ se describe en la especificaci√≥n.  Es decir, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  Pero, de hecho, nadie lo hace.  Hazlo m√°s f√°cil: </p><br><p>  Si obtiene un car√°cter de retorno de carro ( <strong><code>\r</code></strong> ), observe si hay un car√°cter de avance de l√≠nea ( <strong><code>\n</code></strong> ).  Si lo hay, entonces cambiamos ambos caracteres al car√°cter de avance de l√≠nea ( <strong><code>\n</code></strong> ), si no, cambiamos solo el primer car√°cter ( <strong><code>\r</code></strong> ) al avance de l√≠nea ( <strong><code>\n</code></strong> ). </p><br><p>  Esto completa el procesamiento preliminar de datos.  S√≠, solo necesita deshacerse de los s√≠mbolos de retorno de carro para que no caigan en el tokenizador.  El tokenizador no espera y no sabe qu√© hacer con el s√≠mbolo de retorno de carro. </p><br><h3 id="oshibki-parsinga">  Analizando errores </h3><br><p>  Para que en el futuro no haya preguntas, debe saber de inmediato qu√© es un <code> </code> ( <strong><code>parse error</code></strong> ). </p><br><p>  Nada realmente mal.  Suena amenazante, pero en realidad esto es solo una advertencia de que est√°bamos esperando uno, pero tenemos otro. </p><br><p>  Un error de an√°lisis no detendr√° el procesamiento de datos o la construcci√≥n de √°rboles.  Este es un mensaje que indica que no tenemos HTML v√°lido. </p><br><p>  Se puede obtener un error de Parsig para pares sustitutos, <code>\0</code> , ubicaci√≥n de etiqueta incorrecta, <strong><code>&lt;!DOCTYPE&gt;</code></strong> incorrecto y todo tipo de otras cosas. </p><br><p>  Por cierto, algunos errores de an√°lisis conducen a consecuencias.  Por ejemplo, si especifica "bad" <strong><code>&lt;!DOCTYPE&gt;</code></strong> , el √°rbol HTML se marcar√° como <strong><code>QUIRKS</code></strong> y la l√≥gica de algunas funciones DOM cambiar√°. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  Como se mencion√≥ anteriormente, el tokenizer acepta caracteres Unicode como entrada.  Esta es una m√°quina de estados que tiene <strong><code>80</code></strong> estados.  En cada estado, condiciones para los caracteres Unicode.  Dependiendo del personaje recibido, el tokenizer puede: </p><br><ol><li>  Cambia tu estado </li><li>  Genera un token y cambia de estado </li><li>  No hagas nada, espera al pr√≥ximo personaje </li></ol><br><p>  El tokenizer crea seis tipos de tokens: DOCTYPE, Start Tag, End Tag, Comment, Character, End-Of-File.  Que entran en la etapa de construir un √°rbol. </p><br><p>  Es de destacar que el tokenizer no conoce todos sus estados, pero donde aproximadamente el 40% (tomado del techo, por ejemplo).  "¬øPor qu√© el resto?"  - usted pregunta  Alrededor del 60% restante conoce la etapa de construcci√≥n de un √°rbol. </p><br><p>  Esto se hace para analizar correctamente etiquetas como <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> y as√≠ sucesivamente.  Es decir, generalmente aquellas etiquetas en las que no esperamos otras etiquetas, sino solo cerrarnos. </p><br><p>  Por ejemplo, la <strong><code>&lt;title&gt;</code></strong> no puede contener otras etiquetas.  Cualquier etiqueta en <strong><code>&lt;title&gt;</code></strong> se percibir√° como texto hasta que encuentre una etiqueta de cierre para s√≠ misma <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  ¬øPor qu√© se hace esto?  Despu√©s de todo, podr√≠as decirle al tokenizador que si nos encontramos con la <strong><code>&lt;title&gt;</code></strong> seguiremos el "camino que necesitamos".  ¬°Y eso ser√≠a cierto si no son espacios de nombres!  S√≠, el espacio de nombres afecta el comportamiento de la etapa de construcci√≥n del √°rbol, que a su vez cambia el comportamiento del tokenizer. </p><br><p>  Como ejemplo, considere el comportamiento de la <strong><code>&lt;title&gt;</code></strong> en los espacios de nombres HTML y SVG: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El resultado de construir un √°rbol: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El resultado de construir un √°rbol: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  Vemos que en el primer caso (espacio de nombres HTML) la <strong><code>&lt;span&gt;</code></strong> es texto, el elemento <strong><code>span</code></strong> no se cre√≥.  En el segundo caso (espacio de nombres SVG), se cre√≥ un elemento basado en la etiqueta <strong><code>&lt;span&gt;</code></strong> .  Es decir, dependiendo del espacio de nombres, las etiquetas se comportan de manera diferente. </p><br><p>  Pero eso no es todo.  El pastel de esta "celebraci√≥n de la vida" es el hecho de que el tokenizador debe saber en qu√© espacio de nombres se encuentra la etapa de construcci√≥n del √°rbol.  Y esto es necesario √∫nicamente para manejar adecuadamente <strong><code>CDATA</code></strong> . </p><br><p>  Considere dos ejemplos con <strong><code>CDATA</code></strong> , dos espacios de nombres: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El resultado de construir un √°rbol: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El resultado de construir un √°rbol: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  En el primer caso (espacio de nombres HTML), el tokenizer tom√≥ <strong><code>CDATA</code></strong> para hacer comentarios.  En el segundo caso, el tokenizer desmont√≥ la estructura <strong><code>CDATA</code></strong> y recibi√≥ datos de ella.  En general, la regla es la siguiente: si nos encontramos con <strong><code>CDATA</code></strong> no en el espacio de nombres HTML, lo analizamos, de lo contrario lo consideramos como un comentario. </p><br><p>  Esta es la estrecha conexi√≥n entre el tokenizador y la construcci√≥n del √°rbol.  El tokenizador debe saber en qu√© espacio de nombres se encuentra actualmente la etapa de construcci√≥n del √°rbol, y la etapa de construcci√≥n del √°rbol puede cambiar el estado del tokenizador. </p><br><h3 id="tokeny">  Fichas </h3><br><p>  A continuaci√≥n, consideraremos los seis tipos de tokens creados por el tokenizador.  Vale la pena se√±alar que todos los tokens tienen datos preparados, es decir, ya procesados ‚Äã‚Äãy "listos para usar".  Esto significa que todas las referencias de caracteres con nombre, como <strong><code>&amp;copy</code></strong> , se convertir√°n en caracteres unicode. </p><br><h3 id="doctype-token">  Token DOCTYPE </h3><br><p>  El token DOCTYPE tiene su propia estructura, no similar a otras etiquetas.  El token contiene: </p><br><ol><li>  Nombre </li><li>  Identificador p√∫blico </li><li>  Identificador del sistema </li></ol><br><p>  En HTML moderno, el √∫nico DOCTYPE v√°lido / v√°lido deber√≠a tener este aspecto: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  Todos los dem√°s <strong><code>&lt;!DOCTYPE&gt;</code></strong> se considerar√°n un error de an√°lisis. </p><br><h3 id="start-tag-token">  Iniciar etiqueta token </h3><br><p>  La etiqueta de apertura puede contener: </p><br><ol><li>  Nombre de etiqueta </li><li>  Atributos </li><li>  Banderas </li></ol><br><p>  Por ejemplo, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  La etiqueta de apertura puede contener una bandera de <strong><code>self-closing</code></strong> .  Este indicador no afecta el cierre de la etiqueta, pero puede causar un error de an√°lisis para elementos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nulos</a> . </p><br><h3 id="end-tag-token">  Token de etiqueta final </h3><br><p>  Etiqueta de cierre  Tiene todas las propiedades del token de la etiqueta de apertura, pero tiene una barra diagonal <strong><code>/</code></strong> delante del nombre de la etiqueta. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  La etiqueta de cierre puede contener un indicador de <strong><code>self-closing</code></strong> que provocar√° un error de an√°lisis.  Adem√°s, el error de an√°lisis ser√° causado por los atributos de la etiqueta de cierre.  Se analizar√°n correctamente, pero se arrojar√°n en la etapa de construcci√≥n del √°rbol. </p><br><h3 id="comment-token">  Token de comentario </h3><br><p>  El token de comentario contiene todo el texto del comentario.  Es decir, se copia completamente de la transmisi√≥n al token. </p><br><p>  Ejemplo </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Ficha de personaje </h3><br><p>  Quiz√°s la ficha m√°s interesante.  S√≠mbolo de token Unicode.  Puede contener un (solo un) car√°cter. </p><br><p>  Se crear√° un token para cada car√°cter en HTML y se enviar√° a la etapa de construcci√≥n del √°rbol.  Esto es muy costoso. <br>  Veamos como funciona. </p><br><p>  Toma los datos HTML: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  ¬øQu√© piensas cu√°ntos tokens se crear√°n para este ejemplo?  Respuesta: 22. </p><br><p>  Considere la lista de tokens creados: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  No es reconfortante, ¬øverdad?  Pero, por supuesto, muchos creadores de analizadores HTML de hecho solo tienen un token durante el procesamiento.  Ejecutarlo en un c√≠rculo y sobrescribirlo con nuevos datos cada vez. </p><br><p>  Avancemos y respondamos la pregunta: ¬øpor qu√© se hace esto?  ¬øPor qu√© no tomar este texto en una sola pieza?  La respuesta est√° en la fase de construcci√≥n del √°rbol. </p><br><p>  Un tokenizer es in√∫til sin la etapa de construir un √°rbol HTML.  Es en la etapa de construcci√≥n de un √°rbol que el texto se pega con diferentes condiciones. </p><br><p>  Las condiciones son aproximadamente las siguientes: </p><br><ol><li>  Si llega un token de personaje con <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ), entonces causamos un error de an√°lisis e ignoramos el token. </li><li>  Si uno de los <strong><code>CHARACTER TABULATION</code></strong> <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> ) o <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) lleg√≥, llame al algoritmo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">restaurar los elementos de formato activos</a> y inserte la ficha en el √°rbol. </li></ol><br><p>  El token de s√≠mbolo se agrega al √°rbol de acuerdo con el algoritmo: </p><br><ol><li>  Si la posici√≥n de inserci√≥n actual no es un nodo de texto, cree un nodo de texto, ins√©rtelo en el √°rbol y agr√©guele datos del token. </li><li>  De lo contrario, agregue datos del token a un nodo de texto existente. </li></ol><br><p>  Este comportamiento crea muchos problemas.  La necesidad de que cada s√≠mbolo cree un token y lo env√≠e para su an√°lisis a la etapa de construcci√≥n de un √°rbol.  No conocemos el tama√±o del nodo de texto y tenemos que asignar una gran cantidad de memoria por adelantado o hacer enlaces.  Todo esto es extremadamente costoso de memoria o tiempo. </p><br><h3 id="end-of-file-token">  Token de fin de archivo </h3><br><p>  Token simple y claro.  Los datos han terminado. Perm√≠tanos informarle sobre esta etapa de la construcci√≥n de √°rboles. </p><br><h3 id="postroenie-dereva">  Construir un √°rbol </h3><br><p>  Tree building es una m√°quina <strong><code>23</code></strong> estados con <strong><code>23</code></strong> estados con muchas condiciones para tokens (etiquetas, texto).  La etapa de construcci√≥n de un √°rbol es la m√°s grande, ocupa una parte significativa de la especificaci√≥n y tambi√©n es capaz de causar irritaci√≥n y sue√±o let√°rgico. </p><br><p>  Todo est√° organizado de manera muy simple.  Los tokens se reciben en la entrada y, dependiendo del token, se cambia el estado de la construcci√≥n del √°rbol.  En la salida, tenemos un DOM real. </p><br><h2 id="problemy">  Problemas? </h2><br><p>  Los siguientes problemas parecen bastante obvios: </p><br><p>  <strong>Copia caracter por caracter</strong> </p><br><p>  Cada estado del tokenizador recibe un car√°cter en la entrada, que copia / convierte cuando sea necesario: nombres de etiquetas, atributos, comentarios, s√≠mbolos. </p><br><p>  Esto es muy derrochador tanto en la memoria como en el tiempo.  Nos vemos obligados a preasignar una cantidad desconocida de memoria para cada atributo, nombre de etiqueta, comentario, etc.  Y esto, en consecuencia, conduce a reinos, y los reinos conducen a tiempo perdido. </p><br><p>  Y si imagina que HTML contiene 1000 etiquetas, y cada etiqueta tiene al menos un atributo, entonces obtenemos un analizador infernalmente lento. </p><br><p>  <strong>Ficha de personaje</strong> </p><br><p>  El segundo problema es el token de personaje.  Resulta que creamos una ficha para cada s√≠mbolo y le damos para construir un √°rbol.  Construir un √°rbol no sabe cu√°ntos de estos tokens tendremos y no podemos asignar inmediatamente memoria para la cantidad requerida de caracteres.  En consecuencia, aqu√≠ todos los mismos realoks + constantes verifican la presencia de un nodo de texto en el estado actual del √°rbol. </p><br><p>  <strong>Sistema monol√≠tico</strong> </p><br><p>  El gran problema es la dependencia de todo en todo.  Es decir, el tokenizer depende del estado de construcci√≥n del √°rbol, y la construcci√≥n del √°rbol puede controlar el tokenizer.  Y todo tiene la culpa del espacio de nombres (espacios de nombres). </p><br><h2 id="kak-budem-reshat-problemy">  ¬øC√≥mo resolveremos los problemas? </h2><br><p>  A continuaci√≥n, describir√© la implementaci√≥n del analizador HTML en mi proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lexbor</a> , as√≠ como la soluci√≥n a todos los problemas expresados. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Pretratamiento </h3><br><p>  Eliminamos el procesamiento preliminar de datos.  Entrenaremos el tokenizador para comprender el retorno de carro ( <strong><code>\r</code></strong> ) como un car√°cter de espacio.  Por lo tanto, lo arrojar√°n a la etapa de construcci√≥n de un √°rbol donde lo resolveremos. </p><br><h3 id="tokeny-1">  Fichas </h3><br><p>  Con un movimiento de mu√±eca unificamos todas las fichas.  Tendremos una ficha para todo.  En general, solo habr√° un token en todo el proceso de an√°lisis. </p><br><p>  Nuestro token unificado contendr√° los siguientes campos: </p><br><ol><li>  ID de etiqueta </li><li>  Comenzar </li><li>  Fin </li><li>  Atributos </li><li>  Banderas </li></ol><br><h4 id="tag-id">  ID de etiqueta </h4><br><p>  No trabajaremos con la representaci√≥n textual del nombre de la etiqueta.  Traducimos todo a n√∫meros.  Los n√∫meros son f√°ciles de comparar, m√°s f√°ciles de trabajar. </p><br><p>  Creamos una tabla hash est√°tica a partir de todas las etiquetas conocidas.  Creamos enumeraci√≥n a partir de todas las etiquetas conocidas.  Es decir, debemos asignar r√≠gidamente un identificador a cada etiqueta.  En consecuencia, en la tabla hash, la clave es el nombre de la etiqueta y el valor se escribe desde la enumeraci√≥n. </p><br><p>  Por un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Como puede ver en el ejemplo, creamos etiquetas para el token <strong>END-OF-FILE</strong> , para texto, para un documento.  Todo esto en aras de una mayor comodidad.  Al abrir el tel√≥n, dir√© que en el nodo ( <strong><code>DOM Node Interface</code></strong> ) tendremos una <strong><code>Tag ID</code></strong> .  Esto se hace para no hacer dos comparaciones: en el tipo de nodo y en el elemento.  Es decir, si necesitamos un elemento <strong><code>DIV</code></strong> , entonces hacemos una comprobaci√≥n en el nodo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  Pero, por supuesto, puedes hacer esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  Se necesitan dos guiones bajos en <strong><code>LXB_TAG__</code></strong> para separar las etiquetas comunes de las del sistema.  En otras palabras, el usuario puede crear una etiqueta con el <strong><code>text</code></strong> del nombre o el <strong><code>end-of-file</code></strong> y si luego buscamos por nombre de etiqueta, no se producir√°n errores.  Todas las etiquetas del sistema comienzan con un <strong><code>#</code></strong> . </p><br><p>  Pero a√∫n as√≠, un nodo puede almacenar una representaci√≥n textual del nombre de la etiqueta.  Para 98.99999% de nodos, este par√°metro ser√° <strong><code>NULL</code></strong> .  En algunos espacios de nombres, necesitamos especificar un prefijo o nombre de etiqueta con un registro fijo.  Por ejemplo, <strong><code>baseProfile</code></strong> en el espacio de nombres SVG. </p><br><p>  La l√≥gica del trabajo es simple.  Si tenemos una etiqueta con un registro claramente definido, entonces: </p><br><ol><li>  Agr√©guelo a la base general de etiquetas en min√∫sculas.  Obtenga la identificaci√≥n de la etiqueta. </li><li>  Agregue el identificador de etiqueta y el nombre de etiqueta original en la representaci√≥n de texto al nodo. </li></ol><br><p>  <strong>Etiquetas personalizadas</strong> </p><br><p>  Un desarrollador puede crear cualquier etiqueta en HTML.  Como solo tenemos las etiquetas que conocemos en una tabla hash est√°tica y el usuario puede crearlas, necesitamos una tabla hash din√°mica. </p><br><p>  Todo se ve muy simple.  Cuando nos llegue la etiqueta, veremos si est√° en la tabla hash est√°tica.  Si no hay etiqueta, veamos la din√°mica, si no la hay, aumente el contador del identificador en uno y agregue la etiqueta a la tabla din√°mica. </p><br><p>  Todo lo descrito ocurre en la etapa del tokenizer.  Dentro del tokenizer y despu√©s de todas las comparaciones, vaya por <strong><code>Tag ID</code></strong> (con raras excepciones). </p><br><h4 id="begin-and-end">  Comienzo y fin </h4><br><p>  Ahora en el tokenizer no tendremos procesamiento de datos.  No copiaremos ni convertiremos nada.  Simplemente llevamos punteros al principio y al final de los datos. </p><br><p>  Todo el procesamiento de datos, como los enlaces simb√≥licos, se llevar√° a cabo en la etapa de construcci√≥n del √°rbol. <br>  Por lo tanto, sabremos el tama√±o de los datos para la asignaci√≥n posterior de memoria. </p><br><h4 id="attributes">  Atributos </h4><br><p>  Aqu√≠ todo es igual de simple.  No copiamos nada, simplemente guardamos punteros al principio / al final del nombre y los valores de los atributos.  Todas las transformaciones ocurren en el momento en que se construye el √°rbol. </p><br><h4 id="flags">  Banderas </h4><br><p>  Dado que tenemos tokens unificados, debemos informar de alguna manera al edificio del √°rbol sobre el tipo de token.  Para hacer esto, use el campo de mapa de bits de Banderas. </p><br><p>  El campo puede contener los siguientes valores: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  Adem√°s del tipo de token que se abre o cierra, hay valores para el convertidor de datos.  Solo el tokenizer sabe c√≥mo convertir correctamente los datos.  En consecuencia, el tokenizer marca en el token c√≥mo se deben procesar los datos. </p><br><h4 id="character-token-1">  Ficha de personaje </h4><br><p>  De lo descrito anteriormente, podemos concluir que el token del s√≠mbolo ha desaparecido de nosotros.  S√≠, ahora tenemos un nuevo tipo de token: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Ahora creamos un token para todo el texto entre las etiquetas, marcando c√≥mo se debe procesar en el futuro. </p><br><p>  Debido a esto, tendremos que cambiar las condiciones en la construcci√≥n del √°rbol.  Necesitamos entrenarlo para trabajar no con tokens simb√≥licos, sino con tokens de texto: convertir, eliminar caracteres innecesarios, omitir espacios, etc. </p><br><p>  Pero, no hay nada complicado.  En la etapa de construcci√≥n de un √°rbol, los cambios ser√°n m√≠nimos.  Pero el tokenizer ahora no coincide con la especificaci√≥n de la palabra en absoluto.  Pero no lo necesitamos, es normal.  Nuestra tarea es obtener un √°rbol HTML / DOM que cumpla totalmente con las especificaciones. </p><br><h3 id="stadii-tokenizatora">  Etapas Tokenizer </h3><br><p>  Para garantizar el procesamiento de datos a alta velocidad en el tokenizer, agregaremos nuestro iterador a cada etapa.  Seg√∫n la especificaci√≥n, cada etapa acepta un s√≠mbolo para nosotros y, dependiendo del s√≠mbolo que ha llegado, toma decisiones.  Pero, la verdad es que es muy caro. </p><br><p>  Por ejemplo, para pasar de la etapa <strong><code>ATTRIBUTE_NAME</code></strong> a la etapa <strong><code>ATTRIBUTE_VALUE</code></strong> necesitamos encontrar un espacio en blanco en el nombre del atributo, que indicar√° su finalizaci√≥n.  De acuerdo con la especificaci√≥n, debemos alimentar por car√°cter a la etapa <strong><code>ATTRIBUTE_NAME</code></strong> hasta que se <strong><code>ATTRIBUTE_NAME</code></strong> un car√°cter de espacio en blanco, y esta etapa no cambie a otra.  Esto es muy costoso, generalmente se implementa a trav√©s de una llamada de funci√≥n para cada car√°cter o devoluci√≥n de llamada como "tkz-&gt; next_code_point ()". </p><br><p>  Agregamos un bucle a la etapa <strong><code>ATTRIBUTE_NAME</code></strong> y pasamos todo el b√∫fer entrante.  En el ciclo, buscamos los s√≠mbolos que necesitamos cambiar y continuamos trabajando en la siguiente etapa.  Aqu√≠ obtenemos muchas ganancias, incluso optimizaciones del compilador. </p><br><p>  Pero!  Lo peor es que rompimos el soporte de trozos (trozos) fuera de la caja.  Gracias al procesamiento de caracteres por s√≠mbolo en cada etapa del tokenizer, ten√≠amos soporte para fragmentos, y ahora lo hemos roto. </p><br><p>  ¬øC√≥mo arreglarlo?  ¬øC√≥mo implementar soporte para trozos?  Es simple, presentamos el concepto de buffers entrantes (Buffer entrante). </p><br><h3 id="incoming-buffer">  Tamp√≥n entrante </h3><br><p>  A menudo, el HTML se analiza en fragmentos.  Por ejemplo, si recibimos datos a trav√©s de la red.  Para no permanecer inactivo mientras espera los datos restantes, podemos enviar los datos ya recibidos para su procesamiento / an√°lisis.  Naturalmente, los datos se pueden dividir en cualquier lugar.  Por ejemplo, tenemos dos buffers: </p><br><p>  <strong>Primero</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Segundo</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Dado que no copiamos nada en la etapa de tokenizaci√≥n, sino que solo llevamos punteros al principio y al final de los datos, tenemos un problema.  Punteros a diferentes buffers de usuario.  Y dado que los desarrolladores a menudo usan el mismo b√∫fer para los datos, estamos tratando con un puntero al comienzo de datos inexistentes. </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>    : </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p>  HTML  (   )    <strong><code>sarcasm</code></strong> .            . </p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p>   . </p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ÃÜ :  ,  N+  </li><li> ÃÜ     </li><li>      </li><li>    Ãà </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  C√≥digo fuente </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps">  PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p>    .  ,        . <br>      (      ).    . </p></div></div><br><p>  Gracias por su atencion! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430736/">https://habr.com/ru/post/es430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430724/index.html">DEFCON 21. La conferencia DNS puede ser peligrosa para su salud. Parte 1</a></li>
<li><a href="../es430728/index.html">Ens√©√±ame a dar retroalimentaci√≥n</a></li>
<li><a href="../es430730/index.html">Qu√© hace R&D ABBYY: Grupo de Investigaci√≥n Avanzada de PNL</a></li>
<li><a href="../es430732/index.html">A la cuesti√≥n de divisi√≥n y TI</a></li>
<li><a href="../es430734/index.html">Actualizaciones inteligentes vs contratos inteligentes</a></li>
<li><a href="../es430738/index.html">S√© un ninja de seguridad: nivel secreto</a></li>
<li><a href="../es430740/index.html">C√≥mo orde√±ar vacas con robots y hacer una startup industrial en √©l. Historia de desarrollo de R-SEPT</a></li>
<li><a href="../es430742/index.html">Olimpiada estudiantil "Soy un profesional": direcci√≥n "Programaci√≥n y tecnolog√≠a de la informaci√≥n"</a></li>
<li><a href="../es430746/index.html">¬øPor qu√© las bater√≠as de Tesla no funcionan en taxi a√©reo?</a></li>
<li><a href="../es430748/index.html">La lucha por los recursos, parte 6: cpuset o Sharing no siempre es correcto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>