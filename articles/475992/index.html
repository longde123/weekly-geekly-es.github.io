<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 👉🏾 🕺🏼 Escribir un complemento VLC para aprender inglés ⏏️ 🙏🏻 ◽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo hablaré sobre cómo escribir un complemento en C para el reproductor multimedia VLC. Escribí mi plugin para simplificar ver programas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir un complemento VLC para aprender inglés</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475992/"><img src="https://habrastorage.org/webt/nl/nj/r4/nlnjr4lpomher2u_r87vvsjeptc.png" alt="imagen"><br><br>  En este artículo hablaré sobre cómo escribir un complemento en C para el reproductor multimedia VLC.  Escribí mi plugin para simplificar ver programas de televisión y películas en inglés.  La idea de crear este complemento se describe en las secciones <b>Idea</b> y <b>Búsqueda de una solución</b> .  Los detalles técnicos de la implementación del complemento se proporcionan en las secciones de <b>implementación</b> y <b>complemento Hello World</b> .  Lo que sucedió al final y cómo usarlo se puede encontrar en la última sección, <b>Resultado</b> . <br><br>  El código fuente del proyecto está disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><a name="habracut"></a><br><h1>  Idea </h1><br>  La idea de aprender un idioma extranjero mientras veo mi serie favorita no es nueva, pero siempre he tenido problemas con ella personalmente.  Es muy difícil ver una serie o una película cuando no entiendes la mitad de lo que dicen.  Por supuesto, puede activar los subtítulos, pero si se encuentra una palabra o expresión desconocida en un discurso, no quedará más claro que el texto lo duplicará.  Y no me gustó ver la serie con subtítulos en ruso: el cerebro cambia a su idioma nativo y deja de percibir el habla extranjera.  Leí en alguna parte que primero necesitas ver una serie en ruso y luego en el original.  Pero este enfoque tampoco me convenía.  En primer lugar, dónde tomar tanto tiempo para mirar la misma cosa varias veces, y en segundo lugar, mirar la segunda vez ya no es tan interesante: se pierde la motivación. <br><br>  A pesar de todas las dificultades para ver programas de televisión extranjeros, puedo leer bastante bien la documentación técnica, artículos y libros en inglés.  Me gusta leer libros en el lector electrónico Kindle, ya que la función del diccionario es genial: puedes encontrar una traducción de una palabra desconocida con solo tocar la pantalla.  Es conveniente leer artículos y sitios en inglés instalando una extensión especial para la traducción en el navegador. Uso la extensión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.Translation</a> .  Este enfoque le permite leer y comprender textos en inglés, sin mucha distracción para la búsqueda de palabras desconocidas. <br><br>  Pensé, por qué no aplicar el mismo enfoque para ver programas de televisión: activamos la serie en inglés tan pronto como se encuentra una frase incomprensible, cambiamos a la pista de audio rusa y retrocedemos un poco.  A continuación, seguimos viendo la serie en inglés. <br><br><h1>  Busca una solución </h1><br>  De hecho, toda la funcionalidad que necesito ya está disponible en muchos reproductores multimedia populares.  Lo único que me gustaría cambiar la pista de audio y rebobinar el video hace unos segundos con el clic de un botón.  También sería genial si, después de traducir un fragmento incomprensible, el reproductor multimedia cambiara la pista de audio al inglés.  Bueno, sería bueno poder repetir el fragmento traducido previamente con la pista en inglés. <br><br>  Es decir, necesito un reproductor multimedia para el que pueda escribir complementos.  También es deseable que sea multiplataforma, ya que uso una PC con Windows y una computadora portátil con Linux.  Mi elección recayó inmediatamente en el VLC.  En habr incluso encontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo</a> en el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@Idunno</a> dice cómo escribir una extensión VLC en LUA.  Por cierto, también escribió esta extensión para aprender inglés) Desafortunadamente, esta extensión no funciona en las últimas versiones de VLC (anteriores a 2.0.5).  Debido a la operación inestable, la capacidad de agregar funciones de devolución de llamada a través de las cuales era posible procesar eventos de teclado en la extensión LUA se eliminó de la API LUA.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">README</a> , un enlace a la lista de correo de desarrolladores de VLC que discuten este problema lleva a su extensión en GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@Idunno</a> . <br><br>  Por lo tanto, para implementar mi idea, una extensión de LUA no funciona, necesita escribir un complemento en C. Y aunque escribí algo en C la última vez hace unos 7 años, de vuelta en la universidad, decidí probarlo. <br><br><h1>  Hola plugin mundial </h1><br>  Vale la pena señalar que el reproductor multimedia VLC tiene bastante buena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> .  Aprendí de él que el desarrollo de un reproductor multimedia utiliza un enfoque modular.  VLC consta de varios módulos independientes que implementan cierta funcionalidad, y el núcleo ( <b>libVLCCore</b> ), que administra estos módulos.  Hay dos tipos de módulos: internos ( <i>en árbol</i> ) y externos ( <i>fuera de árbol</i> ).  El código fuente de los módulos internos se almacena en un repositorio con el código del núcleo.  Los módulos externos se desarrollan y ensamblan independientemente del reproductor multimedia VLC.  En realidad, estos últimos son lo que se llaman complementos. <br><br>  La documentación también tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo</a> sobre cómo escribir su complemento (módulo) en C. Este artículo proporciona el código fuente de un complemento simple que, cuando se inicia VLC, muestra un mensaje de bienvenida " <i>Hola, &lt;nombre&gt;</i> " en la consola (se toma el valor &lt;nombre&gt; desde la configuración del complemento).  Corriendo un poco más adelante, diré que en el ejemplo anterior, agregue la siguiente línea después de <code>set_category(CAT_INTERFACE)</code> : <br><br><pre> <code class="cpp hljs">set_subcategory( SUBCAT_INTERFACE_CONTROL )</code> </pre> <br>  Bueno, todo lo que queda es ensamblar el complemento y probar su funcionamiento.  También hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instrucción para</a> construir un complemento externo.  Aquí vale la pena prestar atención a la sección de <b>Internacionalización</b> , que describe cómo funciona la localización en VLC.  En resumen, para complementos externos necesita definir macros <code>N_()</code> , <code>_()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOMAIN </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vlc-myplugin"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _(str) dgettext(DOMAIN, str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_(str) (str)</span></span></code> </pre> <br>  Para el ensamblaje, se propone utilizar el viejo Makefile o Autotools.  Decidí seguir el camino simple y elegí el Makefile.  En el Makefile, debe recordar definir la variable <b><code>MODULE_STRING</code></b> : este es el identificador de nuestro complemento.  También modifiqué un poco el trabajo con directorios, ahora se definen a través de <i>pkg-config</i> .  El resultado son los siguientes archivos: <br><br><div class="spoiler">  <b class="spoiler_title">hola.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @file hello.c * @brief Hello world interface VLC module example */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_CONFIG_H # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOMAIN </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vlc-myplugin"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _(str) dgettext(DOMAIN, str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_(str) (str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; /* VLC core API headers */ #include &lt;vlc_common.h&gt; #include &lt;vlc_plugin.h&gt; #include &lt;vlc_interface.h&gt; /* Forward declarations */ static int Open(vlc_object_t *); static void Close(vlc_object_t *); /* Module descriptor */ vlc_module_begin() set_shortname(N_("Hello")) set_description(N_("Hello interface")) set_capability("interface", 0) set_callbacks(Open, Close) set_category(CAT_INTERFACE) set_subcategory( SUBCAT_INTERFACE_CONTROL ) add_string("hello-who", "world", "Target", "Whom to say hello to.", false) vlc_module_end () /* Internal state for an instance of the module */ struct intf_sys_t { char *who; }; /** * Starts our example interface. */ static int Open(vlc_object_t *obj) { intf_thread_t *intf = (intf_thread_t *)obj; /* Allocate internal state */ intf_sys_t *sys = malloc(sizeof (*sys)); if (unlikely(sys == NULL)) return VLC_ENOMEM; intf-&gt;p_sys = sys; /* Read settings */ char *who = var_InheritString(intf, "hello-who"); if (who == NULL) { msg_Err(intf, "Nobody to say hello to!"); goto error; } sys-&gt;who = who; msg_Info(intf, "Hello %s!", who); return VLC_SUCCESS; error: free(sys); return VLC_EGENERIC; } /** * Stops the interface. */ static void Close(vlc_object_t *obj) { intf_thread_t *intf = (intf_thread_t *)obj; intf_sys_t *sys = intf-&gt;p_sys; msg_Info(intf, "Good bye %s!", sys-&gt;who); /* Free internal state */ free(sys-&gt;who); free(sys); }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">LD</span></span> = ld <span class="hljs-type"><span class="hljs-type">CC</span></span> = cc <span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span> = pkg-config <span class="hljs-type"><span class="hljs-type">INSTALL</span></span> = install <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> = -g -<span class="hljs-type"><span class="hljs-type">O2</span></span> -<span class="hljs-type"><span class="hljs-type">Wall</span></span> -<span class="hljs-type"><span class="hljs-type">Wextra</span></span> <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> = <span class="hljs-type"><span class="hljs-type">LIBS</span></span> = <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --cflags vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --libs vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --variable=pluginsdir vlc-plugin) plugindir = <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span>)/misc override <span class="hljs-type"><span class="hljs-type">CC</span></span> += -std=gnu99 override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DPIC</span></span> -<span class="hljs-type"><span class="hljs-type">I</span></span>. -<span class="hljs-type"><span class="hljs-type">Isrc</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += -fPIC override <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">Wl</span></span>,-no-undefined,-z,defs override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DMODULE_STRING</span></span>=\<span class="hljs-comment"><span class="hljs-comment">"hello\"</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span>) override <span class="hljs-type"><span class="hljs-type">LIBS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span>) all: libhello_plugin.so install: all mkdir -p -- <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">INSTALL</span></span>) --mode <span class="hljs-number"><span class="hljs-number">0755</span></span> libhello_plugin.so <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) install-strip: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">MAKE</span></span>) install <span class="hljs-type"><span class="hljs-type">INSTALL</span></span>=<span class="hljs-comment"><span class="hljs-comment">"$(INSTALL) -s"</span></span> uninstall: rm -f <span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir)/libhello_plugin.so clean: rm -f -- libhello_plugin.so src/*.o mostlyclean: clean <span class="hljs-type"><span class="hljs-type">SOURCES</span></span> = hello.c <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.c) libhello_plugin.so: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">CC</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span>) -shared -o <span class="hljs-string"><span class="hljs-string">$@</span></span> <span class="hljs-string"><span class="hljs-string">$^</span></span> <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LIBS</span></span>) .<span class="hljs-type"><span class="hljs-type">PHONY</span></span>: all install install-strip uninstall clean mostlyclean</code> </pre></div></div><br>  La forma más fácil de construir un complemento para Linux.  Para hacer esto, debe instalar, de hecho, el reproductor multimedia VLC, así como los archivos y herramientas necesarios para compilar el complemento.  En Debian / Ubuntu, esto se puede hacer con el siguiente comando: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc libvlc-dev libvlccore-dev gcc make pkg-config</code> </pre> <br>  En realidad, todo está listo, recopilamos e instalamos nuestro complemento usando el comando: <br><br><pre> <code class="bash hljs">sudo make install</code> </pre> <br>  Para probar el complemento, ejecute VLC también desde la consola: <br><br><pre> <code class="bash hljs">vlc</code> </pre> <br>  Desafortunadamente, no vimos ningún " <i>Hola mundo</i> ".  La cuestión es que el complemento primero debe estar habilitado.  Para hacer esto, abra la configuración ( <b>Herramientas</b> &gt; <b>Preferencias</b> ), cambie a la vista avanzada (seleccione <b>Todo</b> en el grupo <b>Mostrar configuración</b> ) y busque en el árbol en el panel izquierdo <b>Interfaz</b> &gt; <b>Interfaces de</b> <b>control</b> - marque la casilla junto a nuestro complemento de <b>interfaz Hello</b> . <br><br> <a href=""><img src="https://habrastorage.org/webt/fi/wr/ey/fiwreyqdhfd4ncbgzc2g8z1z3y8.png"></a> <br><br>  Guardamos la configuración y reiniciamos el VLC. <br><br> <a href=""><img src="https://habrastorage.org/webt/g3/-n/h3/g3-nh3qc7k37kzwpbfywtow8msa.png"></a> <br><br><h1>  Crea un complemento para Windows </h1><br>  Con Windows, las cosas son un poco más complicadas.  Para compilar el complemento, debe descargar sdk, que contiene bibliotecas, encabezados y archivos de configuración de VLC.  Anteriormente, SDK era parte del ensamblaje VLC normal y se podía encontrar en la carpeta de instalación del programa.  Ahora viene como un ensamblaje de reproductor multimedia separado.  Por ejemplo, para VLC versión 3.0.8, este ensamblaje se puede descargar en <a href="">ftp://ftp.videolan.org/pub/videolan/vlc/3.0.8/win64/vlc-3.0.8-win64.7z</a> (es importante descargar 7z -archivo). <br><br>  Copie el contenido del archivo en una carpeta, por ejemplo, en <i>C: \ Proyectos</i> .  Además de SDK, el archivo también contiene el propio reproductor multimedia, que se puede utilizar para probar y depurar el complemento. <br><br>  Para que nuestro Makefile se pueda usar para compilar e instalar el complemento, debe corregir el archivo <i>C: \ Projects \ vlc-3.0.8 \ sdk \ lib \ pkgconfig \ vlc-plugin.pc</i> , que indica la ruta correcta a la carpeta <b>sdk</b> en las variables <b>prefijo</b> y <b>pluginsdir</b> y <b>complementos</b> respectivamente: <br><br><pre> <code class="bash hljs">prefix=/c/Projects/vlc-3.0.8/sdk pluginsdir=/c/Projects/vlc-3.0.8/plugins</code> </pre> <br>  Para compilar en Windows, también necesitamos instalar un compilador y otras utilidades.  Todo el software necesario se puede obtener instalando el entorno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSYS2</a> .  El sitio web del proyecto tiene instrucciones detalladas de instalación.  En resumen, inmediatamente después de la instalación, debe abrir la consola ( <i>C: \ msys64 \ msys2.exe</i> ) y actualizar los paquetes MSYS2 con el comando: <br><br><pre> <code class="bash hljs">pacman -Syu</code> </pre> <br>  A continuación, cierre la ventana del terminal MSYS2, luego ábrala nuevamente y ejecute el comando <br><br><pre> <code class="bash hljs">pacman -Su</code> </pre> <br>  Después de actualizar todos los paquetes, debe instalar la cadena de herramientas: <br><br><pre> <code class="bash hljs">pacman -S base-devel mingw-w64-x86_64-toolchain</code> </pre> <br>  Ahora que todos los paquetes necesarios están instalados, puede comenzar a compilar el complemento.  Modifiqué un poco el Makefile para que pudiera compilar el complemento tanto en Linux como en Windows.  Además, tuve que eliminar algunos parámetros de compilación MinGW no compatibles, como resultado, el Makefile comenzó a verse así: <br><br><div class="spoiler">  <b class="spoiler_title">Makefile para Windows</b> <div class="spoiler_text"><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">LD</span></span> = ld <span class="hljs-type"><span class="hljs-type">CC</span></span> = cc <span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span> = pkg-config <span class="hljs-type"><span class="hljs-type">INSTALL</span></span> = install <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> = -g -<span class="hljs-type"><span class="hljs-type">O2</span></span> -<span class="hljs-type"><span class="hljs-type">Wall</span></span> -<span class="hljs-type"><span class="hljs-type">Wextra</span></span> <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> = <span class="hljs-type"><span class="hljs-type">LIBS</span></span> = <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --cflags vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --libs vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --variable=pluginsdir vlc-plugin) plugindir = <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span>)/misc override <span class="hljs-type"><span class="hljs-type">CC</span></span> += -std=gnu99 override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DPIC</span></span> -<span class="hljs-type"><span class="hljs-type">I</span></span>. -<span class="hljs-type"><span class="hljs-type">Isrc</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += -fPIC override <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">Wl</span></span>,-no-undefined override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DMODULE_STRING</span></span>=\<span class="hljs-comment"><span class="hljs-comment">"hello\"</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span>) override <span class="hljs-type"><span class="hljs-type">LIBS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span>) <span class="hljs-type"><span class="hljs-type">SUFFIX</span></span> := so ifeq (<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">OS</span></span>),<span class="hljs-type"><span class="hljs-type">Windows_NT</span></span>) <span class="hljs-type"><span class="hljs-type">SUFFIX</span></span> := dll endif all: libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) install: all mkdir -p -- <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">INSTALL</span></span>) --mode <span class="hljs-number"><span class="hljs-number">0755</span></span> libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) install-strip: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">MAKE</span></span>) install <span class="hljs-type"><span class="hljs-type">INSTALL</span></span>=<span class="hljs-comment"><span class="hljs-comment">"$(INSTALL) -s"</span></span> uninstall: rm -f <span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir)/libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) clean: rm -f -- libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) src/*.o mostlyclean: clean <span class="hljs-type"><span class="hljs-type">SOURCES</span></span> = hello.c <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.c) libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">CC</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span>) -shared -o <span class="hljs-string"><span class="hljs-string">$@</span></span> <span class="hljs-string"><span class="hljs-string">$^</span></span> <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LIBS</span></span>) .<span class="hljs-type"><span class="hljs-type">PHONY</span></span>: all install install-strip uninstall clean mostlyclean</code> </pre></div></div><br>  Dado que MSYS2 no sabe nada acerca de nuestro SDK para VLC, debe agregar la ruta a la carpeta <b>pkgconfig</b> desde este SDK a la <b>variable de</b> entorno <b>PKG_CONFIG_PATH</b> .  Abra la consola MinGW ( <i>C: \ msys64 \ mingw64.exec</i> ) y ejecute los comandos: <br><br><pre> <code class="plaintext hljs">export PKG_CONFIG_PATH=/c/projects/vlc-3.0.8/sdk/lib/pkgconfig:$PKG_CONFIG_PATH make install</code> </pre> <br>  Para probar el complemento, ejecute VLC también desde la consola: <br><br><pre> <code class="plaintext hljs">/c/projects/vlc-3.0.8/vlc</code> </pre> <br>  Como en el caso de Linux, vaya a la configuración y active nuestro complemento.  Guardamos la configuración y reiniciamos el VLC. <br><br><h1>  Implementación de complementos </h1><br>  Para implementar mi complemento, necesitaba entender cómo controlar el reproductor multimedia (cambiar la pista de audio, rebobinar) y cómo manejar los eventos de pulsación de teclas.  Para entender todo esto, recurrí a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> .  También en Internet encontré un par de artículos interesantes que arrojan luz sobre la arquitectura del reproductor multimedia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20141204234622/">la arquitectura del marco</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multimedia VLC</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación API del reproductor multimedia VLC</a> . <br><br>  VLC consta de una gran cantidad de módulos independientes (más de 400).  Cada módulo debe proporcionar información sobre el tipo de funcionalidad que implementa, así como las funciones de inicialización / finalización.  Esta información se describe en el <b>bloque vlc_module_begin ()</b> - <b>vlc_module_end ()</b> utilizando las <b>macros set_capability ()</b> y <b>set_callbacks ()</b> .  Las funciones de inicialización / finalización del módulo (generalmente llamadas <b>Abrir</b> y <b>Cerrar</b> ) tienen la siguiente firma: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span></code> </pre> <br>  <b>vlc_object_t</b> es el tipo base para representar datos en VLC, del cual se heredan todos los demás (vea el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object_Management</a> ).  Un puntero a <b>vlc_object_t</b> debe convertirse a un tipo de datos específico de acuerdo con la funcionalidad que implementa el módulo.  Para controlar el reproductor multimedia, <b>configuro el</b> valor de <b>la</b> <b><i>interfaz</i></b> en la macro <b>set_capability ()</b> .  En consecuencia, en las funciones <b>Abrir</b> y <b>Cerrar</b> , necesito <b>enviar vlc_object_t</b> a <b>intf_thread_t</b> . <br><br>  La interacción entre los módulos se basa en el patrón de diseño del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">observador</a> .  VLC proporciona un mecanismo de <i>"variables de objeto"</i> (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Variables</a> ), con el que puede agregar variables a instancias de tipo <b>vlc_object_t</b> (y sus derivados).  Los módulos pueden intercambiar datos a través de estas variables.  También puede adjuntar una función de devolución de llamada a la variable, que se llamará cuando cambie el valor de esta variable. <br><br>  Como ejemplo, considere el módulo de teclas de <b>acceso rápido</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modules / control / hotkeys.c</a> ), que es responsable de manejar los eventos de teclas de <b>acceso</b> rápido.  En la función Open, la función de devolución de llamada <b>ActionEvent</b> se cuelga en la <b>variable</b> <b>clave-acción</b> : <br><br><pre> <code class="cpp hljs">var_AddCallback( p_intf-&gt;obj.libvlc, <span class="hljs-string"><span class="hljs-string">"key-action"</span></span>, ActionEvent, p_intf );</code> </pre> <br>  Un puntero a <b>vlc_object_t</b> , un nombre de variable, una función de devolución de llamada y un puntero a anular se pasan a la función <b>var_AddCallback</b> para pasar datos arbitrarios, que luego se reenvían a la función de devolución de llamada especificada.  La firma de la función de devolución de llamada se muestra a continuación. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span></code> </pre> <br>  Un puntero a <b>vlc_object_t</b> , el nombre de la variable, los valores antiguos y nuevos de esta variable (en este caso, el identificador de la combinación de teclas de acceso rápido presionadas correspondiente de la acción), así como el puntero a cualquier dato adicional especificado al agregar la función de devolución de llamada, se pasan a la función de devolución de llamada . <br><br>  El procesamiento directo de eventos de teclas de <b>acceso</b> rápido se realiza en la función <b>PutAction</b> , que se llama dentro de la función de devolución de llamada de <b>ActionEvent</b> .  La función <b>PutAction</b> acepta un identificador de un evento de presionar una combinación de teclas de acceso rápido ( <b>i_action</b> ) y, con la ayuda del operador del interruptor, realiza las acciones correspondientes. <br><br>  Por ejemplo, un evento de rebobinado corresponde a <b><code>ACTIONID_JUMP_BACKWARD_SHORT</code></b> .  Para realizar la acción correspondiente, el intervalo de rebobinado se toma de la configuración de VLC (de la variable <b>tamaño de salto corto</b> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mtime_t</span></span> it = var_InheritInteger( p_input, varname );</code> </pre> <br>  Para rebobinar el archivo que se está reproduciendo, simplemente configure la variable de <b>desplazamiento de tiempo</b> en el valor correspondiente al tiempo (en microsegundos) por el que desea cambiar la reproducción: <br><br><pre> <code class="cpp hljs">var_SetInteger( p_input, <span class="hljs-string"><span class="hljs-string">"time-offset"</span></span>, it * sign * CLOCK_FREQ );</code> </pre> <br>  Para el avance rápido, debe especificar un valor positivo, para el retroceso rápido: negativo.  La <b>constante CLOCK_FREQ se</b> usa para convertir segundos a microsegundos. <br><br>  Del mismo modo, la pista de audio cambia (evento <b><code>ACTIONID_AUDIO_TRACK</code></b> ).  Solo la variable <b>audio-es</b> responsable de la pista de audio puede aceptar un conjunto limitado de valores (de acuerdo con las pistas de audio disponibles en el archivo que se está reproduciendo).  Puede obtener una lista de posibles valores de una variable utilizando la función <b>var_Change ()</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">vlc_value_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, list2; var_Change( p_input, <span class="hljs-string"><span class="hljs-string">"audio-es"</span></span>, VLC_VAR_GETCHOICES, &amp;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, &amp;list2 );</code> </pre> <br>  Además de la lista de valores, esta función también le permite obtener una lista de descripciones de estos valores (en este caso, el nombre de las pistas de audio).  Ahora podemos cambiar la pista de audio usando la función <b>var_Set ()</b> : <br><br><pre> <code class="cpp hljs">var_Set( p_input, <span class="hljs-string"><span class="hljs-string">"audio-es"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.p_list-&gt;p_values[i] );</code> </pre> <br>  Cómo administrar el reproductor multimedia descubierto, queda por aprender cómo manejar los eventos del teclado.  Lamentablemente, no pude agregar una nueva tecla de acceso rápido.  Todas las teclas de acceso rápido están codificadas en el código del núcleo VLC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">src / misc / actions.c</a> ).  Por lo tanto, agregué un controlador para los eventos de pulsación de teclas del teclado de nivel inferior, colgando mi función de devolución de llamada para cambiar la variable <b>presionada por</b> la <b>tecla</b> : <br><br><pre> <code class="cpp hljs">var_AddCallback( p_intf-&gt;obj.libvlc, <span class="hljs-string"><span class="hljs-string">"key-pressed"</span></span>, KeyboardEvent, p_intf );</code> </pre> <br>  La variable <b>presionada la tecla</b> almacena el código de caracteres (en Unicode) correspondiente a la última tecla presionada.  Por ejemplo, cuando presiona la tecla con el número <b>"1"</b> , a la variable <b>presionada</b> se le asignará el valor <b><i>49</i></b> (0x00000031 en el sistema de número 16).  Puede ver otros códigos de caracteres en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unicode-table.com</a> .  Además, el valor de la variable <b>presionada por</b> la <b>tecla</b> tiene en cuenta la presión de las teclas modificadoras, el cuarto byte significativo se les asigna.  Entonces, por ejemplo, cuando presiona la <b>combinación de teclas</b> " <b>Ctrl + 1</b> ", a la variable <b>presionada</b> se le asignará el valor 0x <b>04</b> 000031 (00000 <b>1</b> 00 00000000 00000000 00110001 <sub>2</sub> ).  Para mayor claridad, la siguiente tabla muestra los significados de varias combinaciones de teclas: <br><div class="scrollable-table"><table><tbody><tr><th>  Atajo de teclado </th><th>  Valor </th></tr><tr><td>  Ctrl + 1 </td><td>  00000 <b>1</b> 00 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Alt + 1 </td><td>  0000000 <b>1</b> 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Ctrl + Alt + 1 </td><td>  00000 <b>1</b> 0 <b>1</b> 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Shift + 1 </td><td>  000000 <b>1</b> 0 00000000 00000000 <b>00100001</b> <sub>2</sub> </td></tr></tbody></table></div>  Preste atención al valor al presionar la combinación " <b>Shift + 1</b> ".  Ya que en este caso el " <b>!</b>  ", Entonces el valor del primer byte corresponderá al código de este carácter en Unicode (0x00000021). <br><br><h1>  Resultado </h1><br>  Llamé a mi complemento <b>TIP</b> un acrónimo de la frase "traducirlo, por favor", también la punta se puede traducir como "pista".  El código fuente del complemento se publica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> , donde también puede descargar ensamblajes de complementos listos para Windows y Linux. <br><br>  Para instalar el complemento, debe copiar el archivo <b>libtip_plugin.dll</b> (libtip_plugin.so para Linux) en la carpeta <i>&lt;path-to-vlc&gt; / plugins</i> .  En Windows, VLC generalmente se instala en la carpeta <i>C: \ Archivos de programa \ VideoLAN \ VLC</i> .  En Linux, puede encontrar la carpeta de instalación con el comando: <br><br><pre> <code class="plaintext hljs">whereis vlc</code> </pre> <br>  En Ubuntu, por ejemplo, VLC está instalado en <i>/ usr / lib / x86_64-linux-gnu / vlc</i> . <br><br>  A continuación, deberá reiniciar VLC, luego en el menú principal abra <b>Herramientas</b> &gt; <b>Preferencias</b> , cambie a la vista avanzada (seleccione <b>Todo</b> en el grupo <b>Mostrar configuración</b> ), en el panel izquierdo vaya a la sección <b>Interfaz</b> &gt; <b>Control</b> y marque la casilla junto a <b>CONSEJO (traduzca, por favor)</b> .  Por otra parte, deberá reiniciar el VLC. <br><br> <a href=""><img src="https://habrastorage.org/webt/df/06/qk/df06qkcl2vbiatwq7j_8uw4m_ey.png"></a> <br><br>  En la configuración del complemento, puede especificar los números de las pistas de audio principal y auxiliar (para traducción), así como el tiempo (en segundos) por el cual el complemento se rebobinará para repetir con la pista de audio auxiliar. <br><br> <a href=""><img src="https://habrastorage.org/webt/mv/9-/vu/mv9-vuo9mfzicqyiqpsopnevrpu.png"></a> <br><br>  Para controlar el complemento, agregué los siguientes métodos abreviados de teclado: <br><br><ul><li>  " <b>/</b> " Para traducción </li><li>  " <b>Shift + /</b> " para repetir el fragmento de video traducido previamente con la pista de audio principal </li></ul><br>  Durante la ejecución de los comandos de traducción y reintento, el complemento muestra los mensajes <i>"CONSEJO: traducir"</i> y <i>"CONSEJO: repetir"</i> en la esquina superior izquierda <i>,</i> respectivamente. <br><br><img src="https://habrastorage.org/webt/4z/bu/1p/4zbu1p5mwskebq8vpbiny_oayr4.png"><br><br>  Desde mi experiencia con el complemento, puedo decir que, en general, estoy satisfecho con el resultado.  Lo principal es elegir el contenido correcto, si se entiende al menos la mitad del discurso extranjero utilizado allí, el complemento ayudará a traducir el resto.  De lo contrario, el complemento probablemente será inútil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/475992/">https://habr.com/ru/post/475992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../475980/index.html">Baja conectividad, arquitectura y organización del equipo.</a></li>
<li><a href="../475982/index.html">Como aprender un idioma extranjero</a></li>
<li><a href="../475986/index.html">Descripción general del lector PocketBook 740 Pro: 7.8 pulgadas, audio y protección IPX8</a></li>
<li><a href="../475988/index.html">Actualizaciones de ML.NET Model Builder</a></li>
<li><a href="../475990/index.html">Creación de aplicaciones modernas en la nube con Pulumi y .NET Core</a></li>
<li><a href="../475994/index.html">Consejos y trucos geniales de WSL (subsistema de Windows para Linux)</a></li>
<li><a href="../475996/index.html">Agregar cuarzo a la bota de primavera</a></li>
<li><a href="../475998/index.html">Aplicación de RPA en cálculos científicos y de ingeniería.</a></li>
<li><a href="../476000/index.html">Actualizaciones de ML.NET Model Builder</a></li>
<li><a href="../476002/index.html">Experiencia en encontrar un puesto de estudiante de doctorado en Alemania</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>