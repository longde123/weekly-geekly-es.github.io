<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù§Ô∏è üë©‚Äç‚öïÔ∏è üìï Yang Anda butuhkan hanyalah URL üë∞üèæ üåç üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengguna VKontakte bertukar 10 miliar pesan setiap hari. Mereka saling mengirim foto, komik, meme, dan lampiran lainnya. Kami akan memberi tahu Anda c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yang Anda butuhkan hanyalah URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="gambar"></div><br>  Pengguna VKontakte bertukar 10 miliar pesan setiap hari.  Mereka saling mengirim foto, komik, meme, dan lampiran lainnya.  Kami akan memberi tahu Anda cara kami membuat aplikasi iOS untuk mengunggah gambar menggunakan <b><code>URLProtocol</code></b> , dan langkah demi langkah kami akan mencari tahu bagaimana menerapkannya sendiri. <br><a name="habracut"></a><br>  Sekitar satu setengah tahun yang lalu, pengembangan bagian pesan baru dalam aplikasi VK untuk iOS sedang berjalan lancar.  Ini adalah bagian pertama yang seluruhnya ditulis dalam Swift.  Itu terletak di modul terpisah <code>vkm</code> (Pesan VK), yang tidak tahu apa-apa tentang perangkat aplikasi utama.  Ia bahkan dapat dijalankan dalam proyek terpisah - fungsionalitas dasar membaca dan mengirim pesan akan terus berfungsi.  Dalam aplikasi utama, pengontrol pesan ditambahkan melalui Pengontrol Tampilan Kontainer yang sesuai untuk ditampilkan, misalnya, daftar percakapan atau pesan dalam percakapan. <br><br>  Pesan adalah salah satu bagian paling populer dari aplikasi seluler VKontakte, jadi penting agar ia berfungsi seperti jam.  Dalam proyek <code>messages</code> , kami berjuang untuk setiap baris kode.  Kami selalu sangat menyukai betapa rapi pesan-pesan tersebut dibangun ke dalam aplikasi, dan kami berusaha untuk memastikan bahwa semuanya tetap sama. <br><br>  Secara bertahap mengisi bagian dengan fungsi-fungsi baru, kami mendekati tugas berikut: kami harus memastikan bahwa foto yang dilampirkan ke pesan pertama kali ditampilkan dalam konsep, dan setelah mengirimnya, dalam daftar umum pesan.  Kami hanya bisa menambahkan modul untuk bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PHImageManager</code></a> , tetapi kondisi tambahan membuat tugas lebih sulit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="gambar"></div><br><br>  Saat memilih foto, pengguna dapat memprosesnya: menerapkan filter, memutar, memotong, dll. Dalam aplikasi VK, fungsi tersebut diimplementasikan dalam komponen <code>AssetService</code> terpisah.  Sekarang perlu belajar untuk bekerja dengannya dari proyek pesan. <br><br><blockquote>  Nah, tugasnya cukup sederhana, kami akan melakukannya.  Ini kira-kira solusi rata-rata, karena ada banyak variasi.  Kami mengambil protokol, membuangnya dalam pesan dan mulai mengisinya dengan metode.  Kami menambah AssetService, mengadaptasi protokol dan menambahkan implementasi cache kami!  untuk viskositas.  Kemudian kami menempatkan implementasi dalam pesan, menambahkannya ke beberapa layanan atau manajer yang akan bekerja dengan semua ini, dan mulai menggunakannya.  Pada saat yang sama, seorang pengembang baru masih datang dan, sambil mencoba mencari tahu semuanya, ia mengutuk dengan berbisik ... (yah, Anda mengerti).  Pada saat bersamaan, keringat muncul di dahinya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="gambar"></div><br></blockquote><br>  Keputusan ini <i>tidak sesuai dengan keinginan kita</i> .  Entitas baru muncul yang perlu diketahui komponen pesan saat bekerja dengan gambar dari <code>AssetService</code> .  Pengembang juga perlu melakukan pekerjaan ekstra untuk mengetahui cara kerja sistem ini.  Akhirnya, ada tautan implisit tambahan ke komponen proyek utama, yang kami coba hindari sehingga bagian pesan terus berfungsi sebagai modul independen. <br><br>  Saya ingin menyelesaikan masalah sehingga proyek tidak tahu sama sekali tentang jenis gambar apa yang dipilih, bagaimana cara menyimpannya, apakah itu perlu memuat dan merender khusus.  Selain itu, kami sudah memiliki kemampuan untuk mengunduh gambar konvensional dari Internet, hanya saja mereka tidak diunduh melalui layanan tambahan, tetapi hanya dengan <code>URL</code> .  Dan, pada kenyataannya, tidak ada perbedaan antara kedua jenis gambar.  Hanya beberapa yang disimpan secara lokal, sementara yang lain disimpan di server. <br><br>  Jadi kami datang dengan ide yang sangat sederhana: bagaimana jika aset lokal juga dapat dipelajari untuk memuat melalui <code>URL</code> ?  Tampaknya dengan satu klik jari <s>Thanos</s> , itu akan menyelesaikan semua masalah kami: Anda tidak perlu tahu apa-apa tentang <code>AssetService</code> , menambahkan tipe data baru dan menambah entropi dengan sia-sia, belajar memuat jenis gambar baru, berhati-hati dalam menyimpan data caching.  Kedengarannya seperti rencana. <br><br><h2>  Yang kita butuhkan hanyalah URL </h2><br>  Kami mempertimbangkan gagasan ini dan memutuskan untuk menentukan format <code>URL</code> yang akan kami gunakan untuk memuat aset lokal: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Kami akan menggunakan nilai properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>localIdentifier</code></a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>localIdentifier</code></a> sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PHObject</code></a> , dan kami akan melewati parameter <code>width</code> dan <code>height</code> untuk memuat gambar dari ukuran yang diinginkan.  Kami juga menambahkan beberapa parameter lagi seperti <code>crop</code> , <code>filter</code> , <code>rotate</code> , yang akan memungkinkan Anda untuk bekerja dengan informasi dari gambar yang diproses. <br><br>  Untuk menangani <code>URL</code> ini <code>URL</code> kami akan membuat <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Tugasnya adalah memuat gambar melalui <code>AssetService</code> dan mengembalikan kembali data yang sudah siap digunakan. <br><br>  Semua ini akan memungkinkan kami untuk mendelegasikan hampir sepenuhnya pekerjaan protokol <code>URL Loading System</code> dan <code>URL Loading System</code> . <br><br>  Di dalam pesan itu akan memungkinkan untuk beroperasi dengan <code>URL</code> paling umum, hanya dalam format yang berbeda.  Ini juga akan mungkin untuk menggunakan kembali mekanisme yang ada untuk memuat gambar, sangat sederhana untuk membuat serial dalam database, dan mengimplementasikan caching data melalui <code>URLCache</code> standar. <br><br>  Apakah itu berhasil?  Jika, membaca artikel ini, Anda dapat melampirkan foto dari galeri ke pesan di aplikasi VKontakte, maka ya :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="gambar"></div><br>  Untuk memperjelas cara menerapkan <code>URLProtocol</code> Anda, saya mengusulkan untuk mempertimbangkan ini dengan sebuah contoh. <br><br>  Kami menetapkan sendiri tugas: untuk mengimplementasikan aplikasi sederhana dengan daftar di mana Anda perlu menampilkan daftar foto snapshot pada koordinat yang diberikan.  Untuk mengunduh snapshots, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MKMapSnapshotter</code></a> standar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MapKit</code></a> , dan kami akan memuat data melalui <code>URLProtocol</code> kustom.  Hasilnya mungkin terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="gambar"></div><br>  Pertama, kami menerapkan mekanisme untuk memuat data dengan <code>URL</code> .  Untuk menampilkan snapshot peta, kita perlu mengetahui koordinat titik - garis lintang dan garis bujur ( <code>latitude</code> , <code>longitude</code> ).  Tetapkan format <code>URL</code> khusus tempat kami ingin memuat informasi: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Sekarang kami menerapkan <code>URLProtocol</code> , yang akan memproses tautan tersebut dan menghasilkan hasil yang diinginkan.  Mari kita membuat kelas <code>MapURLProtocol</code> , yang akan kita warisi dari kelas dasar <code>URLProtocol</code> .  Terlepas dari namanya, <code>URLProtocol</code> adalah kelas abstrak.  Jangan malu, di sini kami menggunakan konsep lain - <code>URLProtocol</code> mewakili protokol <code>URL</code> dengan tepat dan tidak ada hubungannya dengan ketentuan OOP.  Jadi <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Sekarang kami mendefinisikan kembali beberapa metode yang diperlukan yang tanpanya protokol <code>URL</code> tidak akan berfungsi: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>canInit(with:)</code></a> diperlukan untuk menunjukkan jenis permintaan apa yang dapat ditangani oleh protokol <code>URL</code> kami.  Untuk contoh ini, anggap protokol hanya akan memproses permintaan dengan skema <code>map</code> di <code>URL</code> .  Sebelum memulai permintaan apa pun, <code>URL Loading System</code> memeriksa semua protokol yang terdaftar untuk sesi ini dan memanggil metode ini.  Protokol terdaftar pertama, yang dalam metode ini akan mengembalikan <code>true</code> , akan digunakan untuk memproses permintaan. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>canonicalRequest(for:)</code></a> dimaksudkan untuk mengurangi permintaan ke formulir kanonik.  Dokumentasi mengatakan bahwa implementasi protokol itu sendiri memutuskan apa yang harus dipertimbangkan sebagai definisi dari konsep ini.  Di sini Anda dapat menormalkan skema, menambahkan header ke permintaan, jika perlu, dll. Satu-satunya persyaratan agar metode ini berfungsi adalah bahwa untuk setiap permintaan yang masuk harus selalu ada hasil yang sama, termasuk karena metode ini juga digunakan untuk mencari jawaban yang di-cache permintaan di <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>startLoading()</code></a> menjelaskan semua logika untuk memuat data yang diperlukan.  Dalam contoh ini, Anda perlu mem-parsing <code>URL</code> permintaan dan, berdasarkan nilai-nilai parameter <code>latitude</code> dan <code>longitude</code> , <code>MKMapSnapshotter</code> dan muat snapshot peta yang diinginkan. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Setelah menerima data, protokol perlu dimatikan dengan benar: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Pertama-tama, buat objek bertipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>URLResponse</code></a> .  Objek ini berisi metadata penting untuk menanggapi permintaan.  Kemudian kami menjalankan tiga metode penting untuk objek bertipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>URLProtocolClient</code></a> .  Properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>client</code></a> jenis ini berisi setiap entitas dari protokol <code>URL</code> .  Ini bertindak sebagai proksi antara protokol <code>URL</code> dan seluruh <code>URL Loading System</code> , yang, saat memanggil metode ini, menarik kesimpulan tentang apa yang perlu dilakukan dengan data: cache, mengirim permintaan ke <code>completionHandler</code> , entah bagaimana proses penutupan protokol, dll. dan jumlah panggilan ke metode ini dapat bervariasi tergantung pada implementasi protokol.  Misalnya, kita dapat mengunduh data dari jaringan dengan batch dan memberi tahu <code>URLProtocolClient</code> tentang ini secara berkala untuk menunjukkan perkembangan pemuatan data di antarmuka. <br><br>  Jika terjadi kesalahan dalam pengoperasian protokol, perlu juga memproses dan memberi tahu <code>URLProtocolClient</code> tentang ini dengan benar: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  Kesalahan inilah yang kemudian akan dikirim ke <code>completionHandler</code> permintaan, di mana ia dapat diproses dan pesan yang indah ditampilkan kepada pengguna. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>stopLoading()</code></a> dipanggil ketika operasi protokol selesai karena beberapa alasan.  Ini bisa berupa penyelesaian yang berhasil, atau penyelesaian kesalahan atau pembatalan permintaan.  Ini adalah tempat yang baik untuk membebaskan sumber daya yang diduduki atau menghapus data sementara. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Ini melengkapi implementasi protokol <code>URL</code> , dapat digunakan di mana saja dalam aplikasi.  Untuk menjadi tempat menerapkan protokol kami, tambahkan beberapa hal lagi. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Ini adalah kelas sederhana, turunan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>UIImageView</code></a> , implementasi serupa yang mungkin Anda miliki di aplikasi apa pun.  Di sini kita cukup memuat gambar dengan <code>URL</code> di metode <code>render(url:)</code> dan menulisnya ke properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>image</code></a> .  Kemudahannya adalah Anda dapat mengunggah gambar apa pun, baik dengan <code>URL</code> <code>http</code> / <code>https</code> , atau dengan <code>URL</code> khusus kami. <br><br>  Untuk menjalankan permintaan untuk memuat gambar, Anda juga akan memerlukan objek tipe <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  Konfigurasi sesi sangat penting di sini.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>URLSessionConfiguration</code></a> ada satu properti penting bagi kami - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>protocolClasses</code></a> .  Ini adalah daftar jenis protokol <code>URL</code> yang dapat ditangani oleh sesi dengan konfigurasi ini.  Secara default, sesi mendukung pemrosesan protokol <code>http</code> / <code>https</code> , dan jika dukungan khusus diperlukan, mereka harus ditentukan.  Sebagai contoh kami, tentukan <code>MapURLProtocol</code> . <br><br>  Yang masih harus dilakukan adalah mengimplementasikan View Controller, yang akan menampilkan snapshot peta.  Kode sumbernya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Inilah hasilnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="gambar"></div><br><h2>  Bagaimana dengan caching? </h2><br>  Segalanya tampak bekerja dengan baik - kecuali satu poin penting: ketika kita menggulir daftar bolak-balik, bintik-bintik putih muncul di layar.  Tampaknya snapshot tidak di-cache dengan cara apa pun dan untuk setiap panggilan ke metode <code>render(url:)</code> , kami <code>MKMapSnapshotter</code> data melalui <code>MKMapSnapshotter</code> .  Ini membutuhkan waktu, dan oleh karena itu kesenjangan dalam memuat.  Perlu menerapkan mekanisme caching data sehingga snapshot yang sudah dibuat tidak diunduh lagi.  Di sini kami menggunakan kekuatan <code>URL Loading System</code> , yang sudah memiliki mekanisme caching untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>URLCache</code></a> disediakan untuk ini. <br><br>  Pertimbangkan proses ini secara lebih rinci dan bagi pekerjaan dengan cache menjadi dua tahap penting: membaca dan menulis. <br><br><h3>  Membaca </h3><br>  Untuk membaca data yang di-cache dengan benar, <code>URL Loading System</code> perlu bantuan untuk mendapatkan jawaban atas beberapa pertanyaan penting: <br><br>  <b>1. URLCache apa yang digunakan?</b> <br><br>  Tentu saja, sudah ada <code>URLCache.shared</code> sudah selesai, tetapi <code>URL Loading System</code> tidak selalu dapat menggunakannya - lagipula, pengembang mungkin ingin membuat dan menggunakan entitas <code>URLCache</code> miliknya sendiri.  Untuk menjawab pertanyaan ini, <code>URLSessionConfiguration</code> sesi <code>URLSessionConfiguration</code> memiliki properti <code>urlCache</code> .  Ini digunakan untuk membaca dan merekam respons terhadap permintaan.  Kami akan <code>URLCache</code> beberapa <code>URLCache</code> untuk keperluan ini dalam konfigurasi yang ada. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. Apakah saya perlu menggunakan data cache atau mengunduh lagi?</b> <br><br>  Jawaban untuk pertanyaan ini tergantung pada permintaan <code>URLRequest</code> kita jalankan.  Saat membuat permintaan, kami memiliki kesempatan untuk menentukan kebijakan cache dalam argumen <code>cachePolicy</code> selain <code>URL</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  Nilai defaultnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>.useProtocolCachePolicy</code></a> , yang juga ditulis dalam dokumentasi.  Ini berarti bahwa dalam versi ini, tugas untuk menemukan respons yang di-cache ke suatu permintaan dan menentukan relevansinya sepenuhnya terletak pada implementasi protokol <code>URL</code> .  Tetapi ada cara yang lebih mudah.  Jika Anda menetapkan nilai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>.returnCacheDataElseLoad</code></a> , maka saat membuat entitas berikutnya, <code>URLProtocol</code> <code>URL Loading System</code> akan mengambil beberapa pekerjaan: ia akan meminta <code>urlCache</code> respons yang di-cache ke permintaan saat ini menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cachedResponse(for:)</code></a> .  Jika ada data yang di-cache, maka objek tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CachedURLResponse</code></a> akan ditransfer segera ketika <code>URLProtocol</code> diinisialisasi dan disimpan di properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cachedResponse</code></a> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> adalah kelas sederhana yang berisi data ( <code>Data</code> ) dan meta-informasi untuk mereka ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>URLResponse</code></a> ). <br><br>  Kami hanya dapat mengubah <code>startLoading</code> metode <code>startLoading</code> dan memeriksa nilai properti ini di dalamnya - dan segera mengakhiri protokol dengan data ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Rekam </h3><br>  Untuk menemukan data dalam cache, Anda harus meletakkannya di sana.  <code>URL Loading System</code> juga menangani pekerjaan ini.  Semua yang diperlukan dari kami adalah untuk memberitahunya bahwa kami ingin melakukan cache data ketika protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cacheStoragePolicy</code></a> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cacheStoragePolicy</code></a> kebijakan cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cacheStoragePolicy</code></a> .  Ini adalah penghitungan sederhana dengan nilai-nilai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Itu berarti bahwa caching diperbolehkan dalam memori dan pada disk, hanya dalam memori atau dilarang.  Dalam contoh kami, kami menunjukkan bahwa caching diperbolehkan dalam memori dan pada disk, karena mengapa tidak. <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Jadi, dengan mengikuti beberapa langkah sederhana, kami mendukung kemampuan untuk me-cache snapshot peta.  Dan sekarang aplikasi berfungsi seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="gambar"></div><br>  Seperti yang Anda lihat, tidak ada lagi bintik putih - kartu dimuat satu kali dan kemudian digunakan kembali dari cache. <br><br><h2>  Tidak selalu mudah </h2><br>  Saat menerapkan protokol <code>URL</code> , kami mengalami serangkaian gangguan. <br><br>  Yang pertama terkait dengan implementasi internal interaksi <code>URL Loading System</code> dengan <code>URLCache</code> ketika caching tanggapan terhadap permintaan.  Dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyatakan</a> : meskipun ada keamanan <code>URLCache</code> , pengoperasian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>cachedResponse(for:)</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>storeCachedResponse(_:for:)</code></a> metode untuk membaca / menulis tanggapan terhadap permintaan dapat mengarah pada perlombaan status, oleh karena itu, poin ini harus diperhitungkan dalam subclass dari <code>URLCache</code> .  Kami berharap menggunakan <code>URLCache.shared</code> masalah ini akan terpecahkan, tetapi ternyata salah.  Untuk memperbaikinya, kami menggunakan cache <code>ImageURLCache</code> terpisah, turunan dari <code>URLCache</code> , di mana kami menjalankan metode yang ditentukan secara sinkron pada antrian terpisah.  Sebagai bonus yang menyenangkan, kami dapat mengonfigurasi kapasitas cache secara terpisah dalam memori dan pada disk secara terpisah dari entitas <code>URLCache</code> lainnya. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Masalah lain hanya direproduksi pada perangkat dengan iOS 9. Metode untuk memulai dan mengakhiri pemuatan protokol <code>URL</code> dapat dilakukan pada utas yang berbeda, yang dapat menyebabkan crash yang jarang namun tidak menyenangkan.  Untuk menyelesaikan masalah, kami menyimpan utas saat ini dalam metode <code>startLoading</code> dan kemudian menjalankan kode penyelesaian unduhan langsung di utas ini. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  Kapan protokol URL berguna? </h2><br>  Akibatnya, hampir setiap pengguna aplikasi iOS kami dengan satu atau lain cara menemukan elemen yang bekerja melalui protokol <code>URL</code> .  Selain mengunduh media dari galeri, berbagai implementasi protokol <code>URL</code> membantu kami menampilkan peta dan polling, serta menunjukkan avatar obrolan yang terdiri dari foto-foto peserta mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="gambar"></div><br>  Seperti solusi apa pun, <code>URLProtocol</code> memiliki kelebihan dan kekurangan. <br><br><h3>  Kerugian dari <code>URLProtocol</code> </h3><br><ul><li>  <b>Kurang mengetik ketat</b> - saat membuat <code>URL</code> skema dan parameter tautan ditentukan secara manual melalui string.  Jika Anda salah ketik, parameter yang diinginkan tidak akan diproses.  Ini dapat mempersulit proses debug aplikasi dan mencari kesalahan dalam operasinya.  Dalam aplikasi VKontakte, kami menggunakan <code>URLBuilder</code> khusus yang membentuk <code>URL</code> final berdasarkan parameter yang diteruskan.  Keputusan ini tidak terlalu indah dan agak bertentangan dengan tujuan tidak menghasilkan entitas tambahan, tetapi belum ada ide yang lebih baik.  Tetapi kami tahu bahwa jika Anda perlu membuat semacam <code>URL</code> khusus, maka pasti ada <code>URLBuilder</code> khusus untuk itu yang akan membantu Anda untuk tidak membuat kesalahan. </li><li>  <b>Crash tidak jelas</b> - Saya sudah menjelaskan beberapa skenario yang dapat menyebabkan aplikasi menggunakan <code>URLProtocol</code> mogok.  Mungkin ada yang lain.   ,  ,      ,    stack trace'    . </li></ul><br><h3>  URLProtocol </h3><br><ul><li> <b>  </b> ‚Äî  ,      ,      ,   :     ,   .       <code>URL</code> ‚Äî     . </li><li> <b> </b> ‚Äî    <code>URL</code> -        .         . </li><li> <b>  </b> ‚Äî       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> ‚Äî    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> ‚Äî      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - ‚Äî         .      .  -   ,   -    ,   ,    , ‚Äî  ,      .  ,     , ‚Äî  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467605/">https://habr.com/ru/post/id467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467591/index.html">Bukti baru memecahkan perkiraan angka seperti pi</a></li>
<li><a href="../id467593/index.html">(Tidak relevan, diperbaiki) Catatan. Bagaimana Tele2 berbagi akses ke akun pribadi pelanggan baru</a></li>
<li><a href="../id467595/index.html">Bepergian melalui pusat data Selectel. Dinosaurus di Api, VMware, C2F5H dan Manusia Serigala Yang Tak Terlihat</a></li>
<li><a href="../id467597/index.html">Personalisasi Pedoman Produk Big Data dengan Vowpal Wabbit</a></li>
<li><a href="../id467599/index.html">Render grafik 3D dengan OpenGL</a></li>
<li><a href="../id467607/index.html">Pengakuan pembenci buruh pelabuhan</a></li>
<li><a href="../id467609/index.html">Membuat aplikasi seluler di React Native</a></li>
<li><a href="../id467611/index.html">Algoritma Deteksi Garis Besar Gambar</a></li>
<li><a href="../id467615/index.html">Cara membuat pembungkus Python dan tidak menjadi gila</a></li>
<li><a href="../id467617/index.html">Kaspresso: kerangka kerja autotest yang Anda tunggu-tunggu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>