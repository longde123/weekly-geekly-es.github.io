<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐚 👨🏾‍🏫 👞 Volcanic Piglet oder Do-it-yourself-SQL 🈲 🌡️ ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Sammeln, Speichern, Konvertieren und Präsentieren von Daten sind die Hauptherausforderungen für Dateningenieure. Die Business Intelligence Badoo-A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volcanic Piglet oder Do-it-yourself-SQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  Das Sammeln, Speichern, Konvertieren und Präsentieren von Daten sind die Hauptherausforderungen für Dateningenieure.  Die Business Intelligence Badoo-Abteilung empfängt und verarbeitet täglich mehr als 20 Milliarden Ereignisse, die von Benutzergeräten oder 2 TB eingehender Daten gesendet werden. </p><br><p>  Das Studium und die Interpretation all dieser Daten ist nicht immer eine triviale Aufgabe, manchmal wird es notwendig, über die Fähigkeiten vorgefertigter Datenbanken hinauszugehen.  Und wenn Sie den Mut haben und sich für etwas Neues entschieden haben, sollten Sie sich zunächst mit den Funktionsprinzipien bestehender Lösungen vertraut machen. </p><br><p>  Mit einem Wort, neugierige und aufgeschlossene Entwickler, dieser Artikel wird angesprochen.  Darin finden Sie eine Beschreibung des traditionellen Modells der Abfrageausführung in relationalen Datenbanken am Beispiel der Demosprache PigletQL. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintergrund</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL-Interpreter-Struktur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vulkanmodell und Abfrageausführung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexikalisch und Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantischer Analysator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompilieren von Abfragen in eine Zwischenansicht</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Durchführung einer Zwischenpräsentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betreiber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeitsbeispiele</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Literatur</a> </li></ul><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  Unsere Gruppe von Ingenieuren beschäftigt sich mit Backends und Schnittstellen und bietet Möglichkeiten zur Analyse und Recherche von Daten innerhalb des Unternehmens (wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expandieren</a> übrigens).  Unsere Standardtools sind eine verteilte Datenbank mit Dutzenden von Servern (Exasol) und ein Hadoop-Cluster für Hunderte von Computern (Hive und Presto). </p><br><p>  Die meisten Abfragen an diese Datenbanken sind analytisch, dh sie betreffen Hunderttausende bis Milliarden von Datensätzen.  Ihre Ausführung dauert Minuten, zehn Minuten oder sogar Stunden, abhängig von der verwendeten Lösung und der Komplexität der Anforderung.  Bei manueller Arbeit des Benutzer-Analysten wird diese Zeit als akzeptabel angesehen, ist jedoch nicht für die interaktive Recherche über die Benutzeroberfläche geeignet. </p><br><p>  Im Laufe der Zeit haben wir die gängigen analytischen Abfragen und Abfragen hervorgehoben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die in Bezug auf</a> SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwer</a> darzulegen sind, und kleine spezialisierte Datenbanken für sie entwickelt.  Sie speichern eine Teilmenge von Daten in einem Format, das für einfache Komprimierungsalgorithmen (z. B. Streamvbyte) geeignet ist. Auf diese Weise können Sie Daten mehrere Tage lang auf einem einzelnen Computer speichern und Abfragen in Sekunden ausführen. </p><br><p>  Die ersten Abfragesprachen für diese Daten und ihre Interpreter wurden ahnungslos implementiert, wir mussten sie ständig weiterentwickeln, und jedes Mal dauerte es unannehmbar lange. </p><br><p>  Abfragesprachen waren nicht flexibel genug, obwohl es keine offensichtlichen Gründe gab, ihre Fähigkeiten einzuschränken.  Infolgedessen haben wir uns an die Erfahrung der Entwickler von SQL-Interpreten gewandt, dank derer wir die aufgetretenen Probleme teilweise lösen konnten. </p><br><p>  Im Folgenden werde ich über das häufigste Modell zur Ausführung von Abfragen in relationalen Datenbanken sprechen - Volcano.  Der Quellcode des Interpreters des primitiven SQL-Dialekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Artikel beigefügt</a> , sodass sich alle Interessierten leicht mit den Details im Repository vertraut machen können. </p><br><h1 id="struktura-interpretatora-sql">  SQL-Interpreter-Struktur </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Dolmetscherstruktur"></a> </p><br><p>  Die meisten gängigen Datenbanken bieten eine Schnittstelle zu Daten in Form einer deklarativen SQL-Abfragesprache.  Eine Abfrage in Form einer Zeichenfolge wird vom Parser in eine Beschreibung der Abfrage konvertiert, ähnlich einem abstrakten Syntaxbaum.  Es ist bereits in dieser Phase möglich, einfache Abfragen auszuführen. Zur Optimierung von Transformationen und der anschließenden Ausführung ist diese Darstellung jedoch unpraktisch.  In den mir zu diesem Zweck bekannten Datenbanken werden Zwischendarstellungen eingeführt. </p><br><p>  Die relationale Algebra wurde zum Modell für Zwischendarstellungen.  Dies ist eine Sprache, in der die an den Daten durchgeführten Transformationen ( <em>Operatoren</em> ) explizit beschrieben werden: Auswählen einer Teilmenge der Daten gemäß einem Prädikat, Kombinieren von Daten aus verschiedenen Quellen usw. Darüber hinaus ist die relationale Algebra eine Algebra im mathematischen Sinne, dh eine große Anzahl von Äquivalenten Transformationen.  Daher ist es zweckmäßig, Transformationen über eine Abfrage in Form eines Baums relationaler Algebraoperatoren zu optimieren. </p><br><p>  Es gibt wichtige Unterschiede zwischen internen Darstellungen in Datenbanken und der ursprünglichen relationalen Algebra. Daher ist es korrekter, sie als <em>logische Algebra zu bezeichnen</em> . </p><br><p>  Die Überprüfung der Gültigkeit einer Abfrage wird normalerweise beim Kompilieren der anfänglichen Darstellung der Abfrage in logische Algebraoperatoren durchgeführt und entspricht der Stufe der semantischen Analyse in herkömmlichen Compilern.  Die Rolle der Symboltabelle in Datenbanken spielt <em>das Datenbankverzeichnis</em> , in dem Informationen zum Datenbankschema und zu den Metadaten gespeichert werden: Tabellen, Tabellenspalten, Indizes, Benutzerrechte usw. </p><br><p>  Im Vergleich zu Allzweckdolmetschern weisen Datenbankdolmetscher eine weitere Besonderheit auf: Unterschiede im Datenvolumen und Metainformationen zu den Daten, an die Abfragen gestellt werden sollen.  In Tabellen oder Beziehungen in Bezug auf die relationale Algebra kann es eine unterschiedliche Datenmenge geben, auf einigen Spalten (Beziehungsattributen) können Indizes erstellt werden usw. Das heißt, abhängig vom Datenbankschema und der Datenmenge in den Tabellen muss die Abfrage von verschiedenen Algorithmen ausgeführt werden und verwenden Sie sie in einer anderen Reihenfolge. </p><br><p>  Um dieses Problem zu lösen, wird eine andere Zwischendarstellung eingeführt - die <em>physikalische Algebra</em> .  Abhängig von der Verfügbarkeit von Indizes für die Spalten, der Datenmenge in den Tabellen und der Struktur des Baums der logischen Algebra werden verschiedene Formen des Baums der physikalischen Algebra angeboten, aus denen die beste Option ausgewählt wird.  Dieser Baum wird der Datenbank als Abfrageplan angezeigt.  In herkömmlichen Compilern entspricht diese Stufe bedingt den Stufen der Registerzuweisung, Planung und Befehlsauswahl. </p><br><p>  Der letzte Schritt in der Arbeit des Interpreten ist direkt die Ausführung des Baums von Operatoren der physikalischen Algebra. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Vulkanmodell und Abfrageausführung </h1><br><p>  Physikalische Algebra-Bauminterpreter wurden immer in geschlossenen kommerziellen Datenbanken verwendet, aber die akademische Literatur bezieht sich normalerweise auf den experimentellen Optimierer Volcano, der Anfang der 90er Jahre entwickelt wurde. </p><br><p>  Im Volcano-Modell verwandelt sich jeder Operator eines Baums der physischen Algebra in eine Struktur mit drei Funktionen: Öffnen, Weiter, Schließen.  Zusätzlich zu den Funktionen enthält der Bediener einen Betriebszustand - Zustand.  Die Funktion open initiiert den Status der Anweisung, die nächste Funktion gibt entweder das nächste <em>Tupel</em> (englisches Tupel) zurück oder NULL. Wenn keine Tupel mehr vorhanden sind, beendet die Funktion close die Anweisung: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Operatoren können verschachtelt werden, um einen Baum von Operatoren der physikalischen Algebra zu bilden.  Jeder Operator iteriert somit über die Tupel einer Beziehung, die entweder auf einem realen Medium vorhanden ist, oder über eine virtuelle Beziehung, die durch Aufzählen der Tupel verschachtelter Operatoren gebildet wird: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  In Bezug auf moderne Hochsprachen ist der Baum solcher Operatoren eine Kaskade von Iteratoren. </p><br><p>  Sogar industrielle Abfragedolmetscher in relationalem DBMS werden vom Volcano-Modell abgestoßen. Deshalb habe ich es als Grundlage für den PigletQL-Interpreter verwendet. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Um das Modell zu demonstrieren, habe ich den Interpreter der eingeschränkten Abfragesprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL entwickelt</a> .  Es ist in C geschrieben, unterstützt die Erstellung von Tabellen im SQL-Stil, ist jedoch auf einen einzigen Typ beschränkt - 32-Bit-Ganzzahlen.  Alle Tabellen sind im Speicher.  Das System arbeitet in einem einzelnen Thread und verfügt nicht über einen Transaktionsmechanismus. </p><br><p>  In PigletQL gibt es keinen Optimierer, und SELECT-Abfragen werden direkt in den Operatorbaum der physischen Algebra kompiliert.  Die verbleibenden Abfragen (CREATE TABLE und INSERT) funktionieren direkt in den primären internen Ansichten. </p><br><p>  Beispiel für eine Benutzersitzung in PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Lexikalisch und Parser </h2><br><p>  PigletQL ist eine sehr einfache Sprache, deren Implementierung in den Phasen der lexikalischen Analyse und der Parsing-Analyse nicht erforderlich war. </p><br><p>  Der lexikalische Analysator wird von Hand geschrieben.  Aus der <a href="">Abfragezeichenfolge</a> wird ein Analysatorobjekt ( <a href="">scanner_t</a> ) erstellt, das nacheinander Token <a href="">ausgibt</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  Das Parsen erfolgt mit der rekursiven Abstiegsmethode.  Zunächst wird das Objekt <a href="">parser_t erstellt</a> , das nach Erhalt des lexikalischen Analysators (scanner_t) das Objekt query_t mit Informationen zur Anforderung füllt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  Das Ergebnis der Analyse in query_t ist eine der drei von PigletQL unterstützten Abfragetypen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  Die komplexeste Art von Abfrage in PigletQL ist SELECT.  Es entspricht der Datenstruktur <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  Die Struktur enthält eine Beschreibung der Abfrage (ein vom Benutzer angefordertes Array von Attributen), eine Liste von Datenquellen - Beziehungen, ein Array von Prädikaten, die Tupel filtern, und Informationen zu dem Attribut, das zum Sortieren der Ergebnisse verwendet wird. </p><br><h2 id="semanticheskiy-analizator">  Semantischer Analysator </h2><br><p>  Die semantische Analysephase in regulärem SQL umfasst die Überprüfung des Vorhandenseins der aufgelisteten Tabellen, Spalten in den Tabellen und die Typprüfung in Abfrageausdrücken.  Für Prüfungen in Bezug auf Tabellen und Spalten wird das Datenbankverzeichnis verwendet, in dem alle Informationen zur Datenstruktur gespeichert sind. </p><br><p>  In PigletQL gibt es keine komplexen Ausdrücke. Daher wird die Abfrageprüfung auf die Überprüfung der Katalogmetadaten von Tabellen und Spalten reduziert.  SELECT-Abfragen werden beispielsweise von der Funktion <a href="">validate_select validiert</a> .  Ich werde es in Kurzform bringen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Wenn die Anforderung gültig ist, besteht der nächste Schritt darin, den Analysebaum in einen Operatorbaum zu kompilieren. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Kompilieren von Abfragen in eine Zwischenansicht </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  In vollwertigen SQL-Interpreten gibt es normalerweise zwei Zwischendarstellungen: logische und physikalische Algebra. </p><br><p>  Ein einfacher PigletQL-Interpreter führt CREATE TABLE- und INSERT-Abfragen direkt aus seinen <a href="">Analysebäumen aus,</a> <a href="">dh den Strukturen</a> <a href="">query_create_table_t</a> und <a href="">query_insert_t</a> .  Komplexere SELECT-Abfragen werden zu einer einzigen Zwischendarstellung kompiliert, die vom Interpreter ausgeführt wird. </p><br><p>  Der Operatorbaum wird in der folgenden Reihenfolge von den Blättern bis zur Wurzel erstellt: </p><br><ol><li><p>  Aus dem rechten Teil der Abfrage ("... VON Beziehung1, Beziehung2, ...") werden die Namen der gewünschten Beziehungen erhalten, für die jeweils eine Scan-Anweisung erstellt wird. </p><br></li><li><p>  Durch Extrahieren von Tupeln aus Relationen werden Scanoperatoren über den Verknüpfungsoperator zu einem linksseitigen Binärbaum kombiniert. </p><br></li><li><p>  Vom Benutzer angeforderte Attribute ("SELECT attr1, attr2, ...") werden von der Projektanweisung ausgewählt. </p><br></li><li><p>  Wenn Prädikate angegeben werden ("... WO a = 1 UND b&gt; 10 ..."), wird die select-Anweisung zum obigen Baum hinzugefügt. </p><br></li><li><p>  Wenn die Methode zum Sortieren des Ergebnisses angegeben ist ("... ORDER BY attr1 DESC"), wird der Sortieroperator oben im Baum hinzugefügt. </p><br></li></ol><br><p>  Kompilierung in PigletQL- <a href="">Code</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Nachdem der Baum gebildet wurde, werden normalerweise optimierende Transformationen durchgeführt, aber PigletQL geht sofort zum Stadium der Ausführung der Zwischendarstellung über. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Durchführung einer Zwischenpräsentation </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  Das Volcano-Modell impliziert eine Schnittstelle für die Arbeit mit Bedienern über drei gemeinsame Öffnungs- / Weiter- / Schließvorgänge.  Im Wesentlichen ist jede Volcano-Anweisung ein Iterator, aus dem Tupel einzeln „gezogen“ werden. Daher wird dieser Ausführungsansatz auch als Pull-Modell bezeichnet. </p><br><p>  Jeder dieser Iteratoren kann selbst dieselben Funktionen verschachtelter Iteratoren aufrufen, temporäre Tabellen mit Zwischenergebnissen erstellen und eingehende Tupel konvertieren. </p><br><p>  Ausführen von <a href="">SELECT-Abfragen</a> in PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Die Anforderung wird zuerst von der Funktion compile_select kompiliert, die den Stamm des Operatorbaums zurückgibt. Danach werden dieselben Funktionen zum Öffnen / Weiter / Schließen für den Stammoperator aufgerufen.  Jeder Aufruf von next gibt entweder das nächste Tupel oder NULL zurück.  Im letzteren Fall bedeutet dies, dass alle Tupel extrahiert wurden und die Funktion zum Schließen des Iterators aufgerufen werden sollte. </p><br><p>  Die resultierenden Tupel werden neu berechnet und von der Tabelle an den Standardausgabestream ausgegeben. </p><br><h2 id="operatory">  Betreiber </h2><br><p>  Das Interessanteste an PigletQL ist der Operatorbaum.  Ich werde das Gerät einiger von ihnen zeigen. </p><br><p>  <a href="">Die</a> Operatoren haben eine gemeinsame <a href="">Schnittstelle</a> und bestehen aus Zeigern auf die Open / Next / Close-Funktion und einer zusätzlichen Destroy Destroy-Funktion, die die Ressourcen des gesamten Operatorbaums auf einmal freigibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  Zusätzlich zu Funktionen kann der Operator einen beliebigen internen Zustand (Zustandszeiger) enthalten. </p><br><p>  Im Folgenden werde ich das Gerät von zwei interessanten Operatoren analysieren: den einfachsten Scan und das Erstellen einer Zwischenrelationssortierung. </p><br><h3 id="operator-scan">  Scan-Anweisung </h3><br><p>  Die Anweisung, die eine Abfrage startet, ist scan.  Er geht einfach alle Tupel der Beziehung durch.  <a href="">Der interne Status des Scans</a> ist ein Zeiger auf die Beziehung, aus der Tupel abgerufen werden, der Index des nächsten Tupels in der Beziehung und eine Verknüpfungsstruktur zum aktuellen Tupel, die an den Benutzer übergeben wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Um den Status einer Scan-Anweisung zu erstellen, benötigen Sie eine Quellbeziehung.  alles andere (Zeiger auf die entsprechenden Funktionen) ist bereits bekannt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Öffnungs- / Schließvorgänge bei Scan-Reset-Links zurück zum ersten Element der Beziehung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  Der nächste Aufruf gibt entweder das nächste Tupel zurück oder NULL, wenn die Beziehung keine Tupel mehr enthält: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Sortieranweisung </h3><br><p>  Die sort-Anweisung erzeugt Tupel in der vom Benutzer angegebenen Reihenfolge.  Erstellen Sie dazu eine temporäre Beziehung zu Tupeln, die von verschachtelten Operatoren abgerufen wurden, und sortieren Sie sie. </p><br><p>  <a href="">Der interne Status des</a> Bedieners: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  Die Sortierung erfolgt nach den in der Anforderung angegebenen Attributen (sort_attr_name und sort_order) über das Zeitverhältnis (tmp_relation).  All dies geschieht, wenn die offene Funktion aufgerufen wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  Die Aufzählung der Elemente der temporären Beziehung erfolgt durch den temporären Operator tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  Die temporäre Beziehung wird in der Funktion zum Schließen freigegeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Hier können Sie deutlich sehen, warum das Sortieren von Spalten in Spalten ohne Indizes viel Zeit in Anspruch nehmen kann. </p><br><h2 id="primery-raboty">  Arbeitsbeispiele </h2><br><p>  Ich werde einige Beispiele für PigletQL-Abfragen und die entsprechenden Bäume der physikalischen Algebra geben. </p><br><p>  Das einfachste Beispiel, bei dem alle Tupel aus einer Beziehung ausgewählt werden: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Für die einfachste Abfrage werden nur Tupel aus der Scan-Beziehung abgerufen und das einzige Projektattribut aus den Tupeln ausgewählt: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Tupel mit einem Prädikat auswählen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Prädikate werden durch die select-Anweisung ausgedrückt: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Auswahl von Tupeln mit Sortierung: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  Der Scan-Sortieroperator im offenen Aufruf erstellt ( <em>materialisiert</em> ) eine temporäre Beziehung, platziert alle eingehenden Tupel dort und sortiert das Ganze.  Danach werden bei den nächsten Aufrufen Tupel aus der temporären Beziehung in der vom Benutzer angegebenen Reihenfolge abgeleitet: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Kombinieren von Tupeln zweier Beziehungen mit einem Prädikat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  Der Join-Operator in PigletQL verwendet keine komplexen Algorithmen, sondern bildet einfach ein kartesisches Produkt aus den Tupelmengen der linken und rechten Teilbäume.  Dies ist sehr ineffizient, aber für einen Demo-Interpreter reicht es aus: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Abschließend stelle ich fest, dass Sie, wenn Sie einen Interpreter für eine SQL-ähnliche Sprache erstellen, wahrscheinlich nur eine der vielen verfügbaren relationalen Datenbanken verwenden sollten.  Tausende von Personenjahren wurden in moderne Optimierer und Abfragedolmetscher gängiger Datenbanken investiert, und es dauert Jahre, um selbst die einfachsten Allzweckdatenbanken zu entwickeln. </p><br><p>  Die Demosprache PigletQL imitiert die Arbeit des SQL-Interpreters, aber in Wirklichkeit verwenden wir nur einzelne Elemente der Volcano-Architektur und nur für diejenigen (seltenen!) Arten von Abfragen, die im Rahmen des relationalen Modells schwer auszudrücken sind. </p><br><p>  Trotzdem wiederhole ich: Selbst eine oberflächliche Kenntnis der Architektur solcher Dolmetscher ist nützlich, wenn es notwendig ist, flexibel mit Datenströmen zu arbeiten. </p><br><h1 id="literatura">  Literatur </h1><br><p>  Wenn Sie sich für die grundlegenden Probleme der Datenbankentwicklung interessieren, sind Bücher besser als die „Implementierung des Datenbanksystems“ (Garcia-Molina H., Ullman JD, Widom J., 2000). </p><br><p>  Der einzige Nachteil ist eine theoretische Ausrichtung.  Persönlich gefällt es mir, wenn dem Material konkrete Beispiele für Code oder sogar ein Demo-Projekt beigefügt sind.  Informationen hierzu finden Sie im Buch „Datenbankdesign und -implementierung“ (Sciore E., 2008), das den vollständigen Code für eine relationale Datenbank in Java enthält. </p><br><p>  Die beliebtesten relationalen Datenbanken verwenden immer noch Variationen des Themas Volcano.  Die Originalveröffentlichung ist in einer sehr leicht zugänglichen Sprache verfasst und kann leicht in Google Scholar gefunden werden: "Volcano - ein erweiterbares und paralleles Abfragebewertungssystem" (Graefe G., 1994). </p><br><p>  Obwohl sich SQL-Interpreter in den letzten Jahrzehnten im Detail stark verändert haben, hat sich die sehr allgemeine Struktur dieser Systeme seit langem nicht geändert.  Eine Vorstellung davon können Sie einem Übersichtsartikel desselben Autors „Abfrageauswertungstechniken für große Datenbanken“ (Graefe G. 1993) entnehmen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461699/">https://habr.com/ru/post/de461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461689/index.html">Entwickler-IoT-Identifikation</a></li>
<li><a href="../de461691/index.html">So schließen wir Schwachstellen in Astra Linux Special Edition</a></li>
<li><a href="../de461693/index.html">Cross-Kompilieren von OpenCV 4 für Raspberry Pi und BeagleBone Black</a></li>
<li><a href="../de461695/index.html">VFX Praktikum</a></li>
<li><a href="../de461697/index.html">Bier Intelligenz</a></li>
<li><a href="../de461703/index.html">Microstepping-Reporting in der Arbeit eines Programmierers</a></li>
<li><a href="../de461707/index.html">Die Abenteuer der schwer fassbaren Malvari, Teil V: Weitere DDE- und COM-Scriptlets</a></li>
<li><a href="../de461709/index.html">Was Sie erwartet, wenn Sie iOS-Entwickler werden möchten</a></li>
<li><a href="../de461713/index.html">4 Möglichkeiten zum Speichern von Cloud-Backups</a></li>
<li><a href="../de461715/index.html">Angst und Abscheu als Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>