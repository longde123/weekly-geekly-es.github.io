<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üë®üèæ‚Äçüè´ üëû Volcanic Piglet oder Do-it-yourself-SQL üà≤ üå°Ô∏è ‚è≠Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Sammeln, Speichern, Konvertieren und Pr√§sentieren von Daten sind die Hauptherausforderungen f√ºr Dateningenieure. Die Business Intelligence Badoo-A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volcanic Piglet oder Do-it-yourself-SQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  Das Sammeln, Speichern, Konvertieren und Pr√§sentieren von Daten sind die Hauptherausforderungen f√ºr Dateningenieure.  Die Business Intelligence Badoo-Abteilung empf√§ngt und verarbeitet t√§glich mehr als 20 Milliarden Ereignisse, die von Benutzerger√§ten oder 2 TB eingehender Daten gesendet werden. </p><br><p>  Das Studium und die Interpretation all dieser Daten ist nicht immer eine triviale Aufgabe, manchmal wird es notwendig, √ºber die F√§higkeiten vorgefertigter Datenbanken hinauszugehen.  Und wenn Sie den Mut haben und sich f√ºr etwas Neues entschieden haben, sollten Sie sich zun√§chst mit den Funktionsprinzipien bestehender L√∂sungen vertraut machen. </p><br><p>  Mit einem Wort, neugierige und aufgeschlossene Entwickler, dieser Artikel wird angesprochen.  Darin finden Sie eine Beschreibung des traditionellen Modells der Abfrageausf√ºhrung in relationalen Datenbanken am Beispiel der Demosprache PigletQL. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintergrund</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL-Interpreter-Struktur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vulkanmodell und Abfrageausf√ºhrung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexikalisch und Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantischer Analysator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompilieren von Abfragen in eine Zwischenansicht</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Durchf√ºhrung einer Zwischenpr√§sentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betreiber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeitsbeispiele</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Literatur</a> </li></ul><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  Unsere Gruppe von Ingenieuren besch√§ftigt sich mit Backends und Schnittstellen und bietet M√∂glichkeiten zur Analyse und Recherche von Daten innerhalb des Unternehmens (wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expandieren</a> √ºbrigens).  Unsere Standardtools sind eine verteilte Datenbank mit Dutzenden von Servern (Exasol) und ein Hadoop-Cluster f√ºr Hunderte von Computern (Hive und Presto). </p><br><p>  Die meisten Abfragen an diese Datenbanken sind analytisch, dh sie betreffen Hunderttausende bis Milliarden von Datens√§tzen.  Ihre Ausf√ºhrung dauert Minuten, zehn Minuten oder sogar Stunden, abh√§ngig von der verwendeten L√∂sung und der Komplexit√§t der Anforderung.  Bei manueller Arbeit des Benutzer-Analysten wird diese Zeit als akzeptabel angesehen, ist jedoch nicht f√ºr die interaktive Recherche √ºber die Benutzeroberfl√§che geeignet. </p><br><p>  Im Laufe der Zeit haben wir die g√§ngigen analytischen Abfragen und Abfragen hervorgehoben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die in Bezug auf</a> SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwer</a> darzulegen sind, und kleine spezialisierte Datenbanken f√ºr sie entwickelt.  Sie speichern eine Teilmenge von Daten in einem Format, das f√ºr einfache Komprimierungsalgorithmen (z. B. Streamvbyte) geeignet ist. Auf diese Weise k√∂nnen Sie Daten mehrere Tage lang auf einem einzelnen Computer speichern und Abfragen in Sekunden ausf√ºhren. </p><br><p>  Die ersten Abfragesprachen f√ºr diese Daten und ihre Interpreter wurden ahnungslos implementiert, wir mussten sie st√§ndig weiterentwickeln, und jedes Mal dauerte es unannehmbar lange. </p><br><p>  Abfragesprachen waren nicht flexibel genug, obwohl es keine offensichtlichen Gr√ºnde gab, ihre F√§higkeiten einzuschr√§nken.  Infolgedessen haben wir uns an die Erfahrung der Entwickler von SQL-Interpreten gewandt, dank derer wir die aufgetretenen Probleme teilweise l√∂sen konnten. </p><br><p>  Im Folgenden werde ich √ºber das h√§ufigste Modell zur Ausf√ºhrung von Abfragen in relationalen Datenbanken sprechen - Volcano.  Der Quellcode des Interpreters des primitiven SQL-Dialekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Artikel beigef√ºgt</a> , sodass sich alle Interessierten leicht mit den Details im Repository vertraut machen k√∂nnen. </p><br><h1 id="struktura-interpretatora-sql">  SQL-Interpreter-Struktur </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Dolmetscherstruktur"></a> </p><br><p>  Die meisten g√§ngigen Datenbanken bieten eine Schnittstelle zu Daten in Form einer deklarativen SQL-Abfragesprache.  Eine Abfrage in Form einer Zeichenfolge wird vom Parser in eine Beschreibung der Abfrage konvertiert, √§hnlich einem abstrakten Syntaxbaum.  Es ist bereits in dieser Phase m√∂glich, einfache Abfragen auszuf√ºhren. Zur Optimierung von Transformationen und der anschlie√üenden Ausf√ºhrung ist diese Darstellung jedoch unpraktisch.  In den mir zu diesem Zweck bekannten Datenbanken werden Zwischendarstellungen eingef√ºhrt. </p><br><p>  Die relationale Algebra wurde zum Modell f√ºr Zwischendarstellungen.  Dies ist eine Sprache, in der die an den Daten durchgef√ºhrten Transformationen ( <em>Operatoren</em> ) explizit beschrieben werden: Ausw√§hlen einer Teilmenge der Daten gem√§√ü einem Pr√§dikat, Kombinieren von Daten aus verschiedenen Quellen usw. Dar√ºber hinaus ist die relationale Algebra eine Algebra im mathematischen Sinne, dh eine gro√üe Anzahl von √Ñquivalenten Transformationen.  Daher ist es zweckm√§√üig, Transformationen √ºber eine Abfrage in Form eines Baums relationaler Algebraoperatoren zu optimieren. </p><br><p>  Es gibt wichtige Unterschiede zwischen internen Darstellungen in Datenbanken und der urspr√ºnglichen relationalen Algebra. Daher ist es korrekter, sie als <em>logische Algebra zu bezeichnen</em> . </p><br><p>  Die √úberpr√ºfung der G√ºltigkeit einer Abfrage wird normalerweise beim Kompilieren der anf√§nglichen Darstellung der Abfrage in logische Algebraoperatoren durchgef√ºhrt und entspricht der Stufe der semantischen Analyse in herk√∂mmlichen Compilern.  Die Rolle der Symboltabelle in Datenbanken spielt <em>das Datenbankverzeichnis</em> , in dem Informationen zum Datenbankschema und zu den Metadaten gespeichert werden: Tabellen, Tabellenspalten, Indizes, Benutzerrechte usw. </p><br><p>  Im Vergleich zu Allzweckdolmetschern weisen Datenbankdolmetscher eine weitere Besonderheit auf: Unterschiede im Datenvolumen und Metainformationen zu den Daten, an die Abfragen gestellt werden sollen.  In Tabellen oder Beziehungen in Bezug auf die relationale Algebra kann es eine unterschiedliche Datenmenge geben, auf einigen Spalten (Beziehungsattributen) k√∂nnen Indizes erstellt werden usw. Das hei√üt, abh√§ngig vom Datenbankschema und der Datenmenge in den Tabellen muss die Abfrage von verschiedenen Algorithmen ausgef√ºhrt werden und verwenden Sie sie in einer anderen Reihenfolge. </p><br><p>  Um dieses Problem zu l√∂sen, wird eine andere Zwischendarstellung eingef√ºhrt - die <em>physikalische Algebra</em> .  Abh√§ngig von der Verf√ºgbarkeit von Indizes f√ºr die Spalten, der Datenmenge in den Tabellen und der Struktur des Baums der logischen Algebra werden verschiedene Formen des Baums der physikalischen Algebra angeboten, aus denen die beste Option ausgew√§hlt wird.  Dieser Baum wird der Datenbank als Abfrageplan angezeigt.  In herk√∂mmlichen Compilern entspricht diese Stufe bedingt den Stufen der Registerzuweisung, Planung und Befehlsauswahl. </p><br><p>  Der letzte Schritt in der Arbeit des Interpreten ist direkt die Ausf√ºhrung des Baums von Operatoren der physikalischen Algebra. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Vulkanmodell und Abfrageausf√ºhrung </h1><br><p>  Physikalische Algebra-Bauminterpreter wurden immer in geschlossenen kommerziellen Datenbanken verwendet, aber die akademische Literatur bezieht sich normalerweise auf den experimentellen Optimierer Volcano, der Anfang der 90er Jahre entwickelt wurde. </p><br><p>  Im Volcano-Modell verwandelt sich jeder Operator eines Baums der physischen Algebra in eine Struktur mit drei Funktionen: √ñffnen, Weiter, Schlie√üen.  Zus√§tzlich zu den Funktionen enth√§lt der Bediener einen Betriebszustand - Zustand.  Die Funktion open initiiert den Status der Anweisung, die n√§chste Funktion gibt entweder das n√§chste <em>Tupel</em> (englisches Tupel) zur√ºck oder NULL. Wenn keine Tupel mehr vorhanden sind, beendet die Funktion close die Anweisung: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Operatoren k√∂nnen verschachtelt werden, um einen Baum von Operatoren der physikalischen Algebra zu bilden.  Jeder Operator iteriert somit √ºber die Tupel einer Beziehung, die entweder auf einem realen Medium vorhanden ist, oder √ºber eine virtuelle Beziehung, die durch Aufz√§hlen der Tupel verschachtelter Operatoren gebildet wird: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  In Bezug auf moderne Hochsprachen ist der Baum solcher Operatoren eine Kaskade von Iteratoren. </p><br><p>  Sogar industrielle Abfragedolmetscher in relationalem DBMS werden vom Volcano-Modell abgesto√üen. Deshalb habe ich es als Grundlage f√ºr den PigletQL-Interpreter verwendet. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Um das Modell zu demonstrieren, habe ich den Interpreter der eingeschr√§nkten Abfragesprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletQL entwickelt</a> .  Es ist in C geschrieben, unterst√ºtzt die Erstellung von Tabellen im SQL-Stil, ist jedoch auf einen einzigen Typ beschr√§nkt - 32-Bit-Ganzzahlen.  Alle Tabellen sind im Speicher.  Das System arbeitet in einem einzelnen Thread und verf√ºgt nicht √ºber einen Transaktionsmechanismus. </p><br><p>  In PigletQL gibt es keinen Optimierer, und SELECT-Abfragen werden direkt in den Operatorbaum der physischen Algebra kompiliert.  Die verbleibenden Abfragen (CREATE TABLE und INSERT) funktionieren direkt in den prim√§ren internen Ansichten. </p><br><p>  Beispiel f√ºr eine Benutzersitzung in PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Lexikalisch und Parser </h2><br><p>  PigletQL ist eine sehr einfache Sprache, deren Implementierung in den Phasen der lexikalischen Analyse und der Parsing-Analyse nicht erforderlich war. </p><br><p>  Der lexikalische Analysator wird von Hand geschrieben.  Aus der <a href="">Abfragezeichenfolge</a> wird ein Analysatorobjekt ( <a href="">scanner_t</a> ) erstellt, das nacheinander Token <a href="">ausgibt</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  Das Parsen erfolgt mit der rekursiven Abstiegsmethode.  Zun√§chst wird das Objekt <a href="">parser_t erstellt</a> , das nach Erhalt des lexikalischen Analysators (scanner_t) das Objekt query_t mit Informationen zur Anforderung f√ºllt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  Das Ergebnis der Analyse in query_t ist eine der drei von PigletQL unterst√ºtzten Abfragetypen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  Die komplexeste Art von Abfrage in PigletQL ist SELECT.  Es entspricht der Datenstruktur <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  Die Struktur enth√§lt eine Beschreibung der Abfrage (ein vom Benutzer angefordertes Array von Attributen), eine Liste von Datenquellen - Beziehungen, ein Array von Pr√§dikaten, die Tupel filtern, und Informationen zu dem Attribut, das zum Sortieren der Ergebnisse verwendet wird. </p><br><h2 id="semanticheskiy-analizator">  Semantischer Analysator </h2><br><p>  Die semantische Analysephase in regul√§rem SQL umfasst die √úberpr√ºfung des Vorhandenseins der aufgelisteten Tabellen, Spalten in den Tabellen und die Typpr√ºfung in Abfrageausdr√ºcken.  F√ºr Pr√ºfungen in Bezug auf Tabellen und Spalten wird das Datenbankverzeichnis verwendet, in dem alle Informationen zur Datenstruktur gespeichert sind. </p><br><p>  In PigletQL gibt es keine komplexen Ausdr√ºcke. Daher wird die Abfragepr√ºfung auf die √úberpr√ºfung der Katalogmetadaten von Tabellen und Spalten reduziert.  SELECT-Abfragen werden beispielsweise von der Funktion <a href="">validate_select validiert</a> .  Ich werde es in Kurzform bringen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Wenn die Anforderung g√ºltig ist, besteht der n√§chste Schritt darin, den Analysebaum in einen Operatorbaum zu kompilieren. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Kompilieren von Abfragen in eine Zwischenansicht </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  In vollwertigen SQL-Interpreten gibt es normalerweise zwei Zwischendarstellungen: logische und physikalische Algebra. </p><br><p>  Ein einfacher PigletQL-Interpreter f√ºhrt CREATE TABLE- und INSERT-Abfragen direkt aus seinen <a href="">Analyseb√§umen aus,</a> <a href="">dh den Strukturen</a> <a href="">query_create_table_t</a> und <a href="">query_insert_t</a> .  Komplexere SELECT-Abfragen werden zu einer einzigen Zwischendarstellung kompiliert, die vom Interpreter ausgef√ºhrt wird. </p><br><p>  Der Operatorbaum wird in der folgenden Reihenfolge von den Bl√§ttern bis zur Wurzel erstellt: </p><br><ol><li><p>  Aus dem rechten Teil der Abfrage ("... VON Beziehung1, Beziehung2, ...") werden die Namen der gew√ºnschten Beziehungen erhalten, f√ºr die jeweils eine Scan-Anweisung erstellt wird. </p><br></li><li><p>  Durch Extrahieren von Tupeln aus Relationen werden Scanoperatoren √ºber den Verkn√ºpfungsoperator zu einem linksseitigen Bin√§rbaum kombiniert. </p><br></li><li><p>  Vom Benutzer angeforderte Attribute ("SELECT attr1, attr2, ...") werden von der Projektanweisung ausgew√§hlt. </p><br></li><li><p>  Wenn Pr√§dikate angegeben werden ("... WO a = 1 UND b&gt; 10 ..."), wird die select-Anweisung zum obigen Baum hinzugef√ºgt. </p><br></li><li><p>  Wenn die Methode zum Sortieren des Ergebnisses angegeben ist ("... ORDER BY attr1 DESC"), wird der Sortieroperator oben im Baum hinzugef√ºgt. </p><br></li></ol><br><p>  Kompilierung in PigletQL- <a href="">Code</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Nachdem der Baum gebildet wurde, werden normalerweise optimierende Transformationen durchgef√ºhrt, aber PigletQL geht sofort zum Stadium der Ausf√ºhrung der Zwischendarstellung √ºber. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Durchf√ºhrung einer Zwischenpr√§sentation </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  Das Volcano-Modell impliziert eine Schnittstelle f√ºr die Arbeit mit Bedienern √ºber drei gemeinsame √ñffnungs- / Weiter- / Schlie√üvorg√§nge.  Im Wesentlichen ist jede Volcano-Anweisung ein Iterator, aus dem Tupel einzeln ‚Äûgezogen‚Äú werden. Daher wird dieser Ausf√ºhrungsansatz auch als Pull-Modell bezeichnet. </p><br><p>  Jeder dieser Iteratoren kann selbst dieselben Funktionen verschachtelter Iteratoren aufrufen, tempor√§re Tabellen mit Zwischenergebnissen erstellen und eingehende Tupel konvertieren. </p><br><p>  Ausf√ºhren von <a href="">SELECT-Abfragen</a> in PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Die Anforderung wird zuerst von der Funktion compile_select kompiliert, die den Stamm des Operatorbaums zur√ºckgibt. Danach werden dieselben Funktionen zum √ñffnen / Weiter / Schlie√üen f√ºr den Stammoperator aufgerufen.  Jeder Aufruf von next gibt entweder das n√§chste Tupel oder NULL zur√ºck.  Im letzteren Fall bedeutet dies, dass alle Tupel extrahiert wurden und die Funktion zum Schlie√üen des Iterators aufgerufen werden sollte. </p><br><p>  Die resultierenden Tupel werden neu berechnet und von der Tabelle an den Standardausgabestream ausgegeben. </p><br><h2 id="operatory">  Betreiber </h2><br><p>  Das Interessanteste an PigletQL ist der Operatorbaum.  Ich werde das Ger√§t einiger von ihnen zeigen. </p><br><p>  <a href="">Die</a> Operatoren haben eine gemeinsame <a href="">Schnittstelle</a> und bestehen aus Zeigern auf die Open / Next / Close-Funktion und einer zus√§tzlichen Destroy Destroy-Funktion, die die Ressourcen des gesamten Operatorbaums auf einmal freigibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  Zus√§tzlich zu Funktionen kann der Operator einen beliebigen internen Zustand (Zustandszeiger) enthalten. </p><br><p>  Im Folgenden werde ich das Ger√§t von zwei interessanten Operatoren analysieren: den einfachsten Scan und das Erstellen einer Zwischenrelationssortierung. </p><br><h3 id="operator-scan">  Scan-Anweisung </h3><br><p>  Die Anweisung, die eine Abfrage startet, ist scan.  Er geht einfach alle Tupel der Beziehung durch.  <a href="">Der interne Status des Scans</a> ist ein Zeiger auf die Beziehung, aus der Tupel abgerufen werden, der Index des n√§chsten Tupels in der Beziehung und eine Verkn√ºpfungsstruktur zum aktuellen Tupel, die an den Benutzer √ºbergeben wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Um den Status einer Scan-Anweisung zu erstellen, ben√∂tigen Sie eine Quellbeziehung.  alles andere (Zeiger auf die entsprechenden Funktionen) ist bereits bekannt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  √ñffnungs- / Schlie√üvorg√§nge bei Scan-Reset-Links zur√ºck zum ersten Element der Beziehung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  Der n√§chste Aufruf gibt entweder das n√§chste Tupel zur√ºck oder NULL, wenn die Beziehung keine Tupel mehr enth√§lt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Sortieranweisung </h3><br><p>  Die sort-Anweisung erzeugt Tupel in der vom Benutzer angegebenen Reihenfolge.  Erstellen Sie dazu eine tempor√§re Beziehung zu Tupeln, die von verschachtelten Operatoren abgerufen wurden, und sortieren Sie sie. </p><br><p>  <a href="">Der interne Status des</a> Bedieners: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  Die Sortierung erfolgt nach den in der Anforderung angegebenen Attributen (sort_attr_name und sort_order) √ºber das Zeitverh√§ltnis (tmp_relation).  All dies geschieht, wenn die offene Funktion aufgerufen wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  Die Aufz√§hlung der Elemente der tempor√§ren Beziehung erfolgt durch den tempor√§ren Operator tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  Die tempor√§re Beziehung wird in der Funktion zum Schlie√üen freigegeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Hier k√∂nnen Sie deutlich sehen, warum das Sortieren von Spalten in Spalten ohne Indizes viel Zeit in Anspruch nehmen kann. </p><br><h2 id="primery-raboty">  Arbeitsbeispiele </h2><br><p>  Ich werde einige Beispiele f√ºr PigletQL-Abfragen und die entsprechenden B√§ume der physikalischen Algebra geben. </p><br><p>  Das einfachste Beispiel, bei dem alle Tupel aus einer Beziehung ausgew√§hlt werden: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  F√ºr die einfachste Abfrage werden nur Tupel aus der Scan-Beziehung abgerufen und das einzige Projektattribut aus den Tupeln ausgew√§hlt: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Tupel mit einem Pr√§dikat ausw√§hlen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Pr√§dikate werden durch die select-Anweisung ausgedr√ºckt: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Auswahl von Tupeln mit Sortierung: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  Der Scan-Sortieroperator im offenen Aufruf erstellt ( <em>materialisiert</em> ) eine tempor√§re Beziehung, platziert alle eingehenden Tupel dort und sortiert das Ganze.  Danach werden bei den n√§chsten Aufrufen Tupel aus der tempor√§ren Beziehung in der vom Benutzer angegebenen Reihenfolge abgeleitet: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Kombinieren von Tupeln zweier Beziehungen mit einem Pr√§dikat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  Der Join-Operator in PigletQL verwendet keine komplexen Algorithmen, sondern bildet einfach ein kartesisches Produkt aus den Tupelmengen der linken und rechten Teilb√§ume.  Dies ist sehr ineffizient, aber f√ºr einen Demo-Interpreter reicht es aus: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Abschlie√üend stelle ich fest, dass Sie, wenn Sie einen Interpreter f√ºr eine SQL-√§hnliche Sprache erstellen, wahrscheinlich nur eine der vielen verf√ºgbaren relationalen Datenbanken verwenden sollten.  Tausende von Personenjahren wurden in moderne Optimierer und Abfragedolmetscher g√§ngiger Datenbanken investiert, und es dauert Jahre, um selbst die einfachsten Allzweckdatenbanken zu entwickeln. </p><br><p>  Die Demosprache PigletQL imitiert die Arbeit des SQL-Interpreters, aber in Wirklichkeit verwenden wir nur einzelne Elemente der Volcano-Architektur und nur f√ºr diejenigen (seltenen!) Arten von Abfragen, die im Rahmen des relationalen Modells schwer auszudr√ºcken sind. </p><br><p>  Trotzdem wiederhole ich: Selbst eine oberfl√§chliche Kenntnis der Architektur solcher Dolmetscher ist n√ºtzlich, wenn es notwendig ist, flexibel mit Datenstr√∂men zu arbeiten. </p><br><h1 id="literatura">  Literatur </h1><br><p>  Wenn Sie sich f√ºr die grundlegenden Probleme der Datenbankentwicklung interessieren, sind B√ºcher besser als die ‚ÄûImplementierung des Datenbanksystems‚Äú (Garcia-Molina H., Ullman JD, Widom J., 2000). </p><br><p>  Der einzige Nachteil ist eine theoretische Ausrichtung.  Pers√∂nlich gef√§llt es mir, wenn dem Material konkrete Beispiele f√ºr Code oder sogar ein Demo-Projekt beigef√ºgt sind.  Informationen hierzu finden Sie im Buch ‚ÄûDatenbankdesign und -implementierung‚Äú (Sciore E., 2008), das den vollst√§ndigen Code f√ºr eine relationale Datenbank in Java enth√§lt. </p><br><p>  Die beliebtesten relationalen Datenbanken verwenden immer noch Variationen des Themas Volcano.  Die Originalver√∂ffentlichung ist in einer sehr leicht zug√§nglichen Sprache verfasst und kann leicht in Google Scholar gefunden werden: "Volcano - ein erweiterbares und paralleles Abfragebewertungssystem" (Graefe G., 1994). </p><br><p>  Obwohl sich SQL-Interpreter in den letzten Jahrzehnten im Detail stark ver√§ndert haben, hat sich die sehr allgemeine Struktur dieser Systeme seit langem nicht ge√§ndert.  Eine Vorstellung davon k√∂nnen Sie einem √úbersichtsartikel desselben Autors ‚ÄûAbfrageauswertungstechniken f√ºr gro√üe Datenbanken‚Äú (Graefe G. 1993) entnehmen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461699/">https://habr.com/ru/post/de461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461689/index.html">Entwickler-IoT-Identifikation</a></li>
<li><a href="../de461691/index.html">So schlie√üen wir Schwachstellen in Astra Linux Special Edition</a></li>
<li><a href="../de461693/index.html">Cross-Kompilieren von OpenCV 4 f√ºr Raspberry Pi und BeagleBone Black</a></li>
<li><a href="../de461695/index.html">VFX Praktikum</a></li>
<li><a href="../de461697/index.html">Bier Intelligenz</a></li>
<li><a href="../de461703/index.html">Microstepping-Reporting in der Arbeit eines Programmierers</a></li>
<li><a href="../de461707/index.html">Die Abenteuer der schwer fassbaren Malvari, Teil V: Weitere DDE- und COM-Scriptlets</a></li>
<li><a href="../de461709/index.html">Was Sie erwartet, wenn Sie iOS-Entwickler werden m√∂chten</a></li>
<li><a href="../de461713/index.html">4 M√∂glichkeiten zum Speichern von Cloud-Backups</a></li>
<li><a href="../de461715/index.html">Angst und Abscheu als Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>