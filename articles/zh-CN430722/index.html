<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 👰🏻 💠 PHP性能：规划，概要分析，优化 🥛 🙆🏿 🎬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 两年前，我们撰写了有关如何切换到PHP 7.0并节省一百万美元的文章。 在我们的负载配置文件中，新版本的CPU使用效率是原来的两倍：过渡开始后，我们曾经为大约600台服务器提供服务的负载约为300个。 结果，两年来我们有很多能力。 

 但是Badoo正在成长。 活动用户的数量在不断增加。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP性能：规划，概要分析，优化</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430722/"><img src="https://habrastorage.org/webt/k_/fe/vv/k_fevvrhhn2aruuz19gpne_jypy.jpeg"><br><br> 哈Ha！ 两年前，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">撰写了</a>有关如何切换到PHP 7.0并节省一百万美元的文章。 在我们的负载配置文件中，新版本的CPU使用效率是原来的两倍：过渡开始后，我们曾经为大约600台服务器提供服务的负载约为300个。 结果，两年来我们有很多能力。 <br><br> 但是Badoo正在成长。 活动用户的数量在不断增加。 我们正在改进和开发我们的功能，这要感谢用户在应用程序中花费越来越多的时间。 反过来，这也反映在请求数量上，在过去两年中，请求数量增加了2-2.5倍。 <br><br> 我们发现自己处于这样一种情况，性能的两倍增长被请求的两倍以上的增长所抵消，然后我们再次开始接近集群的极限。 在PHP的核心中，再次期望进行有用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优化</a> （JIT，预加载），但是它们仅计划用于PHP 7.4，并且此版本将在一年内发布。 因此，过渡技巧现在无法重复-您需要优化应用程序代码本身。 <br><br> 切入点，我将告诉您我们如何处理此类任务，使用哪些工具，并举例说明适用于我们，对我们有帮助的优化，思想和方法。 <br><a name="habracut"></a><br><h1> 为什么要优化 </h1><br> 解决性能问题的最简单，最明显的方法是添加铁。 如果您的代码在同一服务器上运行，那么再添加一个将使集群的性能提高一倍。 将这些成本转移到开发人员的工作时间上，我们问自己：由于优化，他在这段时间内能否将生产率提高两倍？ 也许是，但也许不是：这取决于系统已经在最佳状态下工作以及开发人员的水平。 另一方面，购买的服务器将保留为公司财产，所花费的时间将不退还。 <br><br> 事实证明，在小体积情况下，正确的解决方案通常是添加铁。 <br><br> 但以我们的情况。 现在，从迁移到PHP 7.0所获得的收益被活动的增长和用户数量所抵消之后，我们又有了600台服务器，可以为PHP应用程序提供请求。 为了将容量提高一半半，我们需要添加300台服务器。 <br><br> 以计算一台服务器的平均成本-$ 4,000。  300 * 4000 = $ 1,200,000-将容量增加一倍半的成本。 <br><br> 就是说，在我们的条件下，我们可以投入大量的工作时间来优化系统，与买铁相比，它仍然会更有利可图。 <br><br><h1> 能力计划 </h1><br> 在做任何事情之前，重要的是要了解是否有问题。 如果她不在那，那么值得尝试预测她何时会出现。 此过程称为容量计划。 <br><br> 出现性能问题的具体指标是响应时间。 确实，CPU（或其他资源）的负载是6％还是146％无关紧要：如果客户在满意的时间内获得了所需质量的服务，则一切正常。 <br><br> 关注响应时间的缺点是通常只有在问题已经出现时才开始增加响应时间。 如果尚未出现，则很难预测其外观。 另外，响应时间反映了所有因素（制动服务，网络，驱动器等）影响的结果，并且不能提供问题原因的理解。 <br><br> 在我们的情况下，CPU通常是瓶颈，因此在规划集群的大小和性能时，我们主要关注与使用情况相关的指标。 我们从所有机器上收集CPU使用率，并用平均值，中位数，第75和第95个百分位数构建图形： <br><br><img src="https://habrastorage.org/webt/pt/xs/dr/ptxsdr6jybv45cznqjykeqd11_g.png"><br>  <i>群集计算机的CPU使用率百分比：平均值，中位数，百分位数</i> <br><br> 集群中添加了数百年的机器已经有很多年了。 它们的配置和性能不同（群集不是同质的）。 我们的平衡器考虑了这一点（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> ），并根据机器的功能加载机器。 为了控制此过程，我们还有最大和最小装载机器的时间表。 <br><br><img src="https://habrastorage.org/webt/nf/we/f7/nfwef7cixau-uxenwsglrnvfzho.png"><br>  <i>负载最大和最少的集群计算机</i> <br><br> 如果查看这些图（或仅查看top命令的输出）并看到50％的CPU负载，您可能会认为我们仍然有两倍的负载裕量。 但是实际上通常并非如此。 这就是为什么。 <br><br><h1> 超线程 </h1><br> 想象一个没有超跑的单核。 我们用一个CPU绑定线程加载它。 我们会在顶部看到100％的负载。 <br><br> 现在，在此内核上打开超级读取并以完全相同的方式加载它。 在顶部，我们已经看到了两个逻辑核心，总负载将为50％（通常一个为0％，另一个为100％）。 <br><br><img src="https://habrastorage.org/webt/gr/zi/hw/grzihwfkj986zatrfrsrgg4-ykk.png"><br>  <i>CPU利用率：主要数据以及实际情况</i> <br><br> 好像处理器仅加载了50％。 但实际上没有其他可用的免费内核出现。  <i>在某些情况下</i> ，超踩踏允许一次<i>在</i>一个物理核心上执行多个进程。 但这远没有使典型情况下的性能提高一倍，尽管在CPU使用情况图上看起来它只有一半的资源：从50％到100％。 <br><br> 这意味着在启用超跑时，CPU使用率达到50％之后，其增长速度将与以前不同。 <br><br> 我编写了以下代码进行演示（这是一种综合案例，实际上结果会有所不同）： <br><br><div class="spoiler">  <b class="spoiler_title">脚本代码</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $concurrency = $_SERVER[<span class="hljs-string"><span class="hljs-string">'argv'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ?? <span class="hljs-number"><span class="hljs-number">1</span></span>; $hashes = <span class="hljs-number"><span class="hljs-number">100000000</span></span>; $chunkSize = intval($hashes / $concurrency); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $children = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $concurrency; $i++) {    $pid = pcntl_fork();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> === $pid) {        $first = $i * $chunkSize;        $last = ($i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * $chunkSize - <span class="hljs-number"><span class="hljs-number">1</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = $first; $j &lt; $last; $j++) {            $dummy = md5($j);        }        printf(<span class="hljs-string"><span class="hljs-string">"[%d]: %d hashes in %0.4f sec\n"</span></span>, $i, $last - $first, microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1);        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        $children[$pid] = <span class="hljs-number"><span class="hljs-number">1</span></span>;    } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count($children) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    $pid = pcntl_waitpid(<span class="hljs-number"><span class="hljs-number">-1</span></span>, $status);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($children[$pid]);    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a error pid=$pid"</span></span>);    } }</code> </pre> <br><br></div></div><br> 我的笔记本电脑上有两个物理核心。 使用不同的输入数据运行此代码，以便使用不同数量的并行C进程衡量其性能。 <br><br><div class="spoiler">  <b class="spoiler_title">测量结果</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/n5/3z/ev/n53zevyyvda4w4u-2xkjryqlj9m.png"><br></div></div><br> 我们绘制启动结果： <br><img src="https://habrastorage.org/webt/xg/iv/rn/xgivrnyyynb418fnr5muqfn0qba.png"><br>  <i>脚本性能取决于并行进程数</i> <br><br> 您需要注意的是： <br><br><ul><li> 当HT = on和HT = off时，C = 1和C = 2可以预期是相同的，当添加物理内核时，性能会翻倍； <br></li></ul><br><ul><li> 在C = 3时，HT的优势变得显而易见：对于HT =开启，我们可以获得额外的性能，而对于HT =断开，且C = 3起，它开始缓慢地下降。 <br></li></ul><br><ul><li> 在C = 4时，我们看到了HT的所有好处； 我们可以将生产力提高30％，但与此时的C = 2相比，CPU使用率从50％增加到100％。 <br></li></ul><br> 总计，从最高的CPU负载的50％来看，执行此脚本时，我们得到8,065 Mhash /秒，而达到100％-10,511 Mhash /秒。 这意味着在最高性能的大约50％处，我们将获得最大系统性能的8.065 / 10.511〜77％，实际上，储备中还剩下大约100％-77％= 23％，而不是看起来的50％。 <br><br> 规划时必须考虑这一事实。 <br><br><img src="https://habrastorage.org/webt/ru/6g/00/ru6g002t0ziv1pkppgqfjber80o.png"><br>  <i>主题的CPU使用率：最高数据以及实际发生的情况</i> <br><br><h1> 流量不一致 </h1><br> 除了超跑外，根据一天中的时间，一周中的某天，季节和其他频率，计划还会使交通不平衡变得更加复杂。 例如，对我们来说，高峰是周日晚上。 <br><br><img src="https://habrastorage.org/webt/eh/ks/58/ehks58pfn7sjva3c869i7cwj7fy.png"><br>  <i>每秒请求数，星期天晚上达到高峰</i> <br><br> 请求数量并非总是以明显的方式改变。 例如，用户可以以某种方式与其他用户进行交互：某些用户的活动可能会向其他用户生成推送/电子邮件，从而使他们参与此过程。 除此以外，还增加了宣传活动，这些活动增加了访问量，您还需要为此做好准备。 <br><br> 在计划时要考虑的所有这些因素也很重要：例如，要在高峰日建立趋势，并记住高峰增长可能存在的非线性。 <br><br><h1> 分析和测量工具 </h1><br> 假设我们发现存在性能问题，了解这不是数据库/服务/内容，但是我们决定优化代码。 为此，首先，我们需要一个探查器或一些工具来查找瓶颈，然后查看我们的优化结果。 <br><br> 不幸的是，对于今天的PHP，还没有一个好的通用工具。 <br><br><h2> 性能 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">perf</a>是Linux内核中内置的性能分析工具。 它是由单独的进程启动的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">采样</a>分析器，因此它不会直接给要分析的程序增加开销。 间接增加的开销被均匀地“抹上”，因此不会使测量失真。 <br><br> 尽管有其所有优点，但是perf只能与编译后的代码和JIT一起使用，而不能与“在虚拟机下”运行的代码一起使用。 因此，无法在其中分析PHP代码本身，但是您可以清楚地看到PHP在内部的工作方式，包括各种PHP扩展，以及在其上花费了多少资源。 <br><br> 例如，在性能方面，我们发现了几个瓶颈，包括压缩位置，我将在下面进行讨论。 <br><br> 一个例子： <br><br> <code>perf record --call-graph dwarf,65528 -F 99 -p $(pgrep php-cgi | paste -sd "," -) -- sleep 20 <br> perf report</code> <br> <br>  （如果进程和性能在不同的用户下执行，则性能需要从sudo下运行）。 <br><br><img src="https://habrastorage.org/webt/k9/vu/k6/k9vuk6sf37xhshipgvx2byw3xps.png"><br>  <i>PHP-FPM的Perf报告输出示例</i> <br><br><h2>  XHProf和XHProf聚合器 </h2><br>  XHProf是PHP的扩展，它在所有对函数/方法的调用周围放置计时器，并且还包含用于可视化由此获得的结果的工具。 与perf不同，它允许您使用PHP代码进行操作（同时，扩展中发生的事情是不可见的）。 <br><br> 缺点包括两点： <br><br><ul><li> 所有度量都是在单个请求的框架内收集的，因此它们不提供有关整个图片的信息； <br></li><li> 开销，尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不如</a>使用Xdebug时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大</a> ，但开销却很大，并且在某些情况下，结果会严重失真（调用函数的次数越多，且函数越简单，失真就越大）。 <br></li></ul><br> 这是说明最后一点的示例： <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ child1(); child2(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; $i++) { parent1(); }</code> </pre> <br><img src="https://habrastorage.org/webt/iw/7m/y6/iw7my6irzq5xg7_soy7sfkqpj7m.png"><br>  <i>演示的XHProf输出：parent1比child1和child2之和大几个数量级</i> <br><br> 可以看出，parent1（）的执行时间是child1（）+ child2（）的〜500倍，尽管实际上这些数字应大致相等，与main（）和parent1（）相同。 <br><br> 如果最后一个缺点很难克服，那么为了克服第一个缺点，我们为XHProf创建了一个附加程序，该附加程序汇总了不同请求的配置文件并可视化了汇总数据。 <br><br> 除了XHProf外，还有许多其他鲜为人知的探查器也基于类似原理工作。 它们具有类似的优点和缺点。 <br><br><h2> 平巴 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pinba</a>允许您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过</a>脚本（动作）和预设计时器来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">监视性能</a> 。 脚本上下文中的所有度量均是开箱即用的；为此，不需要其他步骤。 对于每个脚本和计时器，都会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行getrusage</a> ，因此我们确切地知道在特定代码段上花费了多少处理器时间（与采样分析器不同，该时间可能是网络，磁盘等）。  Pinba非常适合保存历史数据并获取一般和特定类型查询中的图片。 <br><br><img src="https://habrastorage.org/webt/od/x5/qr/odx5qryl0ufhceiuyjkytjhtm0c.png"><br>  <i>从Pinba获得的所有脚本的总体使用情况</i> <br><br> 缺点包括以下事实：配置代码的特定部分（而不是整个脚本）的计时器必须事先在代码中安排，以及存在可能使数据失真的开销（例如XHProf）。 <br><br><h2>  phpspy </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">phpspy</a>是一个相对较新的项目（在GitHub上的第一次提交是在半年前），它看起来很有希望，因此我们正在密切监视它。 <br><br> 从用户的角度来看，phpspy类似于perf：启动了并行进程，该进程会定期复制PHP进程的内存部分，对其进行解析并从那里接收堆栈跟踪和其他数据。 这是以相当特定的方式完成的。 为了最大程度地减少开销，phpspy不会停止PHP进程并在运行时直接复制内存。 这导致了一个事实，即探查器可能会获得不一致的状态，堆栈跟踪可能会中断。 但是phpspy可以检测到这一点并丢弃此类数据。 <br><br> 将来，使用此工具将有可能收集整个图片上的数据以及特定类型查询的配置文件。 <br><br><h2> 比较表 </h2><br> 为了构造工具之间的差异，让我们创建一个数据透视表： <br><br><img src="https://habrastorage.org/webt/bg/1a/bt/bg1abtxk-f8i5q83qm5teok3lbs.png"><br>  <i>比较器的主要功能比较</i> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">火焰图</a></i> <br><br><h1> 优化和方法 </h1><br> 使用这些工具，我们可以不断监控资源的性能和使用情况。 如上文所述，当不合理地使用它们或接近阈值时（对于CPU，我们经验性地选择55％的值，以便在增长时有一定的余量），解决问题的方法之一就是优化。 <br><br> 好吧，如果优化已经由其他人完成（例如PHP 7.0），则该版本比以前的版本生产力更高。 我们通常尝试使用现代技术和工具，包括及时更新PHP的最新版本。 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公共</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基准</a> ，PHP 7.2比PHP 7.1快5-12％。 但是，这种过渡给我们带来的好处要少得多。 <br><br> 一直以来，我们都实现了大量的优化。 不幸的是，它们大多数与我们的业务逻辑紧密相关。 我将讨论那些不仅与我们相关的内容，或者可以在我们的代码之外使用的思想和方法。 <br><br><h2>  Zlib压缩=&gt; zstd </h2><br> 我们对大的Memkey键使用压缩。 由于用于压缩/解压缩的额外CPU成本，这使我们可以减少三到四倍的存储空间。 我们为此使用zlib（我们与memekes一起使用的扩展名不同于PHP附带的扩展名，但官方的扩展名<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> zlib）。 <br><br> 在性能方面，生产是这样的： <br><br> <code>+    4.03%     0.22% php-cgi  libz.so.1.2.11      [.] inflate <br> +    3.38%     0.00% php-cgi  libz.so.1.2.11      [.] deflate</code> <br> <br>  7-8％的时间用于压缩/解压缩。 <br><br> 我们决定测试不同的级别和压缩算法。 事实证明，zstd在我们的数据上运行的速度几乎快了十倍，丢失了约1.1倍。 算法上的一个相当简单的变化为我们节省了大约7.5％的CPU（我记得，在我们的卷上，这相当于大约45个服务器）。 <br><br> 重要的是要理解，不同的压缩算法的性能比可以根据输入数据而有很大的不同。 有各种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较</a> ，但是最准确的说，只能使用实际示例进行估算。 <br><br><h2>  IS_ARRAY_IMMUTABLE作为很少修改的数据的存储库 </h2><br> 在执行实际任务时，您必须处理经常需要的数据，同时很少更改并且数据量有限。 我们有很多类似的数据，一个很好的例子是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拆分测试</a>的配置。 我们检查用户是否处于特定测试条件下，并以此为基础向用户展示实验性功能或正常功能（这几乎发生在每个请求中）。 在其他项目中，配置和各种目录可以是这样的示例：国家，城市，语言，类别，品牌等。 <br><br> 由于经常请求此类数据，因此它们的接收可能给应用程序本身以及存储此数据的服务造成明显的额外负担。 后一个问题可以通过使用APCu解决，例如，APCu使用运行PHP-FPM的同一台计算机的内存作为存储。 但是即使这样： <br><br><ul><li> 会有序列化/反序列化的费用； <br></li><li> 您需要在更改时以某种方式使数据无效； <br></li><li> 与仅在PHP中访问变量相比，存在一些开销。 <br></li></ul><br>  PHP 7.0引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IS_ARRAY_IMMUTABLE</a>优化。 如果声明一个数组，所有元素在编译时都是已知的，则将对其进行处理并将其放入OPCache内存一次，PHP-FPM工作人员将引用此共享内存，而无需花费时间来尝试更改。 还可以得出结论，无论大小如何（通常为〜1微秒），包含此类数组都将花费固定的时间。 <br><br> 为了进行比较：通过include和apcu_fetch获得10,000个元素的数组的时间示例： <br><br><pre> <code class="php hljs">$t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'test-incl-1.php'</span></span>; $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"include (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); $t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = apcu_fetch(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"apcu_fetch (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//include (10000): 1 microsec //apcu_fetch (10000): 792 microsec</span></span></code> </pre><br> 如果查看生成的操作码，则检查是否已应用此优化可能非常简单： <br><br><pre> <code class="php hljs">$ cat immutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val1'</span></span>, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ cat mutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; \SomeClass::CONST_1, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ php -d opcache.enable=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> immutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">1</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">0</span></span>) ; (after optimizer) ; /home/ubuntu/immutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(...) $ php -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> mutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">5</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">2</span></span>) ; (after optimizer) ; /home/ubuntu/mutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T1 = FETCH_CLASS_CONSTANT string(<span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"CONST_1"</span></span>) L1 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T0 = INIT_ARRAY <span class="hljs-number"><span class="hljs-number">3</span></span> T1 string(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) L2 (<span class="hljs-number"><span class="hljs-number">5</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val2"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>) L3 (<span class="hljs-number"><span class="hljs-number">6</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>) L4 (<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T0</code> </pre><br> 在第一种情况下，很明显文件中只有一个操作码-完成数组的返回。 在第二种情况下，每次执行此文件时，都会逐个元素地形成。 <br><br> 因此，可以以在运行时不需要进一步转换的形式生成结构。 例如，您不必为每次自动加载而每次都用符号“ _”和“ \”来分解类名，而是可以预先生成对应关系图“ Class =&gt; Path”。 在这种情况下，转换功能将简化为单个哈希表调用。 如果启用了<a href="">optimize-autoloader选项，</a>则Composer会进行这种优化。 <br><br> 对于此类数据的无效化，您无需做任何特别的事情-PHP本身将在更改时重新编译文件，就像在常规代码部署中一样。 您一定不能忘记的唯一缺点：如果文件很大，则更改后的第一个请求将导致重新编译，这可能会花费很多时间。 <br><br><h2> 性能包括/要求 </h2><br> 与静态数组示例不同，使用类和函数声明附加文件不是那么快。 尽管有OPCache，PHP引擎仍必须将它们复制到进程内存中，以递归方式连接依赖关系，最终每个文件可能要花费数百微秒甚至毫秒。 <br><br> 如果在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symfony 4.1</a>上创建一个新的空项目，并将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">get_included_files（）作为操作的</a>第一行，则可以看到已经连接了310个文件。 在实际的项目中，每个请求的数量可以达到数千。 值得注意以下几点。 <br><br>  <b>缺乏自动焊接功能</b> <br><br> 有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能自动加载RFC</a> ，但是几年来还没有开发。 因此，如果Composer中的依赖项在类之外定义了函数，并且用户应该可以访问这些函数，则可以通过<a href="">将</a>具有这些函数<a href="">的</a>文件<a href="">强制连接</a>到自动加载器的每个初始化来完成此操作。 <br><br> 例如，从composer.json中删除一个依赖项，该依赖项声明了许多功能，并且很容易被一百行代码替换，我们赢得了百分之几的CPU。 <br><br>  <b>自动加载器的调用次数比看起来要多。</b> <br><br> 为了演示这个想法，请使用一个类创建这样的文件： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">D</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC1 = \E::E1;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC2 = \F::F1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as3 = \G::G1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as4 = \H::H1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a5 = \I::I1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a6 = \J::J1;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\K $k = null)</span></span></span><span class="hljs-function"> </span></span>{}   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\L $l = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\M $m = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\N $n = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\P $p = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>注册自动加载器：</b> <br><br><pre> <code class="php hljs">spl_autoload_register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Including $name...\n"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"$name.php"</span></span>; });</code> </pre> <br>  <b>我们将为此类提供一些用例：</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'A.php'</span></span> Including B... Including D... Including C... \A::AC1 Including A... Including B... Including D... Including C... Including E... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A() Including A... Including B... Including D... Including C... Including E... Including F... Including G... Including H... Including I... Including J...</code> </pre><br> 您可能会注意到，当我们以某种方式连接该类但不创建其实例时，将连接父类，接口和特征。 对于作为解析连接的所有文件，将以递归方式完成此操作。 <br><br> 创建实例时，将向其添加所有常量和字段的解析度，从而导致为此所需的所有文件的连接，从而又将导致新连接的类的特征，父级和接口的递归连接。 <br><br><img src="https://habrastorage.org/webt/8a/qq/2t/8aqq2tf_8j-mixi8p_ydoypo-yo.png"><br>  <i>连接相关类以用于实例创建过程和其他情况</i> <br><br> 没有通用的解决方案来解决这个问题，您只需要记住它并监视类之间的连接即可：一行可以拉动数百个文件的连接。 <br><br>  <b>OPCache设置</b> <br><br> 如果使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原子部署</a>方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过更改</a> PHP创建者Rasmus Lerdorf提出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的符号链接来</a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原子部署</a>方法，那么要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解决</a>将符号链接“粘贴”在旧版本上的问题，您必须包含opcache.revalidate_path，例如，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文中</a>有关此建议的建议中，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>推荐的.Ru集团。 <br><br> 问题在于，此选项会显着（平均一两次半到两次）增加包含每个文件的时间。 总体而言，这可能会消耗大量资源（在我们的示例中，禁用此选项可获得7-9％的收益）。 <br><br> 要禁用它，您需要做两件事： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使</a> Web服务器解析符号链接； <br></li><li> 停止沿着包含符号链接的路径连接PHP脚本内的文件，或强制它们通过readlink（）或realpath（）。 <br></li></ul><br> 如果所有文件都用Composer自动加载器连接，则第二项将在第一个项完成后自动执行：omposer使用__DIR__常量，它将被正确解析。 <br><br>  OPCache具有更多选项，可以提高性能以换取灵活性。 您可以在我上面提到的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>中了解有关此内容的更多信息。 <br><br> 尽管进行了所有这些优化，include仍然不是免费的。 为了解决这个问题，PHP 7.4计划添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">preload</a> 。 <br><br><h2>  APCu锁 </h2><br> 尽管这里我们不讨论数据库和服务，但是代码中也可能发生各种类型的锁，这增加了脚本的执行时间。 <br><br> 随着请求的增加，我们注意到高峰时段的响应速度急剧下降。 在找出原因之后，事实证明，尽管APCu是获取数据的最快方法（与Memcache，Redis和其他外部存储相比），但在频繁覆盖相同密钥的情况下，它也可以缓慢运行。 <br><br><img src="https://habrastorage.org/webt/hs/05/gc/hs05gcwvqozrqews1ewwtsskdyo.png"><br>  <i>每秒请求数和运行时间：10月16日和17日达到峰值</i> <br><br> 当使用APCu作为缓存时，此问题并不那么重要，因为缓存通常涉及罕见的写入和频繁的读取。 但是某些任务和算法（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Circuit Breaker</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用PHP实现</a> ））也涉及频繁记录，这会导致锁定。 <br><br> 对于此问题，还没有通用的解决方案，但是在使用断路器的情况下，例如可以通过将其放入安装在装有PHP的计算机上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单独服务中</a>来解决。 <br><br><h2> 批处理 </h2><br> 即使不考虑include，通常查询的大部分时间仍会花在初始化上：框架（例如，构建DI容器并初始化其所有依赖项，路由，执行所有侦听器），引发会话，User等。进一步。 <br><br> 如果您的后端是用于某些内容的内部API，则对于某些请求，可以将客户端上的某些请求打包并作为单个请求发送。 在这种情况下，将对多个请求执行一次初始化。 <br><br>      ,   ,    .    -  ,          .       . <br><br><h2>    </h2><br>    Badoo   ,     .    PHP-FPM,      CPU,   ,            ,    :        IO, CPU  . <br><br>      PHP-FPM    —  ,          PHP. <br><br>         (CPU, IO),    . , ,       ,  ,    -     ,        .        ,     .   ,  ,      . <br><br><h1> 结论 </h1><br>        .                    PHP     . <br><br>  : <br><br><ul><li>       ; <br></li><li>     ; <br></li><li>  -  ,  :  ,    ; <br></li><li>   :       (, ,  ); <br></li><li>    :     ; <br></li><li>   , OPCache    PHP,  , ,   ; <br></li><li>    :       (, ,   PHP 7.2   ,   ); <br></li><li>    : ,        . <br></li></ul><br>       ? <br><br> 感谢您的关注！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430722/">https://habr.com/ru/post/zh-CN430722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430710/index.html">如果黑色星期五是明天并且您的服务器未准备好怎么办</a></li>
<li><a href="../zh-CN430712/index.html">NeurIPS：如何征服最佳ML会议</a></li>
<li><a href="../zh-CN430714/index.html">VMware收购Heptio-对Kubernetes意味着什么</a></li>
<li><a href="../zh-CN430718/index.html">使用云视频监控对哪些对象有价值？</a></li>
<li><a href="../zh-CN430720/index.html">英特尔实感D435i：较小的更新和较短的历史题外话</a></li>
<li><a href="../zh-CN430724/index.html">DEFCON 21. DNS会议可能对您的健康有害。 第一部分</a></li>
<li><a href="../zh-CN430728/index.html">教我提供反馈</a></li>
<li><a href="../zh-CN430730/index.html">R＆D ABBYY做什么：NLP高级研究小组</a></li>
<li><a href="../zh-CN430732/index.html">关于划分和TI的问题</a></li>
<li><a href="../zh-CN430734/index.html">智能更新与智能合约</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>