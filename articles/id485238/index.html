<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚕️ 🏠 💜 Kami menggunakan penyeleksi redux terlalu banyak 👩🏾‍⚖️ ℹ️ 📶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya melihat file {domain} /selectors.js di proyek React / Redux besar yang saya kerjakan, saya sering melihat daftar penyeleksi redux yang bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menggunakan penyeleksi redux terlalu banyak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485238/"><p>  Ketika saya melihat file {domain} /selectors.js di proyek React / Redux besar yang saya kerjakan, saya sering melihat daftar penyeleksi redux yang besar seperti ini: </p><br><pre><code class="plaintext hljs">getUsers(state) getUser(id)(state) getUserId(id)(state) getUserFirstName(id)(state) getUserLastName(id)(state) getUserEmailSelector(id)(state) getUserFullName(id)(state) …</code> </pre> <br><p>  Pada pandangan pertama, penggunaan penyeleksi tidak terlihat aneh, tetapi dengan pengalaman kita mulai memahami bahwa mungkin ada terlalu banyak penyeleksi.  Dan sepertinya kita selamat sampai titik ini. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/f62/2b9/e99/f622b9e99db638c8d9405beb722cd4e2.jpg" alt="gambar"><a name="habracut"></a><br><br><h2 id="redux-i-selektory">  Redux dan penyeleksi </h2><br><p>  Mari kita lihat Redux.  Apa dia, kenapa?  Setelah membaca redux.js.org, kami memahami bahwa Redux adalah "wadah yang dapat diprediksi untuk menyimpan status aplikasi JavaScript" </p><br><p>  Saat menggunakan Redux, kami disarankan untuk menggunakan penyeleksi, meskipun mereka opsional.  Penyeleksi hanya pengambil untuk mendapatkan beberapa bagian dari seluruh negara, yaitu  fungsi dari form <code>(State) =&gt; SubState</code> .  Biasanya kami menulis penyeleksi sehingga kami tidak dapat mengakses negara secara langsung, dan kemudian kami dapat menggabungkan atau memotret hasil penyeleksi ini.  Kedengarannya masuk akal. </p><br><h2 id="silno-pogruzhayas-v-selektory">  Sangat tenggelam dalam pemilih </h2><br><p>  Daftar pemilih yang saya kutip dalam pengantar artikel ini adalah karakteristik dari kode yang dibuat terburu-buru. </p><br><p>  Bayangkan kami memiliki model Pengguna dan kami ingin menambahkan bidang email baru ke dalamnya.  Kami memiliki komponen yang mengharapkan input <code>firstName</code> dan <code>lastName</code> , dan sekarang akan menunggu <code>email</code> lain.  Mengikuti logika dalam kode dengan penyeleksi, memperkenalkan bidang email baru, penulis harus menambahkan pemilih <code>getUserEmailSelector</code> dan menggunakannya untuk meneruskan bidang ini ke komponen.  Bingo! </p><br><p>  Tapi apakah bingo?  Dan jika kita mendapatkan pemilih lain, mana yang lebih rumit?  Kami akan menggabungkannya dengan penyeleksi lain, dan mungkin kami akan sampai pada gambar ini: </p><br><pre> <code class="plaintext hljs">const getUsers = (state) =&gt; state.users; const getUser = (id) =&gt; (state) =&gt; getUsers(state)[id]; const getUserEmailSelector = (id) =&gt; (state) =&gt; getUser(id)(state).email;</code> </pre> <br><p>  Pertanyaan pertama muncul: apa yang harus <code>getUserEmailSelector</code> pemilih <code>getUserEmailSelector</code> jika pemilih <code>getUser</code> kembali tanpa <code>undefined</code> ?  Dan ini adalah situasi yang mungkin - bug, refactoring, warisan - semuanya dapat mengarah padanya.  Secara umum, tidak pernah menjadi tugas penyeleksi untuk menangani kesalahan atau memberikan nilai default. </p><br><p>  Masalah kedua muncul dengan menguji penyeleksi tersebut.  Jika kita ingin menutupinya dengan unit test, kita akan memerlukan data tiruan yang identik dengan data dari produksi.  Kami harus menggunakan data tiruan seluruh negara bagian (karena negara bagian tidak dapat tidak konsisten dalam produksi) untuk pemilih ini saja.  Ini, tergantung pada arsitektur aplikasi kita, bisa sangat tidak nyaman - menyeret data ke dalam pengujian. </p><br><p>  Mari kita asumsikan bahwa kita menulis dan menguji pemilih <code>getUserEmailSelector</code> seperti dijelaskan di atas.  Kami menggunakannya dan menghubungkan komponen ke negara: </p><br><pre> <code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({ firstName: getUserFirstName(ownProps.userId)(state), lastName: getUserLastName(ownProps.userId)(state), //   email: getUserEmailName(ownProps.userId)(state), })</code> </pre> <br><p>  Mengikuti logika di atas, kami mendapatkan sekelompok penyeleksi yang berada di awal artikel. <br>  <strong>Kami sudah terlalu jauh.</strong>  <strong>Sebagai hasilnya, kami menulis pseudo-API untuk entitas Pengguna.</strong>  <strong>API ini tidak dapat digunakan di luar konteks Redux karena membutuhkan pemeran status lengkap.</strong>  <strong>Selain itu, API ini sulit diperluas - saat menambahkan bidang baru ke entitas Pengguna, kita harus membuat penyeleksi baru, menambahkannya ke mapStateToProps, menulis lebih banyak kode boilerplate.</strong> </p><br><h2 id="a-mozhet-stoit-obraschatsya-k-polyam-suschnosti-napryamuyu">  Atau mungkin Anda harus mengakses bidang entitas secara langsung? </h2><br><p>  Jika masalahnya hanya kita memiliki terlalu banyak penyeleksi - mungkin kita hanya menggunakan getUser dan mengakses properti entitas yang kita butuhkan secara langsung? </p><br><pre> <code class="plaintext hljs">const user = getUser(id)(state); const email = user.email;</code> </pre> <br><p>  Pendekatan ini memecahkan masalah penulisan dan mendukung sejumlah besar penyeleksi, tetapi menciptakan masalah lain.  Jika kita perlu mengubah model Pengguna, kita juga perlu memeriksa semua tempat di mana <code>user.email</code> ( <em>catatan penerjemah</em> atau bidang lain yang kita ubah).  Dengan sejumlah besar kode dalam proyek, ini bisa menjadi tugas yang sulit dan menyulitkan bahkan sedikit refactoring.  Ketika kami memiliki pemilih, itu melindungi kami dari konsekuensi perubahan, karena  memikul tanggung jawab bekerja dengan model dan kode menggunakan pemilih tidak tahu apa-apa tentang model. </p><br><p>  Akses langsung dapat dimengerti.  Tetapi bagaimana dengan menerima data yang dihitung?  Misalnya, dengan nama pengguna lengkap, yang merupakan gabungan dari nama depan dan belakang?  Perlu menggali lebih lanjut ... </p><br><img src="https://habrastorage.org/getpro/habr/post_images/fc4/5d5/df3/fc45d5df378821827b32e53402d6a041.png" alt="gambar"><br><br><h2 id="model-predmetnoy-oblasti---vo-glave-redux---vtorichen">  Model domain menuju.  Redux - Sekunder </h2><br><p>  Anda dapat melihat gambar ini dengan menjawab dua pertanyaan: </p><br><ul><li>  Bagaimana kita mendefinisikan model domain kita? </li><li>  Bagaimana kita menyimpan data?  (manajemen negara, untuk itu kami menggunakan redux * translator's note * bahwa layer persistence disebut dalam DDD) </li></ul><br><p>  Menjawab pertanyaan "Bagaimana kita mendefinisikan model domain" (dalam kasus kami, Pengguna), mari kita abstrak dari redux dan memutuskan apa "pengguna" itu dan API apa yang diperlukan untuk berinteraksi dengannya? </p><br><pre> <code class="plaintext hljs">// api.ts type User = { id: string, firstName: string, lastName: string, email: string, ... } const getFirstName = (user: User) =&gt; user.firstName; const getLastName = (user: User) =&gt; user.lastName; const getFullName = (user: User) =&gt; `${user.firstName} ${user.lastName}`; const getEmail = (user: User) =&gt; user.email; ... const createUser = (id: string, firstName: string, ...) =&gt; User;</code> </pre> <br><p>  Akan bagus jika kita selalu menggunakan API ini dan menganggap model Pengguna tidak dapat diakses di luar file api.ts.  Ini berarti bahwa kita tidak akan pernah beralih langsung ke bidang entitas sejak saat itu  kode yang menggunakan API bahkan tidak tahu entitas mana yang memiliki bidang. </p><br><p>  Sekarang kita bisa kembali ke Redux dan menyelesaikan masalah yang hanya berkaitan dengan negara: </p><br><ul><li>  Tempat apa yang ditempati pengguna dalam artikel kami? </li><li>  Bagaimana seharusnya kita menyimpan pengguna?  Daftar?  Kamus (nilai kunci)?  Bagaimana lagi? </li><li>  Bagaimana kita akan mendapatkan instance Pengguna dari negara?  Haruskah memoisasi digunakan?  (dalam konteks pemilih getUser) </li></ul><br><h2 id="malenkoe-api-s-bolshimi-preimuschestvami">  API kecil dengan manfaat besar </h2><br><p>  Menerapkan prinsip berbagi tanggung jawab antara bidang subjek dan negara bagian, kami mendapatkan banyak bonus. </p><br><p>  Model domain yang didokumentasikan dengan baik (Model pengguna dan API-nya) di file api.ts.  Ini cocok untuk pengujian, sebagai  tidak memiliki dependensi.  Kita dapat mengekstrak model dan API ke perpustakaan untuk digunakan kembali di aplikasi lain. </p><br><p>  Kita dapat dengan mudah menggabungkan fungsi API sebagai penyeleksi, yang merupakan keunggulan yang tak tertandingi dibandingkan akses langsung ke properti.  Selain itu, antarmuka data kami sekarang mudah dipelihara di masa mendatang - kami dapat dengan mudah mengubah model Pengguna tanpa mengubah kode yang menggunakannya. </p><br><p>  Tidak ada keajaiban terjadi dengan API, itu masih terlihat jelas.  API menyerupai apa yang dilakukan dengan menggunakan penyeleksi, tetapi memiliki satu perbedaan utama: tidak memerlukan seluruh keadaan, tidak perlu mendukung status penuh aplikasi untuk pengujian lagi - API tidak ada hubungannya dengan Redux dan kode boilerplate-nya. </p><br><p>  Alat peraga komponen telah menjadi lebih bersih.  Alih-alih menunggu input Nama depan, nama belakang, dan email menjadi input, komponen menerima instance Pengguna dan secara internal menggunakan API-nya untuk mengakses data yang diperlukan.  Ternyata kita hanya membutuhkan satu pemilih - getUser. </p><br><p>  Ada manfaat untuk reduksi dan middleware dari API semacam itu.  Inti dari manfaatnya adalah pertama-tama Anda bisa mendapatkan instance dari Pengguna, menangani nilai-nilai yang hilang di dalamnya, memproses atau mencegah semua kesalahan, dan kemudian menggunakan metode API.  Ini lebih baik daripada menggunakan setiap bidang individu menggunakan penyeleksi dalam isolasi dari area subjek.  Dengan demikian, Redux benar-benar menjadi "wadah yang dapat diprediksi" dan tidak lagi menjadi objek "ilahi" dengan pengetahuan tentang segalanya. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dengan niat baik (baca di sini - penyeleksi) jalan menuju neraka sudah diaspal: kami tidak ingin mengakses bidang entitas secara langsung dan membuat penyeleksi terpisah untuk ini. </p><br><p>  Meskipun gagasan penyeleksi itu sendiri bagus, terlalu sering membuatnya sulit untuk mempertahankan kode kami. </p><br><p>  Solusi yang dijelaskan dalam artikel ini mengusulkan untuk menyelesaikan masalah dalam dua tahap - pertama menggambarkan model domain dan API-nya, kemudian berurusan dengan Redux (penyimpanan data, penyeleksi).  Dengan cara ini Anda akan menulis kode yang lebih baik dan lebih kecil - Anda hanya perlu satu pemilih untuk membuat API yang lebih fleksibel dan skalabel. </p><br><h4 id="primechaniya-perevodchika">  Catatan Penerjemah </h4><br><ol><li>  Saya menggunakan kata negara, karena sepertinya kata itu telah dengan kuat memasuki perbendaharaan kata para pengembang berbahasa Rusia. </li><li>  Penulis menggunakan kata-kata hulu / hilir yang berarti "kode tingkat tinggi / tingkat rendah" (jika menurut Martin) atau "kode yang digunakan di bawah / kode di bawah ini yang menggunakan apa yang tertulis di atas", tetapi tidak benar untuk mengetahui cara menggunakan ini dalam terjemahan Karena itu, saya dapat menghibur diri sendiri dengan berusaha tidak mengecewakan akal sehat. </li></ol><br><p>  Saya dengan senang hati akan menerima komentar dan saran untuk koreksi di PM dan memperbaikinya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485238/">https://habr.com/ru/post/id485238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485226/index.html">Pengembangan UI: siapa yang harus didengarkan - diri sendiri atau pengguna?</a></li>
<li><a href="../id485228/index.html">Apa itu pembelajaran aktif?</a></li>
<li><a href="../id485230/index.html">5 Buku Teratas untuk Dibaca untuk Perancang Gerakan</a></li>
<li><a href="../id485232/index.html">Pembelajaran mesin otomatis: ketika para ilmuwan data tidak akan diperlukan</a></li>
<li><a href="../id485236/index.html">File konfigurasi python</a></li>
<li><a href="../id485240/index.html">Layout go pet project di VPS</a></li>
<li><a href="../id485256/index.html">Ivan Lilekvist dan Kim Dotkom, sebuah wawancara besar: kisah Megaupload, ekstradisi ke Amerika Serikat, kebebasan, bitcoin. Bagian 1</a></li>
<li><a href="../id485260/index.html">13 Kesalahan Umum untuk Analis Bisnis Awal</a></li>
<li><a href="../id485264/index.html">Seperti apa bentuk arsip zip dan apa yang bisa kita lakukan dengannya. Bagian 4 - Membaca arsip</a></li>
<li><a href="../id485266/index.html">Habr Contest: pemenang dari kontes ide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>