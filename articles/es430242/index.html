<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥ üë®‚Äçüë®‚Äçüë¶ üò´ OpenSceneGraph: nodos de grupo, nodos de transformaci√≥n y nodos de conmutaci√≥n üíÜüèø ‚óºÔ∏è üë©üèΩ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Cuando se dibuja un punto, l√≠nea o pol√≠gono complejo en un mundo tridimensional, el resultado final finalmente se mostrar√° en una panta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: nodos de grupo, nodos de transformaci√≥n y nodos de conmutaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430242/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Cuando se dibuja un punto, l√≠nea o pol√≠gono complejo en un mundo tridimensional, el resultado final finalmente se mostrar√° en una pantalla plana y bidimensional.  En consecuencia, los objetos tridimensionales pasan por una cierta ruta de transformaci√≥n, convirti√©ndose en un conjunto de p√≠xeles que se muestran en una ventana bidimensional. <br><br>  El desarrollo de herramientas de software que implementan gr√°ficos tridimensionales ha llegado, independientemente de cu√°l elija, a aproximadamente el mismo concepto de descripciones matem√°ticas y algor√≠tmicas de las transformaciones anteriores.  Ideol√≥gicamente, las API gr√°ficas "limpias" como OpenGL, y los motores de juegos geniales como Unity y Unreal, utilizan mecanismos similares para describir la transformaci√≥n de una escena tridimensional.  OpenSceneGraph no es una excepci√≥n. <br><br>  En este art√≠culo, revisaremos los mecanismos para agrupar y transformar objetos tridimensionales en OSG. <br><a name="habracut"></a><br><h1>  1. Matriz modelo, matriz de vista y matriz de proyecci√≥n </h1><br>  Tres matrices b√°sicas involucradas en la transformaci√≥n de coordenadas est√°n involucradas en la transformaci√≥n entre diferentes sistemas de coordenadas.  A menudo, en t√©rminos de OpenGL, se denominan <em>matriz</em> <em>modelo</em> <em>, matriz de vista</em> y <em>matriz de proyecci√≥n</em> . <br><br>  La matriz del modelo se usa para describir la ubicaci√≥n del objeto en el mundo 3D.  Convierte los v√©rtices del <em>sistema de coordenadas local del objeto</em> al <em>sistema de coordenadas mundial</em> .  Por cierto, todos los sistemas de coordenadas en OSG son <em>diestros</em> . <br><br>  El siguiente paso es la transformaci√≥n de las coordenadas mundiales en un espacio de vista, realizado utilizando la matriz de vista.  Supongamos que tenemos una c√°mara ubicada en el origen del sistema de coordenadas mundial.  La matriz inversa a la matriz de transformaci√≥n de la c√°mara se usa realmente como una matriz de vista.  En un sistema de coordenadas diestro, OpenGL, por defecto, siempre define una c√°mara ubicada en el punto (0, 0, 0) del sistema de coordenadas global y dirigida a lo largo de la direcci√≥n negativa del eje Z. <br><br>  Observo que en OpenGL la matriz del modelo y la matriz de vista no est√°n separadas.  Sin embargo, la matriz de vista de modelo se determina all√≠, lo que convierte las coordenadas locales del objeto en las coordenadas del espacio de vista.  Esta matriz, de hecho, es el producto de la matriz modelo y la matriz de la forma.  Por lo tanto, la transformaci√≥n de un v√©rtice V de coordenadas locales a un espacio de la forma se puede escribir condicionalmente como el producto <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  La siguiente tarea importante es determinar c√≥mo se proyectar√°n los objetos 3D en el plano de la pantalla y calcular la llamada <em>pir√°mide de recorte</em> , un √°rea de espacio que contiene objetos que se mostrar√°n en la pantalla.  La matriz de proyecci√≥n se utiliza para especificar la pir√°mide de recorte definida en el espacio mundial por seis planos: izquierdo, derecho, inferior, superior, cercano y lejano.  OpenGL proporciona la funci√≥n gluPerapective (), que le permite especificar una pir√°mide de recorte y una forma de proyectar un mundo tridimensional en un plano. <br><br>  El sistema de coordenadas obtenido despu√©s de las transformaciones anteriores se denomina <em>sistema de coordenadas normalizado del dispositivo</em> , tiene un rango de coordenadas de -1 a 1 en cada eje y es zurdo.  Y, como √∫ltimo paso, los datos recibidos se proyectan en el puerto de visualizaci√≥n (ventana gr√°fica) de la ventana, definido por el rect√°ngulo del √°rea del cliente de la ventana.  Despu√©s de eso, el mundo 3D aparece en nuestra pantalla 2D.  El valor final de las coordenadas de pantalla de los v√©rtices Vs puede expresarse mediante la siguiente transformaci√≥n <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  o <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  donde MVPW es la matriz de transformaci√≥n equivalente igual al producto de tres matrices: matrices de vista de modelo, matrices de proyecci√≥n y matrices de ventana. <br><br>  Vs en esta situaci√≥n es un vector tridimensional que determina la posici√≥n de un p√≠xel 2D con un valor de profundidad.  Al invertir la operaci√≥n de transformaci√≥n de coordenadas, obtenemos una l√≠nea en el espacio tridimensional.  Por lo tanto, un punto 2D puede considerarse como dos puntos: uno en el cercano (Zs = 0), el otro en el plano de recorte lejano (Zs = 1).  Las coordenadas de estos puntos en el espacio tridimensional. <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  donde invMVPW es el inverso de MVPW. <br><br>  En todos los ejemplos discutidos hasta ahora, creamos un √∫nico objeto tridimensional en las escenas.  En estos ejemplos, las coordenadas locales del objeto siempre coincidieron con las coordenadas globales globales.  Ahora es el momento de hablar sobre las herramientas que le permiten colocar muchos objetos en la escena y cambiar su posici√≥n en el espacio. <br><br><h1>  2. Agrupar nodos </h1><br>  La clase osg :: Group es el llamado <em>nodo</em> de <em>grupo</em> de un gr√°fico de escena en OSG.  Puede tener cualquier n√∫mero de nodos secundarios, incluidos los nodos hoja de geometr√≠a u otros nodos de grupo.  Estos son los nodos m√°s utilizados con amplia funcionalidad. <br><br>  La clase osg :: Group se deriva de la clase osg :: Node y, en consecuencia, hereda de la clase osg :: Referenced.  osg :: Group contiene una lista de nodos secundarios, donde cada nodo secundario est√° controlado por un puntero inteligente.  Esto asegura que no haya p√©rdidas de memoria cuando se conecta en cascada una rama de un √°rbol de escena.  Esta clase proporciona al desarrollador una serie de m√©todos p√∫blicos. <br><ol><li>  addChild (): agrega el nodo al final de la lista de nodos secundarios.  Por otro lado, existe el m√©todo insertChild (), que coloca el nodo secundario en una posici√≥n espec√≠fica en la lista, que se especifica mediante un √≠ndice entero o un puntero al nodo, pasado como un par√°metro. <br></li><li>  removeChild () y removeChildren (): elimina un solo nodo o grupo de nodos. <br></li><li>  getChild (): obtener un puntero a un nodo por su √≠ndice en la lista <br></li><li>  getNumChildren (): obtiene el n√∫mero de nodos secundarios asociados a este grupo. <br></li></ol><br><h2>  Administraci√≥n del nodo principal </h2><br>  Como ya sabemos, la clase osg :: Group gestiona grupos de sus objetos secundarios, entre los cuales puede haber instancias osg :: Geode que controlan la geometr√≠a de los objetos de escena.  Ambas clases tienen una interfaz para administrar nodos primarios. <br><br>  OSG permite que los nodos de escena tengan m√∫ltiples nodos principales (hablaremos de esto alg√∫n d√≠a m√°s tarde).  Mientras tanto, veremos los m√©todos definidos en osg :: Node que se utilizan para manipular los nodos principales: <br><ol><li>  getParent (): devuelve un puntero de tipo osg :: Group que contiene una lista de nodos principales. <br></li><li>  getNumParants (): devuelve el n√∫mero de nodos principales. <br></li><li>  getParentalNodePath (): devuelve todas las rutas posibles al nodo ra√≠z de la escena desde el nodo actual.  Devuelve una lista de variables de tipo osg :: NodePath. <br></li></ol><br>  osg :: NodePath es un std :: vector de punteros a nodos de escena. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  Por ejemplo, para la escena que se muestra en la figura, el siguiente c√≥digo <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  devolver√° nodos Root, Child1, Child2. <br><br>  No debe utilizar mecanismos de administraci√≥n de memoria para hacer referencia a los nodos principales.  Cuando se elimina un nodo principal, todos los nodos secundarios se eliminan autom√°ticamente, lo que puede provocar un bloqueo de la aplicaci√≥n. <br><br><h1>  3. Agregar m√∫ltiples modelos al √°rbol de escenas </h1><br>  Ilustramos el mecanismo para usar grupos con el siguiente ejemplo. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de grupo completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Fundamentalmente, el ejemplo difiere de todos los anteriores en que cargamos dos modelos tridimensionales, y para agregarlos a la escena, creamos un nodo ra√≠z grupal y le agregamos nuestros modelos como nodos secundarios <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  Como resultado, obtenemos una escena que consta de dos modelos: un avi√≥n y una divertida vaca espejo.  Por cierto, una vaca espejo no ser√° espejo a menos que copie su textura de OpenSceneGraph-Data / Images / reflect.rgb en el directorio data / Images de nuestro proyecto. <br><br>  La clase osg :: Group puede aceptar cualquier tipo de nodos como hijos, incluidos los nodos de su tipo.  Por el contrario, la clase osg :: Geode no contiene ning√∫n nodo secundario en absoluto; es un nodo terminal que contiene la geometr√≠a del objeto de escena.  Este hecho es conveniente cuando se pregunta si el nodo es un nodo de tipo osg :: Group u otro tipo de derivado de osg :: Node.  Veamos un peque√±o ejemplo. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  El valor devuelto por la funci√≥n osgDB :: readNodeFile () siempre es del tipo osg :: Node *, pero se puede convertir a su descendiente osg :: Group *.  Si el nodo del modelo Cessna es un nodo de grupo, la conversi√≥n tendr√° √©xito; de lo contrario, la conversi√≥n devolver√° NULL. <br><br>  Tambi√©n puedes realizar el mismo truco que funciona en la mayor√≠a de los compiladores <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  En lugares de c√≥digo de rendimiento cr√≠tico, es mejor usar m√©todos de conversi√≥n especiales <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. Nodos de transformaci√≥n. </h1><br>  Los nodos Osg :: Group no pueden realizar ninguna transformaci√≥n, excepto la capacidad de ir a sus nodos secundarios.  OSG proporciona la clase osg :: Transform para el movimiento de geometr√≠a espacial.  Esta clase es una sucesora de la clase osg :: Group, pero tambi√©n es abstracta: en la pr√°ctica, se utilizan sus herederos, que implementan diversas transformaciones espaciales de la geometr√≠a.  Al recorrer el gr√°fico de escena, el nodo osg :: Transform agrega su transformaci√≥n a la matriz de transformaci√≥n actual de OpenGL.  Esto es equivalente a multiplicar las matrices de transformaci√≥n de OpenGL por el comando glMultMatrix () <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  Este ejemplo de gr√°fico de escena se puede traducir al siguiente c√≥digo de OpenGL <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  Podemos decir que la posici√≥n de Geode1 se establece en el sistema de coordenadas Transform1, y la posici√≥n de Geode2 se establece en el sistema de coordenadas Transform2, desplazamiento relativo a Transform1.  Al mismo tiempo, el posicionamiento en coordenadas absolutas se puede habilitar en OSG, lo que conducir√° al comportamiento del objeto, equivalente al resultado del comando glGlobalMatrix () OpenGL <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  Puede volver al modo de posicionamiento relativo <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. El concepto de una matriz de transformaci√≥n de coordenadas. </h1><br>  El tipo osg :: Matrix es un tipo OSG b√°sico no controlado por punteros inteligentes.  Proporciona una interfaz para operaciones en matrices 4x4 que describen la transformaci√≥n de coordenadas, como mover, rotar, escalar y calcular proyecciones.  La matriz se puede especificar expl√≠citamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  La clase osg :: Matrix proporciona los siguientes m√©todos p√∫blicos: <br><br><ol><li>  postMult () y operator * (): la multiplicaci√≥n correcta de la matriz actual por la matriz o el vector pasado como par√°metro.  El m√©todo preMult () realiza la multiplicaci√≥n izquierda. <br></li><li>  makeTranslate (), makeRotate () y makeScale (): restablece la matriz actual y crea una matriz 4x4 que describe el movimiento, la rotaci√≥n y la escala.  sus versiones est√°ticas translate (), rotate () y scale () se pueden usar para crear un objeto matricial con par√°metros espec√≠ficos. <br></li><li>  invert (): calcula el inverso de la matriz actual.  Su versi√≥n est√°tica de inverse () toma una matriz como par√°metro y devuelve una nueva matriz inversa a la dada. <br></li></ol><br>  OSG entiende las matrices como matrices de cadenas y los vectores como cadenas, por lo tanto, para aplicar una transformaci√≥n matricial a un vector, haga esto <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  El orden de las operaciones matriciales es f√°cil de entender al observar c√≥mo se multiplican las matrices para obtener una conversi√≥n equivalente <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  El desarrollador debe leer el proceso de transformaci√≥n de izquierda a derecha.  Es decir, en el fragmento de c√≥digo descrito, el vector primero se escala y luego su movimiento. <br><br>  osg :: Matrixf contiene elementos de tipo float. <br><br><h1>  6. Usando la clase osg :: MatrixTransform </h1><br>  Aplicamos el conocimiento te√≥rico adquirido en la pr√°ctica al cargar dos modelos de aviones en diferentes puntos de la escena. <br><br><div class="spoiler">  <b class="spoiler_title">Texto completo del ejemplo de transformaci√≥n</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  El ejemplo es realmente bastante trivial.  Cargando el modelo de avi√≥n desde el archivo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Crear un nodo de transformaci√≥n <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Configuramos el modelo para mover el modelo a lo largo del eje X 25 unidades hacia la izquierda como matriz de transformaci√≥n <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Establecemos nuestro modelo para el nodo de transformaci√≥n como un nodo hijo <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  Hacemos lo mismo con la segunda transformaci√≥n, pero como matriz establecemos el movimiento a la derecha en 25 unidades. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Creamos un nodo ra√≠z y como nodos de transformaci√≥n para √©l establecemos nodos de transformaci√≥n transform1 y transform2 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Crear un visor y pasarle el nodo ra√≠z como datos de escena <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  Ejecutar el programa da esa imagen <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  La estructura del gr√°fico de escena en este ejemplo es la siguiente. <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  No debemos confundirnos por el hecho de que los nodos de transformaci√≥n (Ni√±o 1.1 y Ni√±o 1.2) se refieren al mismo objeto hijo del modelo de avi√≥n (Ni√±o 2).  Este es un mecanismo OSG normal, cuando un nodo secundario de un gr√°fico de escena puede tener varios nodos principales.  Por lo tanto, no tenemos que almacenar dos instancias del modelo en nuestra memoria para obtener dos planos id√©nticos en la escena.  Este mecanismo le permite asignar memoria de manera muy eficiente en la aplicaci√≥n.  El modelo no se eliminar√° de la memoria hasta que se haga referencia a √©l como un hijo, al menos un nodo. <br><br>  En su acci√≥n, la clase osg :: MatrixTransform es equivalente a los comandos de OpenGL glMultMatrix () y glLoadMatrix (), implementa todo tipo de transformaciones espaciales, pero es dif√≠cil de usar debido a la necesidad de calcular la matriz de transformaci√≥n. <br><br>  La clase osg :: PositionAttitudeTransform funciona como las funciones de OpenGL glTranslate (), glScale (), glRotate ().  Proporciona m√©todos p√∫blicos para convertir nodos secundarios: <br><br><ol><li>  setPosition (): mueve el nodo a un punto dado en el espacio especificado por el par√°metro osg :: Vec3 <br></li><li>  setScale (): escala el objeto a lo largo de los ejes de coordenadas.  Los factores de escala a lo largo de los ejes correspondientes se establecen mediante un par√°metro del tipo osg :: Vec3 <br></li><li>  setAttitude (): establece la orientaci√≥n espacial del objeto.  Como par√°metro, toma el cuaterni√≥n de conversi√≥n de rotaci√≥n osg :: Quat, cuyo constructor tiene varias sobrecargas que le permiten especificar el cuaterni√≥n directamente (por componentes) y, por ejemplo, a trav√©s de los √°ngulos de Euler osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg :: Y_AXIS, zAngle, osg :: Z_AXIS) (¬°los √°ngulos se dan en radianes!) <br></li></ol><br><br><h1>  7. Cambiar nodos </h1><br>  Considere otra clase: osg :: Switch, que le permite mostrar u omitir la representaci√≥n de un nodo de escena, dependiendo de alguna condici√≥n l√≥gica.  Es un descendiente de la clase osg :: Group y atribuye alg√∫n valor l√≥gico a cada uno de sus hijos.  Tiene varios m√©todos p√∫blicos √∫tiles: <br><ol><li>  AddChild () sobrecargado, como segundo par√°metro, toma una clave l√≥gica que indica si se muestra o no este nodo. <br></li><li>  setValue (): establece la clave de visibilidad / invisibilidad.  Toma el √≠ndice del nodo hijo que nos interesa y el valor clave deseado.  En consecuencia, getValue () le permite obtener el valor clave actual por el √≠ndice del nodo que nos interesa. <br></li><li>  setNewChildDefaultValue (): establece el valor predeterminado para la clave de visibilidad de todos los objetos nuevos agregados como elementos secundarios. <br></li></ol><br>  Considere la aplicaci√≥n de esta clase con un ejemplo. <br><br><div class="spoiler">  <b class="spoiler_title">Interruptor de ejemplo completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  El ejemplo es trivial: cargamos dos modelos: un cessna convencional y un cessna con el efecto de un motor en llamas <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  Sin embargo, creamos osg :: Switch como nodo ra√≠z, lo que nos permite, al agregarle modelos como nodos secundarios, establecer la clave de visibilidad para cada uno de ellos. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Es decir, model1 no se representar√° y model2 s√≠, lo cual observaremos al ejecutar el programa <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  Al intercambiar los valores de las teclas veremos la imagen opuesta <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Levantando ambas teclas, veremos dos modelos al mismo tiempo <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  Puede habilitar la visibilidad e invisibilidad de un nodo, un hijo de osg :: Switch, directamente sobre la marcha utilizando el m√©todo setValue () <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Conclusi√≥n </h1><br>  En este tutorial, analizamos todas las clases principales de nodos intermedios utilizados en OpenSceeneGraph.  Por lo tanto, colocamos otro ladrillo b√°sico en la base del conocimiento sobre el dispositivo de este motor gr√°fico indudablemente interesante.  Los ejemplos discutidos en el art√≠culo, como antes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°n disponibles en mi repositorio en Github</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430242/">https://habr.com/ru/post/es430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430230/index.html">C√≥mo mantener tu lugar en una startup en crecimiento</a></li>
<li><a href="../es430232/index.html">Generaci√≥n de llamada cerrada en los juegos: "Al borde de la derrota" o "Casi gan√≥"</a></li>
<li><a href="../es430236/index.html">NASA anuncia vuelo de luna nueva</a></li>
<li><a href="../es430238/index.html">Otro dsl en Kotlin o c√≥mo imprim√≠ PDF desde reaccionar</a></li>
<li><a href="../es430240/index.html">Vulnerabilidad de n√∫mero seudoaleatorio de Bitcoin</a></li>
<li><a href="../es430244/index.html">SpaceX recibi√≥ permiso para desplegar una red satelital de 11943 sat√©lites</a></li>
<li><a href="../es430246/index.html">Reubicaci√≥n al socialismo austriaco</a></li>
<li><a href="../es430252/index.html">Enemigo por dentro: c√≥mo me met√≠ en el enrojecimiento interno</a></li>
<li><a href="../es430256/index.html">Configuraci√≥n de la aplicaci√≥n - Metadatos de configuraci√≥n de Spring</a></li>
<li><a href="../es430258/index.html">No a los vertederos de RSU: coloque una granja de vermicin√≠feros debajo de la ventana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>