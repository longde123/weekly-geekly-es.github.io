<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèæ üçÑ üë®üèΩ‚Äçüíª El libro "C ++. La pr√°ctica de la programaci√≥n multiproceso " üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üßóüèø üöº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! El lenguaje C ++ se elige cuando necesita crear aplicaciones realmente r√°pidas. Y el procesamiento competitivo de alta calidad los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "C ++. La pr√°ctica de la programaci√≥n multiproceso "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/484818/"> <a href="https://habr.com/ru/company/piter/blog/484818/"><img src="https://habrastorage.org/webt/cr/ym/3u/crym3urkeecjcfe-nsvq0nrw59y.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  El lenguaje C ++ se elige cuando necesita crear aplicaciones realmente r√°pidas.  Y el procesamiento competitivo de alta calidad los har√° a√∫n m√°s r√°pidos.  Las nuevas caracter√≠sticas de C ++ 17 le permiten utilizar toda la potencia de la programaci√≥n multiproceso para resolver f√°cilmente los problemas de procesamiento gr√°fico, aprendizaje autom√°tico, etc. Anthony Williams, un experto en procesamiento competitivo, considera ejemplos y describe tareas pr√°cticas, as√≠ como comparte secretos que ser√°n √∫tiles para todos en incluidos los desarrolladores m√°s experimentados. <br><br>  En el libro ‚Ä¢ Una descripci√≥n completa de las caracter√≠sticas de C ++ 17.  ‚Ä¢ Lanzamiento y control de flujo.  ‚Ä¢ Sincronizaci√≥n de operaciones competitivas.  ‚Ä¢ Desarrollo de c√≥digo competitivo.  ‚Ä¢ Depuraci√≥n de aplicaciones multiproceso.  El libro es adecuado para desarrolladores de nivel medio que usan C y C ++.  No se requiere experiencia en programaci√≥n competitiva. <br><a name="habracut"></a><br><h3>  Desarrollo de c√≥digo competitivo </h3><br><h3>  8.1.  Formas de distribuir el trabajo entre hilos </h3><br>  Imagina que necesitas construir una casa.  Para hacer esto, tendr√° que cavar un pozo de cimentaci√≥n, llenar la cimentaci√≥n misma, erigir paredes, tender tuber√≠as y cableado el√©ctrico, etc. Te√≥ricamente, con suficientes habilidades, todo se puede hacer de forma independiente, pero lo m√°s probable es que tome mucho tiempo y tendr√° que cambiar de un trabajo a otro. otro  Pero puedes contratar asistentes.  Luego ser√° necesario elegir cu√°ntos asistentes contratar y decidir qu√© deber√≠an poder hacer.  Puede, por ejemplo, contratar a dos trabajadores y trabajar con ellos.  Entonces, todav√≠a tienes que cambiar de un trabajo a otro, pero ahora las cosas ir√°n m√°s r√°pido, ya que habr√° m√°s artistas. <br><br>  Puede elegir otra opci√≥n: contratar un equipo de especialistas, como alba√±il, carpintero, electricista y plomero.  Cada uno trabajar√° en su propia especialidad, por lo tanto, hasta que el plomero tenga un frente de trabajo, se sentar√° inactivo.  Y sin embargo, las cosas ir√°n m√°s r√°pido que antes, ya que hay m√°s trabajadores, y aunque el electricista llevar√° a cabo el cableado en la cocina, el plomero puede ir al ba√±o.  Pero cuando no hay trabajo para un especialista espec√≠fico, se obtiene m√°s tiempo de inactividad.  Sin embargo, se puede observar que incluso teniendo en cuenta el tiempo de inactividad, el trabajo se mueve m√°s r√°pidamente cuando los especialistas vienen a trabajar, en lugar de un equipo de trabajadores.  Los especialistas no necesitan cambiar constantemente las herramientas, y seguramente cada uno de ellos llevar√° a cabo su tarea m√°s r√°pido que el trabajador.  Si esto realmente ser√° as√≠ depende de las circunstancias espec√≠ficas: todo se aprende en la pr√°ctica. <br><br>  Incluso si involucra especialistas, a√∫n debe elegir un n√∫mero diferente de trabajadores de diversas especialidades.  Quiz√°s tenga sentido contratar, por ejemplo, m√°s alba√±iles que electricistas.  Adem√°s, la composici√≥n de su equipo y la efectividad general de su trabajo pueden cambiar si tiene que construir varias casas a la vez.  Incluso si hay poco trabajo para un fontanero en una sola casa, cuando se construyen varias casas a la vez, se puede tomar todo el d√≠a.  Adem√°s, si no tiene que pagar a especialistas por tiempo de inactividad, puede reclutar un equipo m√°s grande, incluso si la cantidad de personas que trabajan simult√°neamente no cambia. <br><br>  Pero deja de hablar de la construcci√≥n.  ¬øQu√© tiene que ver todo esto con los hilos?  Y puede aplicarles consideraciones similares.  Debe decidir cu√°ntos hilos usar y qu√© tareas deben realizar.  ¬øNecesitamos hilos universales que hagan el trabajo que se necesita en un momento particular, o hilos especializados que est√©n bien adaptados a una sola cosa?  ¬øO tal vez vale la pena combinar ambos?  Estas decisiones deben tomarse independientemente de los motivos para paralelizar el programa, y ‚Äã‚Äãel rendimiento y la claridad del c√≥digo dependen significativamente de su √©xito.  Por lo tanto, es muy importante imaginar qu√© opciones est√°n disponibles para tomar una decisi√≥n competente al desarrollar la estructura de la aplicaci√≥n.  En esta secci√≥n, consideraremos una serie de m√©todos para distribuir tareas, comenzando con la distribuci√≥n de datos entre subprocesos hasta que se realice cualquier otro trabajo. <br><br><h3>  8.1.1  Distribuci√≥n de datos entre hilos antes de procesar </h3><br>  Los m√°s f√°ciles de paralelizar son los algoritmos simples, como std :: for_each, que realizan operaciones en cada elemento de un conjunto de datos.  Para paralelizar este algoritmo, puede asignar cada elemento a uno de los hilos de procesamiento.  En el futuro, al considerar los problemas de rendimiento, quedar√° claro que la mejor opci√≥n de distribuci√≥n para lograr un rendimiento √≥ptimo depende de las caracter√≠sticas de la estructura de datos. <br><br>  Al distribuir datos, el caso m√°s simple es cuando los primeros N elementos se asignan a un flujo, los siguientes N elementos a otro, etc. (Fig. 8.1), pero se pueden usar otros esquemas.  Independientemente del m√©todo de distribuci√≥n de datos, cada subproceso procesa solo los elementos asignados a √©l, sin interactuar con otros subprocesos hasta que finaliza el procesamiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ie/ex/rm/ieexrmf49u6qerfqmuhtcgpbgpe.png" alt="imagen"></div><br>  La estructura debe ser familiar para todos los que se han ocupado de la programaci√≥n en la interfaz de paso de mensajes (MPI, <a href="http://www.mpi-forum.org/">www.mpi-forum.org</a> ) o OpenMP (http://www.openmp.org/): la tarea se divide en muchas tareas que se realizan en paralelo, los flujos de trabajo los ejecutan independientemente unos de otros, y los resultados se recopilan en la etapa final de la informaci√≥n.  Este enfoque se utiliz√≥ en el ejemplo con la funci√≥n de acumulaci√≥n de la secci√≥n 2.4: tanto las tareas paralelas como la etapa de reducci√≥n son acumulaci√≥n.  Para un algoritmo simple for_each, falta el paso final, ya que no hay nada que reducir. <br><br>  El hecho de que una mezcla se defina como la esencia de la etapa final juega un papel muy importante: una implementaci√≥n elemental similar a la que se muestra en el Listado 2.9 realizar√° esta mezcla como una etapa secuencial final.  Pero a menudo esta etapa tambi√©n es paralela: la acumulaci√≥n es una operaci√≥n de reducci√≥n, por lo que el c√≥digo en el Listado 2.9 se puede cambiar para obtener una llamada recursiva del mismo c√≥digo cuando, por ejemplo, el n√∫mero de hilos es mayor que el n√∫mero m√≠nimo de elementos procesados ‚Äã‚Äãpor el hilo.  Tambi√©n puede obligar a los flujos de trabajo a realizar pasos de acumulaci√≥n tan pronto como cada uno de ellos complete su tarea, en lugar de comenzar nuevos hilos cada vez. <br><br>  A pesar de su eficacia, esta t√©cnica no es vers√°til.  A veces, los datos no se pueden dividir con precisi√≥n por adelantado, ya que la composici√≥n de cada parte se conoce solo durante el procesamiento.  En particular, esto es evidente cuando se utilizan algoritmos recursivos como Quicksort, por lo que requieren un enfoque diferente. <br><br><h3>  8.1.2.  Distribuci√≥n recursiva de datos </h3><br>  El algoritmo Quicksort tiene dos etapas principales: dividir los datos en dos partes: todo lo que viene a uno de los elementos (referencia), y todo lo que viene despu√©s en el orden de clasificaci√≥n final, y la clasificaci√≥n recursiva de estas dos mitades.  Es imposible paralelizarlo mediante la divisi√≥n preliminar de los datos, ya que es posible determinar en qu√© "mitad" caen solo durante el procesamiento de los elementos.  Si tiene la intenci√≥n de paralelizar este algoritmo, debe usar la esencia misma de la recursividad.  En cada nivel de recursi√≥n, se realizan m√°s y m√°s llamadas a la funci√≥n quick_sort, ya que tiene que ordenar tanto las que son m√°s grandes que la referencia como las que son m√°s peque√±as.  Estas llamadas recursivas son independientes entre s√≠ porque se refieren a conjuntos de elementos separados.  Debido a esto, son los primeros candidatos para la competitividad.  Esta distribuci√≥n recursiva se muestra en la Fig.  8.2. <br><br>  Esta implementaci√≥n ya se cumpli√≥ en el Cap√≠tulo 4. En lugar de hacer dos llamadas recursivas para las mitades m√°s grandes y m√°s peque√±as, utilizamos la funci√≥n std :: async (), que ejecuta tareas asincr√≥nicas para la mitad m√°s peque√±a en cada paso.  Debido al uso de std :: async (), la biblioteca de subprocesos de C ++ tuvo que decidir cu√°ndo iniciar la tarea en un nuevo subproceso y cu√°ndo, en modo sincr√≥nico. <br><br>  Hay una circunstancia importante: al ordenar un gran conjunto de datos, comenzar un nuevo hilo para cada recursi√≥n conducir√° a un r√°pido aumento en el n√∫mero de hilos.  Al examinar problemas de rendimiento, se mostrar√° que demasiados hilos pueden ralentizar la aplicaci√≥n.  Adem√°s, con un gran conjunto de flujos de datos puede que simplemente no sea suficiente.  La idea misma de dividir toda la tarea en un modo tan recursivo parece muy exitosa, solo necesita monitorear cuidadosamente la cantidad de hilos.  En casos simples, la funci√≥n std :: async () maneja esto, pero hay otras opciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ji/l3/rzjil3fye0-nfj2quxo75cvxon4.png" alt="imagen"></div><br>  Una de ellas es utilizar la funci√≥n std :: thread :: hardware_concurrency () para seleccionar el n√∫mero de hilos, como se hizo en la versi√≥n paralela de la funci√≥n generate () del Listado 2.9.  Luego, en lugar de comenzar un nuevo subproceso para cada llamada recursiva, puede colocar el fragmento para ordenarlo en una pila segura para subprocesos, por ejemplo, como se discuti√≥ en los cap√≠tulos 6 y 7. Si el subproceso no tiene nada que hacer o ha terminado de procesar todos sus fragmentos o est√° esperando que se ordene el fragmento, puede toma un fragmento de la pila y clasif√≠calo. <br><br>  El listado 8.1 muestra una implementaci√≥n simple de esta tecnolog√≠a.  Como en la mayor√≠a de los otros ejemplos, solo demuestra la intenci√≥n y no es un c√≥digo listo para su uso pr√°ctico.  Si usa el compilador C ++ 17 y su biblioteca lo admite, debe usar los algoritmos paralelos proporcionados por la biblioteca est√°ndar de acuerdo con las descripciones dadas en el cap√≠tulo 10. <br><br>  Listado 8.1.  Un algoritmo paralelo de Quicksort que utiliza una pila de fragmentos en espera de clasificaci√≥n <br><br><img src="https://habrastorage.org/webt/ko/nb/h6/konbh6b_q40lp0uz-gxyunwws3g.png" alt="imagen"><br><img src="https://habrastorage.org/webt/5s/md/52/5smd5279wgwzktq4thil54lidqy.png" alt="imagen"><br><img src="https://habrastorage.org/webt/ro/js/kt/rojsktncuxgmls2wtndzt9ywhqy.png" alt="imagen"><br><br>  Aqu√≠, la funci√≥n parallel_quick_sort <b>(19)</b> coloca la mayor parte de las responsabilidades funcionales en la clase sorter <b>(1)</b> , que proporciona una manera f√°cil de agrupar la pila de fragmentos sin clasificar <b>(2)</b> y m√∫ltiples hilos <b>(3)</b> .  El trabajo principal se realiza en la funci√≥n del componente do_sort <b>(9)</b> , que est√° ocupada por la partici√≥n de datos habitual <b>(10)</b> .  Esta vez, en lugar de comenzar un nuevo hilo para cada fragmento, empuja este fragmento en la pila (11) e inicia un nuevo hilo solo si hay un recurso de procesador libre (12).  Dado que un fragmento con valores inferiores al de referencia puede ser procesado por otra secuencia, debemos esperar a que est√© listo <b>(13)</b> .  Para que no se pierda el tiempo (en el caso de que tengamos un solo subproceso o todos los dem√°s subprocesos ya est√©n ocupados), se intenta procesar fragmentos de la pila para este per√≠odo de espera <b>(14)</b> .  La funci√≥n try_sort_chunk recupera un fragmento de la pila <b>(7)</b> , lo ordena <b>(8)</b> y guarda los resultados en la promesa de promesa para que puedan recibir la secuencia que coloca este fragmento en la pila <b>(15)</b> . <br><br>  Ahora, los subprocesos reci√©n lanzados est√°n en un bucle e intentan ordenar fragmentos de la pila <b>(17)</b> si el indicador end_of_data <b>(16)</b> no est√° establecido.  Entre las comprobaciones, ceden el recurso inform√°tico a otros subprocesos para que puedan llevar trabajo adicional a la pila.  El trabajo del c√≥digo en t√©rminos de ordenar estos hilos depende del destructor de su clase sorter <b>(4)</b> .  Cuando se ordenan todos los datos, la funci√≥n do_sort devolver√° el control (incluso manteniendo la actividad de los subprocesos de trabajo), el subproceso principal volver√° desde parallel_quick_sort <b>(20)</b> y destruir√° el objeto del clasificador.  Establecer√° el indicador end_of_data <b>(5)</b> y esperar√° a que los subprocesos terminen de funcionar <b>(6).</b> Establecer el indicador detendr√° el bucle en la funci√≥n de subprocesos (16). <br><br>  Con este enfoque, el problema del n√∫mero ilimitado de subprocesos inherentes a la funci√≥n spawn_task que lanz√≥ el nuevo subproceso desaparecer√° y la dependencia de la biblioteca de subprocesos de C ++, que seleccionar√° el n√∫mero de subprocesos para usted, como lo hace al usar std :: async (), desaparecer√°.  En cambio, para evitar el cambio de tareas con demasiada frecuencia, el n√∫mero de subprocesos est√° limitado por el valor devuelto por la funci√≥n std :: thread :: hardware_concurrency ().  Pero surge otro problema: administrar estos flujos e intercambiar datos entre ellos complica enormemente el c√≥digo.  Adem√°s, a pesar del hecho de que los subprocesos procesan elementos de datos individuales, todos acceden a la pila, agregando nuevos fragmentos y tomando fragmentos para el procesamiento.  Tal competencia intensa puede reducir el rendimiento, incluso si se usa una pila sin bloqueo (por lo tanto, sin bloqueo), y las razones para esto pronto se considerar√°n. <br><br>  Este enfoque es una versi√≥n especial del grupo de subprocesos: un conjunto de subprocesos, cada uno de los cuales recibe trabajo de la lista de trabajos diferidos, lo realiza y luego busca en la lista uno nuevo.  Algunos problemas potenciales inherentes al grupo de subprocesos (incluida la competencia al acceder a la lista de trabajos), y las formas de resolverlos se discuten en el Cap√≠tulo 9. Al escalar la aplicaci√≥n creada para que se ejecute en varios procesadores, discutiremos este cap√≠tulo un poco m√°s adelante (ver subsecci√≥n 8.2.1). <br><br>  Al distribuir datos tanto antes del procesamiento como en modo recursivo, se supone que se corrigen de antemano y se est√° buscando su distribuci√≥n.  Pero esto no siempre sucede: si los datos se crean en modo din√°mico o provienen de una fuente externa, este enfoque no funciona.  En este caso, puede ser m√°s razonable distribuir el trabajo de acuerdo con el tipo de tarea y no en funci√≥n de los datos en s√≠. <br><br><h3>  8.1.3.  Distribuci√≥n del trabajo por tipo de tarea. </h3><br>  La distribuci√≥n del trabajo entre subprocesos al asignar a cada uno de ellos (por adelantado o recursivamente durante el procesamiento de datos) diferentes datos en cualquier caso, se basa en el supuesto de que los subprocesos van a hacer el mismo trabajo en cada pieza.  Una distribuci√≥n alternativa del trabajo es la especializaci√≥n de flujos, donde cada uno realiza una tarea separada, ya que los fontaneros y electricistas realizan diferentes tareas en la construcci√≥n de una casa.  Las transmisiones pueden funcionar con datos diferentes o iguales, pero en el √∫ltimo caso lo hacen para diferentes prop√≥sitos. <br><br>  Esta peculiar divisi√≥n del trabajo surge como resultado de la separaci√≥n de tareas con la ayuda de la competencia: cada hilo tiene una tarea separada, que realiza independientemente de otros flujos.  A veces, otros subprocesos pueden entregar datos a la secuencia o producir eventos a los que deber√≠a responder, pero en general, cada secuencia se concentra en el rendimiento de alta calidad de una sola tarea.  Este es un buen dise√±o b√°sico, donde cada parte del c√≥digo debe ser responsable de una cosa. <br><br><h3>  Distribuci√≥n del trabajo por tipo de tarea para compartir la responsabilidad. </h3><br>  Una aplicaci√≥n de subproceso √∫nico tiene que hacer frente a conflictos relacionados con el principio de responsabilidad √∫nica, cuando hay varias tareas que deben realizarse continuamente durante un tiempo determinado, o la aplicaci√≥n debe hacer frente al procesamiento de los eventos entrantes de manera oportuna (por ejemplo, un usuario presiona una tecla o los datos llegan a trav√©s de la red) en presencia de otras tareas pendientes.  En un entorno inform√°tico de un solo subproceso, debe crear de forma independiente el c√≥digo que ejecuta parte de la tarea A, parte de la tarea B, verifica si se presion√≥ la tecla y no hay paquetes de red, y luego vuelve c√≠clicamente a la siguiente parte de la tarea A. Esto complica el c√≥digo para la ejecuci√≥n tareas A debido a la necesidad de mantener su estado y devolver peri√≥dicamente el control al bucle principal.  Si agrega demasiadas tareas al ciclo, el trabajo puede disminuir significativamente y el usuario probablemente notar√° una reacci√≥n lenta a las pulsaciones de teclas.  Estoy seguro de que todos observaron las manifestaciones extremas de una situaci√≥n similar en ciertas aplicaciones: configura una tarea para la aplicaci√≥n y la interfaz no reacciona ante nada hasta que se completa. <br><br>  Aqu√≠ los flujos llegan al escenario.  Si ejecuta cada tarea en un hilo separado, el sistema operativo puede hacer esto en lugar de usted.  En el c√≥digo para la tarea A, puede concentrarse en completar la tarea sin preocuparse por mantener el estado y volver al ciclo principal, o por cu√°nto tiempo pasar√° antes de que esto suceda.  Es decir, el sistema operativo guardar√° autom√°ticamente el estado y en el momento correcto cambiar√° a la tarea B o C, y si el sistema en el que se ejecutar√° el programa tiene varios n√∫cleos o procesadores, ser√° posible ejecutar simult√°neamente las tareas A y B. El c√≥digo para procesar pulsaciones de teclas o recibos los paquetes de red ahora se pueden ejecutar de manera oportuna, y todos se beneficiar√°n: el usuario recibir√° una respuesta adecuada del programa y usted, como desarrollador, recibir√° un c√≥digo simplificado, ya que cada flujo puede ser dirigido  para realizar operaciones directamente relacionadas con sus tareas, sin mezclarlas con el flujo de control y la interacci√≥n del usuario. <br><br>  Est√° surgiendo una imagen ideal.  Pero, ¬øpuede resultar todo de esa manera?  Como siempre, todo depende de las circunstancias espec√≠ficas.  Si se respeta la independencia total y los flujos no necesitan intercambiar datos entre s√≠, entonces eso es exactamente lo que suceder√°.  Desafortunadamente, una situaci√≥n similar se observa muy raramente.  A menudo, las acciones necesarias para el usuario tienen la forma de tareas en segundo plano convenientes, y necesitan notificar al usuario sobre la tarea, actualizando la interfaz de usuario de alguna manera.  O el usuario puede necesitar detener la tarea, por lo que la interfaz de usuario deber√° enviar de alguna manera un mensaje a la tarea en segundo plano, haciendo que deje de ejecutarse.  En ambos casos, es necesario considerar cuidadosamente el dise√±o y la sincronizaci√≥n adecuada, pero las tareas realizadas permanecer√°n fragmentadas.  El subproceso de la interfaz de usuario a√∫n controla esta interfaz, pero puede asignarse para realizar una actualizaci√≥n a petici√≥n de otros subprocesos.  El subproceso que implementa la tarea en segundo plano todav√≠a se concentra en las operaciones necesarias para completarlo; tambi√©n sucede que uno de los subprocesos en segundo plano permite que la tarea detenga el otro subproceso.  En ambos casos, a los flujos no les importa de d√≥nde proviene la solicitud, solo les importa el hecho de que est√° dise√±ada para ellos y est√° directamente relacionada con sus responsabilidades. <br><br>  Hay dos peligros graves en compartir la responsabilidad entre m√∫ltiples hilos.  Primero, puede resultar que se distribuyan responsabilidades inapropiadas.  Una se√±al de esto son demasiados datos compartidos por las transmisiones, o el hecho de que las transmisiones diferentes tienen que esperar entre s√≠.          .      .        , , ,    ,             .   ,        ,     ‚Äî   , ,        . <br><br>                .             ,     ,         . <br><br><h3>      </h3><br>                 ,            .      : ,     ,         . <br><br>            ‚Äî        .   ,     ,      .   ,     ,       ,           . <br><br>      ,    8.1.1,   ,           . ,                  . <br><br>     ,        :    ,       . ,        20          ,      3 .      ,         .  ,   ,    ,  ,   12       ,  24  ‚Äî   . .  20     .      .         .       , ,  ,   ,   12 . ,   12       ,        .      ,  :  ,   ,     ,  ,       ,        .      3         12 . <br><br>      ,    9 ,         .            . ,  ,      .          25   ,    ‚Äî  .  ,       ,    : ,   100   ,  ,    1 ,    100 ,    1     100 .     ,  ,        .       ,     ,  , . <br><br>       ,    ,     ,   ,      . <br><br><h3> 8.2. ,      </h3><br>            ,  ,      .        ,  ,     .     ,       16      ,     . <br><br>    ,        ‚Äî   ,    ,    (      ),      .          ,    :      ? <br><br><h3> 8.2.1.     ? </h3><br>  ( )     ,          .   ,    ,        ,          .     ,     .      ,     . ,         ,         (   )       .     ,   ,      ,            . <br><br>     16-       16  :          16 .    ,        16 .   ,    ,         (   ).    ,    16    ,      ,           ,      1.       (oversubscription). <br><br>          ,       ,    C++11 (Standard Thread Library)   std::thread::hardware_concurrency().             . <br><br>   std::thread::hardware_concurrency()    :       -  ,   ,        .   ,        ,  std::thread::hardware_concurrency(),     .  std::async()    ,           .           . <br><br>      ,    ,    ,      .              ‚Äî   ,   ,     . ,     ,   ,       ,          C++.   ,     std::async(),       ,   ,    .       ,     .   ,      ,      std::thread::hardware_concurrency(),     .      ,      ,  ,    . <br><br>       ,                 .          ,     ,      ,    ,        . <br><br>         ,        ‚Äî          . <br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://www.piter.com/collection/new/product/c-praktika-mnogopotochnogo-programmirovaniya%3F_gs_cttl%3D120%255E_%255Eamp%255E_%255Egs_direct_link%3D1%255E_%255Eamp%255E_%255Egsaid%3D82744%255E_%255Eamp%255E_%255Egsmid%3D29789%255E_%255Eamp%255E_%255Egstid%3Dc">el sitio web del editor</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610831/978544610831_X.pdf">Contenidos</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610831/978544610831_p.pdf">Extracto</a> <br><br>    25%   ‚Äî <b>C++</b> <br><br>  Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </div></div><p>Source: <a href="https://habr.com/ru/post/484818/">https://habr.com/ru/post/484818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484804/index.html">¬øQu√© cifrar en un sistema corporativo? ¬øY por qu√© haces esto?</a></li>
<li><a href="../484806/index.html">Diferencia entre cPanel y obsidiana Plesk</a></li>
<li><a href="../484812/index.html">Mi experiencia con Plesk</a></li>
<li><a href="../484814/index.html">6. Fortinet Getting Started v6.0. Filtrado web y control de aplicaciones</a></li>
<li><a href="../484816/index.html">Uso de enlaces de operaciones para hacer copias de seguridad de archivos en macOS sobre la marcha</a></li>
<li><a href="../484820/index.html">FAQ.Net: un programa gratuito para tomar notas para Windows con un dise√±o actualizado</a></li>
<li><a href="../484822/index.html">Blazor: c√≥mo evitar que un componente se enferme o dos enfoques para separar el c√≥digo del marcado</a></li>
<li><a href="../484824/index.html">La guerra por apagar las luces</a></li>
<li><a href="../484826/index.html">La inteligencia artificial empeora a√∫n m√°s la mala medicina</a></li>
<li><a href="../484834/index.html">C√≥mo construir una estrategia corporativa para capacitaci√≥n y desarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>