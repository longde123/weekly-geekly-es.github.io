<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘— ğŸ‘¨ğŸ½â€ğŸ« ğŸ‘©ğŸ¾â€ğŸš€ Dan bagi kami semuanya "tegak" - DBMS Vertica ğŸ¯ ğŸ’‡ ğŸ¦„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Sergey, saya bekerja sebagai chief engineer di Sbertekh. Saya telah berkecimpung di bidang IT selama sekitar 10 tahun, dimana 6 di antar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dan bagi kami semuanya "tegak" - DBMS Vertica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/414895/">  Hai  Nama saya Sergey, saya bekerja sebagai chief engineer di Sbertekh.  Saya telah berkecimpung di bidang IT selama sekitar 10 tahun, dimana 6 di antaranya terlibat dalam database, proses ETL, DWH, dan segala sesuatu yang terkait dengan data.  Pada artikel ini saya akan berbicara tentang Vertica - DBMS analitis dan benar-benar kolumnis yang secara efisien memampatkan, menyimpan, dengan cepat mengirimkan data, dan hebat sebagai solusi data besar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e1/e72/d1c/6e1e72d1cca80f6339ea76e0c27eedec.png"><br><a name="habracut"></a><br><h2>  Informasi umum </h2><br>  Data besar mulai berkembang pada tahun 2000-an, dan dibutuhkan mesin yang dapat mencernanya semua.  Menanggapi hal ini, sejumlah DBMS kolom yang dimaksudkan untuk tujuan ini muncul - termasuk Vertica. <br><br>  Vertica tidak hanya menyimpan data dalam kolom, tetapi melakukannya secara rasional, dengan tingkat kompresi yang tinggi, juga secara efisien menjadwalkan pertanyaan dan dengan cepat memberikan data.  Informasi, yang dalam DBMS huruf kecil klasik membutuhkan sekitar 1 TB ruang disk, pada Vertica akan memakan waktu sekitar 200-300 GB, sehingga kami mendapatkan penghematan yang baik pada disk. <br><br>  Awalnya Vertica dirancang sebagai kolom DBMS.  Basis lain pada dasarnya hanya mencoba meniru berbagai mekanisme kolom, tetapi mereka tidak selalu berhasil karena mesin masih dirancang untuk memproses string.  Sebagai aturan, peniru hanya memindahkan tabel dan kemudian memprosesnya dengan mekanisme garis biasa. <br><br>  Vertica toleran terhadap kesalahan, tidak memiliki node kontrol - semua node sama.  Jika ada masalah dengan salah satu server di kluster, kami masih akan menerima data.  Sangat sering, menerima data tepat waktu sangat penting bagi pelanggan bisnis, terutama pada saat pelaporan ditutup dan Anda perlu memberikan informasi kepada otoritas keuangan. <br><br><h2>  Area aplikasi </h2><br>  Vertica terutama merupakan gudang data analitik.  Anda tidak boleh menulis kepadanya dalam transaksi kecil, Anda tidak boleh mengacaukannya ke situs mana pun, dll.  Vertica harus dianggap sebagai semacam lapisan batch, di mana ada baiknya merendam data dalam paket besar.  Jika perlu, Vertica siap untuk memberikan data ini dengan sangat cepat - permintaan jutaan saluran diselesaikan dalam hitungan detik. <br><br>  Di mana ini bisa bermanfaat?  Ambil contoh, perusahaan telekomunikasi.  Vertica dapat digunakan di dalamnya untuk geoanalitik, pengembangan jaringan, manajemen kualitas, pemasaran yang ditargetkan, mempelajari informasi dari pusat kontak, mengelola arus keluar klien dan solusi anti-penipuan / anti-spam. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ef/913/bfe/0ef913bfe1510fd3aee6de4bb52e3175.png"><br><br>  Di sektor bisnis lain, semuanya hampir sama - analisis yang tepat waktu dan andal penting untuk mendapatkan keuntungan.  Dalam perdagangan, misalnya, setiap orang mencoba untuk mempersonalisasi pelanggan, mendistribusikan kartu diskon untuk ini, mengumpulkan data di mana, apa dan kapan seseorang membeli, dll.  Dengan menganalisis susunan informasi dari semua saluran ini, kita dapat membandingkannya, membangun model dan membuat keputusan yang mengarah pada pertumbuhan laba. <br><br><h2>  Ambang entri </h2><br>  Saat ini, majikan mana pun membutuhkan analis untuk memahami apa itu SQL.  Jika Anda tahu ANSI SQL, maka Anda bisa disebut pengguna Vertica yang percaya diri.  Jika Anda dapat membangun model dengan Python dan R, maka Anda hanyalah "tukang pijat" data.  Jika Anda telah menguasai Linux dan memiliki pengetahuan dasar tentang administrasi Vertica, maka Anda dapat bekerja sebagai administrator.  Secara umum, ambang pintu masuk di Vertica rendah, tetapi, tentu saja, semua nuansa hanya dapat ditemukan dengan mengisi tangan selama operasi. <br><br><h2>  Arsitektur perangkat keras </h2><br>  Pertimbangkan Vertica level-klaster.  DBMS ini menyediakan pemrosesan data paralel besar-besaran (MPP) dalam arsitektur komputasi terdistribusi - "shared-nothing" - di mana, pada prinsipnya, setiap node siap untuk mengambil fungsi dari node lainnya.  Sifat utama: <br><br><ul><li>  Tidak ada titik kegagalan tunggal <br></li><li>  setiap node independen dan independen, <br></li><li>  Tidak ada titik koneksi tunggal untuk seluruh sistem, <br></li><li>  node infrastruktur digandakan, <br></li><li>  data pada node cluster disalin secara otomatis. <br></li></ul><br>  Cluster berskala linear tanpa masalah.  Kami cukup meletakkan server di rak dan menghubungkannya melalui antarmuka grafis.  Selain server serial, penyebaran ke mesin virtual juga dimungkinkan.  Apa yang bisa dicapai dengan ekstensi? <br><br><ul><li>  Volume bertambah untuk data baru <br></li><li>  Tambah beban kerja maksimum <br></li><li>  Meningkatkan daya tahan.  Semakin banyak node dalam cluster, semakin kecil kemungkinan cluster gagal karena kegagalan, dan oleh karena itu, semakin dekat kita untuk memastikan ketersediaan 24/7. <br></li></ul><br>  Tetapi ada beberapa hal yang perlu dipertimbangkan.  Secara berkala, node harus dihapus dari cluster untuk pemeliharaan.  Kasus lain yang cukup umum di organisasi besar adalah server tidak lagi bergaransi dan beralih dari lingkungan produktif ke semacam pengujian.  Di tempat mereka ada yang baru di bawah garansi pabrik.  Berdasarkan hasil dari semua operasi ini, penyeimbangan diperlukan.  Ini adalah proses di mana data didistribusikan kembali antara node - sesuai, beban kerja didistribusikan kembali.  Ini adalah proses yang intensif sumber daya, dan pada kelompok dengan sejumlah besar data, ini dapat sangat mengurangi kinerja.  Untuk menghindari ini, Anda harus memilih jendela layanan - waktu ketika beban minimal, dalam hal ini pengguna tidak akan melihatnya. <br><br><h2>  Proyeksi </h2><br>  Untuk memahami bagaimana data disimpan di Vertica, Anda perlu berurusan dengan salah satu konsep dasar - proyeksi. <br><br>  Unit logis dari penyimpanan informasi adalah diagram, tabel, dan tampilan.  Unit fisik adalah proyeksi.  Proyeksi datang dalam beberapa jenis: <br><br><ul><li>  Proyeksi super <br></li><li>  Proyeksi-Permintaan Khusus <br></li><li>  Proyeksi Agregat <br></li></ul><br>  Saat membuat tabel apa pun, <i>proyeksi super</i> dibuat secara otomatis yang berisi semua kolom tabel kami.  Jika Anda perlu mempercepat proses biasa, kami dapat membuat <i>proyeksi berorientasi permintaan</i> khusus yang akan berisi, katakanlah, 3 dari 10 kolom. <br><br>  Tipe ketiga juga ditujukan untuk <i>proyeksi</i> akselerasi - <i>agregat</i> .  Saya tidak akan masuk ke subclass mereka - ini tidak terlalu menarik.  Saya ingin segera memperingatkan Anda bahwa tidak ada gunanya untuk terus-menerus menyelesaikan masalah Anda dengan eksekusi permintaan melalui pembuatan proyeksi baru.  Akhirnya, cluster akan mulai melambat. <br><br>  Saat membuat proyeksi, kita perlu mengevaluasi apakah permintaan kita memiliki cukup proyeksi super.  Jika kami masih ingin bereksperimen, kami secara ketat menambahkan satu proyeksi baru.  Jika masalah muncul, akan lebih mudah untuk menemukan akar masalahnya.  Untuk tabel besar, buat proyeksi tersegmentasi.  Ini dibagi menjadi beberapa segmen yang didistribusikan di beberapa node, yang meningkatkan toleransi kesalahan dan meminimalkan beban pada satu node.  Jika tablet kecil, maka lebih baik melakukan proyeksi non-segmentasi.  Mereka sepenuhnya disalin ke setiap node, dan dengan demikian kinerja meningkat.  Saya akan melakukan reservasi: dalam hal Vertica, meja "kecil" adalah sekitar 1 juta baris. <br><br><h2>  Toleransi kesalahan </h2><br>  Toleransi kesalahan di Vertica diimplementasikan menggunakan mekanisme K-Safety.  Ini cukup sederhana dalam hal deskripsi, tetapi rumit dalam hal bekerja di level mesin.  Ini dapat dikontrol menggunakan parameter K-Safety - dapat memiliki nilai 0, 1 atau 2. Parameter ini menetapkan jumlah salinan data proyeksi tersegmentasi. <br><br>  Salinan proyeksi disebut proyeksi teman.  Saya mencoba menerjemahkan frasa ini melalui Yandex-translator dan ternyata seperti â€œsidekick projectionâ€.  Google menawarkan opsi dan lebih menarik.  Biasanya, proyeksi ini disebut pasangan atau tetangga, sesuai dengan tujuan fungsionalnya.  Ini adalah proyeksi yang hanya disimpan pada node tetangga dan dengan demikian dicadangkan.  Proyeksi non-segmented tidak memiliki proyeksi teman - mereka disalin sepenuhnya. <br><br>  Bagaimana cara kerjanya?  Pertimbangkan sekelompok lima mesin.  Biarkan K-safety sama dengan 1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6b/af4/969/f6baf4969fb15ab90df2d68def4862dd.png"><br><br>  Node diberi nomor, dan di bawahnya adalah proyeksi mitra tertulis yang disimpan pada mereka.  Misalkan kita memiliki satu simpul yang terputus.  Apa yang akan terjadi <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5c/adc/696/f5cadc696f5683b45591e3d597ae5cdc.png"><br><br>  Node 1 berisi proyeksi node 2. Oleh karena itu, beban pada node 1 akan bertambah, tetapi cluster tidak akan berhenti bekerja.  Dan sekarang situasi ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b4/414/8af/2b44148afc4c57bf863e966d527ffa36.png"><br><br>  Node 3 berisi proyeksi node 4, dan node 1 dan 3 akan kelebihan beban. <br><br>  Kami menyulitkan tugas.  K-Safety = 2, nonaktifkan dua node yang berdekatan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bd/741/a31/1bd741a3183af8ec14fa2f953b99dc8a.png"><br><br>  Di sini simpul 1 dan 4 akan kelebihan beban (simpul 2 berisi proyeksi simpul 1, dan simpul 3 berisi proyeksi simpul 4). <br><br>  Dalam situasi seperti itu, mesin sistem mengakui bahwa salah satu node tidak merespons, dan beban ditransfer ke node tetangga.  Ini akan digunakan sampai node dikembalikan lagi.  Setelah ini terjadi, beban dan data didistribusikan kembali.  Segera setelah kami kehilangan lebih dari setengah cluster atau node yang berisi semua salinan beberapa data, cluster bangun. <br><br><h2>  Penyimpanan data logis </h2><br>  Vertica memiliki area penyimpanan yang dioptimalkan untuk penulisan, area yang dioptimalkan untuk membaca, dan mekanisme Tuple Mover yang memungkinkan data mengalir dari yang pertama ke yang kedua. <br><br>  Saat menggunakan operasi COPY, INSERT, UPDATE, kami secara otomatis berakhir di WOS (Write Optimized Store), area di mana data tidak dioptimalkan untuk dibaca dan diurutkan hanya jika diminta, disimpan tanpa kompresi atau pengindeksan.  Jika volume data terlalu besar untuk area WOS, maka menggunakan pernyataan DIRECT tambahan, mereka harus segera ditulis ke ROS.  Kalau tidak, WOS akan penuh dan kita akan crash. <br><br>  Setelah waktu yang ditentukan dalam pengaturan berakhir, data dari WOS mengalir ke ROS (Read Optimized Store) - struktur penyimpanan disk yang dioptimalkan dan berorientasi baca.  ROS menyimpan sebagian besar data, di sini disortir dan dikompresi.  Data ROS dibagi ke dalam wadah penyimpanan.  Wadah adalah serangkaian garis yang dibuat oleh operator terjemahan (COPY DIRECT), dan disimpan dalam kelompok file tertentu. <br><br>  Terlepas dari di mana data ditulis - dalam WOS atau di ROS - mereka segera tersedia.  Tetapi membaca dari WOS lebih lambat karena data tidak dikelompokkan di sana. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/c1e/e0d/00ec1ee0d4605f51f009febe686c4a44.png"><br><br>  Tuple Mover adalah alat pembersih yang melakukan dua operasi: <br><br><ul><li>  Moveout - memampatkan dan mengurutkan data dalam WOS, memindahkannya ke ROS dan membuat wadah baru untuk mereka di ROS. <br></li><li>  Mergeout - menyapu di belakang kami saat kami menggunakan DIRECT.  Kami tidak selalu dapat memuat begitu banyak informasi untuk mendapatkan wadah ROS yang besar.  Oleh karena itu, secara berkala menggabungkan wadah ROS kecil menjadi yang lebih besar, membersihkan data yang ditandai untuk dihapus, sambil bekerja di latar belakang (sesuai dengan waktu yang ditentukan dalam konfigurasi). <br></li></ul><br><h2>  Apa manfaat dari penyimpanan kolom? </h2><br>  Jika kita membaca baris, maka, misalnya, untuk menjalankan perintah <br><br> <code>SELECT 1,11,15 from table1 <br></code> <br>  kita harus membaca seluruh tabel.  Ini adalah sejumlah besar informasi.  Dalam hal ini, pendekatan kolom lebih menguntungkan.  Ini memungkinkan Anda untuk menghitung hanya tiga kolom yang kami butuhkan, menghemat memori dan waktu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ee/1b5/69e/6ee1b569e3daa80c154912e1ca3ac6ed.png"><br><br><h2>  Alokasi sumber daya </h2><br>  Untuk menghindari masalah, pengguna perlu dibatasi sedikit.  Selalu ada kemungkinan bahwa pengguna akan menulis permintaan berat yang akan melahap semua sumber daya.  Secara default, Vertica menempati bagian penting dari area Umum, dan di samping itu, area terpisah untuk Tuple Mover, WOS dan proses sistem (pemulihan, dll.) Disorot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e7/008/498/7e70084981be49bb1f041743d31521a1.png"><br><br>  Mari kita coba berbagi sumber daya ini.  Kami membuat area untuk penulis, untuk pembaca, dan untuk pertanyaan yang lambat, prioritas rendah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/895/add/be5895add6099324995b81d8a39f670a.png"><br><br>  Jika kita melihat tabel sistem di mana sumber daya kita disimpan - sumber daya kolam - maka kita akan melihat banyak parameter yang Anda dapat menyesuaikan semuanya dengan lebih halus.  Pada awalnya, Anda tidak harus mempelajari ini, lebih baik membatasi diri Anda untuk memotong memori untuk tugas-tugas tertentu.  Ketika Anda mendapatkan pengalaman dan 100% yakin bahwa Anda melakukan semuanya dengan benar, Anda dapat bereksperimen. <br><br>  Pengaturan yang tipis termasuk prioritas eksekusi, sesi kompetitif, dan jumlah memori yang dialokasikan.  Dan bahkan dengan prosesor, kami dapat memperbaiki sesuatu. Untuk bekerja dengan pengaturan ini, Anda perlu kepercayaan penuh pada kebenaran tindakan Anda, jadi lebih baik untuk meminta dukungan bisnis dan memiliki hak untuk melakukan kesalahan. <br><br>  Di bawah ini adalah contoh permintaan yang dengannya Anda dapat melihat pengaturan kumpulan General: <br><br> <code>dbadmin =&gt; select * FROM resource_pools WHERE NAME = 'general'; <br> <br> -[ RECORD 1 ]------------+--------------- <br> pool_id | 45035996273721212 <br> name | general <br> is_internal | t <br> memorysize | <br> maxmemorysize | 30G <br> executionparallelism | AUTO <br> priority | 0 <br> runtimepriority | MEDIUM <br> runtimeprioritythreshold | 2 <br> queuetimeout | 0:05 <br> plannedconcurrency | 10 <br> maxconcurrency | 20 <br> runtimecap | <br> singleinitiator | f <br> cpuaffinityset | <br> cpuaffinitymode | ANY <br> cascadeto |</code> <br> <br><h2>  ANSI SQL dan fitur lainnya </h2><br><ul><li>  Vertica memungkinkan Anda untuk menulis dalam SQL-99 - semua fungsi didukung. <br></li><li>  Verica memiliki kemampuan analitik yang hebat - bahkan alat pembelajaran mesin disertakan <br></li><li>  Vertica dapat mengindeks teks <br></li><li>  Vertica memproses data semi-terstruktur <br></li></ul><br><h2>  Integrasi </h2><br>  Vertica, seperti semua alat saat ini, terintegrasi secara serius dengan sistem lain.  Mampu bekerja dengan baik dengan HDFS (Hadoop).  Pada versi sebelumnya, Vertica hanya dapat mengunduh data dari HDFS dari format tertentu, tetapi sekarang ia dapat melakukan segalanya, bekerja dengan semua format, misalnya, ORC dan Parket.  Ia bahkan dapat melampirkan file sebagai tabel eksternal dan menyimpan datanya dalam wadah ROS langsung pada HDFS.  Dalam versi kedelapan Vertica, optimasi signifikan dari kecepatan bekerja dengan HDFS, katalog metadata dan penguraian format ini dilakukan.  Anda bisa membangun cluster Vertica langsung di cluster Hadoop. <br><br>  Dimulai dengan versi 7.2 Vertica dapat bekerja dengan Apache Kafka - jika seseorang membutuhkan broker pesan. <br><br>  Vertica 8 memiliki dukungan penuh untuk Spark.  Dimungkinkan untuk menyalin data dari Spark ke Vertica dan sebaliknya. <br><br><h2>  Kesimpulan </h2><br>  Vertica adalah pilihan yang baik untuk bekerja dengan data besar yang tidak memerlukan banyak pengetahuan input.  DBMS ini memiliki kemampuan analitis yang luas.  Dari minus - solusi ini bukan open source, tetapi Anda dapat mencoba menggunakan secara gratis dengan batas 1 TB dan tiga node - ini cukup untuk memahami apakah Anda memerlukan Vertica atau tidak. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414895/">https://habr.com/ru/post/id414895/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414885/index.html">Kami menangani kesalahan dan "penopang" dalam Daftar Badan Hukum Negara Bersatu - register negara dari badan hukum</a></li>
<li><a href="../id414887/index.html">Membuat hook kucing di Unity. Bagian 1</a></li>
<li><a href="../id414889/index.html">Ketika Lembaga Digital Membutuhkan IaaS</a></li>
<li><a href="../id414891/index.html">Kebiasaan Pengembang</a></li>
<li><a href="../id414893/index.html">Viber, WhatsApp, Telegram - mana yang lebih baik?</a></li>
<li><a href="../id414897/index.html">Akses data dalam aplikasi multi-pengguna</a></li>
<li><a href="../id414899/index.html">Cara mengumpulkan analitik dan tidak membunuh produktivitas</a></li>
<li><a href="../id414901/index.html">Dell dan DROVA: cara bermain game yang menuntut bahkan pada laptop yang lemah</a></li>
<li><a href="../id414905/index.html">Komponen web Bagian 3: templat dan impor html</a></li>
<li><a href="../id414907/index.html">Apa yang menghubungkan teori bilangan dengan lintasan cahaya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>