<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•á üë®üèΩ‚Äçüç≥ üçÆ Coordinador de aplicaciones en aplicaciones iOS üë®‚Äçüíº üà∫ üò¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cada a√±o, la plataforma iOS sufre muchos cambios, adem√°s, las bibliotecas de terceros trabajan regularmente para trabajar con la red, almacenar en cac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coordinador de aplicaciones en aplicaciones iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423299/">  Cada a√±o, la plataforma iOS sufre muchos cambios, adem√°s, las bibliotecas de terceros trabajan regularmente para trabajar con la red, almacenar en cach√© los datos, representar la interfaz de usuario a trav√©s de JavaScript y m√°s.  En contraste con todas estas tendencias, <strong>Pavel Gurov</strong> habl√≥ sobre la soluci√≥n arquitect√≥nica, que ser√° relevante independientemente de las tecnolog√≠as que est√© utilizando ahora o que utilizar√° en un par de a√±os. <br><br>  ApplicationCoordinator se puede utilizar para construir la navegaci√≥n entre pantallas y al mismo tiempo resolver una serie de problemas.  Debajo de la demostraci√≥n del gato e instrucciones para la implementaci√≥n m√°s r√°pida de este enfoque. <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg"><br><br>  <strong>Sobre el orador:</strong> Pavel Gurov est√° desarrollando aplicaciones iOS en Avito. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  La navegaci√≥n <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br>  Navegar entre pantallas es una tarea a la que se enfrenta el 100% de ustedes, sin importar lo que hagan: una red social, una llamada de taxi o un banco en l√≠nea.  As√≠ es como comienza la aplicaci√≥n incluso en la etapa de prototipo, cuando ni siquiera sabe hasta el final: c√≥mo se ver√°n las pantallas, qu√© tipo de animaciones ser√°n, si los datos se almacenar√°n en cach√©.  Las pantallas pueden ser im√°genes en blanco o est√°ticas, pero <strong>la tarea de navegaci√≥n aparece en la aplicaci√≥n tan pronto como haya m√°s de una de estas pantallas</strong> .  Es decir, casi de inmediato. <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br>  Los m√©todos m√°s comunes para construir la arquitectura de aplicaciones iOS: MVc, MVVm y MVp, describen c√≥mo construir un m√≥dulo de pantalla √∫nica.  Tambi√©n dice que los m√≥dulos pueden conocerse, comunicarse entre s√≠, etc.  Pero se presta muy poca atenci√≥n a los problemas de c√≥mo se realizan las transiciones entre estos m√≥dulos, qui√©n decide sobre estas transiciones y c√≥mo se transmiten los datos. <br><br><h2>  UlStoryboard + segues <br></h2><br>  iOS listo para usar proporciona varias formas de mostrar el siguiente escenario de pantalla: <br><br><ol><li>  El conocido <strong>UlStoryboard + sigue</strong> , cuando <strong>designamos</strong> todas las transiciones entre pantallas en un metaarchivo, y luego las llamamos.  Todo es muy conveniente y genial. </li><li>  Contenedores, como el UINavigationController.  UITabBarController, UIPageController o, posiblemente, contenedores autoescritos que se pueden usar tanto mediante programaci√≥n como junto con StoryBoards. </li><li>  M√©todo presente (_: animado: finalizaci√≥n :).  Este es solo un m√©todo de la clase UIController. </li></ol><br>  No hay problemas con estas herramientas en s√≠ mismas.  El problema es exactamente c√≥mo se usan com√∫nmente.  El m√©todo UINavigationController, performSegue, prepareForSegue, presentViewController son todos m√©todos de propiedad de la clase UIViewController.  Apple sugiere usar estas herramientas dentro del mismo UIViewController. <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br>  Prueba de ello es lo siguiente. <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br>  Estos son comentarios que aparecen en su proyecto si crea una nueva subclase de UIViewController utilizando una plantilla est√°ndar.  Est√° escrito directamente: si usa segues y necesita transferir datos a la siguiente pantalla seg√∫n el escenario, debe: obtener este ViewController de segue;  saber de qu√© tipo ser√°;  transmitirlo a este tipo y pasar sus datos all√≠. <br><br>  Este enfoque a los problemas en la construcci√≥n de navegaci√≥n. <br><br>  <strong>1. Conectividad r√≠gida de pantallas</strong> <br><br>  Esto significa que la pantalla 1 sabe acerca de la existencia de la pantalla 2. No solo √©l sabe acerca de su existencia, sino que tambi√©n puede crearla, o tomarla de la segue, sabiendo de qu√© tipo es, y transfiere algunos datos a ella. <br><br>  Si necesitamos, en algunas circunstancias, mostrar la pantalla 3 en lugar de la pantalla 2, entonces tendremos que conocer la nueva pantalla 3 de la misma manera para coser en el controlador de pantalla 1. Todo se vuelve a√∫n m√°s dif√≠cil si los controladores 2 y 3 se pueden llamar desde varios lugares m√°s, no solo de la pantalla 1. Resulta que el conocimiento de la pantalla 2 y 3 tendr√° que ser cosido en cada uno de estos lugares. <br><br>  Hacer esto es otra mitad del problema, los problemas principales comenzar√°n cuando sea necesario realizar cambios en estas transiciones o apoyar todo esto. <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2. Reordenar los controladores de script</strong> <br><br>  Esto tampoco es tan simple debido a la conexi√≥n.  Para intercambiar dos ViewControllers, no ser√° suficiente ingresar al UlStoryboard e intercambiar 2 im√°genes.  Tendr√° que abrir el c√≥digo para cada una de estas pantallas, transferirlo a la configuraci√≥n de la siguiente y cambiar sus lugares, lo que no es muy conveniente. <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3. Transferencia de datos seg√∫n el escenario.</strong> <br><br>  Por ejemplo, al elegir algo en la pantalla 3, necesitamos actualizar la Vista en la pantalla 1. Dado que inicialmente no tenemos m√°s que un ViewController, tendremos que conectar de alguna manera los dos ViewControllers, no importa c√≥mo, por delegaci√≥n o de alguna manera todav√≠a  Ser√° a√∫n m√°s dif√≠cil si, de acuerdo con la acci√≥n en la pantalla 3, ser√° necesario actualizar no una pantalla, sino varias a la vez, por ejemplo, la primera y la segunda. <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br>  En este caso, no se puede prescindir de la delegaci√≥n, porque la delegaci√≥n es una relaci√≥n uno a uno.  Alguien dir√°, usemos notificaci√≥n, alguien, a trav√©s de un estado compartido.  Todo esto dificulta la depuraci√≥n y el seguimiento de los flujos de datos en nuestra aplicaci√≥n. <br><br>  Como dicen, es mejor ver una vez que escuchar 100 veces.  Veamos un ejemplo espec√≠fico de esta aplicaci√≥n Avito Services Pro.  Esta aplicaci√≥n es para profesionales en el sector de servicios, en el cual es conveniente rastrear sus pedidos, comunicarse con los clientes, buscar nuevos pedidos. <br><br>  Escenario: elegir una ciudad para editar un perfil de usuario. <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br>  Aqu√≠ hay una pantalla de edici√≥n de perfil, como en muchas aplicaciones.  Estamos interesados ‚Äã‚Äãen elegir una ciudad. <br><br>  ¬øQu√© est√° pasando aqu√≠? <br><br><ul><li>  El usuario hace clic en la celda con la ciudad, y la primera pantalla decide que es hora de agregar la siguiente pantalla a la pila de navegaci√≥n.  Esta es una pantalla con una lista de ciudades federales (Mosc√∫ y San Petersburgo) y una lista de regiones. </li><li>  Si el usuario selecciona una ciudad federal en la segunda pantalla, entonces la segunda pantalla comprende que el gui√≥n se ha completado, reenv√≠a la ciudad seleccionada a la primera y la pila de Navegaci√≥n vuelve a la primera pantalla.  El gui√≥n se considera completo. </li><li>  Si el usuario selecciona un √°rea en la segunda pantalla, la segunda pantalla decide que debe prepararse una tercera pantalla, en la que vemos una lista de ciudades en esta √°rea.  Si el usuario selecciona una ciudad, esta ciudad se env√≠a a la primera pantalla, tira la pila de Navegaci√≥n y la secuencia de comandos se considera completa. </li></ul><br>  En este diagrama, los problemas de conectividad que mencion√© anteriormente se muestran como flechas entre el ViewController.  Nos libraremos de estos problemas ahora. <br><br>  <strong>¬øC√≥mo hacemos esto?</strong> <br><br><ol><li>  Nos <strong>prohibimos dentro del UIViewController acceder a los contenedores</strong> , es decir, self.navigationController, self.tabBarController u otros contenedores personalizados que haya realizado como extensi√≥n de propiedad.  Ahora no podemos tomar nuestro contenedor del c√≥digo de la pantalla y pedirle que haga algo. <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>Nos prohibimos dentro del UIViewController llamar al m√©todo performSegue</strong> y escribir c√≥digo en el m√©todo prepareForSegue, que tomar√≠a la pantalla que sigue al script y lo configurar√°.  Es decir, ya no trabajamos con segue (con transiciones entre pantallas) dentro del UIViewController. <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li>  Tambi√©n <strong>prohibimos cualquier menci√≥n de otros controladores dentro de nuestro controlador espec√≠fico</strong> : sin inicializaciones, transferencias de datos, y eso es todo. <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2>  Coordinador <br></h2><br>  Como eliminamos todas estas responsabilidades del UIViewController, necesitamos una nueva entidad que las realice.  Crea una nueva clase de objetos y ll√°malo coordinador. <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br>  El coordinador es solo un objeto ordinario al que pasamos al inicio del NavigationController y llamamos al m√©todo Start.  Ahora no piense en c√≥mo se implementa, solo mire c√≥mo cambiar√° el escenario para elegir una ciudad en este caso. <br><br>  Ahora no comienza con el hecho de que estamos preparando la transici√≥n a una pantalla espec√≠fica de NavigationController, pero llamamos al m√©todo Start en el coordinador, pas√°ndolo antes en el inicializador NavigationController.  El coordinador entiende que es hora de que NavigationController inicie la primera pantalla, lo cual hace. <br><br>  Adem√°s, cuando el usuario selecciona una celda con una ciudad, este evento se pasa al coordinador.  Es decir, la pantalla en s√≠ misma no sabe nada; despu√©s, como dicen, al menos una inundaci√≥n.  Env√≠a este mensaje al coordinador, y luego el coordinador reacciona a esto (ya que tiene un NavigationController), que env√≠a el siguiente paso: esta es la elecci√≥n de las regiones. <br><br>  Luego, el usuario hace clic en "Regi√≥n", exactamente la misma imagen, la pantalla en s√≠ no resuelve nada, solo le dice al coordinador que se abre la siguiente pantalla. <br><br>  Cuando el usuario selecciona una ciudad espec√≠fica en la tercera pantalla, esta ciudad tambi√©n se transfiere a la primera pantalla a trav√©s del coordinador.  Es decir, se env√≠a un mensaje al coordinador de que se ha seleccionado una ciudad.  El coordinador env√≠a este mensaje a la primera pantalla y lanza la pila de navegaci√≥n a la primera pantalla. <br><br>  Tenga en cuenta que los <strong>controladores ya no se comunican entre s√≠</strong> , deciden qui√©n ser√° el pr√≥ximo y no se transmiten datos entre ellos.  Adem√°s, no saben nada de su entorno. <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br>  Si consideramos la aplicaci√≥n dentro del marco de una arquitectura de tres capas, entonces el ViewController deber√≠a encajar perfectamente en la capa de Presentaci√≥n y llevar lo menos posible la l√≥gica de la aplicaci√≥n. <br><br>  En este caso, usamos el coordinador para extraer la l√≥gica de las transiciones a la capa superior y eliminar este conocimiento del ViewController. <br><br><h2>  Demo <br></h2><br>  Una presentaci√≥n y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto de</a> demostraci√≥n est√°n disponibles en Github, a continuaci√≥n se muestra una demostraci√≥n durante la charla. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este es el mismo escenario: editar un perfil y elegir una ciudad en √©l. <br><br>  La primera pantalla es la pantalla de edici√≥n del usuario.  Muestra informaci√≥n sobre el usuario actual: nombre y ciudad seleccionada.  Hay un bot√≥n "Elegir una ciudad".  Cuando hacemos clic en √©l, llegamos a la pantalla con una lista de ciudades.  Si seleccionamos una ciudad all√≠, entonces la primera pantalla muestra esta ciudad. <br><br>  Veamos ahora c√≥mo funciona esto en el c√≥digo.  Comencemos con el modelo. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>Los modelos son</strong> simples: <br><br><ol><li>  Una estructura de ciudad que tiene un nombre de campo, cadena; </li><li>  Un usuario que tambi√©n tiene un nombre y ciudad de propiedad. </li></ol><br>  El siguiente es <strong>StoryBoard</strong> .  Comienza con un NavigationController.  En principio, aqu√≠ est√°n las mismas pantallas que estaban en el simulador: una pantalla de edici√≥n de usuario con una etiqueta y un bot√≥n y una pantalla con una lista de ciudades, que muestra una tableta con ciudades. <br><br><h4>  Pantalla de edici√≥n de usuario <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br>  Aqu√≠ hay una propiedad Usuario, este es el usuario que se transmite fuera, el usuario que editaremos.  Establecer usuario aqu√≠ hace que se llame al bloque didSet, lo que lleva a una llamada al m√©todo local updateView ().  Todo lo que hace este m√©todo es simplemente poner informaci√≥n sobre el usuario en la etiqueta, es decir, mostrar su nombre y el nombre de la ciudad en la que vive este usuario. <br><br>  Lo mismo sucede en el m√©todo viewWillAppear (). <br><br>  El lugar m√°s interesante es el controlador para hacer clic en el bot√≥n de selecci√≥n de ciudad selectCityTap ().  <strong>Aqu√≠, el controlador en s√≠ no resuelve nada</strong> : no crea ning√∫n controlador, no llama a ning√∫n segue.  Todo lo que hace es devoluci√≥n de llamada: esta es la segunda propiedad de nuestro ViewController.  La devoluci√≥n de llamada onSelectCity no tiene par√°metros.  Cuando el usuario hace clic en el bot√≥n, esto hace que se llame a esta devoluci√≥n de llamada. <br><br><h4>  Pantalla de selecci√≥n de ciudad <br></h4><br><pre> <code class="hljs powershell">import UIKit final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitiesViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span></span> { // MARK: - Output - var onCitySelected: ((City) -&gt; Void)? // MARK: - Private variables - private let cities: [<span class="hljs-type"><span class="hljs-type">City</span></span>] = [<span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Moscow"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ulyanovsk"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"New York"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)] // MARK: - Table - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"cell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>]) } }</code> </pre><br>  Esta pantalla es un UITableViewController.  La lista de ciudades aqu√≠ es fija, pero puede provenir de otro lugar.  Adem√°s (// MARK: - Table -) es un c√≥digo de tabla bastante trivial que muestra una lista de ciudades en celdas. <br><br>  El lugar m√°s interesante aqu√≠ es el controlador didSelectRowAt IndexPath, un m√©todo bien conocido para todos.  Aqu√≠ la pantalla en s√≠ misma no resuelve nada.  ¬øQu√© sucede despu√©s de seleccionar la ciudad?  Simplemente llama a una devoluci√≥n de llamada con un solo par√°metro "ciudad". <br><br>  Esto termina el c√≥digo para las pantallas mismas.  Como vemos, no saben nada sobre su entorno. <br><br><h4>  Coordinador <br></h4><br>  Pasemos al enlace entre estas pantallas. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br>  El coordinador tiene dos propiedades: <br><br><ol><li>  Usuario: el usuario que editaremos; </li><li>  El NavigationController al que pasar al inicio. </li></ol><br>  Hay un simple init () que llena estas propiedades. <br><br>  El siguiente es el m√©todo start (), que hace que se <strong>llame</strong> al m√©todo <strong>ShowUserEditScreen ()</strong> .  Deteng√°monos en ello con m√°s detalle.  Este m√©todo saca el controlador de UIStoryboard, lo pasa a nuestro usuario local.  Luego pone la devoluci√≥n de llamada SelectCity y empuja este controlador a la pila de Navegaci√≥n. <br><br>  Despu√©s de que el usuario hace clic en el bot√≥n, se activa la devoluci√≥n de llamada onSelectCity y esto provoca que se <strong>llame</strong> al siguiente <strong>m√©todo</strong> privado <strong>ShowCitiesScreen ()</strong> . <br><br>  De hecho, hace casi lo mismo: levanta un controlador ligeramente diferente del UIStoryboard, coloca la devoluci√≥n de llamada onCitySelected y lo empuja a la pila de navegaci√≥n, eso es todo lo que sucede.  Cuando el usuario selecciona una ciudad espec√≠fica, se activa esta devoluci√≥n de llamada, el coordinador actualiza el campo "ciudad" de nuestro usuario local y pasa la pila de navegaci√≥n a la primera pantalla. <br><br>  Como el usuario es una estructura, la actualizaci√≥n del campo "ciudad" en √©l lleva al hecho de que se llama al bloque didSet, respectivamente, se llama al m√©todo privado <strong>updateInterfaces ()</strong> .  Este m√©todo recorre toda la pila de navegaci√≥n e intenta implementar cada ViewController como el protocolo UpdateableWithUser.  Este es el protocolo m√°s simple, que tiene una sola propiedad: usuario.  Si esto tiene √©xito, entonces lo lanza al usuario actualizado.  Por lo tanto, resulta que nuestro usuario seleccionado en la segunda pantalla salta autom√°ticamente a la primera pantalla. <br><br>  Todo est√° claro con el coordinador, y lo √∫nico que queda por mostrar aqu√≠ es el punto de entrada a nuestra aplicaci√≥n.  Aqu√≠ es donde todo comienza.  En este caso, este es el m√©todo didFinishLaunchingWithOptions de nuestro AppDelegate. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br>  Aqu√≠ el navigationController obtiene de UIStoryboard, se crea un Usuario, que editaremos, con un nombre y una ciudad espec√≠fica.  A continuaci√≥n, creamos nuestro coordinador con User y navigationController.  Llama al m√©todo start ().  El coordinador se transfiere a la propiedad local, eso es b√°sicamente todo.  El esquema es bastante simple. <br><br><h4>  Entradas y salidas <br></h4><br>  Hay varios puntos en los que me gustar√≠a profundizar m√°s.  Probablemente haya notado que la propiedad en userEditViewController est√° marcada con un comentario como Entrada, y las devoluciones de llamada de estos controladores est√°n marcadas como Salida. <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>Una entrada</strong> es cualquier dato que pueda cambiar con el tiempo, as√≠ como algunos m√©todos de ViewController que se pueden llamar desde afuera.  Por ejemplo, en UserEditViewController esta es una propiedad del usuario: el usuario mismo o su par√°metro City pueden cambiar. <br><br>  <strong>Una salida</strong> es cualquier evento que el controlador quiera comunicar al mundo exterior.  En UserEditViewController, este es un clic en el bot√≥n onSelectCity, y en la pantalla de selecci√≥n de ciudad, es un clic en una celda con una ciudad espec√≠fica.  La idea principal aqu√≠ es, repito, que el controlador no sabe nada y no hace nada acerca de estos eventos.  Delega para decidir qu√© hacer, a otra persona. <br><br>  En Objective-C, realmente no me gustaba escribir devoluciones de llamadas guardadas debido a su horrible sintaxis.  Pero en Swift, esto es mucho m√°s simple.  El uso de devoluciones de llamada en este caso es una alternativa al conocido patr√≥n de delegaci√≥n en iOS.  Solo aqu√≠, en lugar de designar m√©todos en el protocolo y decir que el coordinador corresponde a este protocolo, y luego escribir estos m√©todos en alg√∫n lugar por separado, podemos crear de manera muy conveniente una entidad en un solo lugar, devolverle la llamada y hacerlo todo. <br><br>  Es cierto que con este enfoque, a diferencia de la delegaci√≥n, existe una estrecha conexi√≥n entre la esencia del coordinador y la pantalla, porque el coordinador sabe que existe una esencia espec√≠fica de la pantalla. <br><br>  Puede deshacerse de esto de la misma manera que en la delegaci√≥n, utilizando protocolos. <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br>  Para evitar la conectividad, podemos <strong>cerrar la</strong> <strong>entrada y</strong> <strong>salida de nuestro controlador con un protocolo</strong> . <br><br>  Arriba est√° el protocolo CitiesOutput, que tiene exactamente un requisito: la devoluci√≥n de llamada onCitySelected.  A la izquierda hay un an√°logo de este esquema en Swift.  Nuestro controlador cumple con este protocolo, determinando la devoluci√≥n de llamada necesaria.  Hacemos esto para que el coordinador no sepa sobre la existencia de la clase CitiesViewController.  Pero en alg√∫n momento necesitar√° configurar la salida de este controlador.  Para ponerlo todo en marcha, agregamos una f√°brica al coordinador. <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br>  La f√°brica tiene un m√©todo cityOutput ().  Resulta que nuestro coordinador no crea un controlador y no lo obtiene de alguna parte.  Una f√°brica se lo arroja, lo que devuelve un objeto cerrado por el protocolo en el m√©todo, y √©l no sabe nada sobre qu√© clase es este objeto. <br><br>  Ahora lo m√°s importante: ¬øpor qu√© hacer todo esto?  <strong>¬øPor qu√© necesitamos construir en otro nivel adicional cuando no hubo problemas de todos modos?</strong> <br><br>  Uno puede imaginar esta situaci√≥n: un gerente vendr√° a nosotros y le pedir√° que haga una prueba A / B del hecho de que, en lugar de una lista de ciudades, tendr√≠amos la opci√≥n de elegir una ciudad en el mapa.  Si en nuestra aplicaci√≥n la elecci√≥n de la ciudad no estaba en un lugar, sino en diferentes coordinadores, en diferentes escenarios, tuvimos que coser una bandera en cada lugar, arrojarla afuera, en esta bandera izar uno u otro ViewController.  Esto no es muy conveniente. <br><br>  Queremos eliminar este conocimiento del coordinador.  Por lo tanto, uno podr√≠a hacer esto en un solo lugar.  En la propia f√°brica, har√≠amos un par√°metro mediante el cual la f√°brica devuelve uno u otro controlador cerrado por el protocolo.  Ambos tendr√≠an una devoluci√≥n de llamada en CitySelected, y al coordinador, en principio, no le importar√≠a con cu√°l de estas pantallas trabajar: un mapa o una lista. <br><br><h2>  Composici√≥n VS Herencia <br></h2><br>  El siguiente punto en el que quer√≠a insistir es la composici√≥n contra la herencia. <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li>  El primer m√©todo de c√≥mo nuestro coordinador puede hacerse es <strong>hacer la composici√≥n</strong> cuando el NavigationController se le pasa desde el exterior y se almacena localmente como propiedad.  Esto es como una composici√≥n: le agregamos un NavigationController como una propiedad. </li><li>  Por otro lado, existe la opini√≥n de que todo est√° all√≠ en el kit de interfaz de usuario, y no necesitamos reinventar la rueda.  Simplemente puede tomar y <strong>heredar el UI</strong> <strong>NavigationController</strong> . </li></ol><br>  Cada opci√≥n tiene sus pros y sus contras, pero personalmente me parece que la <strong>composici√≥n en este caso es m√°s adecuada</strong> que la herencia.  La herencia es generalmente un esquema menos flexible.  Si necesitamos, por ejemplo, cambiar la navegaci√≥n a, por ejemplo, UIPageController, en el primer caso podemos simplemente cerrarlos con un protocolo com√∫n, como "Mostrar la siguiente pantalla" y sustituir convenientemente el contenedor que necesitamos. <br><br>  Desde mi punto de vista, el argumento m√°s importante es que escondes del usuario final en la composici√≥n todos los m√©todos innecesarios.  Resulta que es menos probable que tropiece.  Dejas <strong>solo la</strong> <strong>API necesaria</strong> , por ejemplo, el m√©todo de Inicio, y eso es todo.  No tiene forma de llamar al m√©todo PushViewController, PopViewController, es decir, interferir de alguna manera con las actividades del coordinador.  Todos los m√©todos de la clase padre est√°n ocultos. <br><br><h2>  Storyboards <br></h2><br>  Creo que merecen una atenci√≥n especial junto con segues.  Personalmente, <strong>apoyo</strong> <strong>segues</strong> , ya que te permiten familiarizarte r√°pidamente con el script.  Cuando llega un nuevo desarrollador, no necesita escalar el c√≥digo, Storyboards lo ayuda.  Incluso si crea una interfaz con el c√≥digo, puede dejar el ViewController vac√≠o y crear la interfaz con el c√≥digo, pero deje al menos las transiciones y todo el punto.  Toda la esencia de Storyboards est√° en las transiciones en s√≠, y no en el dise√±o de la interfaz de usuario. <br><br>  Afortunadamente, el <strong>enfoque de coordinador no limita la elecci√≥n de herramientas</strong> .  Podemos usar coordinadores de forma segura junto con segues.  Pero debemos recordar que ahora no podemos trabajar con segues dentro del UIViewController. <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br>  Por lo tanto, debemos anular el m√©todo onPrepareForSegue en nuestra clase.  En lugar de hacer algo dentro del controlador, delegaremos estas tareas nuevamente al coordinador, a trav√©s de la devoluci√≥n de llamada.  Se llama al m√©todo onPrepareForSegue, usted no hace nada usted mismo, no sabe qu√© tipo de segue es, qu√© controlador de destino es, no le importa.  Simplemente lo arroja todo en una devoluci√≥n de llamada, y el coordinador lo resolver√°.  √âl tiene este conocimiento, usted no necesita este conocimiento. <br><br>  Para simplificar todo, puede hacer esto en una determinada clase Base para no anularlo en cada controlador tomado por separado.  En este caso, ser√° m√°s conveniente para el coordinador trabajar con sus segues. <br><br>  Otra cosa que me parece conveniente con el Storyboard es cumplir con la regla de que <strong>un</strong> <strong>Storyboard es igual a un coordinador</strong> .  Luego, puede simplificar mucho todo, crear una clase en general: el Coordinador de Storyboard, y generar el par√°metro RootType en √©l, crear el controlador de navegaci√≥n inicial en el Storyboard y envolver todo el script en √©l. <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br>  Como puede ver, aqu√≠ el coordinador tiene 2 propiedades: navigationController;  El rootViewController de nuestro RootType es gen√©rico.  Durante la inicializaci√≥n, le pasamos no un control de navegaci√≥n espec√≠fico, sino un Storyboard, del que obtienen nuestra navegaci√≥n ra√≠z y su primer controlador.  De esta manera, ni siquiera tendremos que llamar a ning√∫n m√©todo de Inicio.  Es decir, usted cre√≥ un coordinador, √©l inmediatamente tiene Navegaci√≥n e inmediatamente tiene Ra√≠z.  Puede mostrar la navegaci√≥n modalmente, o tomar Root e ingresar a la navegaci√≥n existente y continuar trabajando. <br><br>  Nuestro UserEditCoordinator en este caso simplemente se convertir√≠a en typealias, sustituyendo el tipo de su RootViewController en el par√°metro gen√©rico. <br><br><h2>  Transferencia de datos de script de vuelta <br></h2><br>  Hablemos de resolver el √∫ltimo problema, que describ√≠ al principio.  Esta es la transferencia de datos de vuelta al script. <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br>  Considere el mismo escenario para elegir una ciudad, pero ahora ser√° posible elegir no una ciudad, sino varias.  Para mostrarle al usuario que ha seleccionado varias ciudades dentro de la misma regi√≥n, mostraremos en la pantalla con una lista de regiones un peque√±o n√∫mero al lado del nombre de la regi√≥n, mostrando el n√∫mero de ciudades seleccionadas en esta regi√≥n. <br><br>  Resulta que la acci√≥n en un controlador (en el tercero) deber√≠a conducir a un cambio en la apariencia de varios otros a la vez.  Es decir, en el primero debemos mostrar en la celda con la ciudad, y en el segundo debemos actualizar todos los n√∫meros en las regiones seleccionadas. <br><br>  El coordinador simplifica esta tarea mediante la transferencia de datos al script; ahora es una tarea tan simple como transferir datos hacia adelante de acuerdo con el script. <br><br>  ¬øQu√© est√° pasando aqu√≠?  El usuario selecciona una ciudad.  Este mensaje se env√≠a al coordinador.  El coordinador, como ya he mostrado en la demostraci√≥n, revisa toda la pila de navegaci√≥n y env√≠a datos actualizados a todas las partes interesadas.  En consecuencia, ViewController puede actualizar su Vista con estos datos. <br><br><h2>  Refactorizando el C√≥digo Existente <br></h2><br>  ¬øC√≥mo refactorizar el c√≥digo existente si desea incrustar este enfoque en una aplicaci√≥n existente que tenga MVc, MVVm o MVp? <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br>  Tienes un mont√≥n de ViewController.  Lo primero que debe hacer es dividirlos en escenarios en los que participan.  En nuestro ejemplo, hay 3 escenarios: autorizaci√≥n, edici√≥n de perfil, cinta. <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br>  Ahora envolvemos cada escenario dentro de nuestro coordinador.  De hecho, deber√≠amos poder iniciar estos scripts desde cualquier lugar de nuestra aplicaci√≥n.  Esto debe ser flexible: el <strong>coordinador debe ser completamente autosuficiente</strong> . <br><br>  Este enfoque de desarrollo proporciona mayor comodidad.  Consiste en el hecho de que si actualmente est√° trabajando con un escenario espec√≠fico, no necesita hacer clic en √©l cada vez que lo inicia.  Puede iniciarlo r√°pidamente desde el principio, editar algo en √©l y luego eliminar este inicio temporal. <br><br>  Una vez que hayamos decidido sobre nuestros coordinadores, debemos determinar qu√© escenario puede conducir al inicio de otro y hacer un √°rbol a partir de estos escenarios. <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br>  En nuestro caso, el √°rbol es simple: LoginCoordinator puede iniciar el coordinador de edici√≥n de perfil.  Aqu√≠, casi todo encaja, pero queda un detalle muy importante: nuestro esquema carece de un punto de entrada. <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br>  Este punto de entrada ser√° un coordinador especial: coordinador de <strong>aplicaciones</strong> .  Es creado e iniciado por <strong>AppDelegate</strong> , y luego ya controla la l√≥gica a nivel de aplicaci√≥n, es decir, qu√© coordinador comienza ahora. <br><br>  Simplemente miramos un circuito muy similar, solo que ten√≠a ViewController en lugar de coordinadores, y lo hicimos para que ViewController no supiera nada el uno del otro y no se pasara datos entre s√≠.  En principio, lo mismo puede hacerse con los coordinadores.  Podemos designar cierta entrada (m√©todo de inicio) y salida (devoluci√≥n de llamada onFinish) en ellos.  <strong>Los coordinadores se vuelven independientes, reutilizables y f√°cilmente comprobables</strong> .  Los coordinadores dejan de conocerse y se comunican, por ejemplo, solo con el Coordinador de la aplicaci√≥n. <br><br>  Debe tener cuidado, porque si su aplicaci√≥n tiene suficientes scripts, entonces el Coordinador de aplicaciones puede convertirse en un gran objeto divino, sabr√° sobre todos los scripts existentes; esto tampoco es muy bueno.  Aqu√≠ ya debemos mirar, tal vez dividir a los coordinadores en subcoordinadores, es decir, pensar en tal arquitectura para que estos objetos no crezcan a tama√±os incre√≠bles.  <strong>Aunque el tama√±o no siempre es motivo de refactorizaci√≥n</strong> . <br><br><h3>  Por donde empezar <br></h3><br>  Aconsejo comenzar de abajo hacia arriba: primero implemente scripts individuales. <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br>  Como soluci√≥n alternativa, pueden iniciarse dentro del UIViewController.  Es decir, siempre que no tenga Root u otros coordinadores, puede crear un coordinador y, como soluci√≥n temporal, iniciarlo desde UIViewController, guard√°ndolo localmente en la propiedad (como nextCoordinator est√° arriba).  Cuando ocurre un evento, usted, como lo mostr√© en la demostraci√≥n, crea una propiedad local, coloca al coordinador all√≠ y llama al m√©todo Start.  Todo es muy sencillo. <br><br>  Luego, cuando todos estos coordinadores ya lo han hecho, el inicio de uno dentro del otro se ve exactamente igual.  ¬øTiene una propiedad local o alg√∫n tipo de matriz de dependencias como coordinador? Pone todo esto all√≠ para que no se escape y llame al m√©todo Start. <br><br><h2>  Resumen <br></h2><br><ul><li>  <strong>Las pantallas y los guiones independientes</strong> que no saben nada el uno del otro no se comunican entre s√≠.  Intentamos lograr esto. <br></li><li>  <strong>Es f√°cil cambiar el orden de las</strong> pantallas en la aplicaci√≥n sin cambiar los c√≥digos de pantalla.  Si todo se hace como deber√≠a, lo √∫nico que deber√≠a cambiar en la aplicaci√≥n cuando cambia el script no es el c√≥digo de la pantalla, sino el c√≥digo del coordinador. <br></li><li>  <strong>Transferencia de datos simplificada entre pantallas</strong> y otras tareas que implican una conexi√≥n entre pantallas. <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalmente, mi momento favorito es que, para comenzar a usarlo, no es necesario agregar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependencias de terceros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al proyecto </font><font style="vertical-align: inherit;">y comprender el c√≥digo de otras personas.</font></font><br></li></ul><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppsConf 2018 ya es el 8 y 9 de octubre, ¬°no te lo pierdas! </font><font style="vertical-align: inherit;">M√°s bien, estudie el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horario</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rev√≠selo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reserve</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> boletos. </font><font style="vertical-align: inherit;">Naturalmente, se presta mucha atenci√≥n a ambas plataformas: iOS y Android, adem√°s de informes sobre arquitectura que no est√°n vinculados a una sola tecnolog√≠a, y discusi√≥n de otros temas importantes relacionados con el mundo en torno al desarrollo m√≥vil.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423299/">https://habr.com/ru/post/es423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423285/index.html">Ingenier√≠a social: el enemigo evasivo en el mundo de la ciberseguridad</a></li>
<li><a href="../es423291/index.html">Los rusos establecieron un r√©cord: 110 pel√≠culas piratas por persona</a></li>
<li><a href="../es423293/index.html">C√≥mo no dispararte en la pierna con una m√°quina de estado</a></li>
<li><a href="../es423295/index.html">Conferencia de desarrollo m√≥vil m√°s √∫til</a></li>
<li><a href="../es423297/index.html">Del desarrollador de Android a DevOps</a></li>
<li><a href="../es423303/index.html">AI, curso pr√°ctico. Transformaci√≥n de m√∫sica basada en la emoci√≥n</a></li>
<li><a href="../es423305/index.html">Rendimiento de la ruina</a></li>
<li><a href="../es423307/index.html">Solicitudes de extracci√≥n de GitHub en c√≥digo de Visual Studio</a></li>
<li><a href="../es423309/index.html">Transacciones DBMS</a></li>
<li><a href="../es423311/index.html">Asociaci√≥n Naviaddress y ACTUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>