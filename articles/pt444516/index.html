<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•â üîñ üîö Wolfenstein 3D: tra√ßado de raios com WebGL1 ‚òîÔ∏è üß¢ üïµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ap√≥s o surgimento das placas gr√°ficas Nvidia RTX no ver√£o passado, o ray tracing recuperou sua antiga popularidade. Nos √∫ltimos meses, meu feed do Twi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wolfenstein 3D: tra√ßado de raios com WebGL1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444516/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png" alt="imagem"></div><br>  Ap√≥s o surgimento das placas gr√°ficas Nvidia RTX no ver√£o passado, o ray tracing recuperou sua antiga popularidade.  Nos √∫ltimos meses, meu feed do Twitter foi preenchido com um fluxo intermin√°vel de compara√ß√µes gr√°ficas com o RTX ativado e desativado. <br><br>  Depois de admirar tantas imagens bonitas, eu queria tentar combinar o renderizador avan√ßado cl√°ssico com um tra√ßador de raios sozinho. <br><br>  Sofrendo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma s√≠ndrome de rejei√ß√£o do desenvolvimento de outras pessoas</a> , como resultado, criei meu pr√≥prio mecanismo de renderiza√ß√£o h√≠brido baseado no WebGL1.  Voc√™ pode jogar com a renderiza√ß√£o no n√≠vel de demonstra√ß√£o do Wolfenstein 3D com as esferas (que usei devido ao tra√ßado de raios) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><a name="habracut"></a><br><h3>  Prot√≥tipo </h3><br>  Comecei este projeto criando um prot√≥tipo, tentando recriar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a ilumina√ß√£o global com o tra√ßado de raios do Metro Exodus</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/61a/447/26261a447cd19758715a3cbde356eeb7.png"></div><br>  <i>O primeiro prot√≥tipo a mostrar ilumina√ß√£o global difusa (Diffuse GI)</i> <br><br>  O prot√≥tipo √© baseado em um renderizador para frente, que renderiza toda a geometria da cena.  O sombreador usado para rasterizar a geometria n√£o apenas calcula a ilumina√ß√£o direta, mas tamb√©m emite raios aleat√≥rios da superf√≠cie da geometria renderizada para acumular usando a reflex√£o indireta da luz do tra√ßador de raios resultante de superf√≠cies n√£o brilhantes (Diffuse GI). <br><br>  Na imagem acima, voc√™ pode ver como todas as esferas s√£o iluminadas corretamente apenas por ilumina√ß√£o indireta (os raios de luz s√£o refletidos na parede atr√°s da c√¢mera).  A fonte de luz em si √© coberta por uma parede marrom no lado esquerdo da imagem. <br><br><h3>  Wolfenstein 3D </h3><br>  O prot√≥tipo usa uma cena muito simples.  Possui apenas uma fonte de luz e apenas algumas esferas e cubos s√£o renderizados.  Gra√ßas a isso, o c√≥digo de rastreamento de raio no shader √© muito simples.  O ciclo aproximado de verifica√ß√£o de interse√ß√£o, no qual o feixe √© testado para interse√ß√£o com todos os cubos e esferas na cena, ainda √© r√°pido o suficiente para o programa execut√°-lo em tempo real. <br><br>  Depois de criar esse prot√≥tipo, eu queria fazer algo mais complexo, adicionando mais geometria e muitas fontes de luz √† cena. <br><br>  O problema com um ambiente mais complexo √© que ainda preciso tra√ßar raios na cena em tempo real.  Normalmente, uma estrutura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hierarquia de volume delimitadora</a> (BVH) seria usada para acelerar o processo de rastreamento de raios, mas minha decis√£o de criar este projeto no WebGL1 n√£o permitiu isso: √© imposs√≠vel carregar dados de 16 bits em uma textura no WebGL1 e opera√ß√µes bin√°rias n√£o podem ser usadas em um shader.  Isso complica o c√°lculo preliminar e a aplica√ß√£o do BVH nos shaders WebGL1. <br><br>  Por isso, decidi usar o n√≠vel de demonstra√ß√£o Wolfenstein 3D para isso.  Em 2013, criei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shader WebGL de fragmento</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shadertoy</a> , que n√£o apenas renderiza n√≠veis semelhantes a Wolfenstein, mas tamb√©m cria processualmente todas as texturas necess√°rias.  Pela minha experi√™ncia trabalhando neste shader, eu sabia que o design de n√≠vel baseado em grade de Wolfenstein tamb√©m pode ser usado como uma estrutura de acelera√ß√£o r√°pida e f√°cil, e que o tra√ßado de raios ao longo dessa estrutura ser√° muito r√°pido. <br><br>  A captura de tela da demonstra√ß√£o √© mostrada abaixo e, no modo de tela cheia, voc√™ pode reproduzi-la aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://reindernijhoff.net/wolfrt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/gl/fp/euglfpjgl9503fy-_hjdwmr5hdi.png"></div><br><h3>  Breve descri√ß√£o </h3><br>  A demonstra√ß√£o usa um mecanismo de renderiza√ß√£o h√≠brido.  Para renderizar todos os pol√≠gonos no quadro, ele usa a rasteriza√ß√£o tradicional e, em seguida, combina o resultado com sombras, GI difuso e reflex√µes criadas pelo tra√ßado de raios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/fd8/bb9/8f7fd8bb9324905edf5200fedb28bb7a.png"></div><br>  <i>Sombras</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/5b5/6ba/5245b56ba3a1feb02a9401857d625514.png"></div><br>  <i>Gi difuso</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png"></div><br>  <i>Reflex√µes</i> <br><br><h3>  Renderiza√ß√£o proativa </h3><br>  Os cart√µes Wolfenstein podem ser totalmente codificados em uma grade bidimensional de 64 √ó 64.  O mapa usado na demo √© baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro n√≠vel do epis√≥dio 1 do</a> Wolfenstein 3D. <br><br>  Na inicializa√ß√£o, toda a geometria necess√°ria para passar a renderiza√ß√£o proativa √© criada.  Uma malha de paredes √© gerada a partir de dados do mapa.  Tamb√©m cria planos de piso e teto, malhas separadas para luzes, portas e esferas aleat√≥rias. <br><br>  Todas as texturas usadas para paredes e portas s√£o empacotadas em um √∫nico atlas de textura, para que todas as paredes possam ser desenhadas em uma √∫nica chamada. <br><br><h4>  Sombras e ilumina√ß√£o </h4><br>  A ilumina√ß√£o direta √© calculada no sombreador usado para o passe de renderiza√ß√£o direta.  Cada fragmento pode ser iluminado (m√°ximo) por quatro fontes diferentes.  Para saber quais fontes podem influenciar o fragmento no sombreador, quando a demonstra√ß√£o √© iniciada, a textura da pesquisa √© pr√©-calculada.  Essa textura de pesquisa tem um tamanho de 64 por 128 e codifica as posi√ß√µes das 4 fontes de luz mais pr√≥ximas para cada posi√ß√£o na grade do mapa. <br><br><pre><code class="cpp hljs">varying vec3 vWorldPos; varying vec3 vNormal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ vec3 ro = vWorldPos; vec3 normal = normalize(vNormal); vec3 light = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;LIGHTS_ENCODED_IN_MAP; i++) { light += sampleLight(i, ro, normal); }</code> </pre> <br>  Para obter sombras suaves para cada fragmento e fonte de luz, √© amostrada uma posi√ß√£o aleat√≥ria na fonte de luz.  Usando o c√≥digo de rastreamento de raios no sombreador (consulte a se√ß√£o Rastreamento de raios abaixo), um raio de sombra √© emitido no ponto de amostragem para determinar a visibilidade da fonte de luz. <br><br>  Ap√≥s adicionar reflex√µes (auxiliares) (consulte a se√ß√£o Reflex√£o abaixo), a IG difusa √© adicionada √† cor calculada do fragmento, realizando uma pesquisa no alvo de renderiza√ß√£o da IG difusa (veja abaixo). <br><br><h3>  Tra√ßado de raio </h3><br>  Embora o c√≥digo do prot√≥tipo de rastreamento de raios para GI difuso tenha sido combinado com um sombreador preventivo, na demonstra√ß√£o, decidi separ√°-los. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/8fd/3ab/58b8fd3abd38a86da42e1454df7109de.png"></div><br>  Separei-os fazendo uma segunda renderiza√ß√£o de toda a geometria em um destino de renderiza√ß√£o separado (Diffuse GI Render Target) usando outro sombreador que emite apenas raios aleat√≥rios para coletar GI difusa (consulte a se√ß√£o ‚ÄúDiffuse GI‚Äù abaixo).  A ilumina√ß√£o coletada neste destino de renderiza√ß√£o √© adicionada √† ilumina√ß√£o direta calculada na passagem de renderiza√ß√£o direta. <br><br>  Ao separar o passe proativo e o GI difuso, podemos emitir menos de um feixe GI difuso por pixel da tela.  Isso pode ser feito reduzindo a escala do buffer (movendo o controle deslizante nas op√ß√µes no canto superior direito da tela). <br><br>  Por exemplo, se a Escala de buffer for 0,5, apenas um raio ser√° emitido para cada quatro pixels da tela.  Isso proporciona um enorme aumento de produtividade.  Usando a mesma interface do usu√°rio no canto superior direito da tela, voc√™ tamb√©m pode alterar o n√∫mero de amostras por pixel no alvo de renderiza√ß√£o (SPP) e o n√∫mero de reflex√µes de feixe. <br><br><h4>  Emite um feixe </h4><br>  Para poder emitir raios para a cena, toda a geometria de n√≠vel deve ter um formato que o tra√ßador de raios no shader possa usar.  A camada Wolfenstein codificou uma grade de 64 √ó 64, portanto, √© f√°cil codificar todos os dados em uma √∫nica textura de 64 √ó 64: <br><br><ul><li>  No canal vermelho da cor da textura, todos os objetos localizados na c√©lula correspondente <em>x, y da</em> grade do mapa s√£o codificados.  Se o valor do canal vermelho for zero, n√£o haver√° objetos na c√©lula; caso contr√°rio, ele ser√° ocupado por uma parede (valores de 1 a 64), uma porta, uma fonte de luz ou uma esfera que precisa ser verificada quanto √† interse√ß√£o. </li><li>  Se uma esfera ocupa uma c√©lula da grade de n√≠vel, os canais verde, azul e alfa s√£o usados ‚Äã‚Äãpara codificar o raio e as coordenadas relativas <em>x</em> e <em>y</em> da esfera dentro da c√©lula da grade. </li></ul><br>  Um raio √© emitido em uma cena atravessando uma textura usando o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worldHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n vec3 ro,in vec3 rd,in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_min, in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_max, inout vec3 recPos, inout vec3 recNormal, inout vec3 recColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 pos = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(ro); vec3 ri = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/rd; vec3 rs = sign(rd); vec3 dis = (pos-ro + <span class="hljs-number"><span class="hljs-number">0.5</span></span> + rs*<span class="hljs-number"><span class="hljs-number">0.5</span></span>) * ri; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAXSTEPS; i++ ) { vec3 mm = step(dis.xyz, dis.zyx); dis += mm * rs * ri; pos += mm * rs; vec4 mapType = texture2D(_MapTexture, pos.xz * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / <span class="hljs-number"><span class="hljs-number">64.</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWall(mapType)) { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Um c√≥digo de rastreamento de raio de malha semelhante pode ser encontrado neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shader Wolfenstein</a> em Shadertoy. <br><br>  Depois de calcular o ponto de interse√ß√£o com a parede ou porta (usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o teste de interse√ß√£o com um paralelogramo</a> ), pesquisar no mesmo atlas de textura usado para passar a renderiza√ß√£o proativa nos d√° pontos de interse√ß√£o albedo.  As esferas t√™m uma cor que √© determinada procedimentalmente com base em suas coordenadas <em>x, y</em> na grade e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na fun√ß√£o gradiente de cores</a> . <br><br>  As portas s√£o um pouco mais complicadas porque est√£o se movendo.  Para que a representa√ß√£o de cena na CPU (usada para renderizar malhas no passo de renderiza√ß√£o direta) seja igual √† representa√ß√£o de cena na GPU (usada para rastreamento de raios), todas as portas se movem de forma autom√°tica e determin√≠stica, com base na dist√¢ncia da c√¢mera √† porta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/ded/058/3d7ded058d2f62fcf298c9b68b568a69.png"></div><br><br><h4>  Gi difuso </h4><br>  A ilumina√ß√£o global dispersa (IG difusa) √© calculada emitindo raios no sombreador, que √© usado para desenhar toda a geometria no alvo de renderiza√ß√£o da IG difusa.  A dire√ß√£o desses raios depende do normal para a superf√≠cie, determinado pela amostragem do hemisf√©rio com cosseno. <br><br>  Tendo a dire√ß√£o do feixe <em>rd</em> e o ponto inicial <em>ro</em> , a ilumina√ß√£o refletida pode ser calculada usando o seguinte ciclo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBounceCol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in vec3 ro, in vec3 rd, in vec3 col)</span></span></span><span class="hljs-function"> </span></span>{ vec3 emitted = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); vec3 recPos, recNormal, recColor; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAX_RECURSION; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worldHit(ro, rd, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">20.</span></span>, recPos, recNormal, recColor)) { <span class="hljs-comment"><span class="hljs-comment">// if (isLightHit) { // direct light sampling code // return vec3(0); // } col *= recColor; for (int i=0; i&lt;2; i++) { emitted += col * sampleLight(i, recPos, recNormal); } } else { return emitted; } rd = cosWeightedRandomHemisphereDirection(recNormal); ro = recPos; } return emitted; }</span></span></code> </pre> <br>  Para reduzir o ru√≠do, a amostragem direta de luz √© adicionada ao loop.  Isso √© semelhante √† t√©cnica usada no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro</a> shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cornell Box</a> no Shadertoy. <br><br><h4>  Reflex√£o </h4><br>  Gra√ßas √† capacidade de rastrear a cena com raios no shader, √© muito f√°cil adicionar reflexos.  Na minha demonstra√ß√£o, as reflex√µes s√£o adicionadas chamando o mesmo m√©todo <em>getBounceCol</em> mostrado acima, usando o feixe refletido da c√¢mera: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REFLECTION col = mix(col, getReflectionCol(ro, reflect(normalize(vWorldPos - _CamPos), normal), albedo), .15); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  As reflex√µes s√£o adicionadas no passo de renderiza√ß√£o direta; portanto, um raio de reflex√£o sempre emitir√° um feixe de reflex√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/e84/d6a/a88e84d6a2d0209234d6edaf02fcc441.png"></div><br><h3>  Anti-aliasing temporal </h3><br>  Como ambas as sombras suaves na renderiza√ß√£o direta passam e a aproxima√ß√£o GI difusa usa aproximadamente uma amostra por pixel, o resultado final √© extremamente barulhento.  Para reduzir a quantidade de ru√≠do, o anti-aliasing temporal (TAA) foi usado com base no TAA de Playdead: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anti-Aliasing de reproje√ß√£o temporal no INSIDE</a> . <br><br><h4>  Re-proje√ß√£o </h4><br>  A id√©ia por tr√°s do TAA √© bastante simples: o TAA calcula um subpixel por quadro e calcula a m√©dia de seus valores com o pixel correlacionado do quadro anterior. <br><br>  Para saber onde o pixel atual estava no quadro anterior, a posi√ß√£o do fragmento √© reprojetada usando a matriz de exibi√ß√£o de modelo-proje√ß√£o do quadro anterior. <br><br><h4>  Coletar amostras e limitar bairros </h4><br>  Em alguns casos, uma amostra salva do passado √© inv√°lida, por exemplo, quando a c√¢mera se move de tal maneira que um fragmento do quadro atual no quadro anterior foi fechado por geometria.  Para descartar amostras inv√°lidas, √© usada uma restri√ß√£o de vizinhan√ßa.  Eu escolhi o tipo mais simples de restri√ß√£o: <br><br><pre> <code class="cpp hljs">vec3 history = texture2D(_History, uvOld ).rgb; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; x+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; y+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { vec3 n = texture2D(_New, vUV + vec2(x,y) / _Resolution).rgb; mx = max(n, mx); mn = min(n, mn); } } vec3 history_clamped = clamp(history, mn, mx);</code> </pre> <br>  Tamb√©m tentei usar o m√©todo de restri√ß√£o com base no paralelogramo delimitador, mas n√£o vi muita diferen√ßa com minha solu√ß√£o.  Provavelmente isso aconteceu porque na cena da demonstra√ß√£o existem muitas cores escuras id√™nticas e quase nenhum objeto em movimento. <br><br><h4>  Vibra√ß√µes da c√¢mera </h4><br>  Para obter a suaviza√ß√£o de serrilhado, a c√¢mera em cada quadro oscila devido ao uso de (pseudo) deslocamento aleat√≥rio de subpixel.  Isso √© implementado alterando a matriz de proje√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderHeight;</code> </pre> <br><h3>  O barulho </h3><br>  O ru√≠do √© a base dos algoritmos usados ‚Äã‚Äãpara calcular o GI difuso e sombras suaves.  O uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ru√≠do bom</a> afeta muito a qualidade da imagem, enquanto o ru√≠do ruim cria artefatos ou diminui a converg√™ncia da imagem. <br><br>  Receio que o ru√≠do branco usado nesta demonstra√ß√£o n√£o seja muito bom. <br><br>  Usar um bom ru√≠do √© provavelmente o aspecto mais importante para melhorar a qualidade da imagem nesta demonstra√ß√£o.  Por exemplo, voc√™ pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ru√≠do azul</a> . <br><br>  Realizei experimentos com ru√≠do com base na propor√ß√£o √°urea, mas eles n√£o tiveram sucesso.  At√© agora, o infame <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hash sem seno de</a> Dave Hoskins √© usado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 p3 = fract(vec3(g_seed += <span class="hljs-number"><span class="hljs-number">0.1</span></span>) * HASHSCALE3); p3 += dot(p3, p3.yzx + <span class="hljs-number"><span class="hljs-number">19.19</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract((p3.xx+p3.yz)*p3.zy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a81/338/42a/a8133842a43266dad1b4e9ee50c59228.png"></div><br><h3>  Redu√ß√£o de ru√≠do </h3><br>  Mesmo com o TAA ativado, a demonstra√ß√£o ainda mostra muito ru√≠do.  √â especialmente dif√≠cil renderizar o teto, porque ele √© iluminado apenas por ilumina√ß√£o indireta.  Isso n√£o simplifica a situa√ß√£o em que o teto √© uma grande superf√≠cie plana, preenchida com uma cor s√≥lida: se tivesse textura ou detalhes geom√©tricos, o ru√≠do se tornaria menos percept√≠vel. <br><br>  Como n√£o queria gastar muito tempo nessa parte da demonstra√ß√£o, tentei aplicar apenas um filtro de redu√ß√£o de ru√≠do: a Median3x3 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Morgan McGuire e Kyle Witson</a> .  Infelizmente, esse filtro n√£o funciona muito bem com gr√°ficos de "pixel art" de texturas de parede: remove todos os detalhes √† dist√¢ncia e arredonda os cantos dos pixels das paredes pr√≥ximas. <br><br>  Em outro experimento, apliquei o mesmo filtro no destino de renderiza√ß√£o GI difuso.  Embora ele tenha reduzido um pouco o ru√≠do, ao mesmo tempo quase sem alterar os detalhes das texturas da parede, decidi que essa melhoria n√£o valia os milissegundos extras gastos. <br><br><h3>  Demo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Voc√™ pode jogar a demo aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444516/">https://habr.com/ru/post/pt444516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444502/index.html">A criptografia qu√¢ntica √© realmente confi√°vel?</a></li>
<li><a href="../pt444504/index.html">Usando o diret√≥rio local do pacote no Python agora</a></li>
<li><a href="../pt444508/index.html">Como criamos o PHP 7 duas vezes mais r√°pido que o PHP 5. Parte 1: otimizando estruturas de dados</a></li>
<li><a href="../pt444512/index.html">Criando uma aplica√ß√£o gr√°fica para resolver o problema do percurso do cavalo</a></li>
<li><a href="../pt444514/index.html">Webinar "Seguran√ßa do aprendizado de m√°quina: problemas naturais da intelig√™ncia artificial"</a></li>
<li><a href="../pt444518/index.html">Rumo a uma teoria fundamental da consci√™ncia</a></li>
<li><a href="../pt444520/index.html">2. Introdu√ß√£o ao Ponto de Verifica√ß√£o R80.20. Arquitetura da solu√ß√£o</a></li>
<li><a href="../pt444522/index.html">Apocalipse √© cancelado</a></li>
<li><a href="../pt444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../pt444526/index.html">Pilha de DOTS: C ++ e C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>