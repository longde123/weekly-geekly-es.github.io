<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✳️ 👨‍🌾 🌈 Hukum Refleksi dalam Go 🧡 🕊️ 🖇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "The Laws of Reflection" dari pencipta bahasa. 

 Refleksi adalah kemampuan suatu prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hukum Refleksi dalam Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"The Laws of Reflection"</a> dari pencipta bahasa. <br><br>  Refleksi adalah kemampuan suatu program untuk mengeksplorasi strukturnya sendiri, terutama melalui tipe.  Ini adalah bentuk metaprogramming dan sumber kebingungan. <br>  Di Go, refleksi banyak digunakan, misalnya, dalam paket tes dan fmt.  Di artikel ini, kami akan mencoba untuk menghilangkan "sihir" dengan menjelaskan cara kerja refleksi di Go. <br><a name="habracut"></a><br><h3>  Jenis dan Antarmuka </h3><br>  Karena refleksi didasarkan pada sistem tipe, mari menyegarkan pengetahuan kita tentang tipe di Go. <br>  Go diketik secara statis.  Setiap variabel memiliki satu dan hanya satu tipe statis yang diperbaiki pada waktu kompilasi: <code>int, float32, *MyType, []byte</code> ... Jika kita mendeklarasikan: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  maka <code>i</code> adalah tipe <code>int</code> dan <code>j</code> adalah tipe <code>MyInt</code> .  Variabel <code>i</code> dan <code>j</code> memiliki tipe statis yang berbeda dan, meskipun mereka memiliki tipe dasar yang sama, mereka tidak dapat ditugaskan satu sama lain tanpa konversi. <br><br>  Salah satu kategori jenis penting adalah antarmuka, yang merupakan set metode tetap.  Antarmuka dapat menyimpan nilai spesifik (non-antarmuka) selama nilai ini mengimplementasikan metode antarmuka.  Sepasang contoh yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkenal</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">io.Reader dan io.Writer</a> , tipe Reader dan Writer dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket io</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Dikatakan bahwa setiap jenis yang mengimplementasikan metode <code>Read()</code> atau <code>Write()</code> dengan tanda tangan ini mengimplementasikan masing-masing <code>io.Reader</code> atau <code>io.Writer</code> .  Ini berarti bahwa variabel tipe <code>io.Reader</code> dapat berisi nilai apa pun dari tipe Read (): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  Penting untuk memahami bahwa <code>r</code> dapat diberi nilai apa pun yang mengimplementasikan <code>io.Reader</code> .  Go diketik secara statis, dan tipe statis <code>r</code> adalah <code>io.Reader</code> . <br><br>  Contoh yang sangat penting dari jenis antarmuka adalah antarmuka kosong: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  Ini adalah set kosong metode ∅ dan diimplementasikan dengan nilai apa pun. <br>  Beberapa mengatakan antarmuka Go adalah variabel yang diketik secara dinamis, tetapi ini adalah kesalahan.  Mereka diketik secara statis: variabel dengan tipe antarmuka selalu memiliki tipe statis yang sama, dan meskipun pada saat dijalankan nilai yang disimpan dalam variabel antarmuka dapat mengubah jenisnya, nilai ini akan selalu memenuhi antarmuka.  (Tidak ada yang <code>undefined</code> , <code>NaN</code> atau hal-hal lain yang merusak logika program.) <br><br>  Ini harus dipahami - refleksi dan antarmuka terkait erat. <br><br><h3>  Representasi internal antarmuka </h3><br>  Russ Cox menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog</a> terperinci tentang pengaturan antarmuka di Go.  Artikel yang tak kalah bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang Habr'e</a> .  Tidak perlu mengulangi keseluruhan cerita, poin-poin utama disebutkan. <br><br>  Variabel tipe antarmuka memegang pasangan: nilai spesifik yang ditetapkan untuk variabel, dan deskriptor tipe untuk nilai itu.  Lebih tepatnya, nilainya adalah elemen data dasar yang mengimplementasikan antarmuka, dan tipe menggambarkan tipe lengkap elemen ini.  Misalnya setelah <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> berisi, secara skematis, pasangan <code>(, ) --&gt; (tty, *os.File)</code> .  Perhatikan bahwa <code>*os.File</code> jenis mengimplementasikan metode selain <code>Read()</code> ;  bahkan jika nilai antarmuka hanya menyediakan akses ke metode Baca (), nilai di dalamnya membawa semua informasi tentang jenis nilai ini.  Inilah mengapa kita dapat melakukan hal-hal seperti itu: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  Ekspresi dalam penugasan ini adalah pernyataan tipe;  ia mengklaim bahwa elemen di dalam <code>r</code> juga mengimplementasikan <code>io.Writer</code> , dan karenanya kita dapat menugaskannya ke <code>w</code> .  Setelah ditetapkan, <code>w</code> akan berisi pasangan <code>(tty, *os.File)</code> .  Ini adalah pasangan yang sama dengan di <code>r</code> .  Tipe statis dari antarmuka menentukan metode mana yang dapat dipanggil pada variabel antarmuka, meskipun serangkaian metode yang lebih luas dapat memiliki nilai spesifik di dalamnya. <br><br>  Melanjutkan, kita dapat melakukan hal berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  dan nilai kosong dari bidang kosong lagi akan berisi pasangan yang sama <code>(tty, *os.File)</code> .  Ini nyaman: antarmuka kosong dapat berisi nilai apa pun dan semua informasi yang kita perlukan darinya. <br><br>  Kami tidak memerlukan pernyataan tipe di sini, karena diketahui bahwa <code>w</code> memenuhi antarmuka kosong.  Dalam contoh di mana kami mentransfer nilai dari <code>Reader</code> ke <code>Writer</code> , kami perlu secara eksplisit menggunakan pernyataan tipe, karena metode <code>Writer</code> bukan merupakan subset dari <code>Reader</code> .  Mencoba mengonversi nilai yang tidak cocok dengan antarmuka akan menyebabkan kepanikan. <br><br>  Satu detail penting adalah bahwa pasangan di dalam antarmuka selalu memiliki formulir (nilai, tipe spesifik) dan tidak dapat memiliki formulir (nilai, antarmuka).  Antarmuka tidak mendukung antarmuka sebagai nilai. <br><br>  Sekarang kita siap untuk belajar refleksi. <br><br><h3>  Hukum <s>refleksi pertama</s> mencerminkan </h3><br><ul><li>  Refleksi meluas dari antarmuka ke refleksi objek. </li></ul><br>  Pada tingkat dasar, mencerminkan hanyalah sebuah mekanisme untuk memeriksa sepasang jenis dan nilai yang disimpan dalam variabel antarmuka.  Untuk memulai, ada dua jenis yang perlu kita ketahui: <code>reflect.Type</code> dan <code>reflect.Value</code> .  Kedua jenis ini menyediakan akses ke konten variabel antarmuka dan masing-masing dikembalikan oleh fungsi sederhana, reflect.TypeOf () dan reflect.ValueOf ().  Mereka mengekstrak bagian dari arti antarmuka.  (Selain itu, <code>reflect.Value</code> mudah untuk mendapatkan <code>reflect.Type</code> , tetapi jangan gabungkan konsep <code>Value</code> dan <code>Type</code> saat ini.) <br><br>  Mari kita mulai dengan <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  Program akan menampilkan <br> <code>type: float64</code> <br> <br>  Program ini mirip dengan melewatkan variabel <code>float64 x</code> sederhana untuk <code>float64 x</code> <code>reflect.TypeOf()</code> .  Apakah Anda melihat antarmuka?  Dan itu - <code>reflect.TypeOf()</code> menerima antarmuka kosong, sesuai dengan deklarasi fungsi: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Ketika kita memanggil <code>reflect.TypeOf(x)</code> , <code>x</code> pertama kali disimpan dalam antarmuka kosong, yang kemudian diteruskan sebagai argumen;  <code>reflect.TypeOf()</code> membongkar antarmuka kosong ini untuk mengembalikan informasi jenis. <br><br>  Fungsi <code>reflect.ValueOf()</code> , tentu saja, mengembalikan nilai (selanjutnya kami akan mengabaikan template dan fokus pada kode): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  akan dicetak <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Kami memanggil metode <code>String()</code> secara eksplisit karena, secara default, paket fmt membongkar untuk <code>reflect.Value</code> dan mencetak nilai tertentu.) <br>  <code>reflect.Type</code> dan <code>reflect.Type</code> keduanya memiliki banyak metode, yang memungkinkan Anda untuk menjelajahi dan memodifikasinya.  Salah satu contoh penting adalah <code>reflect.Value</code> memiliki metode <code>Type()</code> yang mengembalikan tipe nilai.  <code>reflect.Type</code> dan <code>reflect.Value</code> memiliki metode <code>Kind()</code> yang mengembalikan konstanta yang menunjukkan elemen primitif mana yang disimpan: <code>Uint, Float64, Slice</code> ... Konstanta ini dideklarasikan dalam enumerasi dalam paket mencerminkan.  Metode <code>Value</code> dengan nama seperti <code>Int()</code> dan <code>Float()</code> memungkinkan kami untuk mengeluarkan nilai (seperti int64 dan float64) yang terlampir di dalam: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  akan dicetak <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Ada juga metode seperti <code>SetInt()</code> dan <code>SetFloat()</code> , tetapi untuk menggunakannya kita perlu memahami settability, topik dari hukum refleksi ketiga. <br><br>  Pustaka refleksi memiliki beberapa properti yang perlu Anda sorot.  Pertama, untuk menjaga API tetap sederhana, metode <code>Value</code> "getter" dan "setter" bekerja pada tipe terbesar yang dapat berisi nilai: <code>int64</code> untuk semua bilangan bulat yang <code>int64</code> .  Yaitu, metode <code>Int()</code> dari nilai <code>Value</code> mengembalikan <code>int64</code> , dan nilai <code>SetInt()</code> mengambil <code>int64</code> ;  konversi ke tipe aktual mungkin diperlukan: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  akan <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Di sini <code>v.Uint()</code> akan mengembalikan <code>uint64</code> , pernyataan tipe eksplisit diperlukan. <br><br>  Properti kedua adalah bahwa <code>Kind()</code> mencerminkan objek menggambarkan tipe dasar, bukan tipe statis.  Jika objek refleksi berisi nilai tipe integer yang ditentukan pengguna, seperti pada <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , meskipun tipe statis <code>x</code> adalah <code>MyInt</code> , bukan <code>int</code> .  Dengan kata lain, <code>Kind()</code> tidak dapat membedakan <code>int</code> dari <code>MyInt</code> , <code>MyInt</code> <code>Type()</code> .  <code>Kind</code> hanya dapat menerima nilai tipe bawaan. <br><br><h3>  Hukum <s>refleksi</s> kedua mencerminkan </h3><br><ul><li>  Refleksi meluas dari objek pantulan ke antarmuka. </li></ul><br>  Seperti refleksi fisik, pantulan dalam Go menciptakan kebalikannya. <br><br>  Memiliki <code>reflect.Value</code> , kita dapat mengembalikan nilai antarmuka menggunakan metode <code>Interface()</code> ;  Metode ini mengemas informasi jenis dan nilai kembali ke antarmuka dan mengembalikan hasilnya: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  Sebagai contoh: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  mencetak nilai <code>float64</code> diwakili oleh objek refleksi <code>v</code> . <br>  Namun, kita dapat melakukan yang lebih baik lagi.  Argumen di <code>fmt.Println()</code> dan <code>fmt.Printf()</code> dilewatkan sebagai antarmuka kosong, yang kemudian dibongkar oleh paket fmt secara internal, seperti pada contoh sebelumnya.  Oleh karena itu, semua yang diperlukan untuk mencetak konten <code>reflect.Value</code> dengan benar adalah meneruskan hasil dari metode <code>Interface()</code> ke fungsi output yang diformat: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (Mengapa tidak <code>fmt.Println(v)</code> ? Karena <code>v</code> adalah tipe <code>reflect.Value</code> ; kami ingin mendapatkan nilai yang terkandung di dalamnya.) Karena nilai kami adalah <code>float64</code> , kami bahkan dapat menggunakan format floating point jika kami mau: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  akan menampilkan dalam kasus tertentu <br> <code>3.4e+00</code> <br> <br>  Sekali lagi, tidak perlu <code>v.Interface()</code> tipe hasil <code>v.Interface()</code> di <code>float64</code> ;  nilai antarmuka kosong berisi informasi tentang nilai spesifik di dalamnya, dan <code>fmt.Printf()</code> mengembalikannya. <br>  Singkatnya, metode <code>Interface()</code> adalah kebalikan dari fungsi <code>ValueOf()</code> , kecuali bahwa hasilnya selalu dari <code>interface{}</code> tipe statis <code>interface{}</code> . <br><br>  Ulangi: Refleksi meluas dari nilai antarmuka ke objek refleksi dan sebaliknya. <br><br><h3>  Hukum ketiga <s>refleksi</s> refleksi </h3><br><ul><li>  Untuk mengubah objek refleksi, nilainya harus dapat disetel. </li></ul><br>  Hukum ketiga adalah yang paling halus dan membingungkan.  Kami mulai dengan prinsip pertama. <br>  Kode ini tidak berfungsi, tetapi perlu diperhatikan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Jika Anda menjalankan kode ini, kode itu akan macet karena panik dengan pesan penting: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  Masalahnya bukan bahwa <code>7.1</code> literal tidak ditangani;  inilah yang <code>v</code> tidak dapat diinstal.  <code>reflect.Value</code> adalah properti dari <code>reflect.Value</code> , dan tidak setiap <code>reflect.Value</code> memilikinya. <br>  Metode <code>reflect.Value.CanSet()</code> yang ditetapkan;  dalam kasus kami: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  akan dicetak: <br> <code>settability of v: false</code> <br> <br>  Terjadi kesalahan saat memanggil metode <code>Set()</code> pada nilai yang tidak dikelola.  Tapi apa itu instalabilitas? <br><br>  Keberlanjutan agak mirip dengan addressability, tetapi lebih ketat.  Ini adalah properti tempat objek refleksi dapat mengubah nilai yang disimpan yang digunakan untuk membuat objek refleksi.  Keberlanjutan ditentukan oleh apakah objek refleksi berisi elemen sumber, atau hanya salinannya.  Ketika kita menulis: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  kami meneruskan salinan <code>x</code> ke <code>reflect.ValueOf()</code> , sehingga antarmuka dibuat sebagai argumen untuk <code>reflect.ValueOf()</code> - ini adalah salinan <code>x</code> , bukan <code>x</code> itu sendiri.  Jadi, jika pernyataan: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  jika dijalankan, itu tidak akan memperbarui <code>x</code> , meskipun <code>v</code> sepertinya itu dibuat dari <code>x</code> .  Sebagai gantinya, ia akan memperbarui salinan <code>x</code> tersimpan di dalam nilai <code>v</code> , dan <code>x</code> itu sendiri tidak akan terpengaruh.  Ini dilarang agar tidak menimbulkan masalah, dan instalabilitas adalah properti yang digunakan untuk mencegah masalah. <br><br>  Ini seharusnya tidak aneh.  Ini adalah situasi umum dalam pakaian yang tidak biasa.  Pertimbangkan untuk meneruskan <code>x</code> ke fungsi: <br> <code>f(x)</code> <br> <br>  Kami tidak berharap <code>f()</code> dapat mengubah <code>x</code> , karena kami melewati salinan nilai <code>x</code> , bukan <code>x</code> itu sendiri.  Jika kita ingin <code>f()</code> secara langsung mengubah <code>x</code> , kita harus meneruskan sebuah pointer ke <code>x</code> ke fungsi kita: <br> <code>f(&amp;x)</code> <br> <br>  Ini mudah dan akrab, dan refleksi bekerja dengan cara yang sama.  Jika kita ingin mengubah <code>x</code> menggunakan refleksi, kita harus menyediakan pointer perpustakaan dengan nilai yang ingin kita ubah. <br><br>  Ayo lakukan.  Pertama, kita menginisialisasi <code>x</code> seperti biasa, dan kemudian membuat <code>reflect.Value p</code> yang menunjuk ke sana. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  akan menampilkan <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  Objek Refleksi <code>p</code> tidak dapat diatur, tetapi bukan <code>p</code> yang ingin kita atur, itu adalah pointer <code>*p</code> .  Untuk mendapatkan poin <code>p</code> , kita memanggil metode <code>Value.Elem()</code> , yang mengambil nilai secara tidak langsung melalui pointer, dan menyimpan hasilnya dalam <code>reflect.Value v</code> : <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Sekarang <code>v</code> adalah objek yang dapat diinstal; <br> <code>settability of v: true</code> <br>  dan karena itu merepresentasikan <code>x</code> , kita akhirnya bisa menggunakan <code>v.SetFloat()</code> untuk mengubah nilai <code>x</code> : <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  kesimpulan seperti yang diharapkan <br> <code>7.1 <br> 7.1</code> <br>  Refleksi mungkin sulit untuk dipahami, tetapi ia melakukan persis seperti apa bahasa itu, meskipun dengan bantuan <code>reflect.Type</code> dan <code>reflection.Value</code> , yang dapat menyembunyikan apa yang terjadi.  Perlu diingat bahwa <code>reflection.Value</code> memerlukan alamat variabel untuk mengubahnya. <br><br><h3>  Struktur </h3><br>  Dalam contoh kita sebelumnya, <code>v</code> bukan pointer, itu hanya diturunkan darinya.  Cara umum untuk membuat situasi ini adalah menggunakan refleksi untuk mengubah bidang struktur.  Selama kita memiliki alamat struktur, kita dapat mengubah bidangnya. <br><br>  Berikut adalah contoh sederhana yang menganalisis nilai struktur <code>t</code> .  Kami membuat objek refleksi dengan alamat struktur untuk memodifikasinya nanti.  Kemudian atur typeOfT ke tipenya dan lakukan iterasi pada field menggunakan pemanggilan metode sederhana (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket untuk penjelasan terperinci</a> ).  Perhatikan bahwa kami mengekstraksi nama bidang dari tipe struktur, tetapi bidang itu sendiri adalah <code>reflect.Value</code> biasa. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  Program akan menampilkan <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Satu hal lagi tentang installabilitas ditunjukkan di sini: nama bidang <code>T</code> dalam huruf besar (diekspor), karena hanya bidang yang diekspor yang dapat diatur. <br>  Karena <code>s</code> berisi objek refleksi yang dapat diinstal, kita dapat mengubah bidang struktur. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  Hasil: <br> <code>t is now {77 Sunset Strip}</code> <br>  Jika kita mengubah program sehingga <code>s</code> dibuat dari <code>t</code> daripada <code>&amp;t</code> , panggilan ke <code>SetInt()</code> dan <code>SetString()</code> akan berakhir dengan panik, karena bidang <code>t</code> tidak akan dapat diatur. <br><br><h3>  Kesimpulan </h3><br>  Ingat hukum refleksi: <br><br><ul><li>  Refleksi meluas dari antarmuka ke refleksi objek. </li><li>  Refleksi meluas dari refleksi objek ke antarmuka. </li><li>  Untuk mengubah objek refleksi, nilai harus ditetapkan. </li></ul><br>  Diposting oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415171/">https://habr.com/ru/post/id415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415159/index.html">Pengumuman DevOps-conference DevOops 2018</a></li>
<li><a href="../id415163/index.html">Jaringan nirkabel di pabrik farmasi yang dijaga khusus dan terlindung secara khusus di beberapa tempat di Rusia</a></li>
<li><a href="../id415165/index.html">Rilis Node.js 10.5: multithreading di luar kotak</a></li>
<li><a href="../id415167/index.html">Buka pelajaran “Multithreading di Jawa. Primitif sinkronisasi dasar »</a></li>
<li><a href="../id415169/index.html">Kompresi dan deduplikasi: Mengurangi ukuran arsip email dan cadangan menggunakan musim dingin ZxPowerstore</a></li>
<li><a href="../id415175/index.html">Wawancara dengan Anggota Augmented World Expo</a></li>
<li><a href="../id415177/index.html">Selamat datang</a></li>
<li><a href="../id415181/index.html">[Yekaterinburg, pengumuman] Mitap analis - tentang analis pertama dan CBAP, tentang metrik, tentang sektor publik, dan jenis analis</a></li>
<li><a href="../id415183/index.html">Ekstensi web lintas browser untuk skrip khusus Bagian 1</a></li>
<li><a href="../id415185/index.html">3CX WebMeeting Konferensi Video Gratis: Gambaran Umum Fitur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>