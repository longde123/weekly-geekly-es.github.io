<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÑÔ∏è üë®‚Äçüî¨ üóº C√≥mo soltar 10 millones de paquetes por segundo ‚ôàÔ∏è üëÆ üò∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la compa√±√≠a, nuestro equipo para contrarrestar los ataques DDoS se llama "droppers de paquetes". Si bien todos los dem√°s equipos est√°n haciendo cos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo soltar 10 millones de paquetes por segundo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419921/"> En la compa√±√≠a, nuestro equipo para contrarrestar los ataques DDoS se llama "droppers de paquetes".  Si bien todos los dem√°s equipos est√°n haciendo cosas interesantes con el tr√°fico que pasa por nuestra red, nos divertimos encontrando nuevas formas de deshacernos de √©l. <br><br><img src="https://habrastorage.org/webt/s-/3y/un/s-3yun8pllqd7-e077fuxbk9jiw.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brian Evans</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CC BY-SA 2.0</a></i> <br><br>  La capacidad de descartar paquetes r√°pidamente es muy importante para oponerse a los ataques DDoS. <br><br>  Los paquetes descartados que llegan a nuestros servidores se pueden realizar en varios niveles.  Cada m√©todo tiene sus pros y sus contras.  Debajo del corte, miramos todo lo que probamos. <br><a name="habracut"></a><br><blockquote>  <i>Nota del traductor: en la salida de algunos de los comandos presentados, se eliminaron espacios adicionales para mantener la legibilidad.</i> </blockquote><h1>  Sitio de prueba </h1><br>  Para la conveniencia de comparar los m√©todos, le proporcionaremos algunos n√∫meros, sin embargo, no los tome demasiado literalmente, debido a la artificialidad de las pruebas.  Utilizaremos una de nuestras tarjetas de red Intel de 10 Gb / s.  Las caracter√≠sticas restantes del servidor no son tan importantes, porque queremos centrarnos en las limitaciones del sistema operativo, no en el hardware. <br><br>  Nuestras pruebas se ver√°n de la siguiente manera: <br><br><ul><li>  Creamos una carga de una gran cantidad de paquetes UDP peque√±os, alcanzando un valor de 14 millones de paquetes por segundo; </li><li>  Todo este tr√°fico se dirige a un n√∫cleo de procesador del servidor seleccionado; </li><li>  Medimos el n√∫mero de paquetes procesados ‚Äã‚Äãpor el n√∫cleo en un solo n√∫cleo de procesador. </li></ul><br>  El tr√°fico artificial se genera de tal manera que se crea una carga m√°xima: se utilizan una direcci√≥n IP aleatoria y un puerto del remitente.  As√≠ es como se ve en tcpdump: <br><br><pre><code class="bash hljs">$ tcpdump -ni vlan100 -c 10 -t udp and dst port 1234 IP 198.18.40.55.32059 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.51.16.30852 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.35.51.61823 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.44.42.30344 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.106.227.38592 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.48.67.19533 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.49.38.40566 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.50.73.22989 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.43.204.37895 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.104.128.1543 &gt; 198.18.0.12.1234: UDP, length 16</code> </pre> <br>  En el servidor seleccionado, todos los paquetes se convertir√°n en una cola RX y, por lo tanto, ser√°n procesados ‚Äã‚Äãpor un n√∫cleo.  Logramos esto con el control de flujo de hardware: <br><br><pre> <code class="bash hljs">ethtool -N ext0 flow-type udp4 dst-ip 198.18.0.12 dst-port 1234 action 2</code> </pre><br>  Las pruebas de rendimiento son un proceso complejo.  Cuando preparamos las pruebas, notamos que la presencia de sockets sin procesar activos afecta negativamente el rendimiento, por lo que antes de ejecutar las pruebas, debe asegurarse de que no se est√© ejecutando <code>tcpdump</code> .  Hay una manera f√°cil de verificar si hay procesos incorrectos: <br><br><pre> <code class="bash hljs">$ ss -A raw,packet_raw -l -p|cat Netid State Recv-Q Send-Q Local Address:Port p_raw UNCONN 525157 0 *:vlan100 users:((<span class="hljs-string"><span class="hljs-string">"tcpdump"</span></span>,pid=23683,fd=3))</code> </pre><br>  Y finalmente, apagamos Intel Turbo Boost en nuestro servidor: <br><br><pre> <code class="hljs pgsql">echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee /sys/devices/<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>/cpu/intel_pstate/no_turbo</code> </pre> <br>  A pesar de que Turbo Boost es una gran cosa y aumenta el rendimiento en al menos un 20%, arruina significativamente la desviaci√≥n est√°ndar en nuestras pruebas.  Con turbo encendido, la desviaci√≥n alcanza ¬± 1.5%, mientras que sin ella solo 0.25%. <br><br><img src="https://habrastorage.org/webt/ic/ik/jq/icikjqda_ztydjswe8xjq07u5sa.png"><br><br><h3>  Paso 1. Descarte los paquetes en la aplicaci√≥n </h3><br>  Comencemos con la idea de entregar todos los paquetes a la aplicaci√≥n e ignorarlos all√≠.  Para la honestidad del experimento, aseg√∫rese de que iptables no afecte el rendimiento de ninguna manera: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t mangle -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I INPUT -t filter -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT</code> </pre><br>  La aplicaci√≥n es un ciclo simple en el que los datos recibidos se descartan inmediatamente: <br><br><pre> <code class="python hljs">s = socket.socket(AF_INET, SOCK_DGRAM) s.bind((<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-number"><span class="hljs-number">1234</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: s.recvmmsg([...])</code> </pre><br>  Ya hemos preparado el <a href="">c√≥digo</a> , ejecuta: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=171261 bytes=1940176</code> </pre><br>  Esta soluci√≥n permite que el n√∫cleo tome solo 175 mil paquetes de la cola de hardware, como lo midi√≥ <code>ethtool</code> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestras</a> <code>mmwatch</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|grep rx_2'</span></span> rx2_packets: 174.0k/s</code> </pre><br>  T√©cnicamente, 14 millones de paquetes por segundo llegan al servidor, sin embargo, un n√∫cleo de procesador no puede hacer frente a ese volumen.  <code>mpstat</code> confirma esto: <br><br><pre> <code class="bash hljs">$ watch <span class="hljs-string"><span class="hljs-string">'mpstat -u -I SUM -P ALL 1 1|egrep -v Aver'</span></span> 01:32:05 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:32:06 PM 0 0.00 0.00 0.00 2.94 0.00 3.92 0.00 0.00 0.00 93.14 01:32:06 PM 1 2.17 0.00 27.17 0.00 0.00 0.00 0.00 0.00 0.00 70.65 01:32:06 PM 2 0.00 0.00 0.00 0.00 0.00 100.00 0.00 0.00 0.00 0.00 01:32:06 PM 3 0.95 0.00 1.90 0.95 0.00 3.81 0.00 0.00 0.00 92.38</code> </pre><br><br>  Como podemos ver, la aplicaci√≥n no es un cuello de botella: la CPU # 1 se usa al 27.17% + 2.17%, mientras que el manejo de interrupciones ocupa el 100% en la CPU # 2. <br><br>  Usar <code>recvmessagge(2)</code> juega un papel importante.  Despu√©s de que se descubri√≥ la vulnerabilidad de Spectre, las llamadas al sistema se volvieron a√∫n m√°s caras debido al <abbr title="Aislamiento de tabla de p√°ginas del n√∫cleo">KPTI</abbr> y la <abbr title="Trampol√≠n de regreso">retpoline</abbr> utilizada en el n√∫cleo <br><br><pre> <code class="hljs ruby">$ tail -n +<span class="hljs-number"><span class="hljs-number">1</span></span> /sys/devices/system/cpu/vulnerabilities/* ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/meltdown</span></span> &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> PTI ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v1 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> __user pointer sanitization ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v2 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> Full generic retpoline, IBPB, IBRS_FW</code> </pre><br><br><h3>  Paso 2. Matar conntrack </h3><br>  Espec√≠ficamente, realizamos una carga de este tipo con diferentes puertos IP y de remitente para cargar conntrack tanto como sea posible.  El n√∫mero de entradas en conntrack durante la prueba tiende al m√°ximo posible y podemos verificar esto: <br><br><pre> <code class="bash hljs">$ conntrack -C 2095202 $ sysctl net.netfilter.nf_conntrack_max net.netfilter.nf_conntrack_max = 2097152</code> </pre><br>  Adem√°s, en <code>dmesg</code> tambi√©n puedes ver gritos conntrack: <br><br><pre> <code class="bash hljs">[4029612.456673] nf_conntrack: nf_conntrack: table full, dropping packet [4029612.465787] nf_conntrack: nf_conntrack: table full, dropping packet [4029617.175957] net_ratelimit: 5731 callbacks suppressed</code> </pre><br>  As√≠ que vamos a apagarlo: <br><br><pre> <code class="bash hljs">iptables -t raw -I PREROUTING -d 198.18.0.12 -p udp -m udp --dport 1234 -j NOTRACK</code> </pre><br>  Y reinicie las pruebas: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=331008 bytes=5296128</code> </pre><br><br>  Esto nos permiti√≥ alcanzar la marca de 333 mil paquetes por segundo.  ¬°Hurra! <br>  PD Usando SO_BUSY_POLL podemos alcanzar hasta 470 mil por segundo, sin embargo, este es un tema para una publicaci√≥n separada. <br><br><h3>  Paso 3. Filtro de lote Berkeley </h3><br>  Sigamos adelante.  ¬øPor qu√© necesitamos entregar paquetes a la aplicaci√≥n?  Aunque esta no es una soluci√≥n com√∫n, podemos vincular el cl√°sico filtro de paquetes de Berkeley al socket llamando a <code>setsockopt(SO_ATTACH_FILTER)</code> y configurar el filtro para que los paquetes vuelvan a caer en el n√∫cleo. <br>  Prepare el <a href="">c√≥digo</a> , ejecute: <br><br><pre> <code class="bash hljs">$ ./bpf-drop packets=0 bytes=0</code> </pre><br>  Usando un filtro de paquetes (los filtros Berkeley cl√°sicos y avanzados ofrecen un rendimiento m√°s o menos similar), llegamos a aproximadamente 512 mil paquetes por segundo.  Adem√°s, dejar caer un paquete durante una interrupci√≥n libera al procesador de tener que activar la aplicaci√≥n. <br><br><h3>  Paso 4. iptables DROP despu√©s del enrutamiento </h3><br>  Ahora podemos descartar paquetes agregando la siguiente regla a iptables en la cadena INPUT: <br><br><pre> <code class="bash hljs">iptables -I INPUT -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre><br>  Perm√≠tame recordarle que ya deshabilitamos conntrack con la regla <code>-j NOTRACK</code> .  Estas dos reglas nos dan 608 mil paquetes por segundo. <br><br>  Veamos los n√∫meros en iptables: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'iptables -L -v -n -x | head'</span></span> Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> destination 605.9k/s 26.7m/s DROP udp -- * * 0.0.0.0/0 198.18.0.12 udp dpt:1234</code> </pre><br>  Bueno, no est√° mal, pero podemos hacerlo mejor. <br><br><h3>  Paso 5. iptabes DROP en PREROUTING </h3><br>  Una t√©cnica m√°s r√°pida es descartar paquetes antes de enrutarlos usando esta regla: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre> <br>  Esto nos permite descartar 1.688 millones de paquetes por segundo. <br><br>  De hecho, este es un salto ligeramente sorprendente en el rendimiento.  Todav√≠a no entiendo las razones, tal vez nuestro enrutamiento es complicado, o tal vez solo un error en la configuraci√≥n del servidor. <br><br>  En cualquier caso, las iptables sin procesar son mucho m√°s r√°pidas. <br><br><h3>  Paso 6. nftables DROP </h3><br>  La utilidad iptables ahora es un poco vieja.  Fue reemplazada por nftables.  Mira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta explicaci√≥n en video de</a> por qu√© nftables es el mejor.  Nftables promete ser m√°s r√°pido que el encanecimiento de iptables por una variedad de razones, incluidos los rumores de que las retpolines ralentizan mucho a iptables. <br><br>  Pero nuestro art√≠culo todav√≠a no se trata de comparar iptables y nftables, as√≠ que intentemos lo m√°s r√°pido que pueda hacer: <br><br><pre> <code class="bash hljs">nft add table netdev filter nft -- add chain netdev filter input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500 \; policy accept \; } nft add rule netdev filter input ip daddr 198.18.0.0/24 udp dport 1234 counter drop nft add rule netdev filter input ip6 daddr fd00::/64 udp dport 1234 counter drop</code> </pre><br>  Los contadores se pueden ver as√≠: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'nft --handle list chain netdev filter input'</span></span> table netdev filter { chain input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500; policy accept; ip daddr 198.18.0.0/24 udp dport 1234 counter packets 1.6m/s bytes 69.6m/s drop <span class="hljs-comment"><span class="hljs-comment"># handle 2 ip6 daddr fd00::/64 udp dport 1234 counter packets 0 bytes 0 drop # handle 3 } }</span></span></code> </pre><br>  El enlace de entrada nftables mostr√≥ valores de aproximadamente 1,53 millones de paquetes.  Esto es un poco menos que la cadena PREROUTING en iptables.  Pero hay un misterio en esto: te√≥ricamente, el enlace nftables va antes que PREROUTING iptables y, por lo tanto, debe procesarse m√°s r√°pido. <br><br>  En nuestra prueba, nftables es un poco m√°s lento que iptables, pero de todos modos nftables es m√°s genial.  : P <br><br><h3>  Paso 7. tc DROP </h3><br>  De manera algo inesperada, el enlace tc (control de tr√°fico) ocurre antes que iptables PREROUTING.  tc nos permite seleccionar paquetes de acuerdo con criterios simples y, por supuesto, descartarlos.  La sintaxis es un poco inusual, por lo que sugerimos usar <a href="">este script</a> para la configuraci√≥n.  Y necesitamos una regla bastante complicada que se vea as√≠: <br><br><pre> <code class="bash hljs">tc qdisc add dev vlan100 ingress tc filter add dev vlan100 parent ffff: prio 4 protocol ip u32 match ip protocol 17 0xff match ip dport 1234 0xffff match ip dst 198.18.0.0/24 flowid 1:1 action drop tc filter add dev vlan100 parent ffff: protocol ipv6 u32 match ip6 dport 1234 0xffff match ip6 dst fd00::/64 flowid 1:1 action drop</code> </pre><br>  Y podemos comprobarlo en acci√≥n: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'tc -s filter show dev vlan100 ingress'</span></span> filter parent ffff: protocol ip pref 4 u32 filter parent ffff: protocol ip pref 4 u32 fh 800: ht divisor 1 filter parent ffff: protocol ip pref 4 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 (rule hit 1.8m/s success 1.8m/s) match 00110000/00ff0000 at 8 (success 1.8m/s ) match 000004d2/0000ffff at 20 (success 1.8m/s ) match c612000c/ffffffff at 16 (success 1.8m/s ) action order 1: gact action drop random <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> none pass val 0 index 1 ref 1 <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 1 installed 1.0/s sec Action statistics: Sent 79.7m/s bytes 1.8m/s pkt (dropped 1.8m/s, overlimits 0 requeues 0)</code> </pre><br>  El enlace tc nos permiti√≥ dejar caer hasta 1.8 millones de paquetes por segundo en un solo n√∫cleo.  ¬°Esto es genial! <br>  Pero podemos hacerlo a√∫n m√°s r√°pido ... <br><br><h3>  Paso 8. XDP_DROP </h3><br>  Y finalmente, nuestra arma m√°s fuerte: XDP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eXpress Data Path</a> .  Con XDP, podemos ejecutar el c√≥digo extendido de Berkley Packet Filter (eBPF) directamente en el contexto del controlador de red y, lo m√°s importante, incluso antes de asignar memoria para <code>skbuff</code> , lo que nos promete un aumento en la velocidad. <br><br>  Por lo general, un proyecto XDP consta de dos partes: <br><br><ul><li>  c√≥digo eBPF descargable </li><li>  gestor de arranque que coloca el c√≥digo en la interfaz de red correcta </li></ul><br>  Escribir su gestor de arranque es una tarea dif√≠cil, as√≠ que simplemente use el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuevo chip iproute2</a> y cargue el c√≥digo con un comando simple: <br><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev ext0 xdp obj xdp-drop-ebpf.o</code> </pre><br>  Ta Dam! <br><br>  El c√≥digo fuente del <a href="">programa descargable eBPF est√° disponible aqu√≠</a> .  El programa analiza caracter√≠sticas de los paquetes IP como el protocolo UDP, la subred del remitente y el puerto de destino: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h_proto == htons(<span class="hljs-type"><span class="hljs-type">ETH_P_IP</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iph-&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPPROTO_UDP</span></span></span><span class="hljs-class"> &amp;&amp; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htonl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">daddr</span></span></span><span class="hljs-class">) &amp; 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xFFFFFF00</span></span></span><span class="hljs-class">) == 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xC6120000</span></span></span><span class="hljs-class"> // 198.18.0.0/24 &amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htons</span></span></span><span class="hljs-class">(1234)) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">XDP_DROP</span></span>; } }</code> </pre><br>  El programa XDP debe construirse utilizando el sonido met√°lico moderno, que puede generar el c√≥digo de bytes BPF.  Despu√©s de eso, podemos descargar y probar la funcionalidad del programa BFP: <br><br><pre> <code class="bash hljs">$ ip link show dev ext0 4: ext0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc fq state UP mode DEFAULT group default qlen 1000 link/ether 24:8a:07:8a:59:8e brd ff:ff:ff:ff:ff:ff prog/xdp id 5 tag aedc195cc0471f51 jited</code> </pre><br>  Y luego vea las estad√≠sticas en <code>ethtool</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|egrep "rx"|egrep -v ": 0"|egrep -v "cache|csum"'</span></span> rx_out_of_buffer: 4.4m/s rx_xdp_drop: 10.1m/s rx2_xdp_drop: 10.1m/s</code> </pre><br>  Yoo hoo!  ¬°Con XDP, podemos soltar hasta 10 millones de paquetes por segundo! <br><br><img src="https://habrastorage.org/webt/fq/mf/e5/fqmfe5jgs1qylz7fpwryoeey0ag.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrew Filer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CC BY-SA 2.0</a></i> <br><br><h3>  Conclusiones </h3><br>  Repetimos el experimento para IPv4 e IPv6 y preparamos este diagrama: <br><br><img src="https://habrastorage.org/webt/dl/sc/qa/dlscqatdfii2rihttytjnfvtfea.png"><br>  En general, se puede argumentar que nuestra configuraci√≥n para IPv6 es un poco m√°s lenta.  Pero dado que los paquetes IPv6 son algo m√°s grandes, se espera la diferencia de velocidad. <br><br>  Linux tiene muchas formas de filtrar paquetes, cada una con su propia velocidad y complejidad. <br><br>  Para protegerse contra DDoS, es bastante razonable entregar paquetes a la aplicaci√≥n y procesarlos all√≠.  Una aplicaci√≥n bien ajustada puede mostrar buenos resultados. <br><br>  Para ataques DDoS con IP aleatoria o falsificada, puede ser √∫til deshabilitar conntrack para obtener un peque√±o aumento de velocidad, pero tenga cuidado: hay ataques contra los cuales conntrack es muy √∫til. <br><br>  En otros casos, tiene sentido agregar el firewall de Linux como una de las formas de mitigar el ataque DDoS.  En algunos casos, es mejor usar la tabla "-t raw PREROUTING", ya que es mucho m√°s r√°pida que la tabla de filtro. <br><br>  Para los casos m√°s avanzados, siempre usamos XDP.  Y s√≠, esto es algo muy poderoso.  Aqu√≠ hay un gr√°fico como el anterior, solo con XDP: <br><br><img src="https://habrastorage.org/webt/o4/un/dm/o4undm-syfgavdxop6izkvpckyk.png"><br>  Si desea repetir el experimento, aqu√≠ est√° <a href="">README, en el que documentamos todo</a> . <br><br>  En CloudFlare usamos ... casi todas estas t√©cnicas.  Algunos trucos en el espacio del usuario est√°n integrados en nuestras aplicaciones.  La t√©cnica de iptables se encuentra en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gatebot</a> .  Finalmente, reemplazamos nuestra propia soluci√≥n central con XDP. <br><br>  Muchas gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jesper Dangaard Brouer</a> por su ayuda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419921/">https://habr.com/ru/post/es419921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419911/index.html">Construyendo √≥rbitas de cuerpos celestes usando Python</a></li>
<li><a href="../es419913/index.html">IKEA y casa inteligente. Parte 2</a></li>
<li><a href="../es419915/index.html">Servidor de enlaces y SSH en initramfs</a></li>
<li><a href="../es419917/index.html">Redes neuronales: implementaci√≥n de la tarea sobre hongos en Tensor Flow y Python</a></li>
<li><a href="../es419919/index.html">Control de versiones dentro de SQL Server</a></li>
<li><a href="../es419923/index.html">Mi trabajo temporal, relojes de placa base</a></li>
<li><a href="../es419925/index.html">Control de versiones de archivos individuales usando GitHub Gist</a></li>
<li><a href="../es419927/index.html">[DotNetBook] Excepciones: Arquitectura de sistema de tipo</a></li>
<li><a href="../es419929/index.html">[DotNetBook] Eventos de excepci√≥n y c√≥mo obtener StackOverflow y ExecutionEngineException desde cero</a></li>
<li><a href="../es419931/index.html">[DotNetBook] Tiempo para historias entretenidas: situaciones excepcionalmente excepcionales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>