<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 ☘️ 👩🏿‍🎨 Shader ist keine Magie. Shader in Unity schreiben. Vertex-Shader 👊🏾 👩🏿‍🏭 🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Grigory Dyadichenko und ich bin der Gründer und CTO von Foxsys Studios. Heute sprechen wir über Vertex-Shader. Der Art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shader ist keine Magie. Shader in Unity schreiben. Vertex-Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474812/"> Hallo allerseits!  Mein Name ist Grigory Dyadichenko und ich bin der Gründer und CTO von Foxsys Studios.  Heute sprechen wir über Vertex-Shader.  Der Artikel wird die Praxis aus der Sicht von Unity untersuchen, sehr einfache Beispiele sowie viele Links zum Studium von Informationen über Shader in Unity.  Wenn Sie gut darin sind, Shader zu schreiben, werden Sie für sich selbst nichts Neues finden.  Jeder, der anfangen möchte, Shader in Unity zu schreiben, ist bei cat willkommen. <br><br><img src="https://habrastorage.org/webt/zr/9n/wy/zr9nwyvbjnky73iqvvuvvzxpyjs.jpeg"><br><a name="habracut"></a><br><h3>  Ein bisschen Theorie </h3><br><br>  Zum besseren Verständnis des Shader-Prozesses werfen wir einen Blick auf eine kleine Theorie.  Ein Vertex-Shader oder Vertex-Shader ist eine programmierbare Stufe eines Shaders, der mit einzelnen Vertexen arbeitet.  Vertexe wiederum speichern verschiedene Attribute, die von diesem Teil des Shaders verarbeitet werden, um konvertierte Attribute am Ausgang zu erhalten. <br><br><h3>  Beispiele, bei denen Vertex-Shader verwendet werden </h3><br><br><img src="https://habrastorage.org/webt/fk/ry/kc/fkrykcsixvzaihfaa4g6jajebk4.jpeg"><br><br>  <b>Verformung von Objekten</b> - realistische Wellen, Auswirkungen von Regenwellen, Verformung beim Auftreffen einer Kugel - all dies kann mit Vertex-Shadern durchgeführt werden und sieht realistischer aus als dasselbe, das durch Bump-Mapping im Fragmentteil des Shaders erzielt wird.  Da dies eine Änderung der Geometrie ist.  Level 3.0-Shader zu diesem Thema verfügen über eine Technik namens Dispacement Mapping, da sie jetzt Zugriff auf Texturen im Scheitelpunktteil des Shaders haben. <br><br><img src="https://habrastorage.org/webt/8e/tb/uu/8etbuufscvxpmvx3acs8irusgag.jpeg"><br><br>  <b>Animation von Objekten.</b>  Spiele sehen lebendiger und interessanter aus, wenn Pflanzen auf einen Charakter oder Bäume reagieren, die sich im Wind wiegen.  Hierzu werden auch Vertex-Shader verwendet. <br><br><img src="https://habrastorage.org/webt/cu/ov/vk/cuovvkcufzn0jn0351xjw9bzfso.jpeg"><br><br>  <b>Cartoon Beleuchtung oder stilisiert.</b>  In vielen Spielen sieht aus Sicht des Stils nicht die pbr-Beleuchtung viel interessanter aus, sondern die Stilisierung.  Gleichzeitig macht es keinen Sinn, irgendetwas im Fragmentteil zu berechnen. <br><br><img src="https://habrastorage.org/webt/m1/8a/km/m18akmnn364xlwyrh_0r5pb_zjc.png"><br><br>  <b>Häuten.</b>  Gegenwärtig ist dieses Problem in Spiel-Engines behoben, aber es ist dennoch nützlich, Vertex-Shader zu verstehen, um zu verstehen, wie es funktioniert. <br><br><h3>  Einfache Beispiele für die Arbeit mit Scheitelpunkten </h3><br><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"><br><br>  Ich möchte nicht, dass es passiert, wie in den alten Lektionen über das Zeichnen einer Eule. Gehen wir also schrittweise vor.  Erstellen Sie einen Standardoberflächen-Shader.  Dies kann mit der rechten Maustaste in der Projektansicht oder im oberen Bereich auf der Registerkarte Assets erfolgen.  Erstellen-&gt; Shader-&gt; Standard Surface Shader. <br><br>  Und wir bekommen so einen Standardrohling. <br><br><div class="spoiler">  <b class="spoiler_title">Surface Shader</b> <div class="spoiler_text"><code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _MainTex ("Albedo (RGB)", 2D) = "white" {} <br> _Glossiness ("Smoothness", Range(0,1)) = 0.5 <br> _Metallic ("Metallic", Range(0,1)) = 0.0 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> // Physically based Standard lighting model, and enable shadows on all light types <br> #pragma surface surf Standard fullforwardshadows <br> <br> // Use shader model 3.0 target, to get nicer looking lighting <br> #pragma target 3.0 <br> <br> sampler2D _MainTex; <br> <br> struct Input <br> { <br> float2 uv_MainTex; <br> }; <br> <br> half _Glossiness; <br> half _Metallic; <br> fixed4 _Color; <br> <br> // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. <br> // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. <br> // #pragma instancing_options assumeuniformscaling <br> UNITY_INSTANCING_BUFFER_START(Props) <br> // put more per-instance properties here <br> UNITY_INSTANCING_BUFFER_END(Props) <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> // Albedo comes from a texture tinted by color <br> fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; <br> o.Albedo = c.rgb; <br> // Metallic and smoothness come from slider variables <br> o.Metallic = _Metallic; <br> o.Smoothness = _Glossiness; <br> o.Alpha = ca; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> }</code> </div> </div><br>  Wie es funktioniert und im Allgemeinen werden wir es im Artikel nach der Grundübung detailliert analysieren und es während der Implementierung von Shadern teilweise verstehen.  Lassen Sie vorerst einige Dinge wie gegeben bleiben.  Kurz gesagt, es gibt keine Magie (in Bezug auf die Art und Weise, wie Parameter erfasst werden usw.). Nur für bestimmte Schlüsselwörter generiert das Gerät Code für Sie, um ihn nicht von Grund auf neu zu schreiben.  Daher ist dieser Prozess nicht offensichtlich genug.  Weitere Informationen zum Surface Shader und seinen Eigenschaften in Unity finden Sie hier.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-SurfaceShaders.html</a> <br><br>  Wir werden alles Überflüssige entfernen, damit es nicht ablenkt, da es im gegebenen Moment nicht benötigt wird.  Und hol dir so einen kurzen Shader. <br><br><div class="spoiler">  <b class="spoiler_title">Vereinfachter Shader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/wg/po/iw/wgpoiwtso4uxmmipwrbvtnz1mek.jpeg"><br><br>  Nur die Farbe auf dem Modell mit Beleuchtung.  In diesem Fall ist Unity für die Berechnung der Beleuchtung verantwortlich. <br><br>  Fügen Sie zunächst den einfachsten Effekt aus den Unity-Beispielen hinzu.  Die Extrusion ist normal und an ihrem Beispiel werden wir analysieren, wie es funktioniert. <br><br>  <i>Fügen Sie</i> dazu den Modifikator <i>vertex: vert</i> zur <i>Zeile #pragma surface surf Standard fullforwardshadows</i> hinzu.  Wenn wir <i>inout appdata_full v</i> als Parameter an eine Funktion übergeben, ist diese Funktion im Wesentlichen ein Vertex-Modifikator.  Im Kern ist es Teil des Vertex-Shaders, der von der Code-Generierungseinheit erstellt wird, die die vorläufige Verarbeitung von Vertices durchführt.  <i>Fügen Sie</i> außerdem im <i>Eigenschaftsblock</i> das Feld <i>_Amount hinzu</i> , das Werte von 0 bis 1 akzeptiert. Um das Feld <i>_Amount</i> im Shader zu verwenden, müssen Sie es auch dort definieren.  In der Funktion werden wir abhängig von <i>_Amount</i> einfach zur Normalen <i>wechseln</i> , wobei 0 die Standardscheitelpunktposition (Null-Verschiebung) und 1 die Verschiebung genau zur Normalen ist. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionShader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amount ("Extrusion Amount", Range(0,1)) = 0.5 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amount; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amount; <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br>  Sie können ein wichtiges Merkmal von Shadern feststellen.  Obwohl der Shader in jedem Frame ausgeführt wird, wird das während des Shader-Vorgangs erhaltene Ergebnis nicht im Netz gespeichert, sondern nur zum Rendern verwendet.  Daher ist es unmöglich, sich auf die Funktionen des Shaders sowie das <i>Update</i> in Skripten zu beziehen.  Sie werden bei jedem Frame angewendet, ohne die Mesh-Daten zu ändern, sondern ändern einfach das Mesh für das weitere Rendern. <br><br>  Eine der einfachsten Möglichkeiten, eine Animation zu erstellen, besteht darin, die Amplitude mithilfe der Zeit zu ändern.  Das Gerät verfügt über integrierte Variablen. Eine vollständige Liste finden Sie hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a> In diesem Fall schreiben wir einen neuen Shader basierend auf unserem vorherigen Shader.  <i>Lassen Sie uns</i> anstelle von <i>_Amount</i> den <i>Gleitkommawert _Amplitude festlegen</i> und die integrierte Unity-Variable <i>_SinTime verwenden</i> .  <i>_SinTime</i> ist der Sinus der Zeit und nimmt daher Werte von -1 bis 1 an. Vergessen Sie jedoch nicht, dass alle in Unit Shader integrierten <i>Zeitvariablen float4-</i> Vektoren sind.  Beispielsweise ist <i>_SinTime</i> definiert als <i>(sin (t / 8), sin (t / 4), sin (t / 2), sin (t))</i> , wobei t die Zeit ist.  Daher nehmen wir die z-Komponente, damit die Animation schneller ist.  Und wir bekommen: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionWithTime</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionWithTime" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amplitude ("Extrusion Amplitude", float) = 1 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amplitude; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amplitude * (1 - _SinTime.z); <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="https://i.giphy.com/media/U5UFh8tOZIAmDyZmzm/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Das waren also einfache Beispiele.  Es ist Zeit, eine Eule zu zeichnen! <br><br><h3>  Verformung von Gegenständen </h3><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="https://media.giphy.com/media/pOwf43ETsackhG30CA/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Ich habe bereits einen ganzen Artikel über einen Deformationseffekt mit einer detaillierten Analyse der Mathematik des Prozesses und der Logik des Denkens bei der Entwicklung eines solchen Effekts geschrieben. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habr.com/de/post/435828</a> Dies wird unsere Eule sein. <br><br>  Alle Shader im Artikel sind in hlsl geschrieben.  Diese Sprache hat eine eigene umfangreiche Dokumentation, die viele vergessen und sich fragen, woher die Hälfte der verkabelten Funktionen stammt, obwohl sie in HLSL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumenten</a> definiert sind. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl- Eigenfunktionen</a> <br><br>  Tatsächlich sind Oberflächen-Shader in einer Einheit ein großes und umfangreiches Thema für sich.  Außerdem möchten Sie sich nicht immer mit Unity-Beleuchtung anlegen.  Manchmal müssen Sie den schnellsten Shader betrügen und schreiben, der nur die richtigen vordefinierten Effekte hat.  In Unity können Sie Shader auf niedrigerer Ebene schreiben. <br><br><h3>  Low-Level-Shader </h3><br><br><img src="https://habrastorage.org/webt/k6/xx/bm/k6xxbmwnws5jw0bjy181o3q9ome.jpeg"><br><br>  Nach der guten alten Tradition der Arbeit mit Shadern werden wir im Folgenden das Stanford-Kaninchen quälen. <br><br>  Im Allgemeinen ist das sogenannte Unity ShaderLab im Wesentlichen eine Visualisierung eines Inspektors mit Feldern in Materialien und einer gewissen Vereinfachung des Schreibens von Shadern. <br><br>  Nehmen Sie die allgemeine Struktur des Shaderlab-Shaders: <br><br><div class="spoiler">  <b class="spoiler_title">Allgemeine Shader-Struktur</b> <div class="spoiler_text"> <code>Shader "MyShaderName" <br> { <br> Properties <br> { <br> //   <br> } <br> SubShader //     (   ) <br> { <br> Pass <br> { <br> //   <br> } <br> //        <br> } <br> //     <br> FallBack "VertexLit" //         ,     <br> } <br></code> <br></div></div><br>  Kompilierungsanweisungen wie <br>  <i>#pragma vertex vert</i> <br>  <i>#pragma fragment frag</i> <br>  Bestimmen Sie, welcher Shader als Vertex- bzw. Fragment-Shader kompiliert werden soll. <br><br>  Nehmen wir an, wir nehmen eines der häufigsten Beispiele - einen Shader zum Anzeigen der Farbe von Normalen: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleNormalVisualization</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleNormalVisualization" <br> { <br> Properties <br> { <br> } <br> SubShader <br> { <br> Pass <br> { <br> CGPROGRAM <br> <br> #pragma vertex vert <br> #pragma fragment frag <br> <br> #include "UnityCG.cginc" <br> <br> struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> }; <br> <br> v2f vert (appdata_base v) <br> { <br> v2f o; <br> o.pos = UnityObjectToClipPos(v.vertex); <br> o.color = v.normal * 0.5 + 0.5; <br> return o; <br> } <br> <br> fixed4 frag (v2f i) : SV_Target <br> { <br> return fixed4 (i.color, 1); <br> } <br> ENDCG <br> } <br> } <br> FallBack "VertexLit" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/5t/oy/wv/5toywvw0cewffefffvw5xfvtj60.jpeg"><br><br>  In diesem Fall schreiben wir im Scheitelpunktteil den konvertierten Normalwert in die Scheitelpunktfarbe und im Pixelteil verwenden wir diese Farbe als Farbe des Modells. <br><br>  Die <i>UnityObjectToClipPos-</i> Funktion ist eine Unity-Zusatzfunktion (aus der <i>UnityCG.cginc-</i> Datei), die die Scheitelpunkte des Objekts in die der Kamera zugeordnete Position übersetzt.  Ohne sie wird ein Objekt, wenn es in die Sichtbarkeit der Kamera eintritt (Frustrum), unabhängig von der Position der Transformation in den Koordinaten des Bildschirms gezeichnet.  Seit Anfang werden die Positionen der Eckpunkte in den Koordinaten des Objekts dargestellt.  Nur Werte relativ zu seinem Drehpunkt. <br><br>  Dieser Block. <br> <code>struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> };</code> <br>  Dies ist die Definition der Struktur, die im Scheitelpunktteil verarbeitet und in das erste Fragment übertragen wird.  In diesem Fall wird bestimmt, dass zwei Parameter aus dem Netz entnommen werden - die Position des Scheitelpunkts und die Farbe des Scheitelpunkts.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> darüber, welche Daten in einem Gerät gespeichert werden können, finden Sie unter diesem Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a> <br><br>  Wichtige Klarstellung.  Die Namen der Netzattribute spielen keine Rolle.  Nehmen wir an, Sie können im Farbattribut den Vektor der Abweichung von der ursprünglichen Position schreiben (auf diese Weise bewirken sie manchmal einen Effekt, wenn der Charakter davon abweicht, sodass das Gras davon abstößt).  Wie dieses Attribut verarbeitet wird, hängt vollständig von Ihrem Shader ab. <br><br><h3>  Fazit </h3><br><br>  Vielen Dank für Ihre Aufmerksamkeit!  Es ist problematisch, einige komplexe Effekte ohne einen fragmentarischen Teil zu schreiben. Aus diesem Grund werden wir ähnliche Themen in separaten Artikeln behandeln.  Ich hoffe, dass in diesem Artikel etwas klarer wurde, wie der Code der Vertex-Shader im Allgemeinen geschrieben ist und wo Sie Informationen zum Lernen finden, da Shader ein sehr tiefes Thema sind. <br><br>  In zukünftigen Artikeln werden wir die anderen Shader-Typen und die einzelnen Effekte analysieren und versuchen, meine Denklogik beim Erstellen neuer oder komplexer Effekte zu beschreiben. <br><br>  Es wurde auch ein Repository erstellt, in dem alle Ergebnisse dieser Artikelserie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/Nox7atra/ShaderExamples</a> hinzugefügt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.Ich</a> hoffe, dass diese Informationen Anfängern nützlich sind, die sich gerade mit diesem Thema befassen. <br><br><h4>  Einige nützliche Links (einschließlich Quellen): </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.khronos.org/opengl/wiki/Vertex_Shader</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-reference</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/en/current/Manual/SL-Reference.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/GraphicsTutorials.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.malbred.com/3d-grafika-3d-redaktory/sovremennaya-terminologiya-3d-grafiki/vertex-shader-vershinnyy-sheyder.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3dpapa.ru/genauer-Versetzungs-Workflow</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474812/">https://habr.com/ru/post/de474812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474800/index.html">Leistung in .NET Core</a></li>
<li><a href="../de474804/index.html">Russischer technologischer Fortschritt im Sport: Neuronale Schnittstellen, IP-Kameras, Sport-CRM und BigData aus einem Rennwagen</a></li>
<li><a href="../de474806/index.html">UDP Flood von Google oder wie nicht alle Youtube zu berauben</a></li>
<li><a href="../de474808/index.html">Rust 1.39.0 Release: async / await, Attribute für Funktionsparameter, neue konstante Funktionen</a></li>
<li><a href="../de474810/index.html">Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3</a></li>
<li><a href="../de474814/index.html">Altertümer: der Botschafter des Verfalls oder der ungeplanten Veralterung</a></li>
<li><a href="../de474816/index.html">Haustierprojekte - kleines Leben</a></li>
<li><a href="../de474818/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474822/index.html">WISE-PaaS - eine Cloud-Plattform für das industrielle Internet der Dinge</a></li>
<li><a href="../de474826/index.html">Normale Tabellen in Markdown</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>