<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèΩ ‚òòÔ∏è üë©üèø‚Äçüé® Shader ist keine Magie. Shader in Unity schreiben. Vertex-Shader üëäüèæ üë©üèø‚Äçüè≠ üè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Grigory Dyadichenko und ich bin der Gr√ºnder und CTO von Foxsys Studios. Heute sprechen wir √ºber Vertex-Shader. Der Art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shader ist keine Magie. Shader in Unity schreiben. Vertex-Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474812/"> Hallo allerseits!  Mein Name ist Grigory Dyadichenko und ich bin der Gr√ºnder und CTO von Foxsys Studios.  Heute sprechen wir √ºber Vertex-Shader.  Der Artikel wird die Praxis aus der Sicht von Unity untersuchen, sehr einfache Beispiele sowie viele Links zum Studium von Informationen √ºber Shader in Unity.  Wenn Sie gut darin sind, Shader zu schreiben, werden Sie f√ºr sich selbst nichts Neues finden.  Jeder, der anfangen m√∂chte, Shader in Unity zu schreiben, ist bei cat willkommen. <br><br><img src="https://habrastorage.org/webt/zr/9n/wy/zr9nwyvbjnky73iqvvuvvzxpyjs.jpeg"><br><a name="habracut"></a><br><h3>  Ein bisschen Theorie </h3><br><br>  Zum besseren Verst√§ndnis des Shader-Prozesses werfen wir einen Blick auf eine kleine Theorie.  Ein Vertex-Shader oder Vertex-Shader ist eine programmierbare Stufe eines Shaders, der mit einzelnen Vertexen arbeitet.  Vertexe wiederum speichern verschiedene Attribute, die von diesem Teil des Shaders verarbeitet werden, um konvertierte Attribute am Ausgang zu erhalten. <br><br><h3>  Beispiele, bei denen Vertex-Shader verwendet werden </h3><br><br><img src="https://habrastorage.org/webt/fk/ry/kc/fkrykcsixvzaihfaa4g6jajebk4.jpeg"><br><br>  <b>Verformung von Objekten</b> - realistische Wellen, Auswirkungen von Regenwellen, Verformung beim Auftreffen einer Kugel - all dies kann mit Vertex-Shadern durchgef√ºhrt werden und sieht realistischer aus als dasselbe, das durch Bump-Mapping im Fragmentteil des Shaders erzielt wird.  Da dies eine √Ñnderung der Geometrie ist.  Level 3.0-Shader zu diesem Thema verf√ºgen √ºber eine Technik namens Dispacement Mapping, da sie jetzt Zugriff auf Texturen im Scheitelpunktteil des Shaders haben. <br><br><img src="https://habrastorage.org/webt/8e/tb/uu/8etbuufscvxpmvx3acs8irusgag.jpeg"><br><br>  <b>Animation von Objekten.</b>  Spiele sehen lebendiger und interessanter aus, wenn Pflanzen auf einen Charakter oder B√§ume reagieren, die sich im Wind wiegen.  Hierzu werden auch Vertex-Shader verwendet. <br><br><img src="https://habrastorage.org/webt/cu/ov/vk/cuovvkcufzn0jn0351xjw9bzfso.jpeg"><br><br>  <b>Cartoon Beleuchtung oder stilisiert.</b>  In vielen Spielen sieht aus Sicht des Stils nicht die pbr-Beleuchtung viel interessanter aus, sondern die Stilisierung.  Gleichzeitig macht es keinen Sinn, irgendetwas im Fragmentteil zu berechnen. <br><br><img src="https://habrastorage.org/webt/m1/8a/km/m18akmnn364xlwyrh_0r5pb_zjc.png"><br><br>  <b>H√§uten.</b>  Gegenw√§rtig ist dieses Problem in Spiel-Engines behoben, aber es ist dennoch n√ºtzlich, Vertex-Shader zu verstehen, um zu verstehen, wie es funktioniert. <br><br><h3>  Einfache Beispiele f√ºr die Arbeit mit Scheitelpunkten </h3><br><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"><br><br>  Ich m√∂chte nicht, dass es passiert, wie in den alten Lektionen √ºber das Zeichnen einer Eule. Gehen wir also schrittweise vor.  Erstellen Sie einen Standardoberfl√§chen-Shader.  Dies kann mit der rechten Maustaste in der Projektansicht oder im oberen Bereich auf der Registerkarte Assets erfolgen.  Erstellen-&gt; Shader-&gt; Standard Surface Shader. <br><br>  Und wir bekommen so einen Standardrohling. <br><br><div class="spoiler">  <b class="spoiler_title">Surface Shader</b> <div class="spoiler_text"><code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _MainTex ("Albedo (RGB)", 2D) = "white" {} <br> _Glossiness ("Smoothness", Range(0,1)) = 0.5 <br> _Metallic ("Metallic", Range(0,1)) = 0.0 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> // Physically based Standard lighting model, and enable shadows on all light types <br> #pragma surface surf Standard fullforwardshadows <br> <br> // Use shader model 3.0 target, to get nicer looking lighting <br> #pragma target 3.0 <br> <br> sampler2D _MainTex; <br> <br> struct Input <br> { <br> float2 uv_MainTex; <br> }; <br> <br> half _Glossiness; <br> half _Metallic; <br> fixed4 _Color; <br> <br> // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. <br> // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. <br> // #pragma instancing_options assumeuniformscaling <br> UNITY_INSTANCING_BUFFER_START(Props) <br> // put more per-instance properties here <br> UNITY_INSTANCING_BUFFER_END(Props) <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> // Albedo comes from a texture tinted by color <br> fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; <br> o.Albedo = c.rgb; <br> // Metallic and smoothness come from slider variables <br> o.Metallic = _Metallic; <br> o.Smoothness = _Glossiness; <br> o.Alpha = ca; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> }</code> </div> </div><br>  Wie es funktioniert und im Allgemeinen werden wir es im Artikel nach der Grund√ºbung detailliert analysieren und es w√§hrend der Implementierung von Shadern teilweise verstehen.  Lassen Sie vorerst einige Dinge wie gegeben bleiben.  Kurz gesagt, es gibt keine Magie (in Bezug auf die Art und Weise, wie Parameter erfasst werden usw.). Nur f√ºr bestimmte Schl√ºsselw√∂rter generiert das Ger√§t Code f√ºr Sie, um ihn nicht von Grund auf neu zu schreiben.  Daher ist dieser Prozess nicht offensichtlich genug.  Weitere Informationen zum Surface Shader und seinen Eigenschaften in Unity finden Sie hier.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-SurfaceShaders.html</a> <br><br>  Wir werden alles √úberfl√ºssige entfernen, damit es nicht ablenkt, da es im gegebenen Moment nicht ben√∂tigt wird.  Und hol dir so einen kurzen Shader. <br><br><div class="spoiler">  <b class="spoiler_title">Vereinfachter Shader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/wg/po/iw/wgpoiwtso4uxmmipwrbvtnz1mek.jpeg"><br><br>  Nur die Farbe auf dem Modell mit Beleuchtung.  In diesem Fall ist Unity f√ºr die Berechnung der Beleuchtung verantwortlich. <br><br>  F√ºgen Sie zun√§chst den einfachsten Effekt aus den Unity-Beispielen hinzu.  Die Extrusion ist normal und an ihrem Beispiel werden wir analysieren, wie es funktioniert. <br><br>  <i>F√ºgen Sie</i> dazu den Modifikator <i>vertex: vert</i> zur <i>Zeile #pragma surface surf Standard fullforwardshadows</i> hinzu.  Wenn wir <i>inout appdata_full v</i> als Parameter an eine Funktion √ºbergeben, ist diese Funktion im Wesentlichen ein Vertex-Modifikator.  Im Kern ist es Teil des Vertex-Shaders, der von der Code-Generierungseinheit erstellt wird, die die vorl√§ufige Verarbeitung von Vertices durchf√ºhrt.  <i>F√ºgen Sie</i> au√üerdem im <i>Eigenschaftsblock</i> das Feld <i>_Amount hinzu</i> , das Werte von 0 bis 1 akzeptiert. Um das Feld <i>_Amount</i> im Shader zu verwenden, m√ºssen Sie es auch dort definieren.  In der Funktion werden wir abh√§ngig von <i>_Amount</i> einfach zur Normalen <i>wechseln</i> , wobei 0 die Standardscheitelpunktposition (Null-Verschiebung) und 1 die Verschiebung genau zur Normalen ist. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionShader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amount ("Extrusion Amount", Range(0,1)) = 0.5 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amount; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amount; <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br>  Sie k√∂nnen ein wichtiges Merkmal von Shadern feststellen.  Obwohl der Shader in jedem Frame ausgef√ºhrt wird, wird das w√§hrend des Shader-Vorgangs erhaltene Ergebnis nicht im Netz gespeichert, sondern nur zum Rendern verwendet.  Daher ist es unm√∂glich, sich auf die Funktionen des Shaders sowie das <i>Update</i> in Skripten zu beziehen.  Sie werden bei jedem Frame angewendet, ohne die Mesh-Daten zu √§ndern, sondern √§ndern einfach das Mesh f√ºr das weitere Rendern. <br><br>  Eine der einfachsten M√∂glichkeiten, eine Animation zu erstellen, besteht darin, die Amplitude mithilfe der Zeit zu √§ndern.  Das Ger√§t verf√ºgt √ºber integrierte Variablen. Eine vollst√§ndige Liste finden Sie hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a> In diesem Fall schreiben wir einen neuen Shader basierend auf unserem vorherigen Shader.  <i>Lassen Sie uns</i> anstelle von <i>_Amount</i> den <i>Gleitkommawert _Amplitude festlegen</i> und die integrierte Unity-Variable <i>_SinTime verwenden</i> .  <i>_SinTime</i> ist der Sinus der Zeit und nimmt daher Werte von -1 bis 1 an. Vergessen Sie jedoch nicht, dass alle in Unit Shader integrierten <i>Zeitvariablen float4-</i> Vektoren sind.  Beispielsweise ist <i>_SinTime</i> definiert als <i>(sin (t / 8), sin (t / 4), sin (t / 2), sin (t))</i> , wobei t die Zeit ist.  Daher nehmen wir die z-Komponente, damit die Animation schneller ist.  Und wir bekommen: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionWithTime</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionWithTime" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amplitude ("Extrusion Amplitude", float) = 1 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amplitude; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amplitude * (1 - _SinTime.z); <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="https://i.giphy.com/media/U5UFh8tOZIAmDyZmzm/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Das waren also einfache Beispiele.  Es ist Zeit, eine Eule zu zeichnen! <br><br><h3>  Verformung von Gegenst√§nden </h3><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="https://media.giphy.com/media/pOwf43ETsackhG30CA/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Ich habe bereits einen ganzen Artikel √ºber einen Deformationseffekt mit einer detaillierten Analyse der Mathematik des Prozesses und der Logik des Denkens bei der Entwicklung eines solchen Effekts geschrieben. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habr.com/de/post/435828</a> Dies wird unsere Eule sein. <br><br>  Alle Shader im Artikel sind in hlsl geschrieben.  Diese Sprache hat eine eigene umfangreiche Dokumentation, die viele vergessen und sich fragen, woher die H√§lfte der verkabelten Funktionen stammt, obwohl sie in HLSL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumenten</a> definiert sind. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl- Eigenfunktionen</a> <br><br>  Tats√§chlich sind Oberfl√§chen-Shader in einer Einheit ein gro√ües und umfangreiches Thema f√ºr sich.  Au√üerdem m√∂chten Sie sich nicht immer mit Unity-Beleuchtung anlegen.  Manchmal m√ºssen Sie den schnellsten Shader betr√ºgen und schreiben, der nur die richtigen vordefinierten Effekte hat.  In Unity k√∂nnen Sie Shader auf niedrigerer Ebene schreiben. <br><br><h3>  Low-Level-Shader </h3><br><br><img src="https://habrastorage.org/webt/k6/xx/bm/k6xxbmwnws5jw0bjy181o3q9ome.jpeg"><br><br>  Nach der guten alten Tradition der Arbeit mit Shadern werden wir im Folgenden das Stanford-Kaninchen qu√§len. <br><br>  Im Allgemeinen ist das sogenannte Unity ShaderLab im Wesentlichen eine Visualisierung eines Inspektors mit Feldern in Materialien und einer gewissen Vereinfachung des Schreibens von Shadern. <br><br>  Nehmen Sie die allgemeine Struktur des Shaderlab-Shaders: <br><br><div class="spoiler">  <b class="spoiler_title">Allgemeine Shader-Struktur</b> <div class="spoiler_text"> <code>Shader "MyShaderName" <br> { <br> Properties <br> { <br> //   <br> } <br> SubShader //     (   ) <br> { <br> Pass <br> { <br> //   <br> } <br> //        <br> } <br> //     <br> FallBack "VertexLit" //         ,     <br> } <br></code> <br></div></div><br>  Kompilierungsanweisungen wie <br>  <i>#pragma vertex vert</i> <br>  <i>#pragma fragment frag</i> <br>  Bestimmen Sie, welcher Shader als Vertex- bzw. Fragment-Shader kompiliert werden soll. <br><br>  Nehmen wir an, wir nehmen eines der h√§ufigsten Beispiele - einen Shader zum Anzeigen der Farbe von Normalen: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleNormalVisualization</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleNormalVisualization" <br> { <br> Properties <br> { <br> } <br> SubShader <br> { <br> Pass <br> { <br> CGPROGRAM <br> <br> #pragma vertex vert <br> #pragma fragment frag <br> <br> #include "UnityCG.cginc" <br> <br> struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> }; <br> <br> v2f vert (appdata_base v) <br> { <br> v2f o; <br> o.pos = UnityObjectToClipPos(v.vertex); <br> o.color = v.normal * 0.5 + 0.5; <br> return o; <br> } <br> <br> fixed4 frag (v2f i) : SV_Target <br> { <br> return fixed4 (i.color, 1); <br> } <br> ENDCG <br> } <br> } <br> FallBack "VertexLit" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/5t/oy/wv/5toywvw0cewffefffvw5xfvtj60.jpeg"><br><br>  In diesem Fall schreiben wir im Scheitelpunktteil den konvertierten Normalwert in die Scheitelpunktfarbe und im Pixelteil verwenden wir diese Farbe als Farbe des Modells. <br><br>  Die <i>UnityObjectToClipPos-</i> Funktion ist eine Unity-Zusatzfunktion (aus der <i>UnityCG.cginc-</i> Datei), die die Scheitelpunkte des Objekts in die der Kamera zugeordnete Position √ºbersetzt.  Ohne sie wird ein Objekt, wenn es in die Sichtbarkeit der Kamera eintritt (Frustrum), unabh√§ngig von der Position der Transformation in den Koordinaten des Bildschirms gezeichnet.  Seit Anfang werden die Positionen der Eckpunkte in den Koordinaten des Objekts dargestellt.  Nur Werte relativ zu seinem Drehpunkt. <br><br>  Dieser Block. <br> <code>struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> };</code> <br>  Dies ist die Definition der Struktur, die im Scheitelpunktteil verarbeitet und in das erste Fragment √ºbertragen wird.  In diesem Fall wird bestimmt, dass zwei Parameter aus dem Netz entnommen werden - die Position des Scheitelpunkts und die Farbe des Scheitelpunkts.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> dar√ºber, welche Daten in einem Ger√§t gespeichert werden k√∂nnen, finden Sie unter diesem Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a> <br><br>  Wichtige Klarstellung.  Die Namen der Netzattribute spielen keine Rolle.  Nehmen wir an, Sie k√∂nnen im Farbattribut den Vektor der Abweichung von der urspr√ºnglichen Position schreiben (auf diese Weise bewirken sie manchmal einen Effekt, wenn der Charakter davon abweicht, sodass das Gras davon abst√∂√üt).  Wie dieses Attribut verarbeitet wird, h√§ngt vollst√§ndig von Ihrem Shader ab. <br><br><h3>  Fazit </h3><br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit!  Es ist problematisch, einige komplexe Effekte ohne einen fragmentarischen Teil zu schreiben. Aus diesem Grund werden wir √§hnliche Themen in separaten Artikeln behandeln.  Ich hoffe, dass in diesem Artikel etwas klarer wurde, wie der Code der Vertex-Shader im Allgemeinen geschrieben ist und wo Sie Informationen zum Lernen finden, da Shader ein sehr tiefes Thema sind. <br><br>  In zuk√ºnftigen Artikeln werden wir die anderen Shader-Typen und die einzelnen Effekte analysieren und versuchen, meine Denklogik beim Erstellen neuer oder komplexer Effekte zu beschreiben. <br><br>  Es wurde auch ein Repository erstellt, in dem alle Ergebnisse dieser Artikelserie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/Nox7atra/ShaderExamples</a> hinzugef√ºgt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.Ich</a> hoffe, dass diese Informationen Anf√§ngern n√ºtzlich sind, die sich gerade mit diesem Thema befassen. <br><br><h4>  Einige n√ºtzliche Links (einschlie√ülich Quellen): </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.khronos.org/opengl/wiki/Vertex_Shader</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-reference</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/en/current/Manual/SL-Reference.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/GraphicsTutorials.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.malbred.com/3d-grafika-3d-redaktory/sovremennaya-terminologiya-3d-grafiki/vertex-shader-vershinnyy-sheyder.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3dpapa.ru/genauer-Versetzungs-Workflow</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474812/">https://habr.com/ru/post/de474812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474800/index.html">Leistung in .NET Core</a></li>
<li><a href="../de474804/index.html">Russischer technologischer Fortschritt im Sport: Neuronale Schnittstellen, IP-Kameras, Sport-CRM und BigData aus einem Rennwagen</a></li>
<li><a href="../de474806/index.html">UDP Flood von Google oder wie nicht alle Youtube zu berauben</a></li>
<li><a href="../de474808/index.html">Rust 1.39.0 Release: async / await, Attribute f√ºr Funktionsparameter, neue konstante Funktionen</a></li>
<li><a href="../de474810/index.html">Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3</a></li>
<li><a href="../de474814/index.html">Altert√ºmer: der Botschafter des Verfalls oder der ungeplanten Veralterung</a></li>
<li><a href="../de474816/index.html">Haustierprojekte - kleines Leben</a></li>
<li><a href="../de474818/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474822/index.html">WISE-PaaS - eine Cloud-Plattform f√ºr das industrielle Internet der Dinge</a></li>
<li><a href="../de474826/index.html">Normale Tabellen in Markdown</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>