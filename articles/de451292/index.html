<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 👏🏽 🕧 RxDart: magische Transformationen von Flüssen 👁️ 👆🏾 🕴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Willkommen - Dies ist der dritte Teil meiner Artikelserie Flutter Architecture. 


- Einführung 
- Dart Streams Grundlagen 
- RxDart: Magic Stream Tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxDart: magische Transformationen von Flüssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451292/"><p>  Willkommen - Dies ist der dritte Teil meiner Artikelserie Flutter Architecture. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dart Streams Grundlagen</a> </li><li>  <strong>RxDart: Magic Stream Transformationen (dieser Beitrag)</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxVMS-Grundlagen: RxCommand und GetIt</a> </li><li>  RxVMS: Services und Manager </li><li>  RxVMS: in sich geschlossene Widgets </li><li>  Benutzerauthentifizierung mit RxVMS </li></ul><br><p> Dieses Mal werden wir einen kleinen Sprung in das magische Reich der reaktiven Erweiterungen (Rx) machen.  Ich werde mich auf die am häufigsten verwendeten Rx-Funktionen konzentrieren und deren Anwendung erläutern.  Wenn Sie den vorherigen Beitrag nicht gelesen haben, ist jetzt die Zeit dafür, bevor Sie fortfahren. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxDart</a> ist eine Implementierung des Rx-Konzepts für die Dart-Sprache, dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frank Pepermans</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brian Egan dafür</a> .  Wenn Sie Rx zuvor in anderen Sprachen verwendet haben, werden Sie wahrscheinlich einen Unterschied in der Benennung einer Reihe von Funktionen bemerken, aber dies wird Ihnen wahrscheinlich keine Schwierigkeiten bereiten. </p><br><p>  Der Code zum Testen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Bisher haben wir Streams verwendet, um Daten in unserer Anwendung von einem Ort zum anderen zu übertragen, aber sie können noch viel mehr.  Werfen wir einen Blick auf einige der Funktionen, die Rx Streams hinzufügt. </p><a name="habracut"></a><br><h2 id="sozdanie-observables">  Observables erstellen </h2><br><p>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erwähnt</a> , handelt es sich bei Observables um Rx-Versionen von Streams mit hervorragenden Funktionen.  Es gibt verschiedene interessante Möglichkeiten, sie zu erstellen: </p><br><h3 id="iz-potoka">  Aus dem Strom </h3><br><p>  Jeder Stream kann in Observable konvertiert werden, indem er an den Konstruktor übergeben wird: </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); var streamObservable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(controller.stream); streamObservable.listen(print);</code> </pre> <br><h3 id="povtoryayuschiesya-sobytiya">  Wiederkehrende Ereignisse </h3><br><pre> <code class="cpp hljs">var timerObservable = Observable.periodic(Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), (x) =&gt; x.toString() ); timerObservable.listen(print);</code> </pre> <br><p>  Auf diese Weise wird ein Observable erstellt, das Werte mit einem bestimmten Zeitraum anzeigt.  So können Sie den Timer ersetzen. </p><br><h3 id="iz-odinochnogo-znacheniya">  Aus einem einzigen Wert </h3><br><p>  Manchmal erwartet eine API einen Stream / Observable, in dem Sie nur einen Wert haben.  In solchen Fällen verfügt das Observable über eine Fabrik. </p><br><pre> <code class="cpp hljs">var justObservable = Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.just(<span class="hljs-number"><span class="hljs-number">42</span></span>); justObservable.listen(print); <span class="hljs-comment"><span class="hljs-comment">//   : 42</span></span></code> </pre> <br><h3 id="iz-future">  Aus der Zukunft </h3><br><pre> <code class="cpp hljs"> Future&lt;String&gt; asyncFunction() async { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Future.delayed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), () =&gt; <span class="hljs-string"><span class="hljs-string">"AsyncRsult"</span></span>); } test(<span class="hljs-string"><span class="hljs-string">'Create Observable from Future'</span></span>, () async { print(<span class="hljs-string"><span class="hljs-string">'start'</span></span>); var fromFutureObservable = Observable.fromFuture(asyncFunction()); fromFutureObservable.listen(print);</code> </pre> <br><p>  Das Erstellen eines <code>Observable</code> from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> wartet darauf, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> abgeschlossen ist, und gibt einen Wert für das Ergebnis oder <code>null</code> wenn der Wert nicht zurückgegeben wird.  Eine andere Möglichkeit, einen Stream aus Future zu erstellen, besteht darin, <code>toStream()</code> für jede Zukunft <code>toStream()</code> . </p><br><p>  Sie fragen sich vielleicht, wozu Future in ein Observable / Stream konvertiert werden soll, anstatt nur darauf zu warten.  Seien Sie versichert, dies wird deutlich, wenn wir die verfügbaren Funktionen zum Bearbeiten von Daten untersuchen, während sie sich im Stream befinden. </p><br><h3 id="subjects">  Themen </h3><br><p>  <code>Subjects</code> sind ein Ersatz für <code>StreamController</code> in RxDart, und so werden sie irgendwo im Darm der Bibliothek implementiert. </p><br><p>  Ihr Verhalten unterscheidet sich jedoch geringfügig von den grundlegenden StreamControllern: </p><br><ul><li>  Sie können <code>listen()</code> direkt auf einen Betreff anwenden, ohne auf die Stream-Eigenschaft zuzugreifen </li><li>  Es stehen beliebig viele Abonnements zur Verfügung, und alle Listener erhalten gleichzeitig dieselben Daten </li><li>  Es gibt drei Arten von Themen, die im Folgenden anhand von Beispielen erläutert werden: </li></ul><br><h4 id="publishsubjects">  PublishSubjects </h4><br><p>  <code>PublishSubjects</code> verhalten sich wie <code>StreamControllers</code> , mit Ausnahme der Möglichkeit vieler Listener: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    subject.listen((item) =&gt; print(item.toUpperCase())); subject.add("Item2"); subject.add("Item3"); //        await Future.delayed(Duration(seconds: 5)); //    subject.close;</span></span></code> </pre> <br><p>  Führen Sie diesen Code aus und Sie erhalten: </p><br><pre> <code class="cpp hljs">Item1 ITEM2 Item2 ITEM3 Item3</code> </pre> <br><p>  Es ist klar, dass der zweite Zuhörer, der zu spät zur Party kam (wir werden sie als späte Abonnenten bezeichnen), den ersten Punkt verpasst hat.  Um dies zu vermeiden, können Sie <code>BehaviourSubject</code> </p><br><h4 id="behavioursubject">  Verhaltensgegenstand </h4><br><p>  Mit <code>BehaviourSubject</code> erhält jeder neue Abonnent zuerst den zuletzt akzeptierten Wert: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.listen((item) =&gt; print(item.toUpperCase())); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Am Ausgang </p><br><pre> <code class="cpp hljs">Item1 ITEM2 ITEM3 Item2 Item3</code> </pre> <br><p>  Sie können sehen, dass <code>Item1</code> für den zweiten Abonnenten verloren geht, aber <code>Item2</code> empfängt.  Sie werden überrascht sein, dass der zweite Teilnehmer <code>Item3</code> erhält, bevor der erste Teilnehmer <code>Item2</code> erhält.  Dies liegt daran, dass die Reihenfolge der Serviceteilnehmer nicht garantiert ist, obwohl alle Teilnehmer Daten in der richtigen Reihenfolge empfangen.  <code>BehaviourSubject</code> nur das zuletzt für verspätete Abonnenten empfangene Element zwischen.  Wenn Sie mehr Elemente zwischenspeichern müssen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplaySubject verwenden</a> .  In den meisten Fällen ist dies nicht erforderlich. </p><br><h2 id="manipulirovanie-dannymi-na-letu">  Daten im laufenden Betrieb bearbeiten </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"></p><br><p>  Die wahre Stärke von Rx liegt in der Tatsache, dass Sie Daten während der Übertragung über den Stream verarbeiten können.  Jede der Rx-Methoden gibt einen neuen Stream mit den resultierenden Daten zurück (wie in der Abbildung). Dies bedeutet, dass Sie sie in einer Verarbeitungspipeline zusammenbinden können. Dies macht Rx zu einem äußerst leistungsstarken Tool. </p><br><h3 id="map">  Karte </h3><br><p>  Wenn es einen Stream-Vorgang gibt, den ich am meisten nicht missen möchte, dann ist dies <code>map()</code> .  <code>map()</code> verwendet jedes zu übertragende Datenelement und wendet eine bestimmte Funktion darauf an. Anschließend wird das Ergebnis in den resultierenden Stream eingefügt.  Ein einfaches Beispiel: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"></p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()).listen(print); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="cpp hljs">ITEM1 ITEM2 ITEM3</code> </pre> <br><p>  Die <code>map</code> nicht denselben Datentyp zurückgeben, den sie als Eingabe empfängt.  Im folgenden Beispiel werden Ganzzahlen anstelle von Zeichenfolgen verwendet.  Zusätzlich werden wir zwei Transformationen verknüpfen: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((intValue) =&gt; intValue.toString()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()) .listen(print); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  oder so ähnlich: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataClass</span></span></span><span class="hljs-class">{</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrapperClass</span></span></span><span class="hljs-class"> {</span></span> final DataClass wrapped; WrapperClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapped); } var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;WrapperClass&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WrapperClass&gt;((a) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WrapperClass(a));</code> </pre> <br><p>  Eine der nützlichsten Anwendungen von <code>.map</code> ist, wenn Sie Daten in einem Format von einer REST-API oder aus einer Datenbank <code>.map</code> und möchten, dass sie in Ihre eigenen Objekte konvertiert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> final String name; final String adress; final String phoneNumber; final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-comment"><span class="hljs-comment">//       - //   factory User.fromJson(String jsonString) { var jsonMap = json.decode(jsonString); return User( jsonMap['name'], jsonMap['adress'], jsonMap['phoneNumber'], jsonMap['age'], ); } User(this.name, this.adress, this.phoneNumber, this.age); @override String toString() { return '$name - $adress - $phoneNumber - $age'; } } void main() { test('Map', () { // -  var jsonStrings = [ '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }', '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }', '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }', ]; //   json-,    API/DB. var dataStreamFromAPI = new PublishSubject&lt;String&gt;(); dataStreamFromAPI .map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)) // json -&gt; User .listen((user) =&gt; print(user.toString())); //    dataStreamFromAPI.add(jsonStrings[0]); dataStreamFromAPI.add(jsonStrings[1]); dataStreamFromAPI.add(jsonStrings[2]); });</span></span></code> </pre> <br><p>  <em>Ich stelle fest, dass nicht nur Streams, sondern auch jedes Iterable eine Kartenfunktion bietet, die Sie für Transformationen in Listen verwenden können.</em> </p><br><h3 id="where">  Wo </h3><br><p>  Wenn Sie nur an bestimmten Werten interessiert sind, die im Stream vorkommen, können Sie die Funktion <code>.where()</code> anstelle der <code>if</code> in Ihrem Listener verwenden. Dies ist aussagekräftiger und leichter zu lesen: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.where((val) =&gt; val.isOdd) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints odd numbers: $val'</span></span>)); subject.where((val) =&gt; val.isEven) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints even numbers: $val'</span></span>)); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//: This only prints odd numbers: 1 This only prints even numbers: 2 This only prints odd numbers: 3</span></span></code> </pre> <br><h3 id="debounce">  Entprellen </h3><br><p>  Dies ist eine der kleinen Perlen von Rx!  Stellen Sie sich vor, Sie haben ein Suchfeld, das die REST-API aufruft, wenn ihr Text geändert wird.  Ein API-Aufruf für jeden Tastendruck ist teuer.  Daher möchten Sie nur dann einen Anruf tätigen, wenn der Benutzer einen Moment innehält.  Hierzu wird die Funktion <code>debounce()</code> verwendet, die alle eingehenden Ereignisse verschluckt, wenn ihnen keine Pause folgt. </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.debounce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">500</span></span>)).listen((s) =&gt; print(s)); subject.add(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">'AB'</span></span>); await Future.delayed(Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">200</span></span>)); subject.add(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    await Future.delayed(Duration(milliseconds: 700)); //       : 'ABC'</span></span></code> </pre> <br><p>  Wenn Sie den <code>TextField.onChanged</code> Handler in <code>Observable</code> konvertieren, erhalten Sie daher eine elegante Lösung. </p><br><h3 id="expand">  Erweitern </h3><br><p>  Wenn Ihr Quell-Stream Arrays von Objekten <code>.expand</code> und Sie jedes Objekt selbst verarbeiten möchten, können Sie <code>.expand</code> , um genau das zu tun: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif" alt="Bild"></p><br><p>  Die Anwendung dieser Methode sehen Sie unten im FireStore-Beispiel. </p><br><h3 id="merge">  Zusammenführen </h3><br><p>  Wenn Sie mehrere verschiedene Threads haben, aber deren Objekte zusammen verarbeiten möchten, können Sie <code>.mergeWith</code> (in anderen Rx-Implementierungen nur <code>merge</code> ) verwenden, das ein Array von Threads verwendet und einen zusammengeführten Thread zurückgibt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif" alt="Bild"></p><br><p>  <code>.mergeWith</code> garantiert nicht, dass eine Bestellung in den Streams zusammengeführt wird.  Die Daten werden in der Eingabereihenfolge ausgegeben. </p><br><p>  Wenn Sie beispielsweise zwei Komponenten haben, die Fehler über den Stream melden, und möchten, dass sie zusammen in einem Dialogfeld angezeigt werden, können Sie dies wie folgt tun (Pseudocode): </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ super.initState(); component1.errors.mergeWith([component2.errors]) .listen( (error) async =&gt; await showDialog(error.message)); }</code> </pre> <br><p>  oder wenn Sie eine kombinierte Anzeige von Nachrichten aus mehreren sozialen Netzwerken wünschen, kann dies folgendermaßen aussehen (Pseudocode): </p><br><pre> <code class="cpp hljs">final observableTwitter = getTwitterStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromTwitter(data)); final observableFacebook = getFacebookStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromFaceBook(data)); final postStream = observableTwitter.mergeWith([observableFacebook]);</code> </pre> <br><h3 id="zipwith">  Reißverschluss </h3><br><p>  <code>zipWith</code> auch einen Stream mit einem anderen zusammen.  Im Gegensatz zu <code>.mergeWith</code> es jedoch keine Daten, sobald es ein Element aus einem seiner Quelldatenströme empfängt.  Er wartet, bis die Elemente aus beiden Quelldatenströmen eintreffen, und kombiniert sie dann mithilfe der bereitgestellten <code>zipper</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif" alt="Bild"></p><br><p>  Die <code>zipWith</code> Signatur sieht beängstigend aus, aber jetzt sehen wir sie uns an: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// R :   Stream/Observable // S :   Stream/Observable // zipper: - Observable&lt;R&gt; zipWith&lt;S, R&gt;(Stream&lt;S&gt; other, R zipper(T t, S s))</span></span></code> </pre> <br><p>  Ein sehr vereinfachtes Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// .just()  Observable,    .zipWith(new Observable.just(2), (one, two) =&gt; one + two) .listen(print); //  3</span></span></code> </pre> <br><p>  Eine praktischere Anwendung ist, wenn Sie auf zwei asynchrone Funktionen warten müssen, die <code>Future</code> , und die Daten verarbeiten möchten, sobald beide Ergebnisse zurückgegeben werden.  In diesem leicht erfundenen Beispiel stellen wir zwei REST-APIs vor: eine gibt <code>User</code> , die andere gibt <code>Product</code> als JSON-Zeichenfolgen zurück und wir möchten auf beide Aufrufe warten, bevor wir das <code>Invoice</code> Objekt zurückgeben. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class"> {</span></span> final User user; final Product product; Invoice(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product); printInvoice() { print(user.toString()); print(product.toString()); } } <span class="hljs-comment"><span class="hljs-comment">//  HTTP ,  Product,  JSON Future&lt;String&gt; getProduct() async { print("Started getting product"); await Future.delayed(Duration(seconds: 2)); print("Finished getting product"); return '{"name": "Flux compensator", "price": 99999.99}'; } //  HTTP ,  User,  JSON Future&lt;String&gt; getUser() async { print("Started getting User"); await Future.delayed(Duration(seconds: 4)); print("Finished getting User"); return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }'; } void main() { test('zipWith', () async { var userObservable = Observable.fromFuture(getUser()).map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)); var productObservable = Observable.fromFuture(getProduct()) .map&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)); Observable&lt;Invoice&gt; invoiceObservable = userObservable.zipWith&lt;Product, Invoice&gt;( productObservable, (user, product) =&gt; Invoice(user, product)); print("Start listening for invoices"); invoiceObservable.listen((invoice) =&gt; invoice.printInvoice()); //        await Future.delayed(Duration(seconds: 5)); }); }</span></span></code> </pre> <br><p>  Wenn Sie sich die Ausgabe ansehen, können Sie sehen, wie dies asynchron erfolgt </p><br><pre> <code class="cpp hljs">Started getting User Started getting product Start listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> invoices Finished getting product Finished getting User Jon Doe - New York - <span class="hljs-number"><span class="hljs-number">424242</span></span> - <span class="hljs-number"><span class="hljs-number">42</span></span> Flux compensator - <span class="hljs-number"><span class="hljs-number">99999.99</span></span></code> </pre> <br><h3 id="combinelatest">  Kombiniertest </h3><br><p>  <code>combineLatest</code> auch Stream-Werte zusammen, jedoch auf etwas andere Weise als <code>merge</code> und <code>zip</code> .  Es wartet auf weitere Threads und gibt einen kombinierten Wert aus, wenn ein neuer Wert von einem der Threads eingeht.  Es ist interessant, dass nicht nur der geänderte Wert, sondern auch die zuletzt erhaltenen Werte aller anderen Quelldatenströme generiert werden.  Schauen Sie sich diese Animation genau an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif" alt="Bild"></p><br><p>  Bevor <code>combineLates</code> seinen ersten Wert <code>combineLates</code> , müssen alle Quell-Threads mindestens einen Eintrag erhalten. </p><br><p>  Im Gegensatz zu den zuvor verwendeten Methoden ist <code>combineLatest</code> statisch.  Da Dart kein Überladen von Operatoren zulässt, gibt es außerdem Versionen von <code>combLastest</code> von der Anzahl der Quelldatenströme <strong>abhängen</strong> : <strong>combinLatest2 ... kombinierenLatest9</strong> </p><br><p>  <code>combineLatest</code> gute Verwendung, wenn Sie beispielsweise zwei <code>Observable&lt;bool&gt;</code> , die signalisieren, dass einige Teile Ihrer Anwendung ausgelastet sind, und Sie den Busy-Spinner anzeigen möchten, wenn einer von ihnen beschäftigt ist.  Es könnte so aussehen (Pseudocode): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; get isBusy =&gt; Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =&gt; b1 || b2); PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyOne; PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyTwo; }</code> </pre> <br><p>  In Ihrer Benutzeroberfläche können Sie <code>isBusy</code> mit <code>StreamBuilder</code> , um <code>Spinner</code> anzuzeigen, wenn der resultierende Wert wahr ist. </p><br><p>  <code>combineLatest</code> sehr geeignete Funktion in Kombination mit <strong>FireStore-Snapshots-</strong> Streams. </p><br><p>  Stellen Sie sich vor, Sie möchten eine Anwendung erstellen, die einen Newsfeed zusammen mit einer Wettervorhersage anzeigt.  Tickernachrichten und Wetterdaten werden in zwei verschiedenen FireStore-Sammlungen gespeichert.  Beide werden unabhängig voneinander aktualisiert.  Sie möchten Datenaktualisierungen mit StreamBuilder anzeigen.  Mit <code>combineLatest</code> es ganz einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> {</span></span> final String forecastText; final GeoPoint location; factory WeatherForecast.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'forecastText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } WeatherForecast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecastText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsMessage</span></span></span><span class="hljs-class"> {</span></span> final String newsText; final GeoPoint location; factory NewsMessage.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'newsText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } NewsMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CombinedMessage</span></span></span><span class="hljs-class"> {</span></span> final WeatherForecast forecast; final NewsMessage newsMessage; CombinedMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecast, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsMessage); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> CollectionReference weatherCollection; CollectionReference newsCollection; Model() { weatherCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'weather'</span></span>); newsCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'news'</span></span>); } Observable&lt;CombinedMessage&gt; getCombinedMessages() { Observable&lt;WeatherForecast&gt; weatherForecasts = weatherCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WeatherForecast&gt;((document) =&gt; WeatherForecast.fromMap(document.data)); Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.combineLatest2( weatherForecasts, news, (weather, news) =&gt; CombinedMessage(weather, news)); } }</code> </pre> <br><p>  In Ihrer Benutzeroberfläche würde es <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> so aussehen: <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> </p><br><h3 id="distinct">  Deutlich </h3><br><p>  In dem oben beschriebenen Szenario kann es vorkommen, dass <strong>isBusyOne</strong> und <strong>isBusyTwo</strong> denselben Wert <strong>angeben</strong> , was zu einer Aktualisierung der Benutzeroberfläche mit denselben Daten führt.  Um dies zu verhindern, können wir <code>.distinct()</code> .  Es stellt sicher, dass Daten nur gestreamt werden, wenn sich der Wert des neuen Elements vom letzten unterscheidet.  Daher würden wir den Code ändern in: </p><br><pre> <code class="cpp hljs"> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusy =&gt; isBusyOne.mergeWith([isBusyTwo]).distinct();</code> </pre> <br><p>  und es zeigt auch, dass wir unsere Funktionen nach Belieben in verschiedenen Ketten kombinieren können. </p><br><h3 id="asyncmap">  Asyncmap </h3><br><p>  Neben <code>map()</code> gibt es auch eine <code>asyncMap</code> Funktion, mit der Sie eine asynchrone Funktion als Map-Funktion verwenden können.  Lassen Sie uns eine etwas andere Einstellung für unser FireStore-Beispiel einführen.  Jetzt hängt der erforderliche <strong>WeatherForecast</strong> vom Standort von <strong>NewsMessage ab</strong> und sollte nur aktualisiert werden, wenn eine neue <strong>NewsMessage empfangen wird</strong> : </p><br><pre> <code class="cpp hljs">Observable&lt;CombinedMessage&gt; getDependendMessages() { Observable&lt;NewsMessage&gt; news = newsCollection.snapshots().expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> news.asyncMap((newsEntry) async { var weatherDocuments = await weatherCollection.where(<span class="hljs-string"><span class="hljs-string">'location'</span></span>, isEqualTo: newsEntry.location).getDocuments(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombinedMessage( WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry); }); }</code> </pre> <br><p>  Das von getDependendMessages zurückgegebene Observable generiert bei jeder Änderung von newsCollection eine neue CombinedMessage. </p><br><h2 id="otladka-observables">  Debuggen von Observables </h2><br><p>  Wenn man sich die eleganten Rx-Aufrufketten ansieht, scheint es fast unmöglich, einen Ausdruck wie diesen zu debuggen: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data));</code> </pre> <br><p>  Beachten Sie jedoch, dass <code>=&gt;</code> nur eine Kurzform für eine anonyme Funktion ist.  Wenn Sie <strong>Konvertieren verwenden, um den Körper zu blockieren</strong> , erhalten Sie: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); });</code> </pre> <br><p>  Und jetzt können wir in jedem Schritt unserer Pipeline einen Haltepunkt setzen oder Druckanweisungen hinzufügen. </p><br><h2 id="osteregaytes-pobochnyh-effektov">  Vorsicht vor Nebenwirkungen </h2><br><p>  <strong>Wenn Sie Rx nutzen möchten, um Ihren Code robuster zu machen, denken Sie immer daran, dass Rx eine Datenkonvertierung ist, wenn Sie es "entlang des Förderbandes" bewegen.</strong>  <strong>Rufen Sie daher niemals Funktionen auf, die Variablen / Zustände außerhalb der Verarbeitungspipeline ändern, bis Sie die Funktion .listen erreichen.</strong> <br>  Anstatt dies zu tun: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) { var product = Product.fromJson(jsonString); database.save(product); setState((){ _product = product }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> product; }).listen();</code> </pre> <br><p>  mach das: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)) .listen( (product) { database.save(product); setState((){ _product = product }); });</code> </pre> <br><p>  Die Aufgabe von <code>map()</code> ist es, die Daten im Stream zu transformieren und NICHTS MEHR!  Wenn die übergebene Anzeigefunktion etwas anderes bewirkt, wird dies als Nebeneffekt betrachtet, der potenzielle Fehler erzeugt, die beim Lesen des Codes schwer zu erkennen sind. </p><br><h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov">  Einige Gedanken zur Ressourcenfreigabe </h2><br><p>  Um Speicherverluste zu vermeiden, rufen Sie bei Abonnements immer <code>cancel()</code> auf, dispose <code>dispose()</code> für StreamController, <code>close()</code> für Subjects, sobald Sie diese nicht mehr benötigen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Herzlichen Glückwunsch, wenn Sie bis zu diesem Moment bei mir geblieben sind.  Jetzt können Sie Rx nicht nur verwenden, um Ihr Leben zu erleichtern, sondern sich auch auf die nächsten Beiträge vorbereiten, in denen wir uns mit den Details von <strong>RxVMS befassen</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451292/">https://habr.com/ru/post/de451292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451276/index.html">Wie baue ich eine Marke auf?</a></li>
<li><a href="../de451278/index.html">Wavelet-Analyse Teil 1</a></li>
<li><a href="../de451280/index.html">Die interessantesten Metalle</a></li>
<li><a href="../de451282/index.html">Schwarze Löcher in der Webanalyse: Wie viele Daten gehen in GA verloren und warum?</a></li>
<li><a href="../de451286/index.html">Roskomnadzor, den wir verdienen</a></li>
<li><a href="../de451294/index.html">Da ich dem Auto Funktionen über CAN hinzugefügt habe, konnte ich nicht programmieren</a></li>
<li><a href="../de451296/index.html">Angekündigt von ML.NET 1.0</a></li>
<li><a href="../de451298/index.html">So stellen Sie eine Spielekonsole mit einem Gehäuse her, indem Sie eine Leiterplatte bestellen</a></li>
<li><a href="../de451302/index.html">Top-IT-Outsourcing-Unternehmen</a></li>
<li><a href="../de451304/index.html">Yandex-Tipp: So maximieren Sie den Gewinn eines bezahlten Abonnements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>