<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ üëÖ ‚òÆÔ∏è 5 raz√µes pelas quais voc√™ deve parar de usar o System.Drawing no ASP.NET ‚¨ÜÔ∏è üÜë üë®üèø‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo "5 raz√µes pelas quais voc√™ deve parar de usar o System.Drawing from ASP.NET" . 



 Bem, eles fizeram ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 raz√µes pelas quais voc√™ deve parar de usar o System.Drawing no ASP.NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">"5 raz√µes pelas quais voc√™ deve parar de usar o System.Drawing from ASP.NET"</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="imagem"><br><br>  Bem, eles fizeram isso.  A equipe corefx finalmente concordou com <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">v√°rias solicita√ß√µes</a> e incluiu System.Drawing no .NET Core. <a name="habracut"></a>  (artigo original de julho de 2017) <br><br>  O <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">pr√≥ximo</a> pacote <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">System.Drawing.Common</a> conter√° a maior parte da funcionalidade System.Drawing do .NET Framework completo e deve ser usado como uma op√ß√£o de compatibilidade para quem deseja migrar para o .NET Core, mas n√£o pode fazer isso devido a depend√™ncias.  Nesta perspectiva, a Microsoft est√° fazendo a coisa certa.  O atrito precisa ser reduzido, pois a ado√ß√£o do .Net Core √© uma meta que vale a pena. <br><br>  Por outro lado, o System.Drawing √© uma das √°reas mais pobres e mais carenciadas do .Net Framework e muitos de n√≥s esper√°vamos que a implementa√ß√£o do .NET Core significasse a morte lenta do System.Drawing.  E junto com essa morte deve haver uma oportunidade de fazer algo melhor. <br><br>  Por exemplo, a equipe Mono criou um inv√≥lucro compat√≠vel com .NET para a biblioteca de gr√°ficos <a href="https://skia.org/" rel="nofollow">Skia de</a> plataforma cruzada do Google, chamada <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp</a> .  Para simplificar a instala√ß√£o, o Nuget j√° percorreu um longo caminho no suporte de bibliotecas nativas para cada plataforma.  Skia √© bastante completo e seu desempenho faz System.Drawing. <br><br>  A equipe do <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp</a> tamb√©m fez um √≥timo trabalho repetindo grande parte da funcionalidade System.Drawing, mas com a melhor API e implementa√ß√£o 100% C #.  Eles ainda n√£o est√£o prontos para a explora√ß√£o produtiva, mas parece que j√° est√£o perto o suficiente disso.  Um pequeno aviso sobre esta biblioteca, j√° que estamos falando sobre o uso em aplicativos de servidor: agora, na configura√ß√£o padr√£o, o Parallel.For √© usado para acelerar algumas opera√ß√µes, o que significa que mais fluxos de trabalho do pool do ASP.NET ser√£o usados, eventualmente. <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">Como</a> resultado, <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">reduzindo a taxa de transfer√™ncia geral do aplicativo</a> .  Espero que esse comportamento seja revisto antes do lan√ßamento, mas mesmo agora √© suficiente alterar uma linha da configura√ß√£o para torn√°-la mais adequada para uso no servidor. <br><br>  De qualquer forma, se voc√™ estiver desenhando, plotando ou renderizando texto em imagens em um aplicativo no servidor, considere seriamente alterar o System.Drawing para qualquer coisa, independentemente de voc√™ alternar para o .NET Core ou n√£o. <br><br>  Da minha parte, montei um pipeline de processamento de imagem de alto desempenho para .NET e .NET Core, que fornece qualidade de imagem que o System.Drawing n√£o pode fornecer e o faz em uma arquitetura altamente escal√°vel projetada especificamente para uso no servidor.  At√© agora, √© apenas para Windows, no entanto, a plataforma cruzada est√° nos planos.  Se voc√™ usar System.Drawing (ou qualquer outra coisa) para redimensionar imagens no servidor, √© melhor considerar o <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> como um substituto. <br><br>  Mas uma ressurrei√ß√£o do System.Drawing, que facilita a transi√ß√£o para alguns desenvolvedores, provavelmente matar√° a maior parte do momento que esses projetos receberam, pois os desenvolvedores foram for√ßados a procurar alternativas.  Infelizmente, no ecossistema .NET, as bibliotecas e pacotes da Microsoft sempre vencer√£o, n√£o importa qu√£o superiores sejam as alternativas. <br><br>  Esta postagem √© uma tentativa de corrigir alguns erros de c√°lculo do System.Drawing na esperan√ßa de que os desenvolvedores explorem alternativas, mesmo que o System.Drawing continue sendo uma op√ß√£o. <br><br>  Come√ßarei com o <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">aviso de isen√ß√£o de responsabilidade</a> frequentemente mencionado <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">na</a> documenta√ß√£o System.Drawing.  Essa rejei√ß√£o foi levantada algumas vezes em uma <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">discuss√£o no Github ao discutir o System.Drawing.Common</a> . <br><blockquote>  ‚ÄúClasses com o espa√ßo para nome System.Drawing n√£o s√£o suportadas para uso nos servi√ßos Windows ou ASP.NET.  Tentar usar essas classes com esses tipos de aplicativos pode causar problemas inesperados, como diminui√ß√£o do desempenho do servidor e erros de tempo de execu√ß√£o. " </blockquote><br>  Como muitos de voc√™s, li esse aviso h√° muito tempo e pulei e ainda usei o System.Drawing no meu aplicativo ASP.NET.  Porque  Porque eu amo o perigo.  Ou isso, ou nenhuma outra op√ß√£o vi√°vel foi encontrada.  E voc√™ sabe o que?  Nada de ruim aconteceu.  Provavelmente eu n√£o deveria ter dito isso, mas aposto que muitos de voc√™s experimentaram a mesma coisa.  Ent√£o, por que n√£o continuar usando o System.Drawing ou bibliotecas baseadas nele? <br><br><h3>  Raz√£o # 1: Descritores GDI </h3><br>  Se voc√™ j√° teve problemas ao usar o System.Drawing em um servidor, provavelmente √© esse o caso.  Se n√£o testado, essa √© uma das causas poss√≠veis mais prov√°veis. <br><br>  O System.Drawing geralmente √© um inv√≥lucro fino em torno da API do Windows GDI +.  Muitos objetos System.Drawing s√£o suportados por <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">descritores de GDI</a> e possuem um limite quantitativo na sess√£o do processador e do usu√°rio.  Se esse limite for atingido, voc√™ receber√° uma exce√ß√£o "Mem√≥ria insuficiente" e / ou erro 'gen√©rico' do GDI +. <br><br>  O problema √© que, no .NET, a coleta de lixo e o encerramento do processo podem atrasar o lan√ßamento desses descritores quando voc√™ atingir o limite, mesmo com pouca carga.  Se voc√™ esquecer (ou n√£o sabia do que precisa) chamar Dispose () em um objeto que cont√©m esses descritores, voc√™ corre o risco de encontrar esses erros em seu ambiente.  E, como a maioria dos bugs relacionados a limita√ß√µes ou vazamentos de recursos, provavelmente essa situa√ß√£o ser√° testada com sucesso e o afetar√° na opera√ß√£o produtiva.  Naturalmente, isso acontecer√° quando seu aplicativo estiver sob a maior carga, para que o n√∫mero m√°ximo de usu√°rios descubra sua vergonha. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">As restri√ß√µes no processador e na sess√£o do usu√°rio</a> dependem da vers√£o do sistema operacional, e a restri√ß√£o no processador √© personaliz√°vel.  Mas a vers√£o n√£o importa, porque  Os descritores de GDI s√£o representados internamente pelo tipo de dados USHORT, portanto, h√° um limite estrito de 65.536 descritores por sess√£o do usu√°rio e at√© mesmo um aplicativo bem escrito corre o risco de atingir esse limite com carga suficiente.  Quando voc√™ acredita que um servidor mais poderoso permitir√° atender mais e mais usu√°rios em paralelo em uma inst√¢ncia, esse risco se torna mais real.  E realmente, quem quer criar software com um conhecido limite r√≠gido de escalabilidade? <br><br><h3>  Raz√£o # 2: Concorr√™ncia </h3><br>  O GDI + sempre teve problemas com a simultaneidade, embora muitos deles estivessem relacionados a <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">altera√ß√µes arquiteturais no Windows7 / Windows Server 2008 R2</a> , voc√™ ainda v√™ alguns deles em novas vers√µes.  O mais not√°vel √© o <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">bloqueio</a> do <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">processo</a> organizado pelo GDI + durante a opera√ß√£o DrawImage ().  Se voc√™ redimensionar imagens no servidor usando System.Drawing (ou as bibliotecas que o envolvem), o m√©todo DrawImage () provavelmente ser√° a base desse c√≥digo. <br><br>  Al√©m disso, ao fazer v√°rias chamadas para DrawImage () ao mesmo tempo, <b>todas</b> elas ser√£o bloqueadas at√© que <b>todas</b> sejam executadas.  Mesmo que o tempo de resposta n√£o seja um problema para voc√™ (por que n√£o? Voc√™ odeia os usu√°rios?) Lembre-se de que quaisquer recursos de mem√≥ria associados a essas solicita√ß√µes e todos os descritores de GDI mantidos pelos objetos associados a essas solicita√ß√µes est√£o ligados ao tempo de execu√ß√£o.  De fato, n√£o √© preciso muita carga no servidor para come√ßar a causar problemas. <br><br>  Obviamente, existem solu√ß√µes alternativas para esse problema espec√≠fico.  Por exemplo, alguns desenvolvedores criam um processo externo para cada opera√ß√£o DrawImage ().  Mas, de fato, essa solu√ß√£o alternativa adiciona mais fragilidade, o que voc√™ realmente n√£o deveria ter feito. <br><br><h3>  Raz√£o # 3: Mem√≥ria </h3><br>  Considere um manipulador do ASP.NET que gera um gr√°fico.  Ele deveria fazer algo assim: <br><br><ol><li>  Criar um bitmap como uma tela </li><li>  Desenhar v√°rias formas em um bitmap usando canetas e / ou pinc√©is </li><li>  Desenhar texto usando uma ou mais fontes </li><li>  Salvar bitmap como PNG no MemoryStream </li></ol><br>  Digamos que o gr√°fico mede 600 por 400 pontos.  √â um total de 240.000 pontos, multiplicado por 4 bytes para um ponto no formato RGBA padr√£o, totalizando 960.000 bytes para um bitmap, mais um pouco para objetos de desenho e um buffer de salvamento.  Deixe 1mb para toda a solicita√ß√£o.  Provavelmente, voc√™ n√£o ter√° problemas de mem√≥ria para esse cen√°rio e, se encontrar alguma coisa, provavelmente ter√° um limite no n√∫mero de descritores, que mencionei anteriormente, j√° que imagens, pinc√©is, canetas e fontes t√™m seus pr√≥prios descritores. <br><br>  O verdadeiro problema ocorre quando o System.Drawing √© usado para tarefas de cria√ß√£o de imagens.  O System.Drawing √© principalmente uma biblioteca de gr√°ficos, e as bibliotecas de gr√°ficos geralmente s√£o criadas com base na id√©ia de que tudo √© um bitmap na mem√≥ria.  Isso √© √≥timo enquanto voc√™ pensa sobre as pequenas coisas.  Mas as imagens podem ser muito grandes e aumentam a cada dia, porque  c√¢meras com muitos megapixels est√£o constantemente ficando mais baratas. <br><br>  Se voc√™ usar a abordagem ing√™nua do System.Drawing para criar imagens, obter√° algo assim para o manipulador de redimensionamento: <br><br><ol><li>  Crie um bitmap como uma tela para a imagem de destino. </li><li>  Carregue a imagem original em outro bitmap. </li><li>  Chame DrawImage () com o par√¢metro "image-source" para a imagem de destino, usando o redimensionamento. </li><li>  Salve o bitmap de destino no formato JPEG no fluxo de mem√≥ria. </li></ol><br>  Suponha que a imagem de destino tenha 600x400, como no exemplo anterior, novamente temos 1 MB para a <i>imagem de destino</i> e o fluxo de mem√≥ria.  Mas vamos supor que algu√©m tenha carregado uma imagem de 24 megapixels de suas novas DSLRs sofisticadas, ent√£o precisamos de 6000x4000 pixels com 3 bytes para cada (72 MB) para o bitmap de origem decodificado no formato RGB.  E usaremos a reamostragem HighQualityBicubic do System.Drawing, porque ela apenas parece boa.  Em seguida, precisamos levar em considera√ß√£o os outros pontos 6000x4000 com 4 bytes cada, para a <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">convers√£o PRGBA que ocorre dentro do m√©todo chamado</a> , adicionando 96mb adicionais de mem√≥ria usada.  No total, 169mb (!) S√£o obtidos para uma solicita√ß√£o para converter uma √∫nica imagem. <br><br>  Agora imagine que voc√™ tem mais de um usu√°rio fazendo essas coisas.  Agora lembre-se de que as solicita√ß√µes s√£o bloqueadas at√© que todas sejam completamente executadas.  Quanto tempo leva para ficar sem mem√≥ria?  E mesmo que voc√™ n√£o se preocupe com o esgotamento completo de tudo o que estiver dispon√≠vel, lembre-se de que existem v√°rias maneiras de usar melhor a mem√≥ria do seu servidor do que armazenar v√°rios pixels.  Considere o efeito da press√£o da mem√≥ria em outras partes do aplicativo / sistema: <br><br><ol><li>  O cache do ASP.NET pode come√ßar a liberar itens caros para recriar </li><li>  O coletor de lixo ser√° iniciado com mais frequ√™ncia, diminuindo a velocidade do aplicativo </li><li>  O cache do kernel do IIS ou o cache do sistema de arquivos do Windows podem remover elementos √∫teis </li><li>  O pool de aplicativos pode exceder o limite de mem√≥ria e pode ser reiniciado </li><li>  O Windows pode come√ßar a trocar mem√≥ria para disco, diminuindo a velocidade do sistema inteiro </li></ol><br>  Voc√™ realmente n√£o quer nada disso? <br><br>  As bibliotecas projetadas especificamente para tarefas de processamento de imagem abordam esse problema de uma maneira completamente diferente.  Eles n√£o precisam carregar a fonte inteira ou a imagem de destino na mem√≥ria.  Se voc√™ n√£o quiser desenhar, n√£o precisa de um canvas / bitmap.  Isso √© feito mais ou menos assim: <br><br><ol><li>  Criar fluxo para o codificador JPEG da imagem de destino </li><li>  Carregue uma linha da imagem original e comprima-a horizontalmente </li><li>  Repita quantas vezes forem necess√°rias para formar uma linha para o arquivo de destino </li><li>  Comprima as linhas resultantes verticalmente </li><li>  Repita da etapa 2 at√© que todas as linhas do arquivo de origem sejam processadas. </li></ol><br>  Usando esse m√©todo, a mesma imagem pode ser processada usando 1 MB de mem√≥ria no total, e imagens muito maiores exigir√£o um ligeiro aumento na sobrecarga. <br><br>  Conhe√ßo apenas uma biblioteca .NET otimizada por esse princ√≠pio e darei uma dica: esse n√£o √© o System.Drawing. <br><br><h3>  Raz√£o # 4: CPU </h3><br>  Outro efeito colateral do System.Drawing, sendo mais orientado graficamente do que orientado a imagens, √© que DrawImage () √© bastante ineficiente em termos de uso da CPU.  Eu cobri isso em detalhes em um <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">post anterior</a> , mas essa discuss√£o pode ser resumida pelos seguintes fatos: <br><br><ul><li>  No System.Drawing, a convers√£o de escala HighQualityBicubic funciona apenas com o formato PRGBA.  Em quase todos os cen√°rios, isso significa uma c√≥pia extra da imagem.  Al√©m de usar (significativamente) mais mem√≥ria adicional, ele tamb√©m queima os ciclos do processador para converter e processar o canal alfa extra. </li><li>  Mesmo depois que a imagem est√° em seu formato nativo, a convers√£o na escala HighQualityBicubic realiza cerca de quatro vezes mais c√°lculos do que o necess√°rio para obter os resultados de convers√£o corretos. </li></ul><br>  Esses fatos adicionam uma quantidade significativa de ciclos de CPU desperdi√ßados.  Em um ambiente nublado com pagamento por minuto, isso contribui diretamente para o custo de hospedagem.  E, claro, seu tempo de resposta sofrer√°. <br><br>  E pense no fato de que eletricidade adicional ser√° gasta e calor gerado.  Seu uso do System.Drawing para tarefas de processamento de imagem afeta diretamente o aquecimento global.  Voc√™ √© um monstro. <br><br><h3>  Raz√£o # 5: o processamento da imagem √© enganosamente complexo </h3><br>  Al√©m do desempenho, o System.Drawing evita o processamento correto da imagem.  Usar o System.Drawing significa viver com sa√≠da incorreta ou aprender tudo sobre o perfil ICC, quantiza√ß√£o de cores, orienta√ß√£o exif, corre√ß√£o e muitas outras coisas espec√≠ficas.  Esta √© uma toca de coelho, que a maioria dos desenvolvedores n√£o tem tempo nem vontade de explorar. <br><br>  Bibliotecas como ImageResizer e ImageProcessor conquistaram muitos f√£s, cuidando de alguns desses detalhes, mas tenha cuidado, pois possuem System.Drawing por dentro e eles v√™m com toda a bagagem que descrevi em detalhes neste artigo. <br><br><h3>  Motivo do b√¥nus: voc√™ pode fazer melhor </h3><br>  Se voc√™, como eu, teve que usar √≥culos em algum momento da sua vida, provavelmente se lembra de como foi a primeira vez que os colocou.  Eu pensei que estava vendo normalmente, e se eu apertar os olhos corretamente, tudo ficar√° bem claro.  Mas ent√£o coloquei esses √≥culos e o mundo ficou muito mais detalhado do que eu poderia imaginar. <br><br>  System.Drawing √© o mesmo.  Ele faz a coisa certa se voc√™ <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">preencher as configura√ß√µes corretamente</a> , mas voc√™ ficar√° surpreso com a apar√™ncia das imagens, se usar os melhores utilit√°rios. <br><br>  Vou deixar isso aqui como um exemplo.  Este √© o melhor que o System.Drawing pode fazer em compara√ß√£o com as configura√ß√µes padr√£o do MagicScaler.  Talvez seu aplicativo se beneficie da obten√ß√£o de pontos ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="imagem"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="imagem"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Foto de Jakob Owens</a> <br><br>  D√™ uma olhada, explore alternativas e, em nome do amor pelos gatinhos, pare de usar o System.Drawing no ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482274/">https://habr.com/ru/post/pt482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482262/index.html">Como fazer login no Talend Open Studio</a></li>
<li><a href="../pt482264/index.html">Brasil, magia negra, Mortal Kombat, Marte e 15.000 pessoas. Resultados do ano Ontiko</a></li>
<li><a href="../pt482268/index.html">Megaestruturas do futuro: a esfera de Dyson, o motor estelar e a "bomba do buraco negro"</a></li>
<li><a href="../pt482270/index.html">Transmiss√£o WebRTC dentro e ao redor da realidade virtual</a></li>
<li><a href="../pt482272/index.html">Escolhendo um data warehouse para Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../pt482276/index.html">GOST R 57580. Das tend√™ncias √† automa√ß√£o eficiente</a></li>
<li><a href="../pt482280/index.html">Como √© feito o cosplay. Fato avan√ßado de Isaac Clarke para Dead Space 2</a></li>
<li><a href="../pt482282/index.html">O fim da era do ARMv7 ou um pouco sobre como portar jogos</a></li>
<li><a href="../pt482284/index.html">"50 tons de marrom" ou "como chegamos a isso"</a></li>
<li><a href="../pt482286/index.html">Revis√£o coletiva inesperada dos cartuchos Audio-Technica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>