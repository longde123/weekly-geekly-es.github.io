<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📷 🐻 🏿 CPU 24-core, tapi saya tidak bisa mengetikkan email (bagian 2) 👨🏿‍🎤 🍣 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, saya berjanji untuk mengungkapkan secara lebih rinci beberapa detail yang saya abaikan selama investigasi [Gmail hang di Chr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CPU 24-core, tapi saya tidak bisa mengetikkan email (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421153/"> Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya berjanji untuk mengungkapkan secara lebih rinci beberapa detail yang saya abaikan selama investigasi [Gmail hang di Chrome di Windows - kira-kira.  Per.], Termasuk tabel halaman, kunci, WMI, dan kesalahan vmmap.  Sekarang saya mengisi celah ini bersama dengan contoh kode yang diperbarui.  Tapi pertama-tama, jelaskan esensi secara singkat. <br><br>  Intinya adalah bahwa proses yang mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Control Flow Guard</a> (CFG) mengalokasikan memori yang dapat dieksekusi, sementara juga mengalokasikan memori CFG yang tidak pernah dibebaskan oleh Windows.  Oleh karena itu, jika Anda terus mengalokasikan dan membebaskan memori yang dapat dieksekusi <i>di alamat yang berbeda</i> , proses mengakumulasikan jumlah memori CFG yang sewenang-wenang.  Browser Chrome melakukan ini, yang mengarah pada kebocoran memori yang hampir tidak terbatas dan membeku di beberapa mesin. <br><br>  Perlu dicatat bahwa pembekuan sulit untuk dihindari jika VirtualAlloc mulai berjalan lebih dari satu juta kali lebih lambat dari biasanya. <br><a name="habracut"></a><br>  Selain CFG, ada memori lain yang terbuang, meskipun tidak sebanyak klaim vmmap. <br><br><h1>  CFG dan halaman </h1><br>  Memori program dan memori CFG pada akhirnya dialokasikan dengan halaman 4 kilobyte (lebih lanjut tentang ini nanti).  Karena 4 KB memori CFG dapat menggambarkan 256 KB memori program (lebih lanjut tentang itu nanti), ini berarti bahwa jika Anda memilih blok memori 256 KB selaras dengan 256 KB, Anda akan mendapatkan satu halaman CFG 4 KB.  Dan jika Anda mengalokasikan blok 4 KB yang dapat dieksekusi, Anda masih akan mendapatkan halaman 4 KB CFG, tetapi sebagian besar tidak akan digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/0c2/e19/f100c2e19331ea5b1e313961be362c80.png" align="right">  Semuanya lebih rumit jika memori yang dapat dieksekusi dibebaskan.  Jika Anda menggunakan fungsi VirtualFree pada blok memori yang dapat dieksekusi yang bukan kelipatan 256 KB atau tidak sejajar pada 256 KB, maka OS harus melakukan beberapa analisis dan memverifikasi bahwa beberapa memori yang dapat dieksekusi lainnya tidak menggunakan halaman CFG.  Para penulis CFG memutuskan untuk tidak repot - dan selamanya meninggalkan memori CFG yang dialokasikan.  Sangat disayangkan.  Ini berarti bahwa ketika program pengujian saya mengalokasikan dan kemudian membebaskan 1 gigabyte memori yang dapat dieksekusi selaras, ia menyisakan 16 MB memori CFG. <br><br>  Dalam praktiknya, ternyata ketika mesin JavaScript Chrome mengalokasikan dan kemudian melepaskan 128 MB memori yang dapat dieksekusi yang selaras (tidak semua itu digunakan, tetapi seluruh rentang dialokasikan dan segera dibebaskan), maka memori CFG hingga 2 MB akan tetap dialokasikan, meskipun sepele untuk membebaskannya seluruhnya .  Karena Chrome berulang kali mengalokasikan dan membebaskan memori pada alamat acak, ini mengarah pada masalah yang dijelaskan di atas. <br><br><h1>  Memori hilang tambahan </h1><br>  Dalam OS modern apa pun, setiap proses mendapatkan ruang alamat memori virtualnya sendiri, sehingga OS mengisolasi proses dan melindungi memori.  Ini dilakukan dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unit manajemen memori</a> (MMU) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel halaman</a> .  Memori dibagi menjadi 4 halaman KB.  Ini adalah jumlah memori minimum yang diberikan OS kepada Anda.  Setiap halaman ditandai dengan catatan delapan byte dalam tabel halaman, dan catatan itu sendiri disimpan dalam halaman 4 KB.  Masing-masing dari mereka menunjuk maksimum 512 halaman memori yang berbeda, jadi kita membutuhkan hierarki tabel halaman.  Untuk ruang alamat 48-bit dalam sistem operasi 64-bit, sistemnya adalah sebagai berikut: <br><br><ul><li>  Tabel Level 1 mencakup 256 TB (48 bit), menunjuk ke 512 tabel level 2 halaman berbeda </li><li>  Setiap tabel level 2 mencakup 512 GB, menunjuk ke tabel level 512 </li><li>  Setiap tabel level 3 mencakup 1 GB, menunjuk ke tabel level 512 4 </li><li>  Setiap tabel level 4 mencakup 2 MB, menunjuk ke 512 halaman fisik </li></ul><br>  MMU mengindeks tabel level 1 di 9 (dari 48) bit alamat pertama, tabel level 2 di 9 bit berikutnya, dan level yang tersisa diberikan 9 bit, yaitu, hanya 36 bit.  12 bit yang tersisa digunakan untuk mengindeks halaman 4 kilobyte dari tabel tingkat 4.  Baik, baik. <br><br>  Jika Anda segera mengisi semua level tabel, maka Anda membutuhkan lebih dari 512 GB RAM, sehingga mereka diisi seperlunya.  Ini berarti bahwa ketika mengalokasikan halaman memori, OS memilih beberapa tabel halaman - dari nol hingga tiga, tergantung pada apakah alamat yang dialokasikan berada di area 2 MB yang sebelumnya tidak digunakan, area yang sebelumnya tidak digunakan sebesar 1 GB atau area yang sebelumnya tidak digunakan sebesar 512 GB (tabel level 1 halaman) selalu menonjol). <br><br>  Singkatnya, pengalokasian ke alamat acak jauh lebih mahal daripada pengalokasian ke alamat terdekat, karena dalam kasus halaman pertama tabel tidak dapat dibagikan.  Kebocoran CFG jarang terjadi, jadi ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vmmap</a> menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">412.480</a> KB tabel halaman yang digunakan di Chrome, saya berasumsi angkanya benar.  Berikut ini adalah screenshot vmmap dengan tata letak memori chrome.exe dari artikel sebelumnya, tetapi dengan baris Tabel Tabel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08b/7b7/b4d/08b7b7b4dda4d0b54b3017b5eb80c7ab.png"><br><br>  Tapi sepertinya ada yang salah.  Saya memutuskan untuk menambahkan simulator tabel halaman ke alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VirtualScan</a> saya.  Ini menghitung berapa banyak halaman dari tabel halaman yang dibutuhkan untuk semua memori yang dialokasikan selama proses pemindaian.  Anda hanya perlu memindai memori yang dialokasikan, menambahkan ke counter satu setiap kelipatan dari 2 MB, 1 GB atau 512 GB. <br><br>  Dengan cepat ditemukan bahwa hasil simulator sesuai dengan vmmap pada proses normal, tetapi tidak pada proses dengan sejumlah besar memori CFG.  Perbedaannya kira-kira sesuai dengan memori CFG yang dialokasikan.  Untuk proses di atas, di mana vmmap berbicara tentang 402.8 MB (412.480 KB) dari tabel halaman, alat saya menunjukkan 67,7 MB. <br><br><pre>  Memindai waktu, Berkomitmen, tabel halaman, blok berkomitmen
 Total: 41,763s, 1457,7 MiB, 67,7 MiB, 32112, 98 blok kode
 CFG: 41,759s, 353,3 MiB, 59,2 MiB, 24866 </pre><br><br>  Saya memverifikasi kesalahan vmmap dengan menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VAllocStress</a> , yang dalam pengaturan default menyebabkan Windows mengalokasikan 2 gigabytes memori CFG.  vmmap mengklaim telah mengalokasikan 2 gigabita tabel halaman: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/e6e/33f/89ce6e33f668a6de32abc6a0231bd3e1.png"><br><br>  Dan ketika saya menyelesaikan proses melalui Task Manager, vmmap menunjukkan bahwa jumlah memori yang dialokasikan berkurang hanya 2 gigabytes.  Jadi, vmmap salah, perhitungan saya dengan tabel halaman sudah benar, dan setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> bermanfaat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Twitter,</a> saya mengirim laporan tentang kesalahan vmmap, yang harus diperbaiki.  Memori CFG masih mengkonsumsi banyak entri tabel halaman (59,2 MB dalam contoh di atas), tetapi tidak sebanyak yang dikatakan vmmap, dan setelah memperbaikinya praktis tidak akan menghabiskan apa pun. <br><br><h1>  Apa itu CFG dan CFG? </h1><br>  Saya ingin mundur sedikit dan memberi tahu lebih detail apa itu CFG. <br><br>  CFG adalah singkatan dari Control Flow Guard.  Ini adalah metode perlindungan terhadap eksploitasi dengan menulis ulang pointer fungsi.  Dengan CFG diaktifkan, kompiler dan OS bersama-sama memeriksa validitas target cabang.  Pertama, byte kontrol CFG yang sesuai dimuat dari area CFG 2 TB yang dipesan.  Proses 64-bit di Windows mengelola ruang alamat 128 TB, jadi membagi alamat dengan 64 memungkinkan Anda menemukan byte CFG yang sesuai untuk objek ini. <br><br> <code>uint8_t cfg_byte = cfg_base[size_t(target_addr) / 64];</code> <br> <br>  Kami sekarang memiliki satu byte yang harus menjelaskan alamat mana dalam rentang 64-byte yang merupakan target cabang yang valid.  Untuk melakukan ini, CFG memperlakukan byte sebagai empat nilai dua bit, yang masing-masing sesuai dengan rentang 16 byte.  Angka dua bit ini (yang nilainya dari nol hingga tiga) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditafsirkan sebagai berikut</a> : <br><br><ul><li>  0 - semua target dalam blok 16-byte ini adalah target tidak sah dari cabang tidak langsung </li><li>  1 - alamat awal dalam blok 16-byte ini adalah target yang valid dari cabang tidak langsung </li><li>  2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkait dengan panggilan CFG "ditekan"</a> ;  alamat berpotensi tidak valid </li><li>  3 - alamat yang tidak selaras dalam blok 16-byte ini adalah target yang valid dari cabang tidak langsung, namun alamat rata 16-byte berpotensi tidak valid </li></ul><br>  Jika target cabang tidak langsung tidak valid, proses berakhir dan eksploitasi dicegah.  Hore! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/1af/827/a081af827b3df7b40e8b8530b7cbd1a4.png"><br><br>  Dari sini kita dapat menyimpulkan bahwa untuk keamanan maksimum, tujuan tidak langsung dari cabang harus disejajarkan dengan 16 byte, dan kita dapat memahami mengapa memori CFG untuk proses tersebut adalah sekitar 1/64 dari memori program. <br><br><blockquote>  Sebenarnya CFG memuat 32 bit pada satu waktu, tetapi ini adalah detail implementasi.  Banyak sumber menggambarkan memori CFG sebagai 8-bit single-bit daripada 16-bit double-bit.  Penjelasan saya lebih baik. </blockquote><br><h1>  Itu sebabnya semuanya buruk </h1><br>  Gmail hang karena dua alasan.  Pertama, pemindaian memori CFG pada Windows 10 16299 atau sebelumnya <i>sangat</i> lambat.  Saya melihat bagaimana pemindaian ruang alamat dari suatu proses membutuhkan waktu 40 detik atau lebih, dan secara harfiah 99,99% dari waktu ini memori CFG yang dipindai dipindai, meskipun hanya sekitar 75% dari blok memori tetap.  Saya tidak tahu mengapa pemindaian sangat lambat, tetapi mereka memperbaikinya di Windows 10 17134, jadi tidak masuk akal untuk mempelajari masalah lebih detail. <br><br>  Pemindaian lambat menyebabkan pelambatan karena Gmail menginginkan redundansi CFG, dan WMI memegang kunci selama pemindaian.  Tetapi kunci reservasi memori tidak ditahan selama pemindaian.  Dalam contoh saya, ada sekitar 49.000 blok di area CFG, dan fungsi <i>NtQueryVirtualMemory</i> , yang menerima dan melepaskan kunci, dipanggil sekali untuk masing-masing.  Oleh karena itu, kunci diperoleh dan dilepaskan ~ 49.000 kali dan setiap kali ditahan kurang dari 1 milidetik. <br><br>  Tetapi meskipun kunci dirilis 49.000 kali, proses Chrome untuk beberapa alasan tidak bisa mendapatkannya.  Ini tidak adil! <br><br>  Itulah esensi masalahnya.  Seperti yang saya tulis terakhir kali: <br><br><blockquote>  Ini karena kunci Windows secara inheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak adil</a> - dan jika utas melepaskan kunci dan kemudian segera memintanya lagi, kunci itu bisa mendapatkannya selamanya. </blockquote><br>  Penguncian yang adil berarti bahwa dua utas yang bersaing akan menerimanya secara bergantian.  Tetapi ini berarti banyak saklar konteks yang mahal, jadi untuk waktu yang lama kunci tidak akan digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/713/348/9de/7133489de2c1eca7dc2b2c91b08e1871.png"><br><br>  Kunci tidak adil lebih murah, dan itu tidak membuat utas menunggu dalam antrean.  Mereka hanya menangkap kunci, seperti yang disebutkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Joe Duffy</a> .  Ia juga menulis: <br><br><blockquote>  Pengenalan kunci yang tidak adil tidak diragukan lagi dapat menyebabkan kelaparan.  Namun secara statistik, waktu dalam sistem paralel cenderung sangat bervariasi sehingga setiap utas pada akhirnya akan menerima giliran untuk dieksekusi, dari sudut pandang probabilistik. </blockquote><br>  Bagaimana cara menghubungkan pernyataan Joe dari 2006 tentang kelangkaan kelaparan dengan pengalaman saya tentang masalah yang berulang dan 100% tahan lama?  Saya pikir alasan utama adalah apa yang terjadi pada tahun 2006.  Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merilis Core Duo</a> , dan komputer multi-core ada di mana-mana. <br><br>  Bagaimanapun, ternyata masalah kelaparan ini hanya terjadi pada sistem multi-inti!  Dalam sistem seperti itu, utas WMI akan melepaskan kunci, memberi tanda utas Chrome untuk bangun, dan melanjutkan.  Karena streaming WMI sudah berjalan, ia memiliki "cacat" di depan aliran Chrome, sehingga dapat dengan mudah memanggil <i>NtQueryVemualMemory</i> lagi dan mendapatkan kunci lagi sebelum Chrome memiliki kesempatan untuk melakukan ini. <br><br>  Jelas, dalam sistem inti tunggal, hanya satu utas yang dapat bekerja pada satu waktu.  Sebagai aturan, Windows meningkatkan prioritas utas baru, dan meningkatkan prioritas berarti bahwa ketika kunci dilepaskan, utas Chrome baru akan siap dan segera <i>unggul dari</i> utas WMI.  Ini memberi thread Chrome banyak waktu untuk bangun dan mendapatkan kunci, dan rasa lapar tidak pernah datang. <br><br>  Apakah kamu mengerti  Dalam sistem multi-core, peningkatan prioritas dalam banyak kasus tidak mempengaruhi aliran WMI, karena akan berjalan pada kernel yang berbeda! <br><br>  Ini berarti bahwa sistem dengan core tambahan dapat <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merespons lebih lambat</a></i> daripada sistem dengan beban kerja yang sama dan lebih sedikit core.  Kesimpulan lainnya adalah rasa ingin tahu: jika komputer saya memiliki beban yang berat - utas dari prioritas yang sesuai, bekerja pada semua core prosesor - maka hang dapat dihindari (jangan coba ulangi ini di rumah). <br><br>  Dengan demikian, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci yang tidak adil</a> meningkatkan produktivitas, tetapi dapat menyebabkan kelaparan.  Saya menduga bahwa solusinya mungkin apa yang saya sebut kunci "terkadang adil".  Katakanlah, 99% dari waktu mereka akan tidak adil, tetapi dalam 1% memberikan kunci untuk proses lain.  Ini akan menjaga manfaat produktivitas dengan lebih banyak, menghindari masalah kelaparan.  Sebelumnya, kunci di Windows didistribusikan secara adil dan Anda mungkin dapat kembali ke sini sebagian, menemukan keseimbangan yang sempurna.  Penafian: Saya bukan ahli kunci atau insinyur OS, tapi saya tertarik mendengar pemikiran tentang hal itu, dan setidaknya saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukan yang pertama menawarkan sesuatu seperti itu</a> . <br><br>  Linus Torvalds baru-baru ini menghargai pentingnya kunci yang adil: di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Mungkin sudah waktunya untuk perubahan pada Windows juga. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk meringkas</a> : Mengunci selama beberapa detik tidak baik, itu membatasi konkurensi.  Tetapi pada sistem multi-core dengan kunci tidak adil, melepas dan kemudian segera menerima kunci lagi berperilaku <i>persis seperti itu</i> - utas lainnya tidak memiliki cara untuk bekerja. <br><br><h1>  Hampir gagal dengan ETW </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/a68/740/d69a68740eb8df0f6962d53db91190b7.png" align="right">  Untuk semua penelitian ini, saya mengandalkan penelusuran ETW, jadi saya sedikit takut ketika ternyata pada awal penyelidikan bahwa Windows Performance Analyzer (WPA) tidak dapat memuat karakter Chrome.  Saya yakin bahwa minggu lalu semuanya berjalan dengan baik.  Apa yang terjadi ... <br><br>  Kebetulan Chrome M68 keluar, dan itu ditautkan menggunakan lld-link bukan VC ++ linker.  Jika Anda menjalankan <i>dumpbin</i> dan melihat informasi debug, Anda akan melihat: <br><br> <code>C:\b\c\b\win64_clang\src\out\Release_x64\./initialexe/chrome.exe.pdb</code> <br> <br>  Yah, mungkin WPA tidak suka garis miring ini.  Tapi itu masih tidak masuk akal, karena saya mengubah linker ke lld-link, dan saya ingat bahwa saya menguji WPA sebelumnya, jadi apa yang terjadi ... <br><br>  Ternyata alasannya ada pada versi WPA 17134 yang baru. Saya menguji tata letak lld-Link - dan itu bekerja dengan baik di WPA 16299. Sungguh kebetulan!  Linker baru dan WPA baru tidak kompatibel. <br><br>  Saya menginstal versi lama WPA untuk melanjutkan penyelidikan (xcopy dari mesin dengan versi lama) dan melaporkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug lld-link</a> , yang dengan cepat diperbaiki oleh pengembang.  Sekarang Anda dapat kembali ke WPA 17134 ketika M69 dirakit dengan tautan tetap. <br><br><h1>  Wmi </h1><br>  Pemicu pembekuan WMI adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snap-in Instrumentasi Manajemen Windows</a> , dan saya tidak pandai.  Saya menemukan bahwa pada tahun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2014 atau sebelumnya,</a> seseorang mengalami masalah dalam penggunaan CPU secara signifikan di <i>WmiPrvSE.exe</i> di dalam <i>perfproc! GetProcessVaData</i> , tetapi mereka tidak memberikan informasi yang cukup untuk memahami penyebab bug.  Pada titik tertentu, saya membuat kesalahan dan mencoba mencari tahu apa permintaan WMI gila yang mungkin menggantung Gmail selama beberapa detik.  Saya menghubungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pakar</a> ke investigasi dan menghabiskan banyak waktu untuk mencari pertanyaan ajaib ini.  Saya mencatat aktivitas <i>Microsoft-Windows-WMI-Activity</i> dalam jejak ETW, bereksperimen dengan PowerShell untuk menemukan semua pertanyaan Win32_Perf, dan tersesat dalam beberapa cara bundaran yang terlalu membosankan untuk didiskusikan.  Pada akhirnya, saya menemukan bahwa hang Gmail menyebabkan penghitung ini, <i>Win32_PerfRawData_PerfProc_ProcessAddressSpace_Costly</i> , dipicu oleh PowerShell baris tunggal: <br><br><pre> <code class="hljs pgsql">measure-command {<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-WmiObject -Query “<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Win32_PerfFormattedData_PerfProc_ProcessAddressSpace_Costly”}</code> </pre> <br>  Saya kemudian menjadi <i>semakin</i> bingung karena nama penghitung ("sayang"? Benarkah?) Dan karena penghitung ini muncul dan menghilang berdasarkan faktor-faktor yang tidak saya mengerti. <br><br>  Namun detail WMI tidak masalah.  WMI tidak melakukan kesalahan - tidak benar-benar - hanya memindai memori.  Menulis kode pindai Anda sendiri ternyata jauh lebih berguna dalam menyelidiki masalah. <br><br><h1>  Kerumitan untuk Microsoft </h1><br>  Chrome telah merilis tambalan, sisanya untuk Microsoft. <br><br><ol><li>  <s>Mempercepat Pemindaian Wilayah CFG</s> - OK, Selesai </li><li>  Kosongkan memori CFG saat memori yang dapat dieksekusi dibebaskan - setidaknya dalam kasus penyelarasan 256 ribu, <i>mudah</i> </li><li>  Pertimbangkan bendera yang memungkinkan alokasi memori yang dapat dieksekusi tanpa memori CFG, atau gunakan PAGE_TARGETS_INVALID untuk tujuan ini.  Perhatikan bahwa manual <i>Windows Internal Bagian 1 Edisi 7</i> mengatakan bahwa "Anda harus memilih halaman [CFG] dengan setidaknya satu bit yang diset {1, X}" - jika Windows 10 mengimplementasikan ini, maka bendera PAGE_TARGETS_INVALID (yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saat ini digunakan oleh mesin) v8</a> ) akan menghindari alokasi memori </li><li>  Perbaiki perhitungan tabel halaman dalam vmmap untuk proses dengan sejumlah besar alokasi CFG </li></ol><br><h1>  Pembaruan Kode </h1><br>  Saya memperbarui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh kode</a> , terutama VAllocStress.  Ada 20 baris yang disertakan untuk menunjukkan cara menemukan reservasi CFG untuk suatu proses.  Saya juga menambahkan kode uji yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>SetProcessValidCallTarget</i></a> untuk memeriksa nilai bit CFG dan menunjukkan trik yang diperlukan untuk memanggil mereka dengan sukses (petunjuk: menelepon melalui GetProcAddress kemungkinan akan melanggar CFG!) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421153/">https://habr.com/ru/post/id421153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421139/index.html">Frontend Conf - menjaga pengguna</a></li>
<li><a href="../id421141/index.html">Analisis mutasi, atau cara menguji tes</a></li>
<li><a href="../id421143/index.html">Aurora Labs S-Titanium Pro Mini Logam 3D Printer</a></li>
<li><a href="../id421147/index.html">Monster setelah liburan: AMD Threadripper 2990WX 32-Core dan 2950X 16-Core</a></li>
<li><a href="../id421149/index.html">Beberapa kata tentang gradien</a></li>
<li><a href="../id421155/index.html">Pencetakan 3D pada tahun 2018: hal yang paling menarik di industri ini</a></li>
<li><a href="../id421157/index.html">Facebook akan melakukan penelitian tentang MRI menggunakan AI</a></li>
<li><a href="../id421159/index.html">Bagaimana cara menemukan mentor / mentor bisnis?</a></li>
<li><a href="../id421161/index.html">Keamanan informasi pembayaran tanpa uang tunai bank. Bagian 7 - Model Ancaman Dasar</a></li>
<li><a href="../id421163/index.html">Apakah ada alternatif Excel untuk penganggaran dan intelijen bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>