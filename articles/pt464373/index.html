<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏼 👨🏿‍🤝‍👨🏽 🔓 Edge-to-edge no Android: fazendo certo 🈳 🕒 🎅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O passado Google I / O 2019 trouxe muitas inovações sensacionais, muitas das quais afetarão o setor de desenvolvimento móvel nos próximos anos. Não fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Edge-to-edge no Android: fazendo certo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/464373/">  O passado Google I / O 2019 trouxe muitas inovações sensacionais, muitas das quais afetarão o setor de desenvolvimento móvel nos próximos anos.  Não foi menos interessante seguir as tendências emergentes.  Primeiro, as teclas de controle mecânico caíram na história, as telas dos smartphones ficaram maiores e os quadros laterais ficaram mais discretos.  Os gestos substituíram os botões do sistema na tela, deixando cada vez mais espaço para o consumo de conteúdo.  Os aplicativos são exibidos em toda a superfície visível da tela, da parte inferior à moldura superior, sem se restringir aos limites condicionais da barra de status e do painel de navegação.  Estamos à beira de uma era de ponta a ponta. <br><br><img src="https://habrastorage.org/webt/xu/3i/ny/xu3inyrvy6ruyd_uj5j5l97pnf0.png"><br><a name="habracut"></a><br>  O que é borda a borda?  Literalmente entendido, isso significa que seu aplicativo deve ser exibido em toda a superfície visível da tela, do quadro inferior ao quadro superior, sem se restringir à barra de status e aos botões de navegação inferiores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/119/459/053/11945905307bf673c909e4a75a270ba0.jpg"></div><br>  <i>Borda a borda no exemplo do shell do sistema Android.</i> <br><br>  Quando se trata do Android, uma idéia simples está longe de ser sempre fácil de implementar.  Neste artigo, falaremos sobre como maximizar o uso de todo o espaço disponível na tela de qualquer dispositivo, independentemente do fabricante, versão do sistema e a variedade de configurações que os fabricantes de dispositivos do Reino Médio (e não apenas) gostam de agradar aos usuários.  O código apresentado no artigo foi testado em mais de 30 dispositivos por nós pessoalmente e em 231 dispositivos diferentes por 100 mil usuários de nossos aplicativos. <br><br>  O problema de criar uma interface borda a borda não é novo por si só e era relevante muito antes da E / S 2019. Certamente, cada um de vocês se lembrará de como primeiro pesquisou algo da categoria: <i>"barra de status transparente do android"</i> ou <i>"gradiente da barra de status do android" "</i> <br><br>  Os principais critérios para o aplicativo corresponder ao título de borda a borda são: <br><br><ul><li>  barra de status transparente; </li><li>  barra de navegação transparente. </li></ul><br>  Leia mais sobre eles no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">material.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/18b/3a3/a2018b3a34a0d61b30d940f2c50c44fe.png"></div><br>  <i>O aplicativo Deezer não se preocupa com a conformidade de ponta a ponta</i> <i><br></i> <br>  É importante notar que não estamos falando sobre removê-los completamente, como no " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modo de tela cheia</a> ".  Deixamos ao usuário a oportunidade de ver informações importantes do sistema e usar a navegação familiar. <br><br>  Um requisito igualmente importante para uma solução é escalabilidade e extensibilidade.  Existem vários outros: <br><br><ul><li>  Desloque corretamente a tela acima do teclado sem interromper o suporte para os sinalizadores AdjustResize da Activity; </li><li>  Evite sobrepor a barra de status e a barra de navegação nos elementos da interface do usuário do aplicativo, enquanto exibe o plano de fundo correspondente sob eles; </li><li>  Trabalhe em todos os dispositivos com versões atuais do Android e pareça idêntico. </li></ul><br><h1>  Pouco de teoria </h1><br>  Pode demorar muito tempo para encontrar uma solução para uma tarefa aparentemente simples, o que não será fácil para o gerente de projeto explicar.  E quando o controle de qualidade ainda encontra o smartphone infeliz, no qual sua tela não parece "de acordo com os cânones" ... <br>  Em nosso projeto, nos enganamos várias vezes.  Apenas um mês depois, depois de passar por uma longa série de tentativas e erros, resolvemos o problema de uma vez por todas. <br><br>  Primeiro de tudo, você precisa entender como o Android desenha os painéis do sistema.  A partir do Android 5.0, foi fornecida uma API conveniente para trabalhar com recuos do sistema ao longo das bordas horizontais da tela.  Eles são chamados WindowInsets e, na figura abaixo, são coloridos em vermelho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/f76/d86/bd4f76d86dd3508a88edf9618eab7a1b.png"></div><br>  Além disso, os desenvolvedores da equipe do Android adicionaram ouvintes que permitem que você assine alterações nesses recuos, por exemplo, quando o teclado aparecer.  A rigor, WindowInsets são as margens do seu arquivo de layout a partir das bordas da tela.  Ao redimensionar sua Atividade (modo de tela dividida, aparência do teclado), o Inset também será alterado.  Portanto, para oferecer suporte de ponta a ponta, precisamos garantir que esses recuos não estejam lá.  Uma tela com WindowInsets nulo terá a seguinte aparência: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/197/cca/01d/197cca01df6de4ab8707131a70f8c993.png"></div><br><h1>  Implementação </h1><br>  Em nossa implementação, operaremos ativamente no Window e em seus sinalizadores. <br>  Todos os exemplos serão escritos em Kotlin, mas você pode implementá-los facilmente em Java, usando utilitários em vez de funções de extensão. <br><br>  A primeira coisa a fazer com o elemento de layout raiz é definir explicitamente o sinalizador: <br><br><pre><code class="kotlin hljs">android:fitsSystemWindows=<span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Isso é necessário para garantir que a Vista raiz seja desenhada sob os elementos do sistema, bem como para as medidas corretas do Inset ao assinar sua alteração. <br>  Agora nos voltamos para a coisa mais importante - removemos as bordas da tela!  No entanto, isso deve ser feito com muito cuidado.  E aqui está o porquê: <br><br><ol><li>  Zerando a inserção inferior, corremos o risco de perder a reação da janela à aparência do teclado: há dezenas de dicas no StackOverflow para redefinir a inserção superior, mas as inferiores são delicadamente silenciosas.  Por esse motivo, o NavigationBar não se mostra completamente transparente.  Ao redefinir a inserção inferior, o sinalizador AdjustResize para de funcionar. <br><br>  <b>Solução:</b> Cada vez que você altera o Inset, determine se a altura mais baixa do teclado está contida nele e somente restaure-a. </li><li>  Quando você redefine o Inset, as partes visíveis da View aparecem na barra de status e na barra de navegação.  De acordo com o conceito de design de materiais (e senso comum), nenhum elemento ativo deve ser localizado nas áreas do sistema.  Ou seja, nessa área não deve haver botões, campos para inserir texto, caixas de seleção etc. <br><br>  <b>Solução:</b> adicionaremos um ouvinte ao ouvinte para que, ao alterar WindowInsets, traduza os recuos do sistema para a Atividade e responda a eles internamente, definindo os preenchimentos e margens corretos para a Visualização. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/73e/10e/3bd73e10ee50b6e2ae8a2da1b1bb2808.png"></div><br>  Esse comportamento não deve ser permitido (a barra de ferramentas rastreia na barra de status). <br><br>  A função <i>removeSystemInsets ()</i> tem a seguinte aparência: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeSystemInsets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ViewCompat.setOnApplyWindowInsetsListener(view) { _, insets -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = calculateDesiredBottomInset( view, insets.systemWindowInsetTop, insets.systemWindowInsetBottom, listener ) ViewCompat.onApplyWindowInsets( view, insets.replaceSystemWindowInsets(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset) ) } }</code> </pre><br>  A função modifyDesiredBottomInset <i>() calcula a</i> inserção inferior com ou sem o teclado, dependendo da configuração atual do dispositivo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateDesiredBottomInset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, topInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasKeyboard = isKeyboardAppeared(view, bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) bottomInset <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> listener(topInset, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasKeyboard) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bottomInset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desiredBottomInset }</code> </pre><br>  Use o método <i>isKeyboardAppeared ()</i> para verificar a altura do teclado <i>.</i>  Confiamos na hipótese de que o teclado não pode ocupar menos de um quarto da altura da tela.  Se desejar, você pode modificar a lógica de verificação como desejar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyboardAppeared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bottomInset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = bottomInset / resourdisplayMetrics.heightPixels.toDouble() &gt; .<span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre> <br>  O método <i>removeSystemInsets ()</i> usa um ouvinte.  Na verdade, essas são apenas tipealias para uma expressão lambda.  Seu código completo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> OnSystemBarsSizeChangedListener = (statusBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, navigationBarSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span></code> </pre> <br>  O próximo passo é definir a transparência para as barras do sistema: <br><br><pre> <code class="kotlin hljs">window.statusBarColor = Color.TRANSPARENT window.navigationBarColor = Color.TRANSPARENT</code> </pre> <br>  Depois de compilar tudo o que foi dito acima, obtemos o seguinte método: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemInsetsChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { InsetUtil.removeSystemInsets(window.decorView, listener) window.navigationBarColor = Color.TRANSPARENT window.statusBarColor = Color.TRANSPARENT }</code> </pre> <br>  Agora, para ativar o modo borda a borda da Atividade desejada, basta chamar a seguinte função no método <i>onCreate ()</i> : <br><br><pre> <code class="kotlin hljs">setWindowTransparency { statusBarSize, navigationBarSize -&gt; <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Assim, em menos de 30 linhas de código, alcançamos um efeito "de ponta a ponta", sem violar nenhum princípio de UX e sem privar o usuário dos controles usuais do sistema.  Essa implementação pode parecer simples e trivial para alguém, mas é isso que garante a operação confiável do seu aplicativo em qualquer dispositivo. <br>  Você pode obter o efeito "de ponta a ponta" de centenas de maneiras diferentes (o número de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dicas</a> sobre o StackOverflow é uma confirmação clara disso), mas muitas delas levam a comportamentos incorretos em diferentes versões do Android ou não levam em consideração parâmetros como a necessidade de exibição longa. listas ou quebre o redimensionamento da tela ao mostrar o teclado <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/955/a21/a0a/955a21a0a5422a4463fa0908c0427990.gif"></div><br><hr><br><h1>  Voar na pomada </h1><br>  A solução descrita neste artigo é adequada para todos os dispositivos atuais.  Real significa dispositivos no Android Lollipop (5.0) e superior.  Para eles, a solução acima funcionará perfeitamente.  Mas para versões mais antigas do Android, você precisará de sua própria implementação, pois nada era conhecido sobre o WindowInsets naquela época. <br><br>  A boa notícia é que no Android KitKat (4.4), a transparência dos painéis do sistema ainda é suportada.  Mas versões mais antigas não suportam tanta beleza, você nem pode tentar. <br><br>  Vamos nos concentrar na mudança de inserções no Android 4.4.  Isso pode ser feito no método <i>fitSystemWindows ()</i> .  Portanto, o elemento principal em seu layout deve ser um contêiner com um método fitSystemWindows substituído, contendo exatamente a mesma implementação que nosso ouvinte no exemplo de versões atuais do Android. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KitkatTransparentSystemBarsFrame</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyleAttr: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = -<span class="hljs-number"><span class="hljs-number">1</span></span> ) : FrameLayout(context, attrs, defStyleAttr), KitkatTransparentSystemBarsContainer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onSystemInsetsChangedListener: OnSystemInsetsChangedListener = { _, _ -&gt; } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fitSystemWindows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(insets: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Rect</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { insets ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> desiredBottomInset = InsetUtil.calculateDesiredBottomInset( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, insets.top, insets.bottom, onSystemInsetsChangedListener ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.fitSystemWindows(Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, desiredBottomInset)) }</code> </pre><br>  Em dispositivos com Android 4.4, apenas a transparência parcial funciona através da configuração de sinalizadores translúcidos: <br><br><pre> <code class="kotlin hljs">window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION )</code> </pre> <br>  Esses sinalizadores tornam as barras do sistema translúcidas, adicionando um leve gradiente a elas, que, infelizmente, não podem ser removidas.  No entanto, o gradiente pode ser transformado em uma barra de cores translúcida usando esta biblioteca: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/jgilfelt/SystemBarTint</a> .  Ela nos resgatou mais de uma vez no passado.  As alterações mais recentes foram feitas na biblioteca há 5 anos, portanto apenas revelam seu charme para verdadeiras cidades retrógradas. <br><br>  Todo o processo de sinalização para Kitkat terá a seguinte aparência: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Activity.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindowTransparencyKitkat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( rootView: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KitkatTransparentSystemBarsContainer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, listener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OnSystemBarsSizeChangedListener</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = { _, _ -&gt; } )</span></span></span></span> { rootView.onSystemBarsSizeChangedListener = listener window.addFlags( WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION ) }</code> </pre> <br>  Com isso em mente, estamos escrevendo um método universal que pode tornar as barras do sistema transparentes (ou pelo menos translúcidas), independentemente de qual aplicativo esteja sendo executado em um dispositivo com qual versão do Android: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP -&gt; setWindowTransparency(::updateMargins) Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT -&gt; setWindowTransparencyKitkat(root_container, ::updateMargins) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*do nothing*/</span></span> } }</code> </pre><br>  No spoiler abaixo, você pode ver como a amostra apresentada no artigo se parece com alguns dos dispositivos problemáticos: <br><br><div class="spoiler">  <b class="spoiler_title">Screenshots</b> <div class="spoiler_text">  Huawei Honor 8, Android 7.0 <br><br><img src="https://habrastorage.org/webt/vb/iq/vb/vbiqvbaw6ncicr9zaramjgp7rw4.png"><br><br>  Xiaomi Redmi Note 4, Android 6.1 <br><br><img src="https://habrastorage.org/webt/oa/qz/09/oaqz09dbvoqd9lvdrqmvd_db2lq.png"><br><br>  HTC Desire Dual Sim, Android 4.4.2 <br><br><img src="https://habrastorage.org/webt/qa/tj/og/qatjogphzqsrtj59iep-bnnqdyw.png"><br><br>  Samsung J3, Android 7.0 <br><br><img src="https://habrastorage.org/webt/_u/tm/gj/_utmgjk86esswybhkri_ropcghw.jpeg"><br><br>  Meizu M3s, Android 5.1 <br><br><img src="https://habrastorage.org/webt/5m/9b/7f/5m9b7f0wc6g3vodq2jimsaqichm.jpeg"><br><br>  Asus Zenfone 3 Max (Android 6.0) <br><br><img src="https://habrastorage.org/webt/ye/t5/9l/yet59l_2qgcqsdbnps2jgwgvx3g.jpeg"><br><br>  Umi Roma, Android 5.0 <br><br><img src="https://habrastorage.org/webt/qn/th/zp/qnthzp8jdtsobkl2t5c_et3iada.png"><br><br>  Nexus 5X, Android 8.0 <br><br><img src="https://habrastorage.org/webt/t7/9j/mo/t79jmolqrgeimm_0ylppf3nwwrk.png"><br><br>  Samsung Galaxy S8, Android 9.0 <br><br><img src="https://habrastorage.org/webt/to/cg/ab/tocgabznqxu36_wp1-d9aou0hbe.jpeg"><br></div></div><br><hr><br>  Concluindo, quero dizer que a solução para uma tarefa aparentemente tão simples como definir transparência para elementos da interface do usuário do sistema pode arrastar você por toda a variedade de armadilhas e não levar ao resultado desejado, mas causará bugs desagradáveis.  Ainda bem que você tem este artigo agora. <br><br>  Você pode encontrar uma lista completa do programa e uma amostra do trabalho em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório git</a> . <br><br>  O material é inspirado no relatório de Chris Banes "Tornando-se um instalador de janela principal". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_mGDMVRO3iE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Agradeço ao Surf studio e a Evgeny Saturov pela ajuda na preparação do material. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464373/">https://habr.com/ru/post/pt464373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464361/index.html">Intel Quartz Canyon - NUC para profissionais</a></li>
<li><a href="../pt464365/index.html">Semana 34 de segurança: vulnerabilidades extraordinárias no Windows</a></li>
<li><a href="../pt464367/index.html">E outro escalonamento de privilégios locais no cliente Windows Steam 0 dia</a></li>
<li><a href="../pt464369/index.html">Qual bloqueador você usa? Resultados</a></li>
<li><a href="../pt464371/index.html">/etc/resolv.conf para os pods do Kubernetes, opção ndots: 5, pois isso pode afetar adversamente o desempenho do aplicativo</a></li>
<li><a href="../pt464375/index.html">Como os mecanismos de pesquisa funcionam</a></li>
<li><a href="../pt464377/index.html">Montador sujo hacks 6502</a></li>
<li><a href="../pt464381/index.html">Viagem ao Alasca ou KDD'19 através dos olhos de uma testemunha ocular</a></li>
<li><a href="../pt464383/index.html">Como eu coloco as coisas em ordem em um projeto em que há uma floresta de mãos diretas (configurações tslint, mais bonitas, etc.)</a></li>
<li><a href="../pt464385/index.html">Python como o caso final de C ++. Parte 1/2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>