<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üà∏ ‚öôÔ∏è Ajuste del rendimiento de la consulta en PostgreSQL üí∏ üë©üèæ‚Äçü§ù‚Äçüë®üèª üçü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ajuste del rendimiento de la base de datos: los desarrolladores generalmente lo aman o lo odian. Disfruto esto y quiero compartir algunos de los m√©tod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ajuste del rendimiento de la consulta en PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461997/"><img width="40%" align="left" src="https://habrastorage.org/webt/0s/ei/zy/0seizy-vxfjf3uv8g3n_bijcwb0.jpeg">  Ajuste del rendimiento de la base de datos: los desarrolladores generalmente lo aman o lo odian.  Disfruto esto y quiero compartir algunos de los m√©todos que he usado recientemente para ajustar consultas mal ejecutadas en PostgreSQL.  Mis m√©todos no son exhaustivos, sino m√°s bien un libro de texto para aquellos que solo se esfuerzan por afinar. <br><br><h2>  Buscar consultas lentas </h2><br>  La primera forma obvia de comenzar a ajustar es encontrar operadores espec√≠ficos que funcionen mal. <br><br><h3>  pg_stats_statements </h3><br>  El m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_stats_statements</a> es un excelente lugar para comenzar.  Simplemente realiza un seguimiento de las estad√≠sticas de ejecuci√≥n de las instrucciones SQL y puede ser una manera f√°cil de encontrar consultas ineficientes. <br><br>  Una vez que haya instalado este m√≥dulo, estar√° disponible una vista del sistema llamada <i>pg_stat_statements</i> con todas sus propiedades.  Una vez que tenga la oportunidad de recopilar suficientes datos, busque consultas que tengan un valor <i>total_tiempo</i> relativamente alto <i>.</i>  Conc√©ntrese primero en estos operadores. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  ID_usuario </th><th>  dbid </th><th>  queryid </th><th>  consulta </th><th>  llamadas </th><th>  tiempo_total </th></tr></thead><tbody><tr><td>  16384 </td><td>  16385 </td><td>  2948 </td><td>  SELECCIONE direcci√≥n_1 DESDE direcciones a INTERIOR √öNASE personas p EN a.person_id = p.id DONDE a.state = @state_abbrev; </td><td>  39483 </td><td>  15224.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  924 </td><td>  SELECCIONE person_id DESDE personas DONDE name = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">name</a> ; </td><td>  26483 </td><td>  12225.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  395 </td><td>  SELECCIONE _ DE los pedidos DONDE EXISTE (seleccione _ de los productos donde est√°_featured = true) </td><td>  18583 </td><td>  224,67 </td></tr></tbody></table></div><br><a name="habracut"></a><br><h3>  auto_explain </h3><br>  El m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">auto_explain</a> tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es</a> √∫til para encontrar consultas lentas, pero tiene 2 ventajas obvias: registra el plan de ejecuci√≥n real y admite la grabaci√≥n de declaraciones anidadas utilizando la opci√≥n <i>log_nested_statements</i> .  Las declaraciones anidadas son declaraciones que se ejecutan dentro de una funci√≥n.  Si su aplicaci√≥n usa muchas funciones, auto_explain es invaluable para obtener planes de ejecuci√≥n detallados. <br><br>  La opci√≥n <i>log_min_duration</i> controla qu√© planes de ejecuci√≥n de consultas se registran en funci√≥n de cu√°nto tiempo se ejecutan.  Por ejemplo, si establece el valor en 1000, se registrar√°n todos los registros que demoren m√°s de 1 segundo. <br><br><h2>  Ajuste de √≠ndice </h2><br>  Otra estrategia de ajuste importante es garantizar que los √≠ndices se usen correctamente.  Como requisito previo, debemos incluir el recopilador de estad√≠sticas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Postgres Statistics Collector</a> es un subsistema de primera clase que recopila todo tipo de estad√≠sticas de rendimiento √∫tiles. <br><br>  Al habilitar este recopilador, obtiene toneladas de <i>vistas pg_stat _...</i> que contienen todas las propiedades.  En particular, encontr√© que esto es especialmente √∫til para encontrar √≠ndices faltantes y no utilizados. <br><br><h3>  √çndices faltantes </h3><br>  Los √≠ndices faltantes pueden ser una de las soluciones m√°s f√°ciles para mejorar el rendimiento de las consultas.  Sin embargo, no son una bala de plata y deben usarse correctamente (m√°s sobre esto m√°s adelante).  Si tiene habilitado el recopilador de estad√≠sticas, puede ejecutar la siguiente consulta ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente</a> ). <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, seq_scan - idx_scan <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> too_much_seq, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> seq_scan - <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(idx_scan, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'Missing Index?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, pg_relation_size(relname::regclass) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rel_size, seq_scan, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_relation_size(relname::regclass) &gt; <span class="hljs-number"><span class="hljs-number">80000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> too_much_seq <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  La consulta encuentra tablas que tienen m√°s escaneos secuenciales (escaneos de √≠ndice) que escaneos de √≠ndice, una se√±al obvia de que el √≠ndice ayudar√°.  Esto no le dir√° en qu√© columnas crear el √≠ndice, por lo que tomar√° un poco m√°s de trabajo.  Sin embargo, saber qu√© tablas las necesitan es un buen primer paso. <br><br><h3>  √çndices no utilizados </h3><br>  Indice todas las entidades, ¬øverdad?  ¬øSab√≠a que los √≠ndices no utilizados pueden afectar negativamente el rendimiento de escritura?  La raz√≥n es que al crear el √≠ndice de Postgres, se carga con la tarea de actualizar este √≠ndice despu√©s de las operaciones de escritura (INSERT / UPDATE / DELETE).  Por lo tanto, agregar un √≠ndice es un acto de equilibrio, ya que puede acelerar la lectura de datos (si se cre√≥ correctamente), pero ralentizar√° las operaciones de escritura.  Para buscar √≠ndices no utilizados, puede ejecutar la siguiente consulta. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, relid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>, <span class="hljs-string"><span class="hljs-string">'DROP INDEX '</span></span> || indexrelid::regclass || <span class="hljs-string"><span class="hljs-string">';'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> drop_statement <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (indexrelid) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> idx_scan = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> indisunique <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h3>  Nota sobre estad√≠sticas del entorno de desarrollo </h3><br>  Confiar en las estad√≠sticas de una base de datos de desarrollo local puede ser problem√°tico.  Idealmente, puede obtener las estad√≠sticas anteriores de su m√°quina de trabajo o generarlas a partir de una copia de seguridad de trabajo restaurada.  Por qu√©  Los factores ambientales pueden cambiar el comportamiento del optimizador de consultas de Postgres.  Dos ejemplos: <br><br><ul><li>  cuando la m√°quina tiene menos memoria, PostgreSQL puede no ser capaz de realizar una Hash Join, de lo contrario puede y lo har√° m√°s r√°pido. </li><li>  Si no hay tantas filas en la tabla (como en la base de datos de desarrollo), PostgresSQL puede preferir realizar un an√°lisis secuencial de la tabla en lugar de utilizar un √≠ndice disponible.  Cuando los tama√±os de tabla son peque√±os, Seq Scan puede ser m√°s r√°pido.  (Nota: puedes correr <pre> <code class="plaintext hljs">SET enable_seqscan = OFF</code> </pre>  en una sesi√≥n para que el optimizador elija usar √≠ndices, incluso si los escaneos secuenciales pueden ser m√°s r√°pidos.  Esto es √∫til cuando se trabaja con bases de datos de desarrollo que no tienen muchos datos) </li></ul><br><h2>  Comprender los planes de ejecuci√≥n </h2><br>  Ahora que ha encontrado algunas consultas lentas, es hora de comenzar la diversi√≥n. <br><br><h3>  EXPLICAR </h3><br>  El comando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EXPLAIN</a> ciertamente se requiere al configurar consultas.  √âl te dice lo que realmente est√° sucediendo.  Para usarlo, simplemente agregue <i>EXPLICAR</i> a la consulta y ejec√∫telo.  PostgreSQL le mostrar√° el plan de ejecuci√≥n que utiliz√≥. <br><br>  Cuando use EXPLAIN para la sintonizaci√≥n, recomiendo siempre usar la opci√≥n <i>ANALYZE</i> ( <i>EXPLAIN ANALYZE</i> ), ya que le brinda resultados m√°s precisos.  La opci√≥n ANALIZAR realmente ejecuta la declaraci√≥n (en lugar de solo evaluarla) y luego la explica. <br><br>  Tomemos un chapuz√≥n y comencemos a entender la salida de <i>EXPLAIN</i> .  Aqu√≠ hay un ejemplo: <br><br><img src="https://habrastorage.org/webt/ee/py/sv/eepysvoeunknfcwr9meuxa9e4y4.png"><br><br><h3>  Nudos </h3><br>  Lo primero que hay que entender es que cada bloque sangrado con el "-&gt;" anterior (junto con la l√≠nea superior) se llama nodo.  Un nodo es una unidad l√≥gica de trabajo (un "paso", si lo desea) con el costo y el tiempo de entrega asociados.  El costo y el tiempo presentados en cada nodo son acumulativos y re√∫nen a todos los nodos secundarios.  Esto significa que la l√≠nea superior (nodo) muestra el costo total y el tiempo real para todo el operador.  Esto es importante porque puede profundizar f√°cilmente para determinar qu√© nodos son el cuello de botella. <br><br><h3>  Costo </h3><br><pre> <code class="plaintext hljs">cost=146.63..148.65</code> </pre> <br>  El primer n√∫mero es el costo inicial (el costo de obtener el primer registro), y el segundo n√∫mero es el costo de procesar todo el nodo (costo total de principio a fin). <br><br>  De hecho, este es el costo que tendr√°n que cumplir las estimaciones de PostgreSQL para ejecutar la declaraci√≥n.  Este n√∫mero no significa cu√°nto tiempo llevar√° completar la solicitud, aunque generalmente se necesita una relaci√≥n directa para completarla.  El costo es una combinaci√≥n de 5 componentes de trabajo utilizados para evaluar el trabajo requerido: muestreo secuencial, muestreo inconsistente (aleatorio), procesamiento de filas, operador de procesamiento (funci√≥n) y registro del √≠ndice de procesamiento.  El costo es la entrada / salida y la carga del procesador, y es importante saber que el costo relativamente alto significa que PostgresSQL cree que tendr√° que hacer m√°s trabajo.  El optimizador decide qu√© plan de ejecuci√≥n usar seg√∫n el costo.  El optimizador prefiere costos m√°s bajos. <br><br><h3>  Tiempo real </h3><br><pre> <code class="plaintext hljs">actual time=55.009..55.012</code> </pre> <br>  En milisegundos, el primer n√∫mero es el tiempo de inicio (tiempo para recuperar el primer registro), y el segundo n√∫mero es el tiempo requerido para procesar el nodo completo (tiempo total desde el inicio hasta el final).  F√°cil de entender, ¬øverdad? <br><br>  En el ejemplo anterior, tom√≥ 55.009 ms obtener el primer registro y 55.012 ms para completar el nodo completo. <br><br><h3>  Obtenga m√°s informaci√≥n sobre los planes de ejecuci√≥n. </h3><br>  Hay algunos art√≠culos realmente buenos para comprender los resultados de EXPLAIN.  En lugar de tratar de volver a contarlos aqu√≠, recomiendo tomarse el tiempo para comprenderlos realmente yendo a estos 2 maravillosos recursos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.depesz.com/2013/04/16/explaining-the-unexplainable/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://wiki.postgresql.org/images/4/45/Explaining_EXPLAIN.pdf</a> </li></ul><br><h2>  Solicitar ajuste </h2><br>  Ahora que sabe qu√© operadores funcionan mal y puede ver sus planes de ejecuci√≥n, es hora de comenzar a ajustar su consulta para mejorar el rendimiento.  Aqu√≠ realiza cambios en sus consultas y / o agrega √≠ndices para intentar obtener un mejor plan de ejecuci√≥n.  Comience con cuellos de botella y vea si hay alg√∫n cambio que pueda hacer para reducir los costos y / o el tiempo de entrega. <br><br><h4>  Cach√© de datos y nota de costos </h4><br>  Al realizar cambios y evaluar los planes de implementaci√≥n, para ver si habr√° mejoras, es importante saber que las implementaciones futuras pueden depender del almacenamiento en cach√© de los datos que dan una idea de los mejores resultados.  Si ejecuta la solicitud una vez, realice una correcci√≥n y ejec√∫tela por segunda vez, lo m√°s probable es que se ejecute mucho m√°s r√°pido, incluso si el plan de ejecuci√≥n no es m√°s favorable.  Esto se debe a que PostgreSQL podr√≠a almacenar en cach√© los datos utilizados en el primer inicio y puede usarlos en el segundo inicio.  Por lo tanto, debe completar las consultas al menos 3 veces y promediar los resultados para comparar los costos. <br><br>  Lo que aprend√≠ puede ayudar a mejorar los planes de ejecuci√≥n: <br><br><ul><li>  √çndices <br><ul><li>  Excluya la exploraci√≥n secuencial (exploraci√≥n secuencial) agregando √≠ndices (si el tama√±o de la tabla no es peque√±o) </li><li>  Cuando utilice un √≠ndice de varias columnas, aseg√∫rese de prestar atenci√≥n al orden en el que define las columnas incluidas - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√°s informaci√≥n</a> </li><li>  Pruebe los √≠ndices que son muy selectivos para los datos de uso frecuente.  Esto har√° que su uso sea m√°s eficiente. </li></ul></li><li>  Condici√≥n DONDE <br><br><ul><li>  Evitar ME GUSTA </li><li>  Evite llamadas a funciones en la cl√°usula WHERE </li><li>  Evite grandes condiciones en () </li></ul></li><li>  √öNETE <br><br><ul><li>  Al unir tablas, intente usar una expresi√≥n de igualdad simple en la cl√°usula ON (es decir, a.id = b.person_id).  Esto le permite utilizar m√©todos de uni√≥n m√°s eficientes (es decir, Hash Join, no Nested Loop Join) </li><li>  Convierta subconsultas en sentencias JOIN cuando sea posible, ya que esto generalmente le permite al optimizador comprender el objetivo y posiblemente elegir el mejor plan. </li><li>  Utilice COMPUESTOS correctamente: ¬øutiliza GROUP BY o DISTINCT solo porque obtiene resultados duplicados?  Esto generalmente indica un uso incorrecto de JOIN y puede generar costos m√°s altos. </li><li>  Si el plan de ejecuci√≥n usa Hash Join, puede ser muy lento si las estimaciones del tama√±o de la tabla son incorrectas.  Por lo tanto, aseg√∫rese de que las estad√≠sticas de su tabla sean precisas revisando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estrategia de aspiraci√≥n.</a> </li><li>  Evite las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subconsultas correlacionadas siempre que sea</a> posible;  pueden aumentar significativamente el costo de una solicitud </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EXISTS</a> cuando verifique la existencia de cadenas en funci√≥n de un criterio, ya que es similar a un cortocircuito (detiene el procesamiento cuando encuentra al menos una coincidencia) </li></ul></li><li>  Recomendaciones generales <br><br><ul><li>  Haz m√°s con menos;  Procesador m√°s r√°pido que la entrada / salida (E / S) </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expresiones de tabla comunes</a> y tablas temporales cuando necesite realizar consultas encadenadas. </li><li>  Evite las instrucciones LOOP y prefiera las operaciones SET </li><li>  Evite COUNT (*) ya que PostgresSQL escanea tablas para esto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solo para versiones &lt;= 9.1</a> ) </li><li>  Evite ORDER BY, DISTINCT, GROUP BY, UNION siempre que sea posible, ya que esto conlleva altos costos iniciales. </li><li>  Busque la gran diferencia entre las l√≠neas estimadas y reales en la expresi√≥n <i>EXPLICAR</i> .  Si el contador es muy diferente, las estad√≠sticas de la tabla pueden estar desactualizadas y PostgreSQL estima el costo utilizando estad√≠sticas inexactas.  Por ejemplo: <pre> <code class="plaintext hljs">Limit (cost=282.37..302.01 rows=93 width=22) (actual time=34.35..49.59 rows=2203 loops=1)</code> </pre>  El n√∫mero estimado de l√≠neas fue de 93 y el actual - 2203. Por lo tanto, lo m√°s probable es que esta sea una mala decisi√≥n del plan.  Debe revisar su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estrategia de aspiraci√≥n</a> y asegurarse de que ANALYZE se ejecute con la frecuencia suficiente. </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461997/">https://habr.com/ru/post/461997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461983/index.html">C√≥mo modificamos el producto para un cliente espec√≠fico</a></li>
<li><a href="../461985/index.html">Tecnolog√≠as postales: c√≥mo digitalizamos el correo ruso</a></li>
<li><a href="../461989/index.html">Desarrollo de una interfaz de juego para varias proporciones de pantallas.</a></li>
<li><a href="../461993/index.html">C√≥mo convertirse en un supermercado de un "dise√±ador habitual"</a></li>
<li><a href="../461995/index.html">C√≥mo usar proxies residentes para marketing y promoci√≥n de sitios web</a></li>
<li><a href="../461999/index.html">Otra versi√≥n del entorno de desarrollo de WordPress (docker, wp-cli)</a></li>
<li><a href="../462003/index.html">C√≥mo publiqu√© PWA en Svelte en Google Play</a></li>
<li><a href="../462005/index.html">Caracter√≠sticas de Google PageSpeed: calificaci√≥n mejorada del sitio y ranking de b√∫squeda</a></li>
<li><a href="../462007/index.html">Desarrollando scripts robustos de Python</a></li>
<li><a href="../462009/index.html">Tendencias de programaci√≥n: ¬øqu√© se puede esperar en 2020?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>