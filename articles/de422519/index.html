<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰 🐚 🤲🏼 Freebie Distribution: Nicht bremsende Threads in Java. Projektwebstuhl 👀 💗 👨🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Möchten Sie in Java-Threads, die nicht Speicher essen, als ob sie nicht in sich selbst sind und nicht verlangsamen? Gute Kreditwürdigkeit, und dieses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Freebie Distribution: Nicht bremsende Threads in Java. Projektwebstuhl</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422519/"><p>  Möchten Sie in Java-Threads, die nicht Speicher essen, als ob sie nicht in sich selbst sind und nicht verlangsamen?  Gute Kreditwürdigkeit, und dieses Problem beantwortet diese Frage. </p><br><p>  Wir erklären die Arbeit von Project Loom an Pizzaschachteln!  Komm schon! </p><br><p>  All dies wird entfernt und <b>speziell für Habr geschrieben</b> . </p><br><br><p><br clear="all"></p><a name="habracut"></a><br><h1 id="pozyvnye">  Rufzeichen </h1><br><p>  Sehen Sie dieses Bild oft in Ihrem Webdienst: Zuerst war alles in Ordnung, dann kamen eine Million Chinesen zu Ihnen, der Dienst machte eine Million Fäden und ertrank in der Hölle? </p><br><p><img src="https://habrastorage.org/webt/ym/_-/3r/ym_-3rq8a8g56hsmrvjhprnih8y.png"><br><br></p><br><p>  Willst du so ein schönes Bild? </p><br><p><img src="https://habrastorage.org/webt/38/s-/04/38s-04z5nak6trs_p2lei9chjku.png"><br><br></p><br><p>  Mit anderen Worten, möchten Sie in Java-Threads, die kein Gedächtnis fressen, aber nicht an sich sind und nicht langsamer werden?  Gute Kreditwürdigkeit, und dieses Problem beantwortet diese Frage. </p><br><p>  Wir werden in der Tat damit beschäftigt sein, <em>das neue Framework auszupacken</em> .  Erinnerst du dich, wie Wylsacom iPhones ausgepackt hat?  Einige erinnern sich noch nicht an die alten Rezensenten, aber warum?  Weil Habr eine Hochburg des Mainstreams ist und bezahlte Videos leider die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Strahlen des Durchfalls sind</a> .  In diesem Beitrag beschäftigen wir uns ausschließlich mit technischem Hardcore. </p><br><p>  Zunächst zwei Minuten zu den Augäpfeln, Haftungsausschluss und anderem Müll, der gesagt werden muss.  Sie können es überspringen, wenn Sie zu faul sind. </p><br><p>  Erstens sind alles, was in dem Video gesagt wurde, meine persönlichen Gedanken, und sie haben nichts mit dem Arbeitgeber oder dem glorreichen Oracle-Unternehmen, der Weltregierung der Eidechsen und einer verdammten Sache im Mörser zu tun.  Ich schreibe das sogar um drei Uhr morgens, damit klar ist, dass es meine persönliche Initiative ist, mein persönlicher Müll.  <em>Alle Übereinstimmungen sind rein zufällig.</em> </p><br><p>  Aber es gibt noch ein anderes Bonusziel.  Wir reden ständig über Coroutinen in Kotlin.  Kürzlich gab es Interviews mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roma Elizarov</a> , dem Gott von Corutin, und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pascha Finkelstein</a> , der Backends darüber schreiben wird.  Bald wird es ein Interview mit Andrei Breslav geben - dem Vater von Kotlin.  Und überall wird das Loom-Projekt auf die eine oder andere Weise erwähnt, weil es ein Analogon von Coroutine ist.  Und wenn Sie nicht wissen, was Loom ist, werden Sie beim Lesen dieser Interviews möglicherweise dumm.  Es gibt einige coole Typen, die über coole Dinge diskutieren.  Und da bist du, und du bist nicht bei ihnen, du Trottel.  Das ist sehr dumm. </p><br><p>  Tun Sie dies nicht, lesen Sie, was Loom in diesem Artikel ist, oder schauen Sie sich dieses Video weiter an, ich werde alles erklären. </p><br><p>  Also, was ist die Komplikation.  Es gibt so einen Kerl, Ron Presler. </p><br><br><p><img src="https://habrastorage.org/webt/w-/tq/ut/w-tqutfyx33olnhdavtq_asdv9u.png"><br><br></p><br><p>  Letztes Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ging er zur Mailingliste</a> , sagte, dass Threads in Java scheiße sind, und schlug vor, die Laufzeit auszuführen und zu reparieren.  Und jeder würde ihn auslachen und Steine ​​werfen, Scheiße, wenn nicht die Tatsache, dass er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quasar</a> früher geschrieben hat, und das ist eigentlich sehr cool.  Sie können bei Quasar lange schwören, aber es scheint da zu sein und es funktioniert, und im Großen und Ganzen ist dies eher eine Errungenschaft. </p><br><p>  Es gibt verdammt viele Govnokodery, die nichts tun, sagen Sie einfach.  Nun, mach es richtig, ich bin das gleiche.  Oder es gibt Leute, die coole Ingenieure zu sein scheinen, aber im Allgemeinen sagen sie im Unbewussten Folgendes: "In Java müssen Sie die Threads verbessern."  Was kann man verbessern?  Was sind Threads? </p><br><p>  Die Leute sind im Allgemeinen zu faul zum Nachdenken. </p><br><p>  Wie in einem Witz: <br>  Petka und Vasily Ivanovich fliegen in einem Flugzeug. <br>  Wassili Iwanowitsch fragt: - Petka, Geräte? <br>  Petka antwortet: - 200! <br>  Wassili Iwanowitsch: - Und was ist mit 200? <br>  Petka: - Was ist mit Geräten? </p><br><p>  Ich werde eine Geschichte erzählen.  Ich war diesen Frühling in der Ukraine, wir sind aus Weißrussland geflogen (Sie verstehen, warum es direkt aus St. Petersburg unmöglich ist).  Und beim Zoll saßen wir ungefähr zwei Stunden, nicht weniger.  Zollbeamte sind sehr nett, in aller Ernsthaftigkeit gefragt, ob Java eine veraltete Technologie ist.  In der Nähe saßen Leute, die zum selben Konf fliegen.  Und ich bin eine Art Redner, ich muss stechen, stehen und wie erwartet schamlos über Dinge sprechen, die ich überhaupt nicht benutze.  Und auf dem Weg sprach er über die JDK-Distribution namens Liberica, dies ist eine solche JDK für den Raspberry Pi. </p><br><p>  Und was denkst du?  Es vergehen nicht einmal sechs Monate, bis Leute auf meinen Wagen klopfen und sagen, dass wir in Liber eine Lösung für das Produkt gefunden haben, und ich habe bereits einen Bericht darüber in der belarussischen jfuture.by konf.  Dies ist der Ansatz.  Dies ist kein mieser Evangelist, sondern ein Typ, ein normaler Ingenieur. </p><br><blockquote>  Übrigens werden wir bald eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joker 2018-Konferenz haben</a> , an der sowohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Breslav</a> (der offensichtlich in Coroutinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stöbert</a> ) als auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pasha Finkelshtein</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Josh Long</a> nach Spring's Unterstützung für Loom gefragt werden.  Nun, und ein paar coole prominente Experten, komm schon! </blockquote><p>  Und jetzt zurück zu den Fäden.  Die Leute versuchen, einen Gedanken durch ihre degradierten zwei Neuronen zu ziehen, so einen gewundenen Rotz auf ihrer Faust, und murmeln: "In Java sind Threads nicht so, in Java sind Threads nicht so."  Geräte!  Welche Geräte?  Das ist im Allgemeinen die Hölle. </p><br><p>  Und hier kommt Presler, ein normaler, nicht erniedrigter Typ, und zuerst macht er eine vernünftige Beschreibung.  Ein Jahr später sägte ich eine funktionierende Demo.  Ich habe das alles gesagt, damit Sie verstehen, dass eine normale Beschreibung von Problemen, eine normale Dokumentation ein solcher Heldentum der besonderen Art ist.  Und die Demo ist im Allgemeinen Raum.  Dies ist die erste Person, die tatsächlich etwas in diese Richtung getan hat.  Er braucht am meisten. </p><br><p>  Zusammen mit der Demo sprach Presler auf der Konferenz und veröffentlichte dieses Video: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J31o0ZMQEnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  In der Tat ist dieser gesamte Artikel eine Überprüfung dessen, was dort gesagt wurde.  Ich behaupte überhaupt nicht für die Einzigartigkeit dieses Materials, alles, was in diesem Artikel steht, wurde von Ron erfunden. </p><br><p>  Die Diskussion handelt von drei schmerzhaften Themen: </p><br><ul><li>  Ansteckungen </li><li>  Fasern </li><li>  Schwanz ruft </li></ul><br><p>  Wahrscheinlich war er so krank, als er Quasar sägte und mit seinen Pannen kämpfte, dass es keine Kraft gibt - Sie müssen es in die Laufzeit schieben. </p><br><p>  Es war vor einem Jahr und seitdem sägen sie einen Prototyp.  Einige haben bereits die Hoffnung verloren, dass wir eines Tages eine Demo sehen werden, aber vor einem Monat haben sie sie geboren und gezeigt, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf diesem Tweet</a> sichtbar ist. </p><br><br><p><img src="https://habrastorage.org/webt/ck/hp/mc/ckhpmcchdv2k6_4vfbw733evg6c.png"><br><br></p><br><p>  Alle drei schmerzhaften Themen in dieser Demo sind entweder direkt im Code enthalten oder zumindest moralisch präsent.  Nun ja, sie haben Tail Calls noch nicht gemeistert, aber sie wollen. </p><br><h1 id="problematika">  Problem </h1><br><p>  Unglückliche Benutzer, Anwendungsentwickler, müssen bei der Erstellung einer API zwischen zwei Lehrstühlen wählen.  Auf einem Stuhl sind Spitzen eingebaut, auf dem anderen wachsen Blumen.  Und weder der eine noch der andere passt zu uns. </p><br><br><p><img src="https://habrastorage.org/webt/tn/nx/k-/tnnxk-iwzuj7sybfwllour9qozq.png"><br><br></p><br><p>  Wenn Sie beispielsweise einen Dienst schreiben, der synchron funktioniert, funktioniert er hervorragend mit Legacy-Code. Das Debuggen und Überwachen der Leistung ist einfach.  Probleme treten bei der Bandbreite und Skalierbarkeit auf.  Nur weil die Anzahl der Threads, die Sie jetzt auf einer einfachen Hardware ausführen können, auf Standardhardware - sagen wir mal zweitausend.  Dies ist viel weniger als die Anzahl der Verbindungen, die zu diesem Server geöffnet werden könnten.  Was aus Sicht des Netcodes nahezu endlos sein kann. </p><br><p>  (Nun ja, es hat etwas damit zu tun, dass die Sockets in Java schwachsinnig angeordnet sind, aber dies ist ein Thema für ein anderes Gespräch.) </p><br><p>  Stellen Sie sich vor, Sie schreiben eine Art MMO. </p><br><br><p><img src="https://habrastorage.org/webt/ye/mg/pm/yemgpm6on0pidozkhmco3epwapa.png"><br><br></p><br><p>  Während des Nordischen Krieges in EVE Online versammelten sich beispielsweise zweitausendvierhundert Piloten an einem Punkt im Weltraum. Jeder von ihnen - bedingt, wenn er in Java geschrieben wurde - wäre nicht ein Thread, sondern mehrere.  Und der Pilot ist natürlich eine komplexe Geschäftslogik und nicht die Ausgabe von HTML, das von Hand in einer Lupe ausgeschlossen werden kann. </p><br><p>  Die Reaktionszeit in diesem Kampf war so lang, dass der Spieler einige Minuten warten musste, um auf den Schuss zu warten.  Soweit ich weiß, warf die KPCh speziell für diesen Kampf die riesigen Hardwareressourcen ihres Clusters. </p><br><p>  Obwohl ich EVE wahrscheinlich vergeblich als Beispiel anführe, weil meines Wissens alles in Python geschrieben ist und in Python mit Multithreading immer noch schlechter als bei uns - und wir können eine schlechte Konkurrenz der Merkmale der Sprache in Betracht ziehen.  Aber dann ist das Beispiel klar und mit Bildern. </p><br><p>  Wenn Sie sich für das Thema IMO im Allgemeinen und die Geschichte des „Nordischen Krieges“ im Besonderen interessieren, ist kürzlich ein sehr gutes Video zu diesem Thema auf dem Bulzhat-Kanal erschienen (was auch immer dieser Name bedeutet), schauen Sie sich meinen Zeitstempel an. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AkAtiTNvjz8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wir kehren zum Thema zurück. </p><br><p>  Auf der anderen Seite können Sie eine Art asynchrones Framework verwenden.  Es ist skalierbar.  Aber wir werden sofort in ein sehr schwieriges Debugging geraten, ein kompliziertes Profiling der Performance, wir werden es nicht nahtlos in das Erbe integrieren können, Sie müssen viele Dinge neu schreiben, sie in abscheuliche Wrapper einwickeln und im Allgemeinen das Gefühl haben, nur vergewaltigt worden zu sein.  Mehrmals hintereinander.  Tatsächlich müssen Sie sich tagelang die ganze Zeit, in der wir dies schreiben, so fühlen. </p><br><p>  Ich habe den Experten, den berühmten Akademiker Escobar, gefragt, was er davon hält: </p><br><br><p><img width="300" src="https://habrastorage.org/webt/7g/hf/mg/7ghfmg3x8aqhdl0jcyrbpairqsc.png"><br><br></p><br><p>  Was tun?  Die sogenannten Fasern haben es eilig zu helfen. </p><br><p>  Im allgemeinen Fall sind Fasern solche leichten Fäden, die auch durch den Adressraum stöbern (weil Wunder nicht geschehen, verstehen Sie).  Im Gegensatz zu normalen Threads verwenden sie jedoch kein präemptives Multitasking, sondern kooperatives Multitasking.  Lesen Sie mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Wikipedia</a> . </p><br><p>  Fiber kann die Vorteile sowohl der synchronen als auch der asynchronen Programmierung nutzen.  Infolgedessen wird die Verwendung von Eisen erhöht, und wir verwenden weniger Server im Cluster für dieselbe Aufgabe.  Nun, in unserer Tasche dafür bekommen wir Lavendel.  Babos.  Lave.  Geld.  Nun, du verstehst, worum es geht.  Für den gespeicherten Server. </p><br><h1 id="na-raspute">  An der Kreuzung </h1><br><p>  Das erste, was ich diskutieren möchte.  Die Menschen verstehen den Unterschied zwischen Fortsetzungen und Faser nicht. <br>  Jetzt wird es eine Kult-Erleuchtung geben! </p><br><p>  Wir werden die Tatsache bekannt geben: Fortsetzung und Faser sind zwei verschiedene Dinge. </p><br><h1 id="continuations">  Fortsetzung </h1><br><p>  Die Fasern bauen auf einem Mechaniker namens Continuations auf. </p><br><p>  Fortsetzungen (genauer gesagt abgegrenzte Fortsetzungen) sind eine Art Berechnung, Ausführung, ein Teil eines Programms, das einschlafen, dann aufwachen und die Ausführung an dem Ort fortsetzen kann, an dem es eingeschlafen ist.  Es kann manchmal sogar geklont oder serialisiert werden, selbst wenn er schläft. </p><br><p>  Ich werde das Wort "Fortsetzung" verwenden und nicht "Fortsetzung" (wie es auf Wikipedia geschrieben steht), weil wir alle im <em>Rubel kommunizieren</em> .  Mit normaler russischer Terminologie kann man leicht zu einer Situation kommen, in der der Unterschied zwischen dem russischen und dem englischen Begriff zu groß wird und niemand sonst die Bedeutung des Gesagten versteht. </p><br><p>  Ich werde auch manchmal das Wort "Verdrängung" anstelle der englischen Version von "Ertrag" verwenden.  Nur das Wort "Ertrag" - es ist eine Art wirklich böse.  Daher wird es "Verdrängung" geben. </p><br><p>  Also.  Es ist sehr wichtig, dass es innerhalb des Kontinuums keinen Wettbewerb gibt.  Es an sich ist das minimale Primitiv dieses Prozesses. </p><br><p> Sie können sich Continuation als <code>Runnable</code> , in dem Sie die <code>pause()</code> -Methode aufrufen können.  Es ist innen und direkt, weil unser Multitasking kooperativ ist.  Und dann können Sie es erneut ausführen, und anstatt alles neu zu berechnen, fährt er dort fort, wo er aufgehört hat.  Diese Art von Magie.  Wir werden zur Magie zurückkehren. </p><br><p>  Wo Sie eine Demo mit Arbeitsfortsetzungen erhalten können, werden wir am Ende besprechen.  Sprechen wir jetzt darüber, was da ist. </p><br><p>  Die Fortsetzungsklasse selbst befindet sich in java.base, alle Links befinden sich in der Beschreibung.  ( <code>src/java.base/share/classes/java/lang/Continuation.java</code> ).  Aber diese Klasse ist sehr groß und umfangreich, daher ist es sinnvoll, nur eine Art Druck darauf zu betrachten. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope, Runnable body)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPinned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reason reason)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Pinned: "</span></span> + reason); } }</code> </pre> <br><p>  Beachten Sie, dass sich diese Datei ständig ändert.  Zum Beispiel hat die Fortsetzung am <code>Runnable</code> die <code>Runnable</code> Schnittstelle nicht implementiert.  Behandle dies als eine Art Skizze. </p><br><p>  Schauen Sie sich den Konstruktor an.  <code>body</code> - dies ist der Code, den Sie ausführen möchten, und <code>scope</code> - ist eine Art Skop, mit dem Sie Fortsetzungen in Fortsetzungen verschachteln können. </p><br><p>  Dementsprechend können Sie diesen Code entweder mit der <code>run</code> bis zum Ende vorplanen oder ihn mithilfe der <code>yield</code> Methode durch ein bestimmtes Array ersetzen (das Array wird hier für die Weiterleitung von Aktionen an verschachtelte Handler benötigt, ist uns aber als Benutzer egal).  Sie können mit der <code>isDone</code> Methode fragen, ob alles bis zum Ende abgeschlossen ist. </p><br><p>  Und aus Gründen, die ausschließlich von den Anforderungen der aktuellen Implementierung abhängen (aber höchstwahrscheinlich auch in der Version enthalten sein werden), ist es nicht immer möglich, eine <code>yield</code> zu <code>yield</code> .  Wenn wir beispielsweise innerhalb der Fortsetzung einen Übergang zum nativen Code hatten und ein nativer Frame auf dem Stapel erschien, ist es unmöglich, stecken zu bleiben.  Dies ist auch der Fall, wenn Sie versuchen, herausgedrückt zu werden, während ein nativer Monitor, z. B. eine synchronisierte Methode, in den Körper des Kontinuums aufgenommen wird.  Wenn Sie versuchen, dies zu fälschen, wird standardmäßig eine Ausnahme ausgelöst ... aber die auf den Fortsetzungen aufgebauten Fasern überladen diese Methode und führen etwas anderes aus.  Dies wird etwas später sein. </p><br><p>  Sie können dies ungefähr folgendermaßen verwenden: </p><br><pre> <code class="java hljs">Continuation cont = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(SCOPE, () -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>); Continuation.yield(SCOPE); System.out.println(<span class="hljs-string"><span class="hljs-string">"after"</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cont.isDone()) { cont.run(); }</code> </pre> <br><p>  Dies ist ein Beispiel aus Preslers Präsentation.  Auch dies ist kein "trivialer" Code, sondern eine Art Skizze. </p><br><p>  Dies ist eine Skizze dessen, was wir fortsetzen. In der Mitte dieser Fortsetzung sind wir verdrängt und dann fragen wir in einem endlosen Zyklus, ob die Fortsetzung bis zum Ende funktioniert hat und ob sie fortgesetzt werden sollte. </p><br><p>  Im Allgemeinen ist jedoch nicht beabsichtigt, dass sich gewöhnliche Anwendungsprogrammierer auf diese API beziehen.  Es richtet sich an Entwickler von System-Frameworks.  Systembildende Frameworks wie das Spring Framework werden diese Funktion sofort übernehmen, sobald sie herauskommt.  Du wirst sehen.  Betrachten Sie dies als Vorhersage.  Eine solche Lichtvorhersage, weil hier alles ziemlich offensichtlich ist.  Alle Daten zur Vorhersage sind.  Diese Funktion ist zu wichtig, um sie nicht anzupassen.  Daher müssen Sie sich nicht im Voraus Sorgen machen, dass Sie jemand mit einer Kodierung in dieser Form quält.  Wenn Sie ein Spring-Entwickler sind, wissen Sie, was Sie tun. </p><br><p>  Und jetzt werden zusätzlich zu den Fortsetzungen Fasern gebaut. </p><br><h1 id="fibers">  Fasern </h1><br><p>  Also, was in unserem Fall Faser bedeutet. <br><br>  Dies ist eine Art Abstraktion, die ist: </p><br><ul><li>  Leichte Threads, die in der JVM selbst und nicht im Betriebssystem verarbeitet werden. </li><li>  Mit extrem geringem Overhead zum Erstellen, Aufrechterhalten des Lebens und Wechseln von Aufgaben; </li><li>  Welches kann millionenfach ausgeführt werden. </li></ul><br><p>  Viele Technologien versuchen auf die eine oder andere Weise, Fasern herzustellen.  In Kotlin gibt es beispielsweise Coroutinen, die für eine sehr intelligente Bytecode-Generierung implementiert sind.  <em>Sehr intelligent</em> .  Aber Laufzeit ist ein besserer Ort, um solche Dinge zu implementieren. </p><br><p>  Zumindest weiß die JVM bereits, wie man gut mit Threads umgeht, und wir müssen lediglich den Codierungsprozess für Multithreading optimieren.  Sie können asynchrone APIs verwenden, dies kann jedoch kaum als „Vereinfachung“ bezeichnet werden: Selbst die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactor</a> und Spring Project Reactor, mit denen scheinbar linearer Code geschrieben werden kann, hilft nicht viel, wenn Sie komplexe Probleme beheben müssen. </p><br><p>  Also Faser. </p><br><p>  Faser besteht aus zwei Komponenten.  Das: </p><br><ul><li>  Fortsetzung </li><li>  Scheduler </li></ul><br><p>  Also: </p><br><ul><li>  Fortsetzung </li><li>  Planer </li></ul><br><br><p><img src="https://habrastorage.org/webt/ga/wc/yk/gawcykupqgqwqjwfxcpccyltenu.jpeg"><br><br></p><br><p>  Sie können entscheiden, wer der Planer hier ist.  Ich denke, der Planer hier ist Jay. </p><br><ul><li>  Fibre umschließt den Code, den Sie ausführen möchten, in einer Fortsetzung </li><li>  Scheduler startet sie in einem Pool von Carrier-Threads </li></ul><br><p>  <em>Ich werde sie Trägerfäden nennen.</em> </p><br><br><br><p><img src="https://habrastorage.org/webt/j4/hc/gw/j4hcgwglzzsi6qe-cxczwcewohy.jpeg"><br><br></p><br><p>  Der aktuelle Prototyp verwendet <code>java.util.concurrent.Executor</code> und der integrierte Scheduler <code>ForkJoinPool</code> .  Wir haben alles.  In Zukunft mag dort etwas Klügeres auftauchen, aber vorerst so. </p><br><p>  Wie verhält sich die Fortsetzung: </p><br><ul><li>  Es ist verdrängt (Ausbeute), wenn eine Sperre auftritt (z. B. bei E / A). </li><li>  Wird fortgesetzt, wenn Sie fortfahren möchten (z. B. ist der E / A-Vorgang abgeschlossen und Sie können fortfahren). </li></ul><br><p>  Aktueller Stand der Arbeiten: </p><br><ul><li>  Der Schwerpunkt liegt auf Philosophie, Konzepten; </li><li>  Die API ist nicht festgelegt, sondern "for show".  Dies ist ein Forschungsprototyp; </li><li>  Es gibt einen vorgefertigten codierten Arbeitsprototyp der Klasse <code>java.lang.Fiber</code> . </li></ul><br><p>  Es wird diskutiert. </p><br><p>  Was wurde bereits in die Faser gesägt: </p><br><ul><li>  Es wird ein Taskstart ausgeführt. </li><li>  Parkplatz parken auf einem Träger; </li><li>  Warten auf die Fertigstellung der Faser. </li></ul><br><h1 id="principialnaya-shema">  Schaltplan </h1><br><pre> <code class="java hljs">mount(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cont.run(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> () { unmount(); }</code> </pre> <br><ul><li>  Wir können eine Faser auf einen Fadenträger montieren; </li><li>  Führen Sie dann die Fortsetzung aus. </li><li>  Und warten Sie, bis sie überfüllt ist oder ehrlich aufhört; </li><li>  Am Ende verlassen wir immer den Thread. </li></ul><br><p>  Dieser Pseudocode wird auf dem <code>ForkJoinPool</code> oder auf einem anderen (der möglicherweise in der endgültigen Version enthalten sein wird) ausgeführt. </p><br><h1 id="ispolzovanie-v-realnosti">  Verwendung in der Realität </h1><br><pre> <code class="java hljs">Fiber f = Fiber.execute( () -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Morning!"</span></span>); readLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Afternoon"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { readLock.unlock(); } System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Night"</span></span>); });</code> </pre> <br><p>  Schauen Sie, wir schaffen eine Faser, in der: </p><br><ul><li>  begrüße alle; </li><li>  wir blockieren auf wiedereintrittsfähigem loke; </li><li>  Herzlichen Glückwunsch zu Ihrem Mittagessen. </li><li>  Lassen Sie endlich das Schloss los. </li><li>  und auf Wiedersehen sagen. </li></ul><br><p>  Alles ist sehr einfach. </p><br><p>  Wir verursachen kein direktes Gedränge.  Project Loom selbst weiß, dass <code>readLock.lock();</code> ausgelöst wird <code>readLock.lock();</code>  er sollte eingreifen und implizit Unterdrückung tun.  Der Benutzer sieht dies nicht, aber es passiert dort. </p><br><h1 id="steki-povsyudu-steki">  Stapel, Stapel überall! </h1><br><p>  Lassen Sie uns am Beispiel des Pizzastapels demonstrieren, was passiert. </p><br><p>  Zu Beginn befindet sich der Träger-Thread in einem Wartezustand und es passiert nichts. </p><br><p><img src="https://habrastorage.org/webt/8y/gw/mr/8ygwmr7dc_owazfdj-wa4trrs4g.png"><br><br></p><br><p>  Oben auf dem Stapel oben, erinnern Sie sich. </p><br><p>  Dann wurde die Ausführung der Glasfaser geplant, und die Glasfaseraufgabe wurde ausgeführt. </p><br><p><img src="https://habrastorage.org/webt/pd/ya/mn/pdyamn0chhcnelgtphtxeg6eniq.png"><br><br></p><br><p>  In sich selbst startet er offensichtlich eine Fortsetzung, in der sich der eigentliche Code bereits befindet. </p><br><p><img src="https://habrastorage.org/webt/33/nw/fb/33nwfb3dz0klj1oiog21iegsbuy.png"><br><br></p><br><p>  Aus Sicht des Anwenders haben wir hier noch nichts gestartet. </p><br><p>  Dies ist nur der erste Frame des Benutzercodes, der auf dem Stapel angezeigt wird, und er ist lila markiert. </p><br><p>  Ferner wird der Code ausgeführt, ausgeführt, irgendwann versucht die Aufgabe, die Sperre zu erfassen und zu blockieren, was zu einer automatischen Verdrängung führt. </p><br><p><img src="https://habrastorage.org/webt/vv/lk/ah/vvlkahftvyuefpupb4fyidb5gdq.png"><br><br></p><br><p>  Alles, was sich auf dem Fortsetzungsstapel befindet, wird an einem bestimmten magischen Ort gespeichert.  Und verschwindet. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  Wie Sie sehen können, kehrt der Stream zur Faser zurück, zu der Anweisung, die auf <code>Continuation.run</code> folgt.  Und das ist das Ende des Glasfasercodes. </p><br><p>  Die Glasfaseraufgabe endet, der Medienträger wartet auf einen neuen Auftrag. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  Faser ist geparkt, irgendwo liegt, das Kontinuum ist völlig verdrängt. </p><br><p>  Früher oder später kommt der Moment, in dem derjenige, dem das Schloss gehört, es freigibt. <br>  Dies führt dazu, dass die Faser, die auf die Freigabe des Schlosses gewartet hat, ausgepackt wird.  Die Aufgabe dieser Faser beginnt von vorne. </p><br><ul><li>  Reentrantlock.unlock </li><li>  Locksupport.unpark </li><li>  Fiber.unpark </li><li>  ForkJoinPool.execute </li></ul><br><p>  Und wir kehren schnell zum Stapel zurück, der vor kurzem war. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  Darüber hinaus kann das Trägergewinde völlig unterschiedlich sein.  Und das macht Sinn! </p><br><p>  Führen Sie die Fortsetzung erneut aus. </p><br><p><img src="https://habrastorage.org/webt/ll/c-/mx/llc-mxgfttlpleiqtprwm6igcju.png"><br><br></p><br><p>  Und hier kommt die MAGIE !!!  Der Stapel wird wiederhergestellt und die Ausführung mit der Anweisung nach <code>Continuation.yield</code> fortgesetzt. </p><br><p><img src="https://habrastorage.org/webt/la/4t/pp/la4tppjy2spiy4_auvwdikgm8nu.png"><br><br></p><br><p>  Wir kriechen aus dem gerade geparkten Schloss und beginnen mit der Ausführung des gesamten in der Fortsetzung verbleibenden Codes: </p><br><p><img src="https://habrastorage.org/webt/yt/ce/ht/ytcehtff1fomwn5cehnzkegzpts.png"><br><br></p><br><p>  Die Benutzeraufgabe wird beendet, und die Steuerung kehrt unmittelbar nach der Anweisung continue.run zur Glasfaseraufgabe zurück </p><br><p><img src="https://habrastorage.org/webt/sz/m8/cc/szm8ccxgwntcgjzwqcl_gcernqg.png"><br><br></p><br><p>  Gleichzeitig endet die Ausführung der Faser und wir befinden uns wieder im Standby-Modus. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  Der nächste Start der Faser leitet erneut den gesamten oben beschriebenen Wiedergeburtszyklus ein. </p><br><p><img src="https://habrastorage.org/webt/c7/z9/wm/c7z9wmktfbsithnlvyuea4mtqki.jpeg"><br><br></p><br><h1 id="zhivye-primery">  Live-Beispiele </h1><br><p>  Und wer hat jemals gesagt, dass das alles funktioniert?  Geht es um ein paar Mikrobenchmarks, die über den Abend geschrieben wurden? </p><br><p>  Als Beispiel für den Betrieb der Feuerwerkskörper schrieben die Orakloviten einen kleinen Webserver und versorgten ihn mit Anfragen, damit er erstickte.  Dann wurden sie auf Faser übertragen.  Der Server hat aufgehört zu würgen, und daraus haben wir geschlossen, dass die Fasern funktionieren. </p><br><p>  Ich habe nicht den genauen Code für diesen Server, aber wenn dieser Beitrag genügend Likes und Kommentare enthält, werde ich versuchen, selbst ein Beispiel zu schreiben und echte Grafiken zu erstellen. </p><br><h1 id="problemy">  Die Probleme </h1><br><p>  Gibt es hier irgendwelche Probleme?  Ja natürlich!  Die ganze Geschichte mit Faybers ist eine Geschichte über ständige Probleme und Kompromisse. </p><br><h2 id="filosofskie-problemy">  Philosophische Probleme </h2><br><ul><li>  Müssen wir Threads neu erfinden? </li><li>  Sollte der <em>gesamte</em> vorhandene Code in der Glasfaser ordnungsgemäß funktionieren? </li></ul><br><p>  Der aktuelle Prototyp läuft mit Einschränkungen.  Welches kann in die Veröffentlichung gehen, obwohl ich nicht möchte.  Trotzdem ist OpenJDK eine Sache, die endlose Kompatibilität respektiert. </p><br><p>  Was sind die technischen Einschränkungen?  Die offensichtlichsten Einschränkungen sind 2 Stück. </p><br><h2 id="problema-raz--nelzya-vytesnit-nativnye-freymy">  Das Problem ist einmal - Sie können native Frames nicht ersetzen </h2><br><pre> <code class="java hljs">PrivilegedAction&lt;Void&gt; pa = () -&gt; { readLock.lock(); <span class="hljs-comment"><span class="hljs-comment">// may park/yield try { // } finally { readLock.unlock(); } return null; } AccessController.doPrivileged(pa); //native method</span></span></code> </pre> <br><p>  Hier ruft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doPrivileged</a> die native Methode auf. </p><br><p>  Sie rufen <code>doPrivileged</code> , springen aus der VM heraus, ein nativer Frame wird auf Ihrem Stapel angezeigt, und danach versuchen Sie, in der <code>readLock.lock()</code> zu parken.  In diesem Moment wird der Trägerfaden gefärbt, bis er nicht mehr ausgewählt wird.  Das heißt, der Thread verschwindet.  In diesem Fall können die Trägerfäden enden, und im Allgemeinen bricht dies die gesamte Idee der Faser. </p><br><p>  Der Weg, dies zu lösen, ist bereits bekannt, und darüber wird derzeit diskutiert. </p><br><h2 id="problema-dva---synchronized-bloki">  Problem zwei - synchronisierte Blöcke </h2><br><p>  Das ist viel ernsterer Müll </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park object.wait(); //may park }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park socket.getInputStream().read(); //may park }</span></span></code> </pre> <br><p>  Im Falle einer Monitorerfassung in der Faser treten auch die Trägerfäden. </p><br><p>  Es ist klar, dass Sie in einem völlig neuen Code Monitore in direkte Sperren ändern können, anstatt zu warten + zu benachrichtigen, dass Sie Bedingungsobjekte verwenden können, aber was tun mit Legacy?  Das ist ein Problem. </p><br><h1 id="thread-api-threadcurrentthread-thread-locals">  Thread-API?  Thread.currentThread ()?  Einheimische einfädeln? </h1><br><p>  Im aktuellen Prototyp haben <code>Thread</code> und <code>Fiber</code> eine gemeinsame Superklasse namens <code>Strand</code> . </p><br><p>  Auf diese Weise können Sie die API auf minimalste Weise übertragen. <br>  Was als nächstes zu tun ist - wie immer in diesem Projekt - ist eine Frage. </p><br><p>  Was passiert jetzt mit der Thread-API? </p><br><ul><li>  Die erste Verwendung von <code>Thread.currentThread()</code> in einer Faser erzeugt eine Art Schatten-Thread, Shadow Thread; </li><li>  Aus Sicht des Systems handelt es sich um einen "unveröffentlichten" Thread, in dem keine VM-Metainformationen enthalten sind. </li><li>  ST versucht alles zu emulieren, was es kann; </li><li>  Aber Sie müssen verstehen, dass die alte API viel Müll enthält. </li><li>  Insbesondere implementiert Shadow Thread die Thread-API für alles außer <code>stop</code> , <code>stop</code> , <code>resume</code> und Behandeln nicht erfasster Ausnahmen. </li></ul><br><p>  Was tun mit Thread-Einheimischen? </p><br><ul><li>  Jetzt verwandeln sich Thread-Einheimische einfach in Faser-Einheimische. </li><li>  Es gibt viele Probleme damit, all dies wird diskutiert; </li><li>  Eine Reihe von Verwendungen wird besonders diskutiert. </li><li>  Threads wurden in der Vergangenheit sowohl korrekt als auch falsch verwendet (diejenigen, die falsch verwenden, hoffen immer noch auf etwas, und Sie können sie nicht vollständig enttäuschen). </li><li>  Dies schafft im Allgemeinen eine ganze Reihe von Anwendungen: <br><ul><li>  Übergeordnet: Cache von Verbindungen oder Passwörtern im Container; </li><li>  Low-Level: Prozessor in Systembibliotheken. </li></ul></li></ul><br><h1 id="skolko-vse-eto-zhret">  Wie viel isst das alles? </h1><br><p><img src="https://habrastorage.org/webt/pl/7-/pi/pl7-pidz-d2o3l98qx2srbmezxi.png"><br><br></p><br><p>  Thread: </p><br><ul><li>  Stack: 1 MB und 16 KB auf Kernel-Datenstrukturen; </li><li>  Pro Thread-Instanz: 2300 Byte, einschließlich VM-Metainformationen. </li></ul><br><p>  Faser: </p><br><ul><li>  Fortsetzungsstapel: von Hunderten von Bytes bis Kilobyte; </li><li>  Pro Faserinstanz: 200-240 Bytes. </li></ul><br><p>  Der Unterschied ist riesig! <br>  Und genau das lässt Millionen von Menschen aufflammen. </p><br><h1 id="chto-mozhet-parkovatsya">  Was kann parken </h1><br><p>  Es ist klar, dass das Magischste das automatische Parken ist, wenn einige Ereignisse eintreten.  Was wird aktuell unterstützt? </p><br><ul><li>  Thread.sleep, join; </li><li>  java.util.concurrent und LockSupport.lock; </li><li>  E / A: Netzwerk auf Sockets (Socket lesen, schreiben, verbinden, akzeptieren), Dateien, Pipes; </li><li>  All dies ist unvollendet, aber das Licht im Tunnel ist sichtbar. </li></ul><br><h1 id="kommunikaciya-mezhdu-fayberami">  Kommunikation zwischen Glasfaser </h1><br><p>  Eine andere Frage, die sich jeder stellt, ist: Wie kann man Informationen zwischen Fasern wettbewerbsfähig austauschen? </p><br><ul><li>  Der aktuelle Prototyp startet Aufgaben in <code>Runnable</code> und kann bei Bedarf in <code>CompletableFuture</code> konvertiert werden. </li><li>  java.util.concurrent "funktioniert einfach."  Sie können alles auf normale Weise fummeln; </li><li>  Möglicherweise gibt es neue APIs für Multithreading, dies ist jedoch nicht korrekt. </li><li>  eine Reihe kleiner Fragen wie „Sollten Fasern Werte zurückgeben?“;  Alles wird besprochen, sie sind nicht im Prototyp. </li></ul><br><h1 id="kak-realizovany-kontinuacii-v-prototipe">  Wie werden Fortsetzungen im Prototyp implementiert? </h1><br><p>  Offensichtliche Anforderungen werden an die Fortsetzung gestellt: Sie müssen so wenig RAM wie möglich verwenden und so schnell wie möglich zwischen ihnen wechseln.  Andernfalls wird es nicht funktionieren, sie in Millionenhöhe zu halten.  Die Hauptaufgabe hier ist irgendwie, nicht für jeden Park-Uppark eine vollständige Kopie des Stapels zu erstellen.  Und es gibt so ein Schema!  Versuchen wir dies auf den Bildern zu erklären. </p><br><p>  Der coolste Weg wäre natürlich, einfach alle Stapel auf eine Java-Hüfte zu legen und sie direkt zu verwenden.  Es ist jedoch nicht klar, wie jetzt codiert werden soll, daher verwendet der Prototyp das Kopieren.  Aber mit einem kleinen, aber wichtigen Hack kopieren. </p><br><p>  Wir haben zwei Stühle ... ich meine, zwei Stapel.  Zwei Java-Arrays in der Hüfte.  Eines ist ein Objektarray, in dem Verweise auf Objekte gespeichert werden.  Das zweite ist primitiv (zum Beispiel intim), das alles andere erledigt. </p><br><p><img src="https://habrastorage.org/webt/33/tf/cj/33tfcj897awloqfisxfwwl-4ypy.png"><br><br></p><br><p>  Jetzt befinden wir uns in einem Zustand, in dem die Fortsetzung zum ersten Mal durchgeführt werden soll. </p><br><p>  <code>run</code> ruft eine interne Methode namens <code>enter</code> : </p><br><p><img src="https://habrastorage.org/webt/j6/d5/ki/j6d5kioz8ygupanxditl3iaslbi.png"><br><br></p><br><p>  Und dann wird der Benutzercode bis zur ersten Verdrängung ausgeführt. </p><br><p><img src="https://habrastorage.org/webt/ab/on/6c/abon6cdsoepe-ts69pkmm9sk35i.png"><br><br></p><br><p>  Zu diesem Zeitpunkt wird ein VM-Aufruf ausgeführt, der das <code>freeze</code> Anrufen ermöglicht.  In diesem Prototyp erfolgt dies direkt physisch - mithilfe der Kopie. </p><br><p><img src="https://habrastorage.org/webt/iu/or/jv/iuorjvmb6xrjnycvx3nxbdcqxxc.png"><br><br></p><br><p>  Wir beginnen mit dem sequentiellen Kopieren von Frames vom nativen Stack nach Java Hip. </p><br><p><img src="https://habrastorage.org/webt/ln/nu/sm/lnnusmrix2hsqpwxmzkeemd_or0.png"><br><br></p><br><p>  Es muss überprüft werden, ob die Monitore dort gehalten werden oder der native Code verwendet wird oder etwas anderes, das es uns wirklich nicht erlaubt, weiter zu arbeiten. </p><br><p><img src="https://habrastorage.org/webt/vl/5c/k0/vl5ck0i3jtouapded9snnl9brvy.png"><br><br></p><br><p>  Und wenn alles in Ordnung ist, kopieren wir zuerst in ein primitives Array: </p><br><p><img src="https://habrastorage.org/webt/ka/z_/gl/kaz_glkmthfyd1x8rzdprn3v8ym.png"><br><br></p><br><p>  Dann isolieren wir die Verweise auf die Objekte und speichern sie im Objektarray: </p><br><p><img src="https://habrastorage.org/webt/xc/2q/nb/xc2qnbafy_2eybwzif-3s3vmaym.png"><br><br></p><br><p>  Eigentlich zwei Tees an alle, die an diesem Ort lesen! </p><br><p>  Weiter setzen wir diese Prozedur für alle anderen Elemente des nativen Stapels fort. </p><br><p><img src="https://habrastorage.org/webt/6e/sp/-0/6esp-07i4dyasxj5esb9qu6fh5i.png"><br><br></p><br><p>  Hurra!  Wir haben alles in Hüfte ins Nest kopiert.  Sie können sicher zum Ort des Anrufs springen, ohne befürchten zu müssen, dass wir etwas verloren haben.  Alles ist hip. </p><br><p><img src="https://habrastorage.org/webt/bq/sz/ju/bqszjuffw-s4f14audafvzbmqzc.png"><br><br></p><br><p>  Früher oder später ruft der aufrufende Code unsere Fortsetzung erneut auf.  Und sie muss von dem Ort aus weitermachen, an dem sie das letzte Mal zurückgelassen wurde.  Das ist unsere Aufgabe. </p><br><p><img src="https://habrastorage.org/webt/8i/bg/x9/8ibgx9r_26wedxrahar1vfqdifi.png"><br><br></p><br><p>  Wenn Sie überprüfen, ob die Fortsetzung ausgeführt wurde, wird "Ja" angezeigt.  Sie müssen also VM aufrufen, Speicherplatz auf dem Stapel bereinigen und die interne <code>thaw</code> VM-Funktion aufrufen.  "Tauwetter" wird ins Russische übersetzt als "Tauwetter", "Auftauen", was ziemlich logisch klingt.  Es ist notwendig, Frames vom Fortsetzungsstapel in unseren nativen Hauptstapel zu entfernen. </p><br><p>  Ich bin mir nicht sicher, ob das Auftauen von Tee ganz klar ist.  Schlechte Abstraktion ist wie ein Kätzchen mit einer Tür.  Aber das wird für uns reichen. </p><br><p><img src="https://habrastorage.org/webt/ra/sv/5v/rasv5v_5w8_dpegomn_omgtdiza.png"><br><br></p><br><p>  Wir machen ganz offensichtliche Kopien. </p><br><p>  Zuerst mit einem primitiven Array: </p><br><p><img src="https://habrastorage.org/webt/wc/he/vg/wchevg-fsflrnicy0itprkp0q2e.png"><br><br></p><br><p>  Dann vom Link: </p><br><p><img src="https://habrastorage.org/webt/o_/o2/6s/o_o26sakm0n5hyq9wisbo7vouge.png"><br><br></p><br><p>  Sie müssen das Kopierte ein wenig patchen, um den richtigen Stapel zu erhalten: </p><br><p><img src="https://habrastorage.org/webt/sm/h7/0n/smh70naepp3kshxaa78zxv1g2du.png"><br><br></p><br><p>  Wiederholen Sie Obszönität für alle Frames: </p><br><p><img src="https://habrastorage.org/webt/cg/dv/61/cgdv617uqeriqmuqcyc2jkjpnbe.png"><br><br></p><br><p>  Jetzt können Sie zurückkehren, um <code>yield</code> und fortzufahren, als wäre nichts passiert. </p><br><p><img src="https://habrastorage.org/webt/gn/dd/xw/gnddxwqqsrwuidc9ev2nxwmiwqc.png"><br><br></p><br><p>  Das Problem ist, dass eine vollständige Kopie des Stapels überhaupt nicht das ist, was wir gerne hätten.  Es ist sehr hemmend.  All dies ist die Isolierung von Links, die Überprüfung auf Pinning, es ist nicht schnell.  Und vor allem - all dies hängt linear von der Größe des Stapels ab!  Mit einem Wort, Hölle.  Keine Notwendigkeit, dies zu tun. </p><br><p>  Stattdessen haben wir eine andere Idee - faules Kopieren. </p><br><p>  Lassen Sie uns zu dem Ort zurückkehren, an dem wir bereits eine eingefrorene Fortsetzung haben. </p><br><p><img src="https://habrastorage.org/webt/5b/hw/tg/5bhwtgg8cfg-agcwu_kdtrqlify.png"><br><br></p><br><p>  Wir setzen den Prozess wie bisher fort: </p><br><p><img src="https://habrastorage.org/webt/rj/ac/f9/rjacf9tmfekskko8jwojuocxixm.png"><br><br></p><br><p>  Auf die gleiche Weise wie zuvor bereinigen wir den Platz auf dem nativen Stapel: </p><br><p><img src="https://habrastorage.org/webt/nm/ol/ow/nmolowac-dkmdefuobd-kaijyeq.png"><br><br></p><br><p>  Wir kopieren jedoch nicht alles hintereinander, sondern nur einen oder mehrere Frames: </p><br><p><img src="https://habrastorage.org/webt/3a/ca/1x/3aca1xglgfbq8yzwxkjypelxpqy.png"><br><br></p><br><p>  Nun der Hack.  Sie müssen die Rücksprungadresse von Methode <code>C</code> so patchen, dass sie auf eine bestimmte Rückgabesperre verweist: </p><br><p><img src="https://habrastorage.org/webt/zs/si/3z/zssi3zgaadvvsrg883agxsmq3pc.png"><br><br></p><br><p>  Jetzt können Sie sicher zurückkehren, um <code>yield</code> : </p><br><p><img src="https://habrastorage.org/webt/e1/f_/2s/e1f_2snf4bh-ggjcv5lrgabqkwk.png"><br><br></p><br><p>  Was wiederum zu einem Aufruf des Benutzercodes in der <code>C</code> Methode führt: </p><br><p><img src="https://habrastorage.org/webt/y2/nl/rm/y2nlrmn9lczwhcaa3f41ii69nq0.png"><br><br></p><br><p>  Stellen Sie sich nun vor, <code>C</code> möchte zu dem Code zurückkehren, der ihn aufgerufen hat.  Aber sein Beschwörer ist <code>B</code> und er ist nicht auf dem Stapel!  Wenn er versucht zurückzukehren, geht er daher zur Absenderadresse, und diese Adresse ist jetzt die Rückgabesperre.  Und Sie wissen, dies wird wieder einen <code>thaw</code> auslösen: </p><br><p><img src="https://habrastorage.org/webt/hb/6g/8d/hb6g8dfw35ujqntvi-y7lzyskis.png"><br><br></p><br><p>  Und das <code>thaw</code> wird den nächsten Frame auf dem Fortsetzungsstapel <code>thaw</code> , und dies ist <code>B</code> : </p><br><p><img src="https://habrastorage.org/webt/cp/mp/ao/cpmpao3_arvnvgykenc9r4fgwsk.png"><br><br></p><br><p>  Tatsächlich haben wir es auf Anfrage faul kopiert. </p><br><p>  Als nächstes lassen wir <code>B</code> vom Fortsetzungsstapel fallen und setzen die Barriere erneut (die Barriere muss gesetzt werden, da noch etwas auf dem Fortsetzungsstapel übrig ist).  Und so weiter und so fort. </p><br><p><img src="https://habrastorage.org/webt/gv/yo/0u/gvyo0u4iwzunuqovy1yv_-jbutq.png"><br><br></p><br><p>  Angenommen, <code>B</code> kehrt nicht zum aufrufenden Code zurück, sondern ruft zuerst eine andere Methode <code>D</code>  Und diese neue Methode will auch verdrängt werden. </p><br><p><img src="https://habrastorage.org/webt/f9/1i/t9/f91it9xn705zsxuzvvbqh5gdoqi.png"><br><br></p><br><p>  In diesem Fall müssen wir zum <code>freeze</code> nur die Oberseite des nativen Stapels auf den Fortsetzungsstapel kopieren: </p><br><p><img src="https://habrastorage.org/webt/pt/8b/ul/pt8buljt77lsp-wj-rswobc4v_y.png"><br><br></p><br><p>  Somit hängt der Arbeitsaufwand nicht linear von der Größe des Stapels ab.  Es hängt linear nur von der Anzahl der Frames ab, die wir tatsächlich in der Arbeit verwendet haben. </p><br><h1 id="chto-ostalos">  Was bleibt übrig? </h1><br><p>  Entwickler berücksichtigen einige Funktionen, sind jedoch nicht auf den Prototyp gekommen. </p><br><ul><li>  Serialisierung und Klonen.  Die Möglichkeit, auf einem anderen Computer, zu einem anderen Zeitpunkt usw. fortzufahren. </li><li>  JVM TI und Debugging, als wären sie reguläre Threads.  Wenn Sie beim Lesen des Sockets blockiert sind, sehen Sie keinen schönen Sprung von der Ausbeute. Im Prototyp wird der Thread einfach blockiert, wie bei jedem anderen normalen Thread. </li><li>  Die Schwanzrekursion wurde nicht einmal berührt. </li></ul><br><p>  Nächste Schritte: </p><br><ul><li>  Erstellen Sie eine menschliche API. </li><li>  Fügen Sie alle fehlenden Funktionen hinzu. </li><li>  Leistung verbessern. </li></ul><br><h1 id="gde-vzyat">  Wo zu bekommen </h1><br><p>  Der Prototyp wird als Brunch im OpenJDK-Repository erstellt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie können den Prototyp hier herunterladen,</a> indem Sie zu den Brunchfasern wechseln. </p><br><p>  Es wird so gemacht: </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://hg.openjdk.java.net/loom/loom $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> loom $ hg update -r fibers $ sh configure $ make images</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie wissen, wird all dies die Montage des ganzen verdammten OpenJDK starten. </font><font style="vertical-align: inherit;">Daher muss erstens die nächste halbe Stunde Ihres Lebens etwas anderes tun, während all dies geschehen wird.</font></font></p><br><p><img src="https://habrastorage.org/webt/gk/qz/3-/gkqz3-f8gmkcwkynnnrp4opp1rg.png"><br><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens benötigen Sie einen normal konfigurierten Computer mit einer C ++ - Toolchain und GNU-Bibliotheken. </font><font style="vertical-align: inherit;">Ich weise darauf hin, dass es nicht empfohlen wird, dies unter Windows zu tun. </font><font style="vertical-align: inherit;">Im Ernst, selbst wenn Sie VirtualBox herunterladen und dort ein neues Ubuntu installieren, verbringen Sie Größenordnungen weniger Zeit als beim Versuch, einen weiteren unmenschlichen Fehler beim Erstellen von Cygwin oder msys64 zu erkennen. </font><font style="vertical-align: inherit;">Hier kommt msys noch schlimmer ins Spiel als Cygwin.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies natürlich alles eine Lüge ist, habe ich es einfach satt, Ihnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montageanleitungen zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben </font><font style="vertical-align: inherit;">.</font></font></p><br><p>   -   ,   mercurial extension   fsmonitor. ,   ,   <code>hg help -e fsmonitor</code> . <br>      ~/.hgrc  : </p><br><pre> <code class="plaintext hljs">[fsmonitor] mode = on</code> </pre> <br><p>  -           .             -, <code>cp -R ./loom ./loom-backup</code> . </p><br><p>  ,          . ,   Java-    ,       . </p><br><p> <code>sh configure</code>    - . ,     Ubuntu,     Autoconf ( <code>sudo apt-get install autoconf</code> ).  —     OpenJDK   Ubuntu,     ,  .  Windows      ,   . </p><br><p> ,     ,   <code>hg diff --stat -r default:fibers</code> . </p><br><p>  ,          ,   ,     . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>      «, ».   «», . «Loom» —  « ».  Project Loom         . </p><br><p>          ,        . ,      «»  ,  ,      —  , ,  , —  . </p><br><p> ,   ,          XIX    ,        . </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/64e/143/30564e14316852dd18d4235b3850e134.jpg"><br><p>      . -,  . </p><br><p> ,                 .        IDE   . </p><br><p>          ,       ,   ,    « », «», « »   . </p><br><p>       ?   .   . </p><br><p>  Vielen Dank. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422519/">https://habr.com/ru/post/de422519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422509/index.html">Zusammenfassung des Buches "Never Eat Alone"</a></li>
<li><a href="../de422511/index.html">Laden von Daten in Splunk: Universal Forwarder vs Heavy Forwarder. Was ist der Unterschied?</a></li>
<li><a href="../de422513/index.html">7 Tipps, wie Sie einen Testerkollegen im Urlaub nicht verärgern können</a></li>
<li><a href="../de422515/index.html">Zwei Apache Ignite Mitaps und In-Memory Computing Webinar im September</a></li>
<li><a href="../de422517/index.html">TelegramBot in der Wolfram Cloud</a></li>
<li><a href="../de422521/index.html">Vorahnung des Unvermeidlichen</a></li>
<li><a href="../de422525/index.html">"Die Matrix der Freundschaft." Der älteste soziale Graph für den kleinsten</a></li>
<li><a href="../de422527/index.html">PostgreSQL News Digest. Ausgabe 10</a></li>
<li><a href="../de422529/index.html">Group-IB-Spezialkurs: „Sicherheit mobiler Anwendungen“</a></li>
<li><a href="../de422531/index.html">Weboptimierung: Das Wichtigste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>