<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕍 ✂️ 👨🏽‍⚕️ Listes chez Kotlin. Approche Haskell 🐗 👩🏼‍🎨 👜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell est un langage entièrement fonctionnel et extrêmement concis. Quiconque a déjà essayé d'écrire du code dans Haskell remarque à quel point il e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listes chez Kotlin. Approche Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell est un langage entièrement fonctionnel et extrêmement concis.  Quiconque a déjà essayé d'écrire du code dans Haskell remarque à quel point il est concis et élégant que d'écrire la même chose dans un langage impératif.  À mon avis, réaliser la même chose en Java est impossible, mais Kotlin vous permet d'aller dans cette direction et d'essayer un style entièrement fonctionnel.  Nous pouvons dériver toutes les fonctions complexes dont nous pouvons avoir besoin à partir de la base de départ des 3 fonctions les plus célèbres: cartographier, filtrer, réduire.  De plus, j'ai créé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> que vous pouvez étudier et voir les tests. <br><a name="habracut"></a><br>  Avant de commencer, je voudrais attirer l'attention sur le fait qu'il ne vaut pas la peine de mettre en œuvre une approche fonctionnelle de cette manière, car le code sera extrêmement lent et ne devrait pas être utilisé dans des applications de production.  Il existe certainement des options pour l'améliorer, mais le but de l'article n'est pas de divulguer ces options, mais d'envisager une approche alternative à l'écriture de code.  Dans tous les cas, la compréhension de cette approche vous aidera à travailler avec des structures de données récursives, et vous pourrez apprécier la beauté et l'élégance de la façon dont le code est lu et combien il est plus facile à comprendre. <br><br><h3>  Fonctions de base </h3><br>  Les listes jouent un rôle très important dans le langage et de nombreuses fonctions utiles leur sont implémentées.  Examinons certains d'entre eux et comment ils peuvent être mis en œuvre sur Kotlin. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  S'il y a des éléments dans la liste, nous retournerons le premier, sinon nous retournerons une erreur. <br>  Nous n'avons pas la possibilité d'écrire un tel code, mais, en général, si vous regardez de près, il est très similaire à celui du modèle.  Nous utiliserons également la fonction d'extension pour pouvoir plus tard utiliser cette méthode sur des listes et avoir un moyen un peu plus concis d'obtenir la valeur, sans les crochets à la fin, comme un appel de méthode. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Afin d'utiliser commodément la récursivité, nous aimerions également diviser la liste en premier élément + tous les autres.  Essayons d'implémenter la fonction tail pour cela. <br><br>  Voici à quoi cela ressemble sur haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Malheureusement, Kotlin ne fournit pas un tel niveau de correspondance de modèles que les développeurs peuvent décrire dans le même style, nous devons donc écrire un peu quand. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Il est un peu malhonnête d'utiliser une fonction de la bibliothèque de langues, mais d'un autre côté, dans tous les cas, il faudrait écrire du code pour cette méthode, il serait donc préférable d'utiliser des méthodes déjà opérationnelles. <br><br>  Maintenant, nous pouvons diviser la liste en premier élément + le reste de la liste.  Nous aurons également besoin de la fonction de concaténation de la liste et d'un élément, qui sera activement utilisé plus tard pour la conversion et d'autres opérations sur la liste. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Maintenant, nous pouvons ajouter une liste à l'élément à la fin, et notre implémentation de la fonction de carte devient opérationnelle et prête à l'emploi.  Malheureusement, encore une fois, il n'y a aucun moyen d'ajouter un objet à la liste de manière plus pratique, nous utilisons donc la méthode <b>add</b> . <br><br>  Pour le moment, nous avons presque tout ce dont nous avons besoin.  La seule chose dont nous avons besoin maintenant est de pouvoir décrire la condition aux limites pour sortir de la récursivité.  Pour ce faire, nous utiliserons la <b>méthode</b> standard <b>isEmpty ()</b> .  Arrêtons-nous et voyons ce que nous avons en ce moment: <br><br><ul><li>  isEmpty () - y a-t-il des éléments dans la liste </li><li>  head - le premier élément de la liste </li><li>  tail - une liste sans le premier élément </li><li>  élément list + - on peut concaténer la liste avec un objet </li></ul><br>  En fait, c'est tout ce dont nous avons besoin pour obtenir toutes les méthodes dont nous avons besoin. <br>  À mon goût, il serait plus pratique d'utiliser la comparaison de longueur de liste dans les instructions <b>when</b> .  Kotlin nous fournit déjà la <b>taille</b> afin d'obtenir cette longueur de liste.  Supposons cependant que nous voulons l'implémenter nous-mêmes.  Avec nos fonctionnalités, ce sera assez simple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Application des fonctions de base </h3><br>  Prenons l'exemple le plus courant.  Supposons que nous ayons une liste d'entiers, et que nous voulions les résumer, en oubliant l'existence de cycles.  Tout ce que nous avons, ce sont les méthodes que nous avons dérivées ci-dessus et la récursivité.  Pour ce faire, nous utiliserons la même approche que lors du calcul de la taille de la liste: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  L'idée est très simple: s'il n'y a aucun élément dans la liste, alors la somme est 0;  sinon, c'est la somme du premier élément et un appel récursif de la somme pour la queue. <br><br>  Malgré le fait que nous ne nous soucions pas de la vitesse et des optimisations dans ce code, nous ne pouvons nous empêcher de rappeler les capacités du langage à utiliser la récursivité de queue.  La récursivité de queue est un cas spécial de récursivité dans lequel un appel récursif est la dernière opération avant de revenir d'une fonction.  Ce type de récursivité est remarquable car il est garanti pour vous permettre de reconstruire le code pour l'itération.  Comme vous le savez, le principal problème de la récursivité est que pendant l'exécution de la fonction, il est nécessaire de stocker la pile d'appels de sorte que lorsque la condition aux limites est atteinte, vous pouvez revenir en arrière et recalculer le résultat final. <br><br>  Il peut sembler que la fonction du montant que nous avons décrit est juste comme ça, car le dernier appel est <b>sum (xs.tail)</b> .  Mais ce n'est pas vrai.  Si vous décrivez le code un peu différemment, cela deviendra évident: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Maintenant, nous voyons qu'en fait, le dernier appel est la somme du premier élément et de la partie restante de la queue. <br><br>  La bonne nouvelle est que si vous ajoutez le modificateur <b>tailrec</b> à une fonction, l'EDI vous dira que la fonction ne l'est pas.  Cependant, résoudre ce problème est assez simple.  Une astuce courante qui corrige une fonction consiste à utiliser une variable auxiliaire pour stocker les résultats.  Cela ressemble à ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Pour calculer la somme des éléments, il suffit de passer 0. comme 2ème paramètre pas nécessaire. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Ayant cette connaissance, vous pouvez voir que la fonction de taille que nous avons implémentée ci-dessus ne remplit pas les conditions nécessaires pour la récursivité de la queue. <br><br>  Nous sommes maintenant prêts à implémenter la carte, filtrer, réduire à l'aide de Kotlin.  Nous verrons plus tard qu'il suffisait de ne réaliser que ces derniers, et les autres, en général, en sont des dérivés.  Mais tout d'abord. <br><br><h3>  Fonctions principales </h3><br><h4>  CARTE </h4><br>  Une implémentation itérative de cette fonction implique un déplacement séquentiel dans la liste, en utilisant la fonction de conversion et en ajoutant tous les éléments reçus à la nouvelle collection.  Nous utiliserons des appels récursifs où la condition aux limites est une liste vide.  L'implémentation ressemblera alors à ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  S'il n'y a aucun élément dans la liste d'origine, alors nous renvoyons une liste vide, sinon, nous appliquons la transformation au premier élément et ajoutons un appel récursif à la fin pour le reste de la liste. <br><br>  Cependant, nous n'avons toujours pas de fonction pour concaténer un élément et une liste.  Mais nous pouvons déjà le réaliser.  Pour commencer, nous dérivons un cas plus général de concaténation d'une paire de listes et ensuite nous l'utilisons pour ajouter une autre liste à l'élément. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filtrer </h4><br>  L'implémentation sera très similaire à la carte.  La seule différence est que vous devez savoir si vous devez ajouter l'élément actuel au résultat.  Pour ce faire, nous appellerons le lambda que nous avons reçu en paramètre.  L'implémentation ressemblera à ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Si l'élément actuel satisfait la condition de filtre, ajoutez-le récursivement à la fin de la liste; sinon, nous continuons à travailler uniquement avec la fin de la liste. <br><br><h4>  RÉDUIRE </h4><br>  La fonction la plus difficile à comprendre et, en même temps, la plus puissante (dans le monde fonctionnel, elle est connue sous le nom de <b>pli</b> ).  Le plus souvent, il est utilisé pour réduire une liste en un seul élément.  Vous avez une certaine valeur de départ <b>s0</b> , et il y a aussi une liste d'éléments <b>a []</b> et une fonction <b>f</b> , qui renvoie une nouvelle pour la valeur de départ et l'élément suivant de la liste.  <b>f (s0, a [0]) = s1</b> .  Et ainsi, nous parcourons séquentiellement toute la liste des éléments, obtenant une sorte de valeur unique à la sortie.  Un exemple assez courant est la somme des éléments du tableau.  Dans ce cas, la valeur de départ est 0 et la fonction renvoie la somme de deux éléments: <b>f (s, a [i]) = s + a [i]</b> .  Considérez comment nous pouvons implémenter récursivement cette fonction. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  En principe, la mise en œuvre est exactement la même que celle que nous avons examinée ci-dessus.  S'il n'y a aucun élément dans la liste, nous renvoyons la valeur actuelle, sinon, nous calculons le nouveau premier élément et appelons à nouveau la fonction de réduction pour lui et la queue de la liste. <br><br>  Notez que nous pouvons également créer des modifications à cette fonction.  Par exemple, ne transmettez pas la valeur de départ, mais utilisez le premier élément de la liste pour cela.  Pour comprendre que réduire ne s'arrête pas là, imaginez que nous utilisons une liste différente comme valeur de départ.  Dans ce cas, à chaque itération, nous ne stockerons pas une valeur, mais une liste, grâce à laquelle nos capacités augmenteront considérablement.  Par exemple, essayons d'appliquer la fonction de réduction de manière à obtenir la liste d'origine à la sortie: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Maintenant, je pense que vous devinez que nous pourrions utiliser réduire, pour une implémentation alternative de la carte, filtre.  Puisque nous avons appris à retourner exactement la même liste avec réduire, nous devons apporter très peu de modifications pour pouvoir convertir chaque élément.  Pour le filtre, tout est très similaire. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  De plus, ils oublient souvent que nous pouvons également utiliser réduire non pas depuis le début de la liste, mais depuis la fin.  Bien sûr, nous pouvons simplement élargir la liste, puis appliquer réduire, mais ce n'est pas intéressant.  Essayons d'écrire et de comprendre comment réduire fonctionne pour réduire la liste dans l'ordre inverse. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Si la liste n'est pas vide, alors nous appliquons la fonction f au résultat du pliage de la queue de la liste et du début de la liste.  Ainsi, le premier élément sera traité en dernier;  avant-dernier - 2e et ainsi de suite.  Pour cette option, vous pouvez également ajouter des modifications qui utiliseront le dernier élément de la liste comme valeur de départ, etc. <br><br>  Presque toujours, lorsque vous travaillez avec des listes, vous pouvez utiliser une combinaison de ces 3 fonctions pour obtenir le résultat qui vous intéresse. <br><br>  Implémentons également la fonction <b>zip</b> , qui nous permettra de combiner 2 listes. <br>  A l'entrée, nous obtenons 2 listes.  Et nous voulons retourner une liste de paires dont la longueur est égale au minimum des listes originales. <br><br>  Comme d'habitude, vous devez penser à quitter la récursivité et écrire une fonction. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Vous pouvez ajouter vos propres modifications, ce qui vous permettra, au lieu de renvoyer une paire d'éléments, d'appliquer une certaine fonction à deux éléments.  Dans Haskell, cette fonction est appelée <b>zipWith</b> .  Et il est implémenté avec la fonctionnalité que nous avons réussi à écrire très simplement: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Très souvent, lorsque vous utilisez l'approche fonctionnelle, des problèmes surviennent lorsque vous devez effectuer des manipulations basées non pas sur des objets dans des listes, mais sur la base d'indices.  Par exemple, nous devons additionner tous les éléments pairs d'une liste.  Vous pouvez essayer d'atteindre cet objectif en réduisant, en conservant Pair &lt;Int, Boolean&gt; comme valeur actuelle et en ajoutant une valeur si flag == true, et en prenant chaque fois la négation de l'indicateur pour l'étape suivante.  Cependant, cela n'a pas l'air trop joli, et le lecteur devra trouver ce que vous voulez exprimer avec ce code.  Kotlin a des séquences infinies, et elles sont parfaites pour résoudre ce problème.  Si nous analysons ce que nous voulons faire, il s'avère que nous voulons filtrer tous les éléments avec des indices impairs et additionner les autres.  Et pour pouvoir obtenir des index, il suffit d'appeler <b>zip</b> pour la liste et la <b>séquence</b> [0,1,2 ..] <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  Dans la bibliothèque standard de Kotlin, vous pouvez trouver la fonction zip pour la paire de séquences. <br><br>  Maintenant, regardons un puzzle simple qui m'a inspiré pour écrire ce guide, et à quoi ressemble son implémentation dans un langage impératif dans Kotlin et à la fin dans Haskell. <br><br>  Il est nécessaire de calculer la quantité maximale parmi les paires de nombres adjacents dans un tableau d'entiers.  La longueur du tableau est supérieure à 1, et vous n'avez pas à vous soucier du débordement lors de la sommation des éléments. <br><br>  Approche Java impérative: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Une approche fonctionnelle sur Kotlin utilisant des fonctions écrites (je propose d'implémenter la fonction max en tant que formation vous-même): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Implémentation de Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Comme nous pouvons le voir, ce que nous avons implémenté sur Kotlin (soit dit en passant, nous pourrions utiliser réduire pour résoudre ce problème) est très similaire à ce qui peut être écrit en Haskell. <br><br><h3>  Conclusion </h3><br>  Sans aucun doute, cela ne devrait pas être utilisé dans le développement, car tout a été mis en œuvre de manière non optimale uniquement afin de démontrer une approche fonctionnelle.  De plus, presque tout ce qui a été écrit se trouve dans la bibliothèque standard de Kotlin, donc peut-être qu'à l'avenir, au lieu d'en écrire une autre pour la boucle, vous utiliserez le style fonctionnel que Kotlin nous fournit. <br><br>  Le plus difficile dans le style fonctionnel est probablement que le problème peut être résolu de différentes manières.  Le plus évident peut être lourd et difficile à comprendre à l'avenir, et écrire le plus compréhensible peut prendre du temps et réfléchir sérieusement.  La seule chose qui peut aider à maîtriser est une pratique et une formation constantes. <br><br>  PS: Comme mentionné ci-dessus, vous pouvez voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> avec tous les exemples qui sont dans l'article.  Exécutez les tests et voyez comment cela fonctionne! <br><br>  PPS: vous pouvez également envisager une approche alternative qui implémente des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionnalités</a> similaires. <br><br>  Et assurez-vous de voir plus tard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://arrow-kt.io/</a> .  À mon avis, vous ne devriez pas y regarder tout de suite, car tout semble assez effrayant, mais plus tard, lorsque les foncteurs et les monades ne vous feront pas peur, assurez-vous de l'étudier. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425527/">https://habr.com/ru/post/fr425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425511/index.html">Fonctionnalités non évidentes de l'application Rotativa pour la génération de PDF dans l'application ASP.NET MVC</a></li>
<li><a href="../fr425515/index.html">Apple bloque la réparation indépendante des nouveaux modèles de MacBook</a></li>
<li><a href="../fr425517/index.html">Comment Yandex a créé une prévision des précipitations mondiales à l'aide de radars et de satellites</a></li>
<li><a href="../fr425521/index.html">Méthodes protégées dans JavaScript ES5</a></li>
<li><a href="../fr425525/index.html">Tim Berners-Lee part sur le chemin de la guerre: "Un petit pas pour le web ..."</a></li>
<li><a href="../fr425529/index.html">Sans Forgetica: une police qui vous permet de mémoriser légèrement mieux ce que vous lisez</a></li>
<li><a href="../fr425531/index.html">Refroidissement liquide des freins. Options de développement du système</a></li>
<li><a href="../fr425533/index.html">Comment travailler dans le cloud: de la vérification de la fiabilité d'un datacenter à la gestion d'une infrastructure virtuelle</a></li>
<li><a href="../fr425537/index.html">Comment combiner Java, Js et graphiques avec de l'art, ou l'histoire de la création d'un théâtre interactif</a></li>
<li><a href="../fr425541/index.html">Comment contourner rapidement et sans puces inutiles l'immuabilité de l'adresse du capteur HTU21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>