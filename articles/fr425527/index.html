<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïç ‚úÇÔ∏è üë®üèΩ‚Äç‚öïÔ∏è Listes chez Kotlin. Approche Haskell üêó üë©üèº‚Äçüé® üëú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell est un langage enti√®rement fonctionnel et extr√™mement concis. Quiconque a d√©j√† essay√© d'√©crire du code dans Haskell remarque √† quel point il e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listes chez Kotlin. Approche Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell est un langage enti√®rement fonctionnel et extr√™mement concis.  Quiconque a d√©j√† essay√© d'√©crire du code dans Haskell remarque √† quel point il est concis et √©l√©gant que d'√©crire la m√™me chose dans un langage imp√©ratif.  √Ä mon avis, r√©aliser la m√™me chose en Java est impossible, mais Kotlin vous permet d'aller dans cette direction et d'essayer un style enti√®rement fonctionnel.  Nous pouvons d√©river toutes les fonctions complexes dont nous pouvons avoir besoin √† partir de la base de d√©part des 3 fonctions les plus c√©l√®bres: cartographier, filtrer, r√©duire.  De plus, j'ai cr√©√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> que vous pouvez √©tudier et voir les tests. <br><a name="habracut"></a><br>  Avant de commencer, je voudrais attirer l'attention sur le fait qu'il ne vaut pas la peine de mettre en ≈ìuvre une approche fonctionnelle de cette mani√®re, car le code sera extr√™mement lent et ne devrait pas √™tre utilis√© dans des applications de production.  Il existe certainement des options pour l'am√©liorer, mais le but de l'article n'est pas de divulguer ces options, mais d'envisager une approche alternative √† l'√©criture de code.  Dans tous les cas, la compr√©hension de cette approche vous aidera √† travailler avec des structures de donn√©es r√©cursives, et vous pourrez appr√©cier la beaut√© et l'√©l√©gance de la fa√ßon dont le code est lu et combien il est plus facile √† comprendre. <br><br><h3>  Fonctions de base </h3><br>  Les listes jouent un r√¥le tr√®s important dans le langage et de nombreuses fonctions utiles leur sont impl√©ment√©es.  Examinons certains d'entre eux et comment ils peuvent √™tre mis en ≈ìuvre sur Kotlin. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  S'il y a des √©l√©ments dans la liste, nous retournerons le premier, sinon nous retournerons une erreur. <br>  Nous n'avons pas la possibilit√© d'√©crire un tel code, mais, en g√©n√©ral, si vous regardez de pr√®s, il est tr√®s similaire √† celui du mod√®le.  Nous utiliserons √©galement la fonction d'extension pour pouvoir plus tard utiliser cette m√©thode sur des listes et avoir un moyen un peu plus concis d'obtenir la valeur, sans les crochets √† la fin, comme un appel de m√©thode. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Afin d'utiliser commod√©ment la r√©cursivit√©, nous aimerions √©galement diviser la liste en premier √©l√©ment + tous les autres.  Essayons d'impl√©menter la fonction tail pour cela. <br><br>  Voici √† quoi cela ressemble sur haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Malheureusement, Kotlin ne fournit pas un tel niveau de correspondance de mod√®les que les d√©veloppeurs peuvent d√©crire dans le m√™me style, nous devons donc √©crire un peu quand. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Il est un peu malhonn√™te d'utiliser une fonction de la biblioth√®que de langues, mais d'un autre c√¥t√©, dans tous les cas, il faudrait √©crire du code pour cette m√©thode, il serait donc pr√©f√©rable d'utiliser des m√©thodes d√©j√† op√©rationnelles. <br><br>  Maintenant, nous pouvons diviser la liste en premier √©l√©ment + le reste de la liste.  Nous aurons √©galement besoin de la fonction de concat√©nation de la liste et d'un √©l√©ment, qui sera activement utilis√© plus tard pour la conversion et d'autres op√©rations sur la liste. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Maintenant, nous pouvons ajouter une liste √† l'√©l√©ment √† la fin, et notre impl√©mentation de la fonction de carte devient op√©rationnelle et pr√™te √† l'emploi.  Malheureusement, encore une fois, il n'y a aucun moyen d'ajouter un objet √† la liste de mani√®re plus pratique, nous utilisons donc la m√©thode <b>add</b> . <br><br>  Pour le moment, nous avons presque tout ce dont nous avons besoin.  La seule chose dont nous avons besoin maintenant est de pouvoir d√©crire la condition aux limites pour sortir de la r√©cursivit√©.  Pour ce faire, nous utiliserons la <b>m√©thode</b> standard <b>isEmpty ()</b> .  Arr√™tons-nous et voyons ce que nous avons en ce moment: <br><br><ul><li>  isEmpty () - y a-t-il des √©l√©ments dans la liste </li><li>  head - le premier √©l√©ment de la liste </li><li>  tail - une liste sans le premier √©l√©ment </li><li>  √©l√©ment list + - on peut concat√©ner la liste avec un objet </li></ul><br>  En fait, c'est tout ce dont nous avons besoin pour obtenir toutes les m√©thodes dont nous avons besoin. <br>  √Ä mon go√ªt, il serait plus pratique d'utiliser la comparaison de longueur de liste dans les instructions <b>when</b> .  Kotlin nous fournit d√©j√† la <b>taille</b> afin d'obtenir cette longueur de liste.  Supposons cependant que nous voulons l'impl√©menter nous-m√™mes.  Avec nos fonctionnalit√©s, ce sera assez simple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Application des fonctions de base </h3><br>  Prenons l'exemple le plus courant.  Supposons que nous ayons une liste d'entiers, et que nous voulions les r√©sumer, en oubliant l'existence de cycles.  Tout ce que nous avons, ce sont les m√©thodes que nous avons d√©riv√©es ci-dessus et la r√©cursivit√©.  Pour ce faire, nous utiliserons la m√™me approche que lors du calcul de la taille de la liste: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  L'id√©e est tr√®s simple: s'il n'y a aucun √©l√©ment dans la liste, alors la somme est 0;  sinon, c'est la somme du premier √©l√©ment et un appel r√©cursif de la somme pour la queue. <br><br>  Malgr√© le fait que nous ne nous soucions pas de la vitesse et des optimisations dans ce code, nous ne pouvons nous emp√™cher de rappeler les capacit√©s du langage √† utiliser la r√©cursivit√© de queue.  La r√©cursivit√© de queue est un cas sp√©cial de r√©cursivit√© dans lequel un appel r√©cursif est la derni√®re op√©ration avant de revenir d'une fonction.  Ce type de r√©cursivit√© est remarquable car il est garanti pour vous permettre de reconstruire le code pour l'it√©ration.  Comme vous le savez, le principal probl√®me de la r√©cursivit√© est que pendant l'ex√©cution de la fonction, il est n√©cessaire de stocker la pile d'appels de sorte que lorsque la condition aux limites est atteinte, vous pouvez revenir en arri√®re et recalculer le r√©sultat final. <br><br>  Il peut sembler que la fonction du montant que nous avons d√©crit est juste comme √ßa, car le dernier appel est <b>sum (xs.tail)</b> .  Mais ce n'est pas vrai.  Si vous d√©crivez le code un peu diff√©remment, cela deviendra √©vident: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Maintenant, nous voyons qu'en fait, le dernier appel est la somme du premier √©l√©ment et de la partie restante de la queue. <br><br>  La bonne nouvelle est que si vous ajoutez le modificateur <b>tailrec</b> √† une fonction, l'EDI vous dira que la fonction ne l'est pas.  Cependant, r√©soudre ce probl√®me est assez simple.  Une astuce courante qui corrige une fonction consiste √† utiliser une variable auxiliaire pour stocker les r√©sultats.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Pour calculer la somme des √©l√©ments, il suffit de passer 0. comme 2√®me param√®tre pas n√©cessaire. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Ayant cette connaissance, vous pouvez voir que la fonction de taille que nous avons impl√©ment√©e ci-dessus ne remplit pas les conditions n√©cessaires pour la r√©cursivit√© de la queue. <br><br>  Nous sommes maintenant pr√™ts √† impl√©menter la carte, filtrer, r√©duire √† l'aide de Kotlin.  Nous verrons plus tard qu'il suffisait de ne r√©aliser que ces derniers, et les autres, en g√©n√©ral, en sont des d√©riv√©s.  Mais tout d'abord. <br><br><h3>  Fonctions principales </h3><br><h4>  CARTE </h4><br>  Une impl√©mentation it√©rative de cette fonction implique un d√©placement s√©quentiel dans la liste, en utilisant la fonction de conversion et en ajoutant tous les √©l√©ments re√ßus √† la nouvelle collection.  Nous utiliserons des appels r√©cursifs o√π la condition aux limites est une liste vide.  L'impl√©mentation ressemblera alors √† ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  S'il n'y a aucun √©l√©ment dans la liste d'origine, alors nous renvoyons une liste vide, sinon, nous appliquons la transformation au premier √©l√©ment et ajoutons un appel r√©cursif √† la fin pour le reste de la liste. <br><br>  Cependant, nous n'avons toujours pas de fonction pour concat√©ner un √©l√©ment et une liste.  Mais nous pouvons d√©j√† le r√©aliser.  Pour commencer, nous d√©rivons un cas plus g√©n√©ral de concat√©nation d'une paire de listes et ensuite nous l'utilisons pour ajouter une autre liste √† l'√©l√©ment. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filtrer </h4><br>  L'impl√©mentation sera tr√®s similaire √† la carte.  La seule diff√©rence est que vous devez savoir si vous devez ajouter l'√©l√©ment actuel au r√©sultat.  Pour ce faire, nous appellerons le lambda que nous avons re√ßu en param√®tre.  L'impl√©mentation ressemblera √† ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Si l'√©l√©ment actuel satisfait la condition de filtre, ajoutez-le r√©cursivement √† la fin de la liste; sinon, nous continuons √† travailler uniquement avec la fin de la liste. <br><br><h4>  R√âDUIRE </h4><br>  La fonction la plus difficile √† comprendre et, en m√™me temps, la plus puissante (dans le monde fonctionnel, elle est connue sous le nom de <b>pli</b> ).  Le plus souvent, il est utilis√© pour r√©duire une liste en un seul √©l√©ment.  Vous avez une certaine valeur de d√©part <b>s0</b> , et il y a aussi une liste d'√©l√©ments <b>a []</b> et une fonction <b>f</b> , qui renvoie une nouvelle pour la valeur de d√©part et l'√©l√©ment suivant de la liste.  <b>f (s0, a [0]) = s1</b> .  Et ainsi, nous parcourons s√©quentiellement toute la liste des √©l√©ments, obtenant une sorte de valeur unique √† la sortie.  Un exemple assez courant est la somme des √©l√©ments du tableau.  Dans ce cas, la valeur de d√©part est 0 et la fonction renvoie la somme de deux √©l√©ments: <b>f (s, a [i]) = s + a [i]</b> .  Consid√©rez comment nous pouvons impl√©menter r√©cursivement cette fonction. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  En principe, la mise en ≈ìuvre est exactement la m√™me que celle que nous avons examin√©e ci-dessus.  S'il n'y a aucun √©l√©ment dans la liste, nous renvoyons la valeur actuelle, sinon, nous calculons le nouveau premier √©l√©ment et appelons √† nouveau la fonction de r√©duction pour lui et la queue de la liste. <br><br>  Notez que nous pouvons √©galement cr√©er des modifications √† cette fonction.  Par exemple, ne transmettez pas la valeur de d√©part, mais utilisez le premier √©l√©ment de la liste pour cela.  Pour comprendre que r√©duire ne s'arr√™te pas l√†, imaginez que nous utilisons une liste diff√©rente comme valeur de d√©part.  Dans ce cas, √† chaque it√©ration, nous ne stockerons pas une valeur, mais une liste, gr√¢ce √† laquelle nos capacit√©s augmenteront consid√©rablement.  Par exemple, essayons d'appliquer la fonction de r√©duction de mani√®re √† obtenir la liste d'origine √† la sortie: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Maintenant, je pense que vous devinez que nous pourrions utiliser r√©duire, pour une impl√©mentation alternative de la carte, filtre.  Puisque nous avons appris √† retourner exactement la m√™me liste avec r√©duire, nous devons apporter tr√®s peu de modifications pour pouvoir convertir chaque √©l√©ment.  Pour le filtre, tout est tr√®s similaire. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  De plus, ils oublient souvent que nous pouvons √©galement utiliser r√©duire non pas depuis le d√©but de la liste, mais depuis la fin.  Bien s√ªr, nous pouvons simplement √©largir la liste, puis appliquer r√©duire, mais ce n'est pas int√©ressant.  Essayons d'√©crire et de comprendre comment r√©duire fonctionne pour r√©duire la liste dans l'ordre inverse. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Si la liste n'est pas vide, alors nous appliquons la fonction f au r√©sultat du pliage de la queue de la liste et du d√©but de la liste.  Ainsi, le premier √©l√©ment sera trait√© en dernier;  avant-dernier - 2e et ainsi de suite.  Pour cette option, vous pouvez √©galement ajouter des modifications qui utiliseront le dernier √©l√©ment de la liste comme valeur de d√©part, etc. <br><br>  Presque toujours, lorsque vous travaillez avec des listes, vous pouvez utiliser une combinaison de ces 3 fonctions pour obtenir le r√©sultat qui vous int√©resse. <br><br>  Impl√©mentons √©galement la fonction <b>zip</b> , qui nous permettra de combiner 2 listes. <br>  A l'entr√©e, nous obtenons 2 listes.  Et nous voulons retourner une liste de paires dont la longueur est √©gale au minimum des listes originales. <br><br>  Comme d'habitude, vous devez penser √† quitter la r√©cursivit√© et √©crire une fonction. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Vous pouvez ajouter vos propres modifications, ce qui vous permettra, au lieu de renvoyer une paire d'√©l√©ments, d'appliquer une certaine fonction √† deux √©l√©ments.  Dans Haskell, cette fonction est appel√©e <b>zipWith</b> .  Et il est impl√©ment√© avec la fonctionnalit√© que nous avons r√©ussi √† √©crire tr√®s simplement: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Tr√®s souvent, lorsque vous utilisez l'approche fonctionnelle, des probl√®mes surviennent lorsque vous devez effectuer des manipulations bas√©es non pas sur des objets dans des listes, mais sur la base d'indices.  Par exemple, nous devons additionner tous les √©l√©ments pairs d'une liste.  Vous pouvez essayer d'atteindre cet objectif en r√©duisant, en conservant Pair &lt;Int, Boolean&gt; comme valeur actuelle et en ajoutant une valeur si flag == true, et en prenant chaque fois la n√©gation de l'indicateur pour l'√©tape suivante.  Cependant, cela n'a pas l'air trop joli, et le lecteur devra trouver ce que vous voulez exprimer avec ce code.  Kotlin a des s√©quences infinies, et elles sont parfaites pour r√©soudre ce probl√®me.  Si nous analysons ce que nous voulons faire, il s'av√®re que nous voulons filtrer tous les √©l√©ments avec des indices impairs et additionner les autres.  Et pour pouvoir obtenir des index, il suffit d'appeler <b>zip</b> pour la liste et la <b>s√©quence</b> [0,1,2 ..] <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  Dans la biblioth√®que standard de Kotlin, vous pouvez trouver la fonction zip pour la paire de s√©quences. <br><br>  Maintenant, regardons un puzzle simple qui m'a inspir√© pour √©crire ce guide, et √† quoi ressemble son impl√©mentation dans un langage imp√©ratif dans Kotlin et √† la fin dans Haskell. <br><br>  Il est n√©cessaire de calculer la quantit√© maximale parmi les paires de nombres adjacents dans un tableau d'entiers.  La longueur du tableau est sup√©rieure √† 1, et vous n'avez pas √† vous soucier du d√©bordement lors de la sommation des √©l√©ments. <br><br>  Approche Java imp√©rative: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Une approche fonctionnelle sur Kotlin utilisant des fonctions √©crites (je propose d'impl√©menter la fonction max en tant que formation vous-m√™me): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Impl√©mentation de Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Comme nous pouvons le voir, ce que nous avons impl√©ment√© sur Kotlin (soit dit en passant, nous pourrions utiliser r√©duire pour r√©soudre ce probl√®me) est tr√®s similaire √† ce qui peut √™tre √©crit en Haskell. <br><br><h3>  Conclusion </h3><br>  Sans aucun doute, cela ne devrait pas √™tre utilis√© dans le d√©veloppement, car tout a √©t√© mis en ≈ìuvre de mani√®re non optimale uniquement afin de d√©montrer une approche fonctionnelle.  De plus, presque tout ce qui a √©t√© √©crit se trouve dans la biblioth√®que standard de Kotlin, donc peut-√™tre qu'√† l'avenir, au lieu d'en √©crire une autre pour la boucle, vous utiliserez le style fonctionnel que Kotlin nous fournit. <br><br>  Le plus difficile dans le style fonctionnel est probablement que le probl√®me peut √™tre r√©solu de diff√©rentes mani√®res.  Le plus √©vident peut √™tre lourd et difficile √† comprendre √† l'avenir, et √©crire le plus compr√©hensible peut prendre du temps et r√©fl√©chir s√©rieusement.  La seule chose qui peut aider √† ma√Ætriser est une pratique et une formation constantes. <br><br>  PS: Comme mentionn√© ci-dessus, vous pouvez voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> avec tous les exemples qui sont dans l'article.  Ex√©cutez les tests et voyez comment cela fonctionne! <br><br>  PPS: vous pouvez √©galement envisager une approche alternative qui impl√©mente des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionnalit√©s</a> similaires. <br><br>  Et assurez-vous de voir plus tard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://arrow-kt.io/</a> .  √Ä mon avis, vous ne devriez pas y regarder tout de suite, car tout semble assez effrayant, mais plus tard, lorsque les foncteurs et les monades ne vous feront pas peur, assurez-vous de l'√©tudier. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425527/">https://habr.com/ru/post/fr425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425511/index.html">Fonctionnalit√©s non √©videntes de l'application Rotativa pour la g√©n√©ration de PDF dans l'application ASP.NET MVC</a></li>
<li><a href="../fr425515/index.html">Apple bloque la r√©paration ind√©pendante des nouveaux mod√®les de MacBook</a></li>
<li><a href="../fr425517/index.html">Comment Yandex a cr√©√© une pr√©vision des pr√©cipitations mondiales √† l'aide de radars et de satellites</a></li>
<li><a href="../fr425521/index.html">M√©thodes prot√©g√©es dans JavaScript ES5</a></li>
<li><a href="../fr425525/index.html">Tim Berners-Lee part sur le chemin de la guerre: "Un petit pas pour le web ..."</a></li>
<li><a href="../fr425529/index.html">Sans Forgetica: une police qui vous permet de m√©moriser l√©g√®rement mieux ce que vous lisez</a></li>
<li><a href="../fr425531/index.html">Refroidissement liquide des freins. Options de d√©veloppement du syst√®me</a></li>
<li><a href="../fr425533/index.html">Comment travailler dans le cloud: de la v√©rification de la fiabilit√© d'un datacenter √† la gestion d'une infrastructure virtuelle</a></li>
<li><a href="../fr425537/index.html">Comment combiner Java, Js et graphiques avec de l'art, ou l'histoire de la cr√©ation d'un th√©√¢tre interactif</a></li>
<li><a href="../fr425541/index.html">Comment contourner rapidement et sans puces inutiles l'immuabilit√© de l'adresse du capteur HTU21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>