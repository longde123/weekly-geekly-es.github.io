<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦑 📕 🚶🏼 JS battle: como escribí mi eval () 🧓🏼 🏮 👎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Puedes recordar a Alexander Korotayev en la versión del navegador de "Heroes of Might and Magic": el descifrado de su informe sobre ella reunió una gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS battle: como escribí mi eval ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/436586/">  Puedes recordar a <b>Alexander Korotayev</b> en la versión del navegador de "Heroes of Might and Magic": el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descifrado de</a> su informe sobre ella reunió una gran cantidad de puntos de vista sobre Habré.  Y ahora hizo un juego centrado en los programadores: debes jugarlo con un código JS. <br><br>  Esta vez, el desarrollo no llevó semanas, sino semanas, pero sin desafíos interesantes de todos modos, no podría funcionar.  ¿Cómo hacer que el juego sea conveniente incluso para desarrolladores que no hayan tocado JavaScript anteriormente?  ¿Cómo protegerse de formas simples de burlar un juego? <br><br><img src="https://habrastorage.org/webt/to/1i/n0/to1in00dneigddmemqzjqonebuy.png"><br><br>  Como resultado, Alexander nuevamente hizo un informe sobre HolyJS, y nosotros (los organizadores de la conferencia) nuevamente preparamos una versión de texto para Habr. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/TJ7TGk5WJ5k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mi nombre es Alexander Korotaev, trabajo en Tinkoff.ru, estoy comprometido en el front-end.  Además, como parte de la comunidad Spb-frontend, ayudo a organizar mitaps.  Hago el podcast de Drinkcast, invitamos a personas interesantes y discutimos varios temas. <br><br>  ¿Cuál es la esencia del juguete?  Primero, debe elegir una unidad de las propuestas, este es un sistema RPG: cada unidad tiene sus propias fortalezas y debilidades.  Usted ve qué unidades eligió el enemigo y elige vengarse de él.  Luego, debes escribir en JavaScript un script para el comportamiento de tu ejército; en otras palabras, el script "lo que cada unidad debe hacer en el campo de batalla". <br><br>  Esto se hace en modo de depuración: de hecho, debitas el código, y luego ambos oponentes empujan su código, y comienza la batalla entre las dos partes. <br><br>  Por lo tanto, puede ver cómo dos scripts, dos lógicas, dos algoritmos luchan entre sí.  Siempre quise hacer algo como esto, y ahora finalmente se implementa. <br><br>  En acción, todo se ve así: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LfgaRFnmkhk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ¿Y cómo era el trabajo en él?  Se dedicó mucho trabajo a la documentación.  Cuando un jugador se sienta en una computadora portátil, ve la documentación, en la que todo se describe con cierto detalle. <br><br>  Me tomó mucho tiempo para su diseño, revisión y cuestionamiento entre las personas si es claro.  Como resultado, resultó claramente para sishnikov, javists y otros desarrolladores que no saben nada sobre JS.  Incluso puedes promocionar JavaScript con este juguete: "No da miedo, mira cómo puedes escribir en él, incluso sucede algo divertido". <br><br><img src="https://habrastorage.org/webt/c3/9b/cf/c39bcfhakno9pvemjsm5rfj1_jo.png"><br><br>  Tuvimos un gran torneo en nuestra empresa, en el que prácticamente cualquier programador en el que hemos participado. <br><br>  Desde el punto de vista tecnológico, utilicé el motor de juegos más popular del mundo de JS: Phaser.  El Ace Editor más grande y más utilizado.  Este es un editor en la web, muy similar a Sublime o VSCode, se puede incrustar en una página web.  También usé RxJS para trabajar con interacciones asincrónicas de diferentes usuarios y Preact para renderizar html.  De las tecnologías nativas, trabajó especialmente con trabajadores y websocket. <br><br><img src="https://habrastorage.org/webt/hr/7e/hj/hr7ehjcuxfyljukymq0yeiwsvou.png"><br><br><hr><br><h2>  Juegos para programadores </h2><br>  ¿Qué son los juegos para programadores en general?  En mi opinión, estos son juegos en los que necesitas codificar, luego obtener un resultado divertido que se pueda comparar con alguien, esta es una batalla.  De estos juegos en línea disponibles, sé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Elevator Saga"</a> : escribes guiones para ascensores de acuerdo con ciertos parámetros.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Screeps"</a> - sobre biología, moléculas, escribir guiones para ellos. <br><br>  También hay juguetes que a veces se encuentran en conferencias.  El más popular de ellos es "Code in the Dark", también lo presentamos hoy.  Por cierto, "Código en la oscuridad" me inspiró de alguna manera. <br><br><img src="https://habrastorage.org/webt/di/ri/xp/dirixpaaxzsners2q5wbecnqf_i.png"><br><br>  ¿Por qué se hizo esto?  Obtuve la tarea de que necesitas crear algo genial con un stand en la conferencia, algo inusual.  No es que hubiera eychars con cuestionarios.  Está claro que todos quieren llamar la atención y recolectar contactos.  Decidimos ir más allá y se nos ocurrió algo genial y divertido para los programadores.  Me di cuenta de que los programadores quieren pelear, competir, y tenemos que darles esa oportunidad.  Es necesario crear un stand en el que vendrán y codificarán. <br><br>  Gamificación  Hicimos esto no solo entre los programadores practicantes, sino también entre los estudiantes.  Celebramos tales partidos en los institutos el día de la carrera.  Necesitábamos ver de algún modo qué tipo de tipos había, adecuados para nosotros o no.  Utilizamos la gamificación para atraer a las personas al proceso, para ver cómo actúan, qué hacen.  Jugaron y se distrajeron, pero eso nos dio información.  Algunos empujaron el código sin siquiera ejecutarlo una vez, y fue inmediatamente obvio que era demasiado temprano para el desarrollo. <br><br><img src="https://habrastorage.org/webt/zy/j7/-d/zyj7-dtcxgbzsnlm6eiakic1pri.png"><br><br>  Cómo se veía en la primera versión.  Era una pantalla principal y dos computadoras portátiles para jugadores.  Todo esto contactó al servidor, el servidor almacenó el estado y lo revolvió entre todos los clientes conectados.  Cada pantalla era un cliente conectado.  Las computadoras portátiles de los jugadores eran pantallas interactivas desde las cuales se podía cambiar este estado.  Las pantallas están unidas rígidamente a un servidor. <br><br><h2>  Falta de historia del tiempo </h2><br>  La primera historia que encontré en este desarrollo es la historia que tuve muy poco tiempo.  Literalmente, en cinco minutos surgió una idea, en cinco segundos se inventó un nombre cuando se requería crear un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> en GitHub.  Podría pasarlo todo solo cuatro horas por la noche, quitándoselo incluso a mi esposa.  Como resultado, solo me quedaban tres semanas antes de la conferencia para darme cuenta de esto, al menos de alguna manera.  Todo comenzó para que fuera necesario tener una idea en el marco de una lluvia de ideas, en cinco minutos nació la idea: "Escribamos algún tipo de inteligencia artificial para RPG en JS".  Es genial, divertido, puedo implementarlo. <br><br><img src="https://habrastorage.org/webt/un/tq/kh/untqkhyleylozw4th97etc8grc0.png"><br><br>  En la primera implementación, la pantalla tenía un editor de código y una pantalla de batalla, en la cual estaba la batalla misma.  Phaser, Ace Editor y Node.js puro se utilizaron como servidor sin ningún marco.  De lo que me arrepentí más tarde, sin embargo, pero luego no se requirió nada especial del servidor. <br><br><img src="https://habrastorage.org/webt/_g/lz/uz/_glzuzkixm5rkvgffsvxc6i0txi.png"><br><br>  Logré darme cuenta entonces de Renderer, quien pintó la batalla en sí.  La parte más difícil fue la caja de arena para el código JS, es decir, una caja de arena en la que se suponía que todo debía ejecutarse de forma aislada para cada jugador.  También hubo intercambio de estado que vino del servidor.  Los jugadores de alguna manera cambiaron de estado, lo arrojaron al servidor, el servidor envió el resto a los enchufes web.  El servidor era una fuente de verdad, y todos los clientes conectados confiaban en lo que provenía del servidor. <br><br><h2>  Caja de arena </h2><br>  ¿Qué es tan difícil de implementar un sandbox?  El hecho es que el sandbox es el mundo entero para el código en el que debe existir el código.  Es decir, usted crea para él aproximadamente el mismo mundo que a su alrededor, pero solo consiste en algunas convenciones, a partir de una API con la que puede interactuar.  ¿Cómo implementar esto en JS?  Parece que JS no es capaz de esto, está tan lleno de agujeros y es tan libre que simplemente no funcionará encerrar completamente el código de usuario en una caja sin usar una máquina virtual separada con un sistema operativo separado. <br><br><img src="https://habrastorage.org/webt/gb/ok/yi/gbokyimz5h1piufn5yfoudov554.png"><br><br>  ¿Qué debe hacer el sandbox? <br><br>  Primero, como dije, aísle el código.  Debe ser un mundo del que no se pueda salir. <br><br>  Además, la API de administración de la unidad debe arrojarse allí.  Los jugadores deben interactuar con el campo de batalla, moviendo unidades, dirigiéndolos, dándoles un vector de ataque. <br>  Y cualquier acción de las unidades es asíncrona, es decir, de alguna manera debería funcionar con código asíncrono. <br><br><img src="https://habrastorage.org/webt/or/q1/y1/orq1y1fcofatt5oz2qieinaixay.png"><br><br>  ¿Qué quería decir sobre la asincronía?  El hecho es que en JS se implementa básicamente mediante promesas.  Aquí todo está claro para todos, las promesas son una gran cosa, funcionan perfectamente, casi siempre hemos estado con nosotros.  Durante muchos años, todos saben cómo trabajar con ellos, pero este juguete no fue solo para javascripts.  ¿Imagínese si comenzara a explicar a los javistas cómo escribir un código de batalla usando promesas?  Cómo hacer entonces, luego, entonces, por qué a veces no es necesario ... ¿Qué hacer con las condiciones o los bucles? <br><br><img src="https://habrastorage.org/webt/z2/qn/ir/z2qnirhdy_puuuliwdnfu0sxalg.png"><br><br>  Puede, por supuesto, ir de la mejor manera y tomar la sintaxis async / wait.  [Diapositiva 8:57] Pero, ¿se imaginan también cómo los programadores que no utilizan JavaScript pueden explicar que deben esperar antes de casi todas las líneas?  Como resultado, la mejor manera de trabajar con la asincronía es no usarla en absoluto. <br><br><img src="https://habrastorage.org/webt/vm/yd/bi/vmydbi-ocp9npyl56wzqv-rnr4e.png"><br><br>  Cree el código más sincrónico y la API más simple, similar a casi cualquier lenguaje de programación.  Hacemos un juguete no solo para las personas que escriben en JS, queremos que sea accesible para todos los que sepan codificar. <br><br><img src="https://habrastorage.org/webt/ng/et/2d/nget2dl8vrmwwi3y608ztrpn2pk.png"><br><br>  Todos necesitamos comenzar de alguna manera.  El usuario escribe el código, y necesitamos ejecutarlo, mover las unidades en el mapa.  Lo primero que viene a la mente es que necesitamos eval () más la declaración no recomendada con, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no se recomienda para usar en MDN</a> .  Esto funcionará, pero hay problemas. <br><br><img src="https://habrastorage.org/webt/ca/18/5a/ca185aygesba1t6wuxfymhvkghi.png"><br><br>  Por ejemplo, tenemos un código que destruye completamente nuestra idea, lo que nos impide hacer algo más.  Este es un código que bloquea la ejecución.  Es necesario hacer algo para que el usuario no pueda bloquear la aplicación.  Por ejemplo, un bucle sin fin puede romperlo todo.  Si alert () y prompt () aún pueden redefinirse, entonces no podemos redefinir un bucle infinito en absoluto. <br><br><h2>  eval () es malvado </h2><br>  Entonces llegamos al punto donde eval () es malo.  No es de extrañar que se llame maldad, porque es una función insidiosa que realmente incorpora todo lo más libre y abierto que hay en JS, y nos deja completamente indefensos.  Con una función simple, hacemos un gran agujero en nuestra aplicación. <br><br><img src="https://habrastorage.org/webt/-e/1s/yv/-e1syve2mujeqy_vpnr3obdk7sk.png"><br><br>  Pero, ¿y si te digo, <i>[en la voz de Steve Jobs]</i> que reinventamos eval ()? <br><br>  Evaluamos () en otras tecnologías, funciona casi igual que la evaluación () que ya tenemos.  De hecho, tengo una función eval () en mi código, pero implementada usando Workers, la instrucción with y Proxy. <br><br><img src="https://habrastorage.org/webt/wf/gj/ox/wfgjoxy3qrjkfnrnpvq-o06xr8k.png"><br><br>  ¿Por qué trabajadores?  El hecho es que crean un hilo de ejecución separado, es decir, JS es de un solo hilo, pero gracias a los trabajadores podemos obtener otro hilo.  Esto nos da muchos beneficios.  Por ejemplo, dentro de los mismos bucles sin fin, podemos interrumpir el hilo creado a través del trabajador desde el hilo principal, tal vez esta es la razón principal por la que utilicé trabajadores.  Si el trabajador logró trabajar más rápido que en un segundo, lo consideramos exitoso, obtenemos su resultado.  Si no, entonces lo cortamos.  De hecho, el código de usuario por alguna razón no funcionó, se produjeron algunos errores extraños o se ralentizó debido a un bucle infinito.  Muchos trataron de escribir hoy mientras (cierto), advertí que esto no funcionaría. <br><br><img src="https://habrastorage.org/webt/ee/en/va/eeenvauyaknpsa7hizr52fvkcwk.png"><br><br>  Para escribir a nuestro trabajador, solo necesitamos alimentar el script al constructor del trabajador, que se descargará a través de http.  Dentro del guión, necesitamos hacer un manejador de mensajes desde el hilo principal.  Usando la función postMessage () dentro del trabajador, podemos enrutar mensajes al hilo principal.  De esta manera hacemos comunicación entre los dos hilos.  Una API simple bastante conveniente, pero falta algo, es decir, el código de usuario que debemos ejecutar en este trabajador.  Cada vez no generaremos un archivo de script en el servidor y lo enviaremos al trabajador. <br><br><img src="https://habrastorage.org/webt/u2/4h/ia/u24hian_cjbwwi-06mtfn6qldmo.png"><br><br>  Encontré una manera usando URL.createObjectURL ().  Hacemos un bloque y lo alimentamos al trabajador src.  Por lo tanto, descarga nuestro código directamente de la línea.  Por cierto, de esta manera funciona con cualquier objeto en el DOM que tenga src - image funciona así, por ejemplo, e incluso en un iframe puede cargar html simplemente generándolo desde una cadena.  Bastante genial y flexible, creo.  También podemos gestionar al trabajador simplemente pasándole nuestro objeto especialmente generado desde la URL.  También podemos terminarlo y ya funciona como lo necesitamos, y creamos el primer sandbox. <br><br><img src="https://habrastorage.org/webt/mq/kp/mk/mqkpmkw8-ufofb05g8qb94-mzm4.png"><br><br>  Las interacciones asincrónicas van más allá, porque cualquier trabajo con trabajadores es asincrónico.  Enviamos un mensaje, y no podemos esperar sincrónicamente el siguiente mensaje, el trabajador solo nos devuelve la instancia y podemos suscribirnos a los mensajes.  Capturamos el mensaje usando RxJS, creamos dos hilos: uno para un mensaje exitoso del trabajador, el segundo para completar por tiempo de espera.  Dos hilos que luego controlamos con su fusión. <br><br><img src="https://habrastorage.org/webt/-x/mt/ny/-xmtnyqc5ytkd6w2zkzdeqfgsws.png"><br><br>  RxJS tiene operadores que nos permiten trabajar con hilos.  De hecho, es como lodash para operaciones sincrónicas.  Podemos indicar alguna función y no pensar en cómo se implementa en el interior, nos alivia del dolor de cabeza.  Necesitamos comenzar a pensar en hilos, el operador de fusión fusiona nuestros hilos, responde a cualquier mensaje.  Responderá tanto al tiempo de espera como al mensaje.  Solo necesitamos el primer mensaje, respectivamente, después del primer mensaje que terminamos con el trabajador.  En caso de error, imprima este error; en caso de éxito, lo resolvemos. <br><br><img src="https://habrastorage.org/webt/l0/fj/lr/l0fjlrbzawogdkbhwkwkci-1osi.png"><br><br>  Aquí todo es bastante simple.  Nuestro código se vuelve declarativo, la complejidad de la asincronía va a alguna parte.  Lo principal es aprender estos operadores. <br><br><img src="https://habrastorage.org/webt/mi/oc/ev/miocevejr1in0eyfg30wqmozb10.png"><br><br>  Así es como trabajamos con la API de la Unidad.  Quería que la API de la unidad fuera lo más simple posible.  Hablando de JS, muchas personas piensan que es difícil, hay que subir a algún lado, aprender algo.  Y quería hacerlo lo más simple posible: todo en el área global, solo existe el alcance de la API de la Unidad, nada más.  Todo para la gestión de la unidad, incluso autocompletar. <br><br><img src="https://habrastorage.org/webt/nl/-c/v8/nl-cv8_2s_3134omu8mqeanuiis.png"><br><br>  [Diapositiva 15:20] La solución sugiere que todo esto puede ser arrojado a lo muy prohibido con una declaración.  Comprendamos por qué está prohibido. <br><br>  El hecho es que tiene sus problemas.  Por ejemplo, con, desafortunadamente, tiene fugas fuera del alcance que le agregamos, porque trata de mirar más profundo que la API de la Unidad y mira dentro del alcance global. <br><br><img src="https://habrastorage.org/webt/tt/hw/gg/tthwggh1janwscz0t9poham_x44.png"><br>  Aquí el último ejemplo es especialmente genial, porque incluso un cuatro puede ser peligroso para nuestro código, ya que todas estas funciones pueden ser realizadas por el código de usuario.  El usuario puede hacer cualquier cosa.  Este es un juego para programadores, y les gusta explorar los problemas y las formas de piratear algo. <br><br><img src="https://habrastorage.org/webt/b4/e0/hb/b4e0hbfhxr1l7xn51miw-qk8bzk.png"><br><br>  Como dije, los ámbitos son muy permeables, por lo que siempre hay un alcance global disponible.  No importa cuántos ámbitos apliquemos a nuestro código personalizado, no importa cuántos ámbitos lo envuelvamos, el alcance global seguirá siendo visible.  Y todo por culpa de. <br><br>  De hecho, no aísla nada, solo nos agrega una nueva capa de abstracción, un nuevo alcance global.  Pero podemos cambiar este comportamiento con Proxy. <br><br><img src="https://habrastorage.org/webt/zz/ed/qq/zzedqqwgeq-gxquunu4_ypeatak.png"><br><br>  El hecho es que Proxy se ocupa de todas nuestras llamadas al objeto que se representan mediante la nueva API, y podemos controlar cómo se comportan las nuevas solicitudes de datos en este objeto. <br><br><img src="https://habrastorage.org/webt/1u/lh/xa/1ulhxahfzy_yahdczgj7jbmacaw.png"><br><br>  De hecho, con obras bastante simples.  Cuando lo alimentamos con algún tipo de variable, verifica debajo del capó si esta variable está en el objeto (es decir, ejecuta el operador in), y si es así, la ejecuta en el objeto, y si no, se ejecuta en el ámbito superior, en Nuestro caso es global.  Es bastante simple aquí.  Lo principal con lo que el proxy nos ayuda es que podemos anular este comportamiento. <br><br><img src="https://habrastorage.org/webt/c0/jg/ie/c0jgie64g9zgd4fukgnjadkj2g4.png"><br><br>  Existen los ganchos en Proxy.  Una cosa maravillosa que nos permite enviar cualquier solicitud al objeto.  Podemos cambiar el comportamiento de la solicitud de atributo, cambiar el comportamiento del trabajo de atributo y, lo más importante, podemos cambiar el comportamiento de esto en el operador.  Hay un gancho, al que solo podemos volver verdadero.  Por lo tanto, tomamos y engañamos completamente nuestra declaración, haciendo que nuestra API sea mucho más segura que antes. <br><br><img src="https://habrastorage.org/webt/4w/-n/vy/4w-nvyhnsledhvcyl0tetw33hvq.png"><br><br>  Si intentamos ejecutar eval (), primero preguntará si eval () está en unitApi, responderán "sí" y obtendrán "undefined no es una función".  ¡Esta parece ser la primera vez que estoy contento con este error!  Este error es exactamente lo que deberíamos haber recibido.  Lo tomamos y le dijimos al usuario: "Lo siento, olvídate de todo lo que sabías sobre el objeto de la ventana, esto ya no existe".  Ya hemos dejado algunos de los problemas, pero eso no es todo. <br><br><img src="https://habrastorage.org/webt/fo/yw/a2/foywa2mzbpbijvc3ndgpq-9tpxw.png"><br><br>  El hecho es que la declaración with es la misma de JS, JS es dinámica y un poco extraña.  Lo extraño es que no todo funciona como nos gustaría, sin tener en cuenta las especificaciones.  El hecho es que también funciona con propiedades prototipo.  Es decir, podemos curny alimentarlo con una matriz, ejecutar este código oscuro.  Todas las funciones de matriz están disponibles como globales en este ámbito, lo que parece un poco extraño. <br><br><img src="https://habrastorage.org/webt/ih/2g/yr/ih2gyrz7isyixyvx7bswlamgvbe.png"><br><br>  Esto no es importante para nosotros, es importante para nosotros que el usuario pueda ejecutar valueOf () y obtener todo nuestro sandbox.  Toma y recoge directamente, mira lo que contiene.  Yo tampoco quería esto, así que se introdujo algo interesante en la especificación: Symbol.unscopables.  Es decir, en la nueva especificación para símbolos, Symbol.unscopables se introdujo específicamente para la declaración with, que está prohibida.  Porque creen que alguien más lo está usando.  Por ejemplo yo! <br><br><img src="https://habrastorage.org/webt/fv/9o/ns/fv9ons58tbtnrnc5rp7biuexgfk.png"><br><br>  Por lo tanto, haremos otro interceptor, donde verificaremos específicamente si este símbolo se encuentra en la lista de todos los atributos que no se pueden eliminar.  Si no, devuélvelo, pero si es así, perdón, no volveremos.  Nosotros tampoco lo usamos.  Y así, con ni siquiera podemos obtener un prototipo de nuestro sandbox. <br><br><img src="https://habrastorage.org/webt/07/5h/tt/075httw1dt0ekhe37frcstztzri.png"><br><br>  Todavía tenemos el entorno de los trabajadores.  Esto es algo que cuelga en un área global y aún es accesible.  El hecho es que si simplemente anula esto, estará disponible en el prototipo.  Casi todo se puede extraer a través del prototipo en JS.  Sorprendentemente, todos estos métodos todavía están disponibles a través del prototipo. <br><br><img src="https://habrastorage.org/webt/po/mt/fl/pomtflwlmxujubh-l8qzqqn2drg.png"><br><br>  Solo tenía que tomar y limpiar todo esto.  Revisamos todas las llaves y lo limpiamos todo. <br><br><img src="https://habrastorage.org/webt/zg/9k/at/zg9katqtaothaqjip6trmosdig0.png"><br><br>  Y luego dejamos un pequeño huevo de Pascua para el usuario, que todavía intenta llamar a esto.  Tomamos la función habitual, lo principal no es la función de flecha, que tiene un alcance, y cambiamos su alcance a nuestro objeto, en el que dejamos un pequeño huevo de Pascua para un usuario particularmente curioso que quiere mostrar algo de esto o de sí mismo en la consola.  Creo que los huevos de Pascua son maravillosos y deben dejarse en el código. <br><br><img src="https://habrastorage.org/webt/_s/7r/fq/_s7rfqdggfjikj2rjm7rcmhwja8.png"><br><br>  Resulta que se quedaron solo con nuestra Unidad API.  Bloqueamos completamente todo; de hecho, dejamos una lista blanca.  Necesitamos agregar aquellas API que son útiles y necesarias.  Por ejemplo, la API de matemáticas, que tiene una función aleatoria útil que muchas personas usan al escribir código para unidades. <br><br>  También necesitamos consola y muchas otras funciones utilitarias que no tienen ninguna función destructiva.  Creamos una lista de tiempo para nuestras API.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es bueno, porque si creáramos una lista negra, dependeríamos de cualquier actualización del navegador que ocurra sin nuestro conocimiento. </font></font><br><br><img src="https://habrastorage.org/webt/nz/mc/0o/nzmc0or7a_svlqdlhcdg36_bzi8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al crear una lista blanca, podemos comenzar a usar try-catch en nuestro código. </font><font style="vertical-align: inherit;">Nuestro código envuelto ya detecta errores y puede enviarlos al usuario, lo cual es muy importante para la depuración. </font></font><br><br><img src="https://habrastorage.org/webt/cl/pa/q1/clpaq1aarq_8svpxquxahgyrkym.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el hecho es que los métodos de consola de Worker no se manifiestan en el código de usuario. </font><font style="vertical-align: inherit;">Es decir, si abre la consola y entra en el entorno de trabajo, estarán disponibles, pero sería un error decirle al usuario "abra la consola y vea qué le sucedió". </font><font style="vertical-align: inherit;">Decidí hacer una consola amigable para el jugador, donde el jugador, incluso sin experiencia en JavaScript, pudiera ver de manera amigable lo que sucedió.</font></font><br><br>  ,    , -   .      ,     .      ,         webpack   . <br><br><img src="https://habrastorage.org/webt/cl/pa/q1/clpaq1aarq_8svpxquxahgyrkym.png"><br><br>      patchMethod(),     ,     postMessage().    postMessage()   console log, error, warn, info.        ,    .  ,       &lt;div&gt;,      ,    ,      ,     ,        . <br><br><img src="https://habrastorage.org/webt/nf/oq/yw/nfoqywkngugbgug6i5wwv_tpuhy.png"><br><br>     ,      .      : -   -  —   ,     ,  -     . , ,    promises.   ,        actions,       . <br><br><img src="https://habrastorage.org/webt/jl/np/2f/jlnp2fcxsgtmghti8wzt4iwzbki.png"><br><br>          actions.   ,     real-time ?   ,  real-time    workers    ,        worker,       .       - ,    .    ,    , .   ,      ,   .        . <br><br><img src="https://habrastorage.org/webt/lk/zb/xp/lkzbxpal1f_bkmcq1pyk5sto8ey.png"><br><br>     workers,       .  workers ,           .      ,   .  ,     ,    (   ,  ),            .  :    — . <br><hr><br><h2>  Math.random() </h2><br>   ,   ,         ,     .      Math.random(). <br><br>     ,   ,      ,                   .   ,  Math.random()     - . <br><br><img src="https://habrastorage.org/webt/g5/xs/zj/g5xszjwvqxhjxp4slm1hfmdfct4.png"><br><br>  ,     ,        (   ), JS   ,        .         . <br><br><img src="https://habrastorage.org/webt/ds/ic/sy/dsicsy7ra1vb8fuzq6xkry7y9zg.png"><br><br>   ,              ,  ,          .       ,    - . <br><br>            ,      . ,        random(),     . <br><br><img src="https://habrastorage.org/webt/cp/ew/ou/cpewoullokdb8p903gddmmgguj8.png"><br><br>  ,  random()     —  « »      ,      .    ,    -  ,     random() ,       .    -    ,     .   ,          ,  random()    . <br><br><img src="https://habrastorage.org/webt/hu/tp/ot/hutpotesuqtwdc_p7yqelekwpjk.png"><br><br>       .    ,   ,   random()  .   - seed          (  ,        ,   ). <br><br><img src="https://habrastorage.org/webt/of/xs/da/ofxsdamysx7gcyfjgctqw1o72o0.png"><br>     ,     .            ,      random().                  ,  random()     -. <br><br>  <a href=""></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo el código que se envía al trabajador es necesario para que JS sea completamente seguro. </font><font style="vertical-align: inherit;">La "inserción" naranja es el mismo código de usuario. </font><font style="vertical-align: inherit;">que se inyecta allí. </font><font style="vertical-align: inherit;">Esa es la cantidad de código que necesita para que JS sea seguro. </font><font style="vertical-align: inherit;">Las API aleatorias () y de unidad también se inyectan allí. </font><font style="vertical-align: inherit;">A través de inyecciones, recibo aún más código que se envía al trabajador.</font></font><br><hr><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estado compartido: RxJS, servidor y clientes </font></font></h2><br>  Entonces descubrimos lo que tenemos con el cliente.  Ahora hablemos sobre compartir el estado, por qué es necesario y cómo se organizó.  Tenemos el estado almacenado en el servidor, el servidor debe confundirlo con los clientes conectados.  [Diapositiva 28:48] <br><br>  Tenemos cuatro roles de diferentes clientes que pueden conectarse al servidor: "usuario izquierdo", "usuario derecho", un espectador que mira la pantalla principal y un administrador que puede hacer cualquier cosa. <br><br>  La pantalla izquierda no puede cambiar el estado del jugador derecho, el espectador no puede cambiar nada y el administrador puede hacer todo. <br><br><img src="https://habrastorage.org/webt/qo/nw/xz/qonwxz54aiudwbywh6msiilucss.png"><br><br>  ¿Por qué fue esto un problema?  Todo está organizado de manera bastante simple.  Cualquier cliente conectado puede lanzar una sesión, el servidor la acepta y fusiona con el estado, que está dentro del servidor y luego la distribuye a todos los clientes.  Él busca a tientas cualquier cambio que se le ocurra.  Era necesario filtrarlo de alguna manera. <br><br><img src="https://habrastorage.org/webt/th/ol/vu/tholvuuygb9shbr5-de-aemuxs8.png"><br><br>  Primero, diré por qué el servidor también tiene RxJS.  Todas las interacciones con dos o más usuarios conectados se vuelven asíncronas.  Debemos esperar los resultados de ambos usuarios.  Por ejemplo, ambos usuarios hicieron clic en el botón "Finalizar", debe esperar a que ambos hagan clic y solo luego realizar la acción.  Todo fue bastante sencillo en RxJS de esta manera: <br><br><img src="https://habrastorage.org/webt/xa/dp/6z/xadp6zds6_xaucjyb7hdrpskcmu.png"><br><br>  Nuevamente estamos operando con subprocesos, hay un flujo desde el socket, que se llama socket.  Para crear un hilo que monitoree solo al jugador izquierdo, simplemente tomamos y filtramos mensajes de este socket por el jugador izquierdo (y de manera similar con el derecho).  Luego podemos combinarlos usando el operador forkJoin (), que funciona como Promise.all () y es su análogo.  Esperamos ambas acciones y llamamos al método setState (), que establece nuestro estado en "listo".  Resulta que estamos esperando a ambos jugadores y cambiamos el estado del servidor.  En RxJS, esto sale lo más declarativo posible, por eso lo usé. <br><br>  Sigue habiendo un problema con el hecho de que los jugadores pueden cambiar de estado entre sí.  Se les debe prohibir hacer esto.  Aún así, son programadores, hubo precedentes que alguien intentó.  Creemos clases separadas para ellos que se heredan del Cliente. <br><br><img src="https://habrastorage.org/webt/jz/9-/6v/jz9-6vskw2b3lqcf3fxasd2w4kq.png"><br><br>  Tendrán la lógica básica de la comunicación del jugador con el servidor, y en cada clase en particular habrá su lógica personalizada para filtrar datos. <br><br>  El cliente es en realidad un grupo de conexiones, conexiones con clientes. <br><br><img src="https://habrastorage.org/webt/sc/qz/kl/scqzklyflx8hylw3stj7drudpdy.png"><br><br>  Simplemente los almacena y tiene la transmisión onUnsafeMessage, que es completamente insegura: no se puede confiar, estos son solo mensajes sin procesar del usuario que recibe.  Escribimos estos mensajes en bruto en la secuencia. <br><br>  Además, al implementar un reproductor específico, tomamos esto enUnsafeMessage y lo filtramos. <br><br><img src="https://habrastorage.org/webt/yn/z0/1k/ynz01kbib00wt83k_5jwx5ix3ku.png"><br><br>  Necesitamos filtrar solo los datos que podemos obtener de este reproductor, en quien podemos confiar.  El jugador izquierdo solo puede cambiar el estado del jugador izquierdo, respectivamente, tomamos de todos los datos que puede enviar, solo el estado del jugador izquierdo.  Si no lo enviaste, está bien.  Si se envía, tomamos.  Por lo tanto, de mensajes completamente inseguros, obtenemos mensajes seguros en los que podemos confiar cuando trabajamos en la habitación. <br><br><img src="https://habrastorage.org/webt/g3/-a/dg/g3-adglwnncvagey8nojzmksixw.png"><br><br>  Tenemos salas de juegos que reúnen a jugadores.  Dentro de la sala, podemos escribir las funciones que pueden cambiar el estado directamente, simplemente suscribiéndose a estos flujos, en los que ya podemos confiar.  Nos abstraemos de un montón de cheques.  Hicimos las comprobaciones basadas en roles y las llamamos clases separadas.  Dividimos el código de tal manera que dentro del controlador, donde se realizan las funciones importantes de cambio de estado, el código se ha vuelto lo más simple y declarativo posible. <br><br>  RxJS también se usa en el cliente, está conectado al zócalo en el reverso, emite eventos y los redirige en todos los sentidos. <br><br>  En este caso, me gustaría dar un ejemplo cuando necesito cambiar el ejército del adversario correcto. <br><br><img src="https://habrastorage.org/webt/qf/u8/oy/qfu8oy7syyrcekd2z424rxuhplw.png"><br><br>  Para suscribirse, creamos una secuencia desde el mismo socket y la filtramos.  Nos aseguramos de que este sea realmente el jugador correcto, y tomamos un mensaje de él sobre cuál es su ejército.  Si no hay tal mensaje, la transmisión no devolverá nada, no habrá un solo mensaje en él, permanecerá en silencio hasta que el jugador cambie el ejército.  Inmediatamente resolvemos de manera declarativa el problema de filtrar eventos, no lo tenemos cursi. <br><br>  Y cuando algo ya ha venido de la secuencia, llamamos a la función setState ().  Esto es bastante simple, el enfoque que nos permite hacer todo de manera transparente y declarativa.  Lo mismo por lo que asumí el proyecto RxJS y en lo que me ayudó mucho. <br><br><img src="https://habrastorage.org/webt/gy/p9/qc/gyp9qchh3hadurc4_vmg0vjj1u4.png"><br><br>  Creo secuencias que he nombrado claramente, con las que entiendo cómo trabajar, todo es declarativo, se llaman las funciones necesarias, no hay problemas con muchos eventos if y de filtrado, todo esto lo hace RxJS. <br><br><h2>  Historia: de un jugador a multijugador </h2><br><br>  Entonces, la primera versión de mi juguete fue escrita.  Podemos decir que era un solo jugador, ya que solo dos jugadores podían jugarlo, el número de clientes conectados fue fijo.  Teníamos un jugador izquierdo, un jugador derecho y la pantalla detrás, todo esto conectado directamente al servidor.  Todo estaba recubierto, pero en tres semanas ya estaba hecho. <br><br>  Recibí una nueva oferta: expandir el juguete para todos los programadores de la compañía para que puedan abrirlo y jugarlo en sus computadoras.  Para que obtengamos una lista de líderes, multijugador para que puedan jugar juntos.  Entonces me di cuenta de que tenía muchas refactorizaciones. <br><br><img src="https://habrastorage.org/webt/qy/vs/-k/qyvs-khwziiaiv8xyfsnvcrlark.png"><br><br>  Resultó no ser tan difícil.  Simplemente combiné todas las entidades que tenía en habitaciones separadas.  Obtuve la esencia de "Room", que podría combinar todos los roles.  Ahora, no son los jugadores mismos quienes se comunican directamente con el servidor, sino las salas.  Las salas ya han enviado solicitudes directamente al servidor, reemplazando el estado, y el estado se ha separado para cada sala. <br><br><img src="https://habrastorage.org/webt/cc/au/tt/ccautts_bfhkftuja4joqqeg9vm.png"><br><br>  Tomé y reescribí todo, agregué una lista de líderes, otorgamos los mejores premios.  Solo era necesario tener una gran cantidad de usuarios, ya era imposible seguir a todos, era necesario escribir algo donde recolectar todos los datos. <br><br><h2>  JS Gamedev y sus problemas </h2><br><br>  Por lo tanto, me familiaricé más con JS-gamedev.  Di una vuelta sobre el último proyecto durante unos tres años, descansando periódicamente.  Y aquí tuve las dos veces durante tres semanas.  Todos los días me sentaba e hacía algo por las tardes. <br><br>  ¿Qué problemas hay en el desarrollo de juegos en JS?  Todo es diferente de nuestras aplicaciones comerciales, donde no es un problema escribir algo desde cero.  Además, mucho de eso es bienvenido: haremos lo nuestro, recordaremos las historias con NPM y nos iremos. <br><br><img src="https://habrastorage.org/webt/f6/6l/zc/f66lzct-hy9vzyyixqvuplcd2qk.png"><br><br>  Es imposible hacer esto en JS Gamedev, porque todas las tecnologías para mostrar gráficos tienen un nivel tan bajo que no es rentable económicamente escribir algo en ellas.  Si tomé este juguete y comencé a escribirlo desde cero en WebGL, también me sentaría detrás de él durante unos seis meses, solo tratando de descubrir algunos errores extraños.  El motor de juegos más popular Phaser me quitó estos problemas ... <br><br><img src="https://habrastorage.org/webt/x1/zs/aa/x1zsaafnaxys0r9tssldvcper38.png"><br><br>  ... y me agregó otros nuevos: 5 megabytes en un paquete.  Y no se pudo hacer nada al respecto; no sabe en absoluto qué es sacudir árboles.  Además, solo la última versión de Phaser puede funcionar con paquetes web y paquetes.  Antes de esto, Phaser estaba conectado solo en la etiqueta html del script, era extraño para mí. <br><br>  Vengo de todo tipo de webpacks-scripts, y en el desarrollo de juegos JS, casi nada puede hacerlo.  Todos los módulos tienen una tipificación extremadamente pobre o no lo tienen en absoluto, o básicamente no saben cómo usar webpack, fue necesario encontrar formas de envolverlo.  Al final resultó que, incluso Ace Editor en su forma pura no funciona con webpack en absoluto.  Para comenzar a trabajar, debe descargar un paquete separado donde ya está envuelto (llave). <br><br>  Fue casi lo mismo con Phaser, pero en la nueva versión lo hicieron más o menos normalmente.  Seguí escribiendo en Phaser y descubrí cómo hacer que todo funcionara con el paquete web de la forma en que solíamos hacerlo: tanto la escritura como las pruebas podrían adjuntarse a todo esto.  Descubrí que puede tomar <a href="">PixiJS por</a> separado, que es un render de paquete web, y encontrar muchos módulos para él que están listos para trabajar con él. <br><br><img src="https://habrastorage.org/webt/cz/cf/o7/czcfo7ib3-d7n3w-l1rpzxfo8cw.png"><br><br>  PixiJS es una gran biblioteca que puede renderizar en WebGL o en Canvas.  Además, incluso puede escribir código como para Canvas, y se representará en WebGL.  Esta biblioteca puede renderizar 2D muy rápidamente.  Lo principal es saber cómo funciona con la memoria, para no caer en una posición cuando la memoria ha terminado. <br><br>  Recomiendo por separado el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">impresionante</a> repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pixijs</a> en GitHub, donde puedes encontrar diferentes módulos.  Sobre todo me gustó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React-pixi</a> .  Simplemente podemos ignorar la resolución de problemas con la vista cuando escribimos funciones imperativas directamente en el controlador para dibujar formas geométricas, sprites, animaciones y más.  Todos podemos marcar en JSX.  Venimos del mundo JSX con nuestra aplicación comercial y podemos usarlos más.  Para eso me encanta la abstracción.  React-pixi nos da esta abstracción familiar. <br><br>  También le aconsejo que tome tween.js, el mismo famoso motor de animación de Phaser, que le permite realizar animaciones declarativas que son algo similares a las animaciones CSS: hacemos una transición entre estados, y tween.js decide por nosotros exactamente cómo mover el objeto. <br><br><h2>  Tipos de jugadores: quiénes son y cómo hacerse amigos de ellos </h2><br>  Me encontré con diferentes jugadores, y también me gustaría contarte sobre cómo probar el juguete.  Reuní colegas en una habitación cerrada y no los dejé salir hasta que terminaron el juego.  Desafortunadamente, no todos pudieron terminar el juego, porque al principio tenía muchos errores.  Afortunadamente, comencé a probar tan pronto como apareció al menos un prototipo funcional.  Honestamente, la primera prueba falló porque un par de jugadores no comenzaron nada.  Fue una pena, pero me dio una patada que me permitió seguir adelante. <br><br>  Cuando tu juguete esté listo, puedes ser recibido muy bien, o con una horca y antorchas.  Todas las personas esperan algún tipo de fanático de los juegos, esperando la felicidad que les darás.  Y les das algo que no funciona en absoluto, aunque parece funcionar para ti.  Cuando tienes un juguete en línea, hay incluso más errores de este tipo. <br><br>  Como resultado, las personas más agradables con las que me he encontrado son "investigadores" que siempre encuentran más en su juguete de lo que realmente son.  Pueden complementarlo agradablemente con todo tipo de pequeñas cosas, lo que te lleva a agregar algo.  Pero, desafortunadamente, la comunicación con estas personas no dio lo importante: la estabilidad del juguete. <br><br>  Hay jugadores comunes que vienen únicamente por el fanático.  Es posible que a veces ni siquiera se den cuenta de los errores, de alguna manera se les escapen en su camino hacia el placer. <br><br>  Otra categoría son los recolectores de errores, para los cuales casi todo no funciona.  Debes ser amigo de esas personas, aunque hablarán mucho de negatividad.  Necesitamos entablar relaciones extrañas con ellos: te lastiman y estás tratando de tomar algo útil para ti, "sentémonos en tu computadora y veamos".  Necesitas trabajar con ellos, porque al final son estas personas las que harán que tu juego sea de calidad. <br><br>  Solo necesita probar en personas vivas.  Su ojo está borroso, y las pruebas ciertamente mostrarán lo que está oculto.  Estás desarrollando un juguete y buceando más profundo, cortando algunas características, pero puede que ni siquiera sean necesarias.  Acude directamente a sus consumidores, les muestra y observa cómo juegan, qué teclas presionan.  Esto le brinda un incentivo para hacer exactamente lo que necesita.  Verá que algunas personas presionan constantemente Ctrl + S, porque están acostumbrados a guardar el código; bueno, al menos haga que el código se ejecute en Ctrl + S, el jugador se sentirá más cómodo.  Necesitas crear un ambiente cómodo para el jugador, para esto necesitas amarlo y seguirlo. <br><br>  La regla 80/20 funciona: realiza una demostración el 20% del tiempo del desarrollo completo del juego, y para el jugador parece un juego completado al 80%.  La percepción funciona para que la mecánica básica esté lista, todo se mueva y funcione, lo que significa que el juego está casi listo y el desarrollador lo terminará pronto.  Pero en realidad, el desarrollador todavía tiene una salida del 80%.  Como dije, durante mucho tiempo tuve que trabajar en la documentación para que fuera comprensible para todos.  Se lo mostré a muchas personas que hablaron sus comentarios, los filtré, tratando de entender la esencia de las declaraciones.  Y me llevó mucho tiempo buscar errores. <br><br>  Entonces, en el desarrollo de juegos, solo podría aconsejarle que haga demostraciones: deleitan a todos, no requieren mucho tiempo y nadie realmente espera nada de las demostraciones.  Terminar juegos es un proceso aburrido, pero comenzar es genial. <br><br>  Finalmente, te dejo enlaces: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio con un juego e instrucciones para el lanzamiento</a> (estaré encantado de agrupar las solicitudes si encuentra errores) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phaser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">awesome-pixijs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servidor de juegos multijugador Colyseus</a> (yo mismo escribí multijugador, y luego vi un servidor terminado con salas) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Editor de Ace</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Presentación de este informe.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conferencias en ruso a las que puede enviar un informe</a> </li></ul><br><blockquote>  <b>HolyJS 2019 Piter</b> , una conferencia para desarrolladores de JavaScript, se llevará a cabo del 24 al 25 de mayo en San Petersburgo.  Los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primeros oradores</a> ya aparecieron en el sitio. <br>  También puede solicitar un informe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Call for Papers está</a> abierto hasta el 11 de marzo. <br>  Los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">precios de las</a> entradas subirán el 1 de febrero. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436586/">https://habr.com/ru/post/es436586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436568/index.html">Plataforma de video propia o cómo tomar muchos recursos informáticos. Parte 1</a></li>
<li><a href="../es436570/index.html">Programador Exorcismo</a></li>
<li><a href="../es436572/index.html">Skolkovo Cybersecurity Challenge 2019 Concurso del Proyecto de Ciberseguridad</a></li>
<li><a href="../es436578/index.html">Precio de seguridad personal para directores de grandes empresas de TI por año</a></li>
<li><a href="../es436584/index.html">Ley de gestión de runet: implementación de disposiciones y áreas de responsabilidad</a></li>
<li><a href="../es436588/index.html">MegaSlerm en Moscú a principios de junio: primer anuncio y descuentos</a></li>
<li><a href="../es436590/index.html">Consejos para un cliente funcional. Presione Δ para leer</a></li>
<li><a href="../es436592/index.html">Back-end en componentes de archivo único VueJS</a></li>
<li><a href="../es436594/index.html">Adiós Chevy Volt: Historias y leyendas del híbrido recargable</a></li>
<li><a href="../es436596/index.html">Los desarrolladores de pila completa están de hecho atrapados en el nivel medio. Ahórrate el sufrimiento, no sigas ese camino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>