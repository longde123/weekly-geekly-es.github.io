<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💼 👩🏻‍🏭 ✌🏾 思维与意识算法，第2部分 💓 🛳️ ♂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文包含我第一篇文章“思维和意识算法”中对算法的解释。 第一篇文章的论文： 



- 可以对主观思维现象进行算法化。 
- 本文中提出的算法认为，并且可以实际使用。 
- 使用思维算法，我们可以以渐近形式定义意识。 
 作者的观点大体上 。 首先，我从理性和复杂性是相同的假设出发。 结果，无论本质...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>思维与意识算法，第2部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466089/">本文包含我第一篇文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“思维和意识算法”中</a>对算法的解释。 第一篇文章的论文： <br><br><ul><li> 可以对主观思维现象进行算法化。 </li><li> 本文中提出的算法认为，并且可以实际使用。 </li><li> 使用思维算法，我们可以以渐近形式定义意识。 </li></ul><a name="habracut"></a><br>  <b>作者的观点大体上</b> 。 首先，我从理性和复杂性是相同的假设出发。 结果，无论本质上是什么，复杂性逻辑先于任何其他类型的逻辑，因此是绝对的。 从这个角度来看，我提出的算法是合理的，因为它可以在形式化的计算过程中实现任何结构上的复杂性。 <br><br> 思维算法基于复杂性的形式逻辑，具有以下特性： <br><br><ol><li> 逻辑的对象是抽象理论。 </li><li> 任何理论都有其复杂性，这种复杂性可以得到清晰的验证。 </li><li> 从任何理论上，都可以推论出更复杂的理论。 </li><li> 从任何复杂的理论中，都可以推导出一个简单的理论。 </li><li> 两种不同的理论将得出不同的结论。 </li><li> 任何理论都是有意义的。 如果理论是独特且无限复杂的，则它被称为有意义的理论。 在实践中，这意味着可以从一个有意义的理论中构建潜在的无限结论链，这样链中的所有结论都是唯一的，每个后续结论都比前一个更为复杂。 </li></ol><br> 从简单的理论到具有许多实质性理论的更复杂的理论的过渡，直观地对应于理想思维的概念。 这种逻辑的建设性实施将尤其是建设性的思维理论。 <br><br>  <b>有关抽象理论的更多信息</b> 。 关于抽象理论的任何事情，都只知道它们是构造复杂性所固有的，因为这种复杂性可以清楚地得到验证。 并且还已知从任何这样的事物到其他更复杂的片断的建设性的过渡都是可能的，并且这也可以被检查。 <br><br>  <b>非正式地关于建设性的复杂性</b> 。 复杂对象是可以唯一分解为简单对象的东西。 复杂对象中包含的对象越简单，则该对象越复杂。 简单的对象不能以独特的方式制作出来。 所有简单对象的复杂性是相同的。 <br><br> 因此，抽象理论分为两种：简单和复杂。 如果使用某种过程可以从中得出一组独特的简单理论，则该理论称为复杂理论。 反过来，对于所有简单理论，相同的过程将返回恒定的结果，因此简单理论的复杂性是相同的。 由于所考虑的逻辑的复杂性是通过结构性确定的，因此可以对其进行计算和比较。 如果两个理论可以分解为相同数量的简单理论，则它们具有相同的复杂性。 您可以获得的理论越简单，原始理论就越复杂。 <br><br>  <b>复杂性的形式化定义</b> 。 关于理论集<b>S</b> = P∪C，其中<b>P</b> = {s∈S |  A [s] =∅}是简单理论的子集， <b>C</b> = {s∈S |  A [s]≠∅}是复杂理论的子集，如果∀（c <sub>1</sub> ，c <sub>2</sub> ）∈C，c <sub>1</sub> ≠c <sub>2</sub> ，A [c <sub>1</sub> ]≠A [c <sub>2</sub> ]，则算符A： <b>S</b> →2 <sup><b>P</b></sup>定义复杂度。 ; 也就是说，对于任何复杂的理论，都有独特的分解成简单的理论。 反过来，| A [s] |：复杂度s的数值度量。 <br><br>  <b>复杂性的逻辑</b> 。 理论集<b>S</b> ，算子A和算子D： <b>S</b> → <b>S</b>使得∀s∈S，| A [s] |  &lt;| A [D [s]] |和∀（s <sub>1</sub> ，s <sub>2</sub> ）∈S，s <sub>1</sub> ≠s <sub>2</sub> ，D [s <sub>1</sub> ]≠D [s <sub>2</sub> ]定义了复杂度逻辑。 根据任何给定的理论，算子D都会推导出一种新的，有保证的更复杂的算子。 <br><br>  <b>执行逻辑的复杂性</b> 。 上面描述的逻辑可以在形式上对特殊类型的字符串的形式表达。 请参阅第一篇文章，以详细了解实现。 下面只是该实现的简化示意图。 <br><br>  <b>许多理论</b> 。 为了表示理论，使用了由任意括号“（”，“）”和方括号内的任何图形标识符组成的字符串。 为简洁起见，每个字母都被视为一个单独的标识符。 字符串的全部内容必须包含在公共的外部方括号中。 对于生产线中的每个开口支架，应将其关闭。 示例： <b>（（b）a（e））</b>行正确，而<b>（b）a（e）</b> ， <b>（a（b（e））行</b>不正确。 <br><br> 许多<b>S</b>理论包含所有可能的规则线。 <br><br> 如果两行符合子字符串中不可分割元素的排列，则两行相等。 如何重新排列元素的示例：（ab（cd））≡（（cd）ab）≡（b（dc）a）≡...≡（（dc）ba）。 空子字符串并不重要，并且会被丢弃，例如（a（））≡（a）。 <br><br>  <b>提款规则</b> 。 在集合<b>S上，</b>给出了三个推理规则。 <br><br>  <b>抽象规则</b> 。 适用于给定字符串的子字符串。 允许您将相同的内容括入括号。 从同一级别的任何一组括号中，可以根据以下原则从括号中取出任何相同的子字符串： <br><br> <code>((ab)(ac)) ⇒ (a(bc)); <br> <br> ((ab)(abc)) ⇒ { (a(bbc)), (b(aac)), (ab(c )) }; <br> <br> ((ab)(ac)(ae)) ⇒ { (a(bce)), (a(bc)(ae)), (a(ab)(ce)) };</code> <br> <br> 根据抽象规则，结果始终比原始字符串简单。 对于简单字符串，例如（（（a）（b））），应用抽象规则的结果为空。 抽象规则的递归应用程序使您可以将任何复杂的字符串分解为简单的字符串。 <br><br>  <b>扣除规则</b> 。 根据此规则，通过按照以下原则将原始行中的所有元素复制任意给定的次数，您可以从原始行中获得任意多的新行： <br><br> <code>(a) ⇒ { ((aa)(aa)), ((aaa)(aaa)(aaa)), ((aaaa)(aaaa)(aaaa)(aaaa)), …}; <br> <br> (a(b)) ⇒ { ((aa(bb)(bb))(aa(bb)(bb))), ((aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))), …}; <br> <br> (a(b(cc))) ⇒ { (aa(bb(cccc)(cccc))(bb(cccc)(cccc)))(aa(bb(cccc)(cccc))(bb(cccc)(cccc))), …};</code> <br> <br>  <b>组成规则</b>  <b>S中的</b>任何一组线都可以合并为一条线。 例如：（a），（b），（e）⇒（（a）（b）（e））。 <br><br>  <b>运算符</b> A。 <b>运算符</b>的结果是一组唯一的简单字符串。 将抽象规则递归应用到给定的行，直到当所有可能的分解选项用尽时都停止为止，它对应于运算符A的操作。 <br><br> 我想提请注意一个事实，即在主体文章中，与A运算符不同，抽象运算符的工作结果不仅包括简单的操作，而且通常还包括可以根据抽象规则推论的所有行。 <br><br>  <b>运算符</b> D。具有给定复制参数的推导规则对应于运算符D的操作。从任何给定行中，都可以从推导规则推导更复杂的行，并且可以使用运算符A来检查这一事实。 <br><br>  <b>合成运算符</b> （）。 对应于合成规则的动作。 <br><br> 因此，获得了满足复杂度逻辑定义的形式系统。 <br><br>  <b>理论内容</b> 。 在复杂性的逻辑中，每个理论都是有意义的。 由于∀s∈S，因此存在唯一的结论链t <sub>n</sub> =（A [D [t <sub>n-1</sub> ]]），其复杂度可能会增加，并且可能会无限增加。 <br><br>  <b>不可解决性假设</b> 。 一般形式的集合T <sub>s</sub> = {p∈S |  ∀n∈N，p∈A [D [t <sub>n</sub> ]];  t <sub>n</sub> =（A [D [t <sub>n-1</sub> ]]）；  t <sub>0</sub> = s}我认为这是无法解决的。 集合T <sub>s</sub>包含由递归函数t <sub>n</sub>从起始行s派生的所有简单字符串。 给定T <sub>s</sub>的不可解性，输出t <sub>n</sub>在算法上是随机的。 没有证据。 <br><br>  <b>思考</b>  t <sub>n</sub>具有理想思维中的复杂性，在此基础上是理想思维的一种形式。 在每次迭代t <sub>n时，</sub>都有一个从不太复杂的理论到新的更复杂的理论的明显过渡，每个这样的过渡都是唯一的，并且这个过程可能是无止境的。 <br><br> 思维以渐近形式实现意识。 粗略地说，“理论意识”是t <sub>n</sub>在计算过程中追求的最终，无限复杂的内容。 <br><br>  <b>主观经验</b> 。 主观经验是意识的特权。 意识不是建设性的。 <br><br> 计算机在计算过程中能否生存？ 不行 但是在计算结果中，可能会有一些经验以牺牲计算机为代价。 <br><br>  <b>结论</b> 我相信每个人都知道构建真正复杂的东西需要花费多少想象力。 不仅很大，而且很复杂。 对于无限的复杂性，您需要无尽的幻想。 该算法从哪里得到这么多的想象力？ 除非幻想本身是一种算法。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466089/">https://habr.com/ru/post/zh-CN466089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466069/index.html">如何让团队寻找更有成效的想法</a></li>
<li><a href="../zh-CN466071/index.html">每次哈希10.3秒：在Apollo航天器机载控制计算机上进行挖掘</a></li>
<li><a href="../zh-CN466075/index.html">我如何在创业公司离开基础科学</a></li>
<li><a href="../zh-CN466077/index.html">圣彼得堡的Techdir广播日</a></li>
<li><a href="../zh-CN466081/index.html">9月3日</a></li>
<li><a href="../zh-CN466093/index.html">kubectl exec如何工作？</a></li>
<li><a href="../zh-CN466097/index.html">监视.NET应用程序</a></li>
<li><a href="../zh-CN466099/index.html">测试用于视频服务的Web应用程序的功能</a></li>
<li><a href="../zh-CN466103/index.html">云安全监控</a></li>
<li><a href="../zh-CN466105/index.html">使用RoadRunner对Magento Rest API超频</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>