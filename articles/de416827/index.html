<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ üñ®Ô∏è üò∞ Container f√ºr Erwachsene (Teil 02): Ein praktischer Leitfaden zur Terminologie üîç üïµüèæ ü§ΩüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Vorlagen f√ºr den Containeraufbau. Ein Container ist nur eine ausf√ºhrbare Version seines eigenen Images. Daher h√§ngt die Art und Weise, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Container f√ºr Erwachsene (Teil 02): Ein praktischer Leitfaden zur Terminologie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Es gibt viele Vorlagen f√ºr den Containeraufbau.  Ein Container ist nur eine ausf√ºhrbare Version seines eigenen Images.  Daher h√§ngt die Art und Weise, wie ein Container erstellt wird, eng davon ab, wie er beginnt. <br><br>  Einige Container-Images funktionieren ohne besondere Berechtigungen, andere erfordern Root-Berechtigungen.  Dar√ºber hinaus kann dasselbe Bild / Container mehrere Konstruktionsmuster und Verwendungsszenarien gleichzeitig kombinieren. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  Im Folgenden werden die h√§ufigsten Anwendungsf√§lle f√ºr Container betrachtet. <br><br>  (Eine Einf√ºhrung in die Containerterminologie finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> ) <br><a name="habracut"></a><br><h3>  Container-Verwendungsszenarien </h3><br><h4>  Anwendungsbeh√§lter </h4><br>  Anwendungscontainer sind die am h√§ufigsten verwendeten Containertypen.  Entwickler und Anwendungsbesitzer k√ºmmern sich um sie und sie selbst enthalten den Quellcode sowie Dinge wie MySQL, Apache, MongoDB und Node.js. <br><br>  Es entsteht ein riesiges √ñkosystem von Anwendungscontainern.  Projekte wie Software Collections bieten sichere und unterst√ºtzte Anwendungscontainer-Images f√ºr Red Hat Enterprise Linux.  Gleichzeitig entwickeln und unterst√ºtzen Mitglieder der Red Hat-Community innovative Anwendungscontainer. <br><br>  Wir bei Red Hat glauben, dass Anwendungscontainer normalerweise keine besonderen Berechtigungen ben√∂tigen.  Beim Erstellen von Containerproduktionsumgebungen sind jedoch andere Container erforderlich. <br><br><h4>  Betriebssystemcontainer </h4><br>  Der Container des Betriebssystems ist ein Container, der viel mehr einem vollwertigen virtuellen Betriebssystem √§hnelt.  Solche Container verwenden auch den Host-Kernel, f√ºhren jedoch das vollst√§ndige Init-System aus, wodurch sie problemlos mehrere Prozesse ausf√ºhren k√∂nnen.  Beispiele f√ºr Betriebssystemcontainer sind LXC und LXD. <br><br>  Die Container des Betriebssystems k√∂nnen im Prinzip mithilfe von Docker- / OCI-Containern emuliert werden, vorausgesetzt, Sie k√∂nnen das System in ihnen ausf√ºhren, sodass der Endbenutzer Software in solchen Containern auf die √ºbliche Weise installieren und sie als vollwertiges virtuelles Betriebssystem wahrnehmen kann. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Dies vereinfacht die Containerisierung vorhandener Anwendungen erheblich.  Red Hat arbeitet hart daran, Betriebssystemcontainer zu vereinfachen, indem systemd im Container ausgef√ºhrt und der bearbeitete Daemon verwendet wird.  Obwohl viele Kunden noch nicht f√ºr die Microservice-Architektur bereit sind, kann der √úbergang zu einem containerisierten Software-Bereitstellungsmodell, das auf Container-Images basiert, ihnen viele Vorteile bieten. <br><br><h4>  Haustierbeh√§lter </h4><br>  Obwohl Red Hat die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud-basierten Vorlagen</a> bei der Entwicklung neuer Anwendungen nachdr√ºcklich empfiehlt, f√∂rdert und unterst√ºtzt, sind wir uns bewusst, dass nicht alle vorhandenen Anwendungen auf diese Weise neu geschrieben werden.  Insbesondere, weil viele von ihnen so einzigartig und unnachahmlich sind, dass sie im Vergleich zu Standardanwendungen wie Haustiere ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haustiere</a> ) gegen eine Herde K√ºhe aussehen.  F√ºr solche Anwendungen werden spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haustierbeh√§lter</a> entwickelt. <br><br>  Haustiercontainer kombinieren die Portabilit√§t und den Komfort einer Containerinfrastruktur, die auf Registrierungsservern, Containerbildern und Containerhosts basiert, mit der Flexibilit√§t einer herk√∂mmlichen IT-Umgebung, die in einem separaten Container implementiert ist.  Hier geht es darum, die Containerisierung vorhandener Anwendungen zu vereinfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, da systemd im Container</a> zur Verwendung vorhandener Automatisierungstools, Softwareinstallationen und anderer Tools verwendet werden kann, um auf einfache Weise containerf√§hige Images f√ºr den Start zu erstellen. <br><br><h4>  Super Privilege Container </h4><br>  Beim Aufbau einer Containerinfrastruktur auf der Basis dedizierter Containerhosts wie Red Hat Enterprise Linux Atomic Host m√ºssen Systemadministratoren diese noch verwalten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Super Privileged Containers</a> (SPCs) erweisen sich in solchen verteilten Umgebungen als sehr n√ºtzlich, sei es Kubernetes, OpenShift oder sogar eigenst√§ndige Container.  SPCs k√∂nnen sogar spezielle Kernelmodule wie systemtap laden. <br><br>  In der Infrastruktur, die zum Ausf√ºhren von Containern erstellt wurde, ben√∂tigen Administratoren wahrscheinlich SPC-Container, um Aufgaben wie √úberwachung, Sicherung usw. auszuf√ºhren. Es ist wichtig zu verstehen, dass Administratoren SPC-Container normalerweise viel st√§rker mit dem Host-Kern verbunden sind Achten Sie bei der Auswahl von Host-Betriebssystemen besonders auf Zuverl√§ssigkeits- und Standardisierungsprobleme, insbesondere in gro√üen Cluster- und verteilten Umgebungen, die die Fehlerbehebung erschweren.  Dar√ºber hinaus m√ºssen Administratoren sicherstellen, dass der Benutzerbereich innerhalb der SPC mit dem Hostkern kompatibel ist. <br><br><h4>  Tools und Systemsoftware </h4><br>  Linux-Distributionen versorgten den Benutzer immer mit Systemsoftware wie Rsyslogd, SSSD, sadc usw. Traditionell wurde diese Software in Form von RPM- oder DEB-Paketen installiert, aber mit dem Aufkommen von Container-Verpackungsformaten wurde die Installation mit Container-Images einfacher und bequemer.  Insbesondere bietet Red Hat Dinge wie vorgefertigte Container wie die Red Hat-Virtualisierungstools, rsyslog, sssd und sadc. <br><br><h3>  Containerarchitektur </h3><br>  Mit zunehmender Dynamik der Bereitstellung von containerisierter Software entstehen neue Muster f√ºr das Containerdesign.  In diesem Abschnitt werden wir √ºber einige von ihnen sprechen. <br><br>  Die Art und Weise, wie der Container auf der Festplatte gespeichert wird (dh das Format des Bildes), kann sich stark auf den Start auswirken.  Beispielsweise muss ein Container, der f√ºr die Ausf√ºhrung von sssd ausgelegt ist, bei jedem Start √ºber spezielle Berechtigungen verf√ºgen, da er sonst seine Aufgabe nicht ausf√ºhren kann.  Im Folgenden werden kurz die Hauptmuster betrachtet, die sich derzeit in der Phase der aktiven Bildung befinden. <br><br><h4>  Anwendungsbilder </h4><br>  Mit diesen Bildern besch√§ftigen sich Endbenutzer.  Die Szenarien f√ºr die Verwendung solcher Images reichen von DBMS und Webservern bis hin zu einzelnen Anwendungen und Servicebussen.  Diese Bilder k√∂nnen entweder intern von der Organisation erstellt oder von Softwareanbietern bereitgestellt werden.  Daher beziehen sich Endbenutzer h√§ufig mit Vorsicht und Sorgfalt auf den Inhalt solcher autonomen Container.  Obwohl dies die einfachste Option f√ºr den Endbenutzer von Containern ist, sind eigenst√§ndige Images viel schwieriger zu entwerfen, zu erstellen und zu patchen. <br><br><h4>  Grundlegende Bilder </h4><br>  Ein Basisbild ist eine der einfachsten Arten von Bildern.  Menschen k√∂nnen diesen Begriff jedoch mit einer Vielzahl von Dingen bezeichnen, z. B. einer Standard-Unternehmensversammlung oder sogar einem Anwendungsimage.  Obwohl es sich streng genommen nicht um einfache, sondern um Zwischenbilder handelt. <br>  Stellen Sie also einfach klar, dass das Basisbild ein Bild ist, das keine √ºbergeordnete Ebene hat.  Grundlegende Images enthalten normalerweise eine saubere Kopie des Betriebssystems sowie die Tools, die zum Installieren von Softwarepaketen oder zum sp√§teren Aktualisieren des Images erforderlich sind (yum, rpm, apt-get, dnf, microdnf).  Grundlegende Bilder k√∂nnen vom Endbenutzer manuell erfasst werden. In der Praxis werden sie jedoch normalerweise von Entwicklungsgemeinschaften (z. B. Debian, Fedora oder CentOS) oder Softwareanbietern (z. B. Red Hat) erstellt und freigegeben.  Der Ursprung des Basisimages ist f√ºr die Sicherheit von entscheidender Bedeutung.  Zusammenfassend ist der Haupt- und einzige Zweck des Grundbildes, eine Grundlage bereitzustellen, auf deren Grundlage Sie Ihre untergeordneten Bilder erstellen k√∂nnen.  Bei Verwendung von Dockerfile erfolgt die Auswahl des zugrunde liegenden Basisimages explizit: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Builder-Bilder </h4><br>  Dies ist ein spezieller Bildtyp, auf dessen Grundlage untergeordnete Bilder von Anwendungscontainern erstellt werden.  Builder-Images enthalten alles au√üer dem von den Entwicklern geschriebenen Quellcode, n√§mlich Betriebssystembibliotheken, Sprachlaufzeiten, Middleware und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Source-to-Image-</a> Tools. <br><br>  Beim Start ruft das Builder-Image den von den Entwicklern geschriebenen Anwendungsquellcode auf und erstellt ein untergeordnetes Image des Anwendungscontainers, das zum Starten bereit ist und dann in einer Entwicklungs- oder Produktionsumgebung ausgef√ºhrt werden kann. <br><br>  Angenommen, die Entwickler haben den PHP-Code f√ºr die Anwendung geschrieben und m√∂chten ihn im Container ausf√ºhren.  Dazu nehmen sie einfach das Builder-Image von PHP und √ºbergeben ihm die URL auf der GitHub-Website, auf der ihr Code gespeichert ist.  Als Ergebnis erhalten Entwickler ein Anwendungscontainer-Image zum Start bereit, das Red Hat Enterprise Linux, PHP aus den Software-Sammlungen und nat√ºrlich den PHP-Quellcode f√ºr die Anwendung enth√§lt. <br><br>  Builder-Images sind eine leistungsstarke, einfache und schnelle M√∂glichkeit, Quellcode in einen Container zu verwandeln, der auf vertrauensw√ºrdigen Komponenten basiert. <br><br><h4>  Containerisierte Komponenten </h4><br>  Ein Container soll in erster Linie als Komponente eines gr√∂√üeren Softwaresystems und nicht als eigenst√§ndige Einheit bereitgestellt werden.  Daf√ºr gibt es zwei Hauptgr√ºnde. <br><br>  Erstens erh√∂ht die Microservice-Architektur die Wahlfreiheit der Komponenten und f√ºhrt auch zu einer Erh√∂hung der Anzahl der Komponenten, aus denen Anwendungen und Softwaresysteme bestehen.  Containerisierte Komponenten helfen dabei, solche Systeme schneller und einfacher bereitzustellen.  Containerbilder erleichtern beispielsweise die L√∂sung des Problems der Koexistenz verschiedener Versionen derselben Komponente.  Anwendungsdefinierende Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitstellungen yaml / json</a> in Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Service Broker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenShift-Vorlagen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helmdiagramme</a> erm√∂glichen die Erstellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeiner</a> Anwendungsbeschreibungen. <br><br>  Zweitens k√∂nnen bei weitem nicht immer alle Teile eines Softwaresystems leicht containerisiert werden.  Daher ist es sinnvoll, die Containerisierung nur f√ºr einzelne Komponenten durchzuf√ºhren, die daf√ºr am besten geeignet oder hinsichtlich der Ergebnisse am vielversprechendsten sind.  In Multiservice-Anwendungen kann ein Teil der Services als Container bereitgestellt werden, der andere Teil mit herk√∂mmlichen Methoden wie RPM oder Installationsskripten (siehe Haustiercontainer).  Dar√ºber hinaus kann es schwierig sein, einige Komponenten zu containerisieren, da sie schlecht in Komponenten unterteilt sind oder an eine spezielle Hardware gebunden sind oder Kernel-API-Aufrufe auf niedriger Ebene usw. verwenden. Daher in einem gro√üen Softwaresystem h√∂chstwahrscheinlich Es wird Teile geben, die containerisiert werden k√∂nnen, und Teile, die nicht containerisiert werden k√∂nnen.  Containerisierte Komponenten k√∂nnen containerisiert und bereits containerisiert werden.  Containerisierte Komponenten k√∂nnen als Teil einer bestimmten Anwendung und nicht f√ºr sich selbst ausgef√ºhrt werden.  Es ist wichtig zu verstehen, dass sie nicht f√ºr den autonomen Betrieb vorgesehen sind, da sie nur als Teil eines gr√∂√üeren Softwaresystems n√ºtzlich und isoliert davon praktisch unbrauchbar sind. <br><br>  In OpenShift Enterprise 3.0 wurde beispielsweise der gr√∂√üte Teil des Hauptcodes mithilfe von RPM bereitgestellt. Nach der Installation stellten Administratoren den Router und die Registrierung als Container bereit.  OpenShift 3.1 f√ºhrte die containerisierte Bereitstellungsoption f√ºr Master, Node, openvswitch und etcd ein. Nach der Installation konnten Administratoren auch elasticsearch, fluentd und kibana als Container bereitstellen. <br><br>  Obwohl das OpenShift-Installationsprogramm noch √Ñnderungen am Server-Dateisystem vornimmt, k√∂nnen alle wichtigen Softwarekomponenten jetzt mithilfe von Container-Images installiert werden.  Daher sollten diese containerisierten Komponenten, z. B. eine in OpenShift eingebettete Instanz des etcd-Images, niemals zum Speichern des Quellcodes der Anwendung verwendet werden, mit der Ihre Kunden arbeiten, nur weil diese containerisierten Komponenten als Teil ausgef√ºhrt werden sollen OpenShift Container Platform. <br><br>  In neuen Versionen von OpenShift verst√§rkt sich der Trend zur Komponentencontainerisierung nur, und andere Softwareentwickler verwenden diesen Ansatz zunehmend. <br><br><h4>  Deployer-Images </h4><br>  Das Deployer-Image ist eine spezielle Art von Container, der beim Start andere Container bereitstellt oder verwaltet.  Mit Deployer k√∂nnen Sie komplexe Bereitstellungsschemata implementieren, z. B. Container in einer bestimmten Reihenfolge starten oder beim ersten Start einige Aktionen ausf√ºhren, z. B. das Generieren eines Datenschemas oder das anf√§ngliche F√ºllen der Datenbank. <br><br>  In OpenShift wird beispielsweise die Vorlage "Bild- / Containertyp" zum Bereitstellen von Protokollen und Metriken verwendet.  Durch die Bereitstellung dieser Komponenten mithilfe von Deployer-Images k√∂nnen OpenShift-Ingenieure die Reihenfolge steuern, in der die verschiedenen Komponenten ausgef√ºhrt werden, und √ºberpr√ºfen, ob sie ordnungsgem√§√ü funktionieren. <br><br><h4>  Zwischenbilder </h4><br>  Ein Zwischenbild ist ein Bild eines Containers, das auf einem Basisbild basiert.  Kernel-Assemblys, Middleware und Sprachlaufzeiten werden normalerweise als zus√§tzliche Ebenen √ºber dem Basis-Image implementiert und dann in der FROM-Direktive mit diesem Basis-Image angegeben.  Zwischenbilder werden normalerweise nicht alleine verwendet, sondern als Bausteine ‚Äã‚Äãf√ºr die Erstellung eines autonomen Bildes. <br><br>  Verschiedene Bildebenen sind in der Regel in verschiedenen Gruppen von Spezialisten besch√§ftigt.  Beispielsweise sind Systemadministratoren f√ºr die Kernel-Assembly-Schicht und Entwickler f√ºr die Middleware-Schicht verantwortlich.  Gleichzeitig fungieren die zugrunde liegenden Ebenen, die von einem Team erstellt wurden, als Zwischenbild f√ºr diejenigen, die f√ºr Ebenen h√∂herer Ebene verantwortlich sind.  Obwohl manchmal solche Zwischenbilder autonom verwendet werden k√∂nnen, insbesondere beim Testen. <br><br><h4>  Mehrzweckbilder (intermodal) </h4><br>  Mehrzweckcontainerbilder sind Bilder mit einer Hybridarchitektur.  Beispielsweise k√∂nnen viele der Bilder in Red Hat Software Collections auf zwei Arten verwendet werden.  Erstens als regul√§re Anwendungscontainer mit vollem Ruby on Rails- und Apache-Server.  Zweitens k√∂nnen Sie sie als Builder-Images f√ºr die OpenShift Container Platform verwenden und untergeordnete Images erstellen, die Ruby on Rails, Apache und den Anwendungscode enthalten, den Sie beim Erstellen eines solchen untergeordneten Images an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quell-Image-</a> Prozess √ºbergeben haben. <br><br>  Beachten Sie, dass Mehrzweckbilder immer beliebter werden, da Sie damit zwei grundlegend unterschiedliche Aufgaben mit demselben Bild l√∂sen k√∂nnen. <br><br><h4>  Systemcontainer </h4><br>  Bei der Bereitstellung von Systemsoftware in Form von Containern sind f√ºr letztere h√§ufig Superuser-Berechtigungen erforderlich.  Um diese Bereitstellungsoption zu vereinfachen und sicherzustellen, dass solche Container vor der Containerlaufzeit und dem Orchestrierungssystem gestartet werden, hat Red Hat eine spezielle Vorlage namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemcontainer entwickelt</a> .  Diese Container werden w√§hrend des Startvorgangs des Betriebssystems mit systemd und dem Befehl atomic gestartet, wodurch sie unabh√§ngig von Laufzeit- oder Container-Orchestrierungssystemen sind.  Heute bietet Red Hat Systemcontainer f√ºr rsyslog, cockpit, etcd und flanneld an und wird diese Liste in Zukunft erweitern. <br><br>  Systemcontainer vereinfachen das selektive Hinzuf√ºgen dieser Dienste zu Red Hat Enterprise Linux und Atomic Host erheblich. <br><br><h3>  Fazit </h3><br>  Container scheinen f√ºr den Endverbraucher eine ziemlich einfache Sache zu sein, aber beim Aufbau einer Containerproduktionsumgebung stellen sich viele Fragen.  Um die Architektur und Methoden zum Aufbau solcher Umgebungen fruchtbar zu diskutieren, ist f√ºr alle Teilnehmer eine einheitliche Terminologie erforderlich.  Je mehr Sie sich mit dem Entwurf und der Konstruktion solcher Umgebungen befassen, desto mehr Fallstricke entstehen.  Schlie√ülich erinnern wir uns nur an einige von ihnen. <br><br>  Der Unterschied zwischen den Begriffen "Container-Image" und "Repository" wird h√§ufig nicht erkannt, insbesondere wenn sie in Docker-Befehlen verwendet werden.  Wenn Sie die Befehle jedoch verwenden k√∂nnen, ohne die Unterschiede zu verstehen, m√ºssen Sie bei der Arbeit an der Architektur von Containerumgebungen klar verstehen, dass das Repository tats√§chlich die Hauptdatenstruktur ist. <br><br>  Es ist auch ziemlich leicht, den Unterschied zwischen Namespaces, Repositorys, Bildebenen und Tags falsch zu verstehen.  Jedes dieser Dinge hat seinen Zweck in der Containerarchitektur.  Und obwohl Lieferanten und Anwender sie f√ºr eine Vielzahl von Zwecken verwenden, sind sie nur Werkzeuge. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  Der Zweck dieses Artikels besteht darin, Ihnen das Verst√§ndnis der Terminologie zu erleichtern, damit Sie erweiterte Architekturen erstellen k√∂nnen.  Stellen Sie sich zum Beispiel vor, Sie wurden gerade mit der Entwicklung einer Infrastruktur beauftragt, die die Verf√ºgbarkeit von Namespaces, Repositorys und Tags und Layern je nach Rollen und Gesch√§ftsregeln einschr√§nken soll.  Und das letzte - denken Sie daran, dass die Art und Weise, wie der Container zusammengesetzt wird, ma√ügeblich davon abh√§ngt, wie er gestartet wird (Orchestrierung, Berechtigungen usw.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416827/">https://habr.com/ru/post/de416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416817/index.html">3. Platz in der Qualifikationsphase von DataScienceGame 2018</a></li>
<li><a href="../de416819/index.html">Leb wohl, Microservices: von hundert Problemkindern bis zu einem Superstar</a></li>
<li><a href="../de416821/index.html">Funktionsweise von JS: WebRTC- und P2P-Kommunikation</a></li>
<li><a href="../de416823/index.html">Blut, Schwei√ü und Pixel: Worum geht es in Jason Schreiers Buch?</a></li>
<li><a href="../de416825/index.html">Wie man NICHT ein mittelm√§√üiger Entwickler ist</a></li>
<li><a href="../de416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../de416831/index.html">Die externe Weiterleitung des russischen Inlandsverkehrs wird auf 5% reduziert</a></li>
<li><a href="../de416833/index.html">Willkommen beim MskDotNet Meetup # 24</a></li>
<li><a href="../de416837/index.html"># Dashanalune 0</a></li>
<li><a href="../de416839/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Puffer√ºberl√§ufe: Exploits und Schutz, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>