<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úèÔ∏è üï∫üèø üìì Apache Kafka y RabbitMQ: sem√°ntica y garant√≠a de entrega de mensajes ‚¨úÔ∏è üôåüèæ ü•ó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preparamos la traducci√≥n de la siguiente parte del art√≠culo en serie, que compara la funcionalidad de Apache Kafka y RabbitMQ. Esta publicaci√≥n trata ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka y RabbitMQ: sem√°ntica y garant√≠a de entrega de mensajes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Preparamos la traducci√≥n de la siguiente parte del art√≠culo en serie, que compara la funcionalidad de Apache Kafka y RabbitMQ.  Esta publicaci√≥n trata sobre sem√°nticas y garant√≠as de entrega de mensajes.  Tenga en cuenta que el autor tuvo en cuenta Kafka hasta la versi√≥n 0.10 incluida, y apareci√≥ exactamente una vez en la versi√≥n 0.11.  Sin embargo, el art√≠culo sigue siendo relevante y est√° lleno de puntos √∫tiles desde un punto de vista pr√°ctico. <br>  Partes anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primero</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> . <br><a name="habracut"></a><br>  Tanto RabbitMQ como Kafka ofrecen garant√≠as confiables de entrega de mensajes.  Ambas plataformas ofrecen garant√≠as sobre los principios de "como m√°ximo una entrega √∫nica" y "al menos una sola vez", pero con el principio de "estrictamente una sola entrega", las garant√≠as de Kafka se aplican de acuerdo con un escenario muy limitado. <br><br>  Primero, descubramos qu√© significan estas garant√≠as: <br><br><ul><li>  Entrega como m√°ximo una vez.  Esto significa que el mensaje no se puede entregar m√°s de una vez.  Sin embargo, el mensaje puede perderse. </li><li>  Al menos una vez entrega.  Esto significa que el mensaje nunca se perder√°.  En este caso, el mensaje se puede entregar m√°s de una vez. </li><li>  Exactamente una vez entrega.  El santo grial de los sistemas de mensajer√≠a.  Todos los mensajes se entregan estrictamente una vez. </li></ul><br>  La palabra "entrega" aqu√≠ probablemente no sea un t√©rmino exacto.  Ser√≠a m√°s exacto decir "procesamiento".  En cualquier caso, lo que nos interesa ahora es si el consumidor puede procesar mensajes y seg√∫n qu√© principio esto sucede: "no m√°s de uno", "al menos uno" o "estrictamente una vez".  Pero la palabra ‚Äúprocesamiento‚Äù complica la percepci√≥n, y la expresi√≥n ‚Äúentrega por el principio de 'estrictamente una vez'‚Äù en este caso no ser√° una definici√≥n precisa, porque puede ser necesario entregar el mensaje dos veces para procesarlo una vez correctamente.  Si el destinatario se desconect√≥ durante el procesamiento, el mensaje debe enviarse nuevamente al nuevo destinatario. <br><br>  El segundo  Discutiendo el tema del procesamiento de mensajes, llegamos al tema de fallas parciales, lo cual es un dolor de cabeza para los desarrolladores.  En el proceso de procesamiento del mensaje hay varias etapas.  Consiste en sesiones de comunicaci√≥n entre la aplicaci√≥n y el sistema de mensajes al principio y al final, y la aplicaci√≥n misma trabaja con los datos en el medio.  Los escenarios de fallas parciales de la aplicaci√≥n deben ser manejados por la propia aplicaci√≥n.  Si las operaciones realizadas son completamente transaccionales y los resultados se formulan seg√∫n el principio de "todo o nada", se pueden evitar fallas parciales en la l√≥gica de la aplicaci√≥n.  Pero a menudo, muchas etapas incluyen la interacci√≥n con otros sistemas, donde la transaccionalidad es imposible.  Si incluimos en la interacci√≥n las relaciones entre los sistemas de mensajer√≠a, las aplicaciones, el cach√© y la base de datos, ¬øpodemos garantizar el procesamiento "solo una vez"?  La respuesta es no. <br><br>  La estrategia de "estrictamente una vez" se limita a un escenario en el que el √∫nico destinatario de los mensajes procesados ‚Äã‚Äães la plataforma de mensajer√≠a en s√≠, y esta plataforma proporciona transacciones completas.  En este escenario limitado, puede procesar mensajes, escribirlos y enviar se√±ales de que se han procesado como parte de una transacci√≥n realizada seg√∫n el principio de "todo o nada".  Es proporcionado por la biblioteca Kafka Streams. <br><br>  Pero si el procesamiento de mensajes siempre es idempotente, puede evitar la necesidad de implementar la estrategia "estrictamente una vez" a trav√©s de las transacciones.  Si el procesamiento final de los mensajes es idempotente, puede preocuparse por aceptar duplicados.  Pero no todas las acciones pueden implementarse de manera idempotente. <br><br>  <b>Alerta de extremo a extremo</b> <br><br>  Lo que no est√° representado en ning√∫n dispositivo de todos los sistemas de mensajer√≠a con los que trabaj√© es la confirmaci√≥n de extremo a extremo.  Dado que se puede poner en cola un mensaje en RabbitMQ, la notificaci√≥n de extremo a extremo no tiene sentido.  En Kafka, de manera similar, varios grupos diferentes de destinatarios pueden leer informaci√≥n simult√°neamente de un tema.  En mi experiencia, las alertas de extremo a extremo son lo que a menudo piden las personas que son nuevas en el concepto de mensajer√≠a.  En tales casos, es mejor explicar de inmediato que esto no es posible. <br><br>  <b>Cadena de responsabilidad</b> <br><br>  En general, las fuentes de mensajes no pueden saber que sus mensajes se entregan a los destinatarios.  Solo pueden saber que el sistema de mensajer√≠a ha recibido sus mensajes y ha asumido la responsabilidad de garantizar su almacenamiento y entrega seguros.  Hay una cadena de responsabilidad, que comienza con la fuente, pasa por el sistema de mensajer√≠a y termina en el destinatario.  Todos deben cumplir correctamente sus deberes y transmitir claramente el mensaje al siguiente.  Esto significa que usted, como desarrollador, debe dise√±ar correctamente sus aplicaciones para evitar la p√©rdida o el mal uso de los mensajes mientras est√°n bajo su control. <br><br>  <b>Procedimiento de transferencia de mensajes</b> <br><br>  Este art√≠culo est√° dedicado principalmente a c√≥mo cada plataforma proporciona estrategias de env√≠o "al menos una" y "no m√°s de una".  Pero todav√≠a hay una orden de mensajer√≠a.  En las partes anteriores de esta serie, escrib√≠ sobre el orden en que se env√≠an los mensajes y el orden en que se procesan, y le aconsejo que consulte estas partes. <br><br>  En resumen, tanto RabbitMQ como Kafka ofrecen una garant√≠a de primero en entrar, primero en salir (FIFO).  RabbitMQ mantiene este orden en el nivel de la cola y Kafka en el nivel de segmentaci√≥n.  Las implicaciones de tales decisiones de dise√±o se discutieron en art√≠culos anteriores. <br><br>  <b>Garant√≠as de entrega en RabbitMQ</b> <br><br>  Se proporcionan garant√≠as de entrega: <br><br><ul><li>  fiabilidad del mensaje: no desaparecer√°n mientras est√©n almacenados en RabbitMQ; </li><li>  notificaciones de mensajes: RabbitMQ intercambia se√±ales con remitentes y destinatarios. </li></ul><br><h4>  Elementos de confiabilidad </h4><br>  <b>Espejo de cola</b> <br><br>  Las colas se pueden reflejar (replicar) en muchos nodos (servidores).  Cada cola tiene una cola inicial en uno de los nodos.  Por ejemplo, hay tres nodos, 10 colas y dos r√©plicas por cola.  Se distribuir√°n 10 colas de control y 20 r√©plicas en tres nodos.  Se puede configurar la distribuci√≥n de colas de control por nodos.  En caso de congelaci√≥n de un nodo: <br><br><ul><li>  en lugar de cada cola inicial en el nodo colgado, se proporciona una r√©plica de esta cola en otro nodo; </li><li>  Se crean nuevas r√©plicas en otros nodos para reemplazar las r√©plicas perdidas en el nodo saliente, lo que admite el factor de replicaci√≥n. </li></ul><br>  El tema de la tolerancia a fallas se discutir√° en la siguiente parte del art√≠culo. <br><br>  <b>Colas confiables</b> <br><br>  Hay dos tipos de colas en RabbitMQ: confiables y poco confiables.  Las colas confiables se escriben en el disco y se guardan en caso de reinicio de un nodo.  Cuando se inicia el nodo, se anulan. <br><br>  <b>Mensajes persistentes</b> <br><br>  Si la cola es confiable, esto no significa que sus mensajes se guardan cuando se reinicia el nodo.  Solo se recuperar√°n los mensajes marcados como persistentes por el remitente. <br><br>  Cuando trabaje en RabbitMQ, cuanto m√°s confiable sea el mensaje, menor ser√° el rendimiento posible.  Si hay una secuencia de eventos en tiempo real y no es cr√≠tico perder varios de ellos o un peque√±o intervalo de tiempo de la secuencia, es mejor no usar la replicaci√≥n de cola y transmitir todos los mensajes como inestables.  Pero si no es deseable perder mensajes debido a un mal funcionamiento de un nodo, es mejor usar colas confiables con replicaci√≥n y mensajes estables. <br><br><h4>  Notificaciones de mensajes </h4><br>  <b>Mensajer√≠a</b> <br><br>  Los mensajes pueden perderse o duplicarse durante la transmisi√≥n.  Depende del comportamiento del remitente. <br><br>  <i>"Dispar√≥ y olvid√≥"</i> <br><br>  La fuente puede decidir no solicitar confirmaci√≥n del destinatario (notificaci√≥n de recepci√≥n de un mensaje al remitente) y simplemente enviar el mensaje autom√°ticamente.  Los mensajes no se duplicar√°n, pero pueden perderse (lo que satisface la estrategia "como un m√°ximo de entrega √∫nica"). <br><br>  <i>Confirmaciones al remitente</i> <br><br>  Cuando el remitente abre un canal para el intermediario de colas, puede usar el mismo canal para enviar confirmaciones.  Ahora, en respuesta al mensaje recibido, el agente de cola debe proporcionar una de dos cosas: <br><br><ul><li>  b√°sico.ack.  Confirmaci√≥n positiva  El mensaje se recibe, la responsabilidad ahora recae en RabbitMQ; </li><li>  b√°sico.nack.  Confirmaci√≥n negativa  Algo sucedi√≥ y el mensaje no fue procesado.  La responsabilidad por ello permanece en la fuente.  Si lo desea, puede enviar un mensaje por segunda vez. </li></ul><br>  Adem√°s de las notificaciones de entrega positivas y negativas, se proporciona un mensaje de devoluci√≥n b√°sico.  A veces, el remitente necesita saber no solo que el mensaje lleg√≥ a RabbitMQ, sino tambi√©n que realmente cay√≥ en una o m√°s colas.  Puede suceder que la fuente env√≠e un mensaje al sistema de intercambio de temas, en el que el mensaje no se enruta a ninguna de las colas de entrega.  En esta situaci√≥n, el corredor simplemente descarta el mensaje.  En algunos escenarios, esto es normal, en otros, la fuente debe saber si el mensaje ha sido descartado y continuar de acuerdo con esto.  Puede establecer el indicador "Obligatorio" para mensajes individuales, y si el mensaje no se ha definido en ninguna cola de entrega, se devolver√° basic.return al remitente. <br><br>  La fuente puede esperar la confirmaci√≥n despu√©s de enviar cada mensaje, pero esto reducir√° en gran medida su rendimiento.  En cambio, las fuentes pueden enviar un flujo constante de mensajes, estableciendo un l√≠mite en la cantidad de mensajes no reconocidos.  Cuando se alcanza el l√≠mite de mensajes provisionales, el env√≠o se detendr√° hasta que se reciban todas las confirmaciones. <br><br>  Ahora que hay muchos mensajes en tr√°nsito desde el remitente a RabbitMQ, las confirmaciones se agrupan utilizando el indicador m√∫ltiple para mejorar el rendimiento.  A todos los mensajes enviados a trav√©s del canal se les asigna un valor entero que aumenta monot√≥nicamente, el "N√∫mero de secuencia".  La notificaci√≥n de un mensaje incluye el n√∫mero de secuencia del mensaje correspondiente.  Y si al mismo tiempo el valor es multiple = true, el remitente debe rastrear los n√∫meros de secuencia de sus mensajes para saber qu√© mensajes se entregaron con √©xito y cu√°les no.  Escrib√≠ un art√≠culo detallado sobre este tema. <br><br>  Gracias a las confirmaciones, evitamos la p√©rdida de mensajes de las siguientes maneras: <br><br><ul><li>  reenviar mensajes en caso de una notificaci√≥n negativa; </li><li>  almacenamiento continuo de mensajes en alg√∫n lugar en caso de notificaci√≥n negativa o devoluci√≥n b√°sica. </li></ul><br>  <i>Transacciones</i> <br><br>  Las transacciones rara vez se usan en RabbitMQ por los siguientes motivos: <br><br><ul><li>  Garant√≠as d√©biles.  Si los mensajes se enrutan a varias colas o tienen un icono obligatorio, no se admitir√° la continuidad de la transacci√≥n; </li><li>  Baja productividad. </li></ul><br>  Honestamente, nunca los us√©, no dan ninguna garant√≠a adicional, excepto las confirmaciones al remitente, y solo aumentan la incertidumbre en la cuesti√≥n de c√≥mo interpretar el acuse de recibo de los mensajes derivados de la finalizaci√≥n de las transacciones. <br><br>  <i>Errores de comunicaci√≥n / canal</i> <br><br>  Adem√°s de las notificaciones de recepci√≥n de mensajes, el remitente debe tener en cuenta las fallas de las herramientas de comunicaci√≥n y los corredores.  Ambos factores conducen a la p√©rdida del canal de comunicaci√≥n.  Con la p√©rdida de canales, la oportunidad de recibir las notificaciones de recepci√≥n de mensajes a√∫n no recibidos desaparece.  Aqu√≠, el remitente debe elegir entre el riesgo de p√©rdida de mensajes y el riesgo de duplicaci√≥n. <br><br>  La falla del intermediario puede ocurrir cuando el mensaje estaba en el b√∫fer del sistema operativo o preprocesado, y luego el mensaje se perder√°.  O tal vez el mensaje estaba en cola, pero el agente de mensajes muri√≥ antes de enviar una confirmaci√≥n.  En este caso, el mensaje se entregar√° con √©xito. <br><br>  Del mismo modo, el fracaso de los medios de comunicaci√≥n afecta la situaci√≥n.  ¬øOcurri√≥ una falla durante la transmisi√≥n del mensaje?  ¬øO despu√©s de que el mensaje haya sido puesto en cola, pero antes de recibir una notificaci√≥n positiva? <br><br>  El remitente no puede determinar esto, por lo que debe elegir una de las siguientes opciones: <br><br><ul><li>  No reenv√≠e el mensaje, creando un riesgo de p√©rdida; </li><li>  reenv√≠e el mensaje y cree un riesgo de duplicaci√≥n. </li></ul><br>  Si hay muchos mensajes del remitente en tr√°nsito, el problema se vuelve m√°s complicado.  Lo √∫nico que puede hacer el remitente es dar una pista a los destinatarios agregando un encabezado especial al mensaje, lo que indica que el mensaje se est√° enviando por segunda vez.  Los destinatarios pueden decidir verificar la presencia de dichos encabezados en los mensajes y, si se encuentran, verificar si los mensajes recibidos est√°n duplicados (si dicha verificaci√≥n no se ha realizado previamente). <br><br><h4>  Destinatarios </h4><br>  Hay dos opciones disponibles para los destinatarios para recibir notificaciones: <br><br><ul><li>  sin modo de notificaci√≥n; </li><li>  modo de notificaci√≥n manual. </li></ul><br>  <i>Sin modo de notificaci√≥n</i> <br><br>  Es un modo de notificaciones autom√°ticas.  Y √©l es peligroso.  En primer lugar, porque cuando un mensaje ingresa a su aplicaci√≥n, se elimina de la cola.  Esto puede conducir a la p√©rdida de mensajes si: <br><br><ul><li>  la conexi√≥n se interrumpi√≥ antes de recibir el mensaje; </li><li>  el mensaje todav√≠a est√° en el b√∫fer interno y la aplicaci√≥n se deshabilit√≥; </li><li>  el procesamiento del mensaje fall√≥. </li></ul><br>  Adem√°s, estamos perdiendo mecanismos de contrapresi√≥n como un medio para monitorear la calidad de la entrega de mensajes.  Al configurar el modo para enviar notificaciones manualmente, puede establecer una captaci√≥n previa (o establecer el nivel de servicios proporcionados, QoS) para limitar el n√∫mero de mensajes √∫nicos que el sistema a√∫n no ha confirmado.  Sin esto, RabbitMQ env√≠a mensajes tan r√°pido como lo permite la conexi√≥n, y esto puede ser m√°s r√°pido de lo que el receptor puede procesarlos.  Como resultado, los b√∫feres est√°n llenos y se producen errores de memoria. <br><br>  <i>Modo de notificaci√≥n manual</i> <br><br>  El destinatario debe enviar manualmente una notificaci√≥n de recepci√≥n de cada mensaje.  Puede establecer una captaci√≥n previa en caso de que el n√∫mero de mensajes sea m√°s de uno, y procesar muchos mensajes al mismo tiempo.  Puede decidir enviar una notificaci√≥n para cada mensaje, o puede aplicar la bandera m√∫ltiple y enviar varias notificaciones a la vez.  Las notificaciones de agrupaci√≥n mejoran el rendimiento. <br><br>  Cuando el destinatario abre el canal, los mensajes que lo atraviesan contienen el par√°metro Etiqueta de entrega, cuyo valor es un n√∫mero entero, que aumenta monot√≥nicamente.  Se incluye en cada notificaci√≥n de recibo y se utiliza como identificador de mensaje. <br><br>  Las notificaciones pueden ser las siguientes: <br><br><ul><li>  b√°sico.ack.  Despu√©s de eso, RabbitMQ elimina el mensaje de la cola.  La bandera m√∫ltiple se puede aplicar aqu√≠. </li><li>  b√°sico.nack.  El destinatario debe establecer una bandera para indicarle a RabbitMQ si debe volver a poner el mensaje en cola.  Al volver a configurar el mensaje va al comienzo de la cola.  Desde all√≠ se env√≠a nuevamente al destinatario (incluso al mismo destinatario).  La notificaci√≥n basic.nack admite el indicador m√∫ltiple. </li><li>  rechazo basico.  Igual que basic.nack, pero no admite el indicador m√∫ltiple. </li></ul><br>  Por lo tanto, sem√°nticamente basic.ack y basic.nack con requeue = false son lo mismo.  Ambos operadores significan eliminar un mensaje de la cola. <br><br>  La siguiente pregunta es cu√°ndo enviar notificaciones de recibo.  Si el mensaje se proces√≥ r√°pidamente, es posible que desee enviar una notificaci√≥n inmediatamente despu√©s de completar esta operaci√≥n (correcta o incorrecta).  Pero si el mensaje estaba en la cola RabbitMQ y el procesamiento lleva muchos minutos.  Enviar una notificaci√≥n despu√©s de esto ser√° problem√°tico, porque si el canal se cierra, todos los mensajes para los que no hubo notificaciones ser√°n devueltos a la cola y el env√≠o se realizar√° por segunda vez. <br><br>  <b>Error de conexi√≥n / intermediario de mensajes</b> <br><br>  Si se desconect√≥ la conexi√≥n o se produjo un error en el intermediario, despu√©s de lo cual el canal deja de funcionar, todos los mensajes cuyo recibo no ha sido confirmado se vuelven a poner en cola y se reenv√≠an.  Esto es bueno porque evita la p√©rdida de datos, pero malo porque causa una duplicaci√≥n excesiva. <br><br>  Cuanto m√°s tiempo tenga el destinatario mensajes durante mucho tiempo, cuyo recibo no haya confirmado, mayor ser√° el riesgo de reenv√≠o.  Cuando se reenv√≠a un mensaje, RabbitMQ para el indicador de reenv√≠o se establece en verdadero.  Debido a esto, el destinatario al menos tiene una indicaci√≥n de que el mensaje puede haber sido procesado. <br><br>  <b>Idempotencia</b> <br><br>  Si se requiere idempotencia y garantiza que no se pierda ning√∫n mensaje, se deben incorporar algunos cheques duplicados u otros esquemas idempotentes.  Si buscar mensajes duplicados es demasiado costoso, puede aplicar una estrategia en la que el remitente siempre agrega un encabezado especial a los mensajes reenviados, y el destinatario verifica la presencia de dicho encabezado y una bandera de reenv√≠o en los mensajes recibidos. <br><br><h4>  Conclusi√≥n </h4><br>  RabbitMQ ofrece garant√≠as confiables de mensajer√≠a a largo plazo, pero hay muchas situaciones en las que no ayudar√°n. <br><br>  Aqu√≠ hay una lista de puntos para recordar: <br><br><ul><li>  Debe usar la duplicaci√≥n de colas, las colas confiables, los mensajes persistentes, los reconocimientos para el remitente, un indicador de confirmaci√≥n y la notificaci√≥n forzada del destinatario si se requieren garant√≠as confiables en la estrategia de "al menos una vez de entrega". </li><li>  Si el env√≠o se lleva a cabo como parte de la estrategia de "al menos una entrega", es posible que deba agregar un mecanismo de deduplicaci√≥n o idempotencia al duplicar los datos que se env√≠an. </li><li>  Si la cuesti√≥n de la p√©rdida de mensajes no es tan importante como la cuesti√≥n de la velocidad de entrega y la alta escalabilidad, piense en sistemas sin redundancia, sin mensajes persistentes y sin reconocimiento en el lado de la fuente.  Sin embargo, preferir√≠a dejar notificaciones forzadas del destinatario para controlar el flujo de mensajes recibidos cambiando las restricciones de captaci√≥n previa.  En este caso, deber√° enviar notificaciones en lotes y utilizar la bandera "m√∫ltiple". </li></ul><br>  <b>Garant√≠as de entrega en Kafka</b> <br><br>  Se proporcionan garant√≠as de entrega: <br><br><ul><li>  durabilidad del mensaje: los mensajes almacenados en un segmento no se pierden; </li><li>  Notificaciones de mensajes: el intercambio de se√±ales entre Kafka (y posiblemente el repositorio de Apache Zookeeper) por un lado y la fuente / receptor por el otro. </li></ul><br>  <b>Dos palabras sobre el empaquetado de mensajes</b> <br><br>  Una de las diferencias entre RabbitMQ y Kafka es el uso de paquetes para mensajer√≠a. <br><br>  RabbitMQ proporciona algo similar al embalaje gracias a: <br><br><ul><li>  Suspenda el env√≠o de cada mensaje X hasta que se reciban todas las notificaciones.  RabbitMQ generalmente agrupa las notificaciones utilizando el indicador "m√∫ltiple". </li><li>    ¬´prefetch¬ª      ¬´multiple¬ª. </li></ul><br>       .                  ‚Äúmultiple‚Äù.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   ‚Äútrue‚Äù, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   ‚Äúall‚Äù. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li> .          .                 .          .         ,      . </li><li> ,    .      ‚Äú   ‚Äù.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      ‚Äú   ‚Äù.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  ‚Äú  ‚Äù  Kafka Streams,    Java.   Java      .    ‚Äú  ‚Äù,      ,    ,           . ,         ,      ‚Äú  ‚Äù  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      ‚Äú  ‚Äù.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     ‚Äú--‚Äù.         .   ,   ,  . <br><br>        ‚Äú ‚Äù,    ,      (,  , ).      ‚Äú ‚Äù,    ,      .       . <br><br>   :    ‚Äú  ‚Äù      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) ‚Äî      ;     ‚Äú  ‚Äù      . <br><br>  <b>Conclusiones</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Para resumir </h4><br><ul><li>      ‚Äú   ‚Äù  ‚Äú   ‚Äù. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      ‚Äú--‚Äù.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li> Kafka           ,   RabbitMQ       ,    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437446/">https://habr.com/ru/post/437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437436/index.html">Ejecutar el visor de im√°genes desde Windows XP en Windows moderno</a></li>
<li><a href="../437438/index.html">Audiotecnolog√≠a: c√≥mo se mueven las piezas de pl√°stico con ultrasonido y por qu√© es necesario</a></li>
<li><a href="../437440/index.html">Feliz dia del estudiante, programador</a></li>
<li><a href="../437442/index.html">Respuestas del soporte t√©cnico de 3CX: configure el enrutador para el servidor PBX VoIP</a></li>
<li><a href="../437444/index.html">Un balde de alquitr√°n en un barril de miel, o sobre un posible choque cultural para los propietarios de tractores</a></li>
<li><a href="../437448/index.html">28 de enero en Rusia, el sistema de pagos r√°pidos sin comisi√≥n (por n√∫mero de tel√©fono)</a></li>
<li><a href="../437450/index.html">C√≥mo conoc√≠ a OpenCV o en busca de ColorChecker</a></li>
<li><a href="../437454/index.html">Arithmometer Felix M revisi√≥n</a></li>
<li><a href="../437456/index.html">M√°s joven: revisi√≥n de los tel√©fonos IP Snom D315 y D305</a></li>
<li><a href="../437458/index.html">Registro obligatorio por IMEI oferta para hacer pago</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>