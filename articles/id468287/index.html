<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 ↕️ 🎖️ C # Atribut: Tentang Semua Aspek 🚥 ❎ 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca. Artikel ini menjelaskan atribut dari semua sisi - mulai dari spesifikasi, makna dan definisi atribut, membuat milik Anda dan bekerja den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # Atribut: Tentang Semua Aspek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Halo pembaca.  Artikel ini menjelaskan atribut dari semua sisi - mulai dari spesifikasi, makna dan definisi atribut, membuat milik Anda dan bekerja dengannya, diakhiri dengan menambahkan atribut pada runtime dan atribut yang ada yang paling berguna dan menarik.  Jika Anda tertarik pada topik atribut di C #, selamat datang di cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Isi </h2><br><ol><li>  Pendahuluan  Menentukan dan Menetapkan Atribut </li><li>  Atribut yang menarik dengan dukungan runtime.  Di sini, informasi singkat akan diberikan tentang berbagai atribut, keberadaan yang hanya sedikit orang ketahui dan bahkan kurang yang menggunakannya.  Karena ini benar-benar informasi yang tidak praktis, tidak akan ada banyak omelan (bertentangan dengan hasrat saya untuk pengetahuan yang tidak dapat diterapkan) </li><li> Beberapa atribut yang kurang dikenal yang bermanfaat untuk diketahui. </li><li>  Menentukan atribut Anda dan memprosesnya.  Menambahkan Atribut saat Jalankan </li></ol><br><h2>  Pendahuluan </h2><br>  Seperti biasa, mulailah dengan definisi dan spesifikasi.  Ini akan membantu untuk memahami dan mewujudkan atribut di semua tingkatan, yang, pada gilirannya, sangat berguna untuk menemukan aplikasi yang tepat untuk mereka. <br><br>  Mulailah dengan mendefinisikan metadata.  <b>Metadata</b> adalah data yang menjelaskan dan merujuk pada jenis yang didefinisikan oleh <abbr title="Sistem tipe umum">CTS</abbr> .  Metadata disimpan dengan cara yang tidak tergantung pada bahasa pemrograman tertentu.  Dengan demikian, metadata menyediakan mekanisme umum untuk bertukar informasi tentang suatu program untuk digunakan di antara alat-alat yang membutuhkannya (kompiler dan pengadu, serta program itu sendiri), serta antara <abbr title="Sistem eksekusi virtual">VES</abbr> .  Metadata termasuk dalam manifes perakitan.  Mereka dapat disimpan dalam file <abbr title="Eksekusi portabel">PE</abbr> bersama dengan kode <abbr title="Bahasa menengah">IL</abbr> atau dalam file PE terpisah, di mana hanya akan ada manifes perakitan. <br>  <b>Atribut</b> adalah karakteristik dari suatu tipe atau anggotanya (atau konstruksi bahasa lainnya) yang berisi informasi deskriptif.  Meskipun atribut yang paling umum sudah ditentukan sebelumnya dan memiliki format spesifik dalam metadata, atribut khusus juga dapat ditambahkan ke metadata.  Atribut bersifat komutatif, mis.  urutan deklarasi mereka atas elemen tidak penting <br><br>  <b>Dari sudut pandang sintaksis (dalam metadata), ada atribut berikut</b> <br><br><ol><li>  Menggunakan sintaks khusus dalam IL.  Misalnya, kata kunci adalah atribut.  Dan bagi mereka ada sintaks khusus di IL.  Ada cukup banyak dari mereka, daftar semuanya tidak masuk akal </li><li>  Menggunakan sintaks umum.  Ini termasuk atribut pengguna dan perpustakaan. </li><li>  Atribut keamanan.  Ini termasuk atribut yang mewarisi dari SecurityAttribute (langsung atau tidak langsung).  Mereka diproses dengan cara khusus.  Ada sintaks khusus untuk mereka di IL, yang memungkinkan Anda membuat xml yang menggambarkan atribut ini secara langsung </li></ol><br><h4>  Contoh </h4><br><div class="spoiler">  <b class="spoiler_title">Kode C # yang berisi semua jenis atribut di atas</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Menghasilkan IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Seperti yang Anda lihat, StructLayoutAttribute memiliki sintaks khusus, karena di IL direpresentasikan sebagai "eksplisit".  ObsoleteAttribute menggunakan sintaksis umum - di IL dimulai dengan ".custom".  SecurityPermissionAttribute sebagai atribut keamanan telah berubah menjadi ".permissionsetertert menegaskan". <br><br>  Atribut pengguna menambahkan informasi pengguna ke metadata.  Mekanisme ini dapat digunakan untuk menyimpan informasi spesifik aplikasi pada waktu kompilasi dan untuk mengaksesnya pada saat dijalankan atau untuk dibaca dan dianalisis oleh alat lain.  Meskipun setiap tipe yang ditentukan pengguna dapat digunakan sebagai atribut, kesesuaian <abbr title="Spesifikasi bahasa umum">CLS</abbr> mensyaratkan bahwa atribut mewarisi dari System.Attribute.  <abbr title="Infrastruktur bahasa umum">CLI</abbr> menentukan beberapa atribut dan menggunakannya untuk mengontrol perilaku runtime.  Beberapa bahasa mendefinisikan atribut untuk mewakili fitur bahasa yang tidak diwakili secara langsung di CTS. <br><br>  Seperti yang telah disebutkan, atribut disimpan dalam metadata, yang, pada gilirannya, dihasilkan pada tahap kompilasi, mis.  dimasukkan dalam file PE (biasanya * .dll).  Dengan demikian, Anda dapat menambahkan atribut saat runtime hanya dengan memodifikasi file yang dapat dieksekusi saat runtime (tetapi waktu program yang mengubah diri sudah lama hilang).  Oleh karena itu mereka tidak dapat ditambahkan pada tahap eksekusi, tetapi ini tidak sepenuhnya akurat.  Jika kita membentuk rakitan kita, tentukan tipe di dalamnya, maka kita dapat membuat tipe baru pada tahap eksekusi dan menggantung atribut di atasnya.  Jadi secara formal, kita masih bisa menambahkan atribut saat runtime (contohnya ada di paling bawah). <br><br><h4>  Sekarang sedikit tentang batasannya </h4><br>  Jika karena alasan tertentu ada 2 atribut dalam rakitan yang sama dengan nama Name dan NameAtribute, maka menjadi tidak mungkin untuk menempatkan yang pertama dari mereka.  Saat menggunakan [Nama] (yaitu, tanpa akhiran), kompiler mengatakan ia melihat ketidakpastian.  Saat menggunakan [NameAttribute] kita akan meletakkan NameAttribute, yang logis.  Ada sintaksis khusus untuk situasi mistis seperti itu dengan kurangnya imajinasi saat memberi nama.  Untuk menempatkan versi pertama tanpa akhiran, Anda dapat menentukan tanda anjing (yaitu, [Nama] adalah lelucon, itu tidak perlu) sebelum nama atribut [@Nama]. <br><br>  Atribut khusus dapat ditambahkan ke apa pun selain atribut khusus.  Ini mengacu pada metadata, mis.  jika kita meletakkan atribut dalam C # di atas kelas atribut, maka dalam metadata itu akan merujuk ke kelas.  Tetapi Anda tidak dapat menambahkan atribut ke "publik".  Tetapi Anda dapat melakukannya dengan rakitan, modul, kelas, tipe nilai, enum, konstruktor, metode, properti, bidang, peristiwa, antarmuka, parameter, delegasi, nilai balik, atau parameter umum.  Contoh di bawah ini menunjukkan contoh yang jelas dan tidak terlalu tentang bagaimana Anda dapat menempatkan atribut pada konstruksi tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Sintaksis Deklarasi Atribut</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Atribut memiliki 2 jenis parameter - bernama dan posisional.  Parameter posisi termasuk parameter konstruktor.  Untuk menamai - properti publik dengan setter yang dapat diakses.  Selain itu, ini bukan hanya nama formal, semua parameter dapat ditunjukkan saat mendeklarasikan atribut dalam tanda kurung setelah namanya.  Yang disebutkan adalah opsional. <br><br><div class="spoiler">  <b class="spoiler_title">Jenis-jenis Parameter</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  Parameter yang valid (dari kedua jenis) untuk atribut harus salah satu dari jenis berikut: <br><br><ol><li>  bool, byte, char, double, float, int, panjang, pendek, string dan selanjutnya pada primitif, kecuali desimal </li><li>  objek </li><li>  Jenis Sistem </li><li>  enum </li><li>  Array satu dimensi dari salah satu tipe di atas </li></ol><br>  Ini sebagian besar disebabkan oleh fakta bahwa ia harus berupa konstanta waktu kompilasi, dan tipe-tipe di atas dapat menerima konstanta ini (dengan menerima objek yang dapat kita lewati int).  Tetapi untuk beberapa alasan, argumen tidak bisa dari tipe ValueType, meskipun ini mungkin dari sudut pandang logis. <br><br>  Ada dua jenis atribut pengguna: atribut custom asli dan <b>pseudo-custom</b> . <br>  Dalam kode, mereka terlihat sama (ditunjukkan di atas struktur bahasa dalam tanda kurung), tetapi mereka diproses secara berbeda: <br><br><ol><li>  Atribut pengguna asli disimpan langsung di metadata;  parameter atribut disimpan apa adanya.  Mereka tersedia saat runtime dan disimpan sebagai satu set byte (saya harus mengingatkan Anda bahwa mereka dikenal pada waktu kompilasi) </li><li>  Atribut pseudo-pengguna dikenali karena namanya adalah salah satu dari daftar khusus.  Alih-alih menyimpan datanya secara langsung dalam metadata, itu dianalisis dan digunakan untuk mengatur bit atau bidang dalam tabel metadata, dan data tersebut kemudian dibuang dan tidak dapat diterima lebih lanjut.  Tabel metadata diperiksa pada waktu runtime lebih cepat daripada atribut pengguna asli, dan penyimpanan yang lebih sedikit diperlukan untuk menyimpan informasi. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Atribut pseudo-pengguna tidak refleksi terlihat</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  Sebagian besar atribut pengguna diperkenalkan di tingkat bahasa.  Mereka disimpan dan dikembalikan oleh runtime, sedangkan runtime tidak tahu apa-apa tentang arti dari atribut ini.  Tetapi semua atribut pseudo-pengguna ditambah beberapa atribut pengguna sangat menarik bagi penyusun dan CLI.  Jadi kita beralih ke bagian selanjutnya. <br><br><h2>  Atribut yang diaktifkan runtime </h2><br>  Bagian ini murni informatif, jika tidak ada minat menggunakan runtime, maka Anda dapat menggulir ke bagian berikutnya. <br><br>  Tabel di bawah ini mencantumkan atribut pseudo-pengguna dan atribut pengguna khusus (CLI atau kompiler menanganinya dengan cara khusus). <br><br>  Atribut pseudo-pengguna (mereka tidak dapat diperoleh melalui refleksi). <br>  Atribut CLI: <br><div class="scrollable-table"><table><tbody><tr><th>  Atribut </th><th>  Deskripsi </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  Menulis pengidentifikasi algoritma hash yang digunakan.  Mengatur bidang Assembly.HashAlgId </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  Menulis bendera untuk rakitan yang sesuai.  Setel bidang Assembly.Flags </td></tr><tr><td>  DllImportAttribute </td><td>  Memberikan informasi tentang kode yang diterapkan di perpustakaan yang tidak dikelola.  Set bit Method.Flags.PinvokeImpl dari metode yang sesuai;  menambahkan entri baru ke ImplMap (dengan menetapkan nilai MappingFlags, MemberForwarded, ImportName, dan ImportScope) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Memungkinkan Anda menetapkan metode penempatan bidang referensi atau tipe signifikan secara eksplisit.  Setel bidang TypeDef.Flags.LayoutMask untuk jenisnya.  Ini juga dapat mengatur bidang TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize dan ClassLayout.ClassSize </td></tr><tr><td>  FieldOffsetAttribute </td><td>  Menentukan byte offset bidang dalam referensi atau tipe signifikan.  Menetapkan nilai FieldLayout.OffSet untuk metode yang sesuai. </td></tr><tr><td>  Kurang </td><td>  Menunjukkan bahwa parameter dilewatkan sebagai argumen [dalam].  Mengatur bit Param.Flags.In untuk parameter yang sesuai. </td></tr><tr><td>  Mengungguli </td><td>  Menunjukkan bahwa parameter dilewatkan sebagai argumen [keluar].  Mengatur bit Param.Flags.Out untuk parameter yang sesuai. </td></tr><tr><td>  Marshalasattribute </td><td>  Menentukan bagaimana data disusun antara kode yang dikelola dan tidak dikelola.  Set bit Field.Flags.HasFieldMarshal untuk bidang (atau bit Param.Flags.HasFieldMarshal untuk parameter);  Menambahkan entri ke tabel FieldMarshal (dengan mengatur nilai-nilai Parent dan NativeType) </td></tr><tr><td>  MethodImplAttribute </td><td>  Menentukan detail implementasi untuk suatu metode.  Menetapkan nilai Method.ImplFlags untuk metode yang sesuai </td></tr></tbody></table></div><br><br>  Atribut CLS - Bahasa harus mendukungnya: <br><div class="scrollable-table"><table><tbody><tr><th>  Atribut </th><th>  Deskripsi </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Digunakan untuk menunjukkan bagaimana suatu atribut dapat digunakan. </td></tr><tr><td>  Usang Atribut </td><td>  Menunjukkan bahwa item tersebut tidak boleh digunakan. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Menunjukkan apakah suatu barang dinyatakan sebagai sesuai CLS. </td></tr></tbody></table></div><br>  Lain-lain yang menarik <br><div class="scrollable-table"><table><tbody><tr><th>  Atribut </th><th>  Deskripsi </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Menyediakan bidang tipe terkait aliran </td></tr><tr><td>  ConditionalAttribute </td><td>  Menandai metode sebagai dipanggil berdasarkan kondisi kompilasi (ditentukan dalam / define).  Jika kondisi tidak terpenuhi, maka metode tidak akan dipanggil (dan tidak akan dikompilasi ke IL).  Hanya metode void yang dapat ditandai.  Kalau tidak, kesalahan kompilasi akan terjadi. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Menyimpan nilai konstan desimal dalam metadata </td></tr><tr><td>  DefaultMemberAttribute </td><td>  Menentukan anggota kelas untuk digunakan secara default dengan metode InvokeMember. </td></tr><tr><td>  KompilasiRelaksasiAttribute </td><td>  Menunjukkan apakah pengecualian untuk pemeriksaan instruksi ketat atau santai.  Saat ini, Anda hanya dapat melewatkan parameter NoStringInterning, yang menandai perakitan sebagai tidak memerlukan string literal magang.  Namun mekanisme ini masih bisa digunakan. </td></tr><tr><td>  FlagsAttribute </td><td>  Atribut yang menunjukkan apakah enum harus diperlakukan sebagai flag bit </td></tr><tr><td>  IndexerNameAttribute </td><td>  Menentukan nama pengindeks yang akan dikenal dalam bahasa pemrograman yang tidak secara langsung mendukung fitur ini. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Menunjukkan bahwa metode menerima sejumlah parameter variabel. </td></tr></tbody></table></div><br><h2>  Atribut yang Berguna </h2><br>  Bagian integral dari pengembangan produk perangkat lunak adalah debugging.  Dan seringkali dalam sistem yang besar dan kompleks dibutuhkan puluhan dan ratusan kali untuk menjalankan metode yang sama dan memantau keadaan objek.  Pada saat yang sama, pada waktu 20 sudah mulai membuat marah kebutuhan khusus untuk memperluas satu objek dalam 400 kali untuk melihat nilai satu variabel dan me-restart metode lagi. <br>  Untuk debugging yang lebih tenang dan lebih cepat, Anda bisa menggunakan atribut yang mengubah perilaku debugger. <br><br>  <b>DebuggerDisplayAttribute</b> menunjukkan bagaimana tipe atau anggotanya ditampilkan di jendela variabel debugger (dan tidak hanya). <br><br>  Satu-satunya argumen untuk konstruktor adalah string dengan format tampilan.  Apa yang akan terjadi antara kawat gigi akan dihitung.  Formatnya seperti string interpolasi, hanya tanpa dolar.  Anda tidak dapat menggunakan pointer dalam nilai yang dihitung.  Omong-omong, jika Anda memiliki ToString yang diganti, maka nilainya akan ditampilkan seolah-olah berada di atribut ini.  Jika ada ToString dan atribut, maka nilainya diambil dari atribut tersebut. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> mendefinisikan bagaimana bidang atau properti ditampilkan di jendela variabel debugger.  Menerima DebuggerBrowsableState, yang memiliki 3 opsi: <br><br><ul><li>  Tidak pernah - bidang tidak ditampilkan sama sekali selama debugging.  Saat memperluas hierarki objek, bidang ini tidak akan ditampilkan </li><li>  Runtuh - bidang tidak terpecahkan, tetapi dapat diperluas.  Ini adalah perilaku default. </li><li>  RootHidden - bidang itu sendiri tidak ditampilkan, tetapi objek yang terdiri ditampilkan (untuk array dan koleksi) </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> - jika objek dilihat dalam debugger ratusan kali sehari, Anda bisa bingung dan menghabiskan 3 menit membuat objek proxy yang menampilkan objek asli sebagaimana mestinya.  Biasanya, objek proxy untuk ditampilkan adalah kelas dalam.  Sebenarnya, itu akan ditampilkan bukan objek target. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Atribut berguna lainnya <br><br>  <b>ThreadStatic</b> - atribut yang memungkinkan Anda membuat variabel statis sendiri untuk setiap utas.  Untuk melakukan ini, letakkan atribut di atas bidang statis.  Perlu diingat nuansa penting - inisialisasi oleh konstruktor statis akan dilakukan hanya sekali, dan variabel akan berubah di utas yang akan dijalankan oleh konstruktor statis.  Selebihnya, itu akan tetap default.  (PS. Jika Anda memerlukan perilaku ini, saya menyarankan Anda untuk melihat ke arah kelas ThreadLocal). <br><br>  Sedikit tentang nuansa kompartemen mesin.  Baik di Linux dan Windows, ada area memori lokal untuk streaming ( <abbr title="Utas penyimpanan lokal">TLS</abbr> dan <abbr title="Data khusus utas">TSD,</abbr> masing-masing).  Namun, area ini sendiri sangat kecil.  Oleh karena itu, struktur ThreadLocalInfo dibuat, sebuah penunjuk yang ditempatkan di TLS.  Dengan demikian, hanya satu slot yang digunakan.  Struktur itu sendiri berisi 3 bidang - Utas, AppDomain, ClrTlsInfo.  Kami tertarik pada yang pertama.  Dialah yang mengatur penyimpanan statika aliran dalam memori, menggunakan ThreadLocalBlock dan ThreadLocalModule untuk ini. <br><br>  Dengan cara ini: <br><br><ul><li>  Jenis referensi - terletak di heap, ThreadStaticHandleTable, yang didukung oleh kelas ThreadLocalBlock, menyimpan tautan ke sana. </li><li>  Struktur - Dikemas dan disimpan dalam tumpukan yang dikelola serta jenis referensi </li><li>  Tipe signifikan primitif disimpan di area memori yang tidak dikelola yang merupakan bagian dari ThreadLocalModule </li></ul><br>  Nah, karena kita berbicara tentang ini, perlu disebutkan tentang metode asinkron.  Seperti yang mungkin diperhatikan oleh pembaca yang perhatian, jika kita menggunakan asinkron, maka kelanjutan tidak harus dieksekusi di utas yang sama (kita dapat memengaruhi konteks eksekusi, tetapi bukan utas).  Karenanya, kami mendapatkan omong kosong jika kami menggunakan ThreadLocal.  Dalam hal ini, disarankan untuk menggunakan AsyncLocal.  Tapi artikelnya bukan tentang ini, jadi kami melangkah lebih jauh. <br><br>  <b>InternalsVisibleTo</b> - memungkinkan Anda menentukan rakitan, yang akan terlihat oleh elemen yang ditandai <i>internal</i> .  Tampaknya jika beberapa majelis membutuhkan jenis tertentu dan anggotanya, Anda dapat dengan mudah menandai mereka di depan <i>umum</i> dan bukan uap.  Tetapi arsitektur yang baik menyiratkan menyembunyikan detail implementasi.  Namun demikian, mereka mungkin diperlukan untuk beberapa hal infrastruktur, misalnya, proyek uji.  Dengan menggunakan atribut ini, Anda dapat mendukung enkapsulasi dan persentase cakupan pengujian yang diperlukan. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> - memungkinkan Anda untuk menakut-nakuti programmer yang pemalu dan menangkap pengecualian dari kondisi yang rusak.  Secara default, untuk pengecualian seperti itu, CLR tidak menjebak.  Secara umum, solusi terbaik adalah membiarkan aplikasi crash.  Ini adalah pengecualian berbahaya yang menunjukkan bahwa memori proses rusak, jadi menggunakan atribut ini adalah ide yang sangat buruk.  Tetapi mungkin dalam beberapa kasus, untuk pengembangan lokal akan berguna untuk mengatur atribut ini untuk sementara waktu.  Untuk mengetahui pengecualian kondisi rusak, cukup letakkan atribut ini di atas metode.  Dan jika telah mencapai penggunaan atribut ini, disarankan (namun, seperti biasa) untuk menangkap beberapa pengecualian khusus. <br><br>  <b>DisablePrivateReflection</b> - membuat semua anggota pribadi majelis tidak dapat dijangkau untuk refleksi.  Atribut diletakkan di majelis. <br><br><h2>  Menentukan Atribut Anda </h2><br>  Bukan hanya karena bagian ini adalah yang terakhir.  Lagi pula, cara terbaik untuk memahami dalam kasus apa akan bermanfaat untuk menggunakan atribut adalah dengan melihat yang sudah digunakan.  Sulit untuk mengatakan aturan formal ketika Anda harus memikirkan atribut Anda sendiri.  Seringkali mereka digunakan sebagai informasi tambahan tentang jenis / anggotanya atau konstruksi bahasa lain yang umum untuk entitas yang sama sekali berbeda.  Sebagai contoh, semua atribut yang digunakan untuk serialisasi / ORM / pemformatan, dll.  Karena aplikasi yang luas dari mekanisme ini untuk jenis yang sama sekali berbeda, sering tidak diketahui oleh pengembang mekanisme yang sesuai, penggunaan atribut adalah cara yang bagus untuk memungkinkan pengguna untuk memberikan informasi deklaratif untuk mekanisme ini. <br><br>  Menggunakan atribut Anda dapat dibagi menjadi 2 bagian: <br><br><ol><li>  Membuat atribut dan menggunakannya </li><li>  Mendapatkan atribut dan memprosesnya </li></ol><br><h4>  Membuat atribut dan menggunakannya </h4><br>  Untuk membuat atribut Anda, cukup mewarisi dari <i>System.Attribute</i> .  Dalam hal ini, disarankan untuk mematuhi gaya penamaan yang disebutkan - akhiri nama kelas pada Atribut.  Namun, tidak akan ada kesalahan jika Anda menghilangkan sufiks ini.  Seperti disebutkan sebelumnya, atribut dapat memiliki 2 jenis parameter - posisi dan nama.  Logika aplikasi mereka sama dengan properti dan parameter konstruktor kelas - nilai yang diperlukan untuk membuat objek yang tidak ada "default" yang masuk akal ditempatkan dalam posisi (yaitu, konstruktor).  Apa yang dapat secara wajar default, yang akan sering digunakan, lebih baik dibedakan menjadi satu bernama (yaitu properti). <br><br>  Yang tidak kalah pentingnya dalam menciptakan atribut adalah keterbatasan tempat aplikasinya.  AttributeUsageAttribute digunakan untuk ini.  Parameter yang diperlukan (posisional) adalah AttributeTarget, yang menentukan di mana atribut digunakan (metode, perakitan, dll.).  Parameter opsional (bernama) adalah: <br><br><ol><li>  AllowMultiple - menunjukkan apakah mungkin untuk menempatkan lebih dari satu atribut di atas tempat penerapannya atau tidak.  Salah secara default </li><li>  Mewarisi - menentukan apakah atribut ini akan menjadi milik pewaris kelas (dalam hal penempatan di atas kelas dasar) dan metode yang diganti (dalam kasus penempatan di atas metode).  Defaultnya benar. </li></ol><br>  Setelah itu, Anda dapat memuat atribut dengan payload.  Atribut adalah informasi deklaratif, yang berarti segala sesuatu yang didefinisikan di dalamnya harus menggambarkan konstruksi yang terkait.  Atribut tidak boleh mengandung logika yang mendalam.  Untuk pemrosesan atribut yang Anda tentukan, layanan khusus harus bertanggung jawab yang hanya akan memprosesnya.  Tetapi fakta bahwa atribut tidak boleh memiliki logika tidak berarti bahwa itu tidak boleh memiliki metode. <br><br>  Suatu metode (fungsi) juga merupakan informasi dan juga dapat menggambarkan suatu desain.  Dan menggunakan polimorfisme dalam atribut, Anda dapat memberikan alat yang sangat kuat dan nyaman di mana pengguna dapat memengaruhi informasi yang digunakan oleh alat Anda dan tahapan eksekusi dan pemrosesan tertentu.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, ia tidak perlu membuat kelas, menyuntikkan dependensi, biaya pabrik dan antarmuka mereka yang akan membuat kelas ini. </font><font style="vertical-align: inherit;">Itu akan cukup untuk membuat kelas pewaris tunggal yang merangkum detail bekerja dengan elemen yang terkait. </font><font style="vertical-align: inherit;">Tetapi, sebagai aturan, atribut ROSO biasa dengan beberapa properti sudah cukup.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengambil dan memproses atribut </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan atribut yang diterima tergantung pada kasus spesifik dan dapat dilakukan dengan cara yang sangat berbeda. Sulit untuk memberikan fungsi dan trik yang bermanfaat untuk ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut diperoleh pada saat run time menggunakan refleksi. Ada berbagai cara untuk mendapatkan atribut dari elemen tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi semuanya berasal dari antarmuka </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini diimplementasikan oleh tipe seperti Assembly, MemberInfo, Module, ParameterInfo. Pada gilirannya, penerus MemberInfo adalah Jenis, EventInfo, FieldInfo, MethodBase, PropertyInfo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka hanya memiliki 3 fungsi, dan mereka tidak terlalu nyaman. Mereka bekerja dengan array (bahkan jika kita tahu bahwa hanya ada satu atribut) dan tidak parameter berdasarkan tipe (mereka menggunakan objek). Karena itu, Anda jarang harus secara langsung mengakses fungsi antarmuka ini (saya tidak pernah mengatakannya karena saya tidak ingin menjadi kategori). Untuk kemudahan penggunaan, ada kelas </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana ada banyak metode ekstensi untuk semua jenis jenis yang melakukan operasi sederhana untuk casting, memilih nilai tunggal, dan sebagainya, sehingga membebaskan pengembang dari kebutuhan ini. Selain itu, metode ini tersedia sebagai statis di kelas Atribut dengan fungsi yang paling berguna untuk mengabaikan parameter inherit (untuk non-konformis).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi utama yang digunakan tercantum di bawah ini. </font><font style="vertical-align: inherit;">Parameter pertama yang menunjukkan tipe mana yang memperluas metode, saya hilangkan. </font><font style="vertical-align: inherit;">Juga, di mana pun parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pewarisan bool ditentukan,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada kelebihan tanpa itu (dengan nilai default </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Parameter ini menentukan apakah atribut dari kelas induk atau metode dasar harus dipertimbangkan ketika mengeksekusi metode (jika digunakan pada metode yang diganti). </font><font style="vertical-align: inherit;">Jika dalam atribut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inherit = flase</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka bahkan menyetelnya ke true tidak akan membantu memperhitungkan atribut dari kelas dasar</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nama metode </font></font></th><th>  Deskripsi </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt; (bool inherit) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mendapat enumerasi atribut dari tipe yang ditentukan. </font><font style="vertical-align: inherit;">Jika atribut adalah satu, enumerasi 1 elemen akan dikembalikan</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt; (bool inherit) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan atribut tunggal dari tipe yang ditentukan. </font><font style="vertical-align: inherit;">Jika ada beberapa, buang </font><i><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException: Beberapa atribut khusus dari jenis yang sama ditemukan</font></i><font style="vertical-align: inherit;"> pengecualian</font></font><i><font style="vertical-align: inherit;"></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan penghitungan atribut dari semua jenis </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan enumerasi CustomAttributeData, di mana ada properti yang memungkinkan Anda untuk mendapatkan konstruktor, parameter (dinamai dan posisional), argumen konstruktor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined (Ketikkan attrType, bool inherit) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan true jika atribut dideklarasikan di atas elemen, false jika tidak </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk kejelasan, saya mengusulkan untuk melihat demo kecil dari semua fungsi yang disebutkan. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai pengembalian metode di atas</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, untuk kepentingan akademis, saya memberikan contoh mendefinisikan atribut saat runtime. </font><font style="vertical-align: inherit;">Kode ini tidak mengklaim sebagai yang paling indah dan didukung.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468287/">https://habr.com/ru/post/id468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468263/index.html">Katakan halo ke terminal Visual Studio yang baru</a></li>
<li><a href="../id468265/index.html">Membuat permen dari Vim</a></li>
<li><a href="../id468271/index.html">Tes vs Jenis - Versi karat</a></li>
<li><a href="../id468277/index.html">Apakah pekerjaan programmer itu sulit - pandangan dari sudut pandang psikofisiologi</a></li>
<li><a href="../id468285/index.html">Perusahaan Pengembangan Perangkat Lunak Teratas untuk Perusahaan & Startup</a></li>
<li><a href="../id468289/index.html">Pagi</a></li>
<li><a href="../id468291/index.html">Sinopsis dari buku Mark Gaulston "I Can Hear You Through"</a></li>
<li><a href="../id468293/index.html">Vive Cosmos - tinjauan set VR baru dari HTC</a></li>
<li><a href="../id468295/index.html">50 nuansa matplotlib - The Master Plots (dengan kode Python penuh)</a></li>
<li><a href="../id468299/index.html">Apa yang harus dikembangkan Oracle untuk pengembang pada 2019 (dan setelahnya)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>