<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌗 🧒🏼 🦍 Visuelle Regressionstests. Starten Sie neu 👨🏽‍🎤 ◀️ 🤛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Artikel habe ich über die Erfahrungen mit der Verwendung der Gemini- Engine zur Entwicklung von visuellen Tests bzw. visuellen Re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visuelle Regressionstests. Starten Sie neu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  In meinem vorherigen <a href="https://habr.com/ru/post/454464/">Artikel habe</a> ich über die Erfahrungen mit der Verwendung der <a href="https://github.com/gemini-testing/gemini">Gemini-</a> Engine zur Entwicklung von visuellen Tests bzw. visuellen Regressionstests gesprochen.  Bei solchen Tests wird überprüft, ob sich nach den nächsten Änderungen etwas in der Benutzeroberfläche „bewegt“ hat, indem die aktuellen Screenshots mit den zuvor festgelegten Referenz-Screenshots verglichen werden.  Seitdem hat sich in unseren Ansätzen zum Schreiben von visuellen Tests viel geändert, einschließlich der verwendeten Engine.  Jetzt verwenden wir <a href="https://github.com/gemini-testing/hermione">Hermine</a> , aber in diesem Artikel werde ich nicht nur und nicht so sehr von Hermine erzählen, sondern auch von den Problemen, die sich seitdem angesammelt haben, und wie man sie löst, was unter anderem zum Übergang zu einem neuen Motor führte. <br><a name="habracut"></a><br>  Erstens hatten wir, obwohl die Tests erfolgreich waren, kein klares Verständnis darüber, was von den Tests abgedeckt wurde und was nicht.  Es gab natürlich eine Vorstellung von dem Abdeckungsgrad, aber wir haben ihn nicht quantitativ gemessen.  Zweitens nahm die Zusammensetzung der Tests mit der Zeit zu und verschiedene Tests testeten oft das Gleiche, weil  In verschiedenen Screenshots stimmte ein Teil mit dem gleichen Teil überein, jedoch in einem anderen Screenshot.  Infolgedessen können selbst geringfügige Änderungen an CSS viele Tests auf einmal überfordern und die Aktualisierung einer großen Anzahl von Standards erforderlich machen.  Drittens tauchte in unserem Produkt ein dunkles Thema auf, und um es irgendwie mit Tests abzudecken, wurden einige Tests selektiv auf die Verwendung eines dunklen Themas umgestellt, was das Problem bei der Bestimmung des Abdeckungsgrads ebenfalls nicht klarer machte. <br><br><h2>  Leistungsoptimierung </h2><br>  Wir begannen seltsamerweise mit einer optimierten Leistung.  Ich werde erklären warum.  Unsere visuellen Tests basieren auf dem <a href="https://github.com/storybooks/storybook">Storybook</a> .  Jede Story im Storybook ist keine einzelne Komponente, sondern ein ganzer „Block“ (z. B. ein Raster mit einer Liste von Entitäten, einer Entitätskarte, einem Dialog oder sogar der gesamten Anwendung).  Um diesen Block anzuzeigen, müssen Sie die Story mit Daten „pumpen“, und zwar nicht nur mit den Daten, die dem Benutzer angezeigt werden, sondern auch mit dem Status der im Block verwendeten Komponenten.  Diese Informationen werden zusammen mit dem Quellcode in Form von JSON-Dateien gespeichert, die eine serialisierte Darstellung des Status der Anwendung enthalten (Redux Store).  Ja, diese Daten sind, gelinde gesagt, redundant, vereinfachen jedoch die Erstellung von Tests erheblich.  Um einen neuen Test zu erstellen, öffnen wir einfach die gewünschte Karte, Liste oder den gewünschten Dialog in der Anwendung, machen einen Schnappschuss des aktuellen Status der Anwendung und serialisieren ihn in eine Datei.  Dann fügen wir eine neue Story und Tests hinzu, die Screenshots dieser Story enthalten (alles in wenigen Codezeilen). <br><br>  Dieser Ansatz erhöht zwangsläufig die Größe des Bündels.  Der Grad der Vervielfältigung von Daten in ihm "rollt" nur über.  Bei der Ausführung von Tests führt die Gemini-Engine jede Testsuite in einer separaten Browsersitzung aus.  Bei jeder Sitzung wird das Bundle erneut geladen, und die Größe des Bundles in einem solchen Schema ist weit vom letzten Wert entfernt. <br><br>  Um die Testlaufzeit zu verkürzen, haben wir die Anzahl der Testsuiten reduziert, indem wir die Anzahl der darin enthaltenen Tests erhöht haben.  Somit kann eine Testsuite mehrere Storys gleichzeitig betreffen.  In diesem Schema haben wir praktisch die Möglichkeit verloren, nur einen bestimmten Bereich des Bildschirms zu "screenen", da Sie in Gemini den Screenshot-Bereich nur für die Testsuite als Ganzes festlegen können (obwohl die API dies vor jedem Screenshot zulässt, aber in der Praxis nicht funktioniert). <br><br>  Die Unfähigkeit, den Bereich des Screenshots in den Tests einzuschränken, führte zu einer Verdoppelung der visuellen Informationen in den Referenzbildern.  Obwohl es nicht viele Tests gab, schien dieses Problem nicht signifikant zu sein.  Ja, und die Benutzeroberfläche hat sich nicht sehr oft geändert.  Dies konnte jedoch nicht ewig so weitergehen - eine Neugestaltung zeichnete sich ab. <br><br>  Mit Blick auf die Zukunft sage ich, dass in Hermine für jede Aufnahme ein Screenshot-Bereich eingerichtet werden kann und auf den ersten Blick der Wechsel zu einer neuen Engine alle Probleme lösen würde.  Aber wir müssten immer noch große Testsuiten "zerquetschen".  Tatsache ist, dass visuelle Tests von Natur aus nicht stabil sind (dies kann verschiedene Gründe haben, z. B. Netzwerkverzögerungen, Animationen oder „Wetter auf dem Mars“) und es ist sehr schwierig, auf automatische Wiederholungsversuche zu verzichten.  Sowohl Gemini als auch Hermine führen Wiederholungsversuche für die gesamte Testsuite durch. Je „dicker“ die Testsuite ist, desto unwahrscheinlicher ist es, dass sie während der Wiederholungsversuche erfolgreich abgeschlossen wird  Bei der nächsten Ausführung fallen möglicherweise Tests aus, die zuvor erfolgreich abgeschlossen wurden.  Für dicke Testsuiten mussten wir ein alternatives Wiederholungsschema implementieren, das in die Gemini-Engine integriert war, und wollten dies beim Umstieg auf eine neue Engine nicht noch einmal tun. <br><br>  Um das Laden der Testsuite zu beschleunigen, haben wir das monolithische Bündel in Teile aufgeteilt und jeden Snapshot des Anwendungszustands in ein separates "Teil" aufgeteilt, das "bei Bedarf" für jede Story separat geladen wird.  Der Code zur Erstellung der Story sieht nun folgendermaßen aus: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Zum Erstellen einer Story wird die StoryProvider-Komponente verwendet (der Code wird unten angegeben).  Schnappschüsse werden mit der <a href="https://webpack.js.org/guides/code-splitting/">dynamischen Importfunktion</a> geladen.  Verschiedene Geschichten unterscheiden sich nur in Bildern von Staaten.  Für ein dunkles Thema wird eine eigene Geschichte generiert, wobei derselbe Schnappschuss als Geschichte für ein helles Thema verwendet wird.  Im Kontext eines Bilderbuchs sieht es so aus: <br><br><div class="spoiler">  <b class="spoiler_title">Standard-Themengeschichte</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dunkle Themengeschichte</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  Die StoryProvider-Komponente akzeptiert einen Rückruf zum Laden eines Snapshots, in dem die Funktion import () aufgerufen wird.  Die Funktion import () arbeitet asynchron, sodass Sie nicht sofort nach dem Laden der Story einen Screenshot machen können - wir riskieren, die Lücke zu entfernen.  Um den Moment des Endes des Downloads zu erfassen, rendert der Anbieter das Marker-DOM-Element, das die Test-Engine für die Dauer des Downloads signalisiert. Dies muss mit dem Screenshot verzögert werden: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Deaktivieren Sie außerdem das Hinzufügen von Quellzuordnungen zum Bundle, um die Größe des Bundles zu verringern.  Um jedoch nicht die Fähigkeit zu verlieren, die Story zu debuggen (Sie wissen nie was), tun wir dies unter der Bedingung: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  Das <b>Build-Storybook-Skript npm run</b> kompiliert ein statisches Storybook ohne Quellkarte in den Ordner storybook-static.  Es wird bei der Durchführung von Tests verwendet.  Das <b>Storybook-Skript npm run</b> wird zum Entwickeln und Debuggen von Teststories verwendet. <br><br><h2>  Beseitigung von Duplikaten visueller Informationen </h2><br>  Wie bereits erwähnt, können Sie in Gemini für die Testsuite als Ganzes Auswahlmöglichkeiten für den Screenshot-Bereich festlegen. Um das Problem des Duplizierens visueller Informationen in den Screenshots vollständig zu lösen, müssten wir für jeden Screenshot eine eigene Testsuite erstellen.  Selbst unter Berücksichtigung der Optimierung des Ladens der Story sah es in Bezug auf die Geschwindigkeit nicht zu optimistisch aus, und wir dachten darüber nach, die Testmaschine zu wechseln. <br><br>  Eigentlich, warum Hermine?  Momentan ist das Gemini-Repository als veraltet markiert und früher oder später mussten wir irgendwohin „umziehen“.  Die Struktur der Hermine-Konfigurationsdatei ist identisch mit der Struktur der Gemini-Konfigurationsdatei und wir konnten diese Konfiguration wiederverwenden.  Zwillinge und Hermine Plugins sind ebenfalls üblich.  Darüber hinaus konnten wir die Testinfrastruktur - virtuelle Maschinen und eingesetztes Selen-Grid - wiederverwenden. <br><br>  Im Gegensatz zu Gemini ist Hermine nicht nur als Werkzeug für Regressionstests des Layouts positioniert.  Die Funktionen zur Browser-Manipulation sind viel umfangreicher und nur durch die Funktionen von <a href="http://v4.webdriver.io/">Webdriver IO eingeschränkt</a> .  In Kombination mit <a href="https://github.com/mochajs/mocha">Mokka</a> eignet sich diese Engine eher für Funktionstests (Simulation von Benutzeraktionen) als für Layouttests.  Für Regressionstests des Layouts stellt Hermine nur die assertView () -Methode zur Verfügung, die einen Screenshot einer Browserseite mit einer Referenz vergleicht.  Der Screenshot kann auf den Bereich beschränkt werden, der mit CSS-Selektoren festgelegt wurde. <br><br>  In unserem Fall würde der Test für jede einzelne Geschichte ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  Mit der waitForVisible () -Methode können Sie trotz ihres Namens nicht nur das Erscheinungsbild, sondern auch das Ausblenden des Elements erwarten, wenn Sie den zweiten Parameter auf true setzen.  Hier warten wir damit, bis ein Markerelement ausgeblendet ist. Dies zeigt an, dass der Datenschnappschuss noch nicht geladen ist und die Story noch nicht für einen Screenshot bereit ist. <br><br>  Wenn Sie versuchen, die waitForVisible () -Methode in der Hermine-Dokumentation zu finden, werden Sie nichts finden.  Tatsache ist, dass die waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">-Methode die Webdriver-IO-API-Methode ist</a> .  Auch die url () -Methode.  Bei der url () -Methode übergeben wir die Frame-Adresse einer bestimmten Story, nicht das gesamte Storybook.  Erstens ist dies erforderlich, damit die Story-Liste nicht im Browserfenster angezeigt wird - wir müssen sie nicht testen.  Zweitens können wir bei Bedarf auf DOM-Elemente innerhalb des Frames zugreifen (mit den webdriverIO-Methoden können Sie JavaScript-Code in einem Browserkontext ausführen). <br><br>  Um das Schreiben von Tests zu vereinfachen, haben wir unseren Wrapper über Mokka-Tests gemacht.  Tatsache ist, dass die detaillierte Ausarbeitung von Testfällen für Regressionstests keinen besonderen Sinn macht.  Alle Testfälle sind gleich - 'sollte gleich Etalon sein'.  Nun, ich möchte auch nicht den Code für das Warten auf das Laden von Daten in jedem Test duplizieren.  Daher wird die gleiche Arbeit für alle „Affentests“ an die Wrapper-Funktion delegiert, und die Tests selbst werden deklarativ (fast) geschrieben.  Hier ist der Text dieser Funktion: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Ein Objekt, das die Testsuite beschreibt, wird an den Eingang der Funktion übergeben.  Jede Testsuite wird gemäß dem folgenden Szenario erstellt: Wir erstellen einen Screenshot des Hauptlayouts (z. B. einen Bereich einer Entitätskarte oder einen Bereich einer Entitätsliste), drücken dann programmgesteuert Schaltflächen, die zum Erscheinen anderer Elemente führen können (z. B. Popup-Bedienfelder oder Kontextmenüs), und erstellen einen Screenshot »Jedes dieser Elemente separat.  Daher simulieren wir Benutzeraktionen im Browser, jedoch nicht mit dem Ziel, eine Art Geschäftsszenario zu testen, sondern lediglich die maximal mögliche Anzahl visueller Komponenten zu erfassen.  Darüber hinaus ist die Duplizierung visueller Informationen in den Screenshots minimal, weil  Screenshots werden "punktweise" mit Selektoren aufgenommen.  Beispiel für eine Testsuite: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Bestimmung der Deckung </h2><br>  Also, wir haben die Geschwindigkeit und Redundanz herausgefunden, es bleibt die Effektivität unserer Tests herauszufinden, dh den Grad der Abdeckung des Codes mit Tests zu bestimmen (hier mit Code meine ich CSS-Stylesheets). <br><br>  Für Teststories haben wir empirisch die kompliziertesten Karten, Listen und anderen Elemente ausgewählt, um mit einem Screenshot so viele Stile wie möglich abzudecken.  Um beispielsweise eine Entity-Karte zu testen, wurden Karten mit einer großen Anzahl verschiedener Arten von Steuerelementen (Text, Nummer, Übertragungen, Daten, Raster usw.) ausgewählt.  Karten für verschiedene Arten von Entitäten haben ihre eigenen Besonderheiten. Beispielsweise kann ein Bereich mit einer Liste von Dokumentversionen von einer Dokumentkarte angezeigt werden, und die Korrespondenz zu dieser Aufgabe wird auf der Aufgabenkarte angezeigt.  Dementsprechend wurden für jeden Entitätstyp eine eigene Story und eine Reihe typenspezifischer Tests usw. erstellt.  Am Ende stellten wir uns vor, dass alles mit Tests bedeckt zu sein schien, aber wir wollten ein bisschen mehr Selbstvertrauen als „mögen“. <br><br>  Um die Abdeckung in Chrome DevTools zu bewerten, gibt es ein Tool mit dem Namen Abdeckung, das für diesen Fall sehr gut geeignet ist: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  Mit Coverage können Sie bestimmen, welche Stile oder welcher js-Code beim Arbeiten mit der Browserseite verwendet wurden.  Der Bericht über die Verwendung von grünen Streifen gibt den verwendeten Code an, rot - nicht verwendet.  Und alles wäre in Ordnung, wenn wir eine Anwendung der Ebene "Hallo, Welt" hätten, aber was tun, wenn wir Tausende von Codezeilen haben?  Coverage-Entwickler haben dies gut verstanden und konnten den Bericht in eine Datei exportieren, die bereits programmgesteuert bearbeitet werden kann. <br><br>  Ich muss gleich sagen, dass wir bisher keine Möglichkeit gefunden haben, den Abdeckungsgrad automatisch zu erfassen.  Theoretisch kann dies mit dem Headless-Browser des Puppenspielers durchgeführt werden, aber der Puppenspieler arbeitet nicht unter der Kontrolle von Selen, was bedeutet, dass wir den Code unserer Tests nicht wiederverwenden können.  Lassen Sie uns dieses äußerst interessante Thema überspringen und mit Stiften arbeiten. <br><br>  Nachdem wir die Tests im manuellen Modus ausgeführt haben, erhalten wir einen Abdeckungsbericht, der eine JSON-Datei ist.  Im Bericht für jedes CSS, JS, TS, etc.  Die Datei gibt den Text (in einer Zeile) und die Intervalle des in diesem Text verwendeten Codes (in Form von Zeichenindizes dieser Zeile) an.  Unten ist ein Teil des Berichts: <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  Auf den ersten Blick ist es nicht schwierig, nicht verwendete CSS-Selektoren zu finden.  Aber was tun mit diesen Informationen?  In der Tat müssen wir letztendlich keine spezifischen Selektoren finden, sondern Komponenten, die wir vergessen haben, mit Tests abzudecken.  Stile einer Komponente können von mehr als einem Dutzend Selektoren festgelegt werden.  Basierend auf den Ergebnissen der Analyse des Berichts erhalten wir Hunderte nicht verwendeter Selektoren, und wenn Sie sich mit jedem von ihnen befassen, können Sie viel Zeit verlieren. <br><br>  Hier helfen uns reguläre Ausdrücke.  Natürlich funktionieren sie nur, wenn die Namenskonventionen für CSS-Klassen erfüllt sind (in unserem Code werden CSS-Klassen gemäß der BEM-Methode benannt - blockname_name_name_modifier).  Mithilfe von regulären Ausdrücken berechnen wir die eindeutigen Werte der Blocknamen, die den Komponenten nicht mehr schwer zuzuordnen sind.  Natürlich interessieren uns auch Elemente und Modifikatoren, aber nicht an erster Stelle müssen wir uns zuerst mit einem größeren „Fisch“ befassen.  Unten finden Sie ein Skript zum Verarbeiten eines Abdeckungsberichts <br><br><div class="spoiler">  <b class="spoiler_title">coverage.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Wir führen das Skript aus, indem wir zuerst die aus Chrome DevTools exportierte Datei coverage.json platzieren und den Auspuff in eine CSV-Datei schreiben: <br><br>  <b>node coverage.js&gt; coverage.csv</b> <br><br>  Sie können diese Datei mit Excel öffnen und die Daten analysieren, einschließlich der Bestimmung des Prozentsatzes der Codeabdeckung durch Tests. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Anstelle eines Lebenslaufs </h2><br>  Die Verwendung des Storybooks als Grundlage für visuelle Tests hat sich voll und ganz bewährt - wir haben einen ausreichenden Grad an Abdeckung des CSS-Codes mit Tests mit einer relativ geringen Anzahl von Storys und minimalen Kosten für die Erstellung neuer. <br><br>  Durch die Umstellung auf eine neue Engine konnten wir doppelte visuelle Informationen in Screenshots vermeiden, was die Unterstützung bestehender Tests erheblich vereinfachte. <br><br>  Der Abdeckungsgrad des CSS-Codes ist messbar und wird von Zeit zu Zeit überwacht.  Es stellt sich natürlich die große Frage, wie man die Notwendigkeit dieser Kontrolle nicht vergisst und wie man beim Sammeln von Informationen über die Berichterstattung etwas verpasst.  Idealerweise möchte ich den Abdeckungsgrad bei jedem Testlauf automatisch messen, damit die Tests bei Erreichen der festgelegten Schwelle fehlerhaft abfallen.  Wir werden daran arbeiten, wenn es Neuigkeiten gibt, werde ich es Ihnen auf jeden Fall sagen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479040/">https://habr.com/ru/post/de479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479022/index.html">Smart-Fernseher Samsung, LG, Vizio und TCL nehmen jede Sekunde "Fingerabdrücke" vom Bildschirm und senden sie an den Server</a></li>
<li><a href="../de479026/index.html">Echte Summe der Internetkanäle - OpenMPTCPRouter</a></li>
<li><a href="../de479034/index.html">Herstellen einer Verbindung zu einem Unternehmens-VPN unter Linux mithilfe von openconnect und vpn-slice</a></li>
<li><a href="../de479036/index.html">Intel kann die Nachfrage nach Prozessoren nicht befriedigen. HP und Dell leiden darunter</a></li>
<li><a href="../de479038/index.html">Digitale Transformation Leroy Merlin: Entwerfen einer Schnittstelle für die Arbeit mit Kundenanrufen</a></li>
<li><a href="../de479042/index.html">Mit der Y-Methode können Sie ganz einfach einen Rubik's Cube erstellen</a></li>
<li><a href="../de479044/index.html">Meine Ringpuffer-Implementierung in NOR-Flash</a></li>
<li><a href="../de479048/index.html">Node.js Streams für Dummies oder wie man mit Streams arbeitet</a></li>
<li><a href="../de479050/index.html">Patentrecherche in der IT. Der Kurs des jungen Kämpfers. Teil II Informationsquellen für die Patentrecherche</a></li>
<li><a href="../de479052/index.html">[Supercomputing 2019]. Multi-Cloud-Speicher als Anwendung für neue Kingston DC1000M-Laufwerke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>