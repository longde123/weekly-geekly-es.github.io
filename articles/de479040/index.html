<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåó üßíüèº ü¶ç Visuelle Regressionstests. Starten Sie neu üë®üèΩ‚Äçüé§ ‚óÄÔ∏è ü§õüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Artikel habe ich √ºber die Erfahrungen mit der Verwendung der Gemini- Engine zur Entwicklung von visuellen Tests bzw. visuellen Re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visuelle Regressionstests. Starten Sie neu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  In meinem vorherigen <a href="https://habr.com/ru/post/454464/">Artikel habe</a> ich √ºber die Erfahrungen mit der Verwendung der <a href="https://github.com/gemini-testing/gemini">Gemini-</a> Engine zur Entwicklung von visuellen Tests bzw. visuellen Regressionstests gesprochen.  Bei solchen Tests wird √ºberpr√ºft, ob sich nach den n√§chsten √Ñnderungen etwas in der Benutzeroberfl√§che ‚Äûbewegt‚Äú hat, indem die aktuellen Screenshots mit den zuvor festgelegten Referenz-Screenshots verglichen werden.  Seitdem hat sich in unseren Ans√§tzen zum Schreiben von visuellen Tests viel ge√§ndert, einschlie√ülich der verwendeten Engine.  Jetzt verwenden wir <a href="https://github.com/gemini-testing/hermione">Hermine</a> , aber in diesem Artikel werde ich nicht nur und nicht so sehr von Hermine erz√§hlen, sondern auch von den Problemen, die sich seitdem angesammelt haben, und wie man sie l√∂st, was unter anderem zum √úbergang zu einem neuen Motor f√ºhrte. <br><a name="habracut"></a><br>  Erstens hatten wir, obwohl die Tests erfolgreich waren, kein klares Verst√§ndnis dar√ºber, was von den Tests abgedeckt wurde und was nicht.  Es gab nat√ºrlich eine Vorstellung von dem Abdeckungsgrad, aber wir haben ihn nicht quantitativ gemessen.  Zweitens nahm die Zusammensetzung der Tests mit der Zeit zu und verschiedene Tests testeten oft das Gleiche, weil  In verschiedenen Screenshots stimmte ein Teil mit dem gleichen Teil √ºberein, jedoch in einem anderen Screenshot.  Infolgedessen k√∂nnen selbst geringf√ºgige √Ñnderungen an CSS viele Tests auf einmal √ºberfordern und die Aktualisierung einer gro√üen Anzahl von Standards erforderlich machen.  Drittens tauchte in unserem Produkt ein dunkles Thema auf, und um es irgendwie mit Tests abzudecken, wurden einige Tests selektiv auf die Verwendung eines dunklen Themas umgestellt, was das Problem bei der Bestimmung des Abdeckungsgrads ebenfalls nicht klarer machte. <br><br><h2>  Leistungsoptimierung </h2><br>  Wir begannen seltsamerweise mit einer optimierten Leistung.  Ich werde erkl√§ren warum.  Unsere visuellen Tests basieren auf dem <a href="https://github.com/storybooks/storybook">Storybook</a> .  Jede Story im Storybook ist keine einzelne Komponente, sondern ein ganzer ‚ÄûBlock‚Äú (z. B. ein Raster mit einer Liste von Entit√§ten, einer Entit√§tskarte, einem Dialog oder sogar der gesamten Anwendung).  Um diesen Block anzuzeigen, m√ºssen Sie die Story mit Daten ‚Äûpumpen‚Äú, und zwar nicht nur mit den Daten, die dem Benutzer angezeigt werden, sondern auch mit dem Status der im Block verwendeten Komponenten.  Diese Informationen werden zusammen mit dem Quellcode in Form von JSON-Dateien gespeichert, die eine serialisierte Darstellung des Status der Anwendung enthalten (Redux Store).  Ja, diese Daten sind, gelinde gesagt, redundant, vereinfachen jedoch die Erstellung von Tests erheblich.  Um einen neuen Test zu erstellen, √∂ffnen wir einfach die gew√ºnschte Karte, Liste oder den gew√ºnschten Dialog in der Anwendung, machen einen Schnappschuss des aktuellen Status der Anwendung und serialisieren ihn in eine Datei.  Dann f√ºgen wir eine neue Story und Tests hinzu, die Screenshots dieser Story enthalten (alles in wenigen Codezeilen). <br><br>  Dieser Ansatz erh√∂ht zwangsl√§ufig die Gr√∂√üe des B√ºndels.  Der Grad der Vervielf√§ltigung von Daten in ihm "rollt" nur √ºber.  Bei der Ausf√ºhrung von Tests f√ºhrt die Gemini-Engine jede Testsuite in einer separaten Browsersitzung aus.  Bei jeder Sitzung wird das Bundle erneut geladen, und die Gr√∂√üe des Bundles in einem solchen Schema ist weit vom letzten Wert entfernt. <br><br>  Um die Testlaufzeit zu verk√ºrzen, haben wir die Anzahl der Testsuiten reduziert, indem wir die Anzahl der darin enthaltenen Tests erh√∂ht haben.  Somit kann eine Testsuite mehrere Storys gleichzeitig betreffen.  In diesem Schema haben wir praktisch die M√∂glichkeit verloren, nur einen bestimmten Bereich des Bildschirms zu "screenen", da Sie in Gemini den Screenshot-Bereich nur f√ºr die Testsuite als Ganzes festlegen k√∂nnen (obwohl die API dies vor jedem Screenshot zul√§sst, aber in der Praxis nicht funktioniert). <br><br>  Die Unf√§higkeit, den Bereich des Screenshots in den Tests einzuschr√§nken, f√ºhrte zu einer Verdoppelung der visuellen Informationen in den Referenzbildern.  Obwohl es nicht viele Tests gab, schien dieses Problem nicht signifikant zu sein.  Ja, und die Benutzeroberfl√§che hat sich nicht sehr oft ge√§ndert.  Dies konnte jedoch nicht ewig so weitergehen - eine Neugestaltung zeichnete sich ab. <br><br>  Mit Blick auf die Zukunft sage ich, dass in Hermine f√ºr jede Aufnahme ein Screenshot-Bereich eingerichtet werden kann und auf den ersten Blick der Wechsel zu einer neuen Engine alle Probleme l√∂sen w√ºrde.  Aber wir m√ºssten immer noch gro√üe Testsuiten "zerquetschen".  Tatsache ist, dass visuelle Tests von Natur aus nicht stabil sind (dies kann verschiedene Gr√ºnde haben, z. B. Netzwerkverz√∂gerungen, Animationen oder ‚ÄûWetter auf dem Mars‚Äú) und es ist sehr schwierig, auf automatische Wiederholungsversuche zu verzichten.  Sowohl Gemini als auch Hermine f√ºhren Wiederholungsversuche f√ºr die gesamte Testsuite durch. Je ‚Äûdicker‚Äú die Testsuite ist, desto unwahrscheinlicher ist es, dass sie w√§hrend der Wiederholungsversuche erfolgreich abgeschlossen wird  Bei der n√§chsten Ausf√ºhrung fallen m√∂glicherweise Tests aus, die zuvor erfolgreich abgeschlossen wurden.  F√ºr dicke Testsuiten mussten wir ein alternatives Wiederholungsschema implementieren, das in die Gemini-Engine integriert war, und wollten dies beim Umstieg auf eine neue Engine nicht noch einmal tun. <br><br>  Um das Laden der Testsuite zu beschleunigen, haben wir das monolithische B√ºndel in Teile aufgeteilt und jeden Snapshot des Anwendungszustands in ein separates "Teil" aufgeteilt, das "bei Bedarf" f√ºr jede Story separat geladen wird.  Der Code zur Erstellung der Story sieht nun folgenderma√üen aus: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Zum Erstellen einer Story wird die StoryProvider-Komponente verwendet (der Code wird unten angegeben).  Schnappsch√ºsse werden mit der <a href="https://webpack.js.org/guides/code-splitting/">dynamischen Importfunktion</a> geladen.  Verschiedene Geschichten unterscheiden sich nur in Bildern von Staaten.  F√ºr ein dunkles Thema wird eine eigene Geschichte generiert, wobei derselbe Schnappschuss als Geschichte f√ºr ein helles Thema verwendet wird.  Im Kontext eines Bilderbuchs sieht es so aus: <br><br><div class="spoiler">  <b class="spoiler_title">Standard-Themengeschichte</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dunkle Themengeschichte</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  Die StoryProvider-Komponente akzeptiert einen R√ºckruf zum Laden eines Snapshots, in dem die Funktion import () aufgerufen wird.  Die Funktion import () arbeitet asynchron, sodass Sie nicht sofort nach dem Laden der Story einen Screenshot machen k√∂nnen - wir riskieren, die L√ºcke zu entfernen.  Um den Moment des Endes des Downloads zu erfassen, rendert der Anbieter das Marker-DOM-Element, das die Test-Engine f√ºr die Dauer des Downloads signalisiert. Dies muss mit dem Screenshot verz√∂gert werden: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Deaktivieren Sie au√üerdem das Hinzuf√ºgen von Quellzuordnungen zum Bundle, um die Gr√∂√üe des Bundles zu verringern.  Um jedoch nicht die F√§higkeit zu verlieren, die Story zu debuggen (Sie wissen nie was), tun wir dies unter der Bedingung: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  Das <b>Build-Storybook-Skript npm run</b> kompiliert ein statisches Storybook ohne Quellkarte in den Ordner storybook-static.  Es wird bei der Durchf√ºhrung von Tests verwendet.  Das <b>Storybook-Skript npm run</b> wird zum Entwickeln und Debuggen von Teststories verwendet. <br><br><h2>  Beseitigung von Duplikaten visueller Informationen </h2><br>  Wie bereits erw√§hnt, k√∂nnen Sie in Gemini f√ºr die Testsuite als Ganzes Auswahlm√∂glichkeiten f√ºr den Screenshot-Bereich festlegen. Um das Problem des Duplizierens visueller Informationen in den Screenshots vollst√§ndig zu l√∂sen, m√ºssten wir f√ºr jeden Screenshot eine eigene Testsuite erstellen.  Selbst unter Ber√ºcksichtigung der Optimierung des Ladens der Story sah es in Bezug auf die Geschwindigkeit nicht zu optimistisch aus, und wir dachten dar√ºber nach, die Testmaschine zu wechseln. <br><br>  Eigentlich, warum Hermine?  Momentan ist das Gemini-Repository als veraltet markiert und fr√ºher oder sp√§ter mussten wir irgendwohin ‚Äûumziehen‚Äú.  Die Struktur der Hermine-Konfigurationsdatei ist identisch mit der Struktur der Gemini-Konfigurationsdatei und wir konnten diese Konfiguration wiederverwenden.  Zwillinge und Hermine Plugins sind ebenfalls √ºblich.  Dar√ºber hinaus konnten wir die Testinfrastruktur - virtuelle Maschinen und eingesetztes Selen-Grid - wiederverwenden. <br><br>  Im Gegensatz zu Gemini ist Hermine nicht nur als Werkzeug f√ºr Regressionstests des Layouts positioniert.  Die Funktionen zur Browser-Manipulation sind viel umfangreicher und nur durch die Funktionen von <a href="http://v4.webdriver.io/">Webdriver IO eingeschr√§nkt</a> .  In Kombination mit <a href="https://github.com/mochajs/mocha">Mokka</a> eignet sich diese Engine eher f√ºr Funktionstests (Simulation von Benutzeraktionen) als f√ºr Layouttests.  F√ºr Regressionstests des Layouts stellt Hermine nur die assertView () -Methode zur Verf√ºgung, die einen Screenshot einer Browserseite mit einer Referenz vergleicht.  Der Screenshot kann auf den Bereich beschr√§nkt werden, der mit CSS-Selektoren festgelegt wurde. <br><br>  In unserem Fall w√ºrde der Test f√ºr jede einzelne Geschichte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  Mit der waitForVisible () -Methode k√∂nnen Sie trotz ihres Namens nicht nur das Erscheinungsbild, sondern auch das Ausblenden des Elements erwarten, wenn Sie den zweiten Parameter auf true setzen.  Hier warten wir damit, bis ein Markerelement ausgeblendet ist. Dies zeigt an, dass der Datenschnappschuss noch nicht geladen ist und die Story noch nicht f√ºr einen Screenshot bereit ist. <br><br>  Wenn Sie versuchen, die waitForVisible () -Methode in der Hermine-Dokumentation zu finden, werden Sie nichts finden.  Tatsache ist, dass die waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">-Methode die Webdriver-IO-API-Methode ist</a> .  Auch die url () -Methode.  Bei der url () -Methode √ºbergeben wir die Frame-Adresse einer bestimmten Story, nicht das gesamte Storybook.  Erstens ist dies erforderlich, damit die Story-Liste nicht im Browserfenster angezeigt wird - wir m√ºssen sie nicht testen.  Zweitens k√∂nnen wir bei Bedarf auf DOM-Elemente innerhalb des Frames zugreifen (mit den webdriverIO-Methoden k√∂nnen Sie JavaScript-Code in einem Browserkontext ausf√ºhren). <br><br>  Um das Schreiben von Tests zu vereinfachen, haben wir unseren Wrapper √ºber Mokka-Tests gemacht.  Tatsache ist, dass die detaillierte Ausarbeitung von Testf√§llen f√ºr Regressionstests keinen besonderen Sinn macht.  Alle Testf√§lle sind gleich - 'sollte gleich Etalon sein'.  Nun, ich m√∂chte auch nicht den Code f√ºr das Warten auf das Laden von Daten in jedem Test duplizieren.  Daher wird die gleiche Arbeit f√ºr alle ‚ÄûAffentests‚Äú an die Wrapper-Funktion delegiert, und die Tests selbst werden deklarativ (fast) geschrieben.  Hier ist der Text dieser Funktion: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Ein Objekt, das die Testsuite beschreibt, wird an den Eingang der Funktion √ºbergeben.  Jede Testsuite wird gem√§√ü dem folgenden Szenario erstellt: Wir erstellen einen Screenshot des Hauptlayouts (z. B. einen Bereich einer Entit√§tskarte oder einen Bereich einer Entit√§tsliste), dr√ºcken dann programmgesteuert Schaltfl√§chen, die zum Erscheinen anderer Elemente f√ºhren k√∂nnen (z. B. Popup-Bedienfelder oder Kontextmen√ºs), und erstellen einen Screenshot ¬ªJedes dieser Elemente separat.  Daher simulieren wir Benutzeraktionen im Browser, jedoch nicht mit dem Ziel, eine Art Gesch√§ftsszenario zu testen, sondern lediglich die maximal m√∂gliche Anzahl visueller Komponenten zu erfassen.  Dar√ºber hinaus ist die Duplizierung visueller Informationen in den Screenshots minimal, weil  Screenshots werden "punktweise" mit Selektoren aufgenommen.  Beispiel f√ºr eine Testsuite: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Bestimmung der Deckung </h2><br>  Also, wir haben die Geschwindigkeit und Redundanz herausgefunden, es bleibt die Effektivit√§t unserer Tests herauszufinden, dh den Grad der Abdeckung des Codes mit Tests zu bestimmen (hier mit Code meine ich CSS-Stylesheets). <br><br>  F√ºr Teststories haben wir empirisch die kompliziertesten Karten, Listen und anderen Elemente ausgew√§hlt, um mit einem Screenshot so viele Stile wie m√∂glich abzudecken.  Um beispielsweise eine Entity-Karte zu testen, wurden Karten mit einer gro√üen Anzahl verschiedener Arten von Steuerelementen (Text, Nummer, √úbertragungen, Daten, Raster usw.) ausgew√§hlt.  Karten f√ºr verschiedene Arten von Entit√§ten haben ihre eigenen Besonderheiten. Beispielsweise kann ein Bereich mit einer Liste von Dokumentversionen von einer Dokumentkarte angezeigt werden, und die Korrespondenz zu dieser Aufgabe wird auf der Aufgabenkarte angezeigt.  Dementsprechend wurden f√ºr jeden Entit√§tstyp eine eigene Story und eine Reihe typenspezifischer Tests usw. erstellt.  Am Ende stellten wir uns vor, dass alles mit Tests bedeckt zu sein schien, aber wir wollten ein bisschen mehr Selbstvertrauen als ‚Äûm√∂gen‚Äú. <br><br>  Um die Abdeckung in Chrome DevTools zu bewerten, gibt es ein Tool mit dem Namen Abdeckung, das f√ºr diesen Fall sehr gut geeignet ist: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  Mit Coverage k√∂nnen Sie bestimmen, welche Stile oder welcher js-Code beim Arbeiten mit der Browserseite verwendet wurden.  Der Bericht √ºber die Verwendung von gr√ºnen Streifen gibt den verwendeten Code an, rot - nicht verwendet.  Und alles w√§re in Ordnung, wenn wir eine Anwendung der Ebene "Hallo, Welt" h√§tten, aber was tun, wenn wir Tausende von Codezeilen haben?  Coverage-Entwickler haben dies gut verstanden und konnten den Bericht in eine Datei exportieren, die bereits programmgesteuert bearbeitet werden kann. <br><br>  Ich muss gleich sagen, dass wir bisher keine M√∂glichkeit gefunden haben, den Abdeckungsgrad automatisch zu erfassen.  Theoretisch kann dies mit dem Headless-Browser des Puppenspielers durchgef√ºhrt werden, aber der Puppenspieler arbeitet nicht unter der Kontrolle von Selen, was bedeutet, dass wir den Code unserer Tests nicht wiederverwenden k√∂nnen.  Lassen Sie uns dieses √§u√üerst interessante Thema √ºberspringen und mit Stiften arbeiten. <br><br>  Nachdem wir die Tests im manuellen Modus ausgef√ºhrt haben, erhalten wir einen Abdeckungsbericht, der eine JSON-Datei ist.  Im Bericht f√ºr jedes CSS, JS, TS, etc.  Die Datei gibt den Text (in einer Zeile) und die Intervalle des in diesem Text verwendeten Codes (in Form von Zeichenindizes dieser Zeile) an.  Unten ist ein Teil des Berichts: <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  Auf den ersten Blick ist es nicht schwierig, nicht verwendete CSS-Selektoren zu finden.  Aber was tun mit diesen Informationen?  In der Tat m√ºssen wir letztendlich keine spezifischen Selektoren finden, sondern Komponenten, die wir vergessen haben, mit Tests abzudecken.  Stile einer Komponente k√∂nnen von mehr als einem Dutzend Selektoren festgelegt werden.  Basierend auf den Ergebnissen der Analyse des Berichts erhalten wir Hunderte nicht verwendeter Selektoren, und wenn Sie sich mit jedem von ihnen befassen, k√∂nnen Sie viel Zeit verlieren. <br><br>  Hier helfen uns regul√§re Ausdr√ºcke.  Nat√ºrlich funktionieren sie nur, wenn die Namenskonventionen f√ºr CSS-Klassen erf√ºllt sind (in unserem Code werden CSS-Klassen gem√§√ü der BEM-Methode benannt - blockname_name_name_modifier).  Mithilfe von regul√§ren Ausdr√ºcken berechnen wir die eindeutigen Werte der Blocknamen, die den Komponenten nicht mehr schwer zuzuordnen sind.  Nat√ºrlich interessieren uns auch Elemente und Modifikatoren, aber nicht an erster Stelle m√ºssen wir uns zuerst mit einem gr√∂√üeren ‚ÄûFisch‚Äú befassen.  Unten finden Sie ein Skript zum Verarbeiten eines Abdeckungsberichts <br><br><div class="spoiler">  <b class="spoiler_title">coverage.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Wir f√ºhren das Skript aus, indem wir zuerst die aus Chrome DevTools exportierte Datei coverage.json platzieren und den Auspuff in eine CSV-Datei schreiben: <br><br>  <b>node coverage.js&gt; coverage.csv</b> <br><br>  Sie k√∂nnen diese Datei mit Excel √∂ffnen und die Daten analysieren, einschlie√ülich der Bestimmung des Prozentsatzes der Codeabdeckung durch Tests. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Anstelle eines Lebenslaufs </h2><br>  Die Verwendung des Storybooks als Grundlage f√ºr visuelle Tests hat sich voll und ganz bew√§hrt - wir haben einen ausreichenden Grad an Abdeckung des CSS-Codes mit Tests mit einer relativ geringen Anzahl von Storys und minimalen Kosten f√ºr die Erstellung neuer. <br><br>  Durch die Umstellung auf eine neue Engine konnten wir doppelte visuelle Informationen in Screenshots vermeiden, was die Unterst√ºtzung bestehender Tests erheblich vereinfachte. <br><br>  Der Abdeckungsgrad des CSS-Codes ist messbar und wird von Zeit zu Zeit √ºberwacht.  Es stellt sich nat√ºrlich die gro√üe Frage, wie man die Notwendigkeit dieser Kontrolle nicht vergisst und wie man beim Sammeln von Informationen √ºber die Berichterstattung etwas verpasst.  Idealerweise m√∂chte ich den Abdeckungsgrad bei jedem Testlauf automatisch messen, damit die Tests bei Erreichen der festgelegten Schwelle fehlerhaft abfallen.  Wir werden daran arbeiten, wenn es Neuigkeiten gibt, werde ich es Ihnen auf jeden Fall sagen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479040/">https://habr.com/ru/post/de479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479022/index.html">Smart-Fernseher Samsung, LG, Vizio und TCL nehmen jede Sekunde "Fingerabdr√ºcke" vom Bildschirm und senden sie an den Server</a></li>
<li><a href="../de479026/index.html">Echte Summe der Internetkan√§le - OpenMPTCPRouter</a></li>
<li><a href="../de479034/index.html">Herstellen einer Verbindung zu einem Unternehmens-VPN unter Linux mithilfe von openconnect und vpn-slice</a></li>
<li><a href="../de479036/index.html">Intel kann die Nachfrage nach Prozessoren nicht befriedigen. HP und Dell leiden darunter</a></li>
<li><a href="../de479038/index.html">Digitale Transformation Leroy Merlin: Entwerfen einer Schnittstelle f√ºr die Arbeit mit Kundenanrufen</a></li>
<li><a href="../de479042/index.html">Mit der Y-Methode k√∂nnen Sie ganz einfach einen Rubik's Cube erstellen</a></li>
<li><a href="../de479044/index.html">Meine Ringpuffer-Implementierung in NOR-Flash</a></li>
<li><a href="../de479048/index.html">Node.js Streams f√ºr Dummies oder wie man mit Streams arbeitet</a></li>
<li><a href="../de479050/index.html">Patentrecherche in der IT. Der Kurs des jungen K√§mpfers. Teil II Informationsquellen f√ºr die Patentrecherche</a></li>
<li><a href="../de479052/index.html">[Supercomputing 2019]. Multi-Cloud-Speicher als Anwendung f√ºr neue Kingston DC1000M-Laufwerke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>