<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèΩ ‚ûï üçä El rastrillo m√°s com√∫n cuando se usa printf en programas para microcontroladores üòÉ üî§ ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando en mis proyectos, tengo que usar printf junto con un puerto serie (UART o una abstracci√≥n a trav√©s de USB que imita un puerto serie)....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El rastrillo m√°s com√∫n cuando se usa printf en programas para microcontroladores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459420/">  De vez en cuando en mis proyectos, tengo que usar printf junto con un puerto serie (UART o una abstracci√≥n a trav√©s de USB que imita un puerto serie).  Y, como de costumbre, pasa mucho tiempo entre sus aplicaciones y me las arreglo para olvidar por completo todos los matices que deben tenerse en cuenta para que funcione normalmente en un proyecto grande. <br><br>  En este art√≠culo, he compilado mis propios matices principales que surgen al usar printf en programas para microcontroladores, ordenados por evidencia desde la m√°s obvia hasta la completamente no obvia. <br><a name="habracut"></a><br><h2>  Breve introducci√≥n </h2><br>  De hecho, para usar printf en programas para microcontroladores, es suficiente: <ul><li>  incluir el archivo de encabezado en el c√≥digo del proyecto; </li><li>  redefinir la funci√≥n del sistema _write para que salga al puerto serie; </li><li>  Describa los ap√©ndices de las llamadas al sistema que requiere el vinculador (_fork, _wait y otros); </li><li>  use printf call en el proyecto. </li></ul><br>  De hecho, no todo es tan simple. <br><br><h2>  Describa todos los talones, no solo los usados. </h2><br>  La presencia de un mont√≥n de enlaces vagos en el dise√±o del proyecto al principio es sorprendente, pero despu√©s de leer un poco, queda claro qu√© y por qu√©.  En todos mis proyectos, estoy conectando este <a href="">subm√≥dulo</a> .  Por lo tanto, en el proyecto principal, redefinir√© solo los m√©todos que necesito (solo _escribir en este caso), y el resto permanecer√° sin cambios. <br><br>  Es importante tener en cuenta que todos los ap√©ndices deben ser funciones C.  No C ++ (o envuelto en "C" externa).  De lo contrario, el dise√±o fallar√° (recuerde el cambio de nombre durante el ensamblaje con G ++). <br><br><h2>  En _write viene 1 caracter </h2><br>  A pesar de que el prototipo del m√©todo _write tiene un argumento que pasa la longitud del mensaje mostrado, tiene un valor de 1 (de hecho, nosotros mismos haremos que siempre sea 1, pero m√°s sobre eso m√°s adelante). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  En Internet, a menudo puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tal implementaci√≥n de</a> este m√©todo: <br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n frecuente de la funci√≥n _write</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  Tal implementaci√≥n tiene las siguientes desventajas: <br><ul><li>  baja productividad; </li><li>  inseguridad de transmisi√≥n; </li><li>  incapacidad para utilizar el puerto serie para otros fines; </li></ul><br><br><h3>  Bajo rendimiento </h3><br>  El rendimiento lento se debe al env√≠o de bytes utilizando recursos del procesador: debe supervisar el registro de estado en lugar de utilizar el mismo DMA.  Para resolver este problema, puede preparar el b√∫fer para enviar por adelantado, y al recibir el car√°cter del final de la l√≠nea (o llenar el b√∫fer) enviar.  Este m√©todo requiere una memoria intermedia, pero mejora significativamente el rendimiento con el env√≠o frecuente. <br><div class="spoiler">  <b class="spoiler_title">Ejemplo de implementaci√≥n de _write con un b√∫fer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Aqu√≠, el objeto uart, uart_1, es responsable de enviar directamente usando dma.  El objeto utiliza m√©todos FreeRTOS para bloquear el acceso de terceros al objeto en el momento de enviar datos desde el b√∫fer (tomar y devolver mutex).  Por lo tanto, nadie puede usar el objeto uart mientras env√≠a desde otro hilo. <br>  Algunos enlaces: <br><ul><li>  _escribe aqu√≠ el c√≥digo de funci√≥n como parte de un proyecto real </li><li>  la interfaz de la clase uart est√° <a href="">aqu√≠</a> </li><li>  implementaci√≥n de la interfaz de clase uart bajo stm32f4 <a href="">aqu√≠</a> y <a href="">aqu√≠</a> </li><li>  instanciaci√≥n de la clase uart como parte del proyecto <a href="">aqu√≠</a> </li></ul><br><br><h3>  Streaming inseguridad </h3><br>  Esta implementaci√≥n tambi√©n permanece desprotegida, ya que nadie se molesta en el flujo vecino de FreeRTOS para comenzar a enviar otra l√≠nea a printf y, por lo tanto, tritura el b√∫fer que se est√° enviando actualmente (el mutex dentro del uart protege el objeto de ser utilizado en diferentes flujos, pero los datos no se transmiten a ellos )  En caso de que exista el riesgo de que se llame a printf de otro subproceso, se requiere implementar un objeto de capa que bloquee el acceso a printf por completo.  En mi caso particular, solo un hilo interact√∫a con printf, por lo que las complicaciones adicionales solo reducir√°n el rendimiento (captura y liberaci√≥n constante de mutex dentro de la capa). <br><br><h3>  Incapacidad para usar el puerto serie para otros fines </h3><br>  Dado que enviamos solo despu√©s de que se haya recibido toda la cadena (o que el b√∫fer est√© lleno), en lugar del objeto uart, puede llamar al m√©todo del convertidor a alguna interfaz de nivel superior para la posterior transferencia de paquetes (por ejemplo, entrega con una garant√≠a de acuerdo con el protocolo de transmisi√≥n similar a los paquetes transacci√≥n modbus).  Esto le permitir√° usar un uart tanto para mostrar informaci√≥n de depuraci√≥n como, por ejemplo, para la interacci√≥n del usuario con la consola de administraci√≥n (si hay una disponible en el dispositivo).  Ser√° suficiente escribir un descompresor en el lado del receptor. <br><br><h2>  Por defecto, la salida flotante no funciona </h2><br>  Si usa newlib-nano, entonces, por defecto, printf (as√≠ como todos sus derivados como sprintf / snprintf ... y otros) no admiten la salida de valores flotantes.  Esto se resuelve f√°cilmente agregando los siguientes indicadores de enlace al proyecto. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  Vea la lista completa de banderas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  El programa se congela en alg√∫n lugar de las entra√±as de printf </h2><br>  Este es otro defecto en las banderas de enlace.  Para que el firmware se configure con la versi√≥n deseada de la biblioteca, debe especificar expl√≠citamente los par√°metros del procesador. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  Vea la lista completa de banderas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  printf obliga al microcontrolador a tener una falla grave </h2><br>  Puede haber al menos dos razones: <br><ul><li>  problemas de pila; </li><li>  problemas con _sbrk; </li></ul><br><h3>  Problemas de pila </h3><br>  Este problema realmente se manifiesta cuando se usa FreeRTOS o cualquier otro sistema operativo.  El problema est√° usando el b√∫fer.  El primer p√°rrafo dice que en _write viene 1 byte cada uno.  Para que esto suceda, debe prohibir el uso de almacenamiento en b√∫fer en su c√≥digo antes de usar printf por primera vez. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  De la descripci√≥n de la funci√≥n se deduce que uno de los siguientes valores se puede establecer de la misma manera: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  Sin embargo, esto puede provocar un desbordamiento de la pila de tareas (o interrupciones si de repente eres una persona muy mala que llama a printf por interrupciones). <br><br>  Desde el punto de vista t√©cnico, es posible organizar las pilas con mucho cuidado para cada flujo, pero este enfoque requiere una planificaci√≥n cuidadosa y es dif√≠cil detectar los errores que conlleva.  Una soluci√≥n mucho m√°s simple es recibir un byte cada uno, almacenarlo en su propio b√∫fer y luego enviarlo en el formato requerido, analizado anteriormente. <br><br><h3>  Problemas con _sbrk </h3><br>  Este problema fue para m√≠ personalmente el m√°s impl√≠cito.  ¬øY qu√© sabemos sobre _sbrk? <br><ul><li>  Otro trozo que debe implementarse para admitir una parte considerable de las bibliotecas est√°ndar; </li><li>  requerido para asignar memoria en el mont√≥n; </li><li>  utilizado por todo tipo de m√©todos de biblioteca como malloc, gratis. </li></ul><br>  Personalmente, en mis proyectos en el 95% de los casos, uso FreeRTOS con m√©todos redefinidos new / delete / malloc que usan un mont√≥n de FreeRTOS.  Entonces, cuando asigno memoria, estoy seguro de que la asignaci√≥n est√° en el mont√≥n FreeRTOS, que ocupa una cantidad predeterminada de memoria en el √°rea bss.  Puedes mirar la capa <a href="">aqu√≠</a> .  Entonces, puramente t√©cnico, no deber√≠a haber ning√∫n problema.  Una funci√≥n simplemente no deber√≠a llamarse.  Pero pensemos, si ella llama, entonces, ¬ød√≥nde intentar√° recuperar su memoria? <br><br>  Recordemos el dise√±o de la RAM del proyecto "cl√°sico" para microcontroladores: <br><ul><li>  .data; </li><li>  .bss; </li><li>  espacio vacio </li><li>  pila inicial </li></ul><br>  En datos, tenemos los datos iniciales de los objetos globales (variables, estructuras y otros campos del proyecto global).  En bss, campos globales que tienen un valor cero inicial y, con cuidado, un mont√≥n de FreeRTOS.  Es solo una matriz en la memoria.  con el que funcionan los m√©todos del archivo heap_x.c.  El siguiente es el espacio vac√≠o, despu√©s del cual (o m√°s bien desde el final) es la pila.  Porque  FreeRTOS se usa en mi proyecto, luego esta pila se usa solo hasta que se inicia el planificador.  Y, por lo tanto, su uso, en la mayor√≠a de los casos, est√° limitado a los colobytes (de hecho, generalmente un l√≠mite de 100 bytes). <br><br>  ¬øPero d√≥nde, entonces, se asigna la memoria usando _sbrk?  Eche un vistazo a las variables que usa del script de enlazador. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Ahora los encontramos en la secuencia de comandos del enlazador (mi secuencia de comandos es ligeramente diferente de la que proporciona st, sin embargo, esta parte es casi la misma all√≠): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  Es decir, utiliza memoria entre la pila (1 kb desde 0x20020000 hacia abajo con 128 kb RAM) y bss. <br><br>  Entendido  Pero ten√≠a una redefinici√≥n de los m√©todos malloc, free y otros.  Usar _sbrk despu√©s de todo no es necesario?  Al final result√≥ que, una necesidad.  Adem√°s, este m√©todo no utiliza printf, sino el m√©todo para configurar el modo de almacenamiento en b√∫fer: <b>setvbuf</b> (o m√°s bien _malloc_r, que no se declara como una funci√≥n d√©bil en la biblioteca. A diferencia de malloc, que se puede reemplazar f√°cilmente). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Como estaba seguro de que no se usaba sbrk, coloqu√© un mont√≥n de FreeRTOS (secci√≥n bss) cerca de la pila (porque sab√≠a con certeza que la pila se us√≥ 10 veces menos de lo requerido). <br><br>  Soluciones al problema 3: <br><ul><li>  sangr√≠a entre bss y la pila; </li><li>  anule _malloc_r para que no se llame a _sbrk (separe un m√©todo de la biblioteca); </li><li>  reescribe sbrk a trav√©s de malloc y gratis. </li></ul><br>  Me decid√≠ por la primera opci√≥n, ya que no fue exitoso reemplazar el _malloc_r est√°ndar (que est√° dentro de libg_nano.a (lib_a-nano-mallocr.o)) (el m√©todo no se declar√≥ como __attribute__ ((d√©bil)), sino excluir solo una funci√≥n de la bi-biblioteca No logr√© vincular).  Realmente no quer√≠a reescribir sbrk para una llamada. <br><br>  La soluci√≥n final fue asignar particiones separadas en RAM para la pila inicial y _sbrk.  Esto asegura que las secciones no se apilan unas encima de otras durante la fase de configuraci√≥n.  Dentro de sbrk tambi√©n hay un cheque para salir de la secci√≥n.  Tuve que hacer una peque√±a correcci√≥n para que al detectar una transici√≥n al exterior, el flujo se bloqueara en un ciclo while (ya que el uso de sbrk ocurre solo en la etapa inicial de inicializaci√≥n y debe procesarse en la etapa de depuraci√≥n del dispositivo). <br><div class="spoiler">  <b class="spoiler_title">Mem.ld modificado</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Cambios en section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  Puede mirar <a href="">mem.ld</a> y <a href="">section.ld</a> en mi proyecto sandbox <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este commit</a> . <br><br>  UPD 07/12/2019: se corrigi√≥ la lista de banderas para trabajar printf con valores flotantes.  Correg√≠ el enlace a las CMakeLists en funcionamiento con compilaciones corregidas y banderas de dise√±o (hubo matices con el hecho de que las banderas deber√≠an enumerarse una por una y a trav√©s de ";", mientras que en una l√≠nea o en l√≠neas diferentes no importa). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459420/">https://habr.com/ru/post/459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459404/index.html">Idea: registro / autorizaci√≥n an√≥nima utilizando la red Ethereum + Metamask, sin correos electr√≥nicos, etc.</a></li>
<li><a href="../459408/index.html">C√≥mo intent√© arreglar un mapa de b√∫squeda de controladores. Parte 3 (final)</a></li>
<li><a href="../459410/index.html">C√≥mo escribir c√≥digo para que tus colegas no juren</a></li>
<li><a href="../459414/index.html">Escribir una API para React Components, Parte 4: Cuidado con el Apropacalypse</a></li>
<li><a href="../459416/index.html">Escribir una API para React Components, Parte 5: solo use la composici√≥n</a></li>
<li><a href="../459422/index.html">Escribimos API para componentes React, parte 6: creamos comunicaci√≥n entre componentes</a></li>
<li><a href="../459426/index.html">C√≥mo se cre√≥ el dise√±o de Yandex.Avto</a></li>
<li><a href="../459428/index.html">Intel Quartus Prime: todo lo que necesita para trabajar con Intel FPGA</a></li>
<li><a href="../459430/index.html">Aplicaci√≥n m√≥vil con generaci√≥n autom√°tica de formularios: nuestro caso</a></li>
<li><a href="../459432/index.html">RD-180: ¬øpueden los Estados Unidos fabricar motores de cohetes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>