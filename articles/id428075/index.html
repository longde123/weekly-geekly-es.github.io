<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¦• ğŸ’ ğŸ‘©ğŸ¾â€ğŸ’¼ Sama saja, Anda tidak bisa melakukannya! - Menggunakan antarmuka dan injeksi ketergantungan untuk desain jangka panjang ğŸ‘¨â€âš•ï¸ ğŸŒ©ï¸ ğŸ¤›ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Kami akhirnya memiliki kontrak untuk memperbarui buku Mark Siman, " Dependency Injection in .NET " - yang terpenting adalah ia menye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sama saja, Anda tidak bisa melakukannya! - Menggunakan antarmuka dan injeksi ketergantungan untuk desain jangka panjang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Halo semuanya! <br><br>  Kami akhirnya memiliki kontrak untuk memperbarui buku Mark Siman, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dependency Injection in .NET</a> " - yang terpenting adalah ia menyelesaikannya sesegera mungkin.  Kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> di editor Dinesh Rajput yang disegani tentang pola desain di Spring 5, di mana salah satu babnya juga dikhususkan untuk implementasi dependensi. <br><br>  Kami telah lama mencari bahan yang menarik yang akan mengingat kekuatan paradigma DI dan memperjelas minat kami terhadapnya - dan sekarang telah ditemukan.  Benar, penulis lebih suka memberi contoh di Go.  Kami harap ini tidak mencegah Anda dari mengikuti pemikirannya dan membantu untuk memahami prinsip-prinsip umum inversi kontrol dan bekerja dengan antarmuka, jika topik ini dekat dengan Anda. <br><br>  Pewarnaan emosional dari aslinya sedikit lebih tenang, jumlah tanda seru dalam terjemahan berkurang.  Selamat membaca! <br><a name="habracut"></a><br>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka</a> adalah teknik yang dapat dipahami yang memungkinkan Anda membuat kode yang mudah diuji dan mudah diperluas.  Saya telah berulang kali diyakinkan bahwa ini adalah alat desain arsitektur paling kuat dari semuanya. <br><br>  Tujuan artikel ini adalah untuk menjelaskan antarmuka apa, bagaimana mereka digunakan, dan bagaimana mereka memberikan ekstensibilitas dan testabilitas kode.  Akhirnya, artikel tersebut harus menunjukkan bagaimana antarmuka dapat membantu mengoptimalkan manajemen pengiriman perangkat lunak dan menyederhanakan perencanaan! <br><br>  <b>Antarmuka</b> <br><br>  Antarmuka menggambarkan kontrak.  Bergantung pada bahasa atau kerangka kerjanya, penggunaan antarmuka dapat ditentukan secara eksplisit atau implisit.  Jadi, dalam bahasa Go, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka didiktekan secara eksplisit</a> .  Jika Anda mencoba menggunakan entitas sebagai antarmuka, tetapi tidak sepenuhnya konsisten dengan aturan antarmuka ini, kesalahan waktu kompilasi akan terjadi.  Misalnya, menjalankan contoh di atas, kami mendapatkan kesalahan berikut: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Antarmuka adalah alat untuk membantu melepaskan penelepon dari callee, ini dilakukan dengan menggunakan kontrak. <br><br>  Mari kita konkretkan masalah ini menggunakan contoh program untuk perdagangan pertukaran otomatis.  Program pedagang akan dipanggil dengan harga beli yang ditetapkan dan simbol ticker.  Kemudian program akan pergi ke bursa untuk mencari tahu kutipan terbaru dari ticker ini.  Selanjutnya, jika harga pembelian untuk ticker ini tidak melebihi harga yang ditentukan, program akan melakukan pembelian. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  Dalam bentuk yang disederhanakan, arsitektur program ini dapat direpresentasikan sebagai berikut.  Dari contoh di atas jelas bahwa operasi untuk memperoleh harga saat ini secara langsung tergantung pada protokol HTTP, di mana program menghubungi layanan pertukaran. <br><br>  Kondisi <code>Action</code> juga secara langsung bergantung pada HTTP.  Dengan demikian, kedua negara harus sepenuhnya memahami cara menggunakan HTTP untuk mengekstrak data pertukaran dan / atau menyelesaikan transaksi. <br><br>  Begini tampilannya: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Di sini, penelepon ( <code>analyze</code> ) secara langsung bergantung pada HTTP.  Dia perlu tahu bagaimana permintaan HTTP dirumuskan.  Bagaimana penguraian mereka dilakukan.  Cara menangani percobaan ulang, batas waktu, otentikasi, dll.  Dia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pegangan</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">erat</a> pada <code>http</code> .  <b>Setiap kali kita memanggil analisis, kita juga harus memanggil perpustakaan <code>http</code></b> . <br><br>  Bagaimana antarmuka dapat membantu kami di sini?  Dalam kontrak yang disediakan oleh antarmuka, Anda bisa mendeskripsikan <b>perilaku</b> , bukan <b>implementasi</b> spesifik. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  Di atas mendefinisikan konsep <code>StockExchange</code> .  Di sini dikatakan bahwa <code>StockExchange</code> mendukung pemanggilan satu-satunya fungsi <code>CurrentPrice</code> .  Ketiga garis ini bagi saya merupakan teknik arsitektur paling kuat dari semuanya.  Mereka membantu kita mengontrol dependensi aplikasi jauh lebih percaya diri.  Berikan pengujian.  Berikan ekstensibilitas. <br><br>  <b>Injeksi Ketergantungan</b> <br><br>  Untuk memahami sepenuhnya nilai antarmuka, Anda harus menguasai teknik yang disebut "injeksi ketergantungan". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketergantungan injeksi</a> berarti bahwa pemanggil menyediakan sesuatu yang dibutuhkan oleh pemanggil.  Biasanya terlihat seperti ini: penelepon mengkonfigurasi objek, dan kemudian meneruskannya ke callee.  Kemudian pihak yang disebut abstrak dari konfigurasi dan implementasi.  Dalam hal ini, ada mediasi yang dikenal.  Pertimbangkan permintaan ke layanan Istirahat HTTP.  Untuk mengimplementasikan klien, kita perlu menggunakan perpustakaan HTTP yang dapat merumuskan, mengirim, dan menerima permintaan HTTP. <br><br>  Jika kami menempatkan permintaan HTTP di belakang antarmuka, maka penelepon dapat dilepaskan, dan dia akan "tidak sadar" bahwa permintaan HTTP benar-benar terjadi. <br><br>  Penelepon seharusnya hanya membuat panggilan fungsi generik.  Ini bisa berupa panggilan lokal, panggilan jarak jauh, panggilan HTTP, panggilan RPC, dll.  Penelepon tidak mengetahui apa yang terjadi, dan biasanya itu cocok untuknya, selama dia mendapatkan hasil yang diharapkan.  Berikut ini menunjukkan seperti apa injeksi dependensi dalam metode <code>analyze</code> kami. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Saya tidak pernah berhenti kagum dengan apa yang terjadi di sini.  Kami benar-benar membalik pohon ketergantungan kami dan mulai mengendalikan seluruh program dengan lebih baik.  Terlebih lagi, bahkan secara visual seluruh implementasi telah menjadi lebih bersih dan lebih mudah dipahami.  Kami melihat dengan jelas bahwa metode analisis harus memilih harga saat ini, memeriksa apakah harga ini cocok untuk kami, dan jika demikian, buat kesepakatan. <br><br>  Yang terpenting, dalam hal ini kami melepaskan penelepon dari penelepon.  Karena penelepon dan seluruh implementasi dipisahkan dari yang dipanggil menggunakan antarmuka, Anda dapat memperluas antarmuka dengan membuat banyak implementasi yang berbeda dari itu.  Antarmuka memungkinkan Anda untuk membuat banyak implementasi spesifik yang berbeda tanpa perlu mengubah kode dari pihak yang dipanggil! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Status "dapatkan harga saat ini" dalam program ini hanya bergantung pada antarmuka <code>StockExchange</code> .  Implementasi ini tidak tahu <b>apa</b> - <b>apa</b> tentang bagaimana menghubungi layanan pertukaran, bagaimana harga disimpan atau bagaimana permintaan dibuat.  Ketidaktahuan yang sangat bahagia.  Apalagi bilateral.  Implementasi <code>HTTPStockExchange</code> juga tidak tahu apa-apa tentang analisis.  Tentang konteks di mana analisis akan dilakukan, ketika itu dilakukan - karena tantangan terjadi secara tidak langsung. <br><br>  Karena fragmen program (yang bergantung pada antarmuka) tidak perlu diubah ketika mengubah / menambah / menghapus implementasi spesifik, <b>desain seperti itu ternyata tahan lama</b> .  Misalkan kita menemukan bahwa <code>StockService</code> sangat sering tidak tersedia. <br><br>  Bagaimana contoh di atas berbeda dari memanggil suatu fungsi?  Saat menerapkan panggilan fungsi, implementasinya juga akan menjadi lebih bersih.  Perbedaannya adalah bahwa ketika Anda memanggil fungsi, kita masih harus menggunakan HTTP.  Metode <code>analyze</code> hanya akan mendelegasikan tugas fungsi, yang seharusnya memanggil <code>http</code> , daripada memanggil <code>http</code> itu sendiri secara langsung.  Seluruh kekuatan teknik ini terletak pada "injeksi", yaitu, bahwa penelepon menyediakan antarmuka ke callee.  Inilah tepatnya bagaimana inversi ketergantungan terjadi, di mana mendapatkan harga hanya bergantung pada antarmuka, dan bukan pada implementasinya. <br><br>  <b>Implementasi multipel dari kotak</b> <br><br>  Pada tahap ini, kami memiliki fungsi <code>analyze</code> dan antarmuka <code>StockExchange</code> , tetapi kami sebenarnya tidak dapat melakukan sesuatu yang berguna.  Baru saja mengumumkan program kami.  Saat ini, tidak mungkin untuk menyebutnya, karena kami masih belum memiliki implementasi spesifik tunggal yang akan memenuhi persyaratan antarmuka kami. <br><br>  Penekanan utama dalam diagram berikut dibuat pada status "dapatkan harga saat ini" dan ketergantungannya pada antarmuka <code>StockExchange</code> .  Berikut ini menunjukkan bagaimana dua implementasi yang sama sekali berbeda hidup berdampingan, dan mendapatkan harga saat ini tidak di ketahui.  Selain itu, kedua implementasi tidak terkait satu sama lain, masing-masing hanya bergantung pada antarmuka <code>StockExchange</code> . <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Produksi <br><br>  Implementasi HTTP asli sudah ada dalam implementasi <code>analyze</code> utama;  semua yang tersisa bagi kita adalah mengekstraknya dan merangkumnya di belakang implementasi konkret dari antarmuka. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  Kode yang sebelumnya kita tautkan ke fungsi analisis sekarang otonom dan memenuhi antarmuka <code>StockExchange</code> , yaitu, sekarang kita bisa meneruskannya untuk <code>analyze</code> .  Seperti yang Anda ingat dari diagram di atas, analisis tidak lagi dikaitkan dengan ketergantungan HTTP.  Menggunakan antarmuka, <code>analyze</code> tidak "membayangkan" apa yang terjadi di balik layar.  Dia hanya tahu bahwa dia akan dijamin diberi objek yang bisa dia panggil <code>CurrentPrice</code> . <br><br>  Juga di sini kita mengambil keuntungan dari sifat khas enkapsulasi.  Sebelumnya, ketika http-permintaan terikat untuk dianalisis, satu-satunya cara untuk berkomunikasi dengan pertukaran melalui http tidak langsung - melalui metode <code>analyze</code> .  Ya, kami bisa merangkum panggilan-panggilan ini ke dalam fungsi-fungsi dan menjalankan fungsi secara independen, tetapi antarmuka memaksa kami untuk melepaskan penelepon dari penelepon.  Sekarang kita dapat menguji <code>HTTPStockExchange</code> terlepas dari penelepon.  Ini secara fundamental mempengaruhi ruang lingkup pengujian kami dan bagaimana kami memahami dan menanggapi kegagalan pengujian. <br><br>  <b>Pengujian</b> <br><br>  Dalam kode yang ada, kami memiliki struktur <code>HTTPStockService</code> , yang memungkinkan kami memastikan secara terpisah bahwa ia dapat berkomunikasi dengan layanan pertukaran dan mengurai respons yang diterima darinya.  Tetapi sekarang mari kita pastikan bahwa analisis dapat menangani respons dari antarmuka <code>StockExchange</code> , apalagi, bahwa operasi ini dapat diandalkan dan dapat direproduksi. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  KITA BISA menggunakan implementasi dengan HTTP, tetapi itu akan memiliki banyak kelemahan.  Melakukan panggilan jaringan dalam pengujian unit mungkin lambat, terutama untuk layanan eksternal.  Karena keterlambatan dan koneksi jaringan yang tidak stabil, tes bisa berubah menjadi tidak dapat diandalkan.  Selain itu, jika kami memerlukan pengujian dengan pernyataan bahwa kami dapat menyelesaikan transaksi, dan pengujian dengan pernyataan bahwa kami dapat menyaring kasus-kasus di mana transaksi TIDAK boleh disimpulkan, akan sulit untuk menemukan data produksi nyata yang dapat diandalkan untuk memenuhi kedua hal ini. kondisi.  Seseorang dapat memilih <code>maxTradePrice</code> , meniru secara artifisial setiap kondisi dengan cara ini, misalnya, dengan <code>maxTradePrice := -100</code> transaksi tidak boleh diselesaikan, dan <code>maxTradePrice := 10000000</code> jelas harus diakhiri dengan transaksi. <br><br>  Tetapi apa yang terjadi jika kuota tertentu dialokasikan kepada kami pada layanan pertukaran?  Atau jika kita harus membayar akses?  Akankah kita benar-benar (dan harus) membayar atau menghabiskan kuota kita ketika datang ke unit test?  Idealnya, tes harus dijalankan sesering mungkin, sehingga harus cepat, murah, dan dapat diandalkan.  Saya pikir dari paragraf ini jelas mengapa menggunakan versi dengan HTTP murni tidak rasional dalam hal pengujian! <br><br>  <b>Ada cara yang lebih baik, dan itu melibatkan penggunaan antarmuka!</b> <br><br>  Memiliki antarmuka, Anda dapat dengan hati-hati membuat implementasi <code>StockExchange</code> , yang memungkinkan kami <code>analyze</code> dengan cepat, aman, dan andal. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Potongan dari layanan pertukaran digunakan di atas, berkat cabang yang menarik bagi kami dalam <code>analyze</code> diluncurkan.  Kemudian, pernyataan dibuat di setiap tes untuk memastikan bahwa analisis melakukan apa yang diperlukan.  Meskipun ini adalah program pengujian, pengalaman saya menunjukkan bahwa komponen / arsitektur, di mana antarmuka digunakan kira-kira dengan cara ini, diuji dengan cara ini untuk daya tahan dalam kode pertempuran juga !!!  Berkat antarmuka, kita dapat menggunakan <code>StockExchange</code> dikontrol dalam memori, yang menyediakan pengujian yang andal, mudah dapat dikonfigurasi, mudah dimengerti, direproduksi, dan secepat kilat !!! <br><br>  <b>Lepas sematan - Konfigurasi Penelepon</b> <br><br>  Sekarang kita telah membahas bagaimana menggunakan antarmuka untuk melepaskan penelepon dari callee, dan bagaimana melakukan beberapa implementasi, kami masih belum menyentuh pada aspek kritis.  Bagaimana cara mengkonfigurasi dan menyediakan implementasi spesifik pada waktu yang ditentukan secara ketat?  Anda dapat langsung memanggil fungsi analisis, tetapi apa yang harus dilakukan dalam konfigurasi produksi? <br><br>  Di sinilah implementasi dependensi berguna. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Sama seperti dalam kasus pengujian kami, implementasi spesifik StockExchange yang akan digunakan dengan <code>analyze</code> dikonfigurasikan oleh penelepon di luar analisis.  Kemudian dilewatkan (disuntikkan) untuk <code>analyze</code> .  Ini memastikan bahwa analisis TIDAK ADA yang diketahui tentang bagaimana <code>HTTPStockExchange</code> dikonfigurasi.  Mungkin kami ingin memberikan domain http yang akan kami gunakan dalam bentuk bendera baris perintah, dan kemudian menganalisis tidak harus berubah.  Atau apa yang harus dilakukan jika kita perlu menyediakan semacam otentikasi atau token untuk mengakses <code>HTTPStockExchange</code> , yang akan diekstraksi dari lingkungan?  Sekali lagi, analisis tidak boleh berubah. <br><br>  Konfigurasi terjadi pada tingkat di luar <code>analyze</code> , sehingga benar-benar membebaskan analisis dari kebutuhan untuk mengkonfigurasi dependensinya sendiri.  Dengan demikian, pemisahan tugas yang ketat tercapai. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Keputusan rak</b> <br><br>  Mungkin contoh di atas sudah cukup, tetapi masih ada banyak keuntungan lain untuk antarmuka dan injeksi ketergantungan.  Antarmuka memungkinkan menunda keputusan tentang implementasi spesifik.  Meskipun keputusan mengharuskan kita untuk memutuskan perilaku apa yang akan kita dukung, mereka masih memungkinkan kita untuk membuat keputusan tentang implementasi spesifik nanti.  Misalkan kita tahu bahwa kita ingin melakukan transaksi otomatis, tetapi belum yakin penyedia penawaran mana yang akan kita gunakan.  Kelas solusi serupa terus ditangani ketika bekerja dengan gudang data.  Apa yang harus digunakan oleh program kami: mysql, postgres, redis, sistem file, cassandra?  Pada akhirnya, semua ini adalah detail implementasi, dan antarmuka memungkinkan kita untuk menunda keputusan akhir tentang masalah ini.  Mereka memungkinkan kami untuk mengembangkan logika bisnis dari program kami, dan beralih ke solusi teknologi spesifik pada saat terakhir! <br><br>  Terlepas dari kenyataan bahwa teknik ini sendiri menyisakan banyak kemungkinan, sesuatu yang ajaib terjadi pada tingkat perencanaan proyek.  Bayangkan apa yang akan terjadi jika kita menambahkan satu lagi ketergantungan pada antarmuka pertukaran. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Di sini kita akan mengonfigurasi ulang arsitektur kita dalam bentuk grafik asiklik terarah, sehingga segera setelah kita menyetujui rincian antarmuka pertukaran, kita bisa SEPENUHNYA terus bekerja dengan pipa menggunakan <code>HTTPStockExchange</code> .  Kami menciptakan situasi di mana penambahan orang baru ke proyek membantu kami bergerak lebih cepat.  Dengan mengutak-atik arsitektur kita dengan cara ini, kita lebih baik melihat di mana, kapan, dan untuk berapa lama kita bisa melibatkan orang-orang tambahan dalam proyek untuk mempercepat pengiriman seluruh proyek.  Selain itu, karena koneksi antara antarmuka kami lemah, biasanya mudah untuk terlibat dalam pekerjaan, dimulai dengan antarmuka implementasi.  Anda dapat mengembangkan, menguji, dan menguji <code>HTTPStockExchange</code> sepenuhnya terlepas dari program kami! <br><br>  Analisis dependensi arsitektur dan perencanaan sesuai dengan dependensi ini dapat secara drastis mempercepat proyek.  Dengan menggunakan teknik khusus ini, saya dapat dengan cepat menyelesaikan proyek yang diberikan beberapa bulan. <br><br>  <b>Di depan</b> <br><br>  Sekarang harus lebih jelas bagaimana antarmuka dan implementasi dependensi memastikan daya tahan program yang dirancang.  Misalkan kita mengubah penyedia kutipan kami, atau mulai mengalirkan kuota dan menyimpannya secara real time;  ada banyak kemungkinan lain yang Anda inginkan.  Metode analisis dalam bentuk saat ini akan mendukung implementasi yang cocok untuk integrasi dengan antarmuka <code>StockExchange</code> . <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Dengan demikian, dalam banyak kasus, Anda dapat melakukannya tanpa perubahan.  Tidak semuanya, tetapi dalam kasus-kasus yang dapat diprediksi yang mungkin kita temui.  Kami tidak hanya kebal dari kebutuhan untuk mengubah kode <code>analyze</code> dan memeriksa ulang fungsionalitas utamanya, tetapi kami dapat dengan mudah menawarkan implementasi baru atau beralih di antara pemasok.  Kami juga dapat dengan lancar memperluas atau memperbarui implementasi spesifik yang sudah kami miliki tanpa perlu mengubah atau memeriksa ulang <code>analyze</code> ! <br><br>  Saya berharap contoh-contoh di atas secara meyakinkan menunjukkan bagaimana melemahnya komunikasi antara entitas dalam program melalui penggunaan antarmuka sepenuhnya reorientasi dependensi dan memisahkan penelepon dari penelepon.  Berkat detasemen ini, program tidak bergantung pada implementasi spesifik, tetapi tergantung pada <b>perilaku</b> tertentu.  Perilaku ini dapat disediakan oleh berbagai implementasi.  Prinsip desain kritis ini juga disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengetik bebek</a> . <br><br>  Konsep antarmuka dan ketergantungan pada perilaku, dan bukan pada implementasi, sangat kuat sehingga saya menganggap antarmuka sebagai bahasa primitif - ya, ini sangat radikal.  Saya berharap contoh-contoh yang dibahas di atas ternyata cukup meyakinkan, dan Anda akan setuju bahwa antarmuka dan injeksi ketergantungan harus digunakan sejak awal proyek.  Di hampir semua proyek yang saya kerjakan, diperlukan bukan hanya satu, tetapi setidaknya dua implementasi: untuk produksi dan untuk pengujian. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428075/">https://habr.com/ru/post/id428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428063/index.html">Browser menolak dukungan untuk TLS 1.0 dan 1.1</a></li>
<li><a href="../id428065/index.html">Lebih sedikit tidak berarti lebih buruk: langit dan dinding domain di ferromagnet</a></li>
<li><a href="../id428067/index.html">AntiFuzzing: Keamanan melalui ketidakjelasan!?</a></li>
<li><a href="../id428069/index.html">Optimalkan load balancing dalam infrastruktur Veeam Backup & Replication</a></li>
<li><a href="../id428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../id428077/index.html">React.js: A Beginner's Guide</a></li>
<li><a href="../id428079/index.html">Menerapkan Prinsip SOLID untuk Bereaksi Pengembangan Aplikasi</a></li>
<li><a href="../id428081/index.html">Menggunakan RxJS dalam React Development untuk Mengelola Status Aplikasi</a></li>
<li><a href="../id428083/index.html">Matriks pengaruh analisis web - sistem strategis Avinash Koshik</a></li>
<li><a href="../id428085/index.html">Frontend menyerang kembali: top 10 (?) HolyJS 2018 Piter melaporkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>