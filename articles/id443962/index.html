<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèæ üë®üèΩ‚Äçüè´ üôÖüèæ Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 3 üåû üî• üÜï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading 


 Sekarang mari kita bicara tentang es tipis. Pada bagian sebelumnya tentang IDisposable kami menyentuh satu konsep yang sangat penti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443962/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="multithreading">  Multithreading </h2><br><p>  Sekarang mari kita bicara tentang es tipis.  Pada bagian sebelumnya tentang IDisposable kami menyentuh satu konsep yang sangat penting yang mendasari tidak hanya prinsip-prinsip desain tipe Disposable tetapi semua tipe pada umumnya.  Ini adalah konsep integritas objek.  Ini berarti bahwa pada suatu waktu tertentu suatu objek berada dalam keadaan yang ditentukan secara ketat dan tindakan apa pun dengan objek ini mengubah kondisinya menjadi salah satu opsi yang telah ditentukan sebelumnya saat merancang jenis objek ini.  Dengan kata lain, tidak ada tindakan dengan objek yang dapat mengubahnya menjadi keadaan yang tidak ditentukan.  Ini menghasilkan masalah dengan tipe yang dirancang dalam contoh di atas.  Mereka bukan thread-safe.  Ada kemungkinan metode publik jenis ini akan dipanggil ketika penghancuran objek sedang berlangsung.  Mari kita selesaikan masalah ini dan putuskan apakah kita harus menyelesaikannya sama sekali. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre><code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; object _disposingSync = new object(); public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Seek(int position) { lock(_disposingSync) { CheckDisposed(); // Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Kode validasi <code>_disposed</code> dalam Buang () harus diinisialisasi sebagai bagian kritis.  Bahkan, seluruh kode metode publik harus diinisialisasi sebagai bagian penting.  Ini akan memecahkan masalah akses bersamaan ke metode publik dari jenis instance dan ke metode penghancurannya.  Namun, itu membawa masalah lain yang menjadi bom waktu: </p><br><ul><li>  Penggunaan intensif metode instance type serta penciptaan dan penghancuran objek akan menurunkan kinerja secara signifikan.  Ini karena mengambil kunci menghabiskan waktu.  Waktu ini diperlukan untuk mengalokasikan tabel SyncBlockIndex, memeriksa utas saat ini dan banyak hal lainnya (kita akan membahasnya dalam bab tentang multithreading).  Itu berarti kita harus mengorbankan kinerja objek selama masa hidupnya untuk "jarak terakhir" hidupnya. </li><li>  Lalu lintas memori tambahan untuk objek sinkronisasi. </li><li>  Langkah-langkah tambahan yang harus diambil GC untuk melalui grafik objek. </li></ul><br><p>  Sekarang, beri nama yang kedua dan, menurut saya, yang paling penting.  Kami mengizinkan penghancuran suatu objek dan pada saat yang sama berharap untuk bekerja dengannya lagi.  Apa yang kita harapkan dalam situasi ini?  bahwa itu akan gagal?  Karena jika Buang berjalan terlebih dahulu, maka penggunaan metode objek berikut ini pasti akan menghasilkan <code>ObjectDisposedException</code> .  Jadi, Anda harus mendelegasikan sinkronisasi antara panggilan Buang () dan metode publik lainnya dari jenis ke sisi layanan, yaitu ke kode yang membuat instance kelas <code>FileWrapper</code> .  Itu karena hanya sisi penciptaan yang tahu apa yang akan dilakukannya dengan instance kelas dan kapan harus menghancurkannya.  Di sisi lain, panggilan Buang harus menghasilkan hanya kesalahan kritis, seperti <code>OutOfMemoryException</code> , tetapi bukan IOException misalnya.  Ini karena persyaratan untuk arsitektur kelas yang mengimplementasikan IDisposable.  Ini berarti bahwa jika Buang dipanggil dari lebih dari satu utas pada satu waktu, penghancuran suatu entitas dapat terjadi dari dua utas secara bersamaan (kami melewatkan pemeriksaan <code>if(_disposed) return;</code> ).  Itu tergantung pada situasinya: jika sumber daya <em>dapat</em> dilepaskan beberapa kali, tidak perlu ada pemeriksaan tambahan.  Kalau tidak, perlindungan diperlukan: </p><br><pre> <code class="plaintext hljs">// I don't show the whole pattern on purpose as the example will be too long // and will not show the essence class Disposable : IDisposable { private volatile int _disposed; public void Dispose() { if(Interlocked.CompareExchange(ref _disposed, 1, 0) == 0) { // dispose } } }</code> </pre> <br><h2 id="two-levels-of-disposable-design-principle">  Dua tingkat Prinsip Desain Sekali Pakai </h2><br><p>  Apa pola paling populer untuk mengimplementasikan <code>IDisposable</code> yang dapat Anda temui di .NET books dan Internet?  Pola apa yang diharapkan dari Anda selama wawancara untuk pekerjaan baru yang potensial?  Kemungkinan besar yang ini: </p><br><pre> <code class="plaintext hljs">public class Disposable : IDisposable { bool _disposed; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(disposing) { // here we release managed resources } // here we release unmanaged resources } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</code> </pre> <br><p>  Apa yang salah dengan contoh ini dan mengapa kami belum menulis seperti ini sebelumnya?  Faktanya, ini adalah pola yang cocok untuk semua situasi.  Namun, penggunaannya di mana-mana bukanlah gaya yang baik menurut saya karena kita hampir tidak berurusan dengan sumber daya yang tidak dikelola dalam praktik yang membuat setengah dari pola tidak ada gunanya.  Selain itu, karena secara bersamaan mengelola sumber daya yang dikelola dan tidak dikelola, itu melanggar prinsip pembagian tanggung jawab.  Saya pikir ini salah.  Mari kita lihat pendekatan yang sedikit berbeda.  <em>Prinsip Desain Sekali Pakai</em> .  Secara singkat, ini berfungsi sebagai berikut: </p><br><p>  Membuang dibagi menjadi dua tingkatan kelas: </p><br><ul><li>  Tipe Level 0 secara langsung merangkum sumber daya yang tidak dikelola <br><ul><li>  Mereka abstrak atau dikemas. </li><li>  Semua metode harus ditandai: <br>  - PrePrepareMethod, sehingga suatu metode dapat dikompilasi saat memuat suatu tipe <br><ul><li>  SecuritySafeCritical untuk melindungi terhadap panggilan dari kode, bekerja di bawah batasan </li><li>  ReliabilityContract (Consistency.WillNotCorruptState, Cer.Success / MayFail)] untuk meletakkan CER untuk suatu metode dan semua panggilan anaknya <br>  - Mereka dapat mereferensikan tipe Level 0, tetapi harus menambah counter objek referensi untuk menjamin urutan yang tepat untuk memasuki "jarak terakhir" </li></ul></li></ul></li><li>  Tipe Level 1 merangkum hanya sumber daya yang dikelola <br><ul><li>  Mereka hanya diwarisi dari tipe Level 1 atau langsung menerapkan IDisposable </li><li>  Mereka tidak dapat mewarisi tipe Level 0 atau CriticalFinalizerObject </li><li>  Mereka dapat merangkum tipe terkelola Level 1 dan Level 0 </li><li>  Mereka menerapkan IDisposable. Buang dengan menghancurkan objek yang dienkapsulasi mulai dari tipe Level 0 dan pergi ke Level 1 </li><li>  Mereka tidak menerapkan finalizer karena mereka tidak berurusan dengan sumber daya yang tidak dikelola </li><li>  Mereka harus berisi properti yang dilindungi yang memberikan akses ke tipe Level 0. </li></ul></li></ul><br><p>  Itulah mengapa saya menggunakan divisi menjadi dua jenis dari awal: yang berisi sumber daya yang dikelola dan yang dengan sumber daya yang tidak dikelola.  Mereka harus berfungsi secara berbeda. </p><br><h2 id="other-ways-to-use-dispose">  Cara lain untuk menggunakan Buang </h2><br><p>  Gagasan di balik penciptaan IDisposable adalah untuk melepaskan sumber daya yang tidak dikelola.  Tetapi seperti banyak pola lainnya, sangat membantu untuk tugas-tugas lain, misalnya untuk melepaskan referensi ke sumber daya yang dikelola.  Meskipun melepaskan sumber daya yang dikelola tidak terdengar sangat membantu.  Maksud saya mereka dipanggil dikelola dengan sengaja sehingga kita akan bersantai dengan senyum tentang pengembang C / C ++, kan?  Namun, tidak demikian.  Mungkin selalu ada situasi di mana kita kehilangan referensi ke suatu objek tetapi pada saat yang sama berpikir bahwa semuanya baik-baik saja: GC akan mengumpulkan sampah, termasuk objek kita.  Namun, ternyata ingatan itu bertambah.  Kami masuk ke program analisis memori dan melihat bahwa ada sesuatu yang memegang objek ini.  Masalahnya adalah bahwa mungkin ada logika untuk menangkap secara implisit referensi ke entitas Anda di kedua platform .NET dan arsitektur kelas eksternal.  Karena penangkapannya tersirat, seorang programmer dapat kehilangan kebutuhan akan rilisnya dan kemudian mendapatkan kebocoran memori. </p><br><h3 id="delegates-events">  Delegasi, acara </h3><br><p>  Mari kita lihat contoh sintetis ini: </p><br><pre> <code class="plaintext hljs">class Secondary { Action _action; void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action(); } } class Primary { Secondary _foo = new Secondary(); public void PlanSayHello() { _foo.SaveForUseInFuture(Strategy); } public void SayHello() { _foo.CallAction(); } void Strategy() { Console.WriteLine("Hello!"); } }</code> </pre> <br><p>  Masalah apa yang ditunjukkan oleh kode ini?  Toko kelas kedua mendelegasikan tipe <code>Action</code> di bidang <code>_action</code> yang diterima dalam metode <code>SaveForUseInFuture</code> .  Selanjutnya, metode <code>PlanSayHello</code> di dalam kelas <code>Primary</code> melewati pointer ke metode <code>Strategy</code> ke kelas <code>Secondary</code> .  Sangat mengherankan, tetapi jika, dalam contoh ini, Anda melewati suatu metode statis atau metode instance, <code>SaveForUseInFuture</code> disahkan tidak akan diubah, tetapi instance kelas <code>Primary</code> akan direferensikan <em>secara implisit</em> atau tidak direferensikan sama sekali.  Dari luar sepertinya Anda menginstruksikan metode mana yang harus dihubungi.  Namun pada kenyataannya, sebuah delegasi dibangun tidak hanya menggunakan pointer metode tetapi juga menggunakan pointer ke instance kelas.  Pihak yang menelepon harus memahami untuk instance kelas apa yang harus memanggil metode <code>Strategy</code> !  Itu adalah instance dari kelas <code>Secondary</code> telah secara implisit menerima dan memegang pointer ke instance dari kelas <code>Primary</code> , meskipun tidak ditunjukkan secara eksplisit.  Bagi kami itu hanya berarti bahwa jika kita melewati pointer <code>_foo</code> tempat lain dan kehilangan referensi ke <code>Primary</code> , maka GC <em>tidak akan mengumpulkan</em> objek <code>Primary</code> , karena <code>Secondary</code> akan menahannya.  Bagaimana kita bisa menghindari situasi seperti itu?  Kami membutuhkan pendekatan yang ditentukan untuk merilis referensi kepada kami.  Sebuah mekanisme yang sangat cocok dengan tujuan ini dapat digunakan <code>IDisposable</code> </p><br><pre> <code class="plaintext hljs">// This is a simplified implementation class Secondary : IDisposable { Action _action; public event Action&lt;Secondary&gt; OnDisposed; public void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action?.Invoke(); } void Dispose() { _action = null; OnDisposed?.Invoke(this); } }</code> </pre> <br><p>  Sekarang contohnya terlihat dapat diterima.  Jika instance kelas dilewatkan ke pihak ketiga dan referensi ke delegasi <code>_action</code> akan hilang selama proses ini, kami akan menetapkannya menjadi nol dan pihak ketiga akan diberitahu tentang penghancuran instance dan menghapus referensi untuk itu . <br>  Bahaya kedua kode yang dijalankan pada delegasi adalah prinsip-prinsip <code>event</code> berfungsi.  Mari kita lihat apa hasilnya: </p><br><pre> <code class="plaintext hljs"> // a private field of a handler private Action&lt;Secondary&gt; _event; // add/remove methods are marked as [MethodImpl(MethodImplOptions.Synchronized)] // that is similar to lock(this) public event Action&lt;Secondary&gt; OnDisposed { add { lock(this) { _event += value; } } remove { lock(this) { _event -= value; } } }</code> </pre> <br><p>  C # messaging menyembunyikan internal peristiwa dan menyimpan semua objek yang berlangganan untuk memperbarui melalui <code>event</code> .  Jika terjadi kesalahan, referensi ke objek yang ditandatangani tetap di <code>OnDisposed</code> dan akan menahan objek.  Ini adalah situasi yang aneh karena dari segi arsitektur kita mendapatkan konsep "sumber acara" yang tidak boleh menyimpan apa pun secara logis.  Namun pada kenyataannya, objek yang berlangganan pembaruan diadakan secara implisit.  Selain itu, kami tidak dapat mengubah sesuatu di dalam array delegasi ini meskipun entitas itu milik kami.  Satu-satunya hal yang dapat kita lakukan adalah menghapus daftar ini dengan menetapkan nol ke sumber acara. </p><br><p>  Cara kedua adalah menerapkan metode <code>add</code> / <code>remove</code> secara eksplisit, sehingga kami dapat mengontrol koleksi delegasi. </p><br><blockquote>  Situasi implisit lain mungkin muncul di sini.  Tampaknya jika Anda menetapkan nol untuk sumber acara, berlangganan acara berikut akan menyebabkan <code>NullReferenceException</code> .  Saya pikir ini akan lebih logis. </blockquote><p>  Namun, ini tidak benar.  Jika kode eksternal berlangganan acara setelah sumber acara dihapus, FCL akan membuat instance baru dari kelas Action dan menyimpannya di <code>OnDisposed</code> .  Implisit ini dalam C # dapat menyesatkan seorang programmer: berurusan dengan bidang yang dibatalkan harus menghasilkan semacam kewaspadaan daripada ketenangan.  Di sini kami juga menunjukkan pendekatan ketika kecerobohan seorang programmer dapat menyebabkan kebocoran memori. </p><br><h3 id="lambdas-closures">  Penutupan Lambdas </h3><br><p>  Menggunakan gula sintaksis seperti lambda sangat berbahaya. </p><br><blockquote>  Saya ingin menyentuh gula sintaksis secara keseluruhan.  Saya pikir Anda harus menggunakannya dengan hati-hati dan hanya jika Anda tahu hasilnya dengan tepat.  Contoh dengan ekspresi lambda adalah penutupan, penutupan dalam Ekspresi dan banyak kesengsaraan lain yang dapat Anda lakukan pada diri Anda sendiri. </blockquote><p>  Tentu saja, Anda bisa mengatakan Anda tahu bahwa ekspresi lambda menciptakan penutupan dan dapat mengakibatkan risiko kebocoran sumber daya.  Tapi itu sangat rapi, sangat menyenangkan sehingga sulit untuk menghindari menggunakan lambda daripada mengalokasikan seluruh metode, yang akan dijelaskan di tempat yang berbeda dari tempat akan digunakan.  Sebenarnya, Anda tidak boleh ikut serta dalam provokasi ini, meskipun tidak semua orang bisa menolak.  Mari kita lihat contohnya: </p><br><pre> <code class="plaintext hljs"> button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);</code> </pre> <br><p>  Setuju, garis ini terlihat sangat aman.  Tapi itu menyembunyikan masalah besar: sekarang <code>button</code> variabel secara implisit merujuk <code>service</code> dan menahannya.  Bahkan jika kita memutuskan bahwa kita tidak membutuhkan <code>service</code> lagi, <code>button</code> masih akan menyimpan referensi saat variabel ini aktif.  Salah satu cara untuk mengatasi masalah ini adalah dengan menggunakan pola untuk membuat <code>IDisposable</code> dari <code>Action</code> apa pun ( <code>System.Reactive.Disposables</code> ): </p><br><pre> <code class="plaintext hljs">// Here we create a delegate from a lambda Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy); // Here we subscribe button.Clicked += action; // We unsubscribe var subscription = Disposable.Create(() =&gt; button.Clicked -= action); // where it is necessary subscription.Dispose();</code> </pre> <br><p>  Akui, ini terlihat agak panjang dan kita kehilangan seluruh tujuan menggunakan ekspresi lambda.  Jauh lebih aman dan sederhana untuk menggunakan metode pribadi yang umum untuk menangkap variabel secara implisit. </p><br><h3 id="threadabort-protection">  Perlindungan threadabort </h3><br><p>  Saat Anda membuat perpustakaan untuk pengembang pihak ketiga, Anda tidak bisa memprediksi perilakunya dalam aplikasi pihak ketiga.  Terkadang Anda hanya bisa menebak apa yang dilakukan oleh seorang programmer terhadap perpustakaan Anda yang menyebabkan hasil tertentu.  Salah satu contoh berfungsi di lingkungan multithreaded ketika konsistensi pembersihan sumber daya dapat menjadi masalah kritis.  Perhatikan bahwa saat kami menulis metode <code>Dispose()</code> , kami dapat menjamin tidak adanya pengecualian.  Namun, kami tidak dapat memastikan bahwa saat menjalankan metode <code>Dispose()</code> tidak akan ada <code>ThreadAbortException</code> yang menonaktifkan utas eksekusi kami.  Di sini kita harus ingat bahwa ketika <code>ThreadAbortException</code> terjadi, semua blok catch / akhirnya dieksekusi (pada akhir catch / akhirnya block ThreadAbort terjadi lebih jauh).  Jadi, untuk memastikan eksekusi kode tertentu dengan menggunakan Thread.Abort, Anda perlu membungkus bagian kritis di <code>try { ... } finally { ... }</code> , lihat contoh di bawah ini: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; _someInstance.Unsubscribe(this); _disposed = true; }</code> </pre> <br><p>  Seseorang dapat membatalkan ini kapan saja menggunakan <code>Thread.Abort</code> .  Ini sebagian menghancurkan objek, meskipun Anda masih bisa bekerja dengannya di masa depan.  Pada saat yang sama, kode berikut: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; // ThreadAbortException protection try {} finally { _someInstance.Unsubscribe(this); _disposed = true; } }</code> </pre> <br><p>  dilindungi dari pembatalan tersebut dan akan berjalan dengan lancar dan pasti, bahkan jika <code>Thread.Abort</code> muncul di antara memanggil metode <code>Unsubscribe</code> dan menjalankan instruksinya. </p><br><h2 id="results">  Hasil </h2><br><h3 id="advantages">  Keuntungan </h3><br><p>  Ya, kami belajar banyak tentang pola paling sederhana ini.  Mari kita tentukan keunggulannya: </p><br><ol><li>  Keuntungan utama dari pola ini adalah kemampuan untuk melepaskan sumber daya secara pasti, yaitu saat Anda membutuhkannya. </li><li>  Keuntungan kedua adalah pengenalan cara yang sudah terbukti untuk memeriksa jika instance spesifik mengharuskan untuk menghancurkan instansnya setelah digunakan. </li><li>  Jika Anda menerapkan pola dengan benar, tipe yang dirancang akan berfungsi dengan aman dalam hal penggunaan oleh komponen pihak ketiga serta dalam hal pembongkaran dan penghancuran sumber daya saat proses macet (misalnya karena kurangnya memori).  Ini adalah keuntungan terakhir. </li></ol><br><h3 id="disadvantages">  Kekurangan </h3><br><p>  Menurut pendapat saya, pola ini memiliki lebih banyak kerugian daripada keuntungan. </p><br><ol><li>  Di satu sisi, jenis apa pun yang menerapkan pola ini menginstruksikan bagian lain bahwa jika mereka menggunakannya mereka mengambil semacam penawaran publik.  Ini sangat implisit bahwa karena dalam kasus penawaran publik, pengguna tipe tidak selalu tahu bahwa tipe tersebut memiliki antarmuka ini.  Dengan demikian Anda harus mengikuti petunjuk IDE (ketik periode, Dis ... dan periksa apakah ada metode dalam daftar anggota kelas yang difilter).  Jika Anda melihat pola Buang, Anda harus menerapkannya dalam kode Anda.  Kadang-kadang itu tidak terjadi langsung dan dalam hal ini Anda harus menerapkan pola melalui sistem tipe yang menambah fungsionalitas.  Contoh yang baik adalah <code>IEnumerator&lt;T&gt;</code> memerlukan <code>IDisposable</code> . </li><li>  Biasanya ketika Anda mendesain antarmuka, ada kebutuhan untuk memasukkan IDisposable ke dalam sistem antarmuka tipe ketika salah satu antarmuka harus mewarisi IDisposable.  Menurut pendapat saya, ini merusak antarmuka yang kami desain.  Maksud saya ketika Anda mendesain antarmuka, Anda membuat protokol interaksi terlebih dahulu.  Ini adalah serangkaian tindakan yang dapat Anda lakukan dengan <em>sesuatu yang</em> tersembunyi di balik antarmuka.  <code>Dispose()</code> adalah metode untuk menghancurkan instance kelas.  Ini bertentangan dengan esensi dari <em>protokol interaksi</em> .  Bahkan, ini adalah detail implementasi yang menyusup ke antarmuka. </li><li>  Meskipun telah ditentukan, Buang () tidak berarti penghancuran objek secara langsung.  Objek akan tetap ada setelah <em>kehancurannya</em> tetapi di negara lain.  Untuk menjadikannya benar, CheckDisposed () harus menjadi perintah pertama dari setiap metode publik.  Ini terlihat seperti solusi sementara yang diberikan seseorang kepada kami: "Majulah dan berlipat ganda"; </li><li>  Ada juga peluang kecil untuk mendapatkan tipe yang mengimplementasikan <code>IDisposable</code> melalui implementasi <em>eksplisit</em> .  Atau Anda bisa mendapatkan tipe yang mengimplementasikan ID yang dapat digunakan tanpa kesempatan untuk menentukan siapa yang harus menghancurkannya: Anda atau pihak yang memberikannya kepada Anda.  Ini menghasilkan antipattern dari beberapa panggilan Buang () yang memungkinkan untuk menghancurkan objek yang dihancurkan; </li><li>  Implementasi yang lengkap sulit, dan berbeda untuk sumber daya yang dikelola dan tidak dikelola.  Di sini upaya untuk memfasilitasi pekerjaan pengembang melalui GC terlihat canggung.  Anda bisa mengesampingkan metode buang <code>virtual void Dispose()</code> dan memperkenalkan beberapa jenis DisposableObject yang mengimplementasikan seluruh pola, tetapi itu tidak menyelesaikan masalah lain yang terhubung dengan pola; </li><li>  Sebagai aturan, metode Buang () diimplementasikan di akhir file sementara '.tor' dideklarasikan di awal.  Jika Anda memodifikasi kelas atau memperkenalkan sumber daya baru, mudah untuk lupa menambahkan pembuangan untuk mereka. </li><li>  Akhirnya, sulit untuk menentukan urutan <em>kehancuran</em> dalam lingkungan multithreaded ketika Anda menggunakan pola untuk grafik objek di mana objek sepenuhnya atau sebagian menerapkan pola itu.  Maksud saya situasi ketika Buang () dapat mulai dari berbagai ujung grafik.  Di sini lebih baik menggunakan pola lain, misalnya pola Seumur Hidup. </li><li>  Keinginan pengembang platform untuk mengotomatisasi kontrol memori yang dikombinasikan dengan kenyataan: aplikasi berinteraksi dengan kode yang tidak terkelola sangat sering + Anda perlu mengontrol pelepasan referensi ke objek sehingga Pengumpul Sampah dapat mengumpulkannya.  Ini menambah kebingungan besar dalam memahami pertanyaan seperti: "Bagaimana seharusnya kita menerapkan pola dengan benar"?  ‚ÄúApakah ada pola yang dapat diandalkan sama sekali‚Äù?  Mungkin memanggil <code>delete obj; delete[] arr;</code> <code>delete obj; delete[] arr;</code>  lebih sederhana? </li></ol><br><h2 id="domain-unloading-and-exit-from-an-application">  Bongkar domain dan keluar dari aplikasi </h2><br><p>  Jika Anda sampai di bagian ini, Anda menjadi lebih percaya diri dalam keberhasilan wawancara kerja di masa depan.  Namun, kami tidak membahas semua pertanyaan yang terkait dengan pola sederhana ini, seperti yang terlihat, pola.  Pertanyaan terakhir adalah apakah perilaku aplikasi berbeda dalam hal pengumpulan sampah sederhana dan ketika sampah dikumpulkan selama pembongkaran domain dan saat keluar dari aplikasi.  Pertanyaan ini hanya menyentuh pada <code>Dispose()</code> ... Namun <code>Dispose()</code> dan finalisasi berjalan seiring dan kami jarang bertemu dengan implementasi kelas yang memiliki finalisasi tetapi tidak memiliki metode <code>Dispose()</code> .  Jadi, mari gambarkan finalisasi di bagian terpisah.  Di sini kita hanya menambahkan beberapa detail penting. </p><br><p>  Selama pembongkaran domain aplikasi, Anda membongkar rakitan yang dimuat ke domain aplikasi dan semua objek yang dibuat sebagai bagian dari domain untuk dibongkar.  Bahkan, ini berarti pembersihan (pengumpulan oleh GC) dari objek-objek ini dan memanggil finalizer untuk mereka.  Jika logika finalizer menunggu finalisasi objek lain untuk dihancurkan dalam urutan yang benar, Anda dapat memperhatikan properti <code>Environment.HasShutdownStarted</code> menunjukkan bahwa aplikasi diturunkan dari memori dan ke <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code> metode yang menunjukkan bahwa ini domain dibongkar yang merupakan alasan untuk finalisasi.  Jika peristiwa ini terjadi, urutan finalisasi sumber daya umumnya menjadi tidak penting.  Kami tidak dapat menunda pembongkaran domain atau aplikasi karena kami harus melakukan semuanya secepat mungkin. </p><br><p>  Ini adalah cara tugas ini diselesaikan sebagai bagian dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LoaderAllocatorScout</a> </p><br><pre> <code class="plaintext hljs">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in // an unmanaged code // So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown. // We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList. if (!Environment.HasShutdownStarted &amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()) { // Destroy returns false if the managed LoaderAllocator is still alive. if (!Destroy(m_nativeLoaderAllocator)) { // Somebody might have been holding a reference on us via weak handle. // We will keep trying. It will be hopefully released eventually. GC.ReRegisterForFinalize(this); } }</code> </pre> <br><h2 id="typical-implementation-faults">  Kesalahan implementasi yang umum </h2><br><p>  Seperti yang saya tunjukkan kepada Anda, tidak ada pola universal untuk mengimplementasikan IDisposable.  Selain itu, beberapa ketergantungan pada kontrol memori otomatis menyesatkan orang dan mereka membuat keputusan yang membingungkan ketika menerapkan suatu pola.  Keseluruhan .NET Framework penuh dengan kesalahan dalam implementasinya.  Untuk membuktikan maksud saya, mari kita lihat kesalahan ini menggunakan contoh .NET Framework.  Semua implementasi tersedia melalui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IDisposable Usages</a> </p><br><p>  <strong>FileEntry Class</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cmsinterop.cs</a> </p><br><blockquote>  Kode ini ditulis terburu-buru hanya untuk menutup masalah.  Jelas, penulis ingin melakukan sesuatu tetapi berubah pikiran dan menyimpan solusi yang cacat </blockquote><br><pre> <code class="plaintext hljs">internal class FileEntry : IDisposable { // Other fields // ... [MarshalAs(UnmanagedType.SysInt)] public IntPtr HashValue; // ... ~FileEntry() { Dispose(false); } // The implementation is hidden and complicates calling the *right* version of a method. void IDisposable.Dispose() { this.Dispose(true); } // Choosing a public method is a serious mistake that allows for incorrect destruction of // an instance of a class. Moreover, you CANNOT call this method from the outside public void Dispose(bool fDisposing) { if (HashValue != IntPtr.Zero) { Marshal.FreeCoTaskMem(HashValue); HashValue = IntPtr.Zero; } if (fDisposing) { if( MuiMapping != null) { MuiMapping.Dispose(true); MuiMapping = null; } System.GC.SuppressFinalize(this); } } }</code> </pre> <br><p>  <a href="">Sistem</a> <strong>Kelas SemaphoreSlim</strong> <a href="">/ Threading / SemaphoreSlim.cs</a> </p><br><blockquote>  Kesalahan ini ada di bagian atas kesalahan .NET Framework mengenai IDisposable: SuppressFinalize untuk kelas di mana tidak ada finalizer.  Ini sangat umum. </blockquote><br><pre> <code class="plaintext hljs">public void Dispose() { Dispose(true); // As the class doesn't have a finalizer, there is no need in GC.SuppressFinalize GC.SuppressFinalize(this); } // The implementation of this pattern assumes the finalizer exists. But it doesn't. // It was possible to do with just public virtual void Dispose() protected virtual void Dispose(bool disposing) { if (disposing) { if (m_waitHandle != null) { m_waitHandle.Close(); m_waitHandle = null; } m_lockObj = null; m_asyncHead = null; m_asyncTail = null; } }</code> </pre> <br><p>  <strong>Menelepon Tutup + Buang</strong> <a href="">Beberapa kode proyek NativeWatcher</a> </p><br><blockquote>  Terkadang orang memanggil Tutup dan Buang.  Ini salah meskipun tidak akan menghasilkan kesalahan karena Buang kedua tidak menghasilkan pengecualian. </blockquote><p>  Faktanya, Close adalah pola lain untuk membuat segalanya lebih jelas bagi orang-orang.  Namun, itu membuat semuanya lebih tidak jelas. </p><br><pre> <code class="plaintext hljs">public void Dispose() { if (MainForm != null) { MainForm.Close(); MainForm.Dispose(); } MainForm = null; }</code> </pre> <br><h2 id="general-results">  Hasil umum </h2><br><ol><li>  IDposable adalah standar platform dan kualitas implementasinya mempengaruhi kualitas aplikasi secara keseluruhan.  Terlebih lagi, dalam beberapa situasi itu memengaruhi keamanan aplikasi Anda yang dapat diserang melalui sumber daya yang tidak dikelola. </li><li>  Implementasi IDisposable harus produktif maksimal.  Ini terutama benar tentang bagian finalisasi, yang bekerja secara paralel dengan kode lainnya, memuat Pengumpul Sampah. </li><li>  Saat menerapkan IDisposable, Anda tidak boleh menggunakan Buang () bersamaan dengan metode umum kelas.  Penghancuran tidak bisa seiring dengan penggunaan.  Ini harus dipertimbangkan ketika mendesain tipe yang akan menggunakan objek IDisposable. </li><li>  Namun, harus ada perlindungan terhadap panggilan 'Buang ()' dari dua utas secara bersamaan.  Ini hasil dari pernyataan bahwa Buang () seharusnya tidak menghasilkan kesalahan. </li><li>  Jenis yang mengandung sumber daya yang tidak dikelola harus dipisahkan dari jenis lainnya.  Maksud saya jika Anda membungkus sumber daya yang tidak dikelola, Anda harus mengalokasikan jenis yang terpisah untuk itu.  Tipe ini harus mengandung finalisasi dan harus diwarisi dari <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code> .  Pemisahan tanggung jawab ini akan menghasilkan dukungan yang lebih baik dari sistem tipe dan akan menyederhanakan implementasi untuk menghancurkan instance tipe melalui Buang (): tipe-tipe dengan implementasi ini tidak perlu mengimplementasikan finalizer. </li><li>  Secara umum, pola ini tidak nyaman digunakan serta dalam pemeliharaan kode.  Mungkin, kita harus menggunakan pendekatan Inversion of Control ketika kita menghancurkan keadaan objek melalui pola <code>Lifetime</code> .  Namun, kita akan membicarakannya di bagian selanjutnya. </li></ol><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443962/">https://habr.com/ru/post/id443962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443952/index.html">Internet Berdaulat - untuk uang kita</a></li>
<li><a href="../id443954/index.html">Singularitas teknologi: mitos modern tentang akhir dunia dengan kedok hipotesis kemajuan</a></li>
<li><a href="../id443956/index.html">Jejaring sosial pada 2019: Yandex meluncurkan Aura</a></li>
<li><a href="../id443958/index.html">Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 1</a></li>
<li><a href="../id443960/index.html">Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 2</a></li>
<li><a href="../id443964/index.html">Kolesa Conf adalah konferensi IT terbesar di Kazakhstan. Pengumuman laporan</a></li>
<li><a href="../id443966/index.html">Google Documents - obrolan favorit di antara para siswa</a></li>
<li><a href="../id443968/index.html">Bagaimana kami membeli rumah dengan panel surya, dan apa yang terjadi</a></li>
<li><a href="../id443972/index.html">Yandex akan mencari bajak laut menggunakan robot</a></li>
<li><a href="../id443974/index.html">Memory and Span pt. 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>