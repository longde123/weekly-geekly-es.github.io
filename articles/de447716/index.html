<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶ üë®üèæ‚Äçüíª üë®üèø‚Äçüé§ Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug üö¢ üë©üèª‚Äçüè≠ üéé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem musste ich ein Problem l√∂sen, das in vielen Top-View-Spielen h√§ufig vorkommt: eine ganze Reihe feindlicher Gesundheitsbalken auf dem Bildsc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Vor kurzem musste ich ein Problem l√∂sen, das in vielen Top-View-Spielen h√§ufig vorkommt: eine ganze Reihe feindlicher Gesundheitsbalken auf dem Bildschirm zu rendern.  So etwas wie das: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Offensichtlich wollte ich dies so effizient wie m√∂glich tun, vorzugsweise in einem Draw Call.  Wie √ºblich habe ich vor Arbeitsbeginn ein wenig online nach den Entscheidungen anderer gesucht, und die Ergebnisse waren sehr unterschiedlich. <br><br>  Ich werde niemanden f√ºr den Code besch√§men, aber es gen√ºgt zu sagen, dass einige der L√∂sungen nicht ganz brillant waren, zum Beispiel hat jemand jedem Feind ein Canvas-Objekt hinzugef√ºgt (was sehr ineffizient ist). <br><br>  Die Methode, zu der ich als Ergebnis gekommen bin, unterscheidet sich geringf√ºgig von allem, was ich mit anderen gesehen habe, und verwendet √ºberhaupt keine UI-Klassen (einschlie√ülich Canvas). Deshalb habe ich beschlossen, sie f√ºr die √ñffentlichkeit zu dokumentieren.  Und f√ºr diejenigen, die den Quellcode lernen wollen, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihn auf Github</a> gepostet. <br><a name="habracut"></a><br><h2>  Warum nicht Canvas verwenden? </h2><br>  Eine Leinwand f√ºr jeden Feind ist offensichtlich eine schlechte Entscheidung, aber ich k√∂nnte eine gemeinsame Leinwand f√ºr alle Feinde verwenden.  Ein einzelner Canvas w√ºrde auch zum Rendern von Anrufbatches f√ºhren. <br><br>  Ich mag jedoch nicht die Menge an Arbeit, die in jedem Rahmen im Zusammenhang mit diesem Ansatz ausgef√ºhrt wird.  Wenn Sie Canvas verwenden, m√ºssen Sie in jedem Frame die folgenden Vorg√§nge ausf√ºhren: <br><br><ul><li>  Bestimmen Sie, welche der Feinde auf dem Bildschirm angezeigt werden, und w√§hlen Sie jeden von ihnen aus dem Pool-UI-Streifen aus. </li><li>  Projizieren Sie die Position des Feindes in der Kamera, um den Streifen zu positionieren. </li><li>  √Ñndern Sie die Gr√∂√üe des "F√ºll" -Teils des Streifens, wahrscheinlich wie bei Image. </li><li>  √Ñndern Sie h√∂chstwahrscheinlich die Gr√∂√üe der Streifen entsprechend der Art der Feinde;  Zum Beispiel sollten gro√üe Feinde gro√üe Streifen haben, damit es nicht albern aussieht. </li></ul><br>  Auf jeden Fall w√ºrde all dies die Canvas-Geometriepuffer kontaminieren und zu einer Neuerstellung aller Scheitelpunktdaten im Prozessor f√ºhren.  Ich wollte nicht, dass dies alles f√ºr ein so einfaches Element getan wird. <br><br><h2>  Kurz √ºber meine Entscheidung </h2><br>  Eine kurze Beschreibung meines Arbeitsprozesses: <br><br><ul><li>  Wir befestigen Objekte mit Energiestreifen in 3D an Feinden. <br><ul><li>  Auf diese Weise k√∂nnen Sie Streifen automatisch anordnen und zuschneiden. </li><li>  Die Position / Gr√∂√üe des Streifens kann je nach Art des Feindes angepasst werden. </li><li>  Wir werden die Streifen im Code mithilfe der Transformation, die noch vorhanden ist, zur Kamera lenken. </li><li>  Der Shader stellt sicher, dass sie immer √ºber allem rendern. </li></ul></li><li>  Wir verwenden Instancing, um alle Streifen in einem einzigen Draw-Aufruf zu rendern. </li><li>  Wir verwenden einfache prozedurale UV-Koordinaten, um den Grad der F√ºlle des Streifens anzuzeigen. </li></ul><br>  Schauen wir uns nun die L√∂sung genauer an. <br><br><h2>  Was ist Instanz? </h2><br>  Bei der Arbeit mit Grafiken wird seit langem die Standardtechnik verwendet: Mehrere Objekte werden so kombiniert, dass sie gemeinsame Scheitelpunktdaten und Materialien haben und in einem Zeichenaufruf gerendert werden k√∂nnen.  Dies ist genau das, was wir brauchen, denn jeder Draw-Aufruf belastet die CPU und die GPU zus√§tzlich.  Anstatt f√ºr jedes Objekt einen einzelnen Zeichenaufruf durchzuf√ºhren, rendern wir alle gleichzeitig und verwenden einen Shader, um jeder Kopie Variabilit√§t hinzuzuf√ºgen. <br><br>  Sie k√∂nnen dies manuell tun, indem Sie die Netzscheitelpunktdaten X-mal in einem Puffer duplizieren, wobei X die maximale Anzahl von Kopien ist, die gerendert werden k√∂nnen, und dann das Array von Shader-Parametern verwenden, um jede Kopie zu konvertieren / zu f√§rben / zu variieren.  Jede Kopie muss Wissen √ºber die nummerierte Instanz speichern, um diesen Wert als Index des Arrays verwenden zu k√∂nnen.  Dann k√∂nnen wir einen indizierten Renderaufruf verwenden, der "Nur auf N rendern" befiehlt, wobei N die Anzahl der Instanzen <em>ist,</em> die im aktuellen Frame <em>tats√§chlich</em> ben√∂tigt werden, weniger als die maximale Anzahl von X. <br><br>  Die meisten modernen APIs verf√ºgen bereits √ºber Code daf√ºr, sodass Sie dies nicht manuell tun m√ºssen.  Diese Operation wird als "Instanzierung" bezeichnet.  Tats√§chlich automatisiert es den oben beschriebenen Prozess mit vordefinierten Einschr√§nkungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Unity-Engine unterst√ºtzt auch die Instanzierung</a> . Sie verf√ºgt √ºber eine eigene API und eine Reihe von Shader-Makros, die bei der Implementierung helfen.  Es werden beispielsweise bestimmte Annahmen verwendet, dass f√ºr jede Instanz eine vollst√§ndige 3D-Transformation erforderlich ist.  Genau genommen wird es f√ºr 2D-Streifen nicht vollst√§ndig ben√∂tigt - wir k√∂nnen Vereinfachungen vornehmen, aber da dies der Fall ist, werden wir sie verwenden.  Dies vereinfacht unseren Shader und bietet auch die M√∂glichkeit, 3D-Indikatoren zu verwenden, z. B. Kreise oder B√∂gen. <br><br><h2>  Klasse sch√§dlich </h2><br>  Unsere Feinde haben eine Komponente namens " <code>Damageable</code> , die ihnen Gesundheit verleiht und ihnen erm√∂glicht, Schaden durch Kollisionen zu erleiden.  In unserem Beispiel ist es ganz einfach: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  HealthBar-Objekt: Position / Drehung </h2><br>  Das Gesundheitsbalkenobjekt ist sehr einfach: Tats√§chlich ist es nur ein Quad, das an den Feind gebunden ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Wir verwenden die <strong>Skala</strong> dieses Objekts, um den Streifen lang und d√ºnn zu machen und ihn direkt √ºber dem Feind zu platzieren.  Machen Sie sich keine Sorgen um die Drehung, wir werden das Problem mithilfe des Codes beheben, der an das Objekt in <code>HealthBar.cs</code> angeh√§ngt ist: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Dieser Code lenkt das Quad immer in Richtung Kamera.  Wir <em>k√∂nnen</em> die Gr√∂√üe √§ndern und im Shader drehen, aber ich implementiere sie hier aus zwei Gr√ºnden. <br><br>  Erstens verwendet die Unity-Instanzierung immer die vollst√§ndige Transformation jedes Objekts, und da wir immer noch alle Daten √ºbertragen, k√∂nnen Sie sie verwenden.  Zweitens stellt das Einstellen der Skalierung / Drehung hier sicher, dass das Begrenzungsparallelogramm zum Trimmen des Streifens immer wahr ist.  Wenn wir die Aufgabe von Gr√∂√üe und Drehung in die Verantwortung des Shaders legen w√ºrden, k√∂nnte Unity die Streifen abschneiden, die sichtbar sein sollten, wenn sie sich nahe an den Bildschirmr√§ndern befinden, da die Gr√∂√üe und Drehung ihres Begrenzungsparallelogramms nicht dem entspricht, was wir rendern werden.  Nat√ºrlich k√∂nnten wir unsere eigene Methode zum Abschneiden implementieren, aber normalerweise ist es, wenn m√∂glich, besser, das zu verwenden, was wir haben (Unity-Code ist nativ und hat Zugriff auf mehr r√§umliche Daten als wir). <br><br>  Ich werde erkl√§ren, wie der Streifen gerendert wird, nachdem wir uns den Shader angesehen haben. <br><br><h2>  Shader HealthBar </h2><br>  In dieser Version erstellen wir einen einfachen klassischen rot-gr√ºnen Streifen. <br><br>  Ich benutze eine 2x1 Textur mit einem gr√ºnen Pixel links und einem roten rechts.  Nat√ºrlich habe ich das Mipmapping, Filtern und Komprimieren deaktiviert und den Adressierungsmodus-Parameter auf Clamp gesetzt. Dies bedeutet, dass die Pixel in unserem Streifen immer perfekt gr√ºn oder rot sind und sich nicht √ºber die R√§nder verteilen.  Auf diese Weise k√∂nnen wir die Texturkoordinaten im Shader √§ndern, um die Trennlinie zwischen den roten und gr√ºnen Pixeln im Streifen nach unten und oben zu verschieben. <br><br>  <em>(Da es nur zwei Farben gibt, kann ich einfach die Schrittfunktion im Shader verwenden, um zum einen oder anderen Punkt zur√ºckzukehren. Bei dieser Methode ist es jedoch praktisch, dass Sie eine komplexere Textur verwenden k√∂nnen, wenn Sie dies w√ºnschen. Dies funktioniert √§hnlich, w√§hrend der √úbergang ausgef√ºhrt wird mittlere Textur.)</em> <br><br>  Zuerst erkl√§ren wir die Eigenschaften, die wir brauchen: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> ist eine rot-gr√ºne Textur und <code>_Fill</code> ist ein Wert von 0 bis 1, wobei 1 die volle Gesundheit ist. <br><br>  Als n√§chstes m√ºssen wir den Streifen so anordnen, dass er in der √úberlagerungswarteschlange gerendert wird. Dies bedeutet, dass die gesamte Tiefe der Szene ignoriert und √ºber alles gerendert wird: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  Der n√§chste Teil ist der Shader-Code selbst.  Wir schreiben einen Shader ohne Beleuchtung (unbeleuchtet), sodass wir uns nicht um die Integration mit verschiedenen Unity-Oberfl√§chen-Shadern k√ºmmern m√ºssen. Dies sind nur einige Vertex- / Fragment-Shader.  Schreiben Sie zuerst Bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Dies ist gr√∂√ütenteils ein Standard-Bootstrap, mit Ausnahme von <code>#pragma multi_compile_instancing</code> , das dem Unity-Compiler <code>#pragma multi_compile_instancing</code> , was f√ºr die Instanz kompiliert werden muss. <br><br>  Die Scheitelpunktstruktur muss Instanzdaten enthalten, daher werden wir Folgendes tun: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Wir m√ºssen auch angeben, was genau in den Daten von Instanzen enthalten sein wird, zus√§tzlich zu den Unity- (Transformations-) Prozessen f√ºr uns: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Wir berichten also, dass Unity einen Puffer namens "Props" erstellen muss, um die Daten f√ºr jede Instanz zu speichern, und darin einen Float pro Instanz f√ºr eine Eigenschaft namens <code>_Fill</code> . <br><br>  Sie k√∂nnen mehrere Puffer verwenden.  Es lohnt sich, wenn Sie mehrere Eigenschaften mit unterschiedlichen Frequenzen aktualisieren lassen.  Wenn Sie sie teilen, k√∂nnen Sie beispielsweise einen Puffer nicht √§ndern, wenn Sie einen anderen √§ndern, was effizienter ist.  Das brauchen wir aber nicht. <br><br>  Unser Vertex-Shader erledigt die Standardarbeit fast vollst√§ndig, da Gr√∂√üe, Position und Drehung bereits zur Transformation √ºbertragen werden.  Dies wird mit <code>UnityObjectToClipPos</code> implementiert, das automatisch die Transformation jeder Instanz verwendet.  Man k√∂nnte sich vorstellen, dass dies ohne Instanzierung normalerweise eine einfache Verwendung einer einzelnen Matrixeigenschaft w√§re.  Bei Verwendung der Instanz innerhalb der Engine sieht es jedoch wie ein Array von Matrizen aus, und Unity w√§hlt unabh√§ngig eine f√ºr diese Instanz geeignete Matrix aus. <br><br>  Au√üerdem m√ºssen Sie die UV- <code>_Fill</code> √§ndern, um die Position des √úbergangspunkts gem√§√ü der Eigenschaft <code>_Fill</code> von rot nach gr√ºn zu <code>_Fill</code> .  Hier ist das relevante Code-Snippet: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> und <code>UNITY_ACCESS_INSTANCED_PROP</code> erledigen die ganze Magie, indem sie aus dem konstanten Puffer f√ºr diese Instanz auf die richtige Version der Eigenschaft <code>_Fill</code> zugreifen. <br><br>  Wir wissen, dass im Normalzustand die UV-Koordinaten des Quadranten das gesamte Texturintervall abdecken und dass sich die Trennlinie des Streifens horizontal in der Mitte der Textur befindet.  Daher verschieben kleine mathematische Berechnungen den Streifen horizontal nach links oder rechts, und der Klemmwert der Textur stellt die F√ºllung des verbleibenden Teils sicher. <br><br>  Der Fragment-Shader k√∂nnte nicht einfacher sein, da alle Arbeiten bereits ausgef√ºhrt wurden: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  Der vollst√§ndige Kommentar-Shader-Code ist im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> verf√ºgbar. <br><br><h2>  Healthbar-Material </h2><br>  Dann ist alles einfach - wir m√ºssen unserem Strip nur das Material zuweisen, das dieser Shader verwendet.  Es muss fast nichts mehr getan werden. W√§hlen Sie einfach den gew√ºnschten Shader im oberen Teil aus, weisen Sie eine rot-gr√ºne Textur zu und <strong>aktivieren Sie</strong> vor allem das <strong>Kontrollk√§stchen ‚ÄûGPU-Instanz aktivieren‚Äú</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="Bild"><br><br><h2>  HealthBar Fill Property Update </h2><br>  Wir haben also das <code>_Fill</code> , den Shader und das zu rendernde Material. Jetzt m√ºssen wir die <code>_Fill</code> Eigenschaft f√ºr jede Instanz <code>_Fill</code> .  Wir machen das in <code>HealthBar.cs</code> wie folgt: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  Wir <code>CurrentHealth</code> die <code>CurrentHealth</code> Klasse in einen Wert von 0 bis 1 um und teilen ihn durch <code>MaxHealth</code> .  Dann √ºbergeben wir es mit <code>MaterialPropertyBlock</code> an die Eigenschaft <code>_Fill</code> . <br><br>  Wenn Sie <code>MaterialPropertyBlock</code> zum √úbertragen von Daten an Shader verwendet haben, auch ohne Instanz, m√ºssen Sie diese untersuchen.  Dies wird in der Unity-Dokumentation nicht ausf√ºhrlich erl√§utert, ist jedoch die effizienteste Methode zum √úbertragen von Daten von jedem Objekt zu Shadern. <br><br>  In unserem Fall werden bei Verwendung der Instanzierung die Werte f√ºr alle Integrit√§tsbalken in einen konstanten Puffer gepackt, sodass sie alle zusammen √ºbertragen und gleichzeitig gezeichnet werden k√∂nnen. <br><br>  Hier gibt es fast nichts au√üer einem Boilerplate zum Einstellen von Variablen, und der Code ist ziemlich langweilig.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere</a> Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im GitHub-Repository</a> . <br><br><h2>  Demo </h2><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> verf√ºgt √ºber eine Testdemo, in der ein Haufen b√∂ser blauer W√ºrfel durch heldenhafte rote Kugeln zerst√∂rt wird (Hurra!). Dabei wird der durch die im Artikel beschriebenen Streifen verursachte Schaden genommen.  Demo in Unity 2018.3.6f1 geschrieben. <br><br>  Der Effekt der Verwendung von Instanzen kann auf zwei Arten beobachtet werden: <br><br><h3>  Statistik-Panel </h3><br>  Klicken Sie nach dem Klicken auf "Spielen" auf die Schaltfl√§che "Statistiken" √ºber dem Spielfeld.  Hier k√∂nnen Sie sehen, wie viele Draw Calls dank Instancing gespeichert werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="Bild"><br><br>  Nach dem Start des Spiels k√∂nnen Sie auf das HealthBar-Material klicken und das <em>Kontrollk√§stchen</em> "GPU-Instanz aktivieren" deaktivieren. Danach wird die Anzahl der gespeicherten Anrufe auf Null reduziert. <br><br><h3>  Frame-Debugger </h3><br>  Gehen Sie nach dem Start des Spiels zu Fenster&gt; Analyse&gt; Frame-Debugger und klicken Sie im angezeigten Fenster auf "Aktivieren". <br><br>  Unten links sehen Sie alle durchgef√ºhrten Rendering-Vorg√§nge.  Beachten Sie, dass es f√ºr Feinde und Granaten viele verschiedene Herausforderungen gibt (wenn Sie m√∂chten, k√∂nnen Sie auch Instanzen f√ºr sie implementieren).  Wenn Sie nach unten scrollen, sehen Sie den Punkt "Mesh-Gesundheitsleiste (instanziiert zeichnen)". <br><br>  Dieser einzelne Aufruf rendert alle Streifen.  Wenn Sie auf diesen Vorgang und dann auf den Vorgang klicken, werden alle Streifen ausgeblendet, da sie in einem Aufruf gezeichnet werden.  Wenn Sie sich im Frame-Debugger befinden, deaktivieren Sie das Kontrollk√§stchen GPU-Instanz aktivieren im Material. Sie sehen, dass eine Zeile in mehrere umgewandelt wurde, und nachdem Sie das Flag erneut in eine gesetzt haben. <br><br><h2>  So erweitern Sie dieses System </h2><br>  Wie ich bereits sagte, da diese Gesundheitsstreifen echte Objekte sind, hindert Sie nichts daran, einfache 2D-Streifen in etwas Komplexeres zu verwandeln.  Sie k√∂nnen Halbkreise unter Feinden sein, die in einem Bogen abnehmen, oder rotierende Rauten √ºber ihren K√∂pfen.  Mit demselben Ansatz k√∂nnen Sie immer noch alle in einem Aufruf rendern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447716/">https://habr.com/ru/post/de447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447704/index.html">Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</a></li>
<li><a href="../de447706/index.html">Kein einziger ORM</a></li>
<li><a href="../de447708/index.html">Yandex √ºberreichte jungen Wissenschaftlern und Wissenschaftlern die ersten Ilya Segalovich-Preise</a></li>
<li><a href="../de447712/index.html">Hallo, SaaS | Russische SaaS 2018 - Ergebnisse</a></li>
<li><a href="../de447714/index.html">Zur Anwendung der Theorie der ARMA-Prozesse in der Ingenieurpraxis</a></li>
<li><a href="../de447718/index.html">Alles wird nach Plan verlaufen</a></li>
<li><a href="../de447720/index.html">IoT-Sicherheit. Problem 2. Smart Home</a></li>
<li><a href="../de447724/index.html">Wie intelligente St√§dte entstehen</a></li>
<li><a href="../de447728/index.html">Wir berechnen das Energiebudget einer Funkleitung f√ºr einen Satelliten im CubeSat-Format</a></li>
<li><a href="../de447730/index.html">Die Entwicklung des E-Mail-Marketings: von QWERTYUIOP zu GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>