<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦 👨🏾‍💻 👨🏿‍🎤 Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug 🚢 👩🏻‍🏭 🎎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem musste ich ein Problem lösen, das in vielen Top-View-Spielen häufig vorkommt: eine ganze Reihe feindlicher Gesundheitsbalken auf dem Bildsc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Vor kurzem musste ich ein Problem lösen, das in vielen Top-View-Spielen häufig vorkommt: eine ganze Reihe feindlicher Gesundheitsbalken auf dem Bildschirm zu rendern.  So etwas wie das: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Offensichtlich wollte ich dies so effizient wie möglich tun, vorzugsweise in einem Draw Call.  Wie üblich habe ich vor Arbeitsbeginn ein wenig online nach den Entscheidungen anderer gesucht, und die Ergebnisse waren sehr unterschiedlich. <br><br>  Ich werde niemanden für den Code beschämen, aber es genügt zu sagen, dass einige der Lösungen nicht ganz brillant waren, zum Beispiel hat jemand jedem Feind ein Canvas-Objekt hinzugefügt (was sehr ineffizient ist). <br><br>  Die Methode, zu der ich als Ergebnis gekommen bin, unterscheidet sich geringfügig von allem, was ich mit anderen gesehen habe, und verwendet überhaupt keine UI-Klassen (einschließlich Canvas). Deshalb habe ich beschlossen, sie für die Öffentlichkeit zu dokumentieren.  Und für diejenigen, die den Quellcode lernen wollen, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihn auf Github</a> gepostet. <br><a name="habracut"></a><br><h2>  Warum nicht Canvas verwenden? </h2><br>  Eine Leinwand für jeden Feind ist offensichtlich eine schlechte Entscheidung, aber ich könnte eine gemeinsame Leinwand für alle Feinde verwenden.  Ein einzelner Canvas würde auch zum Rendern von Anrufbatches führen. <br><br>  Ich mag jedoch nicht die Menge an Arbeit, die in jedem Rahmen im Zusammenhang mit diesem Ansatz ausgeführt wird.  Wenn Sie Canvas verwenden, müssen Sie in jedem Frame die folgenden Vorgänge ausführen: <br><br><ul><li>  Bestimmen Sie, welche der Feinde auf dem Bildschirm angezeigt werden, und wählen Sie jeden von ihnen aus dem Pool-UI-Streifen aus. </li><li>  Projizieren Sie die Position des Feindes in der Kamera, um den Streifen zu positionieren. </li><li>  Ändern Sie die Größe des "Füll" -Teils des Streifens, wahrscheinlich wie bei Image. </li><li>  Ändern Sie höchstwahrscheinlich die Größe der Streifen entsprechend der Art der Feinde;  Zum Beispiel sollten große Feinde große Streifen haben, damit es nicht albern aussieht. </li></ul><br>  Auf jeden Fall würde all dies die Canvas-Geometriepuffer kontaminieren und zu einer Neuerstellung aller Scheitelpunktdaten im Prozessor führen.  Ich wollte nicht, dass dies alles für ein so einfaches Element getan wird. <br><br><h2>  Kurz über meine Entscheidung </h2><br>  Eine kurze Beschreibung meines Arbeitsprozesses: <br><br><ul><li>  Wir befestigen Objekte mit Energiestreifen in 3D an Feinden. <br><ul><li>  Auf diese Weise können Sie Streifen automatisch anordnen und zuschneiden. </li><li>  Die Position / Größe des Streifens kann je nach Art des Feindes angepasst werden. </li><li>  Wir werden die Streifen im Code mithilfe der Transformation, die noch vorhanden ist, zur Kamera lenken. </li><li>  Der Shader stellt sicher, dass sie immer über allem rendern. </li></ul></li><li>  Wir verwenden Instancing, um alle Streifen in einem einzigen Draw-Aufruf zu rendern. </li><li>  Wir verwenden einfache prozedurale UV-Koordinaten, um den Grad der Fülle des Streifens anzuzeigen. </li></ul><br>  Schauen wir uns nun die Lösung genauer an. <br><br><h2>  Was ist Instanz? </h2><br>  Bei der Arbeit mit Grafiken wird seit langem die Standardtechnik verwendet: Mehrere Objekte werden so kombiniert, dass sie gemeinsame Scheitelpunktdaten und Materialien haben und in einem Zeichenaufruf gerendert werden können.  Dies ist genau das, was wir brauchen, denn jeder Draw-Aufruf belastet die CPU und die GPU zusätzlich.  Anstatt für jedes Objekt einen einzelnen Zeichenaufruf durchzuführen, rendern wir alle gleichzeitig und verwenden einen Shader, um jeder Kopie Variabilität hinzuzufügen. <br><br>  Sie können dies manuell tun, indem Sie die Netzscheitelpunktdaten X-mal in einem Puffer duplizieren, wobei X die maximale Anzahl von Kopien ist, die gerendert werden können, und dann das Array von Shader-Parametern verwenden, um jede Kopie zu konvertieren / zu färben / zu variieren.  Jede Kopie muss Wissen über die nummerierte Instanz speichern, um diesen Wert als Index des Arrays verwenden zu können.  Dann können wir einen indizierten Renderaufruf verwenden, der "Nur auf N rendern" befiehlt, wobei N die Anzahl der Instanzen <em>ist,</em> die im aktuellen Frame <em>tatsächlich</em> benötigt werden, weniger als die maximale Anzahl von X. <br><br>  Die meisten modernen APIs verfügen bereits über Code dafür, sodass Sie dies nicht manuell tun müssen.  Diese Operation wird als "Instanzierung" bezeichnet.  Tatsächlich automatisiert es den oben beschriebenen Prozess mit vordefinierten Einschränkungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Unity-Engine unterstützt auch die Instanzierung</a> . Sie verfügt über eine eigene API und eine Reihe von Shader-Makros, die bei der Implementierung helfen.  Es werden beispielsweise bestimmte Annahmen verwendet, dass für jede Instanz eine vollständige 3D-Transformation erforderlich ist.  Genau genommen wird es für 2D-Streifen nicht vollständig benötigt - wir können Vereinfachungen vornehmen, aber da dies der Fall ist, werden wir sie verwenden.  Dies vereinfacht unseren Shader und bietet auch die Möglichkeit, 3D-Indikatoren zu verwenden, z. B. Kreise oder Bögen. <br><br><h2>  Klasse schädlich </h2><br>  Unsere Feinde haben eine Komponente namens " <code>Damageable</code> , die ihnen Gesundheit verleiht und ihnen ermöglicht, Schaden durch Kollisionen zu erleiden.  In unserem Beispiel ist es ganz einfach: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  HealthBar-Objekt: Position / Drehung </h2><br>  Das Gesundheitsbalkenobjekt ist sehr einfach: Tatsächlich ist es nur ein Quad, das an den Feind gebunden ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Wir verwenden die <strong>Skala</strong> dieses Objekts, um den Streifen lang und dünn zu machen und ihn direkt über dem Feind zu platzieren.  Machen Sie sich keine Sorgen um die Drehung, wir werden das Problem mithilfe des Codes beheben, der an das Objekt in <code>HealthBar.cs</code> angehängt ist: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Dieser Code lenkt das Quad immer in Richtung Kamera.  Wir <em>können</em> die Größe ändern und im Shader drehen, aber ich implementiere sie hier aus zwei Gründen. <br><br>  Erstens verwendet die Unity-Instanzierung immer die vollständige Transformation jedes Objekts, und da wir immer noch alle Daten übertragen, können Sie sie verwenden.  Zweitens stellt das Einstellen der Skalierung / Drehung hier sicher, dass das Begrenzungsparallelogramm zum Trimmen des Streifens immer wahr ist.  Wenn wir die Aufgabe von Größe und Drehung in die Verantwortung des Shaders legen würden, könnte Unity die Streifen abschneiden, die sichtbar sein sollten, wenn sie sich nahe an den Bildschirmrändern befinden, da die Größe und Drehung ihres Begrenzungsparallelogramms nicht dem entspricht, was wir rendern werden.  Natürlich könnten wir unsere eigene Methode zum Abschneiden implementieren, aber normalerweise ist es, wenn möglich, besser, das zu verwenden, was wir haben (Unity-Code ist nativ und hat Zugriff auf mehr räumliche Daten als wir). <br><br>  Ich werde erklären, wie der Streifen gerendert wird, nachdem wir uns den Shader angesehen haben. <br><br><h2>  Shader HealthBar </h2><br>  In dieser Version erstellen wir einen einfachen klassischen rot-grünen Streifen. <br><br>  Ich benutze eine 2x1 Textur mit einem grünen Pixel links und einem roten rechts.  Natürlich habe ich das Mipmapping, Filtern und Komprimieren deaktiviert und den Adressierungsmodus-Parameter auf Clamp gesetzt. Dies bedeutet, dass die Pixel in unserem Streifen immer perfekt grün oder rot sind und sich nicht über die Ränder verteilen.  Auf diese Weise können wir die Texturkoordinaten im Shader ändern, um die Trennlinie zwischen den roten und grünen Pixeln im Streifen nach unten und oben zu verschieben. <br><br>  <em>(Da es nur zwei Farben gibt, kann ich einfach die Schrittfunktion im Shader verwenden, um zum einen oder anderen Punkt zurückzukehren. Bei dieser Methode ist es jedoch praktisch, dass Sie eine komplexere Textur verwenden können, wenn Sie dies wünschen. Dies funktioniert ähnlich, während der Übergang ausgeführt wird mittlere Textur.)</em> <br><br>  Zuerst erklären wir die Eigenschaften, die wir brauchen: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> ist eine rot-grüne Textur und <code>_Fill</code> ist ein Wert von 0 bis 1, wobei 1 die volle Gesundheit ist. <br><br>  Als nächstes müssen wir den Streifen so anordnen, dass er in der Überlagerungswarteschlange gerendert wird. Dies bedeutet, dass die gesamte Tiefe der Szene ignoriert und über alles gerendert wird: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  Der nächste Teil ist der Shader-Code selbst.  Wir schreiben einen Shader ohne Beleuchtung (unbeleuchtet), sodass wir uns nicht um die Integration mit verschiedenen Unity-Oberflächen-Shadern kümmern müssen. Dies sind nur einige Vertex- / Fragment-Shader.  Schreiben Sie zuerst Bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Dies ist größtenteils ein Standard-Bootstrap, mit Ausnahme von <code>#pragma multi_compile_instancing</code> , das dem Unity-Compiler <code>#pragma multi_compile_instancing</code> , was für die Instanz kompiliert werden muss. <br><br>  Die Scheitelpunktstruktur muss Instanzdaten enthalten, daher werden wir Folgendes tun: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Wir müssen auch angeben, was genau in den Daten von Instanzen enthalten sein wird, zusätzlich zu den Unity- (Transformations-) Prozessen für uns: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Wir berichten also, dass Unity einen Puffer namens "Props" erstellen muss, um die Daten für jede Instanz zu speichern, und darin einen Float pro Instanz für eine Eigenschaft namens <code>_Fill</code> . <br><br>  Sie können mehrere Puffer verwenden.  Es lohnt sich, wenn Sie mehrere Eigenschaften mit unterschiedlichen Frequenzen aktualisieren lassen.  Wenn Sie sie teilen, können Sie beispielsweise einen Puffer nicht ändern, wenn Sie einen anderen ändern, was effizienter ist.  Das brauchen wir aber nicht. <br><br>  Unser Vertex-Shader erledigt die Standardarbeit fast vollständig, da Größe, Position und Drehung bereits zur Transformation übertragen werden.  Dies wird mit <code>UnityObjectToClipPos</code> implementiert, das automatisch die Transformation jeder Instanz verwendet.  Man könnte sich vorstellen, dass dies ohne Instanzierung normalerweise eine einfache Verwendung einer einzelnen Matrixeigenschaft wäre.  Bei Verwendung der Instanz innerhalb der Engine sieht es jedoch wie ein Array von Matrizen aus, und Unity wählt unabhängig eine für diese Instanz geeignete Matrix aus. <br><br>  Außerdem müssen Sie die UV- <code>_Fill</code> ändern, um die Position des Übergangspunkts gemäß der Eigenschaft <code>_Fill</code> von rot nach grün zu <code>_Fill</code> .  Hier ist das relevante Code-Snippet: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> und <code>UNITY_ACCESS_INSTANCED_PROP</code> erledigen die ganze Magie, indem sie aus dem konstanten Puffer für diese Instanz auf die richtige Version der Eigenschaft <code>_Fill</code> zugreifen. <br><br>  Wir wissen, dass im Normalzustand die UV-Koordinaten des Quadranten das gesamte Texturintervall abdecken und dass sich die Trennlinie des Streifens horizontal in der Mitte der Textur befindet.  Daher verschieben kleine mathematische Berechnungen den Streifen horizontal nach links oder rechts, und der Klemmwert der Textur stellt die Füllung des verbleibenden Teils sicher. <br><br>  Der Fragment-Shader könnte nicht einfacher sein, da alle Arbeiten bereits ausgeführt wurden: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  Der vollständige Kommentar-Shader-Code ist im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> verfügbar. <br><br><h2>  Healthbar-Material </h2><br>  Dann ist alles einfach - wir müssen unserem Strip nur das Material zuweisen, das dieser Shader verwendet.  Es muss fast nichts mehr getan werden. Wählen Sie einfach den gewünschten Shader im oberen Teil aus, weisen Sie eine rot-grüne Textur zu und <strong>aktivieren Sie</strong> vor allem das <strong>Kontrollkästchen „GPU-Instanz aktivieren“</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="Bild"><br><br><h2>  HealthBar Fill Property Update </h2><br>  Wir haben also das <code>_Fill</code> , den Shader und das zu rendernde Material. Jetzt müssen wir die <code>_Fill</code> Eigenschaft für jede Instanz <code>_Fill</code> .  Wir machen das in <code>HealthBar.cs</code> wie folgt: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  Wir <code>CurrentHealth</code> die <code>CurrentHealth</code> Klasse in einen Wert von 0 bis 1 um und teilen ihn durch <code>MaxHealth</code> .  Dann übergeben wir es mit <code>MaterialPropertyBlock</code> an die Eigenschaft <code>_Fill</code> . <br><br>  Wenn Sie <code>MaterialPropertyBlock</code> zum Übertragen von Daten an Shader verwendet haben, auch ohne Instanz, müssen Sie diese untersuchen.  Dies wird in der Unity-Dokumentation nicht ausführlich erläutert, ist jedoch die effizienteste Methode zum Übertragen von Daten von jedem Objekt zu Shadern. <br><br>  In unserem Fall werden bei Verwendung der Instanzierung die Werte für alle Integritätsbalken in einen konstanten Puffer gepackt, sodass sie alle zusammen übertragen und gleichzeitig gezeichnet werden können. <br><br>  Hier gibt es fast nichts außer einem Boilerplate zum Einstellen von Variablen, und der Code ist ziemlich langweilig.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere</a> Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im GitHub-Repository</a> . <br><br><h2>  Demo </h2><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> verfügt über eine Testdemo, in der ein Haufen böser blauer Würfel durch heldenhafte rote Kugeln zerstört wird (Hurra!). Dabei wird der durch die im Artikel beschriebenen Streifen verursachte Schaden genommen.  Demo in Unity 2018.3.6f1 geschrieben. <br><br>  Der Effekt der Verwendung von Instanzen kann auf zwei Arten beobachtet werden: <br><br><h3>  Statistik-Panel </h3><br>  Klicken Sie nach dem Klicken auf "Spielen" auf die Schaltfläche "Statistiken" über dem Spielfeld.  Hier können Sie sehen, wie viele Draw Calls dank Instancing gespeichert werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="Bild"><br><br>  Nach dem Start des Spiels können Sie auf das HealthBar-Material klicken und das <em>Kontrollkästchen</em> "GPU-Instanz aktivieren" deaktivieren. Danach wird die Anzahl der gespeicherten Anrufe auf Null reduziert. <br><br><h3>  Frame-Debugger </h3><br>  Gehen Sie nach dem Start des Spiels zu Fenster&gt; Analyse&gt; Frame-Debugger und klicken Sie im angezeigten Fenster auf "Aktivieren". <br><br>  Unten links sehen Sie alle durchgeführten Rendering-Vorgänge.  Beachten Sie, dass es für Feinde und Granaten viele verschiedene Herausforderungen gibt (wenn Sie möchten, können Sie auch Instanzen für sie implementieren).  Wenn Sie nach unten scrollen, sehen Sie den Punkt "Mesh-Gesundheitsleiste (instanziiert zeichnen)". <br><br>  Dieser einzelne Aufruf rendert alle Streifen.  Wenn Sie auf diesen Vorgang und dann auf den Vorgang klicken, werden alle Streifen ausgeblendet, da sie in einem Aufruf gezeichnet werden.  Wenn Sie sich im Frame-Debugger befinden, deaktivieren Sie das Kontrollkästchen GPU-Instanz aktivieren im Material. Sie sehen, dass eine Zeile in mehrere umgewandelt wurde, und nachdem Sie das Flag erneut in eine gesetzt haben. <br><br><h2>  So erweitern Sie dieses System </h2><br>  Wie ich bereits sagte, da diese Gesundheitsstreifen echte Objekte sind, hindert Sie nichts daran, einfache 2D-Streifen in etwas Komplexeres zu verwandeln.  Sie können Halbkreise unter Feinden sein, die in einem Bogen abnehmen, oder rotierende Rauten über ihren Köpfen.  Mit demselben Ansatz können Sie immer noch alle in einem Aufruf rendern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447716/">https://habr.com/ru/post/de447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447704/index.html">Elbrus besteigen - Aufklärung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</a></li>
<li><a href="../de447706/index.html">Kein einziger ORM</a></li>
<li><a href="../de447708/index.html">Yandex überreichte jungen Wissenschaftlern und Wissenschaftlern die ersten Ilya Segalovich-Preise</a></li>
<li><a href="../de447712/index.html">Hallo, SaaS | Russische SaaS 2018 - Ergebnisse</a></li>
<li><a href="../de447714/index.html">Zur Anwendung der Theorie der ARMA-Prozesse in der Ingenieurpraxis</a></li>
<li><a href="../de447718/index.html">Alles wird nach Plan verlaufen</a></li>
<li><a href="../de447720/index.html">IoT-Sicherheit. Problem 2. Smart Home</a></li>
<li><a href="../de447724/index.html">Wie intelligente Städte entstehen</a></li>
<li><a href="../de447728/index.html">Wir berechnen das Energiebudget einer Funkleitung für einen Satelliten im CubeSat-Format</a></li>
<li><a href="../de447730/index.html">Die Entwicklung des E-Mail-Marketings: von QWERTYUIOP zu GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>