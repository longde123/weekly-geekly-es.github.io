<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐠 🙍🏿 👯 ＃HolyJS18展台hh.ru上的问题分析 🆗 🔡 🧝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们试图为您做一些有趣而又不寻常的事情。 我真的希望我们成功。 我们不想让您无法回答，也没有解释原因。 让我们做对。 


 首先，我想提醒您比赛是如何进行的，共进行了4轮有关JS的15个问题，进行了1轮非竞争性的关于React的15个问题，最后10个问题。 





 根据削减-前4轮任务的分析...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>＃HolyJS18展台hh.ru上的问题分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/431698/"><p> 我们试图为您做一些有趣而又不寻常的事情。 我真的希望我们成功。 我们不想让您无法回答，也没有解释原因。 让我们做对。 </p><br><p> 首先，我想提醒您比赛是如何进行的，共进行了4轮有关JS的15个问题，进行了1轮非竞争性的关于React的15个问题，最后10个问题。 </p><br><p><img src="https://habrastorage.org/webt/2c/4c/fp/2c4cfpdhp1bei0q3vrr3432ejpk.jpeg" alt="图片"></p><br><p> 根据削减-前4轮任务的分析。 </p><a name="habracut"></a><br><p> 这是我们分析的第二部分。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>回答问题 </p><br><p> 我们都是怎么做到的？ 我们决定需要产生大约80-90个问题，以便有可供选择的股票。 之后，我们将所有内容划分为主题： </p><br><ul><li> 浏览器事件 </li><li> 各种API（Array，Set，defineProperty等）， </li><li> 专心 </li><li> 使用分数 </li><li> 吊装 </li><li> 事件循环 </li><li> 类型转换 </li><li> 类型 </li><li> 逻辑（具有逻辑AND和OR） </li></ul><br><p> 之后，问题被分配了4轮。 我们试图使所有巡回赛的复杂性保持不变，为此，我们进行了多次访问，通过了这些测试，并确定了哪些问题更容易解决，哪些问题更难解决，并用更合适的问题代替了悬而未决的问题。 在每个回合中，我们针对某个特定主题回答了相同数量的问题。 结果，事实证明，在不同的旅行中存在相似但不相同的问题。 </p><br><p> 因此，对游览进行分类似乎不太方便，因为会有很多重复的解释，我建议您按主题查看。 让我们从最简单的开始。 </p><br><h1 id="voprosy-na-vnimatelnost"> 注意事项： </h1><br><h3 id="chto-budet-vyvedeno-v-konsol"> 控制台中将显示什么？ </h3><br><pre><code class="plaintext hljs">console.log(0,1 + 0,2); a) 0.30000000000000004 b) 0.3 c) 2 d) 0 1 2</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）0 1 2 <br> 此处位于数字之间，而不位于<code>.</code> 如果您格式化这样的问题： <br> <code>console.log(0, 1 + 0, 2);</code> 一切都会变得清晰 </p></div></div><br><h3 id="chto-budet-vyvedeno-v-konsol-1"> 控制台中将显示什么？ </h3><br><pre> <code class="plaintext hljs">(() =&gt; { 'use strict'; a = null + undefined; console.log(a); })(); a) 0 b) NaN c) null d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）错误 <br>  <code>a</code>不是作为变量（不是变量声明）创建的，这里有一个隐式的<code>this.a</code>赋值表达式，这通常可能不是您期望的，因为 全局变量<code>window.a</code>将在严格模式下创建，这是禁止的。 </p></div></div><br><h3 id="chto-budet-vyvedeno-v-konsol-2"> 控制台中将显示什么？ </h3><br><pre> <code class="plaintext hljs">let foo = function bar() { return 123; }; console.log( typeof bar() ); a) 'function' b) 'number' c) 'undefined' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）错误 <br> 这是一个函数表达式（表达式）-在这种情况下，函数的名称对于函数而言是本地的。 要调用函数，您需要调用<code>foo</code>而不是<code>bar</code> 。 如果是声明，答案将是<code>number</code> 。 </p></div></div><br><h1 id="voprosy-pro-rabotu-s-drobnymi-chislami"> 有关使用分数的问题： </h1><br><h3 id="chto-budet-vyvedeno-v-konsol-3"> 控制台中将显示什么？ </h3><br><pre> <code class="plaintext hljs">console.log(0.1 ** 2); a) 0.2 b) 0.01 c) 0.010000000000000002 d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）0.010000000000000002 </p></div></div><br><h3 id="chto-budet-vyvedeno-v-konsol-4"> 控制台中将显示什么？ </h3><br><pre> <code class="plaintext hljs">console.log(0.1 + 0.2); a) 0.30000000000000004 b) 0.3 c) 2 d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  a）0.30000000000000004 <br>  <code>**</code> -这是Math.pow平方<code>0.1</code>的类似物-应该为<code>0.01</code> ，但在JS（与许多其他语言一样）中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用浮点数</a>时存在运算准确性的已知问题。 这将是<code>0.010000000000000002</code>这是由于以下事实：在二进制系统中获得了无限大的分数，因为 在JS中，始终为一个数字精确分配64位-所有数字始终为双精度浮点数。 添加时发生相同的事情。 </p></div></div><br><p> 我们转向一些更复杂的问题。 </p><br><h1 id="sobytiya-v-brauzere"> 浏览器中的事件： </h1><br><h3 id="est-obrabotchik-sobytiya-na-elemente-kakie-znacheniya-vnutri-etogo-obrabotchika-budut-vsegda-odinakovy"> 元素上有一个事件处理程序，该处理程序中的哪些值将始终相同？ </h3><br><pre> <code class="plaintext hljs">elem.onclick = function(event) { } a) event.target  event.currentTarget b) event.target  this c) event.currentTarget  this d)    </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）event.currentTarget和这个 <br>  <code>this</code> -总是指向一个元素 <br>  <code>currentTarget</code>事件挂起的元素 <br>  target-发生事件的元素 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-po-kliku-na-div"> 单击div，此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">div.onclick = function() { console.log(1) }; div.onclick = function() { console.log(2) }; div.addEventListener('click', function() { console.log(3) }); a) 1 b) 1 3 c) 2 3 d) 3</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）2 3 <br>  onclick将添加<code>console.log(1)</code>处理函数，但是在下一行中，我们使用新功能对其进行了研磨，仅保留<code>console.log(2)</code> 。  <code>onclick</code>是DOM属性；它始终是一个 <br> 事件将按照其挂起的顺序工作，将先显示2，然后显示3。 <br> 如果我们多次执行<code>addEventListener</code> ，那么它们每个都会工作，因为 处理程序将事件添加到队列中。 </p></div></div><br><p> 有关各种API的问题部分 </p><br><h1 id="defineproperty">  defineProperty： </h1><br><h3 id="chto-vyvedet-etot-kod"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">(() =&gt; { const obj = { key: 1 }; Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: 2 }); console.log(obj.key); obj.key = 3; console.log(obj.key); })(); a) 1, 2 b) 2, 2 c) 2, 3 d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）2、2 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-1"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">(() =&gt; { 'use strict'; const obj = { key: 1 }; Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: 2 }); console.log(obj.key); obj.key = 3; console.log(obj.key); })(); a) 1, 2 b) 2, 2 c) 2, 3 d) 2, </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  d）2，错误 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-2"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">(() =&gt; { const obj = { key: 1 }; Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: true, value: 2 }); console.log(obj.key); obj.key = 3; console.log(obj.key); })(); a) 1, 2 b) 2, 2 c) 2, 3 d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）2、3 <br> 在上述所有问题中，都会<code>defineProperty</code>方法的知识， <code>defineProperty</code>是<code>writable</code>设置。 如果将其设置为<code>false</code>则禁止更改作为第二个参数传递给<code>defineProperty</code>的键的值。 唯一的区别是，如果没有严格模式- <code>use strict</code>严格模式<code>use strict</code>引擎将假装一切正常，但不会更改值，并且在严格模式下会出现错误。 </p></div></div><br><h1 id="inkrement"> 增量： </h1><br><h3 id="chto-vyvedet-etot-kod-3"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let x = 5; console.log(x++); a) 5 b) 6 c) '5++' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）5 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-4"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const a = 5; console.log(a++); a) 5 b) 6 c) '5++' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  d）错误 <br> 当使用后缀形式的incrimination时，该值在增加之前返回。 <br> 并在前缀之后，即  <code>console.log(++5)</code>将输出<code>6</code> <br>  <code>const</code>不能被覆盖；  Number是基元，当其递增时，该变量将被新值覆盖，并且会出现错误。 </p></div></div><br><h1 id="set"> 设置： </h1><br><h3 id="chto-vyvedet-etot-kod-5"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const a = [...new Set([1, 1, 2, , 3, , 4, 5, 5])]; console.log(a); a) [1, 1, 2, , 3, , 4, 5, 5] b) [1, 2, undefined, 3, 4, 5] c) [1, 1, 2, undefined, 3, undefined, 4, 5, 5] d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）[1、2，未定义，3、4、5] </p></div></div><br><h3 id="chto-vyvedet-etot-kod-6"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let set = new Set([10, '10', new Number(10), 1e1, 0xA]); console.log(set.size); a) 5 b) 3 c) 2 d) 1</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）3 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-7"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let obj = {}; let set = new Set([obj, obj, {}, {}, {...{}}, {...obj}]); console.log(set.size); a) 6 b) 5 c) 2 d) 1</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）5 <br>  <code>Set</code>是一个集合；根据定义，其中不能有相同的值。 问题是如何比较这些值。 原始对象按值进行比较，对象按引用进行比较。 <br> 它本身不引用数据类型，可以存储任何类型的值<code>1e1</code>和<code>0xA</code>将转换为十进制并得到<code>10</code> 。 <br> 而且新对象总是不相等： <code>console.log({} == {})</code>将返回<code>false</code>因为 将在内存的不同位置以新方式创建对象，并且它们的链接将不相等。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-8"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(Infinity / Infinity); a) NaN b) 1 c) Error d) Infinity</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）NaN <br> 不可能将无穷大分为无穷大和从无穷大中减去无穷大，因为 从数学的角度来看，获得了不确定性，乘以<code>Infinity</code>并且<code>0</code>错误不会引起数学运算时，会发生相同的事情-将存在<code>NaN</code> </p></div></div><br><h1 id="voprosy-pro-spread"> 有关点差的问题： </h1><br><h3 id="chto-vyvedet-etot-kod-9"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const a = { ...{ a: 1, b: 2, c: 3 }, ...{ a: 2, c: 4, d: 8 } }; console.log(a); a) { a: 2, b: 2, c: 4, d: 8 } c) { a: 1, b: 2, c: 3, d: 8 } c) { a: 1, b: 2, c: 3, a: 2, c: 4, d: 8 } d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）{a：2，b：2，c：4，d：8} </p></div></div><br><h3 id="chto-vyvedet-etot-kod-10"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const a = [...[1, 2], ...[[3, 4]], ...[5, 6]]; console.log(a); a) [1, 2, 3, 4, 5, 6] b) [1, 2, [3, 4], 5, 6] c) [[1, 2], [[3, 4]], 5, 6] e) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）[1、2，[3、4]，5、6] <br>  <code>Spread</code>运算符用于将对象或数组解析为多个部分。 它在<code>...</code>之后从实体获取值，并将其复制到创建的值。 值得注意的是，对于一个数组和一个对象，它打开到1级，即  <code>...[[1]]</code>将返回包含一个元素的数组，而不是元素本身。 对象中不能有重复的值，因此，以后公开的值将被以前公开的值覆盖。 这可用于指定默认设置。 </p><br><pre> <code class="plaintext hljs">const fn = (actualProps) =&gt; ({ ...defaultProps, ...actualProps })</code> </pre> <br><p> 如果有的话，所有默认值都将被传递的值覆盖。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-11"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(parseInt(' -10,3   ')); a) -10,3 b) -10 c) TypeError d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）-10 <br> 关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MDN的</a>详尽描述： <br> 如果parseInt函数遇到的字符不是指定数字系统中的数字，则它将跳过此字符和所有后续字符（即使它们合适），并返回从该字符之前的字符串部分转换而来的整数。  parseInt切除数字的小数部分。 一行的开头和结尾都可以有空格。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-12"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const t = { a: 6, b: 7 }; const p = new Proxy(t, { get() { return 12; }, }); console.log(pa); pa = 18; console.log(pa); console.log(ta); a)  b) 12 18 18 c) 12 18 6 d) 12 12 18 e) 6 18 6</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）12 12 18 <br>  <code>Proxy</code>拦截所有对该对象的调用。 在这种情况下，无论我们访问对象的哪个字段，我们都只代理<code>get</code>方法，并且始终返回<code>12</code> 。 在这种情况下，我们不会触摸设置，并且在访问代理时，对象中的值将被替换。 </p></div></div><br><h1 id="massivy"> 数组： </h1><br><h3 id="chto-vyvedet-etot-kod-13"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let arr = []; arr[1] = 1; arr[5] = 10; console.log(arr.length); a) 1 b) 5 c) 6 d) 10</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）6 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-14"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let arr = new Array(3); console.log(arr[1]); a) undefined b) 1 c) 3 d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  a）未定义 <br> 当我们用一个数字参数创建一个<code>Array</code>时，它表示数组的长度。 数组创建为空，所有值均未<code>undefined</code> 。 如果您创建对不存在的数组字段的访问，也会发生同样的事情。 值得注意的是，如果您将数字传递给<code>Array</code> ，则将返回包含此元素的数组，即  <code>Array('a')</code>将返回<code>['a']</code> </p></div></div><br><h1 id="logicheskie-operacii----i-td"> 逻辑运算<code>&amp;&amp;</code> ， <code>||</code>  ， <code>==</code>等： </h1><br><h3 id="chto-vyvedet-etot-kod-15"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([] &amp;&amp; 'foo' &amp;&amp; undefined &amp;&amp; true &amp;&amp; false); a) [] b) 'foo' c) undefined d) true</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）未定义 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-16"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(0 || 1 &amp;&amp; 2 || 3); a) 0 b) 1 c) 2 d) 3</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）2 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-17"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(0 || '' || 2 || undefined || true || false); a) 0 b) false c) 2 d) true</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）2 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-18"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(2 &amp;&amp; '1' &amp;&amp; null &amp;&amp; undefined &amp;&amp; true &amp;&amp; false); a) 2 b) false c) undefined d) null</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  d）空 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-19"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([] &amp;&amp; {} || null &amp;&amp; 100 || ''); a) true b) 100 c) '' d) {}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）{} <br> 空数组<code>[]</code>为<code>true</code>空对象<code>{}</code>为<code>true</code> 。 <br> 空字符串<code>''</code> ， <code>null</code>和<code>undefined</code>为<code>false</code> <br> 逻辑或<code>||</code>  -返回左操作数，如果为true，则返回右操作数。 <br> 逻辑<code>&amp;&amp;</code> -返回左操作数，如果为false，否则返回右操作数。 </p><br><p> 有时可以在代码中找到它，在默认参数出现之前，他们经常这样写-如果函数中没有参数，那么我们采用默认参数： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userParams</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> params = userParams || defaultParams; }</code> </pre> <br><p> 现在React经常检查条件是否成立，然后我们渲染一些东西： </p><br><pre> <code class="javascript hljs">{ isDivVisible &amp;&amp; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">bla-bla</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> }</code> </pre> </div></div><br><h1 id="sravnenie-massivov"> 数组比较： </h1><br><h3 id="chto-vyvedet-etot-kod-20"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const arrayFoo = [1, 2, 3, 4]; const arrayBaz = [1, 2, 3, 4]; console.log(arrayFoo == arrayBaz &amp;&amp; arrayFoo == arrayBaz); a) false b) true c) undefined d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）错误 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-21"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([null, 0, -0].map(x =&gt; 0 &lt;= x)); a) [false, true, false] b) [false, true, true] c) [false, false, false] d) [true, true, true]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  d）[正确，正确，正确] </p></div></div><br><h3 id="chto-vyvedet-etot-kod-22"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const arrayFoo = [1, 2, 3, 4]; const arrayBaz = [1, 2, 3, 4]; console.log(arrayFoo &gt;= arrayBaz &amp;&amp; arrayFoo &lt;= arrayBaz); a) true b) false c) undefined d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）正确 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-23"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const foo = [1, 2, 3, 4]; const baz = '1,2,3,4'; console.log(foo &gt;= baz &amp;&amp; foo &lt;= baz); a) false b) true c) undefined d)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）正确 <br> 当<code>==</code>通过引用进行比较。 <br> 在操作<code>&gt;, &gt;=, &lt;, &lt;=</code>操作数转换为基元，并在<code>arrayFoo</code>上调用valueOf方法，该方法应返回基元值<code>arrayFoo</code> ，但它返回对同一数组的引用。 接下来，通过调用<code>toString</code>方法进行到原始值的转换，该方法将以“ 1,2,3,4”的形式返回数组的字符串表示形式，在字典上比较两个数组并返回<code>true</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-24"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(+0 == -0); console.log(+0 === -0); console.log(Object.is(+0, -0)); a) true, false, false b) true, true, false c) false, true, true d) false, false. false</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）正确，正确，错误 <br> 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MDN的</a>综合说明： <br> 此方法的行为（谈论<code>Object.is</code> ）与<code>===</code>运算符不同。 运算符<code>===</code> （以及运算符<code>==</code> ）认为数值<code>-0</code>和<code>+0</code>相等，并且值<code>Number.NaN</code>不等<code>Number.NaN</code>自身。 </p></div></div><br><p> 有关吊装的问题： </p><br><h3 id="chto-vyvedet-etot-kod-25"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(str); const str = 'HeadHunter'; a) 'HeadHunter' b) undefined c) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）错误 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-26"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">var arrayFunction = []; for (let i = 0; i &lt;= 10; i++) { arrayFunction.push(() =&gt; i); } console.log(arrayFunction[3]()); a) 4 b) 0 c) 11 d) 3</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  d）3 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-27"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(str); var str = 'HeadHunter'; a) 'HeadHunter' b) undefined c) null c)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）未定义 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-28"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(foo); var foo; foo = foo ? 1 : 0; console.log(foo); a)  b) undefined 0 c) '' 1 d) 0 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）未定义0 </p></div></div><br><h3 id="srabotaet-li-vyzov-funkcii"> 函数调用会起作用吗？ </h3><br><pre> <code class="plaintext hljs">getCompanyName(); function getCompanyName() { return 'HeadHunter'; } a)  b) ,     . c) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）是的 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-29"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">var arrayFunction = []; for (var i = 0; i &lt;= 10; i++) { arrayFunction.push(() =&gt; i); } console.log(arrayFunction[3]()); a) 4 b) 0 c) 11 d) 3</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）11 </p><br><p> 弹出函数声明，但没有表达式。 <br> 弹出<code>var</code> ，但直到<code>undefined</code>初始化为止。 <br>  <code>let</code>和<code>const</code>不会弹出并在块中具有作用域，即 限于<code>{}</code> 。 </p><br><p> 为了使循环与<code>var</code>一起正常工作<code>var</code>您需要使用闭包，值将保存在其中。 <br>  （这曾经是采访的经典任务，但现在我们可以接受了） </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayFunction = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ arrayFunction.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> i); })(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arrayFunction[<span class="hljs-number"><span class="hljs-number">3</span></span>]());</code> </pre> </div></div><br><h3 id="chto-vyvedet-etot-kod-30"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(true + false); a) true b) false c) 1 d) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）1 <br> 所有运算符都不是字符串， <code>+</code>导致数字。 原来是<code>1 + 0</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-31"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([] - 100 + ![]); a) false b) '-100' c) -100 d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）-100 <br> 将该数组强制转换为字符串，之后，由于<code>-</code>我们将其强制转换为数字，结果是<code>-100</code> ，然后将数组强制转换为<code>false</code> ，这是<code>0</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-32"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([[], []] + 1); a) 1 b) '1' c) ',1' d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）'，1' <br> 我们在对象上<code>toString</code> ，而<code>toString</code>也将在数组的所有元素上调用。  <code>[].toString</code>将返回一个空字符串<code>''</code> 。 事实证明<code>, + 1</code>答案<code>,1</code> 。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-33"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log([] + 100 + 5); a) 105 b) '1005' c) 1005 d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）'1005' <br> 该数组可简化为字符串，然后已经发生串联。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-34"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(1 + { a: 3 } + '2'); a) 6 b) '1[object Object]2' c) 3 d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）'1 [object Object] 2' <br> 转换为字符串-只是串联而已。 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-35"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(10.toString() + 10 + 0x1); a) '10101' b) 21 c) '10100x1' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  d）错误 <br> 对于一个数字，一个点<code>.</code> 表示小数部分的开头，我们希望在那里有一个数字-会有错误。 <br> 为了使此示例正常工作，您需要编写<code>10..toString()</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-36"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(5 + false - null + true); a) '0true' b) NaN c) 6 d)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）6 <br> 在这里，一切都减少为一个数字，结果是<code>5 + 0 - 0 + 1</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-37"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(true + NaN + false); a) true b) NaN c) false d) 1</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）NaN <br> 使用<code>NaN</code>加数字时，我们将所有内容减为一个数字-得到<code>NaN</code> </p></div></div><br><h3 id="chto-vyvedet-etot-kod-38"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log('0x1' + '1' - '1e1'); a) 17 b) 7 c) '0x111e1' d) NaN</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）7 <br> 第一次串联后已经有几行，我们得到： <code>'0x11' - '1e1'</code> 。 由于有符号<code>-</code>我们将所有内容都带到了数字上。 <br>  <code>0x11</code>十进制的十六进制数字是<code>17</code> 。 <br>  <code>1e1</code>指数形式与<code>1 * 10 ** 1</code>即 才<code>10</code> 。 </p></div></div><br><h1 id="typeof"> 类型： </h1><br><h3 id="chto-vyvedet-etot-kod-39"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let foo = () =&gt; { return null; }; console.log( typeof typeof foo ); a) 'function' b) 'string' c) 'null' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）“字符串” </p></div></div><br><h3 id="chto-vyvedet-etot-kod-40"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">typeof function() {}.prototype; a) 'function' b) 'object' c) 'undefined' d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  b）“对象” <br>  <code>typeof</code>总是返回一个字符串，其优先级低于调用该函数的优先级，因此该函数将首先执行，并将<code>typeof</code>应用于返回的结果。 函数对象继承自Function.prototype。  Speck明确确定这是一个对象。 </p></div></div><br><h1 id="event-loop"> 事件循环： </h1><br><h2 id="nachnem-s-2-voprosov-pro-promisy"> 让我们从关于诺言的两个问题开始。 </h2><br><h3 id="chto-vyvedet-etot-kod-41"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">Promise.reject() .then(() =&gt; console.log(1), () =&gt; console.log(2)) .then(() =&gt; console.log(3), () =&gt; console.log(4)); a) 1 4 b) 1 3 c) 2 3 d) 2 4</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  c）2 3 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-42"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">Promise.reject('foo') .then(() =&gt; Promise.resolve('bar'), () =&gt; {}) .then((a) =&gt; {console.log(a)}) a) foo b) bar c) undefined d) </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）未定义 <br>  <code>Promise.reject</code>返回处于拒绝状态的承诺。 <br> 应该记住， <code>then</code>需要两个参数，即<code>onFulfill</code>和<code>onReject</code>回调。 如果在此之前发生错误，那么我们将转到<code>onReject</code>回调。 如果其中没有错误，则接下来是<code>onFulfill</code> 。 并且不要忘记<code>() =&gt; {}</code>返回的不是空对象，而是<code>undefined</code> ，为了返回一个空的对象，您应该这样写： <code>() =&gt; ({})</code> </p></div></div><br><h1 id="poryadok-vypolneniya-zadach"> 任务的顺序。 </h1><br><h3 id="chto-vyvedet-etot-kod-43"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">async function get1() { return 1; } function get2() { return 2; } (async () =&gt; { console.log(await get1()); })(); console.log(get2()); a) 1,2 b) 2,1 c) 1 d) 2</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）2.1 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-44"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">setTimeout(() =&gt; {console.log('in timeout')}); Promise.resolve() .then(() =&gt; {console.log('in promise')}); console.log('after'); a) in timeout, in promise, after b) after, in promise, in timeout c) after, in timeout, in promise d) in timeout, after, in promise</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）在承诺之后，在超时之后 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-45"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">let __promise = new Promise((res, rej) =&gt; { setTimeout(res, 1000); }); async function test(i) { await __promise; console.log(i); } test(1); test(2); a) 1, 2 b) 2, 1 c) 1 d) 2</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  a）1、2 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-46"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log('FUS'); setTimeout(() =&gt; {console.log('RO')}) Promise.resolve('DAH!').then(x =&gt; console.log(x)); a FUS RO DAH! b) FUS DAH! RO c) RO FUS DAH! d) DAH! RO FUS</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p>  b）FUS DAH！ 反渗透 </p></div></div><br><h3 id="chto-vyvedet-etot-kod-47"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">console.log(1); setTimeout(() =&gt; console.log('setTimeout'), 0); console.log(2); Promise.resolve().then(() =&gt; console.log('promise1 resolved')); console.log(3); a) 1, 2, 3, 'setTimeout', 'promise1 resolved' b) 1, 'setTimeout', 2, 'promise1 resolved', 3 c) 1, 2, 3, 'promise1 resolved', 'setTimeout' d) 1, 2, 'promise1 resolved', 3, 'setTimeout'</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）1、2、3，“已解决承诺1”，“ setTimeout” <br> 首先，将触发所有同步调用，然后，当调用堆栈为空时，将调用队列中的内容（异步任务）。 首先，微任务-诺言和<code>mutation observer</code> 。 在当前任务结束时，将执行所有微任务，与此微任务相关联，您可以阻止事件循环，任务完成后，浏览器将呈现。 之后，将执行宏任务-超时。 <br> 这是一个非常简化的示例，更详细地说，我建议您看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mikhail Bashurov</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讲话</a> </p></div></div><br><h1 id="i-posledniy-vopros-promise-protiv-await"> 最后一个问题答应与等待 </h1><br><h3 id="chto-vyvedet-etot-kod-48"> 此代码将输出什么？ </h3><br><pre> <code class="plaintext hljs">const p = Promise.resolve(); (async () =&gt; { await p; console.log('1'); })(); p.then(() =&gt; console.log('2')) .then(() =&gt; console.log('3'));</code> </pre> <br><p>  a）1 2 3 <br>  b）2 1 3 <br>  c）2 3 1 <br>  d）3 2 1 </p><br><div class="spoiler">  <b class="spoiler_title">答案+解析</b> <div class="spoiler_text"><p>  c）2 3 1 </p><br><p> 根据规范，必须首先执行添加的承诺，只有在此之后，您才需要继续 <br> 执行异步功能。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">斑点</a> 。 为了更详细地了解为什么这样做，建议您阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关v8.dev</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出色文章</a> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431698/">https://habr.com/ru/post/zh-CN431698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431688/index.html">Clang如何编译函数</a></li>
<li><a href="../zh-CN431690/index.html">解决卡巴斯基实验室的难题</a></li>
<li><a href="../zh-CN431692/index.html">免疫疗法在多发性硬化症治疗中的进展</a></li>
<li><a href="../zh-CN431694/index.html">排序“河内塔”</a></li>
<li><a href="../zh-CN431696/index.html">科丁 基础知识</a></li>
<li><a href="../zh-CN431700/index.html">我在市场上找不到的家用万用表</a></li>
<li><a href="../zh-CN431702/index.html">苏联HI-FI及其创造者：一部唱片的耳机或一个被遗忘的故事电子产品TDK-3“ Quad”</a></li>
<li><a href="../zh-CN431704/index.html">周末阅读：如何不损害您的听力并避免城市噪音-17篇文章和实用指南</a></li>
<li><a href="../zh-CN431706/index.html">幸福理论。 事故不是偶然的吗？</a></li>
<li><a href="../zh-CN431708/index.html">我在澳大利亚的搬迁和工作</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>