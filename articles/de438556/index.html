<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🌾 😨 🎅🏻 Daten bequem sägen 🕵🏾 👨🏼‍🌾 🔳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. 

 In der Praxis stoßen Sie häufig auf Aufgaben, die weit von komplexen ML-Algorithmen entfernt sind, aber gleichzeitig nicht weniger wicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daten bequem sägen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438556/"><img src="https://habrastorage.org/webt/im/nm/mx/imnmmxqmywsjq2wirence45dz4g.jpeg" alt="Bild"><br><br>  Guten Tag. <br><br>  In der Praxis stoßen Sie häufig auf Aufgaben, die weit von komplexen ML-Algorithmen entfernt sind, aber gleichzeitig nicht weniger wichtig und dringend für das Unternehmen sind. <br>  Reden wir über einen von ihnen. <br><br>  Die Aufgabe besteht darin, die Daten einer Zieltabelle mit Aggregaten (Aggregatwerten) auf einer Tabelle mit detaillierterer Granularität zu verteilen (Sägen, Rasplitovat - der Jargon des Geschäfts ist unerschöpflich). <br><br>  Zum Beispiel muss die Handelsabteilung den auf Markenebene vereinbarten Jahresplan aufschlüsseln - im Detail zu den Produkten, damit Vermarkter das jährliche Marketingbudget nach Ländern aufschlüsseln können, die Planungs- und Wirtschaftsabteilung die allgemeinen Geschäftskosten nach Finanzverantwortungszentren aufschlüsseln usw.  usw. <br><br>  Wenn Sie das Gefühl haben, dass solche Aufgaben bereits am Horizont vor Ihnen stehen oder bereits diejenigen behandeln, die unter solchen Aufgaben gelitten haben, dann bitte ich um eine Katze. <br><a name="habracut"></a><br>  Betrachten Sie ein reales Beispiel: <br><br>  Sie senken den Verkaufsplan als Aufgabe wie im Bild unten (ich habe das Beispiel in der Realität absichtlich vereinfacht - ein Excel-Banner mit 100 bis 200 MB). <br><br>  Überschriftenerklärung: <br><br><ul><li>  pos_terr-Gebiet (Region) der Steckdose </li><li>  pos_fo - der Bundesbezirk des Outlets (zum Beispiel der Central Federal District-Central Federal District) </li><li>  product_brend - Produktmarke </li><li>  product_class - Produktklasse </li><li>  plan.sales ist ein Verkaufsplan für alles. </li></ul><br><img src="https://habrastorage.org/webt/wc/2t/n5/wc2tn5wplux5kjawucs4gpl5ey8.png" alt="Bild"><br><br>  Und sie bitten zum Beispiel, ihren Mega-Tisch zu brechen (im Rahmen unseres Kinderbeispiels ist es natürlich bescheidener) - zum Vertriebskanal.  Auf die Frage - nach welcher Logik zu trennen, bekomme ich die Antwort: "Aber nehmen Sie die Statistik der tatsächlichen Verkäufe für das 4. Quartal dieses und jenes Jahres, erhalten Sie die tatsächlichen Anteile der Kanäle in% für jede Zeile des Plans und dividieren Sie durch diese Teile der Planzeile." <br>  In der Tat ist dies die häufigste Antwort bei solchen Aufgaben ... <br><br>  Bisher scheint alles einfach genug zu sein. <br><br>  Ich verstehe diese Tatsache (siehe Bild unten): <br><br><ul><li>  pos_channell - Vertriebskanal (Zielattribut für den Plan) </li><li>  fact.sales - tatsächlicher Verkauf von etwas. </li></ul><br><img src="https://habrastorage.org/webt/8t/uo/pn/8tuopnzhdexvdz9cq2c6sqftgxc.png" alt="Bild"><br><br>  Basierend auf dem erhaltenen Ansatz zum "Sägen" am Beispiel der ersten Zeile des Plans werden wir ihn auf der Grundlage der folgenden Tatsache aufschlüsseln: <br><br><img src="https://habrastorage.org/webt/b9/ib/q0/b9ibq06zbezjvfhsf5gxkeoba4s.png" alt="Bild"><br><br>  Wenn wir jedoch die Tatsache mit dem Plan für die gesamte Platte vergleichen, um zu verstehen, ob alle Linien des Plans in Anteilen angemessen „geschnitten“ werden können, erhalten wir das folgende Bild: (grün - alle Attribute der Planlinie stimmten mit der Tatsache überein, dass gelbe Zellen nicht übereinstimmten). <br><br><img src="https://habrastorage.org/webt/tp/vm/ta/tpvmtayhezx1cou7359wqzmds3c.png" alt="Bild"><br><br><ul><li>  In der ersten Zeile des Plans befinden sich alle Felder vollständig in der Tatsache. </li><li>  In der 2. Zeile des Plans wurde das entsprechende Gebiet tatsächlich nicht gefunden </li><li>  Die 3. Zeile des Plans reicht aufgrund der Marke nicht aus </li><li>  Die 4. Zeile des Plans reicht in Bezug auf das Territorium und den Bundesbezirk nicht aus </li><li>  In der 5. Zeile des Plans fehlen tatsächlich die Marke und die Klasse. </li></ul><br>  Wie Panikovsky sagte: "Sah die Shura, sah - sie sind Gold ..." <br><br><img src="https://habrastorage.org/webt/m3/v0/ig/m3v0ig5ao9agopnt9-7tthegaiu.jpeg" alt="Bild"><br><br>  Ich gehe zum Geschäftskunden und kläre am Beispiel der 2. Zeile, welchen Ansatz er für solche Situationen sieht. <br><br>  Ich bekomme die Antwort: „In Fällen, in denen es nicht möglich ist, den Anteil der Kanäle für Marke Nr. 2 in der Region Smolensk zu berechnen (unter Berücksichtigung der Tatsache, dass wir die Region Smolensk im zentralen Bundesbezirk-zentralen Bundesbezirk haben) - dann brechen Sie diese Linie entsprechend der Struktur der Kanäle im gesamten zentralen Bundesbezirk!“ <br><br>  Das heißt, für {Region Smolensk + Marke_2} aggregieren wir die Tatsache auf der Ebene des Bundesdistrikts und teilen die Region Smolensk wie folgt auf: <br><br><img src="https://habrastorage.org/webt/2t/pf/i1/2tpfi18n14-qytt76pydyjjwnfs.png" alt="Bild"><br><br>  Ich gehe zurück und verdaue, was ich gehört habe, und versuche, es auf eine universellere Heuristik zu verallgemeinern: <br>  Wenn auf der aktuellen Detailebene der Faktentabelle keine Daten vorhanden sind, aggregieren wir vor der Berechnung der Anteile für das Zielfeld (Vertriebskanal) die Faktentabelle bis zum obigen Hierarchieattribut. <br><br>  Das heißt, wenn nicht für das Gebiet, dann aggregieren wir die Tatsache auf eine höhere Hierarchieebene - Anteile für denselben zentralen Bundesdistrikt wie im Plan.  Wenn nicht für die Marke, dann gibt es in der obigen Hierarchie eine Produktklasse - dementsprechend zählen wir die Anteile für dieselbe Klasse und so weiter. <br><br>  Das heißt,  Wir kombinieren den Plan und die Tatsache auf den Kopplungsfeldern, für die wir die Anteile an der Tatsache berücksichtigen, und reduzieren bei jeder Iteration gemäß dem verbleibenden nicht verteilten Plan sukzessive die Zusammensetzung der Kopplungsfelder. <br><br>  Hier zeichnet sich bereits ein bestimmtes Datenverteilungsmuster ab: <br><br><ol><li>  Wir verteilen den Plan tatsächlich auf der Grundlage der vollständigen Übereinstimmung der entsprechenden Felder </li><li>  Wir erhalten einen kaputten Plan (wir akkumulieren ihn im Zwischenergebnis) und einen ungebrochenen Plan (nicht alle Zeilen stimmen überein). </li><li>  Wir nehmen einen ungebrochenen Plan und teilen ihn tatsächlich auf eine höhere Hierarchieebene auf (d. H. Wir geben ein bestimmtes Kopplungsfeld dieser beiden Tabellen auf und aggregieren die Tatsache ohne dieses Feld, um die Anteile zu berechnen). </li><li>  Wir erhalten einen fehlerhaften Plan (wir fügen ihn dem Zwischenergebnis hinzu) und einen ungebrochenen Plan (nicht alle Zeilen stimmen überein). </li><li>  Und wir wiederholen die gleichen Schritte, bis es keinen „ungelösten“ Plan mehr gibt. </li></ol><br>  Im Allgemeinen verpflichtet uns niemand, Hitch-Felder nur innerhalb der Hierarchie konsequent zu entfernen.  Zum Beispiel haben wir die Marke und das Gebiet bereits aus den Hitch-Feldern entfernt und den verbleibenden Plan verteilt nach: product_class (Hierarchie über der Marke) + Fed.krug (Hierarchie über dem Gebiet).  Und immer noch ein nicht zugewiesenes Gleichgewicht des Plans. <br><br>  Ferner können wir aus den Kopplungsfeldern entweder die Produktklasse oder den Bundesbezirk als entfernen  Sie sind nicht mehr in die Hierarchie des anderen eingebettet. <br><br>  Wenn man bedenkt, dass solche Tabellen Dutzende und Reihen von Feldern enthalten - bis zu einer Million, die solche Manipulationen mit den Händen ausführen -, ist die Aufgabe nicht die angenehmste. <br><br>  Und da mir solche Aufgaben am Ende eines jeden Jahres regelmäßig einfallen (Genehmigung der Budgets für das nächste Jahr im Verwaltungsrat), mussten Sie diesen Prozess in eine Art flexible universelle Vorlage übersetzen. <br><br>  Und da ich die meiste Zeit mit Daten über R arbeite, ist die Implementierung entsprechend gleich. <br><br>  Zuerst müssen wir eine universelle magische Funktion schreiben, die eine Basistabelle (Basetab) mit Daten für eine Aufschlüsselung (in unserem Beispiel einen Plan) und eine Tabelle zur Berechnung von Anteilen (Sharetab) verwendet, auf deren Grundlage wir die Daten "sehen" (in unserem Beispiel) Tatsache).  Die Funktion muss jedoch auch verstehen, was mit diesen Objekten zu tun ist, damit die Funktion auch den Vektor der Namen der Kopplungsfelder (merge.vrs) akzeptiert - d. H.  Diese Felder, die in beiden Tabellen identisch benannt sind und es uns ermöglichen, eine Tabelle mit den anderen Feldern zu verbinden, in denen sie funktioniert (d. h. Rechtsverknüpfung).  Außerdem sollte die Funktion verstehen, welche Spalte der Basistabelle in die Verteilung aufgenommen werden soll (basetab.value) und basierend auf welchem ​​Feld die Anteile gezählt werden sollen (sharetab.value).  Nun, und vor allem - was für das resultierende Feld (sharetab.targetvars) zu beachten ist, in unserem Fall möchten wir den Plan über den Vertriebskanal anhand der Tatsache detaillieren. <br><br>  Übrigens ist diese Variable sharetab.targetvars in meinem Plural nicht zufällig - es kann sich nicht um ein Feld, sondern um einen Vektor von Feldnamen handeln, wenn Sie der Basistabelle nicht ein Feld aus der Freigabetabelle hinzufügen müssen, sondern mehrere gleichzeitig (z. B. können Sie den Plan aufgrund der Tatsache nicht aufteilen nur über den Vertriebskanal, aber auch über den Namen der in der Marke enthaltenen Produkte). <br><br>  Ja, und noch eine Bedingung :) Meine Funktion sollte so lokalistisch und lesbar wie möglich sein, ohne mehrstöckiges Gebäude auf 2 Bildschirmen (ich mag große Funktionen wirklich nicht). <br><br>  In der letzten Bedingung passte das beliebte dplyr-Paket so bequem wie möglich, und da die Pipeline-Betreiber die Textnamen der Felder verstehen müssen, die in die Funktion abgesenkt wurden, war die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standart-Bewertung</a> nicht ohne. <br><br>  Hier ist dieses Baby (ohne interne Kommentare): <br><br><pre><code class="plaintext hljs">fn_distr &lt;- function(sharetab, sharetab.value, sharetab.targetvars, basetab, basetab.value, merge.vrs,level.txt=NA) { # sharetab - =   # sharetab.value -            - # sharetab.targetvars -      -          # basetab - =      # basetab.value -         # merge.vrs -    2-  # level.txt -    .       (     merge.vrs) require(dplyr) sharetab.value &lt;- as.name(sharetab.value) basetab.value &lt;- as.name(basetab.value) if(is.na(level.txt )){level.txt &lt;- paste0(merge.vrs,collapse = ",")} result &lt;- sharetab %&gt;% group_by(.dots = c(merge.vrs, sharetab.targetvars)) %&gt;% summarise(sharetab.sum = sum(!!sharetab.value)) %&gt;% ungroup %&gt;% group_by(.dots = merge.vrs) %&gt;% mutate(sharetab.share = sharetab.sum / sum(sharetab.sum)) %&gt;% ungroup %&gt;% right_join(y = basetab, by = merge.vrs) %&gt;% mutate(distributed.result = !!basetab.value * sharetab.share, level = level.txt) %&gt;% select(-sharetab.sum,-sharetab.share) return(result) }</code> </pre> <br>  Bei der Ausgabe sollte die Funktion data.frame der Vereinigung zweier Tabellen mit den Zeilen des Plans + fact zurückgeben, in denen der Plan in der aktuellen Version der Kopplungsfelder aufgeteilt werden konnte, und mit den ursprünglichen Zeilen des Plans (und der leeren Tatsache) in den Zeilen, in denen der Plan in der aktuellen Iteration nicht aufgeteilt werden konnte. <br><br>  Das heißt, das Ergebnis, das von der Funktion nach der ersten Iteration zurückgegeben wird (wobei die erste Zeile des Plans für die Region Jaroslawl unterbrochen wird), sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/zr/jy/nz/zrjynzehck-sb3mv1bysenaixde.png" alt="Bild"><br><br>  Ferner kann dieses Ergebnis durch nicht leeres verteiltes Ergebnis in das kumulative Ergebnis und durch leeres (NA) verteiltes Ergebnis übernommen werden - an die nächste typische Iteration senden, jedoch nach Freigaben auf einer höheren Hierarchieebene unterteilt. <br><br>  Der ganze Reiz und die Bequemlichkeit besteht darin, dass die Arbeit in derselben Art von Blöcken und einer universellen Funktion ausgeführt wird. Bei jedem Schritt (Iteration) muss lediglich der Vektor merge.vrs korrigiert und beobachtet werden, wie die Magie all diese mühsame Arbeit für Sie erledigt: <br><br><img src="https://habrastorage.org/webt/rb/7x/hb/rb7xhby_9ztkha0hwfjfysslxaq.jpeg" alt="Bild"><br><br>  Ja, ich habe fast eine kleine Nuance vergessen: Wenn etwas schief geht und wir am Ende einen kaputten Plan erhalten, der insgesamt nicht dem Plan vor dem Zusammenbruch entspricht, wird es schwierig sein zu verfolgen, bei welcher Iteration alles schief gelaufen ist. <br><br>  Daher liefern wir jeder Iteration eine Prüfsumme: <br><br><pre> <code class="plaintext hljs">(_)-(___ )-(___.)=0</code> </pre> <br>  Versuchen wir nun, unser Beispiel durch die Verteilungsvorlage zu führen und zu sehen, was wir an der Ausgabe erhalten. <br><br>  Holen Sie sich zuerst die Quelldaten: <br><br><pre> <code class="plaintext hljs">library(dplyr) plan &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "), pos_fo = c("", "", "", "", ""), product_brend = c("brend_1", "brend_2", "brend_3", "brend_4", "brend_5"), product_class = c("class_1", "class_1", "class_2", "class_2", "class_3"), plan.sales = c(100, 200, 300, 400, 500)) fact &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "," ", " ", " ", " ", " "), pos_fo = c("", "","","", "", "", "", "", "", ""), product_brend = c("brend_1", "brend_1", "brend_2", "brend_2","brend_2", "brend_4", "brend_4", "brend_1", "brend_2", "brend_4"), product_class = c("class_1", "class_1", "class_1","class_1","class_1", "class_2", "class_2", "class_1", "class_1", "class_2"), pos_channell = c("", "", "","", "", "", "", "", "", ""), fact.sales = c(16.38, 11.64, 30.73,60, 20, 6.40, 26.49, 46.63, 65.96, 98.81)) &lt;/soure&gt;      (   )     . &lt;source&gt; plan.remain &lt;- plan result.total &lt;- data_frame()</code> </pre><br>  <b>1. Wir vertreiben nach Terr, FD (Bundesdistrikt), Marke, Klasse</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_terr","pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) #     -      plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) #            =    cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/84/zv/zq/84zvzqtilnk4mbdvkntjpf43lls.png" alt="Bild"><br><br>  <b>2. Wir vertreiben nach Pho, Marke, Klasse (das heißt, wir verlassen das Gebiet tatsächlich)</b> <br><br>  Der einzige Unterschied zum ersten Block besteht darin, dass sie merge.fields leicht verkürzen, indem sie pos_terr darin entfernen <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>3. Verteilen Sie nach Pho, Klasse</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>4. Nach Klasse verteilen</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/fe/-q/nd/fe-qnd2szmr7giomwxnliujddha.png" alt="Bild"><br><br>  <b>5. Verteilen Sie durch FD</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "pos_fo") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  Wie Sie sehen können, gibt es keinen "nicht gesägten" Plan mehr und die Arithmetik des verteilten Plans entspricht der ursprünglichen. <br><br><img src="https://habrastorage.org/webt/bb/cz/-e/bbcz-enxlpsnwnji6atftwle1tg.png" alt="Bild"><br><br>  Und hier ist das Ergebnis mit Vertriebskanälen (in der rechten Spalte zeigt die Funktion an, für welche Felder die Kopplung / Aggregation bestimmt war, damit wir später verstehen können, woher diese Verteilung stammt): <br><br><img src="https://habrastorage.org/webt/l_/3t/fg/l_3tfgj9v2hvsflh_q18o8l2cbo.png" alt="Bild"><br><br>  Das ist alles  Der Artikel war nicht sehr klein, aber es gibt mehr erklärenden Text als den Code selbst. <br><br>  Ich hoffe, dieser flexible Ansatz spart nicht nur mir Zeit und Nerven :-) <br><br>  Vielen Dank für Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438556/">https://habr.com/ru/post/de438556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438544/index.html">Wir schauen zu Hause Filme: 10 Materialien über den Bau eines Heimkinos und die Auswahl der Ausrüstung</a></li>
<li><a href="../de438546/index.html">Analyse von Modulbindungsansätzen in Node.js.</a></li>
<li><a href="../de438548/index.html">Lombok, sources.jar und praktisches Debuggen</a></li>
<li><a href="../de438550/index.html">Ein weiteres Manifest</a></li>
<li><a href="../de438554/index.html">Verwalten des Status und der Ereignisse zwischen Komponenten in GameObject</a></li>
<li><a href="../de438560/index.html">XGBoost von Grund auf neu schreiben - Teil 1: Entscheidungsbäume</a></li>
<li><a href="../de438562/index.html">XGBoost von Grund auf neu schreiben - Teil 2: Gradientenverstärkung</a></li>
<li><a href="../de438566/index.html">Apple Strange A12X Mikroprozessorgehäuse</a></li>
<li><a href="../de438568/index.html">Über Quantencomputer: Wie verschiedene Länder diese Technologie entwickeln</a></li>
<li><a href="../de438570/index.html">CS Center 2018 Silvesterwettbewerb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>