<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸŒ¾ ğŸ˜¨ ğŸ…ğŸ» Daten bequem sÃ¤gen ğŸ•µğŸ¾ ğŸ‘¨ğŸ¼â€ğŸŒ¾ ğŸ”³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. 

 In der Praxis stoÃŸen Sie hÃ¤ufig auf Aufgaben, die weit von komplexen ML-Algorithmen entfernt sind, aber gleichzeitig nicht weniger wicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daten bequem sÃ¤gen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438556/"><img src="https://habrastorage.org/webt/im/nm/mx/imnmmxqmywsjq2wirence45dz4g.jpeg" alt="Bild"><br><br>  Guten Tag. <br><br>  In der Praxis stoÃŸen Sie hÃ¤ufig auf Aufgaben, die weit von komplexen ML-Algorithmen entfernt sind, aber gleichzeitig nicht weniger wichtig und dringend fÃ¼r das Unternehmen sind. <br>  Reden wir Ã¼ber einen von ihnen. <br><br>  Die Aufgabe besteht darin, die Daten einer Zieltabelle mit Aggregaten (Aggregatwerten) auf einer Tabelle mit detaillierterer GranularitÃ¤t zu verteilen (SÃ¤gen, Rasplitovat - der Jargon des GeschÃ¤fts ist unerschÃ¶pflich). <br><br>  Zum Beispiel muss die Handelsabteilung den auf Markenebene vereinbarten Jahresplan aufschlÃ¼sseln - im Detail zu den Produkten, damit Vermarkter das jÃ¤hrliche Marketingbudget nach LÃ¤ndern aufschlÃ¼sseln kÃ¶nnen, die Planungs- und Wirtschaftsabteilung die allgemeinen GeschÃ¤ftskosten nach Finanzverantwortungszentren aufschlÃ¼sseln usw.  usw. <br><br>  Wenn Sie das GefÃ¼hl haben, dass solche Aufgaben bereits am Horizont vor Ihnen stehen oder bereits diejenigen behandeln, die unter solchen Aufgaben gelitten haben, dann bitte ich um eine Katze. <br><a name="habracut"></a><br>  Betrachten Sie ein reales Beispiel: <br><br>  Sie senken den Verkaufsplan als Aufgabe wie im Bild unten (ich habe das Beispiel in der RealitÃ¤t absichtlich vereinfacht - ein Excel-Banner mit 100 bis 200 MB). <br><br>  ÃœberschriftenerklÃ¤rung: <br><br><ul><li>  pos_terr-Gebiet (Region) der Steckdose </li><li>  pos_fo - der Bundesbezirk des Outlets (zum Beispiel der Central Federal District-Central Federal District) </li><li>  product_brend - Produktmarke </li><li>  product_class - Produktklasse </li><li>  plan.sales ist ein Verkaufsplan fÃ¼r alles. </li></ul><br><img src="https://habrastorage.org/webt/wc/2t/n5/wc2tn5wplux5kjawucs4gpl5ey8.png" alt="Bild"><br><br>  Und sie bitten zum Beispiel, ihren Mega-Tisch zu brechen (im Rahmen unseres Kinderbeispiels ist es natÃ¼rlich bescheidener) - zum Vertriebskanal.  Auf die Frage - nach welcher Logik zu trennen, bekomme ich die Antwort: "Aber nehmen Sie die Statistik der tatsÃ¤chlichen VerkÃ¤ufe fÃ¼r das 4. Quartal dieses und jenes Jahres, erhalten Sie die tatsÃ¤chlichen Anteile der KanÃ¤le in% fÃ¼r jede Zeile des Plans und dividieren Sie durch diese Teile der Planzeile." <br>  In der Tat ist dies die hÃ¤ufigste Antwort bei solchen Aufgaben ... <br><br>  Bisher scheint alles einfach genug zu sein. <br><br>  Ich verstehe diese Tatsache (siehe Bild unten): <br><br><ul><li>  pos_channell - Vertriebskanal (Zielattribut fÃ¼r den Plan) </li><li>  fact.sales - tatsÃ¤chlicher Verkauf von etwas. </li></ul><br><img src="https://habrastorage.org/webt/8t/uo/pn/8tuopnzhdexvdz9cq2c6sqftgxc.png" alt="Bild"><br><br>  Basierend auf dem erhaltenen Ansatz zum "SÃ¤gen" am Beispiel der ersten Zeile des Plans werden wir ihn auf der Grundlage der folgenden Tatsache aufschlÃ¼sseln: <br><br><img src="https://habrastorage.org/webt/b9/ib/q0/b9ibq06zbezjvfhsf5gxkeoba4s.png" alt="Bild"><br><br>  Wenn wir jedoch die Tatsache mit dem Plan fÃ¼r die gesamte Platte vergleichen, um zu verstehen, ob alle Linien des Plans in Anteilen angemessen â€geschnittenâ€œ werden kÃ¶nnen, erhalten wir das folgende Bild: (grÃ¼n - alle Attribute der Planlinie stimmten mit der Tatsache Ã¼berein, dass gelbe Zellen nicht Ã¼bereinstimmten). <br><br><img src="https://habrastorage.org/webt/tp/vm/ta/tpvmtayhezx1cou7359wqzmds3c.png" alt="Bild"><br><br><ul><li>  In der ersten Zeile des Plans befinden sich alle Felder vollstÃ¤ndig in der Tatsache. </li><li>  In der 2. Zeile des Plans wurde das entsprechende Gebiet tatsÃ¤chlich nicht gefunden </li><li>  Die 3. Zeile des Plans reicht aufgrund der Marke nicht aus </li><li>  Die 4. Zeile des Plans reicht in Bezug auf das Territorium und den Bundesbezirk nicht aus </li><li>  In der 5. Zeile des Plans fehlen tatsÃ¤chlich die Marke und die Klasse. </li></ul><br>  Wie Panikovsky sagte: "Sah die Shura, sah - sie sind Gold ..." <br><br><img src="https://habrastorage.org/webt/m3/v0/ig/m3v0ig5ao9agopnt9-7tthegaiu.jpeg" alt="Bild"><br><br>  Ich gehe zum GeschÃ¤ftskunden und klÃ¤re am Beispiel der 2. Zeile, welchen Ansatz er fÃ¼r solche Situationen sieht. <br><br>  Ich bekomme die Antwort: â€In FÃ¤llen, in denen es nicht mÃ¶glich ist, den Anteil der KanÃ¤le fÃ¼r Marke Nr. 2 in der Region Smolensk zu berechnen (unter BerÃ¼cksichtigung der Tatsache, dass wir die Region Smolensk im zentralen Bundesbezirk-zentralen Bundesbezirk haben) - dann brechen Sie diese Linie entsprechend der Struktur der KanÃ¤le im gesamten zentralen Bundesbezirk!â€œ <br><br>  Das heiÃŸt, fÃ¼r {Region Smolensk + Marke_2} aggregieren wir die Tatsache auf der Ebene des Bundesdistrikts und teilen die Region Smolensk wie folgt auf: <br><br><img src="https://habrastorage.org/webt/2t/pf/i1/2tpfi18n14-qytt76pydyjjwnfs.png" alt="Bild"><br><br>  Ich gehe zurÃ¼ck und verdaue, was ich gehÃ¶rt habe, und versuche, es auf eine universellere Heuristik zu verallgemeinern: <br>  Wenn auf der aktuellen Detailebene der Faktentabelle keine Daten vorhanden sind, aggregieren wir vor der Berechnung der Anteile fÃ¼r das Zielfeld (Vertriebskanal) die Faktentabelle bis zum obigen Hierarchieattribut. <br><br>  Das heiÃŸt, wenn nicht fÃ¼r das Gebiet, dann aggregieren wir die Tatsache auf eine hÃ¶here Hierarchieebene - Anteile fÃ¼r denselben zentralen Bundesdistrikt wie im Plan.  Wenn nicht fÃ¼r die Marke, dann gibt es in der obigen Hierarchie eine Produktklasse - dementsprechend zÃ¤hlen wir die Anteile fÃ¼r dieselbe Klasse und so weiter. <br><br>  Das heiÃŸt,  Wir kombinieren den Plan und die Tatsache auf den Kopplungsfeldern, fÃ¼r die wir die Anteile an der Tatsache berÃ¼cksichtigen, und reduzieren bei jeder Iteration gemÃ¤ÃŸ dem verbleibenden nicht verteilten Plan sukzessive die Zusammensetzung der Kopplungsfelder. <br><br>  Hier zeichnet sich bereits ein bestimmtes Datenverteilungsmuster ab: <br><br><ol><li>  Wir verteilen den Plan tatsÃ¤chlich auf der Grundlage der vollstÃ¤ndigen Ãœbereinstimmung der entsprechenden Felder </li><li>  Wir erhalten einen kaputten Plan (wir akkumulieren ihn im Zwischenergebnis) und einen ungebrochenen Plan (nicht alle Zeilen stimmen Ã¼berein). </li><li>  Wir nehmen einen ungebrochenen Plan und teilen ihn tatsÃ¤chlich auf eine hÃ¶here Hierarchieebene auf (d. H. Wir geben ein bestimmtes Kopplungsfeld dieser beiden Tabellen auf und aggregieren die Tatsache ohne dieses Feld, um die Anteile zu berechnen). </li><li>  Wir erhalten einen fehlerhaften Plan (wir fÃ¼gen ihn dem Zwischenergebnis hinzu) und einen ungebrochenen Plan (nicht alle Zeilen stimmen Ã¼berein). </li><li>  Und wir wiederholen die gleichen Schritte, bis es keinen â€ungelÃ¶stenâ€œ Plan mehr gibt. </li></ol><br>  Im Allgemeinen verpflichtet uns niemand, Hitch-Felder nur innerhalb der Hierarchie konsequent zu entfernen.  Zum Beispiel haben wir die Marke und das Gebiet bereits aus den Hitch-Feldern entfernt und den verbleibenden Plan verteilt nach: product_class (Hierarchie Ã¼ber der Marke) + Fed.krug (Hierarchie Ã¼ber dem Gebiet).  Und immer noch ein nicht zugewiesenes Gleichgewicht des Plans. <br><br>  Ferner kÃ¶nnen wir aus den Kopplungsfeldern entweder die Produktklasse oder den Bundesbezirk als entfernen  Sie sind nicht mehr in die Hierarchie des anderen eingebettet. <br><br>  Wenn man bedenkt, dass solche Tabellen Dutzende und Reihen von Feldern enthalten - bis zu einer Million, die solche Manipulationen mit den HÃ¤nden ausfÃ¼hren -, ist die Aufgabe nicht die angenehmste. <br><br>  Und da mir solche Aufgaben am Ende eines jeden Jahres regelmÃ¤ÃŸig einfallen (Genehmigung der Budgets fÃ¼r das nÃ¤chste Jahr im Verwaltungsrat), mussten Sie diesen Prozess in eine Art flexible universelle Vorlage Ã¼bersetzen. <br><br>  Und da ich die meiste Zeit mit Daten Ã¼ber R arbeite, ist die Implementierung entsprechend gleich. <br><br>  Zuerst mÃ¼ssen wir eine universelle magische Funktion schreiben, die eine Basistabelle (Basetab) mit Daten fÃ¼r eine AufschlÃ¼sselung (in unserem Beispiel einen Plan) und eine Tabelle zur Berechnung von Anteilen (Sharetab) verwendet, auf deren Grundlage wir die Daten "sehen" (in unserem Beispiel) Tatsache).  Die Funktion muss jedoch auch verstehen, was mit diesen Objekten zu tun ist, damit die Funktion auch den Vektor der Namen der Kopplungsfelder (merge.vrs) akzeptiert - d. H.  Diese Felder, die in beiden Tabellen identisch benannt sind und es uns ermÃ¶glichen, eine Tabelle mit den anderen Feldern zu verbinden, in denen sie funktioniert (d. h. RechtsverknÃ¼pfung).  AuÃŸerdem sollte die Funktion verstehen, welche Spalte der Basistabelle in die Verteilung aufgenommen werden soll (basetab.value) und basierend auf welchem â€‹â€‹Feld die Anteile gezÃ¤hlt werden sollen (sharetab.value).  Nun, und vor allem - was fÃ¼r das resultierende Feld (sharetab.targetvars) zu beachten ist, in unserem Fall mÃ¶chten wir den Plan Ã¼ber den Vertriebskanal anhand der Tatsache detaillieren. <br><br>  Ãœbrigens ist diese Variable sharetab.targetvars in meinem Plural nicht zufÃ¤llig - es kann sich nicht um ein Feld, sondern um einen Vektor von Feldnamen handeln, wenn Sie der Basistabelle nicht ein Feld aus der Freigabetabelle hinzufÃ¼gen mÃ¼ssen, sondern mehrere gleichzeitig (z. B. kÃ¶nnen Sie den Plan aufgrund der Tatsache nicht aufteilen nur Ã¼ber den Vertriebskanal, aber auch Ã¼ber den Namen der in der Marke enthaltenen Produkte). <br><br>  Ja, und noch eine Bedingung :) Meine Funktion sollte so lokalistisch und lesbar wie mÃ¶glich sein, ohne mehrstÃ¶ckiges GebÃ¤ude auf 2 Bildschirmen (ich mag groÃŸe Funktionen wirklich nicht). <br><br>  In der letzten Bedingung passte das beliebte dplyr-Paket so bequem wie mÃ¶glich, und da die Pipeline-Betreiber die Textnamen der Felder verstehen mÃ¼ssen, die in die Funktion abgesenkt wurden, war die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standart-Bewertung</a> nicht ohne. <br><br>  Hier ist dieses Baby (ohne interne Kommentare): <br><br><pre><code class="plaintext hljs">fn_distr &lt;- function(sharetab, sharetab.value, sharetab.targetvars, basetab, basetab.value, merge.vrs,level.txt=NA) { # sharetab - =   # sharetab.value -            - # sharetab.targetvars -      -          # basetab - =      # basetab.value -         # merge.vrs -    2-  # level.txt -    .       (     merge.vrs) require(dplyr) sharetab.value &lt;- as.name(sharetab.value) basetab.value &lt;- as.name(basetab.value) if(is.na(level.txt )){level.txt &lt;- paste0(merge.vrs,collapse = ",")} result &lt;- sharetab %&gt;% group_by(.dots = c(merge.vrs, sharetab.targetvars)) %&gt;% summarise(sharetab.sum = sum(!!sharetab.value)) %&gt;% ungroup %&gt;% group_by(.dots = merge.vrs) %&gt;% mutate(sharetab.share = sharetab.sum / sum(sharetab.sum)) %&gt;% ungroup %&gt;% right_join(y = basetab, by = merge.vrs) %&gt;% mutate(distributed.result = !!basetab.value * sharetab.share, level = level.txt) %&gt;% select(-sharetab.sum,-sharetab.share) return(result) }</code> </pre> <br>  Bei der Ausgabe sollte die Funktion data.frame der Vereinigung zweier Tabellen mit den Zeilen des Plans + fact zurÃ¼ckgeben, in denen der Plan in der aktuellen Version der Kopplungsfelder aufgeteilt werden konnte, und mit den ursprÃ¼nglichen Zeilen des Plans (und der leeren Tatsache) in den Zeilen, in denen der Plan in der aktuellen Iteration nicht aufgeteilt werden konnte. <br><br>  Das heiÃŸt, das Ergebnis, das von der Funktion nach der ersten Iteration zurÃ¼ckgegeben wird (wobei die erste Zeile des Plans fÃ¼r die Region Jaroslawl unterbrochen wird), sieht folgendermaÃŸen aus: <br><br><img src="https://habrastorage.org/webt/zr/jy/nz/zrjynzehck-sb3mv1bysenaixde.png" alt="Bild"><br><br>  Ferner kann dieses Ergebnis durch nicht leeres verteiltes Ergebnis in das kumulative Ergebnis und durch leeres (NA) verteiltes Ergebnis Ã¼bernommen werden - an die nÃ¤chste typische Iteration senden, jedoch nach Freigaben auf einer hÃ¶heren Hierarchieebene unterteilt. <br><br>  Der ganze Reiz und die Bequemlichkeit besteht darin, dass die Arbeit in derselben Art von BlÃ¶cken und einer universellen Funktion ausgefÃ¼hrt wird. Bei jedem Schritt (Iteration) muss lediglich der Vektor merge.vrs korrigiert und beobachtet werden, wie die Magie all diese mÃ¼hsame Arbeit fÃ¼r Sie erledigt: <br><br><img src="https://habrastorage.org/webt/rb/7x/hb/rb7xhby_9ztkha0hwfjfysslxaq.jpeg" alt="Bild"><br><br>  Ja, ich habe fast eine kleine Nuance vergessen: Wenn etwas schief geht und wir am Ende einen kaputten Plan erhalten, der insgesamt nicht dem Plan vor dem Zusammenbruch entspricht, wird es schwierig sein zu verfolgen, bei welcher Iteration alles schief gelaufen ist. <br><br>  Daher liefern wir jeder Iteration eine PrÃ¼fsumme: <br><br><pre> <code class="plaintext hljs">(_)-(___ )-(___.)=0</code> </pre> <br>  Versuchen wir nun, unser Beispiel durch die Verteilungsvorlage zu fÃ¼hren und zu sehen, was wir an der Ausgabe erhalten. <br><br>  Holen Sie sich zuerst die Quelldaten: <br><br><pre> <code class="plaintext hljs">library(dplyr) plan &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "), pos_fo = c("", "", "", "", ""), product_brend = c("brend_1", "brend_2", "brend_3", "brend_4", "brend_5"), product_class = c("class_1", "class_1", "class_2", "class_2", "class_3"), plan.sales = c(100, 200, 300, 400, 500)) fact &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "," ", " ", " ", " ", " "), pos_fo = c("", "","","", "", "", "", "", "", ""), product_brend = c("brend_1", "brend_1", "brend_2", "brend_2","brend_2", "brend_4", "brend_4", "brend_1", "brend_2", "brend_4"), product_class = c("class_1", "class_1", "class_1","class_1","class_1", "class_2", "class_2", "class_1", "class_1", "class_2"), pos_channell = c("", "", "","", "", "", "", "", "", ""), fact.sales = c(16.38, 11.64, 30.73,60, 20, 6.40, 26.49, 46.63, 65.96, 98.81)) &lt;/soure&gt;      (   )     . &lt;source&gt; plan.remain &lt;- plan result.total &lt;- data_frame()</code> </pre><br>  <b>1. Wir vertreiben nach Terr, FD (Bundesdistrikt), Marke, Klasse</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_terr","pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) #     -      plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) #            =    cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/84/zv/zq/84zvzqtilnk4mbdvkntjpf43lls.png" alt="Bild"><br><br>  <b>2. Wir vertreiben nach Pho, Marke, Klasse (das heiÃŸt, wir verlassen das Gebiet tatsÃ¤chlich)</b> <br><br>  Der einzige Unterschied zum ersten Block besteht darin, dass sie merge.fields leicht verkÃ¼rzen, indem sie pos_terr darin entfernen <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>3. Verteilen Sie nach Pho, Klasse</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>4. Nach Klasse verteilen</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/fe/-q/nd/fe-qnd2szmr7giomwxnliujddha.png" alt="Bild"><br><br>  <b>5. Verteilen Sie durch FD</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "pos_fo") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  Wie Sie sehen kÃ¶nnen, gibt es keinen "nicht gesÃ¤gten" Plan mehr und die Arithmetik des verteilten Plans entspricht der ursprÃ¼nglichen. <br><br><img src="https://habrastorage.org/webt/bb/cz/-e/bbcz-enxlpsnwnji6atftwle1tg.png" alt="Bild"><br><br>  Und hier ist das Ergebnis mit VertriebskanÃ¤len (in der rechten Spalte zeigt die Funktion an, fÃ¼r welche Felder die Kopplung / Aggregation bestimmt war, damit wir spÃ¤ter verstehen kÃ¶nnen, woher diese Verteilung stammt): <br><br><img src="https://habrastorage.org/webt/l_/3t/fg/l_3tfgj9v2hvsflh_q18o8l2cbo.png" alt="Bild"><br><br>  Das ist alles  Der Artikel war nicht sehr klein, aber es gibt mehr erklÃ¤renden Text als den Code selbst. <br><br>  Ich hoffe, dieser flexible Ansatz spart nicht nur mir Zeit und Nerven :-) <br><br>  Vielen Dank fÃ¼r Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438556/">https://habr.com/ru/post/de438556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438544/index.html">Wir schauen zu Hause Filme: 10 Materialien Ã¼ber den Bau eines Heimkinos und die Auswahl der AusrÃ¼stung</a></li>
<li><a href="../de438546/index.html">Analyse von ModulbindungsansÃ¤tzen in Node.js.</a></li>
<li><a href="../de438548/index.html">Lombok, sources.jar und praktisches Debuggen</a></li>
<li><a href="../de438550/index.html">Ein weiteres Manifest</a></li>
<li><a href="../de438554/index.html">Verwalten des Status und der Ereignisse zwischen Komponenten in GameObject</a></li>
<li><a href="../de438560/index.html">XGBoost von Grund auf neu schreiben - Teil 1: EntscheidungsbÃ¤ume</a></li>
<li><a href="../de438562/index.html">XGBoost von Grund auf neu schreiben - Teil 2: GradientenverstÃ¤rkung</a></li>
<li><a href="../de438566/index.html">Apple Strange A12X MikroprozessorgehÃ¤use</a></li>
<li><a href="../de438568/index.html">Ãœber Quantencomputer: Wie verschiedene LÃ¤nder diese Technologie entwickeln</a></li>
<li><a href="../de438570/index.html">CS Center 2018 Silvesterwettbewerb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>