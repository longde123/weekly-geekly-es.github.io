<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 🎌 🛀🏼 Wie funktioniert ein dezentraler Messenger in der Blockchain? ☔️ 👩🏿‍🌾 🕴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang 2017 haben wir begonnen, einen Messenger in der Blockchain zu erstellen [Name und Link befinden sich im Profil], indem wir die Vorteile gegenüb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert ein dezentraler Messenger in der Blockchain?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467751/"> Anfang 2017 haben wir begonnen, einen Messenger in der Blockchain zu erstellen [Name und Link befinden sich im Profil], indem wir die Vorteile gegenüber klassischen P2P-Messenger erörtert haben. <br><br>  <code>2.5</code> Jahre vergingen und wir konnten unser Konzept bestätigen: Instant Messenger-Anwendungen für iOS, Web PWA, Windows, GNU / Linux, Mac OS und Android sind jetzt verfügbar. <br><br>  Heute werden wir Ihnen sagen, wie der Messenger in der Blockchain angeordnet ist und wie Clientanwendungen mit seiner API arbeiten können. <br><img src="https://habrastorage.org/webt/x9/zr/gs/x9zrgsw1wkkm1856yssejnfg5gs.jpeg"><br><a name="habracut"></a><br>  Wir wollten, dass die Blockchain die Sicherheits- und Datenschutzprobleme klassischer P2P-Messenger löst: <br><br><ul><li>  Ein Klick, um ein Konto zu erstellen - keine Telefone und E-Mails, kein Zugriff auf Adressbücher und Geolokalisierungen. </li><li>  Gesprächspartner stellen niemals direkte Verbindungen her, die gesamte Kommunikation erfolgt über ein verteiltes Knotensystem.  IP-Adressen von Benutzern sind einander nicht zugänglich. </li><li>  Alle Nachrichten sind verschlüsselt. Ende-zu-Ende-Kurve25519xsalsa20poly1305.  Es scheint, dass Sie niemanden überraschen werden, aber wir haben Open Source Code. </li><li>  MITM-Angriff ist ausgeschlossen - jede Nachricht ist eine Transaktion und wird von Ed25519 EdDSA signiert. </li><li>  Die Nachricht fällt in ihren Block.  Die Reihenfolge und der <code>timestamp</code> Blöcke können nicht festgelegt werden, daher die Reihenfolge der Nachrichten. </li><li>  "Das habe ich nicht gesagt" funktioniert nicht mit Nachrichten in der Blockchain. </li><li>  Es gibt keine zentrale Struktur, die die „Authentizität“ einer Nachricht überprüft.  Dies erfolgt durch ein konsensbasiertes verteiltes Knotensystem, das den Benutzern gehört. </li><li>  Unmöglichkeit der Zensur - Konten können nicht gesperrt und Nachrichten gelöscht werden. </li><li>  Die 2FA-Blockchain ist eine Alternative zu der höllischen 2FA per SMS, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel Gesundheit gebrochen</a> hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </li><li>  Die Möglichkeit, alle Ihre Dialoge jederzeit von jedem Gerät abzurufen, ist die Möglichkeit, Dialoge überhaupt nicht lokal zu speichern. </li><li>  Bestätigung der Nachrichtenübermittlung.  Nicht zum Gerät des Benutzers, sondern zum Netzwerk.  In der Tat ist dies eine Bestätigung der Fähigkeit des Empfängers, Ihre Nachricht zu lesen.  Dies ist eine nützliche Funktion zum Senden kritischer Benachrichtigungen. </li></ul><br>  Von den Blockchain-Brötchen gibt es auch eine enge Integration mit den Kryptowährungen Ethereum, Dogecoin, Lisk, Dash, Bitcoin (dies ist noch in Bearbeitung) und die Möglichkeit, Token in Chats zu senden.  Wir haben sogar einen eingebauten Krypto-Austauscher hergestellt. <br><br>  Und dann - wie das alles funktioniert. <br><br><h2>  Nachricht ist eine Transaktion </h2><br>  Jeder ist bereits daran gewöhnt, dass Transaktionen in der Blockchain Token (Münzen) von einem Benutzer auf einen anderen übertragen.  Wie Bitcoin.  Wir haben eine spezielle Art von Transaktion zum Senden von Nachrichten erstellt. <br><br>  Um eine Nachricht im Messenger in der Blockchain zu senden, müssen Sie mehrere Schritte durchlaufen: <br><br><ol><li>  Nachrichtentext verschlüsseln </li><li>  Setzen Sie den Chiffretext in die Transaktion ein </li><li>  Transaktion unterzeichnen </li><li>  Senden Sie eine Transaktion an einen beliebigen Host </li><li>  Ein verteiltes Knotensystem bestimmt die „Zuverlässigkeit“ einer Nachricht </li><li>  Wenn alles in Ordnung ist, wird die Transaktion mit der Nachricht in den nächsten Block aufgenommen. </li><li>  Der Empfänger ruft die Nachrichtentransaktion ab und entschlüsselt sie </li></ol><br>  Die Stufen 1-3 und 7 werden lokal auf dem Client und 5-6 auf den Netzwerkknoten ausgeführt. <br><br><h2>  Nachrichtenverschlüsselung </h2><br>  Die Nachricht wird mit dem privaten Schlüssel des Absenders und dem öffentlichen Schlüssel des Empfängers verschlüsselt.  Wir werden den öffentlichen Schlüssel aus dem Netzwerk nehmen, aber dafür muss das Konto des Empfängers initialisiert werden, dh mindestens eine Transaktion haben.  Sie können die REST-Anfrage <code>GET /api/accounts/getPublicKey?address={ADAMANT address}</code> . Wenn Sie Chats herunterladen, sind die öffentlichen Schlüssel der Gesprächspartner bereits verfügbar. <br><br><img src="https://habrastorage.org/webt/gk/km/ky/gkkmkyvasb6jzq_pgs1zq9w7fi0.png"><br><br>  Der Messenger verschlüsselt Nachrichten mit dem Algorithmus edge25519xsalsa20poly1305 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NaCl Box</a> ).  Da das Konto Ed25519-Schlüssel enthält, müssen die Schlüssel zunächst in Curve25519 Diffie-Hellman konvertiert werden, um eine Box zu bilden. <br><br>  Hier ist ein Beispiel in JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Encodes a text message for sending to ADM * @param {string} msg message to encode * @param {*} recipientPublicKey recipient's public key * @param {*} privateKey our private key * @returns {{message: string, nonce: string}} */</span></span> adamant.encodeMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg, recipientPublicKey, privateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nonce = Buffer.allocUnsafe(<span class="hljs-number"><span class="hljs-number">24</span></span>) sodium.randombytes(nonce) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> recipientPublicKey === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { recipientPublicKey = hexToBytes(recipientPublicKey) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plainText = Buffer.from(msg) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHPublicKey = ed2curve.convertPublicKey(recipientPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHSecretKey = ed2curve.convertSecretKey(privateKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encrypted = nacl.box(plainText, nonce, DHPublicKey, DHSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: bytesToHex(encrypted), <span class="hljs-attr"><span class="hljs-attr">nonce</span></span>: bytesToHex(nonce) } }</code> </pre> <br><h2>  Bildung einer Transaktion mit einer Nachricht </h2><br>  Eine Transaktion hat die folgende allgemeine Struktur: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"15161295239237781653"</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">7585271</span></span>, <span class="hljs-string"><span class="hljs-string">"blockId"</span></span>: <span class="hljs-string"><span class="hljs-string">"16391508373936326027"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"block_timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182260</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182254</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"bd39cc708499ae91b937083463fce5e0668c2b37e78df28f69d132fce51d49ed"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U16023712506749300952"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U17653312780572073341"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"23d27f616e304ef2046a60b762683b8dabebe0d8fc26e5ecdb1d5f3d291dbe21"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">204921300000000</span></span>, <span class="hljs-string"><span class="hljs-string">"fee"</span></span>: <span class="hljs-number"><span class="hljs-number">50000000</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"3c8e551f60fedb81e52835c69e8b158eb1b8b3c89a04d3df5adc0d99017ffbcb06a7b16ad76d519f80df019c930960317a67e8d18ab1e85e575c9470000cf607"</span></span>, <span class="hljs-string"><span class="hljs-string">"signatures"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"confirmations"</span></span>: <span class="hljs-number"><span class="hljs-number">3660548</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: {} }</code> </pre> <br>  Für die Transaktionsnachricht ist das <code>asset</code> das wichtigste - Sie müssen die Nachricht im <code>chat</code> Objekt mit der folgenden Struktur platzieren: <br><br><ul><li>  <code>message</code> - Speichern Sie die verschlüsselte Nachricht </li><li>  <code>own_message</code> - nonce </li><li>  <code>type</code> - Nachrichtentyp </li></ul><br>  Nachrichten werden auch in Typen unterteilt.  Im Wesentlichen gibt der Typparameter an, wie die <code>message</code> zu verstehen ist.  Sie können nur Text oder ein Objekt mit interessanten Interessen senden. So überträgt der Messenger beispielsweise Kryptowährungen in Chatrooms. <br><br>  Als Ergebnis bilden wir die Transaktion: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"transaction"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U12499126640447739963"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"e9cafb1e7b403c4cf247c94f73ee4cada367fcc130cb3888219a0ba0633230b6"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: { <span class="hljs-string"><span class="hljs-string">"chat"</span></span>: { <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"cb682accceef92d7cddaaddb787d1184ab5428"</span></span>, <span class="hljs-string"><span class="hljs-string">"own_message"</span></span>: <span class="hljs-string"><span class="hljs-string">"e7d8f90ddf7d70efe359c3e4ecfb5ed3802297b248eacbd6"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U15677078342684640219"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228087</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } }</code> </pre> <br><h2>  Transaktionssignatur </h2><br>  Damit jeder sicher sein kann, dass der Absender und der Empfänger zum Zeitpunkt des Sendens und des Inhalts der Nachricht authentisch sind, wird die Transaktion signiert.  Mit einer digitalen Signatur können Sie die Authentizität einer Transaktion mithilfe eines öffentlichen Schlüssels überprüfen. Ein privater Schlüssel wird hierfür nicht benötigt. <br><br>  Die Signatur selbst wird jedoch nur vom privaten Schlüssel ausgeführt: <br><br><img src="https://habrastorage.org/webt/y_/bk/6k/y_bk6k_7ayzma1-ndyhur2xcaok.png"><br><br>  Aus dem Diagramm ist ersichtlich, dass wir zuerst die Transaktion mit SHA-256 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hashen, dann Ed25519 EdDSA signieren</a> und die Signatursignatur erhalten und die Transaktionskennung Teil des SHA-256-Hash ist. <br><br><h3>  Implementierungsbeispiel: </h3><br>  1 - Wir bilden einen Datenblock mit einer Nachricht <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Calls `getBytes` based on transaction type * @see privateTypes * @implements {ByteBuffer} * @param {transaction} trs * @param {boolean} skipSignature * @param {boolean} skipSecondSignature * @return {!Array} Contents as an ArrayBuffer. * @throws {error} If buffer fails. */</span></span> adamant.getBytes = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transaction</span></span></span><span class="hljs-function">) </span></span>{ ... switch (transaction.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.SEND: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.CHAT_MESSAGE: assetBytes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chatGetBytes(transaction) assetSize = assetBytes.length <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: alert(<span class="hljs-string"><span class="hljs-string">'Not supported yet'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuffer(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">32</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + assetSize, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) bb.writeByte(transaction.type) bb.writeInt(transaction.timestamp) ... bb.flip() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(bb.toArrayBuffer()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arrayBuffer.length; i++) { buffer[i] = arrayBuffer[i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer.from(buffer) }</code> </pre><br>  2 - Wir betrachten SHA-256 aus dem Datenblock <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Creates hash based on transaction bytes. * @implements {getBytes} * @implements {crypto.createHash} * @param {transaction} trs * @return {hash} sha256 crypto hash */</span></span> adamant.getHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBytes(trs)).digest() }</code> </pre> <br>  3 - Wir unterschreiben die Transaktion <br><br><pre> <code class="javascript hljs">adamant.transactionSign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHash(trs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sign(hash, keypair).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * Creates a signature based on a hash and a keypair. * @implements {sodium} * @param {hash} hash * @param {keypair} keypair * @return {signature} signature */</span></span> adamant.sign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sodium.crypto_sign_detached(hash, Buffer.from(keypair.privateKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>)) }</code> </pre> <br><h2>  Senden einer Transaktion mit einer Nachricht an einen Host </h2><br>  Da das Netzwerk dezentralisiert ist, reicht jeder Knoten mit einer offenen API aus.  Wir stellen eine POST-Anfrage für den Endpunkt <code>api/transactions</code> : <br><br><pre> <code class="javascript hljs">curl <span class="hljs-string"><span class="hljs-string">'api/transactions'</span></span> -X POST \ -d <span class="hljs-string"><span class="hljs-string">'TX_DATA'</span></span></code> </pre> <br>  Als Antwort erhalten wir eine Transaktions-ID vom Typ <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"success"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"nodeTimestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228852</span></span>, <span class="hljs-string"><span class="hljs-string">"transactionId"</span></span>: <span class="hljs-string"><span class="hljs-string">"6146865104403680934"</span></span> }</code> </pre> <br><h2>  Transaktionsvalidierung </h2><br>  Ein verteiltes konsensbasiertes Knotensystem bestimmt die „Zuverlässigkeit“ einer Nachrichtentransaktion.  Von wem und an wen, wann, ob die Nachricht durch eine andere ersetzt wurde und ob der Zeitpunkt des Sendens korrekt angegeben wurde.  Dies ist ein sehr wichtiger Vorteil der Blockchain - es gibt keine zentrale Struktur, die für Überprüfungen verantwortlich ist, und die Reihenfolge der Nachrichten und deren Inhalt kann nicht gefälscht werden. <br><br>  Zuerst überprüft ein Knoten die Zuverlässigkeit und sendet sie dann an andere. Wenn die meisten sagen, dass alles in Ordnung ist, wird die Transaktion in den nächsten Block der Kette aufgenommen. Dies ist ein Konsens. <br><br><img src="https://habrastorage.org/webt/4h/qe/to/4hqetosedsbnm1qnu-pir3jjj4k.gif"><br><br>  Der Teil des Host-Codes, der für die Validierung verantwortlich ist, kann auf GitHub - <a href="">validator.js</a> und <a href="">verify.js angezeigt werden</a> .  Ja, der Knoten läuft auf Node.js. <br><br><h2>  Transaktion mit Nachricht in Block einschließen </h2><br>  Wenn ein Konsens erzielt wird, fällt die Transaktion mit unserer Nachricht zusammen mit anderen zuverlässigen Transaktionen in den nächsten Block. <br><br>  Blöcke haben eine strenge Reihenfolge, und jeder nachfolgende Block wird auf der Basis von Hashes vorheriger Blöcke gebildet. <br><br><img src="https://habrastorage.org/webt/es/cf/kt/escfktkasqdtkv2hxs5me6urmmm.png"><br><br>  Das Fazit ist, dass unsere Nachricht auch in dieser Sequenz enthalten ist und nicht „neu angeordnet“ werden kann.  Wenn mehrere Nachrichten in den Block fallen, wird ihre Reihenfolge durch den <code>timestamp</code> Nachrichten bestimmt. <br><br><h2>  Nachrichten lesen </h2><br>  Die Messenger-Anwendung ruft Transaktionen aus der Blockchain ab, die an den Adressaten gesendet werden.  Zu diesem <code>api/chatrooms</code> wir den Endpunkt für <code>api/chatrooms</code> . <br><br>  Alle Transaktionen stehen allen zur Verfügung - Sie können verschlüsselte Nachrichten empfangen.  Aber nur der Empfänger kann mit seinem privaten Schlüssel und dem öffentlichen Schlüssel des Absenders entschlüsseln: <br><br><pre> <code class="javascript hljs">** * Decodes the incoming message * @param {any} msg encoded message * @param {string} senderPublicKey sender public key * @param {string} privateKey our private key * @param {any} nonce nonce * @returns {string} *<span class="hljs-regexp"><span class="hljs-regexp">/ adamant.decodeMessage = function (msg, senderPublicKey, privateKey, nonce) { if (typeof msg === 'string') { msg = hexToBytes(msg) } if (typeof nonce === 'string') { nonce = hexToBytes(nonce) } if (typeof senderPublicKey === 'string') { senderPublicKey = hexToBytes(senderPublicKey) } if (typeof privateKey === 'string') { privateKey = hexToBytes(privateKey) } const DHPublicKey = ed2curve.convertPublicKey(senderPublicKey) const DHSecretKey = ed2curve.convertSecretKey(privateKey) const decrypted = nacl.box.open(msg, nonce, DHPublicKey, DHSecretKey) return decrypted ? decode(decrypted) : '' }</span></span></code> </pre> <br><h2>  Und was noch? </h2><br>  Da Nachrichten auf diese Weise etwa 5 Sekunden lang zugestellt werden - dies ist die Zeit, in der ein neuer Netzwerkblock angezeigt wurde -, haben wir einen Socket-Verbindungs-Client-Knoten und einen Knoten-zu-Knoten entwickelt.  Wenn ein Knoten eine neue Transaktion empfängt, überprüft er deren Gültigkeit und überträgt sie an andere Knoten.  Die Transaktion steht Messenger-Clients bereits vor dem Einsetzen des Konsenses und der Aufnahme in den Block zur Verfügung.  So werden wir sofort Nachrichten übermitteln, ebenso wie die üblichen Boten. <br><br>  Um das Adressbuch zu speichern, haben wir KVS - Key-Value Storage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellt</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies</a> ist eine andere Art von Transaktion, bei der ein <code>asset</code> nicht mit NaCl-Box, sondern mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NaCl-Secretbox verschlüsselt wird</a> .  Der Messenger speichert also andere Daten. <br><br>  Datei- / Bildübertragung und Gruppenchats erfordern noch viel Arbeit.  Natürlich kann dies im Tyap-Bloop-Format schnell behoben werden, aber wir möchten das gleiche Maß an Privatsphäre gewährleisten. <br><br>  Ja, es gibt noch viel zu tun - im Idealfall bedeutet echte Privatsphäre, dass Benutzer keine Verbindung zu öffentlichen Netzwerkknoten herstellen, sondern ihre eigenen erhöhen.  Was denkst du, wie viele Prozent der Nutzer machen das?  Das ist richtig, 0. Teilweise ist es uns gelungen, dieses Problem mit der Tor-Version des Messenger zu lösen. <br><br>  Wir haben bewiesen, dass ein Messenger in der Blockchain existieren kann.  Zuvor gab es 2012 nur einen Versuch - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitmessage</a> , der aufgrund der langen Nachrichtenübermittlungszeit, der CPU-Auslastung und des Mangels an mobilen Anwendungen fehlschlug. <br><br>  Und Skepsis hängt damit zusammen, dass Boten in der Blockchain der Zeit voraus sind - die Menschen sind nicht bereit, Verantwortung für ihr Konto selbst zu übernehmen, der Besitz persönlicher Informationen ist noch kein Trend, und die Technologie erlaubt es nicht, hohe Geschwindigkeiten in der Blockchain sicherzustellen.  Im Folgenden werden weitere technologische Analoga unseres Projekts aufgeführt.  Du wirst sehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467751/">https://habr.com/ru/post/de467751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467741/index.html">Einführung in deterministische Assemblys in C / C ++. Teil 1</a></li>
<li><a href="../de467743/index.html">SamsPcbGuide, Teil 11: Technologie - BGA-Gehäuse, Kunststoff und Raum</a></li>
<li><a href="../de467745/index.html">Cluster besser als die "Ellbogenmethode"</a></li>
<li><a href="../de467747/index.html">Psychologische Tests: Wie man von einem zertifizierten Psychologen zu einem Tester kommt</a></li>
<li><a href="../de467749/index.html">GCP: Analysieren des Google Cloud Platform Computing Stack</a></li>
<li><a href="../de467753/index.html">Weltrekord für drahtlose Datenübertragung: 40 Gbit / s pro 11 Kilometer</a></li>
<li><a href="../de467755/index.html">Prionen, Kalzium, Mikrobiota, Nahrungshormone und Alzheimer</a></li>
<li><a href="../de467759/index.html">Unix-ähnliches Betriebssystemdesign - Virtueller Adressraum (6)</a></li>
<li><a href="../de467761/index.html">Energie, Wärme und Wasser Teil drei: Gehen Sie zum Radio</a></li>
<li><a href="../de467763/index.html">Die ganze Wahrheit über RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>