<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèº üéå üõÄüèº Wie funktioniert ein dezentraler Messenger in der Blockchain? ‚òîÔ∏è üë©üèø‚Äçüåæ üï¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang 2017 haben wir begonnen, einen Messenger in der Blockchain zu erstellen [Name und Link befinden sich im Profil], indem wir die Vorteile gegen√ºb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert ein dezentraler Messenger in der Blockchain?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467751/"> Anfang 2017 haben wir begonnen, einen Messenger in der Blockchain zu erstellen [Name und Link befinden sich im Profil], indem wir die Vorteile gegen√ºber klassischen P2P-Messenger er√∂rtert haben. <br><br>  <code>2.5</code> Jahre vergingen und wir konnten unser Konzept best√§tigen: Instant Messenger-Anwendungen f√ºr iOS, Web PWA, Windows, GNU / Linux, Mac OS und Android sind jetzt verf√ºgbar. <br><br>  Heute werden wir Ihnen sagen, wie der Messenger in der Blockchain angeordnet ist und wie Clientanwendungen mit seiner API arbeiten k√∂nnen. <br><img src="https://habrastorage.org/webt/x9/zr/gs/x9zrgsw1wkkm1856yssejnfg5gs.jpeg"><br><a name="habracut"></a><br>  Wir wollten, dass die Blockchain die Sicherheits- und Datenschutzprobleme klassischer P2P-Messenger l√∂st: <br><br><ul><li>  Ein Klick, um ein Konto zu erstellen - keine Telefone und E-Mails, kein Zugriff auf Adressb√ºcher und Geolokalisierungen. </li><li>  Gespr√§chspartner stellen niemals direkte Verbindungen her, die gesamte Kommunikation erfolgt √ºber ein verteiltes Knotensystem.  IP-Adressen von Benutzern sind einander nicht zug√§nglich. </li><li>  Alle Nachrichten sind verschl√ºsselt. Ende-zu-Ende-Kurve25519xsalsa20poly1305.  Es scheint, dass Sie niemanden √ºberraschen werden, aber wir haben Open Source Code. </li><li>  MITM-Angriff ist ausgeschlossen - jede Nachricht ist eine Transaktion und wird von Ed25519 EdDSA signiert. </li><li>  Die Nachricht f√§llt in ihren Block.  Die Reihenfolge und der <code>timestamp</code> Bl√∂cke k√∂nnen nicht festgelegt werden, daher die Reihenfolge der Nachrichten. </li><li>  "Das habe ich nicht gesagt" funktioniert nicht mit Nachrichten in der Blockchain. </li><li>  Es gibt keine zentrale Struktur, die die ‚ÄûAuthentizit√§t‚Äú einer Nachricht √ºberpr√ºft.  Dies erfolgt durch ein konsensbasiertes verteiltes Knotensystem, das den Benutzern geh√∂rt. </li><li>  Unm√∂glichkeit der Zensur - Konten k√∂nnen nicht gesperrt und Nachrichten gel√∂scht werden. </li><li>  Die 2FA-Blockchain ist eine Alternative zu der h√∂llischen 2FA per SMS, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel Gesundheit gebrochen</a> hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </li><li>  Die M√∂glichkeit, alle Ihre Dialoge jederzeit von jedem Ger√§t abzurufen, ist die M√∂glichkeit, Dialoge √ºberhaupt nicht lokal zu speichern. </li><li>  Best√§tigung der Nachrichten√ºbermittlung.  Nicht zum Ger√§t des Benutzers, sondern zum Netzwerk.  In der Tat ist dies eine Best√§tigung der F√§higkeit des Empf√§ngers, Ihre Nachricht zu lesen.  Dies ist eine n√ºtzliche Funktion zum Senden kritischer Benachrichtigungen. </li></ul><br>  Von den Blockchain-Br√∂tchen gibt es auch eine enge Integration mit den Kryptow√§hrungen Ethereum, Dogecoin, Lisk, Dash, Bitcoin (dies ist noch in Bearbeitung) und die M√∂glichkeit, Token in Chats zu senden.  Wir haben sogar einen eingebauten Krypto-Austauscher hergestellt. <br><br>  Und dann - wie das alles funktioniert. <br><br><h2>  Nachricht ist eine Transaktion </h2><br>  Jeder ist bereits daran gew√∂hnt, dass Transaktionen in der Blockchain Token (M√ºnzen) von einem Benutzer auf einen anderen √ºbertragen.  Wie Bitcoin.  Wir haben eine spezielle Art von Transaktion zum Senden von Nachrichten erstellt. <br><br>  Um eine Nachricht im Messenger in der Blockchain zu senden, m√ºssen Sie mehrere Schritte durchlaufen: <br><br><ol><li>  Nachrichtentext verschl√ºsseln </li><li>  Setzen Sie den Chiffretext in die Transaktion ein </li><li>  Transaktion unterzeichnen </li><li>  Senden Sie eine Transaktion an einen beliebigen Host </li><li>  Ein verteiltes Knotensystem bestimmt die ‚ÄûZuverl√§ssigkeit‚Äú einer Nachricht </li><li>  Wenn alles in Ordnung ist, wird die Transaktion mit der Nachricht in den n√§chsten Block aufgenommen. </li><li>  Der Empf√§nger ruft die Nachrichtentransaktion ab und entschl√ºsselt sie </li></ol><br>  Die Stufen 1-3 und 7 werden lokal auf dem Client und 5-6 auf den Netzwerkknoten ausgef√ºhrt. <br><br><h2>  Nachrichtenverschl√ºsselung </h2><br>  Die Nachricht wird mit dem privaten Schl√ºssel des Absenders und dem √∂ffentlichen Schl√ºssel des Empf√§ngers verschl√ºsselt.  Wir werden den √∂ffentlichen Schl√ºssel aus dem Netzwerk nehmen, aber daf√ºr muss das Konto des Empf√§ngers initialisiert werden, dh mindestens eine Transaktion haben.  Sie k√∂nnen die REST-Anfrage <code>GET /api/accounts/getPublicKey?address={ADAMANT address}</code> . Wenn Sie Chats herunterladen, sind die √∂ffentlichen Schl√ºssel der Gespr√§chspartner bereits verf√ºgbar. <br><br><img src="https://habrastorage.org/webt/gk/km/ky/gkkmkyvasb6jzq_pgs1zq9w7fi0.png"><br><br>  Der Messenger verschl√ºsselt Nachrichten mit dem Algorithmus edge25519xsalsa20poly1305 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NaCl Box</a> ).  Da das Konto Ed25519-Schl√ºssel enth√§lt, m√ºssen die Schl√ºssel zun√§chst in Curve25519 Diffie-Hellman konvertiert werden, um eine Box zu bilden. <br><br>  Hier ist ein Beispiel in JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Encodes a text message for sending to ADM * @param {string} msg message to encode * @param {*} recipientPublicKey recipient's public key * @param {*} privateKey our private key * @returns {{message: string, nonce: string}} */</span></span> adamant.encodeMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg, recipientPublicKey, privateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nonce = Buffer.allocUnsafe(<span class="hljs-number"><span class="hljs-number">24</span></span>) sodium.randombytes(nonce) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> recipientPublicKey === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { recipientPublicKey = hexToBytes(recipientPublicKey) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plainText = Buffer.from(msg) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHPublicKey = ed2curve.convertPublicKey(recipientPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHSecretKey = ed2curve.convertSecretKey(privateKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encrypted = nacl.box(plainText, nonce, DHPublicKey, DHSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: bytesToHex(encrypted), <span class="hljs-attr"><span class="hljs-attr">nonce</span></span>: bytesToHex(nonce) } }</code> </pre> <br><h2>  Bildung einer Transaktion mit einer Nachricht </h2><br>  Eine Transaktion hat die folgende allgemeine Struktur: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"15161295239237781653"</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">7585271</span></span>, <span class="hljs-string"><span class="hljs-string">"blockId"</span></span>: <span class="hljs-string"><span class="hljs-string">"16391508373936326027"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"block_timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182260</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182254</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"bd39cc708499ae91b937083463fce5e0668c2b37e78df28f69d132fce51d49ed"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U16023712506749300952"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U17653312780572073341"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"23d27f616e304ef2046a60b762683b8dabebe0d8fc26e5ecdb1d5f3d291dbe21"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">204921300000000</span></span>, <span class="hljs-string"><span class="hljs-string">"fee"</span></span>: <span class="hljs-number"><span class="hljs-number">50000000</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"3c8e551f60fedb81e52835c69e8b158eb1b8b3c89a04d3df5adc0d99017ffbcb06a7b16ad76d519f80df019c930960317a67e8d18ab1e85e575c9470000cf607"</span></span>, <span class="hljs-string"><span class="hljs-string">"signatures"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"confirmations"</span></span>: <span class="hljs-number"><span class="hljs-number">3660548</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: {} }</code> </pre> <br>  F√ºr die Transaktionsnachricht ist das <code>asset</code> das wichtigste - Sie m√ºssen die Nachricht im <code>chat</code> Objekt mit der folgenden Struktur platzieren: <br><br><ul><li>  <code>message</code> - Speichern Sie die verschl√ºsselte Nachricht </li><li>  <code>own_message</code> - nonce </li><li>  <code>type</code> - Nachrichtentyp </li></ul><br>  Nachrichten werden auch in Typen unterteilt.  Im Wesentlichen gibt der Typparameter an, wie die <code>message</code> zu verstehen ist.  Sie k√∂nnen nur Text oder ein Objekt mit interessanten Interessen senden. So √ºbertr√§gt der Messenger beispielsweise Kryptow√§hrungen in Chatrooms. <br><br>  Als Ergebnis bilden wir die Transaktion: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"transaction"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U12499126640447739963"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"e9cafb1e7b403c4cf247c94f73ee4cada367fcc130cb3888219a0ba0633230b6"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: { <span class="hljs-string"><span class="hljs-string">"chat"</span></span>: { <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"cb682accceef92d7cddaaddb787d1184ab5428"</span></span>, <span class="hljs-string"><span class="hljs-string">"own_message"</span></span>: <span class="hljs-string"><span class="hljs-string">"e7d8f90ddf7d70efe359c3e4ecfb5ed3802297b248eacbd6"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U15677078342684640219"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228087</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } }</code> </pre> <br><h2>  Transaktionssignatur </h2><br>  Damit jeder sicher sein kann, dass der Absender und der Empf√§nger zum Zeitpunkt des Sendens und des Inhalts der Nachricht authentisch sind, wird die Transaktion signiert.  Mit einer digitalen Signatur k√∂nnen Sie die Authentizit√§t einer Transaktion mithilfe eines √∂ffentlichen Schl√ºssels √ºberpr√ºfen. Ein privater Schl√ºssel wird hierf√ºr nicht ben√∂tigt. <br><br>  Die Signatur selbst wird jedoch nur vom privaten Schl√ºssel ausgef√ºhrt: <br><br><img src="https://habrastorage.org/webt/y_/bk/6k/y_bk6k_7ayzma1-ndyhur2xcaok.png"><br><br>  Aus dem Diagramm ist ersichtlich, dass wir zuerst die Transaktion mit SHA-256 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hashen, dann Ed25519 EdDSA signieren</a> und die Signatursignatur erhalten und die Transaktionskennung Teil des SHA-256-Hash ist. <br><br><h3>  Implementierungsbeispiel: </h3><br>  1 - Wir bilden einen Datenblock mit einer Nachricht <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Calls `getBytes` based on transaction type * @see privateTypes * @implements {ByteBuffer} * @param {transaction} trs * @param {boolean} skipSignature * @param {boolean} skipSecondSignature * @return {!Array} Contents as an ArrayBuffer. * @throws {error} If buffer fails. */</span></span> adamant.getBytes = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transaction</span></span></span><span class="hljs-function">) </span></span>{ ... switch (transaction.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.SEND: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.CHAT_MESSAGE: assetBytes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chatGetBytes(transaction) assetSize = assetBytes.length <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: alert(<span class="hljs-string"><span class="hljs-string">'Not supported yet'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuffer(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">32</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + assetSize, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) bb.writeByte(transaction.type) bb.writeInt(transaction.timestamp) ... bb.flip() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(bb.toArrayBuffer()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arrayBuffer.length; i++) { buffer[i] = arrayBuffer[i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer.from(buffer) }</code> </pre><br>  2 - Wir betrachten SHA-256 aus dem Datenblock <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Creates hash based on transaction bytes. * @implements {getBytes} * @implements {crypto.createHash} * @param {transaction} trs * @return {hash} sha256 crypto hash */</span></span> adamant.getHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBytes(trs)).digest() }</code> </pre> <br>  3 - Wir unterschreiben die Transaktion <br><br><pre> <code class="javascript hljs">adamant.transactionSign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHash(trs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sign(hash, keypair).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * Creates a signature based on a hash and a keypair. * @implements {sodium} * @param {hash} hash * @param {keypair} keypair * @return {signature} signature */</span></span> adamant.sign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sodium.crypto_sign_detached(hash, Buffer.from(keypair.privateKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>)) }</code> </pre> <br><h2>  Senden einer Transaktion mit einer Nachricht an einen Host </h2><br>  Da das Netzwerk dezentralisiert ist, reicht jeder Knoten mit einer offenen API aus.  Wir stellen eine POST-Anfrage f√ºr den Endpunkt <code>api/transactions</code> : <br><br><pre> <code class="javascript hljs">curl <span class="hljs-string"><span class="hljs-string">'api/transactions'</span></span> -X POST \ -d <span class="hljs-string"><span class="hljs-string">'TX_DATA'</span></span></code> </pre> <br>  Als Antwort erhalten wir eine Transaktions-ID vom Typ <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"success"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"nodeTimestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228852</span></span>, <span class="hljs-string"><span class="hljs-string">"transactionId"</span></span>: <span class="hljs-string"><span class="hljs-string">"6146865104403680934"</span></span> }</code> </pre> <br><h2>  Transaktionsvalidierung </h2><br>  Ein verteiltes konsensbasiertes Knotensystem bestimmt die ‚ÄûZuverl√§ssigkeit‚Äú einer Nachrichtentransaktion.  Von wem und an wen, wann, ob die Nachricht durch eine andere ersetzt wurde und ob der Zeitpunkt des Sendens korrekt angegeben wurde.  Dies ist ein sehr wichtiger Vorteil der Blockchain - es gibt keine zentrale Struktur, die f√ºr √úberpr√ºfungen verantwortlich ist, und die Reihenfolge der Nachrichten und deren Inhalt kann nicht gef√§lscht werden. <br><br>  Zuerst √ºberpr√ºft ein Knoten die Zuverl√§ssigkeit und sendet sie dann an andere. Wenn die meisten sagen, dass alles in Ordnung ist, wird die Transaktion in den n√§chsten Block der Kette aufgenommen. Dies ist ein Konsens. <br><br><img src="https://habrastorage.org/webt/4h/qe/to/4hqetosedsbnm1qnu-pir3jjj4k.gif"><br><br>  Der Teil des Host-Codes, der f√ºr die Validierung verantwortlich ist, kann auf GitHub - <a href="">validator.js</a> und <a href="">verify.js angezeigt werden</a> .  Ja, der Knoten l√§uft auf Node.js. <br><br><h2>  Transaktion mit Nachricht in Block einschlie√üen </h2><br>  Wenn ein Konsens erzielt wird, f√§llt die Transaktion mit unserer Nachricht zusammen mit anderen zuverl√§ssigen Transaktionen in den n√§chsten Block. <br><br>  Bl√∂cke haben eine strenge Reihenfolge, und jeder nachfolgende Block wird auf der Basis von Hashes vorheriger Bl√∂cke gebildet. <br><br><img src="https://habrastorage.org/webt/es/cf/kt/escfktkasqdtkv2hxs5me6urmmm.png"><br><br>  Das Fazit ist, dass unsere Nachricht auch in dieser Sequenz enthalten ist und nicht ‚Äûneu angeordnet‚Äú werden kann.  Wenn mehrere Nachrichten in den Block fallen, wird ihre Reihenfolge durch den <code>timestamp</code> Nachrichten bestimmt. <br><br><h2>  Nachrichten lesen </h2><br>  Die Messenger-Anwendung ruft Transaktionen aus der Blockchain ab, die an den Adressaten gesendet werden.  Zu diesem <code>api/chatrooms</code> wir den Endpunkt f√ºr <code>api/chatrooms</code> . <br><br>  Alle Transaktionen stehen allen zur Verf√ºgung - Sie k√∂nnen verschl√ºsselte Nachrichten empfangen.  Aber nur der Empf√§nger kann mit seinem privaten Schl√ºssel und dem √∂ffentlichen Schl√ºssel des Absenders entschl√ºsseln: <br><br><pre> <code class="javascript hljs">** * Decodes the incoming message * @param {any} msg encoded message * @param {string} senderPublicKey sender public key * @param {string} privateKey our private key * @param {any} nonce nonce * @returns {string} *<span class="hljs-regexp"><span class="hljs-regexp">/ adamant.decodeMessage = function (msg, senderPublicKey, privateKey, nonce) { if (typeof msg === 'string') { msg = hexToBytes(msg) } if (typeof nonce === 'string') { nonce = hexToBytes(nonce) } if (typeof senderPublicKey === 'string') { senderPublicKey = hexToBytes(senderPublicKey) } if (typeof privateKey === 'string') { privateKey = hexToBytes(privateKey) } const DHPublicKey = ed2curve.convertPublicKey(senderPublicKey) const DHSecretKey = ed2curve.convertSecretKey(privateKey) const decrypted = nacl.box.open(msg, nonce, DHPublicKey, DHSecretKey) return decrypted ? decode(decrypted) : '' }</span></span></code> </pre> <br><h2>  Und was noch? </h2><br>  Da Nachrichten auf diese Weise etwa 5 Sekunden lang zugestellt werden - dies ist die Zeit, in der ein neuer Netzwerkblock angezeigt wurde -, haben wir einen Socket-Verbindungs-Client-Knoten und einen Knoten-zu-Knoten entwickelt.  Wenn ein Knoten eine neue Transaktion empf√§ngt, √ºberpr√ºft er deren G√ºltigkeit und √ºbertr√§gt sie an andere Knoten.  Die Transaktion steht Messenger-Clients bereits vor dem Einsetzen des Konsenses und der Aufnahme in den Block zur Verf√ºgung.  So werden wir sofort Nachrichten √ºbermitteln, ebenso wie die √ºblichen Boten. <br><br>  Um das Adressbuch zu speichern, haben wir KVS - Key-Value Storage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellt</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies</a> ist eine andere Art von Transaktion, bei der ein <code>asset</code> nicht mit NaCl-Box, sondern mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NaCl-Secretbox verschl√ºsselt wird</a> .  Der Messenger speichert also andere Daten. <br><br>  Datei- / Bild√ºbertragung und Gruppenchats erfordern noch viel Arbeit.  Nat√ºrlich kann dies im Tyap-Bloop-Format schnell behoben werden, aber wir m√∂chten das gleiche Ma√ü an Privatsph√§re gew√§hrleisten. <br><br>  Ja, es gibt noch viel zu tun - im Idealfall bedeutet echte Privatsph√§re, dass Benutzer keine Verbindung zu √∂ffentlichen Netzwerkknoten herstellen, sondern ihre eigenen erh√∂hen.  Was denkst du, wie viele Prozent der Nutzer machen das?  Das ist richtig, 0. Teilweise ist es uns gelungen, dieses Problem mit der Tor-Version des Messenger zu l√∂sen. <br><br>  Wir haben bewiesen, dass ein Messenger in der Blockchain existieren kann.  Zuvor gab es 2012 nur einen Versuch - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitmessage</a> , der aufgrund der langen Nachrichten√ºbermittlungszeit, der CPU-Auslastung und des Mangels an mobilen Anwendungen fehlschlug. <br><br>  Und Skepsis h√§ngt damit zusammen, dass Boten in der Blockchain der Zeit voraus sind - die Menschen sind nicht bereit, Verantwortung f√ºr ihr Konto selbst zu √ºbernehmen, der Besitz pers√∂nlicher Informationen ist noch kein Trend, und die Technologie erlaubt es nicht, hohe Geschwindigkeiten in der Blockchain sicherzustellen.  Im Folgenden werden weitere technologische Analoga unseres Projekts aufgef√ºhrt.  Du wirst sehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467751/">https://habr.com/ru/post/de467751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467741/index.html">Einf√ºhrung in deterministische Assemblys in C / C ++. Teil 1</a></li>
<li><a href="../de467743/index.html">SamsPcbGuide, Teil 11: Technologie - BGA-Geh√§use, Kunststoff und Raum</a></li>
<li><a href="../de467745/index.html">Cluster besser als die "Ellbogenmethode"</a></li>
<li><a href="../de467747/index.html">Psychologische Tests: Wie man von einem zertifizierten Psychologen zu einem Tester kommt</a></li>
<li><a href="../de467749/index.html">GCP: Analysieren des Google Cloud Platform Computing Stack</a></li>
<li><a href="../de467753/index.html">Weltrekord f√ºr drahtlose Daten√ºbertragung: 40 Gbit / s pro 11 Kilometer</a></li>
<li><a href="../de467755/index.html">Prionen, Kalzium, Mikrobiota, Nahrungshormone und Alzheimer</a></li>
<li><a href="../de467759/index.html">Unix-√§hnliches Betriebssystemdesign - Virtueller Adressraum (6)</a></li>
<li><a href="../de467761/index.html">Energie, W√§rme und Wasser Teil drei: Gehen Sie zum Radio</a></li>
<li><a href="../de467763/index.html">Die ganze Wahrheit √ºber RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>