<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∏ üîÇ üñåÔ∏è Die ganze Wahrheit √ºber RTOS. Artikel 24. Warteschlangen: Nebendienstleistungen und Datenstrukturen üîΩ üíÉ ü§üüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir weiterhin Warteschlangen ber√ºcksichtigen. 

 Sekund√§re Warteschlangendienste 
 Nucleus RTOS verf√ºgt √ºber vier API-Aufrufe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 24. Warteschlangen: Nebendienstleistungen und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  In diesem Artikel werden wir weiterhin Warteschlangen ber√ºcksichtigen. <br><br><h2>  Sekund√§re Warteschlangendienste </h2><br>  Nucleus RTOS verf√ºgt √ºber vier API-Aufrufe, die Zusatzfunktionen f√ºr Warteschlangen bereitstellen: Zur√ºcksetzen einer Warteschlange, Empfangen von Warteschlangeninformationen, Abrufen der Anzahl der Warteschlangen in einer Anwendung und Abrufen von Zeigern auf alle Warteschlangen in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br><br><h3>  Zur√ºcksetzen der Warteschlange </h3><br>  Dieser API-Aufruf setzt die Warteschlange auf ihren urspr√ºnglichen, nicht verwendeten Status zur√ºck.  Alle Nachrichten, die in der Warteschlange gespeichert sind, gehen verloren.  Alle in der Warteschlange angehaltenen Aufgaben werden mit dem R√ºckkehrcode <b>NUSE_QUEUE_WAS_RESET fortgesetzt</b> . <br><br>  <b><i>Warteschlangen-Reset-Aufruf in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Reset_Queue (NU_QUEUE * Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Ein Zeiger auf einen vom Benutzer bereitgestellten Warteschlangensteuerblock. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger. <br><br>  <b><i>Anruf zum Zur√ºcksetzen der Warteschlange in Nucleus SE</i></b> <br>  Dieser Dienstprogrammaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Queue_Reset (NUSE_QUEUE-Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Index (ID) der abgelegten Warteschlange. <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenindex. <br><br>  <b><i>Implementieren des Zur√ºcksetzens der Warteschlange in Nucleus SE</i></b> <br>  Der Code der Funktion <b>NUSE_Queue_Reset</b> (nach √úberpr√ºfung der Parameter) ist recht einfach.  Indizes des Kopfes und Endes der Warteschlange sowie des Nachrichtenz√§hlers in der Warteschlange wird ein Nullwert zugewiesen. <br><br>  Wenn die Task-Sperre aktiviert ist, ist zus√§tzlicher Code f√ºr die Wiederherstellung angehaltener Tasks verantwortlich: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Jeder angehaltenen Aufgabe in der Warteschlange wird der Status "Bereit" mit dem R√ºckkehrcode <b>NUSE_QUEUE_WAS_RESET zugewiesen</b> .  Nach Abschluss dieses Vorgangs wird bei Verwendung des Priorit√§tsplaners die Funktion <b>NUSE_Reschedule () aufgerufen</b> , da m√∂glicherweise eine oder mehrere Aufgaben mit hoher Priorit√§t zur Ausf√ºhrung bereit sind. <br><br><h3>  Abrufen von Warteschlangeninformationen </h3><br>  Dieser Serviceabruf enth√§lt Informationen zur Warteschlange.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zur√ºckgegeben werden, da die Objektbenennung, die variable Nachrichtenl√§nge und die Reihenfolge der Aufgabenpausen nicht unterst√ºtzt werden und das Sperren von Aufgaben deaktiviert werden kann. <br><br>  <b><i>Aufruf f√ºr Warteschlangeninformationen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Queue_Information (NU_QUEUE * Warteschlange, CHAR * Name, VOID ** Startadresse, UNSIGNED * Warteschlangengr√∂√üe, UNSIGNED * verf√ºgbar, UNSIGNED * Nachrichten, OPTION * Nachrichtentyp, UNSIGNED * Nachrichtengr√∂√üe, OPTION * Suspend_Typ, UNSIGNt_t_</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich f√ºr den Namen der Nachricht in der Warteschlange; <br>  <b>start_address</b> - ein Zeiger auf einen Zeiger, in den die Adresse des Anfangs des Warteschlangendatenbereichs geschrieben wird; <br>  <b>queue_size</b> - ein Zeiger auf eine Variable zum Speichern der Gesamtzahl der <b>UNSIGNED-</b> Elemente in der Warteschlange; <br>  <b>verf√ºgbar</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl verf√ºgbarer <b>UNSIGNED-</b> Elemente in der Warteschlange; <br>  Nachrichten - ein Zeiger auf eine Variable zum Speichern der aktuellen Anzahl von Nachrichten in der Warteschlange; <br>  <b>message_type</b> - Ein Zeiger auf eine Variable zum Speichern des von der Warteschlange unterst√ºtzten Nachrichtentyps.  G√ºltige Werte sind <b>NU_FIXED_SIZE</b> und <b>NU_VARIABLE</b> . <br>  <b>message_size</b> - Ein Zeiger auf eine Variable zum Speichern der Anzahl der <b>UNSIGNED-</b> Datenelemente in jeder Nachricht der Warteschlange.  Wenn die Warteschlange Nachrichten mit variabler L√§nge unterst√ºtzt, gibt diese Nummer die maximale Nachrichtenl√§nge an. <br>  <b>suspend_type</b> - Ein Zeiger auf eine Variable zum Speichern der Art der <b>Unterbrechung</b> von Aufgaben.  G√ºltige Werte sind <b>NU_FIFO</b> und <b>NU_PRIORITY</b> . <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der in dieser Warteschlange angehaltenen Aufgaben; <br>  <b>first_task</b> - Zeiger auf den Aufgabenzeiger, in dem der Zeiger der ersten angehaltenen Aufgabe platziert ist. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger. <br><br>  <b><i>Informationen zur Warteschlange in Nucleus SE anfordern</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Information (NUSE_QUEUE-Warteschlange, ADDR * Startadresse, U8 * Warteschlangengr√∂√üe, U8 * verf√ºgbar, U8 * Nachrichten, U8 * Aufgaben warten, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - Index der Warteschlange, √ºber die Informationen angefordert werden; <br>  <b>start_address</b> - ein Zeiger auf eine Variable vom Typ <b>ADDR</b> , in der die Adresse des Beginns des Datenbereichs der Warteschlange gespeichert wird; <br>  <b>queue_size</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , in der die Gesamtzahl der Nachrichten gespeichert wird, die in die Warteschlange passen k√∂nnen; <br>  <b>verf√ºgbar</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , in der die Anzahl der freien Pl√§tze in der Warteschlange gespeichert wird; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , die die aktuelle Anzahl von Nachrichten in der Warteschlange speichert; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, in der die Anzahl der in dieser Warteschlange angehaltenen Tasks gespeichert wird (bei deaktivierter Task-Sperre wird nichts zur√ºckgegeben); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK,</b> in der der Index der ersten angehaltenen Task gespeichert wird (bei deaktivierter Task-Sperre wird nichts zur√ºckgegeben). <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren der Anzeige von Warteschlangeninformationen in Nucleus SE</i></b> <br><br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  Die Funktion gibt den Status der Warteschlange zur√ºck.  Wenn dann die Aufgabenverriegelung aktiviert ist, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zur√ºckgegeben (andernfalls werden beide Parameter auf 0 gesetzt). <br><br><h3>  Abrufen der Anzahl der Warteschlangen </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der in der Anwendung konfigurierten Warteschlangen zur√ºck.  In Nucleus RTOS kann sich ihre Anzahl im Laufe der Zeit √§ndern, und der R√ºckgabewert gibt die aktuelle Anzahl von Warteschlangen an.  In Nucleus SE wird der R√ºckgabewert w√§hrend der Erstellungsphase festgelegt und kann nicht ge√§ndert werden. <br><br>  <b><i>Aufrufen des Warteschlangenz√§hlers in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Established_Queues (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die Anzahl der im System erstellten Warteschlangen. <br><br>  <b><i>Aufrufen des Warteschlangenz√§hlers in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Queue_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die Anzahl der in der Anwendung konfigurierten Warteschlangen. <br><br>  <b><i>Implementieren des Warteschlangenz√§hlers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist sehr einfach: Der Wert des Symbols <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> wird <b>zur√ºckgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Warteschlangen verwenden f√ºnf oder sechs Datenstrukturen (entweder im RAM oder im ROM), bei denen es sich um Tabellens√§tze handelt (wie bei anderen Nucleus SE-Objekten), deren Anzahl und Gr√∂√üe der Anzahl der Warteschlangen in der Anwendung und den ausgew√§hlten Parametern entspricht. <br><br><h3>  Kerneldaten im RAM </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Queue_Head []</b> ist ein Array von Zeigern vom Typ <b>U8</b> , hat einen Eintrag f√ºr jede konfigurierte Warteschlange und zeigt auf den Kopf der Nachrichtenwarteschlange.  Wird als Adressindex in <b>NUSE_Queue_Data [] verwendet</b> (siehe unten); <br>  <b>NUSE_Queue_Tail []</b> ist ein Array vom Typ <b>U8</b> , hat einen Eintrag f√ºr jede in der Anwendung konfigurierte Warteschlange und zeigt auf das Ende der Nachrichtenwarteschlange.  Wird als Adressindex in <b>NUSE_Queue_Data [] verwendet</b> (siehe unten); <br>  <b>NUSE_Queue_Items []</b> ist ein Array vom Typ <b>U8</b> , hat einen Eintrag f√ºr jede konfigurierte Warteschlange und ist ein Z√§hler f√ºr Nachrichten in der Warteschlange.  Diese Daten k√∂nnen als redundant betrachtet werden, da diese Werte √ºber die Indizes am Anfang und Ende der Warteschlange abgerufen werden k√∂nnen. Das Speichern des Z√§hlers vereinfacht jedoch den Code. <br>  <b>NUSE_Queue_Blocking_Count []</b> - Dieses Array vom Typ <b>U8</b> enth√§lt Z√§hler f√ºr die Anzahl der Aufgaben, die in jeder Warteschlange angehalten wurden.  Dieses Array wird nur erstellt, wenn die Unterst√ºtzung f√ºr Task-Sperren aktiviert ist. <br><br>  Diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Queue () auf Null</b> initialisiert.  Dies ist logisch, da alle Warteschlangen leer erstellt (nicht verwendet) werden. <br><br>  Im Folgenden sind die Definitionen dieser Strukturen in der Datei <b>nuse_init.c aufgef√ºhrt</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  RAM-Benutzerdaten </h3><br>  Der Benutzer ist daf√ºr verantwortlich, einen RAM-Bereich zum Speichern jeder Warteschlange bereitzustellen.  Die Gr√∂√üe dieses Bereichs sollte ein Array vom Typ <b>ADDR enthalten</b> , in dem jeder Datensatz einer Nachricht in der Warteschlange entspricht <br><br><h3>  ROM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Queue_Data []</b> - Ein Array vom Typ <b>ADDR</b> hat einen Eintrag f√ºr jede konfigurierte Warteschlange und zeigt auf den Datenbereich der Warteschlange (siehe Benutzer-RAM-Daten). <br>  <b>NUSE_Queue_Size []</b> - Ein Array vom Typ <b>U8</b> hat einen Eintrag f√ºr jede konfigurierte Warteschlange und zeigt die maximale Anzahl von Nachrichten an, die jede Warteschlange empfangen kann. <br><br>  Diese Datenstrukturen werden in der Datei <b>nuse_config.c</b> deklariert und (statisch) initialisiert: <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  Die Speichermenge f√ºr Warteschlangen </h3><br>  Wie bei allen Nucleus SE-Kernelobjekten ist die f√ºr Warteschlangen ben√∂tigte Speichermenge leicht vorhersehbar. <br><br>  Die Datenmenge im ROM (in Byte) f√ºr alle Warteschlangen in der Anwendung kann wie folgt berechnet werden: <br>  <b>NUSE_QUEUE_NUMBER * (Gr√∂√üe von (ADDR) + 1)</b> <br><br>  Die Menge der Kerneldaten im RAM (in Byte) f√ºr alle Warteschlangen in der Anwendung mit aktivierter Task-Sperre wird wie folgt berechnet: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Wenn die Sperre deaktiviert ist: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  Die Menge der Benutzerdaten im RAM (in Byte) f√ºr die Warteschlange mit dem <b>Warteschlangenindex</b> : <br>  <b>NUSE_Queue_Size [Warteschlange] * sizeof (ADDR)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Vier API-Aufrufe, die in Nucleus RTOS enthalten sind, sind in Nucleus SE nicht implementiert: <br><br><h3>  Warteschlangenerstellung </h3><br>  Dieser API-Aufruf erstellt eine Warteschlange. In Nucleus SE ist dies nicht erforderlich, da Warteschlangen statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Queue (NU_QUEUE * Warteschlange, Zeichen * Name, VOID * Startadresse, UNSIGNED Warteschlangengr√∂√üe, OPTION Nachrichtentyp, UNSIGNIERT Nachrichtengr√∂√üe, OPTION Suspend_Typ);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - Ein Zeiger auf eine vom Benutzer bereitgestellte Steuereinheit, mit der Warteschlangen in anderen API-Aufrufen verwaltet werden. <br>  <b>name</b> - ein Zeiger auf einen 7-stelligen Warteschlangennamen mit einem Null-Abschlussbyte; <br>  <b>start_address</b> - Adresse des Beginns der Warteschlange; <br>  <b>Nachrichtentyp</b> - Nachrichtentyp, der von der Warteschlange unterst√ºtzt wird.  Es kann die Werte <b>NU_FIXED_SIZE</b> oder <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Wenn die Warteschlange Nachrichten mit fester L√§nge unterst√ºtzt, legt dieser Parameter die genaue L√§nge jeder Nachricht fest. Wenn die Warteschlange Nachrichten mit variabler L√§nge unterst√ºtzt, ist dieser Wert die maximale Nachrichtenl√§nge. <br>  <b>suspend_type</b> - Bestimmt den Typ der Suspend-Aufgaben in der Warteschlange.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY annehmen</b> , die das FIFO-Prinzip (First-In-First-Out) bzw. das Prinzip der Priorit√§t der Aussetzung von Aufgaben bedeuten. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - Nullzeiger auf den Warteschlangensteuerblock ( <b>NULL</b> ) oder der Zeiger wird bereits verwendet; <br>  <b>NU_INVALID_MEMORY</b> - ung√ºltiger Speicherbereich in <b>start_address angegeben</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - ung√ºltiger Parameter <b>message_type</b> ; <br>  <b>NU_INVALID_SIZE</b> - Die Warteschlange unterst√ºtzt keine Nachrichten dieser L√§nge, oder die Warteschlangengr√∂√üe und / oder Nachrichtenl√§nge betr√§gt 0. <br>  <b>NU_INVALID_SUSPEND</b> - ung√ºltiger <b>suspend_type-</b> Parameter. <br><br><h3>  Warteschlange l√∂schen </h3><br>  Dieser API-Aufruf l√∂scht die zuvor erstellte Warteschlange.  Nucleus SE ben√∂tigt dies nicht, da Warteschlangen statisch erstellt werden und nicht gel√∂scht werden k√∂nnen. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Queue (NU_QUEUE * Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Ein Zeiger auf einen Warteschlangensteuerblock. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger. <br><br><h3>  Warteschlangenzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Warteschlangen im System.  Nucleus SE ben√∂tigt dies nicht, da Warteschlangen anhand eines einfachen Index und nicht anhand eines Zeigers identifiziert werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Queue_Pointers (NU_QUEUE ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_QUEUE</b> .  Dieses Array wird mit Zeigern auf im System erstellte Warteschlangen gef√ºllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  R√ºckgabewert: <br>  Die Anzahl der <b>NU_QUEUE-</b> Zeiger im Array. <br><br><h3>  Warteschlangen (Broadcast to Queue) </h3><br>  Dieser API-Aufruf leitet die Nachricht an alle in der Warteschlange angehaltenen Aufgaben weiter, die auf Nachrichten aus der angegebenen Warteschlange warten.  Diese Funktion ist in Nucleus SE nicht implementiert, da dadurch Redundanz hinzugef√ºgt wird. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Broadcast_To_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Gr√∂√üe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf einen Warteschlangensteuerblock; <br>  <b>Nachricht</b> - Zeiger auf die √ºbertragene Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der nicht <b>signierten</b> Elemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter gleich oder kleiner als die von der Warteschlange unterst√ºtzte Nachrichtenl√§nge sein.  Wenn die Warteschlange Nachrichten fester L√§nge unterst√ºtzt, muss dieser Parameter der L√§nge der von der Warteschlange unterst√ºtzten Nachricht entsprechen. <br>  <b>suspen</b> - <b>Gibt</b> an, ob die aufrufende Aufgabe <b>angehalten werden soll</b> , wenn die Warteschlange bereits voll ist.  <b>Dies</b> kann <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder ein Timeout-Wert sein. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ung√ºltiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die angegebene Nachrichtenl√§nge ist nicht mit der beim Erstellen der Warteschlange angegebenen L√§nge kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten,</b> der der Aufgabe nicht zugeordnet ist; <br>  <b>NU_QUEUE_FULL</b> - In der Warteschlange ist nicht gen√ºgend Platz f√ºr die Nachricht vorhanden. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist nach Ablauf des Zeitlimits noch voll. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilit√§t des Anwendungscodes mit Nucleus RTOS zu maximieren.  Warteschlangen sind keine Ausnahme und werden aus Anwendersicht auf die gleiche Weise wie in Nucleus RTOS implementiert.  Es gibt auch eine gewisse Inkompatibilit√§t, die ich f√ºr akzeptabel hielt, da der Code dadurch verst√§ndlicher und effizienter in Bezug auf den erforderlichen Speicher wird.  Andernfalls k√∂nnen Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch eine Datenstruktur (Steuereinheiten) beschrieben, die einen bestimmten Datentyp hat.  Ein Zeiger auf diese Steuereinheit dient als Kennung f√ºr die Warteschlange.  Ich entschied, dass in Nucleus SE ein anderer Ansatz f√ºr die effiziente Nutzung des Speichers erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben.  Die Gr√∂√üe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Also habe ich <b>NUSE_QUEUE</b> als das √Ñquivalent von <b>U8 definiert</b> . Eine Variable (kein Zeiger) dieses Typs dient als Warteschlangenkennung.  Diese leichte Inkompatibilit√§t ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgef√ºhrt. <br><br>  Nucleus RTOS unterst√ºtzt auch die Benennung von Warteschlangen.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Nachrichtengr√∂√üe und -typ </h3><br>  In Nucleus RTOS kann eine Warteschlange so konfiguriert werden, dass Nachrichten verarbeitet werden, die aus einer beliebigen Anzahl von <b>nicht signierten</b> Elementen bestehen.  In Nucleus SE werden Warteschlangen vereinfacht und unterst√ºtzen nur einzelne <b>Nachrichten vom</b> Typ <b>ADDR</b> .  Die Datenkan√§le von Nucleus SE sind etwas flexibler und k√∂nnen in einigen F√§llen eine n√ºtzliche Alternative zu Warteschlangen sein.  Kan√§le werden in den n√§chsten beiden Artikeln dieser Reihe behandelt. <br><br>  Nucleus SE unterst√ºtzt auch Nachrichtenwarteschlangen mit variabler L√§nge, die nur die maximale Nachrichtenl√§nge w√§hrend der Erstellung angeben.  Variable Nachrichtenl√§ngen werden von Nucleus SE nicht unterst√ºtzt <br><br><h3>  Warteschlangengr√∂√üe </h3><br>  In Nucleus SE betr√§gt die maximale Anzahl von Nachrichten in einer Warteschlange 256, da alle Variablen und Konstanten vom Typ <b>U8 sind</b> .  Nucleus RTOS unterliegt keinen solchen Einschr√§nkungen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterst√ºtzt zehn Warteschlangenverwaltungsaufrufe.  Von diesen sind vier nicht in Nucleus SE implementiert.  Details zu diesen Aufrufen sowie die Gr√ºnde f√ºr eine solche Entscheidung finden Sie in diesem Artikel oben im Abschnitt "Nicht realisierte API-Aufrufe". <br><br>  Im n√§chsten Artikel werden Daten√ºbertragungskan√§le erl√§utert. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432804/">https://habr.com/ru/post/de432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432794/index.html">Bret Victor: Ein paar Worte zu Douglas Engelbart</a></li>
<li><a href="../de432796/index.html">Rechenmodul, Modelle 2019</a></li>
<li><a href="../de432798/index.html">Bestes Sicherheitsbetriebssystem: Titan-Vergleich</a></li>
<li><a href="../de432800/index.html">Untersuchung von Sicherheitsvorf√§llen mit StaffCop Enterprise 4.4</a></li>
<li><a href="../de432802/index.html">Sechs kostenlose Lernplattformen f√ºr die automatisierte Programmierung</a></li>
<li><a href="../de432806/index.html">Superintelligenz: eine Idee, die kluge Leute verfolgt</a></li>
<li><a href="../de432808/index.html">Geh√§lter in AI: Wo es mehr Geld gibt und wen sie in Russland suchen</a></li>
<li><a href="../de432810/index.html">Erste Bu√ügelder f√ºr die DSGVO: Wer wurde bereits bestraft?</a></li>
<li><a href="../de432812/index.html">Wir schreiben Handelsroboter mit dem grafischen Framework von StockSharp. Teil 1</a></li>
<li><a href="../de432814/index.html">Kuchen- und TeamCity-Integration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>