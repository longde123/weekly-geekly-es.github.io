<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎸 🔂 🖌️ Die ganze Wahrheit über RTOS. Artikel 24. Warteschlangen: Nebendienstleistungen und Datenstrukturen 🔽 💃 🤟🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir weiterhin Warteschlangen berücksichtigen. 

 Sekundäre Warteschlangendienste 
 Nucleus RTOS verfügt über vier API-Aufrufe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 24. Warteschlangen: Nebendienstleistungen und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  In diesem Artikel werden wir weiterhin Warteschlangen berücksichtigen. <br><br><h2>  Sekundäre Warteschlangendienste </h2><br>  Nucleus RTOS verfügt über vier API-Aufrufe, die Zusatzfunktionen für Warteschlangen bereitstellen: Zurücksetzen einer Warteschlange, Empfangen von Warteschlangeninformationen, Abrufen der Anzahl der Warteschlangen in einer Anwendung und Abrufen von Zeigern auf alle Warteschlangen in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br><br><h3>  Zurücksetzen der Warteschlange </h3><br>  Dieser API-Aufruf setzt die Warteschlange auf ihren ursprünglichen, nicht verwendeten Status zurück.  Alle Nachrichten, die in der Warteschlange gespeichert sind, gehen verloren.  Alle in der Warteschlange angehaltenen Aufgaben werden mit dem Rückkehrcode <b>NUSE_QUEUE_WAS_RESET fortgesetzt</b> . <br><br>  <b><i>Warteschlangen-Reset-Aufruf in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Reset_Queue (NU_QUEUE * Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Ein Zeiger auf einen vom Benutzer bereitgestellten Warteschlangensteuerblock. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger. <br><br>  <b><i>Anruf zum Zurücksetzen der Warteschlange in Nucleus SE</i></b> <br>  Dieser Dienstprogrammaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Queue_Reset (NUSE_QUEUE-Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Index (ID) der abgelegten Warteschlange. <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ungültiger Warteschlangenindex. <br><br>  <b><i>Implementieren des Zurücksetzens der Warteschlange in Nucleus SE</i></b> <br>  Der Code der Funktion <b>NUSE_Queue_Reset</b> (nach Überprüfung der Parameter) ist recht einfach.  Indizes des Kopfes und Endes der Warteschlange sowie des Nachrichtenzählers in der Warteschlange wird ein Nullwert zugewiesen. <br><br>  Wenn die Task-Sperre aktiviert ist, ist zusätzlicher Code für die Wiederherstellung angehaltener Tasks verantwortlich: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Jeder angehaltenen Aufgabe in der Warteschlange wird der Status "Bereit" mit dem Rückkehrcode <b>NUSE_QUEUE_WAS_RESET zugewiesen</b> .  Nach Abschluss dieses Vorgangs wird bei Verwendung des Prioritätsplaners die Funktion <b>NUSE_Reschedule () aufgerufen</b> , da möglicherweise eine oder mehrere Aufgaben mit hoher Priorität zur Ausführung bereit sind. <br><br><h3>  Abrufen von Warteschlangeninformationen </h3><br>  Dieser Serviceabruf enthält Informationen zur Warteschlange.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zurückgegeben werden, da die Objektbenennung, die variable Nachrichtenlänge und die Reihenfolge der Aufgabenpausen nicht unterstützt werden und das Sperren von Aufgaben deaktiviert werden kann. <br><br>  <b><i>Aufruf für Warteschlangeninformationen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Queue_Information (NU_QUEUE * Warteschlange, CHAR * Name, VOID ** Startadresse, UNSIGNED * Warteschlangengröße, UNSIGNED * verfügbar, UNSIGNED * Nachrichten, OPTION * Nachrichtentyp, UNSIGNED * Nachrichtengröße, OPTION * Suspend_Typ, UNSIGNt_t_</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Warteschlangensteuerblock; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich für den Namen der Nachricht in der Warteschlange; <br>  <b>start_address</b> - ein Zeiger auf einen Zeiger, in den die Adresse des Anfangs des Warteschlangendatenbereichs geschrieben wird; <br>  <b>queue_size</b> - ein Zeiger auf eine Variable zum Speichern der Gesamtzahl der <b>UNSIGNED-</b> Elemente in der Warteschlange; <br>  <b>verfügbar</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl verfügbarer <b>UNSIGNED-</b> Elemente in der Warteschlange; <br>  Nachrichten - ein Zeiger auf eine Variable zum Speichern der aktuellen Anzahl von Nachrichten in der Warteschlange; <br>  <b>message_type</b> - Ein Zeiger auf eine Variable zum Speichern des von der Warteschlange unterstützten Nachrichtentyps.  Gültige Werte sind <b>NU_FIXED_SIZE</b> und <b>NU_VARIABLE</b> . <br>  <b>message_size</b> - Ein Zeiger auf eine Variable zum Speichern der Anzahl der <b>UNSIGNED-</b> Datenelemente in jeder Nachricht der Warteschlange.  Wenn die Warteschlange Nachrichten mit variabler Länge unterstützt, gibt diese Nummer die maximale Nachrichtenlänge an. <br>  <b>suspend_type</b> - Ein Zeiger auf eine Variable zum Speichern der Art der <b>Unterbrechung</b> von Aufgaben.  Gültige Werte sind <b>NU_FIFO</b> und <b>NU_PRIORITY</b> . <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der in dieser Warteschlange angehaltenen Aufgaben; <br>  <b>first_task</b> - Zeiger auf den Aufgabenzeiger, in dem der Zeiger der ersten angehaltenen Aufgabe platziert ist. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger. <br><br>  <b><i>Informationen zur Warteschlange in Nucleus SE anfordern</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Queue_Information (NUSE_QUEUE-Warteschlange, ADDR * Startadresse, U8 * Warteschlangengröße, U8 * verfügbar, U8 * Nachrichten, U8 * Aufgaben warten, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - Index der Warteschlange, über die Informationen angefordert werden; <br>  <b>start_address</b> - ein Zeiger auf eine Variable vom Typ <b>ADDR</b> , in der die Adresse des Beginns des Datenbereichs der Warteschlange gespeichert wird; <br>  <b>queue_size</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , in der die Gesamtzahl der Nachrichten gespeichert wird, die in die Warteschlange passen können; <br>  <b>verfügbar</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , in der die Anzahl der freien Plätze in der Warteschlange gespeichert wird; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , die die aktuelle Anzahl von Nachrichten in der Warteschlange speichert; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, in der die Anzahl der in dieser Warteschlange angehaltenen Tasks gespeichert wird (bei deaktivierter Task-Sperre wird nichts zurückgegeben); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK,</b> in der der Index der ersten angehaltenen Task gespeichert wird (bei deaktivierter Task-Sperre wird nichts zurückgegeben). <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_QUEUE</b> - ungültiger Warteschlangenindex; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren der Anzeige von Warteschlangeninformationen in Nucleus SE</i></b> <br><br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  Die Funktion gibt den Status der Warteschlange zurück.  Wenn dann die Aufgabenverriegelung aktiviert ist, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zurückgegeben (andernfalls werden beide Parameter auf 0 gesetzt). <br><br><h3>  Abrufen der Anzahl der Warteschlangen </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der in der Anwendung konfigurierten Warteschlangen zurück.  In Nucleus RTOS kann sich ihre Anzahl im Laufe der Zeit ändern, und der Rückgabewert gibt die aktuelle Anzahl von Warteschlangen an.  In Nucleus SE wird der Rückgabewert während der Erstellungsphase festgelegt und kann nicht geändert werden. <br><br>  <b><i>Aufrufen des Warteschlangenzählers in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Established_Queues (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die Anzahl der im System erstellten Warteschlangen. <br><br>  <b><i>Aufrufen des Warteschlangenzählers in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Queue_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die Anzahl der in der Anwendung konfigurierten Warteschlangen. <br><br>  <b><i>Implementieren des Warteschlangenzählers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist sehr einfach: Der Wert des Symbols <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> wird <b>zurückgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Warteschlangen verwenden fünf oder sechs Datenstrukturen (entweder im RAM oder im ROM), bei denen es sich um Tabellensätze handelt (wie bei anderen Nucleus SE-Objekten), deren Anzahl und Größe der Anzahl der Warteschlangen in der Anwendung und den ausgewählten Parametern entspricht. <br><br><h3>  Kerneldaten im RAM </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Queue_Head []</b> ist ein Array von Zeigern vom Typ <b>U8</b> , hat einen Eintrag für jede konfigurierte Warteschlange und zeigt auf den Kopf der Nachrichtenwarteschlange.  Wird als Adressindex in <b>NUSE_Queue_Data [] verwendet</b> (siehe unten); <br>  <b>NUSE_Queue_Tail []</b> ist ein Array vom Typ <b>U8</b> , hat einen Eintrag für jede in der Anwendung konfigurierte Warteschlange und zeigt auf das Ende der Nachrichtenwarteschlange.  Wird als Adressindex in <b>NUSE_Queue_Data [] verwendet</b> (siehe unten); <br>  <b>NUSE_Queue_Items []</b> ist ein Array vom Typ <b>U8</b> , hat einen Eintrag für jede konfigurierte Warteschlange und ist ein Zähler für Nachrichten in der Warteschlange.  Diese Daten können als redundant betrachtet werden, da diese Werte über die Indizes am Anfang und Ende der Warteschlange abgerufen werden können. Das Speichern des Zählers vereinfacht jedoch den Code. <br>  <b>NUSE_Queue_Blocking_Count []</b> - Dieses Array vom Typ <b>U8</b> enthält Zähler für die Anzahl der Aufgaben, die in jeder Warteschlange angehalten wurden.  Dieses Array wird nur erstellt, wenn die Unterstützung für Task-Sperren aktiviert ist. <br><br>  Diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Queue () auf Null</b> initialisiert.  Dies ist logisch, da alle Warteschlangen leer erstellt (nicht verwendet) werden. <br><br>  Im Folgenden sind die Definitionen dieser Strukturen in der Datei <b>nuse_init.c aufgeführt</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  RAM-Benutzerdaten </h3><br>  Der Benutzer ist dafür verantwortlich, einen RAM-Bereich zum Speichern jeder Warteschlange bereitzustellen.  Die Größe dieses Bereichs sollte ein Array vom Typ <b>ADDR enthalten</b> , in dem jeder Datensatz einer Nachricht in der Warteschlange entspricht <br><br><h3>  ROM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Queue_Data []</b> - Ein Array vom Typ <b>ADDR</b> hat einen Eintrag für jede konfigurierte Warteschlange und zeigt auf den Datenbereich der Warteschlange (siehe Benutzer-RAM-Daten). <br>  <b>NUSE_Queue_Size []</b> - Ein Array vom Typ <b>U8</b> hat einen Eintrag für jede konfigurierte Warteschlange und zeigt die maximale Anzahl von Nachrichten an, die jede Warteschlange empfangen kann. <br><br>  Diese Datenstrukturen werden in der Datei <b>nuse_config.c</b> deklariert und (statisch) initialisiert: <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  Die Speichermenge für Warteschlangen </h3><br>  Wie bei allen Nucleus SE-Kernelobjekten ist die für Warteschlangen benötigte Speichermenge leicht vorhersehbar. <br><br>  Die Datenmenge im ROM (in Byte) für alle Warteschlangen in der Anwendung kann wie folgt berechnet werden: <br>  <b>NUSE_QUEUE_NUMBER * (Größe von (ADDR) + 1)</b> <br><br>  Die Menge der Kerneldaten im RAM (in Byte) für alle Warteschlangen in der Anwendung mit aktivierter Task-Sperre wird wie folgt berechnet: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Wenn die Sperre deaktiviert ist: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  Die Menge der Benutzerdaten im RAM (in Byte) für die Warteschlange mit dem <b>Warteschlangenindex</b> : <br>  <b>NUSE_Queue_Size [Warteschlange] * sizeof (ADDR)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Vier API-Aufrufe, die in Nucleus RTOS enthalten sind, sind in Nucleus SE nicht implementiert: <br><br><h3>  Warteschlangenerstellung </h3><br>  Dieser API-Aufruf erstellt eine Warteschlange. In Nucleus SE ist dies nicht erforderlich, da Warteschlangen statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Queue (NU_QUEUE * Warteschlange, Zeichen * Name, VOID * Startadresse, UNSIGNED Warteschlangengröße, OPTION Nachrichtentyp, UNSIGNIERT Nachrichtengröße, OPTION Suspend_Typ);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - Ein Zeiger auf eine vom Benutzer bereitgestellte Steuereinheit, mit der Warteschlangen in anderen API-Aufrufen verwaltet werden. <br>  <b>name</b> - ein Zeiger auf einen 7-stelligen Warteschlangennamen mit einem Null-Abschlussbyte; <br>  <b>start_address</b> - Adresse des Beginns der Warteschlange; <br>  <b>Nachrichtentyp</b> - Nachrichtentyp, der von der Warteschlange unterstützt wird.  Es kann die Werte <b>NU_FIXED_SIZE</b> oder <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Wenn die Warteschlange Nachrichten mit fester Länge unterstützt, legt dieser Parameter die genaue Länge jeder Nachricht fest. Wenn die Warteschlange Nachrichten mit variabler Länge unterstützt, ist dieser Wert die maximale Nachrichtenlänge. <br>  <b>suspend_type</b> - Bestimmt den Typ der Suspend-Aufgaben in der Warteschlange.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY annehmen</b> , die das FIFO-Prinzip (First-In-First-Out) bzw. das Prinzip der Priorität der Aussetzung von Aufgaben bedeuten. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - Nullzeiger auf den Warteschlangensteuerblock ( <b>NULL</b> ) oder der Zeiger wird bereits verwendet; <br>  <b>NU_INVALID_MEMORY</b> - ungültiger Speicherbereich in <b>start_address angegeben</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - ungültiger Parameter <b>message_type</b> ; <br>  <b>NU_INVALID_SIZE</b> - Die Warteschlange unterstützt keine Nachrichten dieser Länge, oder die Warteschlangengröße und / oder Nachrichtenlänge beträgt 0. <br>  <b>NU_INVALID_SUSPEND</b> - ungültiger <b>suspend_type-</b> Parameter. <br><br><h3>  Warteschlange löschen </h3><br>  Dieser API-Aufruf löscht die zuvor erstellte Warteschlange.  Nucleus SE benötigt dies nicht, da Warteschlangen statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Queue (NU_QUEUE * Warteschlange);</b> <br><br>  Parameter: <br>  <b>Warteschlange</b> - Ein Zeiger auf einen Warteschlangensteuerblock. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger. <br><br><h3>  Warteschlangenzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Warteschlangen im System.  Nucleus SE benötigt dies nicht, da Warteschlangen anhand eines einfachen Index und nicht anhand eines Zeigers identifiziert werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Queue_Pointers (NU_QUEUE ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_QUEUE</b> .  Dieses Array wird mit Zeigern auf im System erstellte Warteschlangen gefüllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  Rückgabewert: <br>  Die Anzahl der <b>NU_QUEUE-</b> Zeiger im Array. <br><br><h3>  Warteschlangen (Broadcast to Queue) </h3><br>  Dieser API-Aufruf leitet die Nachricht an alle in der Warteschlange angehaltenen Aufgaben weiter, die auf Nachrichten aus der angegebenen Warteschlange warten.  Diese Funktion ist in Nucleus SE nicht implementiert, da dadurch Redundanz hinzugefügt wird. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Broadcast_To_Queue (NU_QUEUE * Warteschlange, VOID * Nachricht, UNSIGNED Größe, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>Warteschlange</b> - ein Zeiger auf einen Warteschlangensteuerblock; <br>  <b>Nachricht</b> - Zeiger auf die übertragene Nachricht; <br>  <b>Größe</b> - Die Anzahl der nicht <b>signierten</b> Elemente in der Nachricht.  Wenn die Warteschlange Nachrichten mit variabler Länge unterstützt, muss dieser Parameter gleich oder kleiner als die von der Warteschlange unterstützte Nachrichtenlänge sein.  Wenn die Warteschlange Nachrichten fester Länge unterstützt, muss dieser Parameter der Länge der von der Warteschlange unterstützten Nachricht entsprechen. <br>  <b>suspen</b> - <b>Gibt</b> an, ob die aufrufende Aufgabe <b>angehalten werden soll</b> , wenn die Warteschlange bereits voll ist.  <b>Dies</b> kann <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder ein Timeout-Wert sein. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_QUEUE</b> - ungültiger Warteschlangenzeiger; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die angegebene Nachrichtenlänge ist nicht mit der beim Erstellen der Warteschlange angegebenen Länge kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten,</b> der der Aufgabe nicht zugeordnet ist; <br>  <b>NU_QUEUE_FULL</b> - In der Warteschlange ist nicht genügend Platz für die Nachricht vorhanden. <br>  <b>NU_TIMEOUT</b> - Die Warteschlange ist nach Ablauf des Zeitlimits noch voll. <br>  <b>NU_QUEUE_DELETED</b> - Die Warteschlange wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_QUEUE_RESET</b> - Die Warteschlange wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilität des Anwendungscodes mit Nucleus RTOS zu maximieren.  Warteschlangen sind keine Ausnahme und werden aus Anwendersicht auf die gleiche Weise wie in Nucleus RTOS implementiert.  Es gibt auch eine gewisse Inkompatibilität, die ich für akzeptabel hielt, da der Code dadurch verständlicher und effizienter in Bezug auf den erforderlichen Speicher wird.  Andernfalls können Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch eine Datenstruktur (Steuereinheiten) beschrieben, die einen bestimmten Datentyp hat.  Ein Zeiger auf diese Steuereinheit dient als Kennung für die Warteschlange.  Ich entschied, dass in Nucleus SE ein anderer Ansatz für die effiziente Nutzung des Speichers erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben.  Die Größe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Also habe ich <b>NUSE_QUEUE</b> als das Äquivalent von <b>U8 definiert</b> . Eine Variable (kein Zeiger) dieses Typs dient als Warteschlangenkennung.  Diese leichte Inkompatibilität ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgeführt. <br><br>  Nucleus RTOS unterstützt auch die Benennung von Warteschlangen.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Nachrichtengröße und -typ </h3><br>  In Nucleus RTOS kann eine Warteschlange so konfiguriert werden, dass Nachrichten verarbeitet werden, die aus einer beliebigen Anzahl von <b>nicht signierten</b> Elementen bestehen.  In Nucleus SE werden Warteschlangen vereinfacht und unterstützen nur einzelne <b>Nachrichten vom</b> Typ <b>ADDR</b> .  Die Datenkanäle von Nucleus SE sind etwas flexibler und können in einigen Fällen eine nützliche Alternative zu Warteschlangen sein.  Kanäle werden in den nächsten beiden Artikeln dieser Reihe behandelt. <br><br>  Nucleus SE unterstützt auch Nachrichtenwarteschlangen mit variabler Länge, die nur die maximale Nachrichtenlänge während der Erstellung angeben.  Variable Nachrichtenlängen werden von Nucleus SE nicht unterstützt <br><br><h3>  Warteschlangengröße </h3><br>  In Nucleus SE beträgt die maximale Anzahl von Nachrichten in einer Warteschlange 256, da alle Variablen und Konstanten vom Typ <b>U8 sind</b> .  Nucleus RTOS unterliegt keinen solchen Einschränkungen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt zehn Warteschlangenverwaltungsaufrufe.  Von diesen sind vier nicht in Nucleus SE implementiert.  Details zu diesen Aufrufen sowie die Gründe für eine solche Entscheidung finden Sie in diesem Artikel oben im Abschnitt "Nicht realisierte API-Aufrufe". <br><br>  Im nächsten Artikel werden Datenübertragungskanäle erläutert. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432804/">https://habr.com/ru/post/de432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432794/index.html">Bret Victor: Ein paar Worte zu Douglas Engelbart</a></li>
<li><a href="../de432796/index.html">Rechenmodul, Modelle 2019</a></li>
<li><a href="../de432798/index.html">Bestes Sicherheitsbetriebssystem: Titan-Vergleich</a></li>
<li><a href="../de432800/index.html">Untersuchung von Sicherheitsvorfällen mit StaffCop Enterprise 4.4</a></li>
<li><a href="../de432802/index.html">Sechs kostenlose Lernplattformen für die automatisierte Programmierung</a></li>
<li><a href="../de432806/index.html">Superintelligenz: eine Idee, die kluge Leute verfolgt</a></li>
<li><a href="../de432808/index.html">Gehälter in AI: Wo es mehr Geld gibt und wen sie in Russland suchen</a></li>
<li><a href="../de432810/index.html">Erste Bußgelder für die DSGVO: Wer wurde bereits bestraft?</a></li>
<li><a href="../de432812/index.html">Wir schreiben Handelsroboter mit dem grafischen Framework von StockSharp. Teil 1</a></li>
<li><a href="../de432814/index.html">Kuchen- und TeamCity-Integration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>