<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 🚣🏿 😏 Guía SQL: Cómo escribir mejor las consultas (Parte 2) 🆗 🧝🏼 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuación del artículo Guía de SQL: Cómo escribir mejor las consultas (Parte 1) 

 De solicitud a planes de ejecución 
 Saber que los antipatrones ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guía SQL: Cómo escribir mejor las consultas (Parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Continuación del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de SQL: Cómo escribir mejor las consultas (Parte 1)</a> <br><br><h2>  De solicitud a planes de ejecución </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Saber que los antipatrones no son estáticos y evolucionan a medida que crece como desarrollador de SQL, y el hecho de que hay muchas cosas a tener en cuenta al pensar en alternativas también significa que evitar antipatrones y reescribir consultas puede ser bastante difícil tarea  Cualquier ayuda puede ser útil, por lo que un enfoque más estructurado para la optimización de consultas utilizando algunas herramientas puede ser más efectivo. <br><br>  También debe tenerse en cuenta que algunos de los antipatrones mencionados en la última sección tienen sus raíces en problemas de rendimiento, como los operadores <code>AND</code> , <code>OR</code> y <code>NOT</code> y su ausencia al usar índices.  Pensar en el rendimiento requiere no solo un enfoque más estructurado, sino también más profundo. <br><br>  Sin embargo, este enfoque estructurado y profundo se basará principalmente en el plan de consulta, que, como recordará, es el resultado de una consulta analizada primero en un "árbol de análisis" o "árbol de análisis" y determina exactamente qué algoritmo utilizado para cada operación y cómo se coordina su ejecución. <br><a name="habracut"></a><br><h2>  Optimización de consultas </h2><br>  Como leyó en la introducción, es posible que deba verificar y configurar planes que el optimizador compila manualmente.  En tales casos, deberá analizar su solicitud nuevamente mirando el plan de solicitud. <br><br>  Para acceder a este plan, debe utilizar las herramientas proporcionadas por el sistema de gestión de bases de datos.  Las siguientes herramientas pueden estar a su disposición: <br><br><ul><li>  Algunos paquetes contienen herramientas que generan una representación gráfica del plan de consulta.  Considere el siguiente ejemplo: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  Otras herramientas proporcionarán una descripción textual del plan de consulta.  Un ejemplo es la declaración <code>EXPLAIN PLAN</code> en Oracle, pero el nombre de la instrucción depende del DBMS con el que esté trabajando.  En otro lugar puede encontrar <code>EXPLAIN</code> (MySQL, PostgreSQL) o <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Tenga en cuenta</b> que cuando trabaje con PostgreSQL, puede hacer una distinción entre <code>EXPLAIN</code> , donde simplemente obtiene una descripción que le dice cómo el planificador intenta ejecutar la consulta sin ejecutarla, mientras que <code>EXPLAIN ANALYZE</code> realmente ejecuta la consulta y le devuelve el análisis. Planes de solicitud esperados y reales.  En términos generales, un plan de ejecución real es un plan en el que una solicitud se ejecuta realmente, mientras que un plan de ejecución de evaluación determina lo que hará sin cumplir la solicitud.  Aunque esto es lógicamente equivalente, el plan de ejecución real es mucho más útil ya que contiene información adicional y estadísticas sobre lo que realmente sucedió cuando se ejecutó la solicitud. <br><br>  En el resto de esta sección, aprenderá más sobre <code>EXPLAIN</code> y <code>ANALYZE</code> , así como también cómo usarlos para obtener más información sobre el plan de consulta y su posible rendimiento.  Para hacer esto, comience con algunos ejemplos en los que trabajará con dos tablas: <code>one_million</code> y <code>half_million</code> . <br><br>  Puede obtener la información actual de la tabla <code>one_million</code> usando <code>EXPLAIN</code> ;  Asegúrese de colocarlo directamente encima de la solicitud y, después de ejecutarlo, le devolverá el plan de consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  En este caso, verá que el costo de la solicitud es <code>0.00..18584.82</code> , y el número de filas es <code>1025082</code> .  El ancho del número de columnas es <code>36</code> . <br><br>  Además, puede actualizar las estadísticas usando <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Además de <code>EXPLAIN</code> y <code>ANALYZE</code> , también puede obtener el tiempo de ejecución real con <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  La desventaja de usar <code>EXPLAIN ANALYZE</code> es que la consulta se ejecuta realmente, ¡así que tenga cuidado con esto! <br><br>  Hasta ahora, todos los algoritmos que ha visto son <code>Seq Scan</code> (Sequential Scan) o Full Table Scan: este es un escaneo realizado en una base de datos donde cada fila de la tabla escaneada se lee en orden serial y las columnas encontradas se verifican para cumplimiento de la condición o no.  En términos de rendimiento, los escaneos secuenciales definitivamente no son el mejor plan de ejecución porque todavía está haciendo un escaneo completo de la tabla.  Sin embargo, esto no es tan malo cuando la tabla no cabe en la memoria: las lecturas secuenciales son bastante rápidas incluso en discos lentos. <br><br>  Aprenderá más sobre esto más adelante cuando hablemos sobre el escaneo de índice. <br><br>  Sin embargo, hay otros algoritmos.  Tome, por ejemplo, este plan de consulta para una conexión: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  ¡Ves que el optimizador de consultas eligió <code>Hash Join</code> aquí!  Recuerde esta operación, ya que la necesitará para evaluar la complejidad temporal de su solicitud.  Por ahora, tenga en cuenta que no hay índice en <code>half_million.counter</code> , que agregamos en el siguiente ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Verá que al crear el índice, el optimizador de consultas ahora ha decidido utilizar la <code>Merge join</code> al escanear el <code>Index Scan</code> índice. <br><br>  <b>Observe</b> la diferencia entre los escaneos de índice y los escaneos de tabla completa o los escaneos secuenciales: el primero, también llamado "escaneos de tabla", escanea los datos o las páginas de índice para encontrar los registros correspondientes, mientras que el segundo escanea cada fila de la tabla. <br><br>  Verá que el tiempo de ejecución general ha disminuido y el rendimiento debería ser mejor, pero hay dos escaneos de índice, lo que hace que la memoria sea más importante aquí, especialmente si la tabla no encaja en ella.  En tales casos, primero debe realizar una exploración de índice completa, que se realiza mediante lecturas secuenciales rápidas y no es un problema, pero luego tiene muchas operaciones de lectura aleatoria para seleccionar filas por valor de índice.  Estas son operaciones de lectura aleatorias que suelen ser varios órdenes de magnitud más lentas que las secuenciales.  En estos casos, un escaneo completo de la tabla es más rápido que un escaneo de índice completo. <br><br>  <b>Sugerencia:</b> Si desea obtener más información sobre EXPLICAR o considerar ejemplos con más detalle, considere leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Explicación de comprensión de</a> Guillaume Lelarge. <br><br><h2>  Complejidad del tiempo y Big O </h2><br>  Ahora que ha revisado brevemente el plan de consulta, puede comenzar a profundizar y pensar en el rendimiento en términos más formales utilizando la teoría de la complejidad computacional.  Este es un campo de la informática teórica, que, entre otras cosas, se centra en la clasificación de problemas computacionales según su complejidad;  Estos problemas computacionales pueden ser algoritmos, pero también consultas. <br><br>  Sin embargo, para las consultas, no se clasifican necesariamente según su complejidad, sino que dependen del tiempo requerido para completarlas y obtener resultados.  Esto se llama complejidad de tiempo, y puede usar la notación O grande para formular o medir este tipo de complejidad. <br><br>  Con la designación O grande, expresa el tiempo de ejecución en términos de qué tan rápido crece en relación con la entrada, ya que la entrada se vuelve arbitrariamente grande.  La notación O grande excluye los coeficientes y los miembros de un orden inferior, por lo que puede centrarse en la parte importante del tiempo de ejecución de su consulta: su tasa de crecimiento.  Cuando se expresan de esta manera, descartando los coeficientes y términos de un orden inferior, dicen que la complejidad del tiempo se describe asintóticamente.  Esto significa que el tamaño de entrada va al infinito. <br><br>  En un lenguaje de base de datos, la complejidad determina cuánto tiempo lleva completar una consulta a medida que aumenta el tamaño de las tablas de datos y, por lo tanto, la base de datos crece. <br><br>  <b>Tenga en cuenta</b> que el tamaño de su base de datos aumenta no solo por el aumento en la cantidad de datos en las tablas, sino que el hecho de que haya índices también juega un papel importante en el tamaño. <br><br>  Estimando la complejidad de tiempo de su plan de consulta <br><br>  Como viste anteriormente, el plan de ejecución, entre otras cosas, determina qué algoritmo se usa para cada operación, lo que te permite expresar lógicamente cada tiempo de ejecución de consulta como una función del tamaño de la tabla incluida en el plan de consulta, que se llama función de complejidad.  En otras palabras, puede usar la notación O grande y el plan de ejecución para evaluar la complejidad y el rendimiento de la consulta. <br><br>  En las siguientes secciones, obtendrá una visión general de los cuatro tipos de complejidad temporal, y verá algunos ejemplos de cómo la complejidad temporal de las consultas puede variar según el contexto en el que se ejecute. <br><br>  Sugerencia: ¡los índices son parte de esta historia! <br><br>  <b>Sin embargo, debe tenerse en cuenta</b> que hay diferentes tipos de índices, diferentes planes de ejecución y diferentes implementaciones para diferentes bases de datos, por lo que las dificultades temporales que se enumeran a continuación son muy generales y pueden variar según la configuración específica. <br><br><h3>  O (1): tiempo constante </h3><br>  Dicen que un algoritmo funciona en tiempo constante si necesita la misma cantidad de tiempo, independientemente del tamaño de los datos de entrada.  Cuando se trata de una consulta, se ejecutará en tiempo constante si se requiere la misma cantidad de tiempo independientemente del tamaño de la tabla. <br><br>  Este tipo de consulta no es realmente común, pero aquí hay un ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  La complejidad del tiempo es constante, ya que se selecciona una fila arbitraria de la tabla.  Por lo tanto, el período de tiempo no debe depender del tamaño de la tabla. <br><br><h3>  Tiempo lineal: O (n) </h3><br>  Dicen que el algoritmo funciona en tiempo lineal, si su tiempo de ejecución es directamente proporcional al tamaño de los datos de entrada, es decir, el tiempo aumenta linealmente con el tamaño de los datos de entrada.  Para las bases de datos, esto significa que el tiempo de ejecución será directamente proporcional al tamaño de la tabla: a medida que aumenta el número de filas en la tabla, aumenta el tiempo de ejecución de la consulta. <br><br>  Un ejemplo es una consulta con una <code>WHERE</code> para una columna no indexada: se requerirá un escaneo completo de la tabla o un <code>Seq Scan</code> , lo que conducirá a una complejidad de tiempo O (n).  Esto significa que cada línea debe leerse para encontrar la línea con el identificador (ID) deseado.  No tiene ninguna restricción en absoluto, por lo que debe contar cada línea, incluso si la primera línea coincide con la condición. <br><br>  Considere también el siguiente ejemplo de consulta, que tendrá complejidad O (n) si no hay índice en el campo <code>i_id</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  Lo anterior también significa que otras consultas, como consultas para calcular el número de filas <code>COUNT (*) FROM TABLE;</code>  tendrá una complejidad de tiempo <i>O (n)</i> , ya que se requerirá un escaneo completo de la tabla porque el número total de filas no se ha guardado para la tabla.  De lo contrario, la complejidad temporal sería similar a <i>O (1)</i> . <br></li></ul><br>  El tiempo de ejecución lineal está estrechamente relacionado con el tiempo de ejecución de los planes que tienen uniones de tabla.  Aquí hay algunos ejemplos: <br><br><ul><li>  La combinación hash tiene la complejidad esperada de O (M + N). El algoritmo clásico de combinación hash para unir internamente dos tablas primero prepara la tabla hash de la tabla más pequeña.  Las entradas de la tabla hash consisten en un atributo de conexión y su cadena.  Se accede a la tabla hash aplicando la función hash al atributo de conexión.  Una vez que se crea la tabla hash, se escanea una tabla grande y las filas correspondientes de la tabla más pequeña se encuentran buscando en la tabla hash. </li><li>  Las combinaciones de combinación generalmente tienen complejidad O (M + N), pero dependerá en gran medida de los índices de la columna de combinación y, si no hay índice, si las filas se ordenan de acuerdo con las claves utilizadas en la combinación: <ul><li>  Si ambas tablas se ordenan según las claves utilizadas en la combinación, la consulta tendrá una complejidad temporal de O (M + N). </li><li>  Si ambas tablas tienen un índice para columnas unidas, entonces el índice ya admite estas columnas en orden y no es necesario ordenarlas.  La dificultad será O (M + N). </li><li>  Si ninguna de las tablas tiene un índice en las columnas conectadas, primero debe ordenar ambas tablas, para que la complejidad se vea como O (M log M + N log N). </li><li>  Si solo una de las tablas tiene un índice en las columnas conectadas, solo la tabla que no tiene un índice debe clasificarse antes de que ocurra el paso de unión, de modo que la complejidad se vea como O (M + N log N). </li></ul></li><li>  Para combinaciones anidadas, la complejidad suele ser O (MN).  Esta combinación es efectiva cuando una o ambas tablas son extremadamente pequeñas (por ejemplo, menos de 10 registros), lo cual es una situación muy común al evaluar consultas, ya que algunas subconsultas se escriben para devolver solo una fila. </li></ul><br>  <b>Recuerde: una</b> combinación anidada es una combinación que compara cada registro en una tabla con cada registro en otra. <br><br><h3>  Tiempo logarítmico: O (log (n)) </h3><br>  Se dice que un algoritmo funciona en tiempo logarítmico si su tiempo de ejecución es proporcional al logaritmo del tamaño de entrada;  Para las consultas, esto significa que se ejecutarán si el tiempo de ejecución es proporcional al logaritmo del tamaño de la base de datos. <br><br>  Esta complejidad de tiempo logarítmico es válida para planes de consulta en los que se escanea un <code>Index Scan</code> o un índice agrupado.  Un índice agrupado es un índice donde el nivel de índice final contiene las filas reales de la tabla.  Un índice agrupado es similar a cualquier otro índice: se define en una o más columnas.  Forman una clave de índice.  La clave de agrupación son las columnas clave de un índice agrupado.  Escanear un índice agrupado es básicamente la operación de leer su DBMS para una fila o filas de arriba a abajo en un índice agrupado. <br><br>  Considere el siguiente ejemplo de consulta, donde hay un índice para <code>i_id</code> y que generalmente resulta en complejidad O (log (n)): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Tenga en cuenta que sin un índice, la complejidad del tiempo sería O (n). <br><br><h3>  Tiempo cuadrático: O (n ^ 2) </h3><br>  Se cree que el algoritmo se ejecuta en tiempo cuadrático, si su tiempo de ejecución es proporcional al cuadrado del tamaño de entrada.  Nuevamente, para las bases de datos, esto significa que el tiempo de ejecución de la consulta es proporcional al cuadrado del tamaño de la base de datos. <br><br>  Un posible ejemplo de una consulta de complejidad de tiempo cuadrático es el siguiente: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  La complejidad mínima puede ser O (n log (n)), pero la complejidad máxima puede ser O (n ^ 2) según la información de índice de los atributos de conexión. <br><br>  Para resumir, también puede echar un vistazo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a la siguiente hoja de trucos</a> para evaluar el rendimiento de la consulta en función de su complejidad temporal y su efectividad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  Ajuste de SQL </h2><br>  Dado el plan de ejecución de la consulta y la complejidad del tiempo, puede personalizar aún más su consulta SQL.  Puede comenzar centrándose en los siguientes puntos: <br><br><ul><li>  Reemplace los escaneos innecesarios de tablas completas con escaneos de índice; </li><li>  Asegúrese de aplicar el orden de unión óptimo. </li><li>  Asegúrese de que los índices se utilicen de manera óptima.  Y </li><li>  Se utiliza el almacenamiento en caché de escaneos de texto completo de tablas pequeñas (escaneos de tabla completa de caché de tabla pequeña). </li></ul><br><h2>  Uso adicional de SQL </h2><br>  Felicidades  Ha llegado al final de este artículo, que acaba de darle un pequeño vistazo al rendimiento de las consultas SQL.  Espero que tenga más información sobre los antipatrones, el optimizador de consultas y las herramientas que puede utilizar para analizar, evaluar e interpretar la complejidad de su plan de consultas.  Sin embargo, ¡todavía tienes mucho por descubrir!  Si desea saber más, lea el libro "Sistemas de gestión de bases de datos" de R. Ramakrishnan y J. Gehrke. <br><br>  Finalmente, no quiero negarle StackOverflow en esta cita: <br><blockquote>  Mi antipatrón favorito no verifica tus solicitudes. <br><br>  Sin embargo, es aplicable cuando: <br><br><ul><li>  Su consulta proporciona más de una tabla. </li><li>  Cree que tiene el diseño óptimo para la solicitud, pero no intente verificar sus suposiciones. </li><li>  Acepta la primera solicitud de trabajo, sin saber qué tan cerca está de lo óptimo. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465975/">https://habr.com/ru/post/465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465959/index.html">Árbol genealógico dentro de git</a></li>
<li><a href="../465961/index.html">Aprenda marketing en Internet por su cuenta: más de 50 cursos gratuitos</a></li>
<li><a href="../465963/index.html">Biografía Salarial en Alemania 2019</a></li>
<li><a href="../465969/index.html">La corrección política penetra a Rusia a través de libros sobre diseño de chips en SystemVerilog para no principiantes</a></li>
<li><a href="../465973/index.html">Los 10 informes de video más populares del 404fest 2018</a></li>
<li><a href="../465977/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Día 31. CDP, Syslog y NTP</a></li>
<li><a href="../465979/index.html">Recuerde que todo ^ W es justo lo que necesita. Experiencia con Anki. Parte 1 (introductoria, penúltima)</a></li>
<li><a href="../465981/index.html">Mi experiencia de administración de IBM DB2 Express-C cuando se usa con 1C: Enterprise</a></li>
<li><a href="../465983/index.html">Intel Comet Lake: un poco de 14 nm en la décima generación</a></li>
<li><a href="../465985/index.html">Aceleramos el procesamiento distribuido de gráficos grandes utilizando estructuras de datos probabilísticas y no solo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>