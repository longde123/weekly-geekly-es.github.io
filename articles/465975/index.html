<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游냇 游뚺游 游땚 Gu칤a SQL: C칩mo escribir mejor las consultas (Parte 2) 游 游빃游낖 游븾游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuaci칩n del art칤culo Gu칤a de SQL: C칩mo escribir mejor las consultas (Parte 1) 

 De solicitud a planes de ejecuci칩n 
 Saber que los antipatrones ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu칤a SQL: C칩mo escribir mejor las consultas (Parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Continuaci칩n del art칤culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu칤a de SQL: C칩mo escribir mejor las consultas (Parte 1)</a> <br><br><h2>  De solicitud a planes de ejecuci칩n </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Saber que los antipatrones no son est치ticos y evolucionan a medida que crece como desarrollador de SQL, y el hecho de que hay muchas cosas a tener en cuenta al pensar en alternativas tambi칠n significa que evitar antipatrones y reescribir consultas puede ser bastante dif칤cil tarea  Cualquier ayuda puede ser 칰til, por lo que un enfoque m치s estructurado para la optimizaci칩n de consultas utilizando algunas herramientas puede ser m치s efectivo. <br><br>  Tambi칠n debe tenerse en cuenta que algunos de los antipatrones mencionados en la 칰ltima secci칩n tienen sus ra칤ces en problemas de rendimiento, como los operadores <code>AND</code> , <code>OR</code> y <code>NOT</code> y su ausencia al usar 칤ndices.  Pensar en el rendimiento requiere no solo un enfoque m치s estructurado, sino tambi칠n m치s profundo. <br><br>  Sin embargo, este enfoque estructurado y profundo se basar치 principalmente en el plan de consulta, que, como recordar치, es el resultado de una consulta analizada primero en un "치rbol de an치lisis" o "치rbol de an치lisis" y determina exactamente qu칠 algoritmo utilizado para cada operaci칩n y c칩mo se coordina su ejecuci칩n. <br><a name="habracut"></a><br><h2>  Optimizaci칩n de consultas </h2><br>  Como ley칩 en la introducci칩n, es posible que deba verificar y configurar planes que el optimizador compila manualmente.  En tales casos, deber치 analizar su solicitud nuevamente mirando el plan de solicitud. <br><br>  Para acceder a este plan, debe utilizar las herramientas proporcionadas por el sistema de gesti칩n de bases de datos.  Las siguientes herramientas pueden estar a su disposici칩n: <br><br><ul><li>  Algunos paquetes contienen herramientas que generan una representaci칩n gr치fica del plan de consulta.  Considere el siguiente ejemplo: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  Otras herramientas proporcionar치n una descripci칩n textual del plan de consulta.  Un ejemplo es la declaraci칩n <code>EXPLAIN PLAN</code> en Oracle, pero el nombre de la instrucci칩n depende del DBMS con el que est칠 trabajando.  En otro lugar puede encontrar <code>EXPLAIN</code> (MySQL, PostgreSQL) o <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Tenga en cuenta</b> que cuando trabaje con PostgreSQL, puede hacer una distinci칩n entre <code>EXPLAIN</code> , donde simplemente obtiene una descripci칩n que le dice c칩mo el planificador intenta ejecutar la consulta sin ejecutarla, mientras que <code>EXPLAIN ANALYZE</code> realmente ejecuta la consulta y le devuelve el an치lisis. Planes de solicitud esperados y reales.  En t칠rminos generales, un plan de ejecuci칩n real es un plan en el que una solicitud se ejecuta realmente, mientras que un plan de ejecuci칩n de evaluaci칩n determina lo que har치 sin cumplir la solicitud.  Aunque esto es l칩gicamente equivalente, el plan de ejecuci칩n real es mucho m치s 칰til ya que contiene informaci칩n adicional y estad칤sticas sobre lo que realmente sucedi칩 cuando se ejecut칩 la solicitud. <br><br>  En el resto de esta secci칩n, aprender치 m치s sobre <code>EXPLAIN</code> y <code>ANALYZE</code> , as칤 como tambi칠n c칩mo usarlos para obtener m치s informaci칩n sobre el plan de consulta y su posible rendimiento.  Para hacer esto, comience con algunos ejemplos en los que trabajar치 con dos tablas: <code>one_million</code> y <code>half_million</code> . <br><br>  Puede obtener la informaci칩n actual de la tabla <code>one_million</code> usando <code>EXPLAIN</code> ;  Aseg칰rese de colocarlo directamente encima de la solicitud y, despu칠s de ejecutarlo, le devolver치 el plan de consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  En este caso, ver치 que el costo de la solicitud es <code>0.00..18584.82</code> , y el n칰mero de filas es <code>1025082</code> .  El ancho del n칰mero de columnas es <code>36</code> . <br><br>  Adem치s, puede actualizar las estad칤sticas usando <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Adem치s de <code>EXPLAIN</code> y <code>ANALYZE</code> , tambi칠n puede obtener el tiempo de ejecuci칩n real con <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  La desventaja de usar <code>EXPLAIN ANALYZE</code> es que la consulta se ejecuta realmente, 춰as칤 que tenga cuidado con esto! <br><br>  Hasta ahora, todos los algoritmos que ha visto son <code>Seq Scan</code> (Sequential Scan) o Full Table Scan: este es un escaneo realizado en una base de datos donde cada fila de la tabla escaneada se lee en orden serial y las columnas encontradas se verifican para cumplimiento de la condici칩n o no.  En t칠rminos de rendimiento, los escaneos secuenciales definitivamente no son el mejor plan de ejecuci칩n porque todav칤a est치 haciendo un escaneo completo de la tabla.  Sin embargo, esto no es tan malo cuando la tabla no cabe en la memoria: las lecturas secuenciales son bastante r치pidas incluso en discos lentos. <br><br>  Aprender치 m치s sobre esto m치s adelante cuando hablemos sobre el escaneo de 칤ndice. <br><br>  Sin embargo, hay otros algoritmos.  Tome, por ejemplo, este plan de consulta para una conexi칩n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  춰Ves que el optimizador de consultas eligi칩 <code>Hash Join</code> aqu칤!  Recuerde esta operaci칩n, ya que la necesitar치 para evaluar la complejidad temporal de su solicitud.  Por ahora, tenga en cuenta que no hay 칤ndice en <code>half_million.counter</code> , que agregamos en el siguiente ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Ver치 que al crear el 칤ndice, el optimizador de consultas ahora ha decidido utilizar la <code>Merge join</code> al escanear el <code>Index Scan</code> 칤ndice. <br><br>  <b>Observe</b> la diferencia entre los escaneos de 칤ndice y los escaneos de tabla completa o los escaneos secuenciales: el primero, tambi칠n llamado "escaneos de tabla", escanea los datos o las p치ginas de 칤ndice para encontrar los registros correspondientes, mientras que el segundo escanea cada fila de la tabla. <br><br>  Ver치 que el tiempo de ejecuci칩n general ha disminuido y el rendimiento deber칤a ser mejor, pero hay dos escaneos de 칤ndice, lo que hace que la memoria sea m치s importante aqu칤, especialmente si la tabla no encaja en ella.  En tales casos, primero debe realizar una exploraci칩n de 칤ndice completa, que se realiza mediante lecturas secuenciales r치pidas y no es un problema, pero luego tiene muchas operaciones de lectura aleatoria para seleccionar filas por valor de 칤ndice.  Estas son operaciones de lectura aleatorias que suelen ser varios 칩rdenes de magnitud m치s lentas que las secuenciales.  En estos casos, un escaneo completo de la tabla es m치s r치pido que un escaneo de 칤ndice completo. <br><br>  <b>Sugerencia:</b> Si desea obtener m치s informaci칩n sobre EXPLICAR o considerar ejemplos con m치s detalle, considere leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Explicaci칩n de comprensi칩n de</a> Guillaume Lelarge. <br><br><h2>  Complejidad del tiempo y Big O </h2><br>  Ahora que ha revisado brevemente el plan de consulta, puede comenzar a profundizar y pensar en el rendimiento en t칠rminos m치s formales utilizando la teor칤a de la complejidad computacional.  Este es un campo de la inform치tica te칩rica, que, entre otras cosas, se centra en la clasificaci칩n de problemas computacionales seg칰n su complejidad;  Estos problemas computacionales pueden ser algoritmos, pero tambi칠n consultas. <br><br>  Sin embargo, para las consultas, no se clasifican necesariamente seg칰n su complejidad, sino que dependen del tiempo requerido para completarlas y obtener resultados.  Esto se llama complejidad de tiempo, y puede usar la notaci칩n O grande para formular o medir este tipo de complejidad. <br><br>  Con la designaci칩n O grande, expresa el tiempo de ejecuci칩n en t칠rminos de qu칠 tan r치pido crece en relaci칩n con la entrada, ya que la entrada se vuelve arbitrariamente grande.  La notaci칩n O grande excluye los coeficientes y los miembros de un orden inferior, por lo que puede centrarse en la parte importante del tiempo de ejecuci칩n de su consulta: su tasa de crecimiento.  Cuando se expresan de esta manera, descartando los coeficientes y t칠rminos de un orden inferior, dicen que la complejidad del tiempo se describe asint칩ticamente.  Esto significa que el tama침o de entrada va al infinito. <br><br>  En un lenguaje de base de datos, la complejidad determina cu치nto tiempo lleva completar una consulta a medida que aumenta el tama침o de las tablas de datos y, por lo tanto, la base de datos crece. <br><br>  <b>Tenga en cuenta</b> que el tama침o de su base de datos aumenta no solo por el aumento en la cantidad de datos en las tablas, sino que el hecho de que haya 칤ndices tambi칠n juega un papel importante en el tama침o. <br><br>  Estimando la complejidad de tiempo de su plan de consulta <br><br>  Como viste anteriormente, el plan de ejecuci칩n, entre otras cosas, determina qu칠 algoritmo se usa para cada operaci칩n, lo que te permite expresar l칩gicamente cada tiempo de ejecuci칩n de consulta como una funci칩n del tama침o de la tabla incluida en el plan de consulta, que se llama funci칩n de complejidad.  En otras palabras, puede usar la notaci칩n O grande y el plan de ejecuci칩n para evaluar la complejidad y el rendimiento de la consulta. <br><br>  En las siguientes secciones, obtendr치 una visi칩n general de los cuatro tipos de complejidad temporal, y ver치 algunos ejemplos de c칩mo la complejidad temporal de las consultas puede variar seg칰n el contexto en el que se ejecute. <br><br>  Sugerencia: 춰los 칤ndices son parte de esta historia! <br><br>  <b>Sin embargo, debe tenerse en cuenta</b> que hay diferentes tipos de 칤ndices, diferentes planes de ejecuci칩n y diferentes implementaciones para diferentes bases de datos, por lo que las dificultades temporales que se enumeran a continuaci칩n son muy generales y pueden variar seg칰n la configuraci칩n espec칤fica. <br><br><h3>  O (1): tiempo constante </h3><br>  Dicen que un algoritmo funciona en tiempo constante si necesita la misma cantidad de tiempo, independientemente del tama침o de los datos de entrada.  Cuando se trata de una consulta, se ejecutar치 en tiempo constante si se requiere la misma cantidad de tiempo independientemente del tama침o de la tabla. <br><br>  Este tipo de consulta no es realmente com칰n, pero aqu칤 hay un ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  La complejidad del tiempo es constante, ya que se selecciona una fila arbitraria de la tabla.  Por lo tanto, el per칤odo de tiempo no debe depender del tama침o de la tabla. <br><br><h3>  Tiempo lineal: O (n) </h3><br>  Dicen que el algoritmo funciona en tiempo lineal, si su tiempo de ejecuci칩n es directamente proporcional al tama침o de los datos de entrada, es decir, el tiempo aumenta linealmente con el tama침o de los datos de entrada.  Para las bases de datos, esto significa que el tiempo de ejecuci칩n ser치 directamente proporcional al tama침o de la tabla: a medida que aumenta el n칰mero de filas en la tabla, aumenta el tiempo de ejecuci칩n de la consulta. <br><br>  Un ejemplo es una consulta con una <code>WHERE</code> para una columna no indexada: se requerir치 un escaneo completo de la tabla o un <code>Seq Scan</code> , lo que conducir치 a una complejidad de tiempo O (n).  Esto significa que cada l칤nea debe leerse para encontrar la l칤nea con el identificador (ID) deseado.  No tiene ninguna restricci칩n en absoluto, por lo que debe contar cada l칤nea, incluso si la primera l칤nea coincide con la condici칩n. <br><br>  Considere tambi칠n el siguiente ejemplo de consulta, que tendr치 complejidad O (n) si no hay 칤ndice en el campo <code>i_id</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  Lo anterior tambi칠n significa que otras consultas, como consultas para calcular el n칰mero de filas <code>COUNT (*) FROM TABLE;</code>  tendr치 una complejidad de tiempo <i>O (n)</i> , ya que se requerir치 un escaneo completo de la tabla porque el n칰mero total de filas no se ha guardado para la tabla.  De lo contrario, la complejidad temporal ser칤a similar a <i>O (1)</i> . <br></li></ul><br>  El tiempo de ejecuci칩n lineal est치 estrechamente relacionado con el tiempo de ejecuci칩n de los planes que tienen uniones de tabla.  Aqu칤 hay algunos ejemplos: <br><br><ul><li>  La combinaci칩n hash tiene la complejidad esperada de O (M + N). El algoritmo cl치sico de combinaci칩n hash para unir internamente dos tablas primero prepara la tabla hash de la tabla m치s peque침a.  Las entradas de la tabla hash consisten en un atributo de conexi칩n y su cadena.  Se accede a la tabla hash aplicando la funci칩n hash al atributo de conexi칩n.  Una vez que se crea la tabla hash, se escanea una tabla grande y las filas correspondientes de la tabla m치s peque침a se encuentran buscando en la tabla hash. </li><li>  Las combinaciones de combinaci칩n generalmente tienen complejidad O (M + N), pero depender치 en gran medida de los 칤ndices de la columna de combinaci칩n y, si no hay 칤ndice, si las filas se ordenan de acuerdo con las claves utilizadas en la combinaci칩n: <ul><li>  Si ambas tablas se ordenan seg칰n las claves utilizadas en la combinaci칩n, la consulta tendr치 una complejidad temporal de O (M + N). </li><li>  Si ambas tablas tienen un 칤ndice para columnas unidas, entonces el 칤ndice ya admite estas columnas en orden y no es necesario ordenarlas.  La dificultad ser치 O (M + N). </li><li>  Si ninguna de las tablas tiene un 칤ndice en las columnas conectadas, primero debe ordenar ambas tablas, para que la complejidad se vea como O (M log M + N log N). </li><li>  Si solo una de las tablas tiene un 칤ndice en las columnas conectadas, solo la tabla que no tiene un 칤ndice debe clasificarse antes de que ocurra el paso de uni칩n, de modo que la complejidad se vea como O (M + N log N). </li></ul></li><li>  Para combinaciones anidadas, la complejidad suele ser O (MN).  Esta combinaci칩n es efectiva cuando una o ambas tablas son extremadamente peque침as (por ejemplo, menos de 10 registros), lo cual es una situaci칩n muy com칰n al evaluar consultas, ya que algunas subconsultas se escriben para devolver solo una fila. </li></ul><br>  <b>Recuerde: una</b> combinaci칩n anidada es una combinaci칩n que compara cada registro en una tabla con cada registro en otra. <br><br><h3>  Tiempo logar칤tmico: O (log (n)) </h3><br>  Se dice que un algoritmo funciona en tiempo logar칤tmico si su tiempo de ejecuci칩n es proporcional al logaritmo del tama침o de entrada;  Para las consultas, esto significa que se ejecutar치n si el tiempo de ejecuci칩n es proporcional al logaritmo del tama침o de la base de datos. <br><br>  Esta complejidad de tiempo logar칤tmico es v치lida para planes de consulta en los que se escanea un <code>Index Scan</code> o un 칤ndice agrupado.  Un 칤ndice agrupado es un 칤ndice donde el nivel de 칤ndice final contiene las filas reales de la tabla.  Un 칤ndice agrupado es similar a cualquier otro 칤ndice: se define en una o m치s columnas.  Forman una clave de 칤ndice.  La clave de agrupaci칩n son las columnas clave de un 칤ndice agrupado.  Escanear un 칤ndice agrupado es b치sicamente la operaci칩n de leer su DBMS para una fila o filas de arriba a abajo en un 칤ndice agrupado. <br><br>  Considere el siguiente ejemplo de consulta, donde hay un 칤ndice para <code>i_id</code> y que generalmente resulta en complejidad O (log (n)): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Tenga en cuenta que sin un 칤ndice, la complejidad del tiempo ser칤a O (n). <br><br><h3>  Tiempo cuadr치tico: O (n ^ 2) </h3><br>  Se cree que el algoritmo se ejecuta en tiempo cuadr치tico, si su tiempo de ejecuci칩n es proporcional al cuadrado del tama침o de entrada.  Nuevamente, para las bases de datos, esto significa que el tiempo de ejecuci칩n de la consulta es proporcional al cuadrado del tama침o de la base de datos. <br><br>  Un posible ejemplo de una consulta de complejidad de tiempo cuadr치tico es el siguiente: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  La complejidad m칤nima puede ser O (n log (n)), pero la complejidad m치xima puede ser O (n ^ 2) seg칰n la informaci칩n de 칤ndice de los atributos de conexi칩n. <br><br>  Para resumir, tambi칠n puede echar un vistazo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a la siguiente hoja de trucos</a> para evaluar el rendimiento de la consulta en funci칩n de su complejidad temporal y su efectividad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  Ajuste de SQL </h2><br>  Dado el plan de ejecuci칩n de la consulta y la complejidad del tiempo, puede personalizar a칰n m치s su consulta SQL.  Puede comenzar centr치ndose en los siguientes puntos: <br><br><ul><li>  Reemplace los escaneos innecesarios de tablas completas con escaneos de 칤ndice; </li><li>  Aseg칰rese de aplicar el orden de uni칩n 칩ptimo. </li><li>  Aseg칰rese de que los 칤ndices se utilicen de manera 칩ptima.  Y </li><li>  Se utiliza el almacenamiento en cach칠 de escaneos de texto completo de tablas peque침as (escaneos de tabla completa de cach칠 de tabla peque침a). </li></ul><br><h2>  Uso adicional de SQL </h2><br>  Felicidades  Ha llegado al final de este art칤culo, que acaba de darle un peque침o vistazo al rendimiento de las consultas SQL.  Espero que tenga m치s informaci칩n sobre los antipatrones, el optimizador de consultas y las herramientas que puede utilizar para analizar, evaluar e interpretar la complejidad de su plan de consultas.  Sin embargo, 춰todav칤a tienes mucho por descubrir!  Si desea saber m치s, lea el libro "Sistemas de gesti칩n de bases de datos" de R. Ramakrishnan y J. Gehrke. <br><br>  Finalmente, no quiero negarle StackOverflow en esta cita: <br><blockquote>  Mi antipatr칩n favorito no verifica tus solicitudes. <br><br>  Sin embargo, es aplicable cuando: <br><br><ul><li>  Su consulta proporciona m치s de una tabla. </li><li>  Cree que tiene el dise침o 칩ptimo para la solicitud, pero no intente verificar sus suposiciones. </li><li>  Acepta la primera solicitud de trabajo, sin saber qu칠 tan cerca est치 de lo 칩ptimo. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465975/">https://habr.com/ru/post/465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465959/index.html">츼rbol geneal칩gico dentro de git</a></li>
<li><a href="../465961/index.html">Aprenda marketing en Internet por su cuenta: m치s de 50 cursos gratuitos</a></li>
<li><a href="../465963/index.html">Biograf칤a Salarial en Alemania 2019</a></li>
<li><a href="../465969/index.html">La correcci칩n pol칤tica penetra a Rusia a trav칠s de libros sobre dise침o de chips en SystemVerilog para no principiantes</a></li>
<li><a href="../465973/index.html">Los 10 informes de video m치s populares del 404fest 2018</a></li>
<li><a href="../465977/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D칤a 31. CDP, Syslog y NTP</a></li>
<li><a href="../465979/index.html">Recuerde que todo ^ W es justo lo que necesita. Experiencia con Anki. Parte 1 (introductoria, pen칰ltima)</a></li>
<li><a href="../465981/index.html">Mi experiencia de administraci칩n de IBM DB2 Express-C cuando se usa con 1C: Enterprise</a></li>
<li><a href="../465983/index.html">Intel Comet Lake: un poco de 14 nm en la d칠cima generaci칩n</a></li>
<li><a href="../465985/index.html">Aceleramos el procesamiento distribuido de gr치ficos grandes utilizando estructuras de datos probabil칤sticas y no solo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>