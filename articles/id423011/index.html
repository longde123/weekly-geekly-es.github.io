<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛 🚔 🏣 Manajemen Layanan Mikro dengan Kubernetes dan Istio 🚅 💇 🐏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebuah cerita pendek tentang kelebihan dan kekurangan dari layanan-layanan microser, konsep Service Mesh dan alat-alat Google yang memungkinkan Anda u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Layanan Mikro dengan Kubernetes dan Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/423011/">  Sebuah cerita pendek tentang kelebihan dan kekurangan dari layanan-layanan microser, konsep Service Mesh dan alat-alat Google yang memungkinkan Anda untuk menjalankan aplikasi-aplikasi layanan-mikro tanpa menyumbat kepala Anda dengan pengaturan kebijakan, akses dan sertifikat yang tak ada habisnya dan dengan cepat menemukan kesalahan yang bersembunyi bukan dalam kode, tetapi dalam logika microservice. <br><br><img src="https://habrastorage.org/webt/os/ta/tg/ostatgvg9ytjgcicnno567t2x_q.jpeg"><br><br>  Artikel ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Craig Box</a> pada konferensi DevOops tahun lalu tahun 2017 kami. Video dan terjemahan dari laporan tersebut sedang terpotong. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RnBXQpo6Mjs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Craig Box (Craig Box, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> ) - DevRel Google yang bertanggung jawab atas layanan microservices dan Kubernetes dan Istio.  Kisahnya saat ini adalah tentang mengelola layanan microser pada platform ini. <br><br>  Mari kita mulai dengan konsep yang relatif baru yang disebut Service Mesh.  Istilah ini digunakan untuk menggambarkan jaringan Microsoft yang berinteraksi yang membentuk aplikasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91b/eb1/7c6/91beb17c6f784bdf2b8d433b44512285.jpg"><br><br>  Pada level tinggi, kita melihat jaringan sebagai pipa yang hanya memindahkan bit.  Kami tidak ingin khawatir tentang mereka atau, misalnya, tentang alamat MAC dalam aplikasi, tetapi kami berusaha untuk memikirkan tentang layanan dan koneksi yang mereka butuhkan.  Jika Anda melihat dari sudut pandang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSI</a> , maka kami memiliki jaringan tingkat ketiga (dengan fungsi untuk menentukan rute dan pengalamatan logis), tetapi kami ingin berpikir tentang ketujuh (dengan fungsi akses ke layanan jaringan). <br><br>  Seperti apakah seharusnya jaringan tingkat tujuh yang sesungguhnya?  Mungkin kita ingin melihat sesuatu seperti jejak lalu lintas di sekitar layanan bermasalah.  Sehingga Anda dapat terhubung ke layanan, dan pada saat yang sama tingkat model dinaikkan dari tingkat ketiga.  Kami ingin mendapatkan ide tentang apa yang terjadi di cluster, menemukan dependensi yang tidak diinginkan, mencari tahu akar penyebab kegagalan.  Kita juga perlu menghindari overhead yang tidak perlu, misalnya, menghubungkan dengan latensi tinggi atau menghubungkan ke server dengan cache yang dingin atau tidak sepenuhnya menghangat. <br><br>  Kita harus yakin bahwa lalu lintas antar layanan dilindungi dari serangan sepele.  Diperlukan otentikasi mutual TLS, tetapi tanpa menyematkan modul yang sesuai di setiap aplikasi yang kami tulis.  Penting untuk dapat mengontrol apa yang mengelilingi aplikasi kita tidak hanya pada tingkat koneksi, tetapi juga pada tingkat yang lebih tinggi. <br><br>  Service Mesh adalah lapisan yang memungkinkan kita untuk memecahkan masalah di atas dalam lingkungan layanan mikro. <br><br><h2>  Monolith dan microservices: pro dan kontra </h2><br>  Tetapi pertama-tama kita bertanya pada diri sendiri, mengapa kita harus menyelesaikan masalah ini sama sekali?  Bagaimana kami melakukan pengembangan perangkat lunak sebelumnya?  Kami memiliki aplikasi yang terlihat seperti ini - seperti monolit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/385/111/8c63851119c38df240c57cf399a8c344.jpg"><br><br>  Sangat bagus: semua kode dalam tampilan penuh.  Mengapa tidak terus menggunakan pendekatan ini? <br>  Ya, karena monolit memiliki masalah sendiri.  Kesulitan utama adalah bahwa jika kita ingin membangun kembali aplikasi ini, kita harus menggunakan kembali setiap modul, bahkan jika tidak ada yang berubah.  Kami dipaksa untuk membuat aplikasi dalam bahasa yang sama atau dalam bahasa yang kompatibel, bahkan jika tim yang berbeda mengerjakannya.  Bahkan, bagian-bagian individual tidak dapat diuji secara independen satu sama lain.  Saatnya untuk mengubahnya, saatnya untuk layanan microser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d19/ccb/fd5/d19ccbfd59552751e2171ba6b89ac9bc.jpg"><br><br>  Jadi, kami membagi monolit menjadi beberapa bagian.  Anda mungkin memperhatikan bahwa dalam contoh ini kami menghapus beberapa dependensi yang tidak perlu dan berhenti menggunakan metode internal yang dipanggil dari modul lain.  Kami menciptakan layanan dari model yang digunakan sebelumnya, menciptakan abstraksi dalam kasus di mana kami perlu mempertahankan keadaan.  Misalnya, setiap layanan harus memiliki status independen sehingga ketika Anda mengaksesnya, Anda tidak perlu khawatir tentang apa yang terjadi di seluruh lingkungan kami. <br><br>  Apa hasilnya? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4da/729/cd24da7292ffd1e23eb4e56ca2842c5f.jpg"><br><br>  Kami meninggalkan dunia aplikasi raksasa untuk mendapatkan apa yang benar-benar tampak hebat.  Kami mempercepat pengembangan, berhenti menggunakan metode internal, menciptakan layanan, dan sekarang kami dapat menskalakannya secara mandiri, menjadikan layanan lebih besar tanpa harus menggabungkan semua yang lain.  Tetapi berapa harga perubahan yang telah kita hilangkan? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b4/234/b49/2b4234b49b4dcb5f79840391ee0f5a36.jpg"><br><br>  Kami memiliki panggilan yang andal di dalam aplikasi karena Anda cukup memanggil fungsi atau modul.  Kami mengganti panggilan tepercaya di dalam modul dengan panggilan prosedur jarak jauh yang tidak dapat diandalkan.  Tetapi layanan di sisi lain tidak selalu tersedia. <br><br>  Kami aman, menggunakan proses yang sama di dalam mesin yang sama.  Sekarang kami terhubung ke layanan yang mungkin ada pada mesin yang berbeda dan pada jaringan yang tidak terpercaya. <br><br>  Dalam pendekatan baru pada jaringan, keberadaan pengguna lain yang mencoba untuk terhubung ke layanan dimungkinkan.  Penundaan meningkat, dan pada saat yang sama, kemampuan pengukurannya menurun.  Sekarang kita memiliki koneksi selangkah demi selangkah di semua layanan yang membuat satu panggilan modul, dan kita tidak bisa lagi hanya melihat aplikasi di debugger dan mencari tahu apa yang sebenarnya menyebabkan kegagalan.  Dan masalah ini perlu dipecahkan.  Jelas, kita membutuhkan seperangkat alat baru. <br><br><h2>  Apa yang bisa dilakukan? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/fd0/857/5a9/fd08575a99e8a4f4baf64d916eef077b.jpg"><br><br>  Ada beberapa opsi.  Kita dapat mengambil aplikasi kita dan mengatakan bahwa jika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RPC</a> tidak berfungsi pertama kali, maka Anda harus mencoba lagi, dan kemudian lagi dan lagi.  Tunggu sebentar dan coba lagi atau tambahkan Jitter.  Kami juga dapat menambahkan jejak entri - keluar untuk mengatakan bahwa panggilan dimulai dan berakhir, yang bagi saya setara dengan debugging.  Anda dapat menambahkan infrastruktur untuk menyediakan otentikasi koneksi dan mengajarkan semua aplikasi kami cara bekerja dengan enkripsi TLS.  Kami harus menanggung beban isi masing-masing tim dan terus-menerus mengingat berbagai masalah yang mungkin muncul di perpustakaan SSL. <br><br>  Mempertahankan konsistensi di berbagai platform adalah tugas yang tidak berterima kasih.  Saya ingin ruang antara aplikasi menjadi masuk akal, sehingga ada kemungkinan pelacakan.  Kita juga memerlukan kemampuan untuk mengubah konfigurasi saat runtime agar tidak mengkompilasi ulang atau memulai kembali aplikasi untuk migrasi.  Wishlist ini dan mengimplementasikan Service Mesh. <br><br><h2>  Isstio </h2><br>  Bicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc8/cdf/0fe/fc8cdf0fe52823fcd092a2dd8de2aeb6.jpg"><br><br>  Istio adalah kerangka kerja lengkap untuk menghubungkan, mengelola dan memantau arsitektur layanan mikro.  Istio dirancang untuk bekerja di atas Kubernetes.  Dia sendiri tidak menyebarkan perangkat lunak dan tidak peduli untuk membuatnya tersedia di mesin yang kami gunakan untuk tujuan ini dengan wadah di Kubernetes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e05/1e8/ddbe051e8e8f90273b1bd686d1f5c90e.jpg"><br><br>  Pada gambar, kita melihat tiga bagian berbeda dari mesin dan blok yang membentuk layanan microser kami.  Kami memiliki cara untuk mengelompokkan mereka menggunakan mekanisme yang disediakan oleh Kubernetes.  Kami dapat menargetkan dan mengatakan bahwa grup tertentu, yang mungkin memiliki penskalaan otomatis, dilampirkan ke layanan web atau mungkin memiliki metode penyebaran lainnya, akan berisi layanan web kami.  Dalam hal ini, kita tidak perlu memikirkan mesin, kita beroperasi dalam hal tingkat akses ke layanan jaringan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/45b/f3c/96645bf3c0ff9d2104622a84edcafeeb.png"><br><br>  Situasi ini dapat direpresentasikan dalam bentuk diagram.  Pertimbangkan contoh ketika kita memiliki mekanisme yang melakukan pemrosesan gambar.  Pengguna di sebelah kiri adalah lalu lintas dari mana datang kepada kami di microservice. <br><br>  Untuk menerima pembayaran dari pengguna, kami memiliki layanan pembayaran mikro terpisah yang memanggil API eksternal yang terletak di luar cluster. <br><br>  Untuk memproses login pengguna, kami menyediakan microservice otentikasi, dan telah menyatakan disimpan lagi di luar cluster kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database Cloud SQL</a> . <br><br>  Apa yang dilakukan Istio?  Istio meningkatkan Kubernetes.  Anda menginstalnya menggunakan fungsi alfa di Kubernet yang disebut Initializer.  Saat Anda menggunakan perangkat lunak, kubernetes akan melihatnya dan bertanya apakah kami ingin mengubah dan menambahkan wadah lain di dalam masing-masing kubernet.  Wadah ini akan menangani jalur dan perutean, menyadari semua perubahan aplikasi. <br><br>  Beginilah tampilan sirkuit dengan Istio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/398/f41/c6d/398f41c6dcbe3e0dea4741e71204d7bd.jpg"><br><br>  Kami memiliki mesin eksternal yang menyediakan proksi masuk dan keluar untuk lalu lintas di layanan tertentu.  Kita dapat membongkar fungsi yang sudah kita bicarakan.  Kita tidak perlu mengajarkan aplikasi bagaimana melakukan telemetri atau melacak menggunakan TLS.  Tetapi kita dapat menambahkan hal-hal lain di dalamnya: gangguan otomatis, batas kecepatan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelepasan kenari</a> . <br><br>  Semua lalu lintas sekarang akan melalui server proxy pada mesin eksternal, dan tidak langsung ke layanan.  Kubernetes melakukan semuanya pada alamat IP yang sama.  Kami akan dapat mencegat lalu lintas yang akan pergi ke depan atau mengakhiri layanan. <br><br>  Proksi eksternal yang digunakan Istio disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utusan</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a00/3ed/04f/a003ed04fc566d4f27b1e5df70e3ae21.jpg"><br><br>  Utusan sebenarnya lebih tua dari Istio, dikembangkan di Lyft.  Telah bekerja dalam produksi selama lebih dari setahun, meluncurkan seluruh infrastruktur layanan-mikro.  Kami memilih Utusan untuk proyek Istio bekerja sama dengan komunitas.  Jadi, Google, IBM dan LYFT adalah tiga perusahaan yang masih mengerjakannya. <br><br>  Utusan ditulis dalam C ++ 11. Ini telah diproduksi selama lebih dari 18 bulan sebelum menjadi proyek open source.  Tidak akan membutuhkan banyak sumber daya saat Anda menghubungkannya ke layanan Anda. <br><br>  Berikut adalah beberapa hal yang dapat dilakukan Utusan.  Ini adalah pembuatan server proxy untuk HTTP, termasuk HTTP / 2 dan protokol yang didasarkan padanya, seperti gRPC.  Itu juga dapat meneruskan ke protokol lain di tingkat biner.  Utusan mengontrol zona infrastruktur Anda sehingga Anda dapat membuat bagian Anda otonom.  Itu dapat menangani sejumlah besar koneksi jaringan dengan coba lagi dan tunggu.  Anda dapat mengatur sejumlah upaya untuk menyambung ke server sebelum menghentikan panggilan dan mengirimkan informasi ke server Anda bahwa layanan ini tidak merespons. <br><br>  Tidak perlu khawatir memuat ulang aplikasi untuk menambahkan konfigurasi ke dalamnya.  Anda cukup menghubungkannya menggunakan API yang sangat mirip dengan kubernetes dan mengubah konfigurasi saat runtime. <br><br>  Tim Istio telah memberikan kontribusi besar pada Platform Utusan UpStream.  Misalnya, peringatan kesalahan injeksi.  Kami memungkinkan untuk melihat bagaimana aplikasi berperilaku jika melebihi jumlah permintaan untuk objek yang gagal.  Dan juga menerapkan fungsi tampilan grafis dan pemisahan lalu lintas untuk menangani kasus ketika penyebaran kenari digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/068/0e1/351/0680e13511f2d5dc5eeac4bada02c05c.jpg"><br><br>  Gambar tersebut menunjukkan seperti apa arsitektur sistem Istio.  Kami hanya akan mengambil dua layanan microser yang disebutkan sebelumnya.  Pada akhirnya, dalam diagram, semuanya sangat mirip dengan jaringan yang ditentukan perangkat lunak.  Dari server proxy Utusan, yang kami gunakan dengan aplikasi, lalu lintas ditransfer menggunakan tabel IP di namespace.  Panel kontrol bertanggung jawab untuk mengelola konsol, tetapi tidak memproses lalu lintas itu sendiri. <br>  Kami memiliki tiga komponen.  Pilot, yang membuat konfigurasi, melihat aturan yang dapat diubah menggunakan API untuk panel kontrol Istio, dan kemudian memperbarui Utusan sehingga berperilaku seperti layanan penemuan cluster.  Istio-Auth berfungsi sebagai otoritas sertifikasi dan mengirimkan sertifikat TLS ke proksi.  Aplikasi tidak memerlukan SSL, mereka dapat terhubung melalui HTTP, dan proksi akan menangani semua ini untuk Anda. <br><br>  Mixer memproses permintaan untuk memastikan bahwa Anda mematuhi kebijakan keamanan, dan kemudian mengirimkan informasi telemetri.  Tanpa membuat perubahan apa pun pada aplikasi, kita bisa melihat semua yang terjadi di dalam kluster kita. <br><br><h2>  Manfaat Istio </h2><br>  Jadi, mari kita bicara lebih detail tentang lima hal yang akan kita dapatkan dari Istio.  Pertama-tama, pertimbangkan <b>manajemen lalu lintas</b> .  Kita dapat memisahkan kontrol lalu lintas dari penskalaan infrastruktur, jadi sebelumnya kita bisa melakukan sekitar 20 contoh aplikasi dan 19 di antaranya ada di versi lama, dan satu di versi baru, yaitu, 5% dari lalu lintas akan di versi baru.  Dengan Istio, kami dapat menggunakan sejumlah instance yang kami butuhkan, dan pada saat yang sama menunjukkan persentase lalu lintas yang harus dikirim ke versi baru.  Aturan pemisahan yang sederhana. <br><br>  Semuanya dapat diprogram dengan cepat menggunakan aturan.  Utusan akan diperbarui secara berkala ketika konfigurasi berubah, dan ini tidak akan menyebabkan pemadaman layanan.  Karena kami bekerja di tingkat akses ke layanan jaringan, kami dapat melihat paket-paket, dan dalam hal ini ada peluang untuk masuk ke agen pengguna, yang terletak di tingkat ketiga jaringan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/1a1/7d5/8101a17d596613c7cc6871ce0f7d238a.png"><br><br>  Misalnya, kita dapat mengatakan bahwa lalu lintas apa pun dari iPhone mengikuti aturan yang berbeda, dan kami akan mengarahkan sebagian kecil lalu lintas ke versi baru, yang ingin kami uji untuk perangkat tertentu.  Layanan panggilan internal Microsoft dapat menentukan versi spesifik mana yang perlu disambungkan, dan Anda dapat mentransfernya ke versi lain, misalnya 2.0. <br><br>  Keuntungan kedua adalah <b>transparansi</b> .  Saat Anda memiliki tampilan di dalam gugus, Anda bisa memahami cara membuatnya.  Kita tidak perlu membuat alat untuk metrik dalam proses pengembangan.  Metrik sudah ada di setiap komponen. <br><br>  Beberapa percaya bahwa cukup untuk menyimpan catatan log untuk pemantauan.  Tetapi pada kenyataannya, yang kita butuhkan adalah memiliki seperangkat indikator universal yang dapat dimasukkan ke layanan pemantauan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/099/627/ab5/099627ab5e7b0615bb2e3725ce118160.jpg"><br><br>  Beginilah tampilan bilah alat Istio yang dibuat menggunakan layanan Prometheus.  Ingatlah untuk menyebarkannya di dalam cluster. <br><br>  Dalam contoh tersebut, tangkapan layar menunjukkan sejumlah parameter yang dipantau khusus untuk seluruh kluster.  Hal-hal yang lebih menarik dapat disimpulkan, misalnya, berapa persen aplikasi memberikan lebih dari 500 kesalahan, yang menyiratkan kegagalan.  Waktu respons dikumpulkan dalam semua instance layanan panggilan dan menanggapi dalam cluster, fungsi ini tidak memerlukan pengaturan.  Istio tahu apa yang didukung Prometheus, dan dia tahu layanan apa yang tersedia di cluster Anda, sehingga Istio-Mixer dapat mengirim metrik ke Prometheus tanpa pengaturan tambahan. <br>  Mari kita lihat cara kerjanya.  Jika Anda memanggil layanan tertentu, layanan proxy mengirimkan informasi tentang panggilan ini ke Mixer, yang menangkap parameter seperti waktu tunggu untuk respons, status kode, dan IP.  Ini menormalkan mereka dan mengirimkannya ke server yang Anda konfigurasikan.  Khusus untuk menampilkan indikator utama ada layanan Prometheus dan adaptor FLUX DB, tetapi Anda juga dapat menulis adaptor Anda sendiri dan menampilkan data dalam format apa pun untuk aplikasi lain.  Dan Anda tidak perlu mengubah apa pun di infrastruktur jika Anda ingin menambahkan metrik baru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/477/8cf/7ea/4778cf7ea5f78c0d8dca61aaaf7756c5.jpg"><br><br>  Jika Anda ingin melakukan penelitian lebih mendalam, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem</a> penelusuran terdistribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zipkin</a> .  Informasi tentang semua panggilan yang dialihkan melalui Istio-Mixer dapat dikirim ke Zipkin.  Di sana Anda akan melihat seluruh rantai panggilan layanan mikro saat merespons pengguna dan dengan mudah menemukan layanan yang memakan waktu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c0/820/3e5/1c08203e54bc8fc2cb3a0f6da427e497.jpg"><br><br>  Pada level aplikasi, tidak perlu khawatir membuat jejak.  Utusan itu sendiri meneruskan semua informasi yang diperlukan ke Mixer, yang mengirimkannya ke jejak, misalnya, ke Zipkin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jejak stackdriver</a> dari Google atau aplikasi pengguna lainnya. <br><br>  Mari kita bicara tentang <b>toleransi kesalahan dan efisiensi</b> . <br><img src="https://habrastorage.org/getpro/habr/post_images/da4/c03/b1b/da4c03b1b08ebbc652e332c680b79599.jpg"><br><br>  Timeout antara panggilan layanan diperlukan untuk menguji kesehatan, pertama-tama, penyeimbang beban.  Kami memperkenalkan kesalahan ke dalam koneksi ini dan melihat apa yang terjadi.  Pertimbangkan sebuah contoh.  Misalkan ada koneksi antara layanan A dan layanan B. Kami menunggu respons dari layanan video selama 100 milidetik dan hanya memberikan 3 upaya jika hasilnya tidak diterima.  Intinya, kita akan mengambilnya selama 300 milidetik sebelum melaporkan upaya koneksi yang gagal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c8/858/101/2c885810146ca5a44c88b42b2b1552c5.jpg"><br><br>  Lebih jauh, misalnya, layanan film kami harus melihat peringkat film melalui layanan microser lain.  Peringkat tersebut memiliki batas waktu 200 milidetik dan dua upaya panggilan diberikan.  Memanggil layanan video dapat menyebabkan Anda menunggu 400 milidetik jika peringkat bintangnya di luar jangkauan.  Tapi, kita ingat, setelah 300 ms layanan film akan melaporkan bahwa itu idle, dan kita tidak akan pernah tahu penyebab sebenarnya dari kegagalan tersebut.  Menggunakan batas waktu dan menguji apa yang terjadi dalam kasus-kasus ini adalah cara yang bagus untuk menemukan semua jenis bug pintar dalam arsitektur layanan mikro Anda. <br><br>  Mari kita lihat sekarang apa dengan efisiensi.  Penyeimbang kubernet sendiri hanya bertindak pada tingkat lapisan keempat.  Kami menemukan konstruktor input untuk load balancing dari lapisan kedua ke ketujuh.  Istio diimplementasikan sebagai penyeimbang untuk lapisan jaringan dengan akses ke layanan jaringan. <br><br>  Kami melakukan TLS-offloading, jadi kami menggunakan SSL modern yang didoping dengan baik di Utusan, jadi Anda tidak perlu khawatir tentang kerentanan. <br><br>  Keuntungan lain dari Istio adalah <b>keamanan</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/902/a1d/fcc/902a1dfcc83b7bbb4bc3d49463c5682b.jpg"><br><br>  Apa saja fitur keamanan dasar di Istio?  Layanan Istio-Auth bekerja dalam beberapa arah.  Ini menggunakan kerangka kerja publik dan satu set standar otentikasi untuk layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPIFFE</a> .  Jika kita berbicara tentang arus lalu lintas, maka kita memiliki otoritas sertifikat Istio yang mengeluarkan sertifikat untuk akun layanan yang kita jalankan di dalam cluster.  Sertifikat ini mematuhi standar SPIFFE dan didistribusikan oleh Utusan menggunakan mekanisme keamanan kubernetes.  Utusan menggunakan kunci untuk otentikasi TLS dua arah.  Dengan demikian, aplikasi backend menerima pengidentifikasi atas dasar yang sudah mungkin untuk mengatur kebijakan. <br><br>  Istio memiliki sertifikat root sendiri sehingga Anda tidak khawatir tentang pencabutan dan tanggal kedaluwarsa.  Sistem akan merespons penskalaan otomatis, jadi dengan memperkenalkan entitas baru, Anda mendapatkan sertifikat baru.  Tidak ada pengaturan manual.  Anda tidak perlu mengkonfigurasi firewall.  Pengguna akan menggunakan kebijakan jaringan dan kubernet untuk menerapkan firewall di antara kontainer. <br><br>  Akhirnya, <b>penerapan kebijakan</b> .  Mixer adalah titik integrasi dengan backend infrastruktur yang dapat Anda kembangkan dengan Service Mesh.  Layanan dapat dengan mudah bergerak dalam sebuah cluster, digunakan di berbagai lingkungan, di cloud atau secara lokal.  Semuanya dirancang untuk kontrol operasional panggilan yang masuk melalui Utusan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat mengizinkan dan melarang panggilan tertentu, menetapkan prasyarat untuk panggilan tidak terjawab, membatasi kecepatan dan nomornya. </font><font style="vertical-align: inherit;">Misalnya, Anda mengizinkan 20 permintaan gratis per hari ke beberapa layanan. </font><font style="vertical-align: inherit;">Jika pengguna telah membuat 20 permintaan, permintaan selanjutnya tidak diproses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prasyarat dapat mencakup hal-hal seperti, misalnya, server sedang dikonfirmasi, ICL, dan berada di daftar putih. </font><font style="vertical-align: inherit;">Manajemen kuota dapat digunakan jika diperlukan bahwa setiap orang yang menggunakan layanan memiliki kecepatan akses yang sama. </font><font style="vertical-align: inherit;">Akhirnya, Mixer mengumpulkan permintaan dan respons hasil telemetri siap. </font><font style="vertical-align: inherit;">Ini memungkinkan produsen dan pengguna untuk menonton telemetri ini menggunakan layanan.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/202/d7a/975/202d7a975db3a50477ac367ea4d6f1e4.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat slide pertama dengan aplikasi foto yang dengannya kami mulai belajar Istio? </font><font style="vertical-align: inherit;">Semua hal di atas disembunyikan di bawah bentuk sederhana. </font><font style="vertical-align: inherit;">Di tingkat atas, semua yang Anda butuhkan akan dilakukan secara otomatis. </font><font style="vertical-align: inherit;">Anda akan menggunakan aplikasi dan tidak akan khawatir tentang bagaimana mendefinisikan kebijakan keamanan atau mengkonfigurasi beberapa aturan perutean. </font><font style="vertical-align: inherit;">Aplikasi akan bekerja persis seperti yang Anda harapkan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagaimana cara memulai dengan Istio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Istio mendukung versi kubernet sebelumnya, tetapi fitur penginisialisasi baru yang saya bicarakan adalah dalam versi 1.7 dan lebih tinggi. </font><font style="vertical-align: inherit;">Ini adalah fungsi alpha di kubernetes. </font><font style="vertical-align: inherit;">Saya sarankan menggunakan cluster Alpha Container Engine Google. </font><font style="vertical-align: inherit;">Kami memiliki kelompok yang dapat Anda aktifkan selama beberapa hari dan pada saat yang sama menggunakan semua kemampuan produksi di dalamnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, Istio adalah proyek open source di github. </font><font style="vertical-align: inherit;">Kami baru saja merilis versi 0.2. </font><font style="vertical-align: inherit;">Di versi 0.1, Anda bisa mengelola objek di dalam namespace kubernet dengan nama yang sama. </font><font style="vertical-align: inherit;">Sejak versi 0.2, kami mendukung kerja di namespace kami sendiri dan di cluster kubernetes. </font><font style="vertical-align: inherit;">Kami juga menambahkan akses ke kemampuan untuk mengelola layanan yang berjalan di mesin virtual. </font><font style="vertical-align: inherit;">Anda dapat menggunakan Utusan di mesin virtual dan mengamankan layanan yang berjalan di atasnya. </font><font style="vertical-align: inherit;">Di masa depan, Istio akan mendukung platform lain, seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Foundry</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panduan instalasi cepat untuk framework ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika Anda memiliki cluster yang menjalankan Google Container Engine 1.8 dengan fitur alpha diaktifkan, menginstal Istio hanya satu perintah.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyukai ceramah ini, datanglah ke konferensi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevOops 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Peter) </font><font style="vertical-align: inherit;">pada 14 Oktober </font><font style="vertical-align: inherit;">: di sana Anda tidak hanya dapat mendengarkan ceramah, tetapi juga mengobrol dengan pembicara mana pun di area diskusi.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423011/">https://habr.com/ru/post/id423011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422997/index.html">Buku "PHP Modern"</a></li>
<li><a href="../id422999/index.html">Buat dataset alien Anda sendiri</a></li>
<li><a href="../id423005/index.html">Bagaimana Yandex.Zen, Plugin Caching WordPress dan Hosting Meningkatkan Tekanan Saya</a></li>
<li><a href="../id423007/index.html">"Malyavki, tapi bagus": bagaimana kami membawa siswa untuk berlatih</a></li>
<li><a href="../id423009/index.html">SENS Diagnostics. Biomarker glikasi protein</a></li>
<li><a href="../id423013/index.html">Bagaimana mengatur dependensi Anda dalam aplikasi Vue</a></li>
<li><a href="../id423015/index.html">Git: kesalahan umum dan cara memperbaikinya</a></li>
<li><a href="../id423017/index.html">Bobbiniki: sepuluh tape recorder reel tape - ceritakan dan tunjukkan</a></li>
<li><a href="../id423021/index.html">Hackathon online oleh Naviaddress</a></li>
<li><a href="../id423023/index.html">Mengapa pengembang perlu mengajar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>