<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏻 👲🏿 🤟🏿 Indizes in PostgreSQL - 3 (Hash) 🥛 ⚔️ 👼🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Artikel beschrieb die PostgreSQL-Indizierungs-Engine , der zweite befasste sich mit der Schnittstelle von Zugriffsmethoden , und jetzt sind ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 3 (Hash)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442776/">  Der erste Artikel beschrieb die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL-Indizierungs-Engine</a> , der zweite befasste sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Schnittstelle von Zugriffsmethoden</a> , und jetzt sind wir bereit, bestimmte Arten von Indizes zu diskutieren.  Beginnen wir mit dem Hash-Index. <br><br><h1>  Hash </h1><br><h2>  Struktur </h2><br><h3>  Allgemeine Theorie </h3><br>  Viele moderne Programmiersprachen enthalten Hash-Tabellen als Basisdatentyp.  Äußerlich sieht eine Hash-Tabelle wie ein reguläres Array aus, das mit einem beliebigen Datentyp (z. B. einer Zeichenfolge) und nicht mit einer Ganzzahl indiziert ist.  Der Hash-Index in PostgreSQL ist ähnlich aufgebaut.  Wie funktioniert das? <br><br>  Datentypen haben in der Regel sehr große Bereiche zulässiger Werte: Wie viele verschiedene Zeichenfolgen können wir uns möglicherweise in einer Spalte vom Typ "Text" vorstellen?  Wie viele verschiedene Werte werden gleichzeitig in einer Textspalte einer Tabelle gespeichert?  Normalerweise nicht so viele von ihnen. <br><br>  Die Idee des Hashings besteht darin, einem Wert eines beliebigen Datentyps eine kleine Zahl (von 0 bis <em>N</em> −1, insgesamt <em>N</em> Werte) zuzuordnen.  <em>Eine solche</em> Assoziation wird als <em>Hash-Funktion bezeichnet</em> .  Die erhaltene Nummer kann als Index eines regulären Arrays verwendet werden, in dem Verweise auf Tabellenzeilen (TIDs) gespeichert werden.  Elemente dieses Arrays werden als <em>Hash-Tabellen-Buckets bezeichnet.</em> Ein Bucket kann mehrere TIDs speichern, wenn derselbe indizierte Wert in verschiedenen Zeilen angezeigt wird. <br><br>  Je gleichmäßiger eine Hash-Funktion die Quellwerte nach Buckets verteilt, desto besser ist sie.  Aber selbst eine gute Hash-Funktion führt manchmal zu gleichen Ergebnissen für verschiedene Quellwerte - dies wird als <em>Kollision bezeichnet</em> .  Ein Bucket kann also TIDs speichern, die verschiedenen Schlüsseln entsprechen, und daher müssen die aus dem Index erhaltenen TIDs erneut überprüft werden. <br><a name="habracut"></a><br>  Nur zum Beispiel: Welche Hash-Funktion für Strings können wir uns vorstellen?  Die Anzahl der Buckets sei 256. Dann können wir beispielsweise für eine Bucket-Nummer den Code des ersten Zeichens verwenden (unter der Annahme einer Einzelbyte-Zeichencodierung).  Ist das eine gute Hash-Funktion?  Offensichtlich nicht: Wenn alle Zeichenfolgen mit demselben Zeichen beginnen, werden alle in einen Bucket verschoben, sodass die Einheitlichkeit nicht in Frage kommt, alle Werte erneut überprüft werden müssen und Hashing keinen Sinn ergibt.  Was ist, wenn wir Codes aller Zeichen Modulo 256 zusammenfassen?  Dies wird viel besser sein, aber alles andere als ideal.  Wenn Sie an den Interna einer solchen Hash-Funktion in PostgreSQL interessiert sind, lesen Sie die Definition von hash_any () in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hashfunc.c</a> . <br><br><h3>  Indexstruktur </h3><br>  Kehren wir zum Hash-Index zurück.  Für einen Wert eines Datentyps (einen Indexschlüssel) besteht unsere Aufgabe darin, schnell die passende TID zu finden. <br><br>  Berechnen wir beim Einfügen in den Index die Hash-Funktion für den Schlüssel.  Hash-Funktionen in PostgreSQL geben immer den Typ "Integer" zurück, der im Bereich von 2 <sup>32</sup> ≈ 4 Milliarden Werten liegt.  Die Anzahl der Buckets beträgt anfangs zwei und nimmt dynamisch zu, um sich an die Datengröße anzupassen.  Die Bucket-Nummer kann aus dem Hash-Code unter Verwendung der Bit-Arithmetik berechnet werden.  Und dies ist der Eimer, in den wir unsere TID stellen werden. <br><br>  Dies ist jedoch nicht ausreichend, da TIDs, die mit verschiedenen Schlüsseln übereinstimmen, in denselben Bucket gestellt werden können.  Was sollen wir tun?  Es ist möglich, den Quellwert des Schlüssels zusätzlich zur TID in einem Bucket zu speichern, dies würde jedoch die Indexgröße erheblich erhöhen.  Um Platz zu sparen, speichert der Bucket anstelle eines Schlüssels den Hash-Code des Schlüssels. <br><br>  Beim Durchsuchen des Index berechnen wir die Hash-Funktion für den Schlüssel und erhalten die Bucket-Nummer.  Jetzt müssen Sie nur noch den Inhalt des Buckets durchgehen und nur übereinstimmende TIDs mit den entsprechenden Hash-Codes zurückgeben.  Dies geschieht effizient, da gespeicherte "Hash-Code-TID" -Paare bestellt werden. <br><br>  Es kann jedoch vorkommen, dass zwei verschiedene Schlüssel nicht nur in einen Bucket gelangen, sondern auch dieselben 4-Byte-Hash-Codes haben - niemand hat die Kollision beseitigt.  Daher fordert die Zugriffsmethode die allgemeine Indizierungs-Engine auf, jede TID zu überprüfen, indem sie die Bedingung in der Tabellenzeile erneut überprüft (die Engine kann dies zusammen mit der Sichtbarkeitsprüfung tun). <br><br><h3>  Zuordnen von Datenstrukturen zu Seiten </h3><br>  Wenn wir einen Index aus Sicht des Puffer-Cache-Managers und nicht aus Sicht der Abfrageplanung und -ausführung betrachten, stellt sich heraus, dass alle Informationen und alle Indexzeilen in Seiten gepackt werden müssen.  Solche Indexseiten werden im Puffercache gespeichert und von dort genauso wie Tabellenseiten entfernt. <br><br><img src="https://habrastorage.org/web/aa7/83b/c8c/aa783bc8cbfc4be49baec029339eb539.png"><br><br>  Der Hash-Index verwendet, wie in der Abbildung gezeigt, vier Arten von Seiten (graue Rechtecke): <br><br><ul><li>  Metaseite - Seitenzahl Null, die Informationen darüber enthält, was sich im Index befindet. </li><li>  Bucket-Seiten - Hauptseiten des Index, auf denen Daten als "Hash-Code-TID" -Paare gespeichert sind. </li><li>  Überlaufseiten - werden wie Bucket-Seiten strukturiert und verwendet, wenn eine Seite für einen Bucket nicht ausreicht. </li><li>  Bitmap-Seiten - Verfolgen von Überlaufseiten, die derzeit gelöscht sind und für andere Buckets wiederverwendet werden können. </li></ul><br>  Abwärtspfeile, die bei Indexseitenelementen beginnen, repräsentieren TIDs, dh Verweise auf Tabellenzeilen. <br><br>  Jedes Mal, wenn der Index erhöht wird, erstellt PostgreSQL sofort doppelt so viele Buckets (und damit Seiten) wie zuletzt erstellt.  Um zu vermeiden, dass diese potenziell große Anzahl von Seiten gleichzeitig zugewiesen wird, wurde die Größe in Version 10 reibungsloser erhöht.  Überlaufseiten werden nach Bedarf zugewiesen und in Bitmap-Seiten nachverfolgt, die bei Bedarf ebenfalls zugewiesen werden. <br><br>  Beachten Sie, dass der Hash-Index nicht kleiner werden kann.  Wenn wir einige indizierte Zeilen löschen, werden einmal zugewiesene Seiten nicht an das Betriebssystem zurückgegeben, sondern erst nach VACUUMING für neue Daten wiederverwendet.  Die einzige Möglichkeit, die Indexgröße zu verringern, besteht darin, sie mit dem Befehl REINDEX oder VACUUM FULL von Grund auf neu zu erstellen. <br><br><h2>  Beispiel </h2><br>  Mal sehen, wie der Hash-Index erstellt wird.  Um zu vermeiden, dass wir unsere eigenen Tabellen erstellen, werden wir von nun an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Demo-Datenbank</a> des Luftverkehrs verwenden und diesmal die Flugtabelle berücksichtigen. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hash(flight_no);</code> </pre> <pre> <code class="plaintext hljs">WARNING: hash indexes are not WAL-logged and their use is discouraged CREATE INDEX</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0001'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (flight_no = 'PG0001'::bpchar) -&gt; Bitmap Index Scan on flights_flight_no_idx Index Cond: (flight_no = 'PG0001'::bpchar) (4 rows)</code> </pre><br>  Was bei der aktuellen Implementierung des Hash-Index unpraktisch ist, ist, dass Operationen mit dem Index nicht im Write-Ahead-Protokoll aufgezeichnet werden (vor dem PostgreSQL beim Erstellen des Index warnt).  Infolgedessen können Hash-Indizes nach einem Fehler nicht wiederhergestellt werden und nehmen nicht an Replikationen teil.  Außerdem liegt der Hash-Index in seiner Vielseitigkeit weit unter "B-Tree", und seine Effizienz ist ebenfalls fraglich.  Daher ist es jetzt unpraktisch, solche Indizes zu verwenden. <br><br>  Dies wird sich jedoch bereits im Herbst (2017) ändern, sobald Version 10 von PostgreSQL veröffentlicht wird.  In dieser Version erhielt der Hash-Index endlich Unterstützung für das Write-Ahead-Protokoll.  Zusätzlich wurde die Speicherzuordnung optimiert und die gleichzeitige Arbeit effizienter gestaltet. <br><br><blockquote>  Das stimmt.  Seit PostgreSQL 10 haben Hash-Indizes volle Unterstützung und können ohne Einschränkungen verwendet werden.  Die Warnung wird nicht mehr angezeigt. <br></blockquote><br><h2>  Hashing-Semantik </h2><br>  Aber warum hat der Hash-Index fast von der Geburt von PostgreSQL bis 9.6 überlebt und war unbrauchbar?  Die Sache ist, dass DBMS den Hashing-Algorithmus in großem Umfang verwendet (insbesondere für Hash-Joins und -Gruppierungen), und das System muss wissen, welche Hash-Funktion auf welche Datentypen angewendet werden soll.  Diese Entsprechung ist jedoch nicht statisch und kann nicht ein für allemal festgelegt werden, da mit PostgreSQL neue Datentypen im laufenden Betrieb hinzugefügt werden können.  Und dies ist eine Zugriffsmethode durch Hash, bei der diese Korrespondenz gespeichert wird, dargestellt als Zuordnung von Hilfsfunktionen zu Operatorfamilien. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_name, amproc.amproc::<span class="hljs-type"><span class="hljs-type">regproc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_procedure <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amproc amproc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amproc.amprocfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_procedure;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_procedure --------------------+-------------------- abstime_ops | hashint4 aclitem_ops | hash_aclitem array_ops | hash_array bool_ops | hashchar ...</code> </pre><br>  Obwohl diese Funktionen nicht dokumentiert sind, können sie verwendet werden, um den Hash-Code für einen Wert des entsprechenden Datentyps zu berechnen.  Beispiel: "Hashtext" -Funktion, wenn sie für die Operatorfamilie "text_ops" verwendet wird: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'one'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 127722028 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'two'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 345620034 (1 row)</code> </pre><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften des Hash-Index an, bei denen diese Zugriffsmethode dem System Informationen über sich selbst liefert.  Wir haben beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal</a> Fragen gestellt.  Jetzt gehen wir nicht über die Ergebnisse hinaus: <br><br><pre> <code class="plaintext hljs"> name | pg_indexam_has_property ---------------+------------------------- can_order | f can_unique | f can_multi_col | f can_exclude | t name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | t name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Eine Hash-Funktion behält die Ordnungsbeziehung nicht bei: Wenn der Wert einer Hash-Funktion für einen Schlüssel kleiner als für den anderen Schlüssel ist, kann keine Schlussfolgerung gezogen werden, wie die Schlüssel selbst geordnet sind.  Daher kann der Hash-Index im Allgemeinen die einzige Operation "gleich" unterstützen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_name, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_operator ---------------+---------------------- abstime_ops | =(abstime,abstime) aclitem_ops | =(aclitem,aclitem) array_ops | =(anyarray,anyarray) bool_ops | =(boolean,boolean) ...</code> </pre><br>  Folglich kann der Hash-Index keine geordneten Daten zurückgeben ("can_order", "orderable").  Der Hash-Index manipuliert NULL-Werte aus demselben Grund nicht: Die Operation "equals" ist für NULL ("search_nulls") nicht sinnvoll. <br><br>  Da der Hash-Index keine Schlüssel (sondern nur deren Hash-Codes) speichert, kann er nicht für den reinen Indexzugriff verwendet werden ("returnable"). <br><br>  Diese Zugriffsmethode unterstützt auch keine mehrspaltigen Indizes ("can_multi_col"). <br><br><h2>  Interna </h2><br>  Ab Version 10 können über die Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pageinspect</a> " Hash-Index-Interna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersucht werden</a> .  So wird es aussehen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Die Metaseite (wir erhalten die Anzahl der Zeilen im Index und die maximal verwendete Bucket-Nummer): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- metapage (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ntuples, maxbucket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> ntuples | maxbucket ---------+----------- 33121 | 127 (1 row)</code> </pre><br>  Eine Bucket-Seite (wir erhalten die Anzahl der lebenden und toten Tupel, dh derjenigen, die gesaugt werden können): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- bucket (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> live_items, dead_items <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_page_stats(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> live_items | dead_items ------------+------------ 407 | 0 (1 row)</code> </pre><br>  Und so weiter.  Es ist jedoch kaum möglich, die Bedeutung aller verfügbaren Felder herauszufinden, ohne den Quellcode zu untersuchen.  Wenn Sie dies wünschen, sollten Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README beginnen</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442776/">https://habr.com/ru/post/de442776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442758/index.html">5 Life Hacks zur Optimierung von SQL-Abfragen in Greenplum</a></li>
<li><a href="../de442760/index.html">Ein Artikel darüber, wie CommVault PostgreSQL sichert</a></li>
<li><a href="../de442764/index.html">Product Management Digest. Was Produkt und Vermarkter im Jahr 2019 begeistert</a></li>
<li><a href="../de442770/index.html">Übersicht über JavaScript-Barcode-Scanner</a></li>
<li><a href="../de442772/index.html">Mathematik für Data Scientist: Notwendige Abschnitte</a></li>
<li><a href="../de442778/index.html">Learning Go: Eine Auswahl von Videoberichten</a></li>
<li><a href="../de442780/index.html">Die häufigsten Missverständnisse in der Populärphysik</a></li>
<li><a href="../de442782/index.html">VShard - horizontale Skalierung in Tarantool</a></li>
<li><a href="../de442784/index.html">BGP-Hijacking durch Hinzufügen des AS des Opfers zum AS-SET des Angreifers</a></li>
<li><a href="../de442786/index.html">7 Nützliche Tipps zur Raumnutzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>