<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèª üë≤üèø ü§üüèø Indizes in PostgreSQL - 3 (Hash) ü•õ ‚öîÔ∏è üëºüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Artikel beschrieb die PostgreSQL-Indizierungs-Engine , der zweite befasste sich mit der Schnittstelle von Zugriffsmethoden , und jetzt sind ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 3 (Hash)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442776/">  Der erste Artikel beschrieb die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL-Indizierungs-Engine</a> , der zweite befasste sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Schnittstelle von Zugriffsmethoden</a> , und jetzt sind wir bereit, bestimmte Arten von Indizes zu diskutieren.  Beginnen wir mit dem Hash-Index. <br><br><h1>  Hash </h1><br><h2>  Struktur </h2><br><h3>  Allgemeine Theorie </h3><br>  Viele moderne Programmiersprachen enthalten Hash-Tabellen als Basisdatentyp.  √Ñu√üerlich sieht eine Hash-Tabelle wie ein regul√§res Array aus, das mit einem beliebigen Datentyp (z. B. einer Zeichenfolge) und nicht mit einer Ganzzahl indiziert ist.  Der Hash-Index in PostgreSQL ist √§hnlich aufgebaut.  Wie funktioniert das? <br><br>  Datentypen haben in der Regel sehr gro√üe Bereiche zul√§ssiger Werte: Wie viele verschiedene Zeichenfolgen k√∂nnen wir uns m√∂glicherweise in einer Spalte vom Typ "Text" vorstellen?  Wie viele verschiedene Werte werden gleichzeitig in einer Textspalte einer Tabelle gespeichert?  Normalerweise nicht so viele von ihnen. <br><br>  Die Idee des Hashings besteht darin, einem Wert eines beliebigen Datentyps eine kleine Zahl (von 0 bis <em>N</em> ‚àí1, insgesamt <em>N</em> Werte) zuzuordnen.  <em>Eine solche</em> Assoziation wird als <em>Hash-Funktion bezeichnet</em> .  Die erhaltene Nummer kann als Index eines regul√§ren Arrays verwendet werden, in dem Verweise auf Tabellenzeilen (TIDs) gespeichert werden.  Elemente dieses Arrays werden als <em>Hash-Tabellen-Buckets bezeichnet.</em> Ein Bucket kann mehrere TIDs speichern, wenn derselbe indizierte Wert in verschiedenen Zeilen angezeigt wird. <br><br>  Je gleichm√§√üiger eine Hash-Funktion die Quellwerte nach Buckets verteilt, desto besser ist sie.  Aber selbst eine gute Hash-Funktion f√ºhrt manchmal zu gleichen Ergebnissen f√ºr verschiedene Quellwerte - dies wird als <em>Kollision bezeichnet</em> .  Ein Bucket kann also TIDs speichern, die verschiedenen Schl√ºsseln entsprechen, und daher m√ºssen die aus dem Index erhaltenen TIDs erneut √ºberpr√ºft werden. <br><a name="habracut"></a><br>  Nur zum Beispiel: Welche Hash-Funktion f√ºr Strings k√∂nnen wir uns vorstellen?  Die Anzahl der Buckets sei 256. Dann k√∂nnen wir beispielsweise f√ºr eine Bucket-Nummer den Code des ersten Zeichens verwenden (unter der Annahme einer Einzelbyte-Zeichencodierung).  Ist das eine gute Hash-Funktion?  Offensichtlich nicht: Wenn alle Zeichenfolgen mit demselben Zeichen beginnen, werden alle in einen Bucket verschoben, sodass die Einheitlichkeit nicht in Frage kommt, alle Werte erneut √ºberpr√ºft werden m√ºssen und Hashing keinen Sinn ergibt.  Was ist, wenn wir Codes aller Zeichen Modulo 256 zusammenfassen?  Dies wird viel besser sein, aber alles andere als ideal.  Wenn Sie an den Interna einer solchen Hash-Funktion in PostgreSQL interessiert sind, lesen Sie die Definition von hash_any () in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hashfunc.c</a> . <br><br><h3>  Indexstruktur </h3><br>  Kehren wir zum Hash-Index zur√ºck.  F√ºr einen Wert eines Datentyps (einen Indexschl√ºssel) besteht unsere Aufgabe darin, schnell die passende TID zu finden. <br><br>  Berechnen wir beim Einf√ºgen in den Index die Hash-Funktion f√ºr den Schl√ºssel.  Hash-Funktionen in PostgreSQL geben immer den Typ "Integer" zur√ºck, der im Bereich von 2 <sup>32</sup> ‚âà 4 Milliarden Werten liegt.  Die Anzahl der Buckets betr√§gt anfangs zwei und nimmt dynamisch zu, um sich an die Datengr√∂√üe anzupassen.  Die Bucket-Nummer kann aus dem Hash-Code unter Verwendung der Bit-Arithmetik berechnet werden.  Und dies ist der Eimer, in den wir unsere TID stellen werden. <br><br>  Dies ist jedoch nicht ausreichend, da TIDs, die mit verschiedenen Schl√ºsseln √ºbereinstimmen, in denselben Bucket gestellt werden k√∂nnen.  Was sollen wir tun?  Es ist m√∂glich, den Quellwert des Schl√ºssels zus√§tzlich zur TID in einem Bucket zu speichern, dies w√ºrde jedoch die Indexgr√∂√üe erheblich erh√∂hen.  Um Platz zu sparen, speichert der Bucket anstelle eines Schl√ºssels den Hash-Code des Schl√ºssels. <br><br>  Beim Durchsuchen des Index berechnen wir die Hash-Funktion f√ºr den Schl√ºssel und erhalten die Bucket-Nummer.  Jetzt m√ºssen Sie nur noch den Inhalt des Buckets durchgehen und nur √ºbereinstimmende TIDs mit den entsprechenden Hash-Codes zur√ºckgeben.  Dies geschieht effizient, da gespeicherte "Hash-Code-TID" -Paare bestellt werden. <br><br>  Es kann jedoch vorkommen, dass zwei verschiedene Schl√ºssel nicht nur in einen Bucket gelangen, sondern auch dieselben 4-Byte-Hash-Codes haben - niemand hat die Kollision beseitigt.  Daher fordert die Zugriffsmethode die allgemeine Indizierungs-Engine auf, jede TID zu √ºberpr√ºfen, indem sie die Bedingung in der Tabellenzeile erneut √ºberpr√ºft (die Engine kann dies zusammen mit der Sichtbarkeitspr√ºfung tun). <br><br><h3>  Zuordnen von Datenstrukturen zu Seiten </h3><br>  Wenn wir einen Index aus Sicht des Puffer-Cache-Managers und nicht aus Sicht der Abfrageplanung und -ausf√ºhrung betrachten, stellt sich heraus, dass alle Informationen und alle Indexzeilen in Seiten gepackt werden m√ºssen.  Solche Indexseiten werden im Puffercache gespeichert und von dort genauso wie Tabellenseiten entfernt. <br><br><img src="https://habrastorage.org/web/aa7/83b/c8c/aa783bc8cbfc4be49baec029339eb539.png"><br><br>  Der Hash-Index verwendet, wie in der Abbildung gezeigt, vier Arten von Seiten (graue Rechtecke): <br><br><ul><li>  Metaseite - Seitenzahl Null, die Informationen dar√ºber enth√§lt, was sich im Index befindet. </li><li>  Bucket-Seiten - Hauptseiten des Index, auf denen Daten als "Hash-Code-TID" -Paare gespeichert sind. </li><li>  √úberlaufseiten - werden wie Bucket-Seiten strukturiert und verwendet, wenn eine Seite f√ºr einen Bucket nicht ausreicht. </li><li>  Bitmap-Seiten - Verfolgen von √úberlaufseiten, die derzeit gel√∂scht sind und f√ºr andere Buckets wiederverwendet werden k√∂nnen. </li></ul><br>  Abw√§rtspfeile, die bei Indexseitenelementen beginnen, repr√§sentieren TIDs, dh Verweise auf Tabellenzeilen. <br><br>  Jedes Mal, wenn der Index erh√∂ht wird, erstellt PostgreSQL sofort doppelt so viele Buckets (und damit Seiten) wie zuletzt erstellt.  Um zu vermeiden, dass diese potenziell gro√üe Anzahl von Seiten gleichzeitig zugewiesen wird, wurde die Gr√∂√üe in Version 10 reibungsloser erh√∂ht.  √úberlaufseiten werden nach Bedarf zugewiesen und in Bitmap-Seiten nachverfolgt, die bei Bedarf ebenfalls zugewiesen werden. <br><br>  Beachten Sie, dass der Hash-Index nicht kleiner werden kann.  Wenn wir einige indizierte Zeilen l√∂schen, werden einmal zugewiesene Seiten nicht an das Betriebssystem zur√ºckgegeben, sondern erst nach VACUUMING f√ºr neue Daten wiederverwendet.  Die einzige M√∂glichkeit, die Indexgr√∂√üe zu verringern, besteht darin, sie mit dem Befehl REINDEX oder VACUUM FULL von Grund auf neu zu erstellen. <br><br><h2>  Beispiel </h2><br>  Mal sehen, wie der Hash-Index erstellt wird.  Um zu vermeiden, dass wir unsere eigenen Tabellen erstellen, werden wir von nun an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Demo-Datenbank</a> des Luftverkehrs verwenden und diesmal die Flugtabelle ber√ºcksichtigen. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hash(flight_no);</code> </pre> <pre> <code class="plaintext hljs">WARNING: hash indexes are not WAL-logged and their use is discouraged CREATE INDEX</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0001'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (flight_no = 'PG0001'::bpchar) -&gt; Bitmap Index Scan on flights_flight_no_idx Index Cond: (flight_no = 'PG0001'::bpchar) (4 rows)</code> </pre><br>  Was bei der aktuellen Implementierung des Hash-Index unpraktisch ist, ist, dass Operationen mit dem Index nicht im Write-Ahead-Protokoll aufgezeichnet werden (vor dem PostgreSQL beim Erstellen des Index warnt).  Infolgedessen k√∂nnen Hash-Indizes nach einem Fehler nicht wiederhergestellt werden und nehmen nicht an Replikationen teil.  Au√üerdem liegt der Hash-Index in seiner Vielseitigkeit weit unter "B-Tree", und seine Effizienz ist ebenfalls fraglich.  Daher ist es jetzt unpraktisch, solche Indizes zu verwenden. <br><br>  Dies wird sich jedoch bereits im Herbst (2017) √§ndern, sobald Version 10 von PostgreSQL ver√∂ffentlicht wird.  In dieser Version erhielt der Hash-Index endlich Unterst√ºtzung f√ºr das Write-Ahead-Protokoll.  Zus√§tzlich wurde die Speicherzuordnung optimiert und die gleichzeitige Arbeit effizienter gestaltet. <br><br><blockquote>  Das stimmt.  Seit PostgreSQL 10 haben Hash-Indizes volle Unterst√ºtzung und k√∂nnen ohne Einschr√§nkungen verwendet werden.  Die Warnung wird nicht mehr angezeigt. <br></blockquote><br><h2>  Hashing-Semantik </h2><br>  Aber warum hat der Hash-Index fast von der Geburt von PostgreSQL bis 9.6 √ºberlebt und war unbrauchbar?  Die Sache ist, dass DBMS den Hashing-Algorithmus in gro√üem Umfang verwendet (insbesondere f√ºr Hash-Joins und -Gruppierungen), und das System muss wissen, welche Hash-Funktion auf welche Datentypen angewendet werden soll.  Diese Entsprechung ist jedoch nicht statisch und kann nicht ein f√ºr allemal festgelegt werden, da mit PostgreSQL neue Datentypen im laufenden Betrieb hinzugef√ºgt werden k√∂nnen.  Und dies ist eine Zugriffsmethode durch Hash, bei der diese Korrespondenz gespeichert wird, dargestellt als Zuordnung von Hilfsfunktionen zu Operatorfamilien. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_name, amproc.amproc::<span class="hljs-type"><span class="hljs-type">regproc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_procedure <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amproc amproc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amproc.amprocfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_procedure;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_procedure --------------------+-------------------- abstime_ops | hashint4 aclitem_ops | hash_aclitem array_ops | hash_array bool_ops | hashchar ...</code> </pre><br>  Obwohl diese Funktionen nicht dokumentiert sind, k√∂nnen sie verwendet werden, um den Hash-Code f√ºr einen Wert des entsprechenden Datentyps zu berechnen.  Beispiel: "Hashtext" -Funktion, wenn sie f√ºr die Operatorfamilie "text_ops" verwendet wird: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'one'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 127722028 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'two'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 345620034 (1 row)</code> </pre><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften des Hash-Index an, bei denen diese Zugriffsmethode dem System Informationen √ºber sich selbst liefert.  Wir haben beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal</a> Fragen gestellt.  Jetzt gehen wir nicht √ºber die Ergebnisse hinaus: <br><br><pre> <code class="plaintext hljs"> name | pg_indexam_has_property ---------------+------------------------- can_order | f can_unique | f can_multi_col | f can_exclude | t name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | t name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Eine Hash-Funktion beh√§lt die Ordnungsbeziehung nicht bei: Wenn der Wert einer Hash-Funktion f√ºr einen Schl√ºssel kleiner als f√ºr den anderen Schl√ºssel ist, kann keine Schlussfolgerung gezogen werden, wie die Schl√ºssel selbst geordnet sind.  Daher kann der Hash-Index im Allgemeinen die einzige Operation "gleich" unterst√ºtzen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_name, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_operator ---------------+---------------------- abstime_ops | =(abstime,abstime) aclitem_ops | =(aclitem,aclitem) array_ops | =(anyarray,anyarray) bool_ops | =(boolean,boolean) ...</code> </pre><br>  Folglich kann der Hash-Index keine geordneten Daten zur√ºckgeben ("can_order", "orderable").  Der Hash-Index manipuliert NULL-Werte aus demselben Grund nicht: Die Operation "equals" ist f√ºr NULL ("search_nulls") nicht sinnvoll. <br><br>  Da der Hash-Index keine Schl√ºssel (sondern nur deren Hash-Codes) speichert, kann er nicht f√ºr den reinen Indexzugriff verwendet werden ("returnable"). <br><br>  Diese Zugriffsmethode unterst√ºtzt auch keine mehrspaltigen Indizes ("can_multi_col"). <br><br><h2>  Interna </h2><br>  Ab Version 10 k√∂nnen √ºber die Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pageinspect</a> " Hash-Index-Interna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersucht werden</a> .  So wird es aussehen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Die Metaseite (wir erhalten die Anzahl der Zeilen im Index und die maximal verwendete Bucket-Nummer): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- metapage (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ntuples, maxbucket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> ntuples | maxbucket ---------+----------- 33121 | 127 (1 row)</code> </pre><br>  Eine Bucket-Seite (wir erhalten die Anzahl der lebenden und toten Tupel, dh derjenigen, die gesaugt werden k√∂nnen): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- bucket (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> live_items, dead_items <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_page_stats(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> live_items | dead_items ------------+------------ 407 | 0 (1 row)</code> </pre><br>  Und so weiter.  Es ist jedoch kaum m√∂glich, die Bedeutung aller verf√ºgbaren Felder herauszufinden, ohne den Quellcode zu untersuchen.  Wenn Sie dies w√ºnschen, sollten Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README beginnen</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442776/">https://habr.com/ru/post/de442776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442758/index.html">5 Life Hacks zur Optimierung von SQL-Abfragen in Greenplum</a></li>
<li><a href="../de442760/index.html">Ein Artikel dar√ºber, wie CommVault PostgreSQL sichert</a></li>
<li><a href="../de442764/index.html">Product Management Digest. Was Produkt und Vermarkter im Jahr 2019 begeistert</a></li>
<li><a href="../de442770/index.html">√úbersicht √ºber JavaScript-Barcode-Scanner</a></li>
<li><a href="../de442772/index.html">Mathematik f√ºr Data Scientist: Notwendige Abschnitte</a></li>
<li><a href="../de442778/index.html">Learning Go: Eine Auswahl von Videoberichten</a></li>
<li><a href="../de442780/index.html">Die h√§ufigsten Missverst√§ndnisse in der Popul√§rphysik</a></li>
<li><a href="../de442782/index.html">VShard - horizontale Skalierung in Tarantool</a></li>
<li><a href="../de442784/index.html">BGP-Hijacking durch Hinzuf√ºgen des AS des Opfers zum AS-SET des Angreifers</a></li>
<li><a href="../de442786/index.html">7 N√ºtzliche Tipps zur Raumnutzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>