<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèª üßëüèø‚Äçü§ù‚Äçüßëüèº üò´ Apprenez OpenGL. Le√ßon 7.1 - D√©bogage üëÄ üë∂üèª üóº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La programmation graphique n'est pas seulement une source de plaisir, mais aussi de frustration lorsque quelque chose ne s'affiche pas comme pr√©vu, ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Le√ßon 7.1 - D√©bogage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300">  La programmation graphique n'est pas seulement une source de plaisir, mais aussi de frustration lorsque quelque chose ne s'affiche pas comme pr√©vu, ou que rien ne s'affiche √† l'√©cran.  √âtant donn√© que la plupart de ce que nous faisons est li√© √† la manipulation des pixels, il peut √™tre difficile de d√©terminer la cause de l'erreur lorsque quelque chose ne fonctionne pas comme il se doit.  Le d√©bogage de ce type d'erreur est plus difficile que le d√©bogage des erreurs sur le CPU.  Nous n'avons pas de console o√π nous pouvons afficher le texte, nous ne pouvons pas mettre un point d'arr√™t dans le shader et nous ne pouvons pas simplement prendre et v√©rifier l'√©tat du programme sur le GPU. </p><br><p>  Dans ce didacticiel, nous vous pr√©senterons certaines des m√©thodes et techniques de d√©bogage de votre programme OpenGL.  Le d√©bogage dans OpenGL n'est pas si difficile, et l'apprentissage de quelques astuces sera certainement payant. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Partie 1. Pour commencer</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©ation de fen√™tres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fen√™tre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Syst√®mes de coordonn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 2. √âclairage de base</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'√©clairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mat√©riaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'√©clairage multiples</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 3. T√©l√©charger des mod√®les 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de mod√®le 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 4. Fonctionnalit√©s avanc√©es d'OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©lange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avanc√© des donn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avanc√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader g√©om√©trique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 5. √âclairage avanc√©</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âclairage avanc√©.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®le Blinn Fong</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fant√¥mes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombr√©es omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu diff√©r√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumi√®re analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition sp√©culaire</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 7. Pratique</b> <div class="spoiler_text"><ol><li>  <b>D√©bogage</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu de texte</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Lorsque vous utilisez incorrectement OpenGL (par exemple, lorsque vous configurez un tampon et oubliez de le lier), OpenGL remarquera et cr√©era un ou plusieurs indicateurs d'erreur personnalis√©s en arri√®re-plan.  Nous pouvons suivre ces erreurs en appelant la fonction <code>glGetError()</code> , qui v√©rifie simplement l'ensemble d'indicateurs d'erreur et renvoie la valeur d'erreur si des erreurs se produisent. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Cette fonction renvoie un indicateur d'erreur ou aucune erreur du tout.  Liste des valeurs de retour: </p><br><div class="scrollable-table"><table><thead><tr><th>  Drapeau </th><th>  Code </th><th>  La description </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td>  Aucune erreur g√©n√©r√©e depuis le dernier appel glGetError </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  D√©fini lorsqu'un param√®tre d'√©num√©ration n'est pas valide </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  D√©finir lorsque la valeur n'est pas valide </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  D√©finir lorsqu'une commande avec des param√®tres sp√©cifi√©s n'est pas valide </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  Elle est √©tablie lorsque l'op√©ration consistant √† pousser des donn√©es sur la pile (push) provoque un d√©bordement de pile. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  Elle est √©tablie lorsque l'op√©ration d'extraction des donn√©es de la pile (pop) se produit √† partir du plus petit point de la pile. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  D√©fini lorsqu'une op√©ration d'allocation de m√©moire ne peut pas allouer suffisamment de m√©moire. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  D√©fini lors de la lecture / √©criture vers / depuis un tampon de cadre qui n'est pas termin√© </td></tr></tbody></table></div><br><p>  Dans la documentation des fonctions OpenGL, vous pouvez trouver des codes d'erreur g√©n√©r√©s par des fonctions mal utilis√©es.  Par exemple, si vous consultez la documentation de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>glBindTexture()</code></a> , vous pouvez trouver les codes d'erreur g√©n√©r√©s par cette fonction dans la section Erreurs. <br>  Lorsque l'indicateur d'erreur est d√©fini, aucun autre indicateur d'erreur n'est g√©n√©r√©.  De plus, lorsque <code>glGetError</code> est appel√©e, la fonction efface tous les drapeaux d'erreur (ou un seul sur un syst√®me distribu√©, voir ci-dessous).  Cela signifie que si vous appelez <code>glGetError</code> une fois apr√®s chaque trame et obtenez une erreur, cela ne signifie pas que c'est la seule erreur et vous ne savez toujours pas o√π cette erreur s'est produite. </p><br><blockquote>  Notez que lorsque OpenGL fonctionne de mani√®re distribu√©e, comme c'est souvent le cas sur les syst√®mes avec X11, d'autres erreurs peuvent √™tre g√©n√©r√©es alors qu'elles ont des codes diff√©rents.  L'appel de <code>glGetError</code> ensuite simplement l'un des indicateurs de code d'erreur au lieu de tous.  Pour cette raison, ils recommandent d'appeler cette fonction en boucle. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Une caract√©ristique distinctive de <code>glGetError</code> est qu'il permet de d√©terminer relativement facilement o√π une erreur peut se produire et de v√©rifier que OpenGL est utilis√© correctement.  Imaginons que vous ne dessiniez rien et que vous ne connaissiez pas la raison: le tampon de trame est mal r√©gl√©?  Vous avez oubli√© de d√©finir la texture?  En appelant <code>glGetError</code> partout, vous pouvez rapidement d√©terminer o√π se produit la premi√®re erreur. <br>  Par d√©faut, <code>glGetError</code> ne signale que le num√©ro d'erreur, ce qui n'est pas facile √† comprendre tant que vous n'avez pas m√©moris√© les num√©ros de code.  Il est souvent judicieux d'√©crire une petite fonction pour aider √† imprimer une cha√Æne d'erreur avec l'emplacement √† partir duquel la fonction est appel√©e. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Si vous d√©cidez de faire plus d'appels √† <code>glCheckError</code> , il sera utile de savoir o√π l'erreur s'est produite. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Conclusion: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Une chose importante reste: il y a un bogue de longue date dans GLEW: <code>glewInit()</code> d√©finit toujours l'indicateur <code>GL_INVALID_ENUM</code> .  Pour r√©soudre ce probl√®me, appelez simplement <code>glGetError</code> apr√®s <code>glewInit</code> pour effacer l'indicateur: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> n'aide pas beaucoup, car les informations renvoy√©es sont relativement simples, mais elles aident souvent √† d√©tecter les fautes de frappe ou √† localiser l'endroit o√π l'erreur s'est produite.  Il s'agit d'un outil de d√©bogage simple mais efficace. </p><br><h1 id="otladochnyy-vyvod">  Sortie de d√©bogage </h1><br><p>  L'outil est moins connu, mais plus utile que <code>glCheckError</code> , l'extension "debug output" d'OpenGL, qui √©tait incluse dans le profil principal d'OpenGL 4.3.  Avec cette extension, OpenGL enverra un message d'erreur √† l'utilisateur avec les d√©tails de l'erreur.  Cette extension fournit non seulement plus d'informations, mais vous permet √©galement de d√©tecter les erreurs l√† o√π elles se produisent √† l'aide du d√©bogueur. </p><br><blockquote>  La sortie de d√©bogage est incluse dans OpenGL √† partir de la version 4.3, ce qui signifie que vous trouverez cette fonctionnalit√© sur n'importe quelle machine prenant en charge OpenGL 4.3 et sup√©rieur.  Si cette version n'est pas disponible, vous pouvez v√©rifier les extensions <code>ARB_debug_output</code> et <code>AMD_debug_output</code> .  Il existe √©galement des informations non v√©rifi√©es selon lesquelles la sortie de d√©bogage n'est pas prise en charge sur OS X (l'auteur de l'original et le traducteur n'ont pas test√©, veuillez en informer l'auteur de l'original ou √† moi-m√™me dans des messages priv√©s via le m√©canisme de correction d'erreurs, si vous trouvez une confirmation ou une r√©futation de ce fait; <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Jeka178RUS a</a> v√©rifi√© cela fait: hors de la bo√Æte, la sortie de d√©bogage ne fonctionne pas, il n'a pas v√©rifi√© les extensions). </blockquote><p>  Pour commencer √† utiliser la sortie de d√©bogage, nous devons demander le contexte de d√©bogage OpenGL pendant le processus d'initialisation.  Ce processus est diff√©rent sur diff√©rents syst√®mes de fen√™tres, mais ici nous ne discuterons que de GLFW, mais √† la fin de l'article dans la section "Mat√©riaux suppl√©mentaires", vous pouvez trouver des informations sur d'autres syst√®mes de fen√™tres. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  D√©boguer la sortie dans GLFW </h4><br><p>  La demande de contextes de d√©bogage dans GLFW est √©tonnamment simple: tout ce que vous devez faire est de donner √† GLFW une indication que nous voulons un contexte qui prend en charge la sortie de d√©bogage.  Nous devons le faire avant d'appeler <code>glfwCreateWindow</code> : </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  D√®s que nous avons initialis√© GLFW, nous devrions avoir un contexte de d√©bogage si nous utilisons OpenGL 4.3 ou sup√©rieur, sinon nous devons tenter notre chance et esp√©rons que le syst√®me pourra toujours cr√©er un contexte de d√©bogage.  En cas d'√©chec, nous devons demander une sortie de d√©bogage via le m√©canisme d'extension OpenGL. </p><br><blockquote>  Le contexte de d√©bogage OpenGL peut √™tre plus lent que la normale, vous devez donc supprimer ou commenter cette ligne lorsque vous travaillez sur des optimisations ou avant la publication. </blockquote><p>  Pour v√©rifier le r√©sultat de l'initialisation du contexte de d√©bogage, il suffit d'ex√©cuter le code suivant: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Comment fonctionne la sortie de d√©bogage?  Nous passons une fonction de rappel √† un gestionnaire de messages dans OpenGL (similaire aux rappels dans GLFW) et dans cette fonction, nous pouvons traiter les donn√©es OpenGL comme nous le souhaitons, dans notre cas, envoyer des messages d'erreur utiles √† la console.  Le prototype de cette fonction: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Notez que sur certains syst√®mes d'exploitation, le type du dernier param√®tre peut √™tre <code>const void*</code> . <br>  √âtant donn√© le grand ensemble de donn√©es dont nous disposons, nous pouvons cr√©er un outil d'impression d'erreur utile, comme indiqu√© ci-dessous: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Lorsque l'extension d√©tecte une erreur OpenGL, elle appelle cette fonction et nous pouvons imprimer une √©norme quantit√© d'informations sur les erreurs.  Notez que nous avons ignor√© certaines erreurs, car elles sont inutiles (par exemple, 131185 dans les pilotes NVidia indique que le tampon a √©t√© cr√©√© avec succ√®s). <br>  Maintenant que nous avons le rappel souhait√©, il est temps d'initialiser la sortie de d√©bogage: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Nous disons donc √† OpenGL que nous voulons activer la sortie de d√©bogage.  L'appel √† <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> indique √† OpenGL que nous voulons un message d'erreur quand il vient de se produire. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  D√©bogage du filtrage de sortie </h4><br><p>  Avec la fonction <code>glDebugMessageControl</code> vous pouvez s√©lectionner les types d'erreurs que vous souhaitez recevoir.  Dans notre cas, nous obtenons toutes sortes d'erreurs.  Si nous voulions uniquement les erreurs de l'API OpenGL, telles que Erreur et le niveau de signification √©lev√©, nous √©cririons le code suivant: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  Avec ce contexte de configuration et de d√©bogage, chaque commande OpenGL incorrecte enverra beaucoup d'informations utiles: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Trouver la source de l'erreur via la pile d'appels </h4><br><p>  Une autre astuce avec la sortie de d√©bogage est que vous pouvez √©tablir relativement facilement l'emplacement exact de l'erreur dans votre code.  En d√©finissant un point d'arr√™t dans la fonction <code>DebugOutput</code> sur le type d'erreur souhait√© (ou au d√©but de la fonction si vous souhaitez intercepter toutes les erreurs), le d√©bogueur intercepte l'erreur et vous pouvez parcourir la pile des appels pour savoir o√π l'erreur s'est produite: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Cela n√©cessite une intervention manuelle, mais si vous savez √† peu pr√®s ce que vous recherchez, il est extr√™mement utile de d√©terminer rapidement quel appel est √† l'origine de l'erreur. </p><br><h4 id="svoi-oshibki">  Propres erreurs </h4><br><p>  En plus des erreurs de lecture, nous pouvons les envoyer au syst√®me de sortie de d√©bogage √† l'aide de <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Ceci est tr√®s utile si vous vous connectez √† une autre application ou √† un code OpenGL qui utilise un contexte de d√©bogage.  Les autres d√©veloppeurs pourront d√©couvrir rapidement toute erreur signal√©e qui se produit dans votre code OpenGL personnalis√©. <br>  En g√©n√©ral, la sortie de d√©bogage (si disponible) est tr√®s utile pour d√©tecter rapidement les erreurs et vaut vraiment la peine d'√™tre consacr√©e √† l'optimisation, car elle √©conomise un temps de d√©veloppement important.  Vous pouvez trouver une copie du code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici en</a> utilisant <code>glGetError</code> et une sortie de d√©bogage.  Il y a des erreurs, essayez de les corriger. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Sortie de d√©bogage de shader </h1><br><p>  En ce qui concerne GLSL, nous n'avons pas acc√®s √† des fonctions comme <code>glGetError</code> ou la possibilit√© de parcourir le code par √©tapes dans le d√©bogueur.  Lorsque vous rencontrez un √©cran noir ou un affichage compl√®tement incorrect, il peut √™tre tr√®s difficile de comprendre ce qui se passe si le probl√®me est dans le shader.  Oui, les erreurs de compilation signalent des erreurs de syntaxe, mais la capture d'erreurs s√©mantiques est ce morceau. <br>  L'une des m√©thodes couramment utilis√©es pour d√©couvrir ce qui ne va pas avec un shader est d'envoyer toutes les variables pertinentes du programme de shader directement au canal de sortie du fragment shader.  En sortant des variables de shader directement sur le canal de sortie avec la couleur, nous pouvons trouver des informations int√©ressantes en v√©rifiant l'image √† la sortie.  Par exemple, nous devons savoir si les normales sont correctes pour le mod√®le.  Nous pouvons les envoyer (transform√©s ou non) du sommet au fragment shader, o√π nous d√©rivons les normales quelque chose comme ceci: <br>  (remarque: pourquoi n'y a-t-il pas de mise en √©vidence de la syntaxe pour GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  En sortant une variable non color√©e sur le canal de sortie avec la couleur telle qu'elle est maintenant, nous pouvons rapidement v√©rifier la valeur de la variable.  Si, par exemple, le r√©sultat est un √©cran noir, il est clair que les normales sont incorrectement transf√©r√©es aux shaders, et lorsqu'elles sont affich√©es, il est relativement facile de v√©rifier leur exactitude: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  D'apr√®s les r√©sultats visuels, nous pouvons voir que les normales sont correctes, car le c√¥t√© droit de la combinaison est principalement rouge (ce qui signifie que les normales apparaissent approximativement dans la direction de l'axe x de rin√ßage) et que la face avant de la combinaison est color√©e dans la direction de l'axe z positif (bleu). </p><br><p>  Cette approche peut √™tre √©tendue √† toute variable que vous souhaitez tester.  Chaque fois que vous √™tes bloqu√© et supposez que l'erreur se trouve dans les shaders, essayez de dessiner des variables ou des r√©sultats interm√©diaires et d√©couvrez dans quelle partie de l'algorithme il y a une erreur. </p><br><h1 id="opengl-glsl-reference-compiler">  Compilateur de r√©f√©rence OpenGL GLSL </h1><br><p>  Chaque pilote vid√©o a ses propres bizarreries.  Par exemple, les pilotes NVIDIA adoucissent l√©g√®rement les exigences de la sp√©cification et les pilotes AMD r√©pondent mieux aux sp√©cifications (ce qui est mieux, il me semble).  Le probl√®me est que les shaders fonctionnant sur une machine peuvent ne pas gagner d'argent sur une autre en raison des diff√©rences de pilotes. </p><br><p>  Pendant plusieurs ann√©es d'exp√©rience, vous pouvez apprendre toutes les diff√©rences entre les diff√©rents GPU, mais si vous voulez √™tre s√ªr que vos shaders fonctionneront partout, vous pouvez v√©rifier votre code avec les sp√©cifications officielles en utilisant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilateur de r√©f√©rence GLSL</a> .  Vous pouvez t√©l√©charger le soi-disant <em>validateur GLSL lang</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ). </p><br><p>  Avec ce programme, vous pouvez tester vos shaders en les passant comme 1er argument au programme.  N'oubliez pas que le programme d√©termine le type de shader par extension: </p><br><ul><li>  <code>.vert</code> : vertex shader </li><li>  <code>.frag</code> : fragment shader </li><li>  <code>.geom</code> : shader g√©om√©trique </li><li>  <code>.tesc</code> : <code>.tesc</code> contr√¥lant le shader </li><li>  <code>.tese</code> : shader informatique de <code>.tese</code> </li><li>  <code>.comp</code> : shader de calcul </li></ul><br><p>  L'ex√©cution du programme est simple: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Notez que s'il n'y a pas d'erreur, le programme ne sortira rien.  Sur un vertex shader cass√©, la sortie ressemblera √†: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  Le programme ne montrera pas les diff√©rences entre les compilateurs GLSL d'AMD, NVidia ou Intel, et ne peut m√™me pas signaler tous les bogues dans le shader, mais il v√©rifie au moins la conformit√© des shaders avec les normes. </p><br><h1 id="vyvod-bufera-kadra">  Sortie du tampon de trame </h1><br><p>  Une autre m√©thode pour votre bo√Æte √† outils consiste √† afficher le contenu du tampon de trame dans une partie sp√©cifique de l'√©cran.  Tr√®s probablement, vous utilisez souvent des tampons d'images, et comme toute la magie se produit dans les coulisses, il peut √™tre difficile de d√©terminer ce qui se passe.  La sortie du contenu du tampon de trame est une astuce utile pour v√©rifier que les choses sont correctes. </p><br><blockquote>  Notez que le contenu du tampon de cadre, comme expliqu√© ici, fonctionne avec des textures, pas avec des objets dans les tampons de dessin </blockquote><p>  En utilisant un shader simple qui dessine une seule texture, nous pouvons √©crire une petite fonction qui dessine rapidement n'importe quelle texture dans le coin sup√©rieur droit de l'√©cran: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Cela vous donnera une petite fen√™tre dans le coin de l'√©cran pour d√©boguer la sortie du tampon de trame.  Il est utile, par exemple, lorsque vous essayez de v√©rifier l'exactitude des normales: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Vous pouvez √©galement d√©velopper cette fonction afin qu'elle rende plus d'une texture.  Il s'agit d'un moyen rapide d'obtenir une r√©troaction continue de n'importe quoi dans les tampons de trame. </p><br><h1 id="vneshnie-programmy-otladchiki">  Programmes de d√©bogage externes </h1><br><p>  Lorsque tout le reste √©choue, il y a une autre astuce: utiliser des programmes tiers.  Ils sont int√©gr√©s au pilote OpenGL et peuvent intercepter tous les appels OpenGL pour vous fournir de nombreuses donn√©es int√©ressantes sur votre application.  Ces applications peuvent profiler l'utilisation des fonctions OpenGL, rechercher les goulots d'√©tranglement et surveiller les tampons de trame, les textures et la m√©moire.  Tout en travaillant sur du (gros) code, ces outils peuvent devenir inestimables. </p><br><p>  J'ai √©num√©r√© plusieurs outils populaires.  Essayez chacun et choisissez celui qui vous convient le mieux. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc est un bon outil de d√©bogage s√©par√© (enti√®rement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouvert</a> ).  Pour d√©marrer la capture, s√©lectionnez le fichier ex√©cutable et le r√©pertoire de travail.  Votre application fonctionne comme d'habitude, et lorsque vous souhaitez regarder une seule image, vous autorisez RenderDoc √† capturer plusieurs images de votre application.  Parmi les trames captur√©es, vous pouvez afficher l'√©tat du pipeline, toutes les commandes OpenGL, le stockage du tampon et les textures utilis√©es. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodeXL</a> - Outil de d√©bogage GPU, fonctionne comme une application autonome et un plugin pour Visual Studio.  CodeXL Fournit beaucoup d'informations et est id√©al pour le profilage d'applications graphiques.  CodeXL fonctionne √©galement sur les cartes graphiques de NVidia et Intel, mais sans prise en charge du d√©bogage OpenCL. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  Je n'utilisais pas beaucoup CodeXL, car RenderDoc me semblait plus facile, mais j'ai inclus CodeXL dans cette liste car il ressemble √† un outil assez fiable et est principalement d√©velopp√© par l'un des plus grands fabricants de GPU. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nsight</a> est un outil de d√©bogage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NUIDIA</a> GPU populaire.  Ce n'est pas seulement un plug-in pour Visual Studio et Eclipse, mais aussi une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application distincte</a> .  Le plugin Nsight est une chose tr√®s utile pour les d√©veloppeurs graphiques car il collecte de nombreuses statistiques en temps r√©el concernant l'utilisation du GPU et l'√©tat image par image du GPU. </p><br><p>  Au moment o√π vous lancez votre application via Visual Studio ou Eclipse √† l'aide des commandes de d√©bogage ou du profilage Nsight, elle d√©marre √† l'int√©rieur de l'application elle-m√™me.  Une bonne chose dans Nsight: rendre un syst√®me GUI (GUI, interface utilisateur graphique) au-dessus d'une application en cours d'ex√©cution, qui peut √™tre utilis√© pour collecter toutes sortes d'informations sur votre application en temps r√©el ou analyse image par image. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight est un outil tr√®s utile qui, √† mon avis, surpasse les outils ci-dessus, mais pr√©sente un s√©rieux inconv√©nient: il <em>ne</em> fonctionne <em>que</em> sur les cartes graphiques NVIDIA.  Si vous utilisez des cartes graphiques NVIDIA et utilisez Visual Studio, alors Nsight vaut vraiment la peine d'√™tre essay√©. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">   </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    ?</a> ‚Äî           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://web.archive.org/web/20150225171555/"> </a> ‚Äî            Vallentin Source. </li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nous avons un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√©l√©gramme conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la coordination des transferts. </font><font style="vertical-align: inherit;">Si vous avez un s√©rieux d√©sir d'aider √† la traduction, alors vous √™tes les bienvenus!</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462897/">https://habr.com/ru/post/fr462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462885/index.html">R√©seau IPoE tol√©rant aux pannes √† port√©e de main</a></li>
<li><a href="../fr462887/index.html">L'exp√©rience de la personnalisation d'une boutique en ligne √† l'aide de l'exemple d'une recommandation dynamique</a></li>
<li><a href="../fr462889/index.html">Continuation Story: le propre compilateur de Pascal pour Windows √† partir de z√©ro</a></li>
<li><a href="../fr462893/index.html">Reconnaissance faciale dans les villes: s√©curit√© et confidentialit√©</a></li>
<li><a href="../fr462895/index.html">R√©soudre un probl√®me avec pwnable.kr 17 - memcpy. Alignement des donn√©es</a></li>
<li><a href="../fr462903/index.html">Comment nous avons con√ßu et mis en ≈ìuvre le nouveau r√©seau sur Huawei dans le bureau de Moscou, partie 3: usine de serveurs</a></li>
<li><a href="../fr462905/index.html">√âcrire un bot de t√©l√©gramme en python √† l'aide de la biblioth√®que de telebot partie 2</a></li>
<li><a href="../fr462907/index.html">ngFanatic hebdomadaire</a></li>
<li><a href="../fr462909/index.html">Les fruits de l'√©volution de l'ASIC: sur les fabricants, les mineurs de SHA-256 et les bizarreries du hashrate astronomique</a></li>
<li><a href="../fr462911/index.html">Un an au volant d'une voiture √©lectrique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>