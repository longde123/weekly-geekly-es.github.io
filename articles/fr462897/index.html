<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏻 🧑🏿‍🤝‍🧑🏼 😫 Apprenez OpenGL. Leçon 7.1 - Débogage 👀 👶🏻 🗼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La programmation graphique n'est pas seulement une source de plaisir, mais aussi de frustration lorsque quelque chose ne s'affiche pas comme prévu, ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Leçon 7.1 - Débogage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300">  La programmation graphique n'est pas seulement une source de plaisir, mais aussi de frustration lorsque quelque chose ne s'affiche pas comme prévu, ou que rien ne s'affiche à l'écran.  Étant donné que la plupart de ce que nous faisons est lié à la manipulation des pixels, il peut être difficile de déterminer la cause de l'erreur lorsque quelque chose ne fonctionne pas comme il se doit.  Le débogage de ce type d'erreur est plus difficile que le débogage des erreurs sur le CPU.  Nous n'avons pas de console où nous pouvons afficher le texte, nous ne pouvons pas mettre un point d'arrêt dans le shader et nous ne pouvons pas simplement prendre et vérifier l'état du programme sur le GPU. </p><br><p>  Dans ce didacticiel, nous vous présenterons certaines des méthodes et techniques de débogage de votre programme OpenGL.  Le débogage dans OpenGL n'est pas si difficile, et l'apprentissage de quelques astuces sera certainement payant. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Partie 1. Pour commencer</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création de fenêtres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fenêtre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Systèmes de coordonnées</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 2. Éclairage de base</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'éclairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Matériaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'éclairage multiples</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 3. Télécharger des modèles 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de modèle 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 4. Fonctionnalités avancées d'OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mélange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avancé des données</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avancé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader géométrique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 5. Éclairage avancé</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éclairage avancé.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle Blinn Fong</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fantômes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombrées omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu différé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Théorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumière analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition spéculaire</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 7. Pratique</b> <div class="spoiler_text"><ol><li>  <b>Débogage</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu de texte</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Lorsque vous utilisez incorrectement OpenGL (par exemple, lorsque vous configurez un tampon et oubliez de le lier), OpenGL remarquera et créera un ou plusieurs indicateurs d'erreur personnalisés en arrière-plan.  Nous pouvons suivre ces erreurs en appelant la fonction <code>glGetError()</code> , qui vérifie simplement l'ensemble d'indicateurs d'erreur et renvoie la valeur d'erreur si des erreurs se produisent. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Cette fonction renvoie un indicateur d'erreur ou aucune erreur du tout.  Liste des valeurs de retour: </p><br><div class="scrollable-table"><table><thead><tr><th>  Drapeau </th><th>  Code </th><th>  La description </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td>  Aucune erreur générée depuis le dernier appel glGetError </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  Défini lorsqu'un paramètre d'énumération n'est pas valide </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  Définir lorsque la valeur n'est pas valide </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  Définir lorsqu'une commande avec des paramètres spécifiés n'est pas valide </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  Elle est établie lorsque l'opération consistant à pousser des données sur la pile (push) provoque un débordement de pile. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  Elle est établie lorsque l'opération d'extraction des données de la pile (pop) se produit à partir du plus petit point de la pile. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  Défini lorsqu'une opération d'allocation de mémoire ne peut pas allouer suffisamment de mémoire. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  Défini lors de la lecture / écriture vers / depuis un tampon de cadre qui n'est pas terminé </td></tr></tbody></table></div><br><p>  Dans la documentation des fonctions OpenGL, vous pouvez trouver des codes d'erreur générés par des fonctions mal utilisées.  Par exemple, si vous consultez la documentation de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>glBindTexture()</code></a> , vous pouvez trouver les codes d'erreur générés par cette fonction dans la section Erreurs. <br>  Lorsque l'indicateur d'erreur est défini, aucun autre indicateur d'erreur n'est généré.  De plus, lorsque <code>glGetError</code> est appelée, la fonction efface tous les drapeaux d'erreur (ou un seul sur un système distribué, voir ci-dessous).  Cela signifie que si vous appelez <code>glGetError</code> une fois après chaque trame et obtenez une erreur, cela ne signifie pas que c'est la seule erreur et vous ne savez toujours pas où cette erreur s'est produite. </p><br><blockquote>  Notez que lorsque OpenGL fonctionne de manière distribuée, comme c'est souvent le cas sur les systèmes avec X11, d'autres erreurs peuvent être générées alors qu'elles ont des codes différents.  L'appel de <code>glGetError</code> ensuite simplement l'un des indicateurs de code d'erreur au lieu de tous.  Pour cette raison, ils recommandent d'appeler cette fonction en boucle. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Une caractéristique distinctive de <code>glGetError</code> est qu'il permet de déterminer relativement facilement où une erreur peut se produire et de vérifier que OpenGL est utilisé correctement.  Imaginons que vous ne dessiniez rien et que vous ne connaissiez pas la raison: le tampon de trame est mal réglé?  Vous avez oublié de définir la texture?  En appelant <code>glGetError</code> partout, vous pouvez rapidement déterminer où se produit la première erreur. <br>  Par défaut, <code>glGetError</code> ne signale que le numéro d'erreur, ce qui n'est pas facile à comprendre tant que vous n'avez pas mémorisé les numéros de code.  Il est souvent judicieux d'écrire une petite fonction pour aider à imprimer une chaîne d'erreur avec l'emplacement à partir duquel la fonction est appelée. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Si vous décidez de faire plus d'appels à <code>glCheckError</code> , il sera utile de savoir où l'erreur s'est produite. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Conclusion: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Une chose importante reste: il y a un bogue de longue date dans GLEW: <code>glewInit()</code> définit toujours l'indicateur <code>GL_INVALID_ENUM</code> .  Pour résoudre ce problème, appelez simplement <code>glGetError</code> après <code>glewInit</code> pour effacer l'indicateur: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> n'aide pas beaucoup, car les informations renvoyées sont relativement simples, mais elles aident souvent à détecter les fautes de frappe ou à localiser l'endroit où l'erreur s'est produite.  Il s'agit d'un outil de débogage simple mais efficace. </p><br><h1 id="otladochnyy-vyvod">  Sortie de débogage </h1><br><p>  L'outil est moins connu, mais plus utile que <code>glCheckError</code> , l'extension "debug output" d'OpenGL, qui était incluse dans le profil principal d'OpenGL 4.3.  Avec cette extension, OpenGL enverra un message d'erreur à l'utilisateur avec les détails de l'erreur.  Cette extension fournit non seulement plus d'informations, mais vous permet également de détecter les erreurs là où elles se produisent à l'aide du débogueur. </p><br><blockquote>  La sortie de débogage est incluse dans OpenGL à partir de la version 4.3, ce qui signifie que vous trouverez cette fonctionnalité sur n'importe quelle machine prenant en charge OpenGL 4.3 et supérieur.  Si cette version n'est pas disponible, vous pouvez vérifier les extensions <code>ARB_debug_output</code> et <code>AMD_debug_output</code> .  Il existe également des informations non vérifiées selon lesquelles la sortie de débogage n'est pas prise en charge sur OS X (l'auteur de l'original et le traducteur n'ont pas testé, veuillez en informer l'auteur de l'original ou à moi-même dans des messages privés via le mécanisme de correction d'erreurs, si vous trouvez une confirmation ou une réfutation de ce fait; <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Jeka178RUS a</a> vérifié cela fait: hors de la boîte, la sortie de débogage ne fonctionne pas, il n'a pas vérifié les extensions). </blockquote><p>  Pour commencer à utiliser la sortie de débogage, nous devons demander le contexte de débogage OpenGL pendant le processus d'initialisation.  Ce processus est différent sur différents systèmes de fenêtres, mais ici nous ne discuterons que de GLFW, mais à la fin de l'article dans la section "Matériaux supplémentaires", vous pouvez trouver des informations sur d'autres systèmes de fenêtres. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  Déboguer la sortie dans GLFW </h4><br><p>  La demande de contextes de débogage dans GLFW est étonnamment simple: tout ce que vous devez faire est de donner à GLFW une indication que nous voulons un contexte qui prend en charge la sortie de débogage.  Nous devons le faire avant d'appeler <code>glfwCreateWindow</code> : </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  Dès que nous avons initialisé GLFW, nous devrions avoir un contexte de débogage si nous utilisons OpenGL 4.3 ou supérieur, sinon nous devons tenter notre chance et espérons que le système pourra toujours créer un contexte de débogage.  En cas d'échec, nous devons demander une sortie de débogage via le mécanisme d'extension OpenGL. </p><br><blockquote>  Le contexte de débogage OpenGL peut être plus lent que la normale, vous devez donc supprimer ou commenter cette ligne lorsque vous travaillez sur des optimisations ou avant la publication. </blockquote><p>  Pour vérifier le résultat de l'initialisation du contexte de débogage, il suffit d'exécuter le code suivant: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Comment fonctionne la sortie de débogage?  Nous passons une fonction de rappel à un gestionnaire de messages dans OpenGL (similaire aux rappels dans GLFW) et dans cette fonction, nous pouvons traiter les données OpenGL comme nous le souhaitons, dans notre cas, envoyer des messages d'erreur utiles à la console.  Le prototype de cette fonction: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Notez que sur certains systèmes d'exploitation, le type du dernier paramètre peut être <code>const void*</code> . <br>  Étant donné le grand ensemble de données dont nous disposons, nous pouvons créer un outil d'impression d'erreur utile, comme indiqué ci-dessous: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Lorsque l'extension détecte une erreur OpenGL, elle appelle cette fonction et nous pouvons imprimer une énorme quantité d'informations sur les erreurs.  Notez que nous avons ignoré certaines erreurs, car elles sont inutiles (par exemple, 131185 dans les pilotes NVidia indique que le tampon a été créé avec succès). <br>  Maintenant que nous avons le rappel souhaité, il est temps d'initialiser la sortie de débogage: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Nous disons donc à OpenGL que nous voulons activer la sortie de débogage.  L'appel à <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> indique à OpenGL que nous voulons un message d'erreur quand il vient de se produire. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  Débogage du filtrage de sortie </h4><br><p>  Avec la fonction <code>glDebugMessageControl</code> vous pouvez sélectionner les types d'erreurs que vous souhaitez recevoir.  Dans notre cas, nous obtenons toutes sortes d'erreurs.  Si nous voulions uniquement les erreurs de l'API OpenGL, telles que Erreur et le niveau de signification élevé, nous écririons le code suivant: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  Avec ce contexte de configuration et de débogage, chaque commande OpenGL incorrecte enverra beaucoup d'informations utiles: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Trouver la source de l'erreur via la pile d'appels </h4><br><p>  Une autre astuce avec la sortie de débogage est que vous pouvez établir relativement facilement l'emplacement exact de l'erreur dans votre code.  En définissant un point d'arrêt dans la fonction <code>DebugOutput</code> sur le type d'erreur souhaité (ou au début de la fonction si vous souhaitez intercepter toutes les erreurs), le débogueur intercepte l'erreur et vous pouvez parcourir la pile des appels pour savoir où l'erreur s'est produite: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Cela nécessite une intervention manuelle, mais si vous savez à peu près ce que vous recherchez, il est extrêmement utile de déterminer rapidement quel appel est à l'origine de l'erreur. </p><br><h4 id="svoi-oshibki">  Propres erreurs </h4><br><p>  En plus des erreurs de lecture, nous pouvons les envoyer au système de sortie de débogage à l'aide de <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Ceci est très utile si vous vous connectez à une autre application ou à un code OpenGL qui utilise un contexte de débogage.  Les autres développeurs pourront découvrir rapidement toute erreur signalée qui se produit dans votre code OpenGL personnalisé. <br>  En général, la sortie de débogage (si disponible) est très utile pour détecter rapidement les erreurs et vaut vraiment la peine d'être consacrée à l'optimisation, car elle économise un temps de développement important.  Vous pouvez trouver une copie du code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici en</a> utilisant <code>glGetError</code> et une sortie de débogage.  Il y a des erreurs, essayez de les corriger. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Sortie de débogage de shader </h1><br><p>  En ce qui concerne GLSL, nous n'avons pas accès à des fonctions comme <code>glGetError</code> ou la possibilité de parcourir le code par étapes dans le débogueur.  Lorsque vous rencontrez un écran noir ou un affichage complètement incorrect, il peut être très difficile de comprendre ce qui se passe si le problème est dans le shader.  Oui, les erreurs de compilation signalent des erreurs de syntaxe, mais la capture d'erreurs sémantiques est ce morceau. <br>  L'une des méthodes couramment utilisées pour découvrir ce qui ne va pas avec un shader est d'envoyer toutes les variables pertinentes du programme de shader directement au canal de sortie du fragment shader.  En sortant des variables de shader directement sur le canal de sortie avec la couleur, nous pouvons trouver des informations intéressantes en vérifiant l'image à la sortie.  Par exemple, nous devons savoir si les normales sont correctes pour le modèle.  Nous pouvons les envoyer (transformés ou non) du sommet au fragment shader, où nous dérivons les normales quelque chose comme ceci: <br>  (remarque: pourquoi n'y a-t-il pas de mise en évidence de la syntaxe pour GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  En sortant une variable non colorée sur le canal de sortie avec la couleur telle qu'elle est maintenant, nous pouvons rapidement vérifier la valeur de la variable.  Si, par exemple, le résultat est un écran noir, il est clair que les normales sont incorrectement transférées aux shaders, et lorsqu'elles sont affichées, il est relativement facile de vérifier leur exactitude: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  D'après les résultats visuels, nous pouvons voir que les normales sont correctes, car le côté droit de la combinaison est principalement rouge (ce qui signifie que les normales apparaissent approximativement dans la direction de l'axe x de rinçage) et que la face avant de la combinaison est colorée dans la direction de l'axe z positif (bleu). </p><br><p>  Cette approche peut être étendue à toute variable que vous souhaitez tester.  Chaque fois que vous êtes bloqué et supposez que l'erreur se trouve dans les shaders, essayez de dessiner des variables ou des résultats intermédiaires et découvrez dans quelle partie de l'algorithme il y a une erreur. </p><br><h1 id="opengl-glsl-reference-compiler">  Compilateur de référence OpenGL GLSL </h1><br><p>  Chaque pilote vidéo a ses propres bizarreries.  Par exemple, les pilotes NVIDIA adoucissent légèrement les exigences de la spécification et les pilotes AMD répondent mieux aux spécifications (ce qui est mieux, il me semble).  Le problème est que les shaders fonctionnant sur une machine peuvent ne pas gagner d'argent sur une autre en raison des différences de pilotes. </p><br><p>  Pendant plusieurs années d'expérience, vous pouvez apprendre toutes les différences entre les différents GPU, mais si vous voulez être sûr que vos shaders fonctionneront partout, vous pouvez vérifier votre code avec les spécifications officielles en utilisant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilateur de référence GLSL</a> .  Vous pouvez télécharger le soi-disant <em>validateur GLSL lang</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ). </p><br><p>  Avec ce programme, vous pouvez tester vos shaders en les passant comme 1er argument au programme.  N'oubliez pas que le programme détermine le type de shader par extension: </p><br><ul><li>  <code>.vert</code> : vertex shader </li><li>  <code>.frag</code> : fragment shader </li><li>  <code>.geom</code> : shader géométrique </li><li>  <code>.tesc</code> : <code>.tesc</code> contrôlant le shader </li><li>  <code>.tese</code> : shader informatique de <code>.tese</code> </li><li>  <code>.comp</code> : shader de calcul </li></ul><br><p>  L'exécution du programme est simple: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Notez que s'il n'y a pas d'erreur, le programme ne sortira rien.  Sur un vertex shader cassé, la sortie ressemblera à: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  Le programme ne montrera pas les différences entre les compilateurs GLSL d'AMD, NVidia ou Intel, et ne peut même pas signaler tous les bogues dans le shader, mais il vérifie au moins la conformité des shaders avec les normes. </p><br><h1 id="vyvod-bufera-kadra">  Sortie du tampon de trame </h1><br><p>  Une autre méthode pour votre boîte à outils consiste à afficher le contenu du tampon de trame dans une partie spécifique de l'écran.  Très probablement, vous utilisez souvent des tampons d'images, et comme toute la magie se produit dans les coulisses, il peut être difficile de déterminer ce qui se passe.  La sortie du contenu du tampon de trame est une astuce utile pour vérifier que les choses sont correctes. </p><br><blockquote>  Notez que le contenu du tampon de cadre, comme expliqué ici, fonctionne avec des textures, pas avec des objets dans les tampons de dessin </blockquote><p>  En utilisant un shader simple qui dessine une seule texture, nous pouvons écrire une petite fonction qui dessine rapidement n'importe quelle texture dans le coin supérieur droit de l'écran: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Cela vous donnera une petite fenêtre dans le coin de l'écran pour déboguer la sortie du tampon de trame.  Il est utile, par exemple, lorsque vous essayez de vérifier l'exactitude des normales: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Vous pouvez également développer cette fonction afin qu'elle rende plus d'une texture.  Il s'agit d'un moyen rapide d'obtenir une rétroaction continue de n'importe quoi dans les tampons de trame. </p><br><h1 id="vneshnie-programmy-otladchiki">  Programmes de débogage externes </h1><br><p>  Lorsque tout le reste échoue, il y a une autre astuce: utiliser des programmes tiers.  Ils sont intégrés au pilote OpenGL et peuvent intercepter tous les appels OpenGL pour vous fournir de nombreuses données intéressantes sur votre application.  Ces applications peuvent profiler l'utilisation des fonctions OpenGL, rechercher les goulots d'étranglement et surveiller les tampons de trame, les textures et la mémoire.  Tout en travaillant sur du (gros) code, ces outils peuvent devenir inestimables. </p><br><p>  J'ai énuméré plusieurs outils populaires.  Essayez chacun et choisissez celui qui vous convient le mieux. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc est un bon outil de débogage séparé (entièrement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouvert</a> ).  Pour démarrer la capture, sélectionnez le fichier exécutable et le répertoire de travail.  Votre application fonctionne comme d'habitude, et lorsque vous souhaitez regarder une seule image, vous autorisez RenderDoc à capturer plusieurs images de votre application.  Parmi les trames capturées, vous pouvez afficher l'état du pipeline, toutes les commandes OpenGL, le stockage du tampon et les textures utilisées. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodeXL</a> - Outil de débogage GPU, fonctionne comme une application autonome et un plugin pour Visual Studio.  CodeXL Fournit beaucoup d'informations et est idéal pour le profilage d'applications graphiques.  CodeXL fonctionne également sur les cartes graphiques de NVidia et Intel, mais sans prise en charge du débogage OpenCL. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  Je n'utilisais pas beaucoup CodeXL, car RenderDoc me semblait plus facile, mais j'ai inclus CodeXL dans cette liste car il ressemble à un outil assez fiable et est principalement développé par l'un des plus grands fabricants de GPU. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nsight</a> est un outil de débogage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NUIDIA</a> GPU populaire.  Ce n'est pas seulement un plug-in pour Visual Studio et Eclipse, mais aussi une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application distincte</a> .  Le plugin Nsight est une chose très utile pour les développeurs graphiques car il collecte de nombreuses statistiques en temps réel concernant l'utilisation du GPU et l'état image par image du GPU. </p><br><p>  Au moment où vous lancez votre application via Visual Studio ou Eclipse à l'aide des commandes de débogage ou du profilage Nsight, elle démarre à l'intérieur de l'application elle-même.  Une bonne chose dans Nsight: rendre un système GUI (GUI, interface utilisateur graphique) au-dessus d'une application en cours d'exécution, qui peut être utilisé pour collecter toutes sortes d'informations sur votre application en temps réel ou analyse image par image. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight est un outil très utile qui, à mon avis, surpasse les outils ci-dessus, mais présente un sérieux inconvénient: il <em>ne</em> fonctionne <em>que</em> sur les cartes graphiques NVIDIA.  Si vous utilisez des cartes graphiques NVIDIA et utilisez Visual Studio, alors Nsight vaut vraiment la peine d'être essayé. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">   </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    ?</a> —           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://web.archive.org/web/20150225171555/"> </a> —            Vallentin Source. </li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nous avons un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">télégramme conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la coordination des transferts. </font><font style="vertical-align: inherit;">Si vous avez un sérieux désir d'aider à la traduction, alors vous êtes les bienvenus!</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462897/">https://habr.com/ru/post/fr462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462885/index.html">Réseau IPoE tolérant aux pannes à portée de main</a></li>
<li><a href="../fr462887/index.html">L'expérience de la personnalisation d'une boutique en ligne à l'aide de l'exemple d'une recommandation dynamique</a></li>
<li><a href="../fr462889/index.html">Continuation Story: le propre compilateur de Pascal pour Windows à partir de zéro</a></li>
<li><a href="../fr462893/index.html">Reconnaissance faciale dans les villes: sécurité et confidentialité</a></li>
<li><a href="../fr462895/index.html">Résoudre un problème avec pwnable.kr 17 - memcpy. Alignement des données</a></li>
<li><a href="../fr462903/index.html">Comment nous avons conçu et mis en œuvre le nouveau réseau sur Huawei dans le bureau de Moscou, partie 3: usine de serveurs</a></li>
<li><a href="../fr462905/index.html">Écrire un bot de télégramme en python à l'aide de la bibliothèque de telebot partie 2</a></li>
<li><a href="../fr462907/index.html">ngFanatic hebdomadaire</a></li>
<li><a href="../fr462909/index.html">Les fruits de l'évolution de l'ASIC: sur les fabricants, les mineurs de SHA-256 et les bizarreries du hashrate astronomique</a></li>
<li><a href="../fr462911/index.html">Un an au volant d'une voiture électrique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>