<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍸 🏖️ ⛳️ So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Yandex.Direct-API-Beispiels (Teil 1) ⏏️ 👩🏽‍🤝‍👩🏼 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die heutige R-Sprache ist eines der leistungsstärksten und multifunktionalsten Werkzeuge für die Arbeit mit Daten. Wie wir jedoch fast immer wissen, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Yandex.Direct-API-Beispiels (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p>  Die heutige R-Sprache ist eines der leistungsstärksten und multifunktionalsten Werkzeuge für die Arbeit mit Daten. Wie wir jedoch fast immer wissen, befindet sich in jedem Fass Honig eine Fliege in der Salbe.  Tatsache ist, dass R standardmäßig Single-Threaded ist. </p><br><p>  Dies wird Sie höchstwahrscheinlich nicht lange genug stören, und es ist unwahrscheinlich, dass Sie diese Frage stellen.  Wenn Sie beispielsweise vor der Aufgabe stehen, Daten von einer großen Anzahl von Werbekonten über die API zu erfassen, z. B. Yandex.Direct, können Sie die Zeit für die Datenerfassung mithilfe von Multithreading mindestens zwei- bis dreimal erheblich verkürzen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="Bild"></p><a name="habracut"></a><br><p> Das Thema Multithreading in R ist nicht neu und wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> wiederholt auf Habré angesprochen, aber die letzte Veröffentlichung stammt aus dem Jahr 2013, und wie man sagt, ist alles Neue gut vergessen, alt.  Darüber hinaus wurde zuvor Multithreading für die Berechnung von Modellen und das Training neuronaler Netze erörtert, und wir werden über die Verwendung von Asynchronität für die Arbeit mit der API sprechen.  Trotzdem möchte ich diese Gelegenheit nutzen, um den Autoren dieser Artikel zu danken, weil  Sie haben mir sehr geholfen, diesen Artikel mit ihren Veröffentlichungen zu schreiben. </p><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Multithreading?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Welche Pakete werden wir verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autorisierung in Yandex.Direct, Ryandexdirect-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequentielle Lösung mit einem Thread und for-Schleife</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multithreading-Lösung in R.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DoSNOW-Paket und Multithread-Funktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DoParallel-Paket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschwindigkeitstest zwischen den drei überprüften Ansätzen, Rbenchmark-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><p>  Der zweite Teil des Artikels, der sich mit moderneren Optionen zur Implementierung von Multithreading in R befasst, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verfügbar. </p><br><h2 id="chto-takoe-mnogopotochnost">  Was ist Multithreading? </h2><br><p>  <u><strong>One-Threading (sequentielle Berechnungen)</strong></u> - Ein Berechnungsmodus, in dem alle Aktionen (Aufgaben) nacheinander ausgeführt werden. In diesem Fall entspricht die Gesamtdauer aller angegebenen Operationen der Summe der Dauer aller Operationen. </p><br><p>  <u><strong>Multithreading (paralleles Rechnen)</strong></u> - ein Rechenmodus, in dem die angegebenen Aktionen (Aufgaben) parallel ausgeführt werden, d. H.  Gleichzeitig entspricht die Gesamtausführungszeit aller Operationen nicht der Summe der Dauer aller Operationen. </p><br><p>  Schauen wir uns zur Vereinfachung der Wahrnehmung die folgende Tabelle an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="Bild"></p><br><p>  Die erste Zeile der angegebenen Tabelle enthält bedingte Zeiteinheiten. In diesem Fall spielt es für uns keine Rolle, Sekunden, Minuten oder andere Zeiträume. </p><br><p>  In diesem Beispiel müssen 4 Operationen ausgeführt werden. Jede Operation hat in diesem Fall eine andere Berechnungsdauer. Im Single-Thread-Modus werden alle 4 Operationen nacheinander ausgeführt. Daher beträgt die Gesamtzeit für ihre Ausführung t1 + t2 + t3 + t4, 3 + 1 + 5 + 4 = 13. </p><br><p>  Im Multithread-Modus werden alle 4 Aufgaben parallel ausgeführt, d. H.  Um die nächste Aufgabe zu starten, müssen Sie nicht warten, bis die vorherige abgeschlossen ist. Wenn wir also unsere Aufgabe in 4 Threads starten, entspricht die Gesamtberechnungszeit der Berechnungszeit der größten Aufgabe. In unserem Fall ist es Aufgabe t3, deren Berechnungsdauer in unserem Beispiel 5 beträgt temporäre Einheiten und die Ausführungszeit aller 4 Operationen in diesem Fall entsprechen 5 temporären Einheiten. </p><br><h2 id="kakie-pakety-my-budem-ispolzovat">  Welche Pakete werden wir verwenden </h2><br><p> Für Berechnungen im Multithread-Modus verwenden wir die <code>doParallel</code> <code>foreach</code> , <code>doSNOW</code> und <code>doParallel</code> . </p><br><p>  Mit dem <code>foreach</code> Paket können Sie das <code>foreach</code> Konstrukt verwenden, das im Wesentlichen eine erweiterte for-Schleife ist. </p><br><p>  Die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> sind im Wesentlichen Zwillingsbrüder, mit denen Sie virtuelle Cluster erstellen und für parallele Berechnungen verwenden können. </p><br><p>  Am Ende des Artikels messen und vergleichen wir mithilfe des <code>rbenchmark</code> Pakets die Dauer der Datenerfassungsvorgänge über die Yandex.Direct-API mit allen unten beschriebenen Methoden. </p><br><p>  Um mit der Yandex.Direct-API zu arbeiten, verwenden wir das ryandexdirect-Paket. In diesem Artikel wird es als Beispiel verwendet. Weitere Details zu seinen Funktionen und Funktionen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> . </p><br><p>  Code zur Installation aller erforderlichen Pakete: </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha">  Herausforderung </h2><br><p>  Sie müssen einen Code schreiben, der eine Liste von Keywords von einer beliebigen Anzahl von Yandex.Direct-Werbekonten anfordert.  Das Ergebnis muss in einem Datumsrahmen erfasst werden, in dem ein zusätzliches Feld mit dem Login des Werbekontos angezeigt wird, zu dem das Keyword gehört. </p><br><p>  Darüber hinaus besteht unsere Aufgabe darin, einen Code zu schreiben, der diesen Vorgang so schnell wie möglich auf einer beliebigen Anzahl von Werbekonten ausführt. </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Autorisierung in Yandex.Direct </h2><br><p>  Um mit der API der Yandex.Direct-Werbeplattform arbeiten zu können, muss zunächst für jedes Konto, von dem wir eine Liste mit Keywords anfordern möchten, eine Autorisierung durchgeführt werden. </p><br><p>  Der gesamte in diesem Artikel angegebene Code spiegelt ein Beispiel für die Arbeit mit regulären Yandex.Direct-Werbekonten wider. Wenn Sie unter einem Agentenkonto arbeiten, müssen Sie das Argument <em>AgencyAccount verwenden</em> und die Anmeldung für das Agentenkonto an dieses Konto übergeben.  Weitere Informationen zum Arbeiten mit Agentenkonten von Yandex.Direct mit dem Paket ryandexdirect finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Für die Autorisierung muss die Funktion <code>yadirAuth</code> aus dem Paket <code>yadirAuth</code> ausgeführt werden. <code>yadirAuth</code> den <code>yadirAuth</code> Code zu wiederholen, ist für jedes Konto erforderlich, von dem Sie eine Liste der Schlüsselwörter und ihrer Parameter anfordern. </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p>  Der Autorisierungsprozess in Yandex.Direct über das Paket <code>ryandexdirect</code> absolut sicher, obwohl er über eine Website eines Drittanbieters geleitet wird.  Ich habe bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie sicher es ist, R-Pakete für die Arbeit mit der Advertising Systems API zu verwenden"</a> ausführlich über die Sicherheit seiner Verwendung gesprochen. </p><br><p>  Nach der Autorisierung wird unter jedem Konto in Ihrem Arbeitsverzeichnis eine Datei <em>login.yadirAuth.RData</em> erstellt, in der die Anmeldeinformationen für jedes Konto gespeichert werden.  Der Dateiname beginnt mit der im <em>Login-</em> Argument angegebenen Anmeldung.  Wenn Sie die Dateien nicht im aktuellen Arbeitsverzeichnis, sondern in einem anderen Ordner <em>speichern müssen</em> , verwenden Sie das <em>TokenPath-</em> Argument. In diesem Fall müssen Sie beim Anfordern von Schlüsselwörtern mithilfe der Funktion <code>yadirGetKeyWords</code> auch das <em>TokenPath-</em> Argument verwenden und den Pfad zu dem Ordner angeben, in dem Sie die Dateien gespeichert haben mit Anmeldeinformationen. </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for">  Sequentielle Lösung mit einem Thread und for-Schleife </h2><br><p>  Der einfachste Weg, Daten von mehreren Konten gleichzeitig zu erfassen, ist die Verwendung der <code>for</code> Schleife.  Einfach, aber nicht die effektivste, weil  Eines der Entwicklungsprinzipien in der R-Sprache besteht darin, die Verwendung von Schleifen im Code zu vermeiden. </p><br><p>  Unten finden Sie einen Beispielcode zum Sammeln von Daten von 4 Konten mithilfe der for-Schleife. In diesem Beispiel können Sie Daten von einer beliebigen Anzahl von Werbekonten erfassen. </p><br><div class="spoiler">  <b class="spoiler_title">Code 1: Wir verarbeiten 4 Konten mit der üblichen for-Schleife</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p>  Das Messen der Laufzeit mit der Funktion system.time ergab folgendes Ergebnis: </p><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 178.83 <br>  <u>System:</u> 0,63 <br>  <u>bestanden:</u> 320,39 </p><br><p>  Das Sammeln von Schlüsselwörtern für 4 Konten dauerte 320 Sekunden. Aus den Informationsmeldungen, die <code>yadirGetKeyWords</code> Funktion <code>yadirGetKeyWords</code> während des Betriebs anzeigt, wird das größte Konto <code>yadirGetKeyWords</code> , von dem 5970 Schlüsselwörter empfangen wurden und 142 Sekunden verarbeitet wurden. </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  Multithreading-Lösung in R. </h2><br><p>  Ich habe bereits oben geschrieben, dass wir für Multithreading die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> . </p><br><p>  Ich möchte darauf aufmerksam machen, dass fast jede API ihre eigenen Einschränkungen hat und die Yandex.Direct-API keine Ausnahme darstellt.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfe</a> zur Arbeit mit der Yandex.Direct-API heißt es: </p><br><blockquote>  Es sind nicht mehr als fünf gleichzeitige API-Anforderungen für einen Benutzer zulässig. </blockquote><p>  Trotz der Tatsache, dass wir in diesem Fall ein Beispiel für die Erstellung von 4 Streams betrachten, können Sie bei der Arbeit mit Yandex.Direct 5 Streams erstellen, selbst wenn Sie alle Anforderungen unter demselben Benutzer senden.  Es ist jedoch am rationalsten, 1 Thread pro 1 Kern Ihres Prozessors zu verwenden. Sie können die Anzahl der physischen Prozessorkerne mit dem Befehl <code>parallel::detectCores(logical = FALSE)</code> Die Anzahl der logischen Kerne kann mit <code>parallel::detectCores(logical = TRUE)</code> .  Ein detaillierteres Verständnis darüber, was ein solcher physischer und logischer Kern bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> möglich ist. </p><br><p>  Zusätzlich zur Begrenzung der Anzahl der Anforderungen gibt es eine tägliche Begrenzung der Anzahl der Punkte für den Zugriff auf die Yandex.Direct-API. Diese kann für alle Konten unterschiedlich sein. Jede Anforderung verbraucht je nach ausgeführter Operation auch eine andere Anzahl von Punkten.  Wenn Sie beispielsweise eine Liste mit Schlüsselwörtern abfragen, erhalten Sie 15 Punkte für eine abgeschlossene Abfrage und 3 Punkte für jeweils 2000 Wörter. Sie können herausfinden, wie Punkte im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Zertifikat</a> abgeschrieben werden.  Sie können auch Informationen über die Anzahl der erzielten und verfügbaren Punkte sowie deren tägliches Limit in Informationsnachrichten <code>yadirGetKeyWords</code> , die von der Funktion <code>yadirGetKeyWords</code> an die Konsole <code>yadirGetKeyWords</code> werden. </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p>  Lassen Sie uns der Reihe nach mit <code>doSNOW</code> und <code>doParallel</code> . </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  DoSNOW-Paket und Multithread-Funktionen </h3><br><p>  Wir schreiben dieselbe Operation für den Multi-Thread-Berechnungsmodus neu, erstellen in diesem Fall 4 Threads und verwenden anstelle der <code>for</code> Schleife das <code>foreach</code> Konstrukt. </p><br><div class="spoiler">  <b class="spoiler_title">Code 2: Paralleles Rechnen mit doSNOW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p>  In diesem Fall ergab die Messung der Laufzeit mit der Funktion system.time das folgende Ergebnis: </p><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 0.17 <br>  <u>System:</u> 0,08 <br>  <u>bestanden:</u> 151,47 </p><br><p>  Das gleiche Ergebnis, d.h.  Wir haben die Sammlung von Schlüsselwörtern von 4 Yandex.Direct-Konten in 151 Sekunden erhalten, d. h.  2 mal schneller.  Außerdem habe ich gerade im letzten Beispiel geschrieben, wie lange es gedauert hat, eine Liste von Keywords aus dem größten Konto zu laden (142 Sekunden), d. H.  In diesem Beispiel ist die Gesamtzeit fast identisch mit der Verarbeitungszeit des größten Kontos.  Tatsache ist, dass wir mit Hilfe der <code>foreach</code> Funktion gleichzeitig den Prozess des Sammelns von Daten in 4 Threads gestartet haben, d. H.  Gleichzeitig werden Daten von allen 4 Konten gesammelt. Die Gesamtzeit entspricht der Verarbeitungszeit des größten Kontos. </p><br><p>  Ich werde <em>Code 2 kurz</em> <code>makeCluster</code> Funktion <code>makeCluster</code> für die Anzahl der Threads verantwortlich. In diesem Fall haben wir einen Cluster mit 4 Prozessorkernen erstellt. Wie ich bereits bei der Arbeit mit der Yandex.Direct-API geschrieben habe, können Sie unabhängig von der Anzahl der Konten 5 Threads erstellen Wenn Sie 5-15-100 oder mehr verarbeiten müssen, können Sie 5 Anforderungen gleichzeitig an die API senden. </p><br><p>  Als nächstes startet die Funktion <code>registerDoSNOW</code> den erstellten Cluster. </p><br><p>  Danach verwenden wir das <code>foreach</code> Konstrukt, wie ich bereits sagte, dieses Konstrukt ist eine verbesserte for-Schleife.  Sie geben den Zähler als erstes Argument an. In dem Beispiel, das ich <em>login genannt</em> habe, wird bei jeder Iteration über die Elemente des <em>Anmeldevektors</em> iteriert. Wenn wir <code>for ( login in logins)</code> schreiben, erhalten wir dasselbe Ergebnis in der <code>for</code> Schleife. </p><br><p>  Als Nächstes müssen Sie im Argument <em>.combine</em> die Funktion <em>angeben,</em> mit der Sie die bei jeder Iteration erzielten Ergebnisse kombinieren. Die häufigsten Optionen sind: </p><br><ul><li>  <code>rbind</code> - Verbinde die resultierenden Tabellen Zeile für Zeile untereinander. </li><li>  <code>cbind</code> - Verbinde die resultierenden Tabellen in Spalten. </li><li>  <code>"+"</code> - fasst das bei jeder Iteration erhaltene Ergebnis zusammen. </li></ul><br><p>  Sie können auch jede andere Funktion verwenden, auch selbst geschrieben. </p><br><p>  Mit dem Argument <em>.inorder = F</em> können Sie die Arbeit der Funktion etwas beschleunigen, wenn es Ihnen egal ist, in welcher Reihenfolge die Ergebnisse kombiniert werden sollen. In diesem Fall ist die Reihenfolge für uns nicht wichtig. </p><br><p>  Als nächstes kommt der <code>%dopar%</code> -Operator, der die Schleife im parallelen Rechenmodus startet. Wenn Sie den <code>%do%</code> -Operator verwenden, werden die Iterationen nacheinander ausgeführt, ebenso wie bei Verwendung der üblichen <code>for</code> Schleife. </p><br><p>  Die <code>stopCluster</code> Funktion stoppt den Cluster. </p><br><p>  Multithreading, oder besser gesagt das <code>foreach</code> Konstrukt im Multithread-Modus, weist einige Funktionen auf. In diesem Fall starten wir jeden parallelen Prozess in einer neuen, sauberen R-Sitzung.  Um die generischen Funktionen und Objekte darin zu verwenden, die außerhalb des <code>foreach</code> Konstrukts definiert wurden, müssen Sie sie daher mit dem Argument <em>.export exportieren</em> .  Dieses Argument verwendet einen Textvektor, der die Namen der Objekte enthält, die Sie in <code>foreach</code> . </p><br><p>  Außerdem werden in <code>foreach</code> im parallelen Modus die zuvor verbundenen Pakete standardmäßig nicht angezeigt, sodass sie auch mit dem Argument <em>.packages</em> in foreach übergeben werden <em>müssen</em> .  Es ist auch erforderlich, Pakete zu übertragen, indem ihre Namen in einem <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> , z. B. <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> .  Im obigen <em>Codebeispiel 2</em> laden wir auf diese Weise das <strong>ryandexdirect-</strong> Paket bei jeder Iteration von <code>foreach</code> . </p><br><h3 id="paket-doparallel">  DoParallel-Paket </h3><br><p>  Wie ich oben geschrieben habe, sind die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> Zwillinge, daher haben sie dieselbe Syntax. </p><br><div class="spoiler">  <b class="spoiler_title">Code 5: Paralleles Rechnen mit doParallel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 0,25 <br>  <u>System:</u> 0,01 <br>  <u>bestanden:</u> 173,28 </p><br><p>  Wie Sie in diesem Fall sehen können, unterscheidet sich die Ausführungszeit geringfügig vom vorherigen Beispiel für parallelen Computercode mit dem Paket <code>doSNOW</code> . </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami">  Geschwindigkeitstest zwischen den drei untersuchten Ansätzen </h2><br><p>  Führen Sie nun den Geschwindigkeitstest mit dem Paket <code>rbenchmark</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="Bild"></p><br><p>  Wie Sie sehen können, haben die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> selbst bei einem Test mit 4 Konten Daten mit Schlüsselwörtern zweimal schneller empfangen als die sequentielle for-Schleife. Wenn Sie einen Cluster mit 5 Kernen erstellen und 50 oder 100 Konten verarbeiten, ist der Unterschied sogar noch größer. </p><br><div class="spoiler">  <b class="spoiler_title">Code 6: Skript zum Vergleichen der Geschwindigkeit von Multithreading und sequentiellem Computing</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p>  Abschließend werde ich den obigen <em>Code 5</em> erläutern, mit dem wir die Arbeitsgeschwindigkeit getestet haben. </p><br><p>  Zunächst haben wir drei Funktionen erstellt: </p><br><p>  <code>for_fun</code> - eine Funktion, die Schlüsselwörter von mehreren Konten anfordert und diese nacheinander in einem regulären Zyklus sortiert. </p><br><p>  <code>dosnow_fun</code> - eine Funktion, die mithilfe des <code>doSNOW</code> Pakets eine Liste von Schlüsselwörtern im Multithread-Modus <code>doSNOW</code> . </p><br><p>  <code>dopar_fun</code> - eine Funktion, die im Multithread-Modus mithilfe des <code>doParallel</code> Pakets eine Liste von Schlüsselwörtern <code>doParallel</code> . </p><br><p>  Als nächstes führen wir innerhalb des Konstrukts inside die <code>benchmark</code> Funktion aus dem <code>rbenchmark</code> Paket aus, geben die Namen der Tests (for_cycle, dosnow, doparallel) und für jede Funktion die Funktionen an: <code>for_fun(logins = logins)</code> ;  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> . </p><br><p>  Das <em>Replikationsargument</em> ist für die Anzahl der Tests verantwortlich, d.h.  Wie oft werden wir jede Funktion ausführen? </p><br><p>  Mit dem <em>Spaltenargument</em> können Sie angeben, welche Spalten Sie erhalten möchten. In unserem Fall bedeutet "Test", "Replikationen", "verstrichen", dass die Spalten zurückgegeben werden: Name des Tests, Anzahl der Tests, Gesamtausführungszeit aller Tests. </p><br><p>  Sie können auch berechnete Spalten hinzufügen ( <code>{ average = elapsed/replications }</code> ), d. H.  Die Ausgabe ist eine durchschnittliche Spalte, die die Gesamtzeit durch die Anzahl der Tests dividiert. Daher berechnen wir die durchschnittliche Ausführungszeit jeder Funktion. </p><br><p>  <em>Die Bestellung</em> ist für die Sortierung der Testergebnisse verantwortlich. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  In diesem Artikel wird im Prinzip eine ziemlich universelle Methode zur Beschleunigung der Arbeit mit der API beschrieben, aber jede API hat ihre Grenzen. Daher ist das obige Beispiel speziell in dieser Form bei so vielen Threads für die Arbeit mit der Yandex.Direct-API geeignet, um sie mit der API zu verwenden Bei anderen Diensten ist es zunächst erforderlich, die Dokumentation zu den Grenzwerten in der API für die Anzahl der gleichzeitig gesendeten Anforderungen zu lesen. Andernfalls wird möglicherweise der Fehler " <code>Too Many Requests</code> angezeigt. </p><br><p>  Die Fortsetzung dieses Artikels finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437078/">https://habr.com/ru/post/de437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437068/index.html">ILV entsperrt 2,7 Millionen IP-Adressen</a></li>
<li><a href="../de437070/index.html">Survey Data Science Tools 2019</a></li>
<li><a href="../de437072/index.html">Schwächen Sie Nüsse in Habr-Regeln</a></li>
<li><a href="../de437074/index.html">Google blockiert möglicherweise seinen Nachrichtendienst in Europa</a></li>
<li><a href="../de437076/index.html">Der Fall und die Wiederherstellung eines Schimmelpilzes</a></li>
<li><a href="../de437084/index.html">Von Uncharted zu Obra Dinn: Lucas Pope spricht über seine Karriere in der Spieleentwicklung</a></li>
<li><a href="../de437086/index.html">Medien: Hacker hackten sich in die Datenbank der US Securities Commission und verdienten Millionen durch Insiderhandel</a></li>
<li><a href="../de437088/index.html">Förderung eines Startups im Ausland: Wie man mit Medium Hunderttausende englischsprachiger Leser erreicht</a></li>
<li><a href="../de437092/index.html">Die Sicherheit von Algorithmen für maschinelles Lernen. Python-Angriffe</a></li>
<li><a href="../de437094/index.html">Wir haben den Atlassian Service Desk gepumpt - die Ankündigung des Mitaps und der Live-Übertragung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>