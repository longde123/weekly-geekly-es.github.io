<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∏ üèñÔ∏è ‚õ≥Ô∏è So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Yandex.Direct-API-Beispiels (Teil 1) ‚èèÔ∏è üë©üèΩ‚Äçü§ù‚Äçüë©üèº ‚úãüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die heutige R-Sprache ist eines der leistungsst√§rksten und multifunktionalsten Werkzeuge f√ºr die Arbeit mit Daten. Wie wir jedoch fast immer wissen, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Yandex.Direct-API-Beispiels (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p>  Die heutige R-Sprache ist eines der leistungsst√§rksten und multifunktionalsten Werkzeuge f√ºr die Arbeit mit Daten. Wie wir jedoch fast immer wissen, befindet sich in jedem Fass Honig eine Fliege in der Salbe.  Tatsache ist, dass R standardm√§√üig Single-Threaded ist. </p><br><p>  Dies wird Sie h√∂chstwahrscheinlich nicht lange genug st√∂ren, und es ist unwahrscheinlich, dass Sie diese Frage stellen.  Wenn Sie beispielsweise vor der Aufgabe stehen, Daten von einer gro√üen Anzahl von Werbekonten √ºber die API zu erfassen, z. B. Yandex.Direct, k√∂nnen Sie die Zeit f√ºr die Datenerfassung mithilfe von Multithreading mindestens zwei- bis dreimal erheblich verk√ºrzen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="Bild"></p><a name="habracut"></a><br><p> Das Thema Multithreading in R ist nicht neu und wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> wiederholt auf Habr√© angesprochen, aber die letzte Ver√∂ffentlichung stammt aus dem Jahr 2013, und wie man sagt, ist alles Neue gut vergessen, alt.  Dar√ºber hinaus wurde zuvor Multithreading f√ºr die Berechnung von Modellen und das Training neuronaler Netze er√∂rtert, und wir werden √ºber die Verwendung von Asynchronit√§t f√ºr die Arbeit mit der API sprechen.  Trotzdem m√∂chte ich diese Gelegenheit nutzen, um den Autoren dieser Artikel zu danken, weil  Sie haben mir sehr geholfen, diesen Artikel mit ihren Ver√∂ffentlichungen zu schreiben. </p><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Multithreading?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Welche Pakete werden wir verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autorisierung in Yandex.Direct, Ryandexdirect-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequentielle L√∂sung mit einem Thread und for-Schleife</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multithreading-L√∂sung in R.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DoSNOW-Paket und Multithread-Funktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DoParallel-Paket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschwindigkeitstest zwischen den drei √ºberpr√ºften Ans√§tzen, Rbenchmark-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><p>  Der zweite Teil des Artikels, der sich mit moderneren Optionen zur Implementierung von Multithreading in R befasst, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar. </p><br><h2 id="chto-takoe-mnogopotochnost">  Was ist Multithreading? </h2><br><p>  <u><strong>One-Threading (sequentielle Berechnungen)</strong></u> - Ein Berechnungsmodus, in dem alle Aktionen (Aufgaben) nacheinander ausgef√ºhrt werden. In diesem Fall entspricht die Gesamtdauer aller angegebenen Operationen der Summe der Dauer aller Operationen. </p><br><p>  <u><strong>Multithreading (paralleles Rechnen)</strong></u> - ein Rechenmodus, in dem die angegebenen Aktionen (Aufgaben) parallel ausgef√ºhrt werden, d. H.  Gleichzeitig entspricht die Gesamtausf√ºhrungszeit aller Operationen nicht der Summe der Dauer aller Operationen. </p><br><p>  Schauen wir uns zur Vereinfachung der Wahrnehmung die folgende Tabelle an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="Bild"></p><br><p>  Die erste Zeile der angegebenen Tabelle enth√§lt bedingte Zeiteinheiten. In diesem Fall spielt es f√ºr uns keine Rolle, Sekunden, Minuten oder andere Zeitr√§ume. </p><br><p>  In diesem Beispiel m√ºssen 4 Operationen ausgef√ºhrt werden. Jede Operation hat in diesem Fall eine andere Berechnungsdauer. Im Single-Thread-Modus werden alle 4 Operationen nacheinander ausgef√ºhrt. Daher betr√§gt die Gesamtzeit f√ºr ihre Ausf√ºhrung t1 + t2 + t3 + t4, 3 + 1 + 5 + 4 = 13. </p><br><p>  Im Multithread-Modus werden alle 4 Aufgaben parallel ausgef√ºhrt, d. H.  Um die n√§chste Aufgabe zu starten, m√ºssen Sie nicht warten, bis die vorherige abgeschlossen ist. Wenn wir also unsere Aufgabe in 4 Threads starten, entspricht die Gesamtberechnungszeit der Berechnungszeit der gr√∂√üten Aufgabe. In unserem Fall ist es Aufgabe t3, deren Berechnungsdauer in unserem Beispiel 5 betr√§gt tempor√§re Einheiten und die Ausf√ºhrungszeit aller 4 Operationen in diesem Fall entsprechen 5 tempor√§ren Einheiten. </p><br><h2 id="kakie-pakety-my-budem-ispolzovat">  Welche Pakete werden wir verwenden </h2><br><p> F√ºr Berechnungen im Multithread-Modus verwenden wir die <code>doParallel</code> <code>foreach</code> , <code>doSNOW</code> und <code>doParallel</code> . </p><br><p>  Mit dem <code>foreach</code> Paket k√∂nnen Sie das <code>foreach</code> Konstrukt verwenden, das im Wesentlichen eine erweiterte for-Schleife ist. </p><br><p>  Die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> sind im Wesentlichen Zwillingsbr√ºder, mit denen Sie virtuelle Cluster erstellen und f√ºr parallele Berechnungen verwenden k√∂nnen. </p><br><p>  Am Ende des Artikels messen und vergleichen wir mithilfe des <code>rbenchmark</code> Pakets die Dauer der Datenerfassungsvorg√§nge √ºber die Yandex.Direct-API mit allen unten beschriebenen Methoden. </p><br><p>  Um mit der Yandex.Direct-API zu arbeiten, verwenden wir das ryandexdirect-Paket. In diesem Artikel wird es als Beispiel verwendet. Weitere Details zu seinen Funktionen und Funktionen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> . </p><br><p>  Code zur Installation aller erforderlichen Pakete: </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha">  Herausforderung </h2><br><p>  Sie m√ºssen einen Code schreiben, der eine Liste von Keywords von einer beliebigen Anzahl von Yandex.Direct-Werbekonten anfordert.  Das Ergebnis muss in einem Datumsrahmen erfasst werden, in dem ein zus√§tzliches Feld mit dem Login des Werbekontos angezeigt wird, zu dem das Keyword geh√∂rt. </p><br><p>  Dar√ºber hinaus besteht unsere Aufgabe darin, einen Code zu schreiben, der diesen Vorgang so schnell wie m√∂glich auf einer beliebigen Anzahl von Werbekonten ausf√ºhrt. </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Autorisierung in Yandex.Direct </h2><br><p>  Um mit der API der Yandex.Direct-Werbeplattform arbeiten zu k√∂nnen, muss zun√§chst f√ºr jedes Konto, von dem wir eine Liste mit Keywords anfordern m√∂chten, eine Autorisierung durchgef√ºhrt werden. </p><br><p>  Der gesamte in diesem Artikel angegebene Code spiegelt ein Beispiel f√ºr die Arbeit mit regul√§ren Yandex.Direct-Werbekonten wider. Wenn Sie unter einem Agentenkonto arbeiten, m√ºssen Sie das Argument <em>AgencyAccount verwenden</em> und die Anmeldung f√ºr das Agentenkonto an dieses Konto √ºbergeben.  Weitere Informationen zum Arbeiten mit Agentenkonten von Yandex.Direct mit dem Paket ryandexdirect finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  F√ºr die Autorisierung muss die Funktion <code>yadirAuth</code> aus dem Paket <code>yadirAuth</code> ausgef√ºhrt werden. <code>yadirAuth</code> den <code>yadirAuth</code> Code zu wiederholen, ist f√ºr jedes Konto erforderlich, von dem Sie eine Liste der Schl√ºsselw√∂rter und ihrer Parameter anfordern. </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p>  Der Autorisierungsprozess in Yandex.Direct √ºber das Paket <code>ryandexdirect</code> absolut sicher, obwohl er √ºber eine Website eines Drittanbieters geleitet wird.  Ich habe bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie sicher es ist, R-Pakete f√ºr die Arbeit mit der Advertising Systems API zu verwenden"</a> ausf√ºhrlich √ºber die Sicherheit seiner Verwendung gesprochen. </p><br><p>  Nach der Autorisierung wird unter jedem Konto in Ihrem Arbeitsverzeichnis eine Datei <em>login.yadirAuth.RData</em> erstellt, in der die Anmeldeinformationen f√ºr jedes Konto gespeichert werden.  Der Dateiname beginnt mit der im <em>Login-</em> Argument angegebenen Anmeldung.  Wenn Sie die Dateien nicht im aktuellen Arbeitsverzeichnis, sondern in einem anderen Ordner <em>speichern m√ºssen</em> , verwenden Sie das <em>TokenPath-</em> Argument. In diesem Fall m√ºssen Sie beim Anfordern von Schl√ºsselw√∂rtern mithilfe der Funktion <code>yadirGetKeyWords</code> auch das <em>TokenPath-</em> Argument verwenden und den Pfad zu dem Ordner angeben, in dem Sie die Dateien gespeichert haben mit Anmeldeinformationen. </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for">  Sequentielle L√∂sung mit einem Thread und for-Schleife </h2><br><p>  Der einfachste Weg, Daten von mehreren Konten gleichzeitig zu erfassen, ist die Verwendung der <code>for</code> Schleife.  Einfach, aber nicht die effektivste, weil  Eines der Entwicklungsprinzipien in der R-Sprache besteht darin, die Verwendung von Schleifen im Code zu vermeiden. </p><br><p>  Unten finden Sie einen Beispielcode zum Sammeln von Daten von 4 Konten mithilfe der for-Schleife. In diesem Beispiel k√∂nnen Sie Daten von einer beliebigen Anzahl von Werbekonten erfassen. </p><br><div class="spoiler">  <b class="spoiler_title">Code 1: Wir verarbeiten 4 Konten mit der √ºblichen for-Schleife</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p>  Das Messen der Laufzeit mit der Funktion system.time ergab folgendes Ergebnis: </p><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 178.83 <br>  <u>System:</u> 0,63 <br>  <u>bestanden:</u> 320,39 </p><br><p>  Das Sammeln von Schl√ºsselw√∂rtern f√ºr 4 Konten dauerte 320 Sekunden. Aus den Informationsmeldungen, die <code>yadirGetKeyWords</code> Funktion <code>yadirGetKeyWords</code> w√§hrend des Betriebs anzeigt, wird das gr√∂√üte Konto <code>yadirGetKeyWords</code> , von dem 5970 Schl√ºsselw√∂rter empfangen wurden und 142 Sekunden verarbeitet wurden. </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  Multithreading-L√∂sung in R. </h2><br><p>  Ich habe bereits oben geschrieben, dass wir f√ºr Multithreading die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> . </p><br><p>  Ich m√∂chte darauf aufmerksam machen, dass fast jede API ihre eigenen Einschr√§nkungen hat und die Yandex.Direct-API keine Ausnahme darstellt.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfe</a> zur Arbeit mit der Yandex.Direct-API hei√üt es: </p><br><blockquote>  Es sind nicht mehr als f√ºnf gleichzeitige API-Anforderungen f√ºr einen Benutzer zul√§ssig. </blockquote><p>  Trotz der Tatsache, dass wir in diesem Fall ein Beispiel f√ºr die Erstellung von 4 Streams betrachten, k√∂nnen Sie bei der Arbeit mit Yandex.Direct 5 Streams erstellen, selbst wenn Sie alle Anforderungen unter demselben Benutzer senden.  Es ist jedoch am rationalsten, 1 Thread pro 1 Kern Ihres Prozessors zu verwenden. Sie k√∂nnen die Anzahl der physischen Prozessorkerne mit dem Befehl <code>parallel::detectCores(logical = FALSE)</code> Die Anzahl der logischen Kerne kann mit <code>parallel::detectCores(logical = TRUE)</code> .  Ein detaillierteres Verst√§ndnis dar√ºber, was ein solcher physischer und logischer Kern bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> m√∂glich ist. </p><br><p>  Zus√§tzlich zur Begrenzung der Anzahl der Anforderungen gibt es eine t√§gliche Begrenzung der Anzahl der Punkte f√ºr den Zugriff auf die Yandex.Direct-API. Diese kann f√ºr alle Konten unterschiedlich sein. Jede Anforderung verbraucht je nach ausgef√ºhrter Operation auch eine andere Anzahl von Punkten.  Wenn Sie beispielsweise eine Liste mit Schl√ºsselw√∂rtern abfragen, erhalten Sie 15 Punkte f√ºr eine abgeschlossene Abfrage und 3 Punkte f√ºr jeweils 2000 W√∂rter. Sie k√∂nnen herausfinden, wie Punkte im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Zertifikat</a> abgeschrieben werden.  Sie k√∂nnen auch Informationen √ºber die Anzahl der erzielten und verf√ºgbaren Punkte sowie deren t√§gliches Limit in Informationsnachrichten <code>yadirGetKeyWords</code> , die von der Funktion <code>yadirGetKeyWords</code> an die Konsole <code>yadirGetKeyWords</code> werden. </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p>  Lassen Sie uns der Reihe nach mit <code>doSNOW</code> und <code>doParallel</code> . </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  DoSNOW-Paket und Multithread-Funktionen </h3><br><p>  Wir schreiben dieselbe Operation f√ºr den Multi-Thread-Berechnungsmodus neu, erstellen in diesem Fall 4 Threads und verwenden anstelle der <code>for</code> Schleife das <code>foreach</code> Konstrukt. </p><br><div class="spoiler">  <b class="spoiler_title">Code 2: Paralleles Rechnen mit doSNOW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p>  In diesem Fall ergab die Messung der Laufzeit mit der Funktion system.time das folgende Ergebnis: </p><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 0.17 <br>  <u>System:</u> 0,08 <br>  <u>bestanden:</u> 151,47 </p><br><p>  Das gleiche Ergebnis, d.h.  Wir haben die Sammlung von Schl√ºsselw√∂rtern von 4 Yandex.Direct-Konten in 151 Sekunden erhalten, d. h.  2 mal schneller.  Au√üerdem habe ich gerade im letzten Beispiel geschrieben, wie lange es gedauert hat, eine Liste von Keywords aus dem gr√∂√üten Konto zu laden (142 Sekunden), d. H.  In diesem Beispiel ist die Gesamtzeit fast identisch mit der Verarbeitungszeit des gr√∂√üten Kontos.  Tatsache ist, dass wir mit Hilfe der <code>foreach</code> Funktion gleichzeitig den Prozess des Sammelns von Daten in 4 Threads gestartet haben, d. H.  Gleichzeitig werden Daten von allen 4 Konten gesammelt. Die Gesamtzeit entspricht der Verarbeitungszeit des gr√∂√üten Kontos. </p><br><p>  Ich werde <em>Code 2 kurz</em> <code>makeCluster</code> Funktion <code>makeCluster</code> f√ºr die Anzahl der Threads verantwortlich. In diesem Fall haben wir einen Cluster mit 4 Prozessorkernen erstellt. Wie ich bereits bei der Arbeit mit der Yandex.Direct-API geschrieben habe, k√∂nnen Sie unabh√§ngig von der Anzahl der Konten 5 Threads erstellen Wenn Sie 5-15-100 oder mehr verarbeiten m√ºssen, k√∂nnen Sie 5 Anforderungen gleichzeitig an die API senden. </p><br><p>  Als n√§chstes startet die Funktion <code>registerDoSNOW</code> den erstellten Cluster. </p><br><p>  Danach verwenden wir das <code>foreach</code> Konstrukt, wie ich bereits sagte, dieses Konstrukt ist eine verbesserte for-Schleife.  Sie geben den Z√§hler als erstes Argument an. In dem Beispiel, das ich <em>login genannt</em> habe, wird bei jeder Iteration √ºber die Elemente des <em>Anmeldevektors</em> iteriert. Wenn wir <code>for ( login in logins)</code> schreiben, erhalten wir dasselbe Ergebnis in der <code>for</code> Schleife. </p><br><p>  Als N√§chstes m√ºssen Sie im Argument <em>.combine</em> die Funktion <em>angeben,</em> mit der Sie die bei jeder Iteration erzielten Ergebnisse kombinieren. Die h√§ufigsten Optionen sind: </p><br><ul><li>  <code>rbind</code> - Verbinde die resultierenden Tabellen Zeile f√ºr Zeile untereinander. </li><li>  <code>cbind</code> - Verbinde die resultierenden Tabellen in Spalten. </li><li>  <code>"+"</code> - fasst das bei jeder Iteration erhaltene Ergebnis zusammen. </li></ul><br><p>  Sie k√∂nnen auch jede andere Funktion verwenden, auch selbst geschrieben. </p><br><p>  Mit dem Argument <em>.inorder = F</em> k√∂nnen Sie die Arbeit der Funktion etwas beschleunigen, wenn es Ihnen egal ist, in welcher Reihenfolge die Ergebnisse kombiniert werden sollen. In diesem Fall ist die Reihenfolge f√ºr uns nicht wichtig. </p><br><p>  Als n√§chstes kommt der <code>%dopar%</code> -Operator, der die Schleife im parallelen Rechenmodus startet. Wenn Sie den <code>%do%</code> -Operator verwenden, werden die Iterationen nacheinander ausgef√ºhrt, ebenso wie bei Verwendung der √ºblichen <code>for</code> Schleife. </p><br><p>  Die <code>stopCluster</code> Funktion stoppt den Cluster. </p><br><p>  Multithreading, oder besser gesagt das <code>foreach</code> Konstrukt im Multithread-Modus, weist einige Funktionen auf. In diesem Fall starten wir jeden parallelen Prozess in einer neuen, sauberen R-Sitzung.  Um die generischen Funktionen und Objekte darin zu verwenden, die au√üerhalb des <code>foreach</code> Konstrukts definiert wurden, m√ºssen Sie sie daher mit dem Argument <em>.export exportieren</em> .  Dieses Argument verwendet einen Textvektor, der die Namen der Objekte enth√§lt, die Sie in <code>foreach</code> . </p><br><p>  Au√üerdem werden in <code>foreach</code> im parallelen Modus die zuvor verbundenen Pakete standardm√§√üig nicht angezeigt, sodass sie auch mit dem Argument <em>.packages</em> in foreach √ºbergeben werden <em>m√ºssen</em> .  Es ist auch erforderlich, Pakete zu √ºbertragen, indem ihre Namen in einem <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> , z. B. <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> .  Im obigen <em>Codebeispiel 2</em> laden wir auf diese Weise das <strong>ryandexdirect-</strong> Paket bei jeder Iteration von <code>foreach</code> . </p><br><h3 id="paket-doparallel">  DoParallel-Paket </h3><br><p>  Wie ich oben geschrieben habe, sind die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> Zwillinge, daher haben sie dieselbe Syntax. </p><br><div class="spoiler">  <b class="spoiler_title">Code 5: Paralleles Rechnen mit doParallel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>Arbeitszeit:</strong> <br>  <u>Benutzer:</u> 0,25 <br>  <u>System:</u> 0,01 <br>  <u>bestanden:</u> 173,28 </p><br><p>  Wie Sie in diesem Fall sehen k√∂nnen, unterscheidet sich die Ausf√ºhrungszeit geringf√ºgig vom vorherigen Beispiel f√ºr parallelen Computercode mit dem Paket <code>doSNOW</code> . </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami">  Geschwindigkeitstest zwischen den drei untersuchten Ans√§tzen </h2><br><p>  F√ºhren Sie nun den Geschwindigkeitstest mit dem Paket <code>rbenchmark</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="Bild"></p><br><p>  Wie Sie sehen k√∂nnen, haben die <code>doParallel</code> <code>doSNOW</code> und <code>doParallel</code> selbst bei einem Test mit 4 Konten Daten mit Schl√ºsselw√∂rtern zweimal schneller empfangen als die sequentielle for-Schleife. Wenn Sie einen Cluster mit 5 Kernen erstellen und 50 oder 100 Konten verarbeiten, ist der Unterschied sogar noch gr√∂√üer. </p><br><div class="spoiler">  <b class="spoiler_title">Code 6: Skript zum Vergleichen der Geschwindigkeit von Multithreading und sequentiellem Computing</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p>  Abschlie√üend werde ich den obigen <em>Code 5</em> erl√§utern, mit dem wir die Arbeitsgeschwindigkeit getestet haben. </p><br><p>  Zun√§chst haben wir drei Funktionen erstellt: </p><br><p>  <code>for_fun</code> - eine Funktion, die Schl√ºsselw√∂rter von mehreren Konten anfordert und diese nacheinander in einem regul√§ren Zyklus sortiert. </p><br><p>  <code>dosnow_fun</code> - eine Funktion, die mithilfe des <code>doSNOW</code> Pakets eine Liste von Schl√ºsselw√∂rtern im Multithread-Modus <code>doSNOW</code> . </p><br><p>  <code>dopar_fun</code> - eine Funktion, die im Multithread-Modus mithilfe des <code>doParallel</code> Pakets eine Liste von Schl√ºsselw√∂rtern <code>doParallel</code> . </p><br><p>  Als n√§chstes f√ºhren wir innerhalb des Konstrukts inside die <code>benchmark</code> Funktion aus dem <code>rbenchmark</code> Paket aus, geben die Namen der Tests (for_cycle, dosnow, doparallel) und f√ºr jede Funktion die Funktionen an: <code>for_fun(logins = logins)</code> ;  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> . </p><br><p>  Das <em>Replikationsargument</em> ist f√ºr die Anzahl der Tests verantwortlich, d.h.  Wie oft werden wir jede Funktion ausf√ºhren? </p><br><p>  Mit dem <em>Spaltenargument</em> k√∂nnen Sie angeben, welche Spalten Sie erhalten m√∂chten. In unserem Fall bedeutet "Test", "Replikationen", "verstrichen", dass die Spalten zur√ºckgegeben werden: Name des Tests, Anzahl der Tests, Gesamtausf√ºhrungszeit aller Tests. </p><br><p>  Sie k√∂nnen auch berechnete Spalten hinzuf√ºgen ( <code>{ average = elapsed/replications }</code> ), d. H.  Die Ausgabe ist eine durchschnittliche Spalte, die die Gesamtzeit durch die Anzahl der Tests dividiert. Daher berechnen wir die durchschnittliche Ausf√ºhrungszeit jeder Funktion. </p><br><p>  <em>Die Bestellung</em> ist f√ºr die Sortierung der Testergebnisse verantwortlich. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  In diesem Artikel wird im Prinzip eine ziemlich universelle Methode zur Beschleunigung der Arbeit mit der API beschrieben, aber jede API hat ihre Grenzen. Daher ist das obige Beispiel speziell in dieser Form bei so vielen Threads f√ºr die Arbeit mit der Yandex.Direct-API geeignet, um sie mit der API zu verwenden Bei anderen Diensten ist es zun√§chst erforderlich, die Dokumentation zu den Grenzwerten in der API f√ºr die Anzahl der gleichzeitig gesendeten Anforderungen zu lesen. Andernfalls wird m√∂glicherweise der Fehler " <code>Too Many Requests</code> angezeigt. </p><br><p>  Die Fortsetzung dieses Artikels finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437078/">https://habr.com/ru/post/de437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437068/index.html">ILV entsperrt 2,7 Millionen IP-Adressen</a></li>
<li><a href="../de437070/index.html">Survey Data Science Tools 2019</a></li>
<li><a href="../de437072/index.html">Schw√§chen Sie N√ºsse in Habr-Regeln</a></li>
<li><a href="../de437074/index.html">Google blockiert m√∂glicherweise seinen Nachrichtendienst in Europa</a></li>
<li><a href="../de437076/index.html">Der Fall und die Wiederherstellung eines Schimmelpilzes</a></li>
<li><a href="../de437084/index.html">Von Uncharted zu Obra Dinn: Lucas Pope spricht √ºber seine Karriere in der Spieleentwicklung</a></li>
<li><a href="../de437086/index.html">Medien: Hacker hackten sich in die Datenbank der US Securities Commission und verdienten Millionen durch Insiderhandel</a></li>
<li><a href="../de437088/index.html">F√∂rderung eines Startups im Ausland: Wie man mit Medium Hunderttausende englischsprachiger Leser erreicht</a></li>
<li><a href="../de437092/index.html">Die Sicherheit von Algorithmen f√ºr maschinelles Lernen. Python-Angriffe</a></li>
<li><a href="../de437094/index.html">Wir haben den Atlassian Service Desk gepumpt - die Ank√ºndigung des Mitaps und der Live-√úbertragung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>