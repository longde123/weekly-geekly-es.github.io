<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üß¢ üç¢ Android LiveData-Ereignisse üéº üòå üë∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="LiveData ist ein gro√üartiges Tool zum Verkn√ºpfen des Status Ihrer Daten und Objekte mit einem Lebenszyklus (LifecycleOwner, normalerweise ein Fragment...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android LiveData-Ereignisse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468749/">  LiveData ist ein gro√üartiges Tool zum Verkn√ºpfen des Status Ihrer Daten und Objekte mit einem Lebenszyklus (LifecycleOwner, normalerweise ein Fragment oder eine Aktivit√§t). <br><br>  In der Regel werden LiveData im ViewModel abgelegt und zum Aktualisieren des Status Ihrer Benutzeroberfl√§che verwendet.  Oft kann ein ViewModel einen LifecycleOwner √ºberleben und einen LiveData-Status beibehalten.  Ein solcher Mechanismus eignet sich, wenn Sie Daten speichern und nach einiger Zeit wiederherstellen m√ºssen, z. B. nach einer Konfigurations√§nderung. <br><br>  Aber was ist, wenn wir den Mechanismus von Ereignissen nutzen wollen, nicht Staaten?  Und es ist im Kontext des Browser-Lebenszyklus (LifecycleOwner) notwendig.  Beispielsweise m√ºssen wir nach einem asynchronen Vorgang eine Nachricht anzeigen, vorausgesetzt, LifecycleOwner ist noch aktiv, verf√ºgt √ºber aktive Browser und ist bereit, die Benutzeroberfl√§che zu aktualisieren.  Wenn wir LiveData verwenden, erhalten wir nach jeder Konfigurations√§nderung oder mit jedem neuen Abonnenten dieselbe Nachricht.  Eine der L√∂sungen, die sich nach der Verarbeitung der Daten in einem Browser anbietet, besteht darin, diese Daten auf LiveData zur√ºckzusetzen. <br><br>  Zum Beispiel ein Code wie dieser: <br><br><pre><code class="kotlin hljs">Observer { handle(it) yourViewModel.liveData.value = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br>  Dieser Ansatz hat jedoch mehrere Nachteile und erf√ºllt nicht alle erforderlichen Anforderungen. <br><a name="habracut"></a><br>  Ich h√§tte gerne einen Ereignismechanismus, der: <br><br><ol><li>  benachrichtigt nur aktive Teilnehmer </li><li>  zum Zeitpunkt des Abonnements nicht √ºber vorherige Daten benachrichtigt, </li><li>  hat die M√∂glichkeit, das behandelte Flag auf true zu setzen, um die weitere Verarbeitung des Ereignisses zu unterbrechen. </li></ol><br>  Ich habe die MutableLiveEvent-Klasse implementiert, die alle oben genannten Eigenschaften aufweist und wie normale LiveData funktionieren kann. <br><br>  Wie man benutzt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   EventArgs        class MyIntEventArgs(data: Int) : EventArgs&lt;Int&gt;(data) //  viewModel class MainViewModel : ViewModel() { private val myEventMutable = MutableLiveEvent&lt;MyIntEventArgs&gt;() val myEvent = myEventMutable as LiveData&lt;MyIntEventArgs&gt; fun sendEvent(data: Int) { myEventMutable.value = MyIntEventArgs(data) } } val vm = ViewModelProviders.of(this).get(MainViewModel::class.java) vm.myEvent.observe(this, Observer { //   /* *   ,    , *      ,   handled = true */ it.handled = true })</span></span></code> </pre><br>  Der gesamte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar, und im Folgenden werde ich ein wenig √ºber die Implementierung sprechen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableLiveEvent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : EventArgs&lt;Any</span></span></span><span class="hljs-class">&gt;&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MutableLiveData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observers = ArraySet&lt;PendingObserver&lt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T&gt;&gt;() <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(owner: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LifecycleOwner</span></span></span></span><span class="hljs-function"><span class="hljs-params">, observer: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wrapper = PendingObserver(observer) observers.add(wrapper) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.observe(owner, wrapper) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeForever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(observer: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wrapper = PendingObserver(observer) observers.add(wrapper) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.observeForever(observer) } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(observer: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (observer) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PendingObserver -&gt; { observers.remove(observer) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.removeObserver(observer) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pendingObserver = observers.firstOrNull { it.wrappedObserver == observer } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pendingObserver != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { observers.remove(pendingObserver) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.removeObserver(pendingObserver) } } } } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { observers.forEach { it.awaitValue() } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.setValue(event) } }</code> </pre><br>  Die Idee ist, dass innerhalb der MutableLiveEvent-Klasse in den Observ- und ObservForever-Methoden Browser in eine spezielle interne Klasse PendingObserver eingeschlossen werden, die den realen Browser nur einmal und nur dann aufruft, wenn das ausstehende Flag auf true gesetzt ist und das Ereignis noch nicht verarbeitet wurde. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingObserver</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : EventArgs&lt;Any</span></span></span><span class="hljs-class">&gt;&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wrappedObserver: Observer&lt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T&gt;) : Observer&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pending = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pending &amp;&amp; event?.handled != <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { pending = <span class="hljs-literal"><span class="hljs-literal">false</span></span> wrappedObserver.onChanged(event) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { pending = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br>  In PendingObserver ist das ausstehende Flag standardm√§√üig auf false gesetzt.  Dies l√∂st Punkt 2 (keine Benachrichtigung √ºber alte Daten) aus unserer Liste. <br><br>  Und der Code in MutableLiveEvent <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { observers.forEach { it.awaitValue() } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.setValue(event) }</code> </pre><br>  Setzt zuerst anstehend auf true und aktualisiert erst dann die Daten in sich.  Dies stellt die Umsetzung von Anspruch 1 sicher.  (Nur aktive Teilnehmer benachrichtigen). <br><br>  Der letzte Punkt, √ºber den ich noch nicht gesprochen habe, ist EventArgs.  Diese Klasse ist eine Verallgemeinerung, bei der ein behandeltes Flag vorhanden ist, um die weitere Verarbeitung des Ereignisses zu unterbrechen (Abschnitt 3). <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventArgs</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content: T?) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handled: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handled) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { content } } }</code> </pre><br>  Das ist alles, danke f√ºrs Zuschauen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468749/">https://habr.com/ru/post/de468749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468735/index.html">Musik herunterladen VKontakte</a></li>
<li><a href="../de468737/index.html">Rezension des Buches: "Life 3.0. Ein Mann im Zeitalter der k√ºnstlichen Intelligenz sein ‚Äú</a></li>
<li><a href="../de468739/index.html">Bereitstellen von Speicherfailover</a></li>
<li><a href="../de468741/index.html">Internet in der Smart City</a></li>
<li><a href="../de468747/index.html">Wie ich den Sommer auf VK verbracht habe</a></li>
<li><a href="../de468753/index.html">Farbenblind - Freund des Menschen (Gesundheitsministerium ist nicht richtig)</a></li>
<li><a href="../de468757/index.html">MySQL-Verbindung nach Fehler 1040: zu viele Verbindungen</a></li>
<li><a href="../de468759/index.html">√úber trivial_abi in Clang</a></li>
<li><a href="../de468761/index.html">Probleml√∂sung mit pwnable.kr 24 - einfaches Login. Stapelrahmen√ºberlagerung</a></li>
<li><a href="../de468765/index.html">Die Wichtigkeit der Best√§tigung von Steuerbefehlen am Beispiel von Delimobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>