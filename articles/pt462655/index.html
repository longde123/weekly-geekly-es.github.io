<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèº üë©üèΩ‚Äçüè≠ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ Digite seu c√≥digo finalmente üö£üèø ü•ó üíáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr! 


 Um dia desses, mais uma vez, recebi o c√≥digo de tipo 


if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Digite seu c√≥digo finalmente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462655/"><p>  Oi Habr! </p><br><p>  Um dia desses, mais uma vez, recebi o c√≥digo de tipo </p><br><pre><code class="plaintext hljs">if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken channels, however we could not differ it from just not started cold system. // Therefore write this case into the logs and then in case of emergency IT Ops will able to gather the target line Log.Info("Channel {0} is broken or was not started yet", someParameter.Key) }</code> </pre> <br><p>  H√° um recurso bastante importante no c√≥digo: o destinat√°rio gostaria muito de saber o que realmente aconteceu.  De fato, em um caso, temos problemas com o sistema e, no outro, apenas aquecemos.  No entanto, o modelo n√£o nos fornece isso (para agradar o remetente, que geralmente √© o autor do modelo). <br>  Al√©m disso, mesmo o fato de "talvez algo esteja errado" decorre do fato de a cole√ß√£o <code>Volatilities</code> vazia.  O que em alguns casos pode estar correto. </p><br><p>  Tenho certeza de que os desenvolvedores mais experientes do c√≥digo viram linhas que continham conhecimento secreto no estilo de "se essa combina√ß√£o de sinalizadores estiver definida, ser√° solicitado que voc√™ fa√ßa A, B e C" (embora isso n√£o seja vis√≠vel pelo pr√≥prio modelo). </p><br><p>  Do meu ponto de vista, essas economias na estrutura das classes t√™m um impacto extremamente negativo no projeto no futuro, transformando-o em um conjunto de hacks e muletas, transformando gradualmente um c√≥digo mais ou menos conveniente em legado. </p><br><p>  <strong>Importante:</strong> no artigo, dou exemplos √∫teis para projetos nos quais v√°rios desenvolvedores (e n√£o um), al√©m de quais ser√£o atualizados e expandidos por pelo menos 5 a 10 anos.  Tudo isso n√£o faz sentido se o projeto tiver um desenvolvedor por cinco anos ou se nenhuma mudan√ßa for planejada ap√≥s o lan√ßamento.  E √© l√≥gico que, se o projeto for necess√°rio por apenas alguns meses, n√£o faz sentido investir em um modelo de dados claro. </p><br><p>  No entanto, se voc√™ est√° jogando muito tempo - bem-vindo ao gato. </p><a name="habracut"></a><br><h1 id="ispolzuyte-pattern-visitor">  Usar padr√£o de visitante </h1><br><p>  Geralmente, o mesmo campo cont√©m um objeto que pode ter significados sem√¢nticos diferentes (como no exemplo).  No entanto, para salvar classes, o desenvolvedor deixa apenas um tipo, fornecendo sinalizadores (ou coment√°rios no estilo "se n√£o houver nada aqui, nada foi contado").  Uma abordagem semelhante pode mascarar um erro (o que √© ruim para o projeto, mas conveniente para a equipe que fornece o servi√ßo, porque os erros n√£o s√£o vis√≠veis do lado de fora).  Uma op√ß√£o mais correta, que permite que mesmo no extremo oposto do fio descubra o que realmente est√° acontecendo, √© usar a interface + os visitantes. </p><br><p>  Nesse caso, o exemplo do cabe√ßalho se transforma em c√≥digo do formul√°rio: </p><br><pre> <code class="plaintext hljs">class Response { public IVolatilityResponse Data { get; } } interface IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) } class VolatilityValues : IVolatilityResponse { public Surface Data; TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } class CalculationIsBroken : IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } interface IVolatilityResponseVisitor&lt;TInput, TOutput&gt; { TOutput Visit(VolatilityValues instance, TInput input); TOutput Visit(CalculationIsBroken instance, TInput input); }</code> </pre> <br><p>  Com este tipo de processamento: </p><br><ul><li>  Precisamos de mais c√≥digo.  Infelizmente, se queremos expressar mais informa√ß√µes no modelo, deve ser mais. </li><li>  Devido a esse tipo de heran√ßa, n√£o podemos mais serializar o <code>Response</code> para <code>json</code> / <code>protobuf</code> , pois as informa√ß√µes do tipo s√£o perdidas l√°.  Teremos que criar um cont√™iner especial que far√° isso (por exemplo, voc√™ pode criar uma classe que contenha um campo separado para cada implementa√ß√£o, mas apenas um deles ser√° preenchido). </li><li>  Estender o modelo (ou seja, adicionar novas classes) requer a expans√£o da <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> , o que significa que o compilador for√ßar√° o suporte no c√≥digo.  O programador n√£o esquecer√° de processar o novo tipo, caso contr√°rio, o projeto n√£o ser√° compilado. </li><li>  Devido √† digita√ß√£o est√°tica, n√£o precisamos armazenar a documenta√ß√£o em algum lugar com poss√≠veis combina√ß√µes de campos etc.  Descrevemos todas as op√ß√µes poss√≠veis no c√≥digo que √© compreens√≠vel para o compilador e a pessoa.  N√£o teremos uma dessincroniza√ß√£o entre documenta√ß√£o e c√≥digo, pois podemos ficar sem o primeiro. </li></ul><br><h2 id="pro-ogranichenie-nasledovaniya-v-drugih-yazykah">  Sobre restri√ß√£o de heran√ßa em outros idiomas </h2><br><p>  V√°rios outros idiomas (por exemplo, <code>Scala</code> ou <code>Kotlin</code> ) t√™m palavras-chave que permitem proibir a heran√ßa de um determinado tipo, sob certas condi√ß√µes.  Assim, na fase de compila√ß√£o, conhecemos todos os poss√≠veis descendentes do nosso tipo. </p><br><p>  Em particular, o exemplo acima pode ser reescrito no <code>Kotlin</code> assim: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: IVolatilityResponse ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityValues</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: Surface } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalculationIsBroken</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>()</code> </pre><br><p>  Ficou um pouco menos do que o c√≥digo, mas agora no processo de compila√ß√£o sabemos que todos os <code>VolatilityResponse</code> poss√≠veis do <code>VolatilityResponse</code> est√£o no mesmo arquivo, o que significa que o c√≥digo a seguir n√£o ser√° compilado, pois n√£o analisamos todos os valores poss√≠veis da classe. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString() }</code> </pre> <br><p>  No entanto, vale lembrar que essas verifica√ß√µes funcionam apenas para chamadas funcionais.  O c√≥digo abaixo ser√° compilado sem erros: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; println(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString()) } }</code> </pre> <br><h1 id="ne-vse-primitivnye-tipy-oznachayut-odno-i-to-zhe">  Nem todos os tipos primitivos significam a mesma coisa </h1><br><p>  Considere um desenvolvimento relativamente t√≠pico para um banco de dados.  Provavelmente, em algum lugar do c√≥digo voc√™ ter√° identificadores de objeto.  Por exemplo: </p><br><pre> <code class="plaintext hljs">class Group { public int Id { get; } public string Name { get; } } class User { public int Id { get; } public int GroupId { get; } public string Name { get; } }</code> </pre> <br><p>  Parece um c√≥digo padr√£o.  Os tipos at√© correspondem aos do banco de dados.  No entanto, a pergunta √©: o c√≥digo abaixo est√° correto? </p><br><pre> <code class="plaintext hljs">public bool IsInGroup(User user, Group group) { return user.Id == group.Id; } public User CreateUser(string name, Group group) { return new User { Id = group.Id, GroupId = group.Id, name = name } }</code> </pre> <br><p>  A resposta provavelmente n√£o √©, pois estamos comparando o <code>Id</code> do usu√°rio e o <code>Id</code> grupo no primeiro exemplo.  E no segundo, definimos por engano o <code>id</code> do <code>Group</code> como o <code>id</code> do <code>User</code> . </p><br><p>  Curiosamente, isso √© bastante simples de corrigir: basta obter os tipos <code>GroupId</code> , <code>UserId</code> e assim por diante.  Assim, a cria√ß√£o do <code>User</code> n√£o funcionar√° mais, pois seus tipos n√£o convergir√£o.  O que √© incrivelmente legal, porque voc√™ pode contar ao compilador sobre o modelo. </p><br><p>  Al√©m disso, m√©todos com os mesmos par√¢metros funcionar√£o corretamente para voc√™, pois agora eles n√£o ser√£o repetidos: </p><br><pre> <code class="plaintext hljs">public void SetUserGroup(UserId userId, GroupId groupId) { /* some sql code */ }</code> </pre> <br><p>  No entanto, voltemos ao exemplo de compara√ß√£o de identificadores.  √â um pouco mais complicado, pois voc√™ deve impedir que o compilador compare o incompar√°vel durante o processo de compila√ß√£o. </p><br><p>  E voc√™ pode fazer isso da seguinte maneira: </p><br><pre> <code class="plaintext hljs">class GroupId { public int Id { get; } public bool Equals(GroupId groupId) =&gt; Id == groupId?.Id; [Obsolete("GroupId can be equal only with GroupId", error: true)] public override bool Equals(object obj) =&gt; Equals(obj as GroupId) public static bool operator==(GroupId id1, GroupId id2) { if(ReferenceEquals(id1, id2)) return true; if(ReferenceEquals(id1, null) || ReferenceEquals(id2, null)) return false; return id1.Id == id2.Id; } [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(object _, GroupId __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(GroupId _, object __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") }</code> </pre> <br><p>  Como resultado: </p><br><ul><li>  Novamente precis√°vamos de mais c√≥digo.  Infelizmente, se voc√™ quiser fornecer mais informa√ß√µes ao compilador, geralmente precisar√° escrever mais linhas. </li><li>  Criamos novos tipos (falaremos sobre otimiza√ß√µes abaixo), que √†s vezes podem prejudicar um pouco o desempenho. </li><li>  No nosso c√≥digo: <br><ul><li>  Proibimos confundir identificadores.  Agora, o compilador e o desenvolvedor veem claramente que √© imposs√≠vel <code>GroupId</code> campo <code>GroupId</code> para o campo <code>GroupId</code> </li><li>  Somos proibidos de comparar o incompar√°vel.  <code>IEquitable</code> que o c√≥digo de compara√ß√£o n√£o foi completamente conclu√≠do (tamb√©m √© desej√°vel implementar a interface <code>IEquitable</code> , voc√™ tamb√©m deve implementar o m√©todo <code>GetHashCode</code> ), para que o exemplo n√£o precise apenas ser copiado para o projeto.  No entanto, a ideia em si √© clara: proibimos explicitamente o compilador de expressar quando os tipos errados foram comparados.  I.e.  em vez de dizer "essas frutas s√£o iguais?"  o compilador agora v√™ "uma pera √© igual a uma ma√ß√£?". </li></ul></li></ul><br><h2 id="nemnogo-esche-ob-sql-i-ob-ogranicheniyah">  Um pouco mais sobre sql e limita√ß√µes </h2><br><p>  Geralmente, em nossos aplicativos para tipos, s√£o introduzidas regras adicionais f√°ceis de verificar.  Na pior das hip√≥teses, v√°rias fun√ß√µes s√£o mais ou menos assim: </p><br><pre> <code class="plaintext hljs">void SetName(string name) { if(name == null || name.IsEmpty() || !name[0].IsLetter || !name[0].IsCapital || name.Length &gt; MAX_NAME_COLUMN_LENGTH) { throw .... } /**/ }</code> </pre> <br><p>  Ou seja, a fun√ß√£o usa um tipo bastante amplo de entrada e executa as verifica√ß√µes.  Geralmente n√£o √© esse o caso, pois: </p><br><ul><li>  N√£o explicamos ao programador e compilador o que queremos aqui. </li><li>  Em outra fun√ß√£o semelhante, voc√™ precisar√° copiar as verifica√ß√µes. </li><li>  Quando recebemos uma <code>string</code> que indica o <code>name</code> , n√£o ca√≠mos imediatamente, mas, por algum motivo, a execu√ß√£o continuada caiu em algumas instru√ß√µes do processador posteriormente. </li></ul><br><p>  O comportamento correto: </p><br><ul><li>  Crie um tipo separado (no nosso caso, aparentemente, <code>Name</code> ). </li><li>  Nele, fa√ßa todas as valida√ß√µes e verifica√ß√µes necess√°rias. </li><li>  Coloque a <code>string</code> em <code>Name</code> mais r√°pido poss√≠vel para obter um erro o mais r√°pido poss√≠vel. </li></ul><br><p>  Como resultado, obtemos: </p><br><ul><li>  Menos c√≥digo, j√° que verificamos as verifica√ß√µes de <code>name</code> no construtor. </li><li>  Estrat√©gia <em>Fail Fast</em> - agora, tendo recebido um nome problem√°tico, cairemos imediatamente, em vez de chamar mais alguns m√©todos, mas ainda cairemos.  Al√©m disso, em vez de um erro de um banco de dados do tipo tipo muito grande, descobrimos imediatamente que n√£o faz sentido sequer come√ßar a processar esses nomes. </li><li>  J√° √© mais dif√≠cil misturarmos os argumentos se a assinatura da fun√ß√£o for: <code>void UpdateData(Name name, Email email, PhoneNumber number)</code> .  Afinal, agora passamos n√£o tr√™s <code>string</code> id√™nticas, mas tr√™s entidades diferentes. </li></ul><br><h2 id="nemnogo-o-privedenii-tipov">  Um pouco sobre elenco </h2><br><p>  Introduzindo uma digita√ß√£o bastante rigorosa, tamb√©m n√£o devemos esquecer que, ao transferir dados para o Sql, ainda precisamos obter um identificador real.  E, nesse caso, √© l√≥gico atualizar levemente os tipos que envolvem uma <code>string</code> : </p><br><ul><li>  Adicione uma implementa√ß√£o de uma interface da interface do formul√°rio <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code>  <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code> .  Nesse caso, na camada de tradu√ß√£o no Sql, podemos obter o valor diretamente </li><li>  Em vez de criar um monte de tipos mais ou menos id√™nticos no c√≥digo, voc√™ pode criar um ancestral abstrato e herdar o restante dele.  O resultado √© um c√≥digo do formul√°rio: </li></ul><br><pre> <code class="plaintext hljs">interface IValueGet&lt;TValue&gt; { TValue Wrapped { get; } } abstract class BaseWrapper : IValueGet&lt;TValue&gt; { protected BaseWrapper(TValue initialValue) { Wrapped = initialValue; } public TValue Wrapped { get; private set; } } sealed class Name : BaseWrapper&lt;string&gt; { public Name(string value) :base(value) { /*no necessary validations*/ } } sealed class UserId : BaseWrapper&lt;int&gt; { public UserId(int id) :base(id) { /*no necessary validations*/ } }</code> </pre> <br><h1 id="proizvoditelnost">  Desempenho </h1><br><p>  Falando sobre a cria√ß√£o de um grande n√∫mero de tipos, muitas vezes voc√™ pode encontrar dois argumentos dial√©ticos: </p><br><ul><li>  Quanto mais tipos, aninhamento e c√≥digo, mais lento o software, pois √© mais dif√≠cil para o jit otimizar o programa.  Portanto, esse tipo de digita√ß√£o estrita levar√° a freios s√©rios no projeto. </li><li>  Quanto mais inv√≥lucros, mais o aplicativo consome mem√≥ria.  Portanto, adicionar wrappers aumentar√° seriamente os requisitos de RAM. </li></ul><br><p>  A rigor, ambos os argumentos s√£o apresentados sem fatos, no entanto: </p><br><ul><li>  De fato, na maioria dos aplicativos no mesmo java, as seq√º√™ncias de caracteres (e matrizes de bytes) ocupam a mem√≥ria principal.  Ou seja, √© improv√°vel que a cria√ß√£o de wrappers seja percept√≠vel para o usu√°rio final.  No entanto, devido a esse tipo de digita√ß√£o, obtemos uma vantagem importante: ao analisar um despejo de mem√≥ria, voc√™ pode avaliar a contribui√ß√£o de cada um de seus tipos para a mem√≥ria.  Afinal, voc√™ v√™ n√£o apenas uma lista an√¥nima de linhas espalhadas pelo projeto.  Pelo contr√°rio, podemos entender que tipos de objetos s√£o maiores.  Al√©m disso, devido ao fato de apenas os Wrappers conterem seq√º√™ncias de caracteres e outros objetos maci√ßos, √© mais f√°cil entender qual a contribui√ß√£o de cada tipo espec√≠fico de wrapper para a mem√≥ria compartilhada. </li><li>  O argumento sobre a otimiza√ß√£o do jit √© parcialmente verdadeiro, mas n√£o est√° completamente completo.  De fato, devido √† digita√ß√£o estrita, seu software come√ßa a se livrar de in√∫meras verifica√ß√µes na entrada das fun√ß√µes.  Todos os seus modelos s√£o verificados quanto √† adequa√ß√£o em seu design.  Portanto, no caso geral, voc√™ ter√° menos verifica√ß√µes (basta exigir o tipo correto).  Al√©m disso, devido ao fato de as verifica√ß√µes serem transferidas para o construtor e n√£o serem manchadas pelo c√≥digo, fica mais f√°cil determinar quais delas realmente levam tempo. </li><li>  Infelizmente, neste artigo, n√£o posso fornecer um teste de desempenho completo, que compara um projeto com um grande n√∫mero de microtipos e com o desenvolvimento cl√°ssico, usando apenas <code>int</code> , <code>string</code> e outros tipos primitivos.  A principal raz√£o √© que, para isso, voc√™ deve primeiro criar um projeto em negrito t√≠pico para o teste e justificar que esse projeto em particular seja t√≠pico.  E com o segundo ponto, tudo √© complicado, pois na vida real os projetos s√£o realmente diferentes.  No entanto, ser√° bastante estranho fazer testes sint√©ticos, porque, como eu j√° disse, a cria√ß√£o de objetos de microtipos em aplicativos Enterprise, de acordo com minhas medi√ß√µes, sempre deixou recursos insignificantes (no n√≠vel do erro de medi√ß√£o). </li></ul><br><h2 id="kak-mozhno-optimizirovat-kod-sostoyaschiy-iz-bolshogo-chisla-podobnyh-mikrotipov">  Como voc√™ pode otimizar um c√≥digo que consiste em um grande n√∫mero desses microtipos. </h2><br><p>  <strong>Importante: voc√™</strong> deve lidar com essas otimiza√ß√µes somente quando receber fatos garantidos de que s√£o microtipos que retardam o aplicativo.  Na minha experi√™ncia, tal situa√ß√£o √© bastante imposs√≠vel.  Com uma probabilidade mais alta, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o mesmo registrador o atrasar√°</a> , porque cada opera√ß√£o est√° aguardando uma descarga no disco (tudo era aceit√°vel no computador do desenvolvedor com o SSD M.2, mas um usu√°rio com um disco r√≠gido antigo v√™ resultados completamente diferentes). </p><br><p>  No entanto, os pr√≥prios truques: </p><br><ul><li>  Use tipos significativos em vez de tipos de refer√™ncia.  Isso pode ser √∫til se o Wrapper tamb√©m funcionar com tipos significativos, o que significa que, em teoria, voc√™ pode passar todas as informa√ß√µes necess√°rias pela pilha.  Embora se deva lembrar que a acelera√ß√£o ser√° apenas se o seu c√≥digo realmente sofrer com GC frequente, precisamente por causa dos microtipos. <br><ul><li>  <code>struct</code> em .Net pode causar boxe / unboxing freq√ºentes.  E, ao mesmo tempo, essas estruturas podem exigir mais mem√≥ria nas cole√ß√µes <code>Dictionary</code> / <code>Map</code> (j√° que as matrizes s√£o alocadas com uma margem). </li><li>  tipos <code>inline</code> da Kotlin / Scala t√™m aplicabilidade limitada.  Por exemplo, voc√™ n√£o pode armazenar v√°rios campos neles (que √†s vezes pode ser √∫til para armazenar em cache o valor <code>ToString</code> / <code>GetHashCode</code> ). </li><li>  V√°rios otimizadores s√£o capazes de alocar mem√≥ria na pilha.  Em particular, o .Net <a href="">faz isso para pequenos objetos tempor√°rios</a> , e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GraalVM em Java pode</a> alocar um objeto na pilha, mas depois copia-o para o heap se for necess√°rio retornar (adequado para c√≥digo rico em condi√ß√µes). </li></ul></li><li>  Use o internamento de objetos (ou seja, tente pegar objetos prontos, pr√©-criados). <br><ul><li>  Se o construtor tiver um argumento, voc√™ poder√° criar um cache onde a chave √© esse argumento e o valor √© o objeto criado anteriormente.  Assim, se a variedade de objetos √© muito pequena, voc√™ pode simplesmente reutilizar os objetos prontos. </li><li>  Se um objeto tiver v√°rios argumentos, voc√™ poder√° simplesmente criar um novo objeto e verificar se ele est√° no cache.  Se houver um semelhante, √© melhor retornar o j√° criado. </li><li>  Esse esquema atrasa o trabalho dos designers, pois <code>Equals</code> / <code>GetHashCode</code> deve ser feito para todos os argumentos.  No entanto, tamb√©m acelera compara√ß√µes futuras de objetos, se voc√™ armazenar em cache o valor do hash, porque, nesse caso, se eles forem diferentes, os objetos ser√£o diferentes.  E objetos id√™nticos geralmente ter√£o um link. </li><li>  No entanto, essa otimiza√ß√£o acelerar√° o programa, devido ao <code>GetHashCode</code> / <code>Equals</code> mais r√°pido (consulte o par√°grafo acima).  Al√©m disso, a vida √∫til dos novos objetos (que est√£o, no entanto, no cache) diminuir√° drasticamente, para que eles entrem apenas na Gera√ß√£o 0. </li></ul></li><li>  Ao criar novos objetos, verifique os par√¢metros de entrada e n√£o ajuste.  Apesar de muitas vezes esse conselho constar do par√°grafo sobre o estilo de codifica√ß√£o, ele permite aumentar a efic√°cia do programa.  Por exemplo, se seu objeto exigir uma string com apenas BIG LETTERS, duas abordagens ser√£o usadas para verificar: fa√ßa <code>ToUpperInvariant</code> partir do argumento ou verifique em um loop se todas as letras s√£o grandes.  No primeiro caso, √© garantida a cria√ß√£o de uma nova linha; no segundo caso, um iterador m√°ximo √© criado.  Como resultado, voc√™ economiza na mem√≥ria (no entanto, em ambos os casos, cada caractere ainda ser√° verificado, para que o desempenho s√≥ aumente no contexto de uma coleta de lixo mais rara). </li></ul><br><h1 id="vyvod">  Conclus√£o </h1><br><p>  Mais uma vez, repetirei o ponto importante do t√≠tulo: todas as coisas descritas no artigo fazem sentido em grandes projetos que foram desenvolvidos e usados ‚Äã‚Äãh√° anos.  Naqueles em que √© significativo reduzir o custo do suporte e o custo da adi√ß√£o de novas funcionalidades.  Em outros casos, geralmente √© mais razo√°vel fabricar um produto o mais r√°pido poss√≠vel, sem se preocupar com testes, modelos e "bom c√≥digo". </p><br><p>  No entanto, para projetos de longo prazo, √© razo√°vel usar a digita√ß√£o mais rigorosa, onde no modelo podemos descrever estritamente quais valores s√£o poss√≠veis em princ√≠pio. </p><br><p>  Se o seu servi√ßo √†s vezes retornar um resultado n√£o √∫til, expresse-o no modelo e mostre-o ao desenvolvedor explicitamente.  N√£o adicione mil sinalizadores com descri√ß√µes na documenta√ß√£o. </p><br><p>  Se seus tipos podem ser os mesmos no programa, mas s√£o diferentes na ess√™ncia dos neg√≥cios, defina-os exatamente como diferentes.  N√£o os misture, mesmo que os tipos de seus campos sejam os mesmos. </p><br><p>  Se voc√™ tiver d√∫vidas sobre produtividade, aplique o m√©todo cient√≠fico e fa√ßa um teste (ou melhor, pe√ßa a uma pessoa independente para verificar tudo isso).  Nesse cen√°rio, voc√™ realmente acelerar√° o programa e n√£o apenas desperdi√ßar√° o tempo da equipe.  No entanto, o oposto tamb√©m √© verdadeiro: se houver suspeita de que seu programa ou biblioteca esteja lento, fa√ßa um teste.  N√£o √© preciso dizer que est√° tudo bem, apenas mostre em n√∫meros. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462655/">https://habr.com/ru/post/pt462655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462635/index.html">Quantum, ou l√° e voltar: um novo algoritmo para estudar a transi√ß√£o cl√°ssica qu√¢ntica</a></li>
<li><a href="../pt462641/index.html">52 Caracter√≠sticas do gerente de produto ideal</a></li>
<li><a href="../pt462643/index.html">Determinar indiv√≠duos interdependentes a bordo de estruturas usando python</a></li>
<li><a href="../pt462649/index.html"># 18 Mosdroid Argon - relat√≥rio</a></li>
<li><a href="../pt462653/index.html">LTE como um s√≠mbolo de independ√™ncia</a></li>
<li><a href="../pt462657/index.html">SkyRC B6 Nano Carregador revis√£o e teste</a></li>
<li><a href="../pt462659/index.html">Introdu√ß√£o ao Analisador Est√°tico PVS-Studio para Desenvolvimento C ++ no Linux</a></li>
<li><a href="../pt462661/index.html">Familiaridade com o analisador est√°tico PVS-Studio ao desenvolver programas C ++ no Linux</a></li>
<li><a href="../pt462663/index.html">Nadar, dan√ßar (!) E balan√ßar: que atividades eu quero</a></li>
<li><a href="../pt462665/index.html">Helm Security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>