<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî™ üë¶üèæ üåÅ Waktunya telah tiba untuk Java 12! Ulasan JEP panas ü§±üèΩ üöà üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enam bulan telah berlalu, yang berarti sudah waktunya untuk menginstal Java baru ! Itu adalah perjalanan yang panjang, dan sedikit yang mencapai akhir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Waktunya telah tiba untuk Java 12! Ulasan JEP panas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/444434/"><p><img src="https://habrastorage.org/webt/k8/rn/qa/k8rnqagstd_wu4hezoj_bnjzfem.png"></p><br><p>  Enam bulan telah berlalu, yang berarti sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waktunya untuk menginstal Java baru</a> !  Itu adalah perjalanan yang panjang, dan sedikit yang mencapai akhir.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Garis mentah</a> jatuh dari JEP yang menarik, tetapi kita akan berbicara tentang sisanya di bawah potongan. </p><a name="habracut"></a><br><h1 id="kak-vsyo-proishodit">  Bagaimana semuanya berjalan </h1><br><p>  Rilis versi baru Jawa berlangsung sesuai dengan siklus rilis baru "dipercepat" dengan panjang sekitar enam bulan.  Tanggal pasti ditentukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman proyek</a> .  Ada beberapa fase utama untuk JDK 12: </p><br><ul><li>  2018/12/13 - Fase pertama pelambatan (saat ini, garpu dibuat dari cabang utama di repositori); </li><li>  2019/01/17 - Fase kedua dari pelambatan (lengkapi semua yang mungkin); </li><li>  2019/02/07 - Kandidat rilis (hanya bug paling penting yang diperbaiki); </li><li>  2019/03/19 - Rilis, Ketersediaan Umum.  <strong>&lt;- kamu di sini</strong> </li></ul><br><p>  Apa yang kita dapatkan dari jadwal ini?  Ya, sebenarnya, tidak ada apa-apa - kami baru saja tiba di garis finish, dan kami menyaksikan para pecinta warisan dari ketinggian JDK 12 yang baru. </p><br><h1 id="bagi-panika-vse-na-dno">  Bug!  Panik!  Semua ke bawah! </h1><br><p><img src="https://habrastorage.org/webt/9j/jw/j8/9jjwj87t8vtlqyiv4zmox4xljem.jpeg"></p><br><p>  Ketika versi non-LTS baru keluar, biasanya semua orang tidak peduli tentang fitur baru.  Akan lebih menarik jika semuanya akan hancur berantakan. </p><br><p>  Tentu saja, ada bug, banyak, tetapi tidak di JDK 12 :) Dilihat oleh jir, semuanya normal: </p><br><p><img src="https://habrastorage.org/webt/st/yr/cr/styrcrroe8hobgqc6jpxgv5hknw.jpeg"></p><br><p>  Saya akan mengutip permintaan itu sehingga Anda mengerti <em>persis</em> apa "norma" itu: </p><br><pre><code class="plaintext hljs">project = JDK AND issuetype = Bug AND status in (Open, "In Progress", New) AND priority in (P1) AND (fixVersion in (12) OR fixVersion is EMPTY AND affectedVersion in (12) AND affectedVersion not in regexVersion("11.*", "10.*", "9.*", "8.*", "7.*", "6.*")) AND (labels is EMPTY OR labels not in (jdk12-defer-request, noreg-demo, noreg-doc, noreg-self)) AND (component not in (docs, globalization, infrastructure) OR component = infrastructure AND subcomponent = build) AND reporter != "Shadow Bug" ORDER BY priority, component, subcomponent, assignee</code> </pre> <br><p>  Tentu saja, <em>secara umum</em> bug ada tempatnya, mereka tidak akan pergi ke mana pun dalam proyek sebesar ini.  Hanya diklaim bahwa bug P1 saat ini belum diketahui. </p><br><p>  Komunikasi yang lebih formal dengan bug dideklarasikan dalam dokumen khusus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 3: Proses Pelepasan JDK</a> , yang dimiliki oleh pelayan abadi kita pada gelombang turbulen di Laut Jawa - Mark Reinhold. </p><br><p>  Dan khususnya, ada baiknya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggali paragraf</a> jitu <del>  siapa yang harus disalahkan dan apa yang harus dilakukan </del>  cara mentransfer tiket jika Anda tidak punya waktu untuk rilis ke-12.  Penting untuk memasukkan bugtracker label <code>jdk$N-defer-request</code> di mana N menunjukkan rilis mana yang ingin Anda transfer, dan tinggalkan komentar, baris pertama di antaranya adalah <em>Deferral Request</em> .  Selanjutnya, peninjauan semua permintaan tersebut diambil oleh pimpinan dari masing-masing bidang dan proyek. </p><br><p>  Masalah lulus TCK tidak dapat diabaikan dengan cara ini - dijamin bahwa Java tetap Java, dan bukan sesuatu yang seperti katak.  <code>jdk$N-defer-request label</code> tidak pernah hilang.  Sangat menarik apa yang mereka lakukan dengan orang yang melanggar aturan untuk tidak menghapus tag - Saya sarankan memberi makan marmut. </p><br><p>  Namun, dengan cara ini Anda dapat melihat berapa banyak bug yang telah porting ke JDK 13. Mari kita coba pertanyaan ini: </p><br><pre> <code class="plaintext hljs">project = JDK AND issuetype = Bug AND status in (Open, "In Progress", New) AND (labels in (jdk12-defer-request) AND labels not in (noreg-demo, noreg-doc, noreg-self)) AND (component not in (docs, globalization, infrastructure) OR component = infrastructure AND subcomponent = build) AND reporter != "Shadow Bug" ORDER BY priority, component, subcomponent, assignee</code> </pre> <br><p>  Hanya 1 buah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK-8216039</a> : "TLS dengan BC dan RSASSA-PSS memecah ECDHServerKeyExchange".  Tidak tebal.  Jika argumen ini masih tidak membantu, maka, sebagai pengacara Anda, saya sarankan mencoba obat penenang. </p><br><h1 id="i-chto-zhe-v-suhom-ostatke">  Dan apa intinya? </h1><br><p><img src="https://habrastorage.org/webt/ef/uf/mx/efufmx-2rdphagrcihuscp0cswo.png"></p><br><p>  Jelas bahwa sebagian besar fitur tidak mempengaruhi pengguna (pemrogram Java), tetapi pengembang OpenJDK itu sendiri.  Oleh karena itu, untuk berjaga-jaga, saya membagi fitur menjadi <strong>eksternal</strong> dan <strong>internal</strong> .  Anda dapat melewati yang internal, tetapi saya tersinggung, saya menulis begitu banyak teks. </p><br><p>  <strong>189: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shenandoah: Pengumpul Sampah Jeda Waktu Rendah (Eksperimental)</a></strong> </p><br><p>  <strong>Fitur eksternal</strong> .  Singkatnya, orang-orang tidak menyukainya ketika Jawa melambat, terutama jika SLA membutuhkan respons terhadap urutan 10-500 milidetik.  Kami sekarang memiliki GC low-punch gratis yang mencoba bekerja lebih dekat ke tepi kiri kisaran ini.  Imbalannya adalah kami menukar CPU dan RAM untuk mengurangi latensi.  Penandaan pinggul dan fase pemadatan bekerja secara paralel dengan utas aplikasi langsung.  Jeda kecil yang tersisa disebabkan oleh fakta bahwa Anda masih perlu mencari dan memperbarui akar grafik objek. </p><br><p>  Jika tidak ada di atas yang masuk akal bagi Anda - tidak masalah, Shenandoah <em>hanya berfungsi</em> , terlepas dari memahami atau tidak memahami proses yang mendasarinya. </p><br><p>  Alexei Shipilev, Christina Flood dan Roman Kennke sedang mengerjakannya - Anda harus berusaha keras untuk tidak tahu tentang orang-orang ini.  Jika Anda umumnya memahami cara kerja GC tetapi tidak tahu apa yang bisa dilakukan pengembang di sana, saya sarankan Anda melihat terjemahan indah dari artikel Leshina yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengumpul Sampah Homemade untuk OpenJDK"</a> atau seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM Anatomy Quark</a> .  Ini <strong>sangat menarik</strong> . </p><br><blockquote>  <strong>Sangat penting.</strong>  Oracle memutuskan untuk tidak mengirimkan Sheandoah dengan rilis apa pun - baik yang ada di jdk.java.net maupun yang ada di oracle.com.  Mengingat Shenandoah adalah salah satu fitur paling penting dari JDK 12, ada baiknya memasang beberapa perakitan resmi lainnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">misalnya, dari Azul</a> . </blockquote><br><hr><br><p>  <strong>230: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microbenchmark Suite</a></strong> </p><br><p>  <strong>Fitur batin</strong> .  Jika Anda pernah mencoba menulis microbenchmarks, maka Anda tahu bahwa ini dilakukan pada JMH.  JMH adalah kerangka kerja untuk membuat, merakit, meluncurkan dan menganalisis microbenchmark untuk Java dan bahasa JVM lainnya, Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sendiri mengerti siapa yang</a> menulisnya (semua kebetulan adalah acak).  Sayangnya, tidak semua yang dilakukan di dunia aplikasi "normal" dapat diterapkan di dalam JDK.  Sebagai contoh, kita tidak akan pernah melihat kode Spring Framework normal di sana. </p><br><p>  Untungnya, mulai dari versi 12, Anda dapat menggunakan setidaknya JMH, dan sudah ada serangkaian tes yang tertulis di sana.  Anda dapat melihatnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>jdk/jdk/test/micro/org/openjdk/bench</code></a> (Anda dapat langsung melihat di browser, jalur ini adalah tautan). </p><br><p>  Misalnya, <a href="">beginilah</a> tampilan <a href="">tes GC</a> . </p><br><blockquote>  Biarkan saya mengingatkan Anda bahwa kami tidak memiliki StackOverflow di sini, dan dilarang menggunakan kode dari copy-paste, di sini dan selanjutnya, tanpa membaca dan mengamati semua lisensi dari <a href="">file yang sesuai</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek OpenJDK</a> secara umum, jika tidak, Anda akan dengan mudah meminta kaus kaki terakhir untuk menuntut. </blockquote><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Alloc</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LENGTH = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ARR_LEN = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largeLen = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smalllen = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLargeConstArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole bh)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localArrlen = ARR_LEN; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LENGTH; i++) { Object[] tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[localArrlen]; bh.consume(tmp); } } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><hr><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">325: Alihkan Ekspresi (Pratinjau)</a></strong> </p><br><p>  <strong>Fitur eksternal</strong> .  Ini secara fundamental akan mengubah pendekatan Anda untuk menulis switch tanpa akhir dengan panjang lebih dari dua layar.  Lihat: </p><br><h3 id="virgin-java-switch-vs-">  Virgin Java Switch vs ... </h3><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dayNum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: dayNum = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: dayNum = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: dayNum = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: dayNum = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  <strong>Mengapa ini buruk</strong> : ada banyak surat, Anda dapat melewatkan waktu istirahat (terutama jika Anda seorang pecandu narkoba atau Anda menderita ADHD). </p><br><h3 id="-vs-chad-java-swtich-expression">  ... vs Chad Java Swtich Expression! </h3><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dayNum = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = day.toString().length(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = f(k); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> result; } };</code> </pre> <br><p>  <strong>Mengapa bagus</strong> : beberapa huruf, aman, nyaman, fitur keren baru. </p><br><p>  <strong>Bonus</strong> : jika Anda seorang sadis, itu akan memberi Anda kepuasan terdalam, karena ribuan pengembang IDE sekarang tersiksa dengan dukungan fitur ini.  Ya, ya? <del>  Anda dapat menangkapnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah laporan pada 6 April</a> dan dengan lembut meminta untuk memberikan semua rincian kotor. </del></p><br><blockquote>  <strong>Ini adalah fitur pratinjau, itu tidak akan berfungsi!</strong>  Saat mengkompilasi, di <code>javac</code> Anda harus melewati opsi baris perintah <code>--enable-preview --release 12</code> , dan untuk menjalankan melalui <code>java</code> - hanya flag <code>--enable-preview</code> . </blockquote><br><hr><br><p>  <strong>334: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM Constants API</a></strong> </p><br><p>  <strong>Fitur batin</strong> .  Pengembang ingin memanipulasi file kelas.  Anda perlu melakukan ini dengan nyaman, dan ini adalah pernyataan masalahnya.  Setidaknya, itulah yang dikatakan Brian Goetz, yang memiliki JEP ini, :-) Semua ini adalah bagian dari medan perang yang lebih besar, tetapi untuk saat ini kami tidak akan terlalu dalam. </p><br><p>  Setiap kelas Java memiliki apa yang disebut "kolam konstan" di mana ada dump dari beberapa nilai (seperti string dan int), atau entitas runtime seperti kelas dan metode.  Anda dapat menggali ke dalam dump ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi ldc</a> - "load costant", sehingga semua sampah ini disebut konstanta yang dapat dimuat.  Masih ada kasus khusus untuk invokedynamic, tetapi tidak apa-apa. </p><br><p>  Jika kita bekerja dengan classfile, maka kita ingin dengan mudah mensimulasikan instrumen bytecode, dan karenanya - konstanta yang dapat dimuat.  Keinginan pertama adalah hanya membuat tipe Java yang sesuai, tetapi bagaimana Anda menyajikannya dengan kelas "hidup", struktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CONSTANT_Class_info</code></a> ?  Objek <code>Class</code> tergantung pada kebenaran dan konsistensi pemuatan kelas, dan dengan pemuatan kelas di Jawa, bacchanalia neraka dibuat.  Untuk memulainya, tidak semua kelas dapat dimuat ke dalam VM, tetapi Anda masih perlu menjelaskannya! </p><br><p>  Saya ingin entah bagaimana mengelola hal-hal seperti kelas, metode, dan binatang yang kurang dikenal seperti pegangan metode dan konstanta dinamis, dengan mempertimbangkan semua seluk-beluk ini. </p><br><p>  Ini dipecahkan dengan memperkenalkan tipe baru dari tautan simbolik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbasis nilai</a> (dalam arti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVMS 5.1</a> ), yang masing-masing menggambarkan tipe konstan tertentu.  Menjelaskan secara murni nominal, terpisah dari kelas pemuatan atau masalah akses.  Mereka tinggal dalam paket-paket seperti <code>java.lang.invoke.constant</code> dan tidak memintanya, tetapi Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat</a> tambalan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><hr><br><p>  <strong>340: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Satu Port AArch64, Bukan Dua</a></strong> <br>  <strong>Fitur eksternal</strong> .  Sudah di JDK 9 ada situasi aneh ketika Oracle dan Red Hat secara bersamaan membuat port ARM mereka dalam keadaan siaga.  Dan sekarang kita melihat akhir dari cerita: bagian 64-bit dari pelabuhan Oraklov telah dihapus dari hulu. </p><br><p>  Anda bisa menggali sejarah untuk waktu yang lama, tetapi ada cara yang lebih baik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BellSoft</a> berpartisipasi dalam pengembangan JEP ini, dan kantornya berlokasi di St. Petersburg, di sebelah bekas kantor Oracle. </p><br><p>  Karena itu, saya segera beralih ke Alexey Voitilov, CTO dari BellSoft: </p><br><blockquote>  "BellSoft meluncurkan Liberica JDK, yang, selain x86 Linux / Windows / Mac dan Solaris / SPARC, juga mendukung ARM. Dimulai dengan JDK 9 untuk ARM, kami berfokus pada peningkatan kinerja port AARCH64 untuk aplikasi server dan terus mendukung port ARM 32-bit untuk Jadi, pada saat rilis JDK 11, ada situasi di mana tidak ada yang mendukung bagian port 64-bit dari Oracle (termasuk Oracle), dan komunitas OpenJDK memutuskan untuk menghapusnya untuk fokus pada port AARCH64. Saat ini, lebih produktif ( lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 315</a> , yang kita  diintegrasikan ke dalam JDK 11) dan, mulai dari JDK 12, mendukung semua fitur yang ada di port dari Oracle (yang terakhir, Minimal VM, saya terintegrasi pada bulan September). Oleh karena itu, saya senang membantu Bob Vandette menghapus rudiment ini di JDK 12. Akibatnya, OpenJDK komunitas menerima satu port pada AARCH64 dan satu port ARM32, yang tentunya membuat mereka lebih mudah untuk didukung. " </blockquote><br><hr><br><p>  <strong>341: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsip CDS Default</a></strong> </p><br><p>  <strong>Fitur batin</strong> .  Masalahnya adalah bahwa pada awal aplikasi Java, ribuan kelas dimuat, yang menciptakan perasaan bahwa Java melambat secara signifikan pada saat startup.  Tetapi siapa yang ada di sana untuk berbohong, ini bukan hanya "sensasi" - memang begitu.  Untuk memperbaiki masalah dari zaman kuno, berbagai ritual dipraktikkan. </p><br><p>  Class Data Sharing adalah fitur yang telah datang kepada kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejak berabad-abad yang</a> lalu, seperti fitur komersial dari JDK 8 Update 40. Ini memungkinkan Anda untuk mengemas semua sampah startup ini ke dalam arsip dengan format Anda sendiri (Anda tidak perlu tahu yang mana), setelah itu kecepatan peluncuran aplikasi meningkat.  Dan setelah beberapa saat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 310</a> muncul: Application Class-Data Sharing, yang memungkinkan kami untuk bekerja dengan cara yang sama tidak hanya dengan kelas sistem, tetapi juga kelas aplikasi. </p><br><p>  Untuk kelas JDK, terlihat seperti ini.  Pertama, kita membuang kelas dengan perintah <code>java -Xshare:dump</code> , dan kemudian menjalankan aplikasi, menyuruhnya menggunakan cache ini: <code>java -Xshare:on -jar app.jar</code> .  Semuanya, startup telah sedikit membaik.  Tahukah Anda tentang fitur ini?  Banyak yang masih belum tahu! </p><br><p>  Kelihatannya aneh di sini: mengapa setiap kali ritual menulis <code>-Xshare:dump</code> jika hasil default dari perintah ini sedikit dapat diprediksi bahkan pada tahap membuat distribusi JDK?  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , jika distribusi Java 8 diinstal menggunakan installer, maka tepat pada saat instalasi itu harus menjalankan perintah yang diperlukan untuk Anda.  Seperti, penginstal diam-diam menambang di sudut.  Tapi mengapa?  Dan apa yang harus dilakukan dengan distribusi, yang didistribusikan bukan sebagai installer, tetapi sebagai file zip? </p><br><p>  Sederhana: dimulai dengan JDK 12, arsip CDS akan dihasilkan oleh pembuat kit distribusi, segera setelah menautkan.  Bahkan untuk build malam (asalkan 64-bit dan asli, bukan untuk kompilasi silang). </p><br><p>  Pengguna bahkan tidak perlu tahu tentang keberadaan fitur ini, karena, dimulai dengan JDK 11, <code>-Xshare:auto</code> diaktifkan secara default, dan arsip semacam itu akan mengambil secara otomatis.  Jadi, <strong>fakta memperbarui ke JDK 12 mempercepat peluncuran aplikasi!</strong> </p><hr><br><p>  <strong>344: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koleksi Campuran yang Diabaikan untuk G1</a></strong> </p><br><p>  <strong>Fitur batin</strong> .  Sejujurnya <del>  Saya tidak mengerti apa pun dalam karya G1 </del>  Penjelasan tentang fitur-fitur GC adalah tugas tanpa pamrih.  Itu membutuhkan pemahaman tentang detail karyanya baik dari penjelajah dan pemahaman.  Bagi kebanyakan orang, GC adalah semacam kotak tembakau yang bisa Anda curang jika terjadi sesuatu.  Karena itu, masalahnya harus dijelaskan dengan cara yang lebih sederhana. </p><br><p>  <strong>Masalah</strong> : G1 mungkin bekerja lebih baik. </p><br><p>  Nah, masalahnya adalah bahwa GC adalah kompromi dari banyak parameter, salah satunya adalah panjang jeda.  Terkadang jeda terlalu panjang, dan menyenangkan untuk membatalkannya. </p><br><p>  Kapan ini terjadi?  G1 benar-benar menganalisis perilaku aplikasi dan memilih bagian depan pekerjaan (dinyatakan sebagai <em>kumpulan koleksi</em> ) berdasarkan kesimpulannya.  Ketika ruang lingkup pekerjaan disetujui, G1 berjanji untuk mengumpulkan semua benda hidup dalam kumpulan koleksi, keras kepala dan tanpa henti, dalam satu kali duduk.  Terkadang butuh terlalu banyak waktu.  Intinya, ini berarti bahwa G1 salah menghitung jumlah pekerjaan.  Anda dapat membodohinya dengan tiba-tiba mengubah perilaku aplikasi Anda sehingga heuristik akan bekerja di atas data buruk ketika terlalu banyak daerah lama masuk ke kumpulan set. </p><br><p>  Untuk keluar dari situasi ini, G1 diselesaikan dengan mekanisme berikut: jika heuristik secara teratur memilih jumlah pekerjaan yang salah, G1 beralih ke pengumpulan sampah tambahan, langkah demi langkah, dan setiap langkah berikutnya (jika tidak sesuai dengan waktu pelaksanaan target) dapat dibatalkan.  Tidak masuk akal untuk mengumpulkan sesuatu secara bertahap (wilayah muda), oleh karena itu, semua pekerjaan tersebut disorot dalam blok "wajib", yang masih dilakukan terus menerus. </p><br><p>  Apa yang harus dilakukan dengan pengguna akhir?  Tidak ada, Anda perlu meningkatkan ke JDK 12, semuanya akan menjadi lebih baik dengan sendirinya. </p><hr><br><p>  <strong>346: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Segera Kembalikan Memori yang Tidak Dipakai Sebelumnya dari G1</a></strong> </p><br><p>  <strong>Fitur batin</strong> .  Masalahnya adalah jika kita memiliki pinggul besar yang tidak digunakan siapa pun secara aktif, tampaknya adil untuk mendapatkan semua memori tidak aktif ini kembali ke sistem operasi.  Namun sebelum JDK 12, ini tidak terjadi. </p><br><p>  Untuk mencapai tujuannya dalam hal panjang jeda yang diizinkan, G1 melakukan serangkaian siklus bertahap, paralel, dan multi-tahap.  Dalam JDK 11, ini memberikan memori yang dikomit ke sistem operasi hanya dengan GC penuh, atau selama fase penandaan paralel.  Jika Anda menghubungkan logging (-Xloggc: /home/gc.log -XX: + PrintGCDetails -XX: + PrintGCDateStamps), maka fase ini akan ditampilkan seperti ini: </p><br><pre> <code class="plaintext hljs">8801.974: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: occupancy higher than threshold, occupancy: 12582912000 bytes, allocation request: 0 bytes, threshold: 12562779330 bytes (45.00 %), source: end of GC] 8804.670: [G1Ergonomics (Concurrent Cycles) initiate concurrent cycle, reason: concurrent cycle initiation requested] 8805.612: [GC concurrent-mark-start] 8820.483: [GC concurrent-mark-end, 14.8711620 secs]</code> </pre> <br><p>  Yang lucu adalah bahwa G1, seperti itu, berjuang dengan berhenti total, dan siklus bersamaan dimulai hanya dengan alokasi yang sering dan tumpukan tersumbat.  Situasi kita, ketika tidak ada yang menyentuh pinggul, justru sebaliknya.  Situasi ketika G1 tergores untuk memberikan memori ke sistem operasi akan terjadi sangat jarang! </p><br><p>  Jadi, setiap orang akan mendapat skor pada masalah ini ("beli lebih banyak RAM, yang seperti bajingan!"), Jika bukan hanya satu tapi - ada segala macam awan dan wadah di mana ini berarti pemanfaatan yang tidak memadai dan kehilangan uang yang serius.  Lihat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang keren</a> , dipenuhi sampai penuh dengan rasa sakit. </p><br><p>  Solusinya adalah mengajar G1 untuk berperilaku baik dalam kasus khusus ini, seperti yang sudah diketahui oleh Shenanda atau GenCon dari OpenJ9.  Hal ini diperlukan untuk menentukan pemanfaatan pinggul yang tidak memadai dan, karenanya, mengurangi penggunaannya.  Pada beberapa tes di Tomcat, ini memungkinkan untuk mengurangi konsumsi memori hampir setengahnya. </p><br><p>  Intinya adalah bahwa aplikasi dianggap tidak aktif, atau jika interval (dalam milidetik) telah <code>getloadavg()</code> dari build terakhir dan tidak ada siklus bersamaan, atau jika <code>getloadavg()</code> untuk periode satu menit menunjukkan beban di bawah ambang tertentu.  Begitu salah satu dari ini terjadi, pengumpulan sampah secara berkala dimulai - itu pasti tidak akan membersihkan serta perakitan penuh, tetapi itu akan mempengaruhi aplikasi minimal. </p><br><p>  Anda dapat mendorongnya ke dalam log ini: </p><br><pre> <code class="plaintext hljs">(1) [6.084s][debug][gc,periodic ] Checking for periodic GC. [6.086s][info ][gc ] GC(13) Pause Young (Concurrent Start) (G1 Periodic Collection) 37M-&gt;36M(78M) 1.786ms (2) [9.087s][debug][gc,periodic ] Checking for periodic GC. [9.088s][info ][gc ] GC(15) Pause Young (Prepare Mixed) (G1 Periodic Collection) 9M-&gt;9M(32M) 0.722ms (3) [12.089s][debug][gc,periodic ] Checking for periodic GC. [12.091s][info ][gc ] GC(16) Pause Young (Mixed) (G1 Periodic Collection) 9M-&gt;5M(32M) 1.776ms (4) [15.092s][debug][gc,periodic ] Checking for periodic GC. [15.097s][info ][gc ] GC(17) Pause Young (Mixed) (G1 Periodic Collection) 5M-&gt;1M(32M) 4.142ms (5) [18.098s][debug][gc,periodic ] Checking for periodic GC. [18.100s][info ][gc ] GC(18) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 1.685ms (6) [21.101s][debug][gc,periodic ] Checking for periodic GC. [21.102s][info ][gc ] GC(20) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.868ms (7) [24.104s][debug][gc,periodic ] Checking for periodic GC. [24.104s][info ][gc ] GC(22) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.778ms</code> </pre> <br><p>  Mencari tahu?  Saya tidak.  Di JEP, ada terjemahan bahasa isyarat terperinci dari setiap baris log, dan bagaimana algoritma bekerja, dan yang lainnya. </p><br><p>  "Jadi apa, mengapa aku mencari tahu?"  - kamu bertanya.  Sekarang kami memiliki dua pegangan tambahan: <code>G1PeriodicGCInterval</code> dan <code>G1PeriodicGCSystemLoadThreshold</code> , yang dapat diputar ketika menjadi buruk.  Pasti suatu hari akan buruk, ini Jawa, sayang! </p><hr><br><h1 id="itogi">  Ringkasan </h1><br><p>  Akibatnya, kami memiliki rilis yang kuat di tangan kami - bukan revolusi, tetapi evolusi yang berfokus pada peningkatan kinerja.  Setengah dari peningkatan terkait dengan kinerja: tiga JEPs tentang GC dan satu tentang CDS, yang berjanji untuk dihidupkan sendiri, hanya perlu ditingkatkan ke JDK 12. Selain itu, kami menerima satu fitur bahasa (sakelar ekspresi), dua alat baru untuk pengembang JDK ( Uji Konstanta API dan JMH), dan sekarang komunitas dapat lebih fokus pada port 64-bit tunggal pada ARM. </p><br><p>  Secara umum, tingkatkan ke JDK 12 sekarang, dan mungkin the Force bersama Anda.  Anda akan membutuhkannya. </p><br><blockquote>  Menit periklanan.  Segera, pada tanggal 5-6 April, konferensi JPoint akan diadakan, yang akan mempertemukan sejumlah besar orang yang tahu banyak tentang JDK dan semua jenis fitur baru.  Sebagai contoh, pasti akan ada Simon Ritter dari Azul dengan kuliah tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"JDK 12: Perangkap bagi yang tidak waspada"</a> .  Tempat paling tepat untuk mendiskusikan rilis terbaru!  Anda dapat mempelajari lebih lanjut tentang JPoint di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444434/">https://habr.com/ru/post/id444434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444424/index.html">AMD Radeon VII: Chip High-End (Bagian 2)</a></li>
<li><a href="../id444426/index.html">Lyft dan Uber go IPO publik. Mengapa berinvestasi di Lyft?</a></li>
<li><a href="../id444428/index.html">Mountain Car: Memecahkan tantangan klasik dengan pelatihan penguatan</a></li>
<li><a href="../id444430/index.html">Analisis: bagaimana cara menggunakan Present Perfect dalam bahasa Inggris</a></li>
<li><a href="../id444432/index.html">Penggunaan Linux dan perangkat lunak sumber terbuka di lembaga pendidikan kita: menjadi atau tidak?</a></li>
<li><a href="../id444436/index.html">Apa itu botnet Mirai, dan bagaimana cara melindungi perangkat saya?</a></li>
<li><a href="../id444438/index.html">Sejarah singkat sumber terbuka - bagaimana perangkat lunak bebas berperang dengan hak milik</a></li>
<li><a href="../id444442/index.html">Jetson Nano: Nvidia Machine Learning Single Board</a></li>
<li><a href="../id444444/index.html">Kegagalan terbaik dari konferensi kami (Joker, JPoint, DotNext, Mobius, TechTrain dan sebagainya)</a></li>
<li><a href="../id444446/index.html">Membuat aplikasi web modern dari awal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>