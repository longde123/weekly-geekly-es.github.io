<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳🏿 ⏳ 🎅🏼 准备好联合收割机 👨‍👧‍👧 🤜🏿 🦃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一年半以前，我唱了 RxSwift的赞歌 。 我花了一些时间才弄清楚，但是当那件事发生时，没有回头路了。 现在，我拥有世界上最好的锤子，如果我周围的一切看起来都不像钉子，该死的我。 

 苹果在WWDC夏季会议上介绍了Combine框架。 乍一看，它看起来像是RxSwift的更好的版本。 在我可以解...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>准备好联合收割机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470117/"><img src="https://habrastorage.org/webt/km/8-/uo/km8-uov-j3m2rfjjsxscoyeh9bc.jpeg"><br><br> 一年半以前，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唱了</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxSwift的赞歌</a> 。 我花了一些时间才弄清楚，但是当那件事发生时，没有回头路了。 现在，我拥有世界上最好的锤子，如果我周围的一切看起来都不像钉子，该死的我。 <br><br> 苹果在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWDC</a>夏季会议上介绍了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Combine</a>框架。 乍一看，它看起来像是RxSwift的更好的版本。 在我可以解释自己喜欢什么以及不喜欢什么之前，我们需要了解Combine旨在解决的问题。 <br><a name="habracut"></a><br><h2> 反应性编程？ 那又怎样 </h2><br>  ReactiveX社区-RxSwift社区是其中的一部分-解释其本质如下： <br><br><blockquote> 具有可观察线程的异步编程的API。 </blockquote><br> 并且： <br><br><blockquote>  ReactiveX是Observer和Iterator设计模式以及功能编程中最好的想法的结合。 </blockquote><br> 好吧...好吧。 <br><br> 这到底是<i>什么</i>意思？ <br><br><h2> 基础知识 </h2><br> 为了真正理解反应式编程的本质，我发现了解我们如何理解它很有用。 在本文中，我将描述如何使用任何现代OOP语言查看现有类型，如何将它们扭曲，然后进行反应式编程。 <br><br> 在本文中，我们将快速深入丛林，这对于理解反应式编程并不是<i>绝对</i>必要的。 <br><br> 但是，我认为这是一种好奇的学术活动，特别是在强类型语言可以引导我们获得新发现方面。 <br><br> 因此，如果您对新细节感兴趣，请等待我的下一篇文章。 <br><br><h2> 可数 </h2><br> 我所知道的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反应式编程</a> ”起源于我曾经写过的语言-C＃。 前提本身很简单： <br><br>  <i>如果它们将自己发送值给您，而不是从可枚举中提取值，该怎么办？</i> <br><br> 布莱恩·贝克曼<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（</a> Brian Beckman）和埃里克·梅耶（Eric Meyer）最好地<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述了</a> “推而不拉”的想法。 前36分钟...我什么都听不懂，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从第36分钟开始，</a>它变得<i>非常</i>有趣。 <br><br> 简而言之，让我们重新构建Swift中线性对象组的概念，以及可以在该线性组上迭代的对象。 您可以通过定义以下虚假的Swift协议来做到这一点： <br><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ;     //    Array. protocol Enumerable { associatedtype Enum: Enumerator associatedtype Element where Self.Element == Self.Enum.Element func getEnumerator() -&gt; Self.Enum } // ,       . protocol Enumerator: Disposable { associatedtype Element func moveNext() throws -&gt; Bool var current: Element { get } } //          // Enumerator,         .   . protocol Disposable { func dispose() }</span></span></code> </pre> <br><h2> 双打 </h2><br> 让我们把它翻过来，做成<i>双打</i> 。 我们会将数据发送到它们的来源。 并从他们离开的地方获取数据。 听起来很荒谬，但请忍受一点。 <br><br><h3> 双枚举 </h3><br> 让我们从Enumerable开始： <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerable { associatedtype Element where Self.Element == Self.Enum.Element associatedtype Enum: Enumerator func getEnumerator() -&gt; Self.Enum } protocol DualOfEnumerable { //  Enumerator : // getEnumerator() -&gt; Self.Enum //    : // getEnumerator(Void) -&gt; Enumerator // //  , : // : Void; : Enumerator // getEnumerator(Void) → Enumerator // //     Void   Enumerator. //   -      Enumerator,   Void. // :  Enumerator; : Void func subscribe(DualOfEnumerator) }</span></span></code> </pre> <br> 由于<code>getEnumerator()</code>接受<code>Void</code>并提供了<code>Enumerator</code> ，所以现在我们接受[double] <code>Enumerator</code>并提供<code>Void</code> 。 <br><br> 我知道这很奇怪。 不要离开 <br><br><h3> 双枚举器 </h3><br> 然后， <code>DualOfEnumerator</code>是<code>DualOfEnumerator</code> ？ <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerator: Disposable { associatedtype Element // : Void; : Bool, Error func moveNext() throws -&gt; Bool // : Void; : Element var current: Element { get } } protocol DualOfEnumerator { // : Bool, Error; : Void //   Error    func enumeratorIsDone(Bool) // : Element, : Void var nextElement: Element { set } }</span></span></code> </pre> <br> 这里有几个问题： <br><br><ul><li>  Swift中没有set-only属性的概念。 <br></li><li>  <code>Enumerator.moveNext()</code> <code>throws</code>发生了什么？ <br></li><li>  <code>Disposable</code>怎么办？ <br></li></ul><br> 为了解决set-only属性的问题，我们可以将其视为真正的函数。 让我们<code>DualOfEnumerator</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool; : Void, Error //   Error    func enumeratorIsDone(Bool) // : Element, : Void func next(Element) }</span></span></code> </pre> <br> 为了解决<code>throws</code>的问题，让我们分离<code>moveNext()</code>中可能发生的错误，并将其作为单独的<code>error()</code>函数使用： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool, Error; : Void func enumeratorIsDone(Bool) func error(Error) // : Element, : Void func next(Element) }</span></span></code> </pre> <br> 我们可以做其他事情：看一下迭代完成的签名： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool)</span></span></span></span></code> </pre> <br> 随着时间的流逝，类似的事情可能会发生： <br><br><pre> <code class="swift hljs">enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     enumeratorIsDone(true)</span></span></code> </pre> <br> 现在，让我们简化事情，仅在一切准备就绪时才调用<code>enumeratorIsDone</code> 。 以此思路为指导，我们简化了代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h3> 好好照顾自己 </h3><br>  <code>Disposable</code>呢？ 怎么办呢？ 由于<code>Disposable</code>是<code>Enumerator</code> <i>类型的</i>一部分<i>，因此</i>当我们得到<code>Enumerator</code> <i>double时</i> ，它可能根本就不应该在<code>Enumerator</code> 。 相反，它应该是<code>DualOfEnumerable</code>一部分。 但是到底在哪里？ <br><br>  <code>DualOfEnumerator</code>这里： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span></code> </pre> <br> 如果我们接受<code>DualOfEnumerator</code> ，那么不应该<i>返回</i> <code>Disposable</code>吗？ <br><br> 最终您会得到什么样的加倍： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2> 称它为玫瑰，虽然不是 </h2><br> 所以，再来一次，这就是我们得到的： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br> 现在让我们来玩一下名称。 <br><br> 让我们从<code>DualOfEnumerator</code>开始。 我们将为这些功能命名更好，以更准确地描述正在发生的事情： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br> 如此更好，更容易理解。 <br><br> 那类型名呢？ 他们真可怕。 让我们对其进行一些更改。 <br><br><ul><li>  <code>DualOfEnumerator</code>跟随线性对象组发生的事情。 可以说他<i>观察到</i>一个线性群。 <br></li><li>  <code>DualOfEnumerable</code>是一个观察对象。 我们在看什么。 因此，可以将其称为<i>observable</i> 。 <br></li></ul><br> 现在进行最终更改并获得以下信息： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observer)</span></span></span></span> → <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2> 哇 </h2><br> 我们刚刚在RxSwift中创建了两个基本对象。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>查看其真实版本。 请注意，在Observer的情况下，三个<code>on()</code>函数组合为一个<code>on(Event)</code> ，其中<code>Event</code>是一个枚举，用于确定事件是什么-完成，下一个值或错误。 <br><br> 这两种类型是RxSwift和反应式编程的基础。 <br><br><h2> 关于虚假协议 </h2><br> 我上面提到的两个“伪”协议实际上根本不是伪造的。 这些是Swift中现有类型的类似物： <br><br><ul><li> 可枚举的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">序列</a> <br></li><li> 枚举<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">器</a>是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迭代器</a>序列 <br></li></ul><br><h2> 那又怎样 </h2><br> 那该担心什么呢？ <br><br> 在现代开发（ <i>尤其是</i>应用程序开发）中，异步是如此重要。 用户突然单击了一个按钮。 用户突然在UISegmentControl中选择了一个选项卡。 用户突然在UITabBar中选择了一个选项卡。  Web套接字突然为我们提供了新信息。 此下载突然-最终-结束。 此后台任务突然结束。 这个清单不胜枚举。 <br><br> 在现代的CocoaTouch世界中，有许多方法可以处理此类事件： <br><br><ul><li> 通知 <br></li><li> 回叫 <br></li><li> 键值观察（KVO）， <br></li><li> 目标/行动机制。 <br></li></ul><br> 想象一下，是否<i>所有这些</i>都可以反映在一个界面中。 它可以与整个应用程序中的<i>任何</i>类型的异步数据或事件一起使用。 <br><br> 现在想象一下，如果有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一整套功能</a>可以让您修改这些<i>流</i> ，将它们从一种类型转换为另一种类型，从Elements中提取信息，或者甚至将它们与其他流组合。 <br><br> 突然，我们手中有了一套新的<i>通用</i>工具。 <br> 因此，我们回到了开始： <br><br><blockquote> 具有可观察线程的异步编程的API。 </blockquote><br> 这就是使RxSwift如此强大的工具的原因。 像合并。 <br><br><h2> 接下来是什么？ </h2><br> 如果您想<i>在实践中</i>阅读有关RxSwift的更多信息，那么我建议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您在2016年撰写五篇文章</a> 。 他们描述了如何创建一个简单的CocoaTouch应用程序，然后逐步转换为RxSwift。 <br><br> 在以下文章之一中，我将解释为什么我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章系列中针对初学者的</a>许多技术都不适用于Combine，并且还将Combine与RxSwift进行了比较。 <br><br><h1> 结合：有什么意义？ </h1><br> 对Combine的讨论还包括对它与RxSwift之间的主要区别的讨论。 对我来说，其中三个： <br><br><ul><li> 使用非反应性类的可能性， <br></li><li> 错误处理 <br></li><li> 背压。 <br></li></ul><br> 我将为每个项目撰写单独的文章。 我将从第一个开始。 <br><br><h2>  RxCocoa的功能 </h2><br> 在上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中，</a>我说过RxSwift不仅仅是... RxSwift。 它为在RxCocoa的type-not-not-quite子项目中使用UIKit中的控件提供了多种可能性。 此外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxSwiftCommunity</a>进一步走了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一步，</a>并为UIKit的更多僻静街道以及RxSwift和RxCocoa尚未涵盖的其他一些CocoaTouch类实现了许多绑定。 <br><br> 因此，很容易通过单击UIButton来获得<code>Observable</code>流。 我将再次给出此示例： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br> 重量轻。 <br><br><h2> 让我们（最后）仍然谈论组合 </h2><br> 合并与RxSwift非常相似。 如文档所述： <br><br><blockquote>  Combine框架提供了一个声明性的Swift API，用于随时间处理值。 </blockquote><br> 听起来很熟悉：回想一下ReactiveX（RxSwift的父项目）的描述： <br><br><blockquote> 具有可观察线程的异步编程的API。 </blockquote><br> 在两种情况下，都说相同的话。 只是ReactiveX的描述中使用了特定的术语。 可以重新定义如下： <br><br><blockquote> 用于随时间推移使用值进行异步编程的API。 </blockquote><br> 和我差不多。 <br><br><h2> 和以前一样 </h2><br> 当我开始分析API时，很明显，我从RxSwift知道的大多数类型在Combine中都有类似的选项： <br><br><ul><li> 可观察→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布者</a> <br></li><li> 观察者→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">订阅者</a> <br></li><li> 一次性→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">取消</a> 。 这是营销的胜利。 当我开始在RxSwift中描述Disposable时，您无法想象我从更公正的开发人员那里得到了多少惊喜。 <br></li><li>  SchedulerType→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序</a> <br></li></ul><br> 到目前为止一切顺利。 再一次，我更喜欢Cancellicable，而不是Disposable。 一个很好的替代品，不仅在营销方面，而且在对对象本质的准确描述方面。 <br><br> 多多益善！ <br><br><ul><li>  RxCocoa的驱动程序-&gt;这是SwiftUI的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BindableObject</a> <br></li></ul><br> 目前尚不清楚，但从精神上讲，它们仅用于一个目的，并且其中任何一个都不会引起错误。 <br><br><ul><li> 单人→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未来</a> <br></li><li>  SubjectType→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主题</a> <br></li><li>  PublishSubject→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PassthroughSubject</a> <br></li></ul><br><h2>  “打破船尾” </h2><br> 一旦您开始研究RxCocoa，一切都会改变。 还记得上面的示例，我们想在其中获得一个Observable流，该流代表UIButton的点击？ 这是： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br> 合并需要……要做更多的工作。 <br><br>  <b>Combine不提供任何绑定到UIKit对象的功能。</b> <br><br> 这……真是个虚幻的经历。 <br><br> 这是使用Combine从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UIControl</a>获取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UIControl.Event</a>的常用方法： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlPublisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIControl</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> = (control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = <span class="hljs-type"><span class="hljs-type">PassthroughSubject</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Output</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">convenience</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: control, events: [event]) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, events: [<span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events { control.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(controlAction), <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: event) } } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">controlAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIControl, forEvent event: UIControl.Event)</span></span></span></span> { subject.send(<span class="hljs-type"><span class="hljs-type">ControlEvent</span></span>(control: sender, event: event)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { subject.receive(subscriber: subscriber) } }</code> </pre> <br> 这里...还有更多工作。 至少呼叫看起来像： <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>(control: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button, event: .touchUpInside) .sink { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }</code> </pre> <br> 为了进行比较，RxCocoa以绑定到UIKit对象的形式提供了一种令人愉悦的可可豆： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) })</code> </pre> <br> 就其本身而言，这些挑战最终确实非常相似。 唯一令人沮丧的是，我必须自己编写<code>ControlPublisher</code>才能达到这一点。 此外，RxSwift和RxCocoa经过了很好的测试，在项目中的使用量远远超过我的。 <br><br> 为了进行比较，我的<code>ControlPublisher</code>仅...现在出现了。 仅由于客户端数量（零）和实际使用时间（与RxCocoa相比几乎为零），我的代码才能被认为更加危险。 <br><br>  mm <br><br><h2> 社区帮助？ </h2><br> 坦白地说，没有什么能阻止社区创建自己的开源“ CombineCocoa”，就像RxSwiftCommunity一样，填补了RxCocoa的空白。 <br><br> 但是，我认为这是Combine的巨大缺点。 我不想重写整个RxCocoa，仅是为了绑定到UIKit对象。 <br><br> 如果我决定下注<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SwiftUI</a> ，那么我想这将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消除</a>缺乏绑定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>问题。 甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的小型应用程序也</a>包含<i>一堆</i> UI代码。 把所有这些扔出去只是为了跳上联合火车，至少是愚蠢的，甚至是危险的。 <br><br> 顺便说一句，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>使用Combine接收和处理事件”</i></a>文档中的文章简要介绍了如何在Combine中接收和处理事件。 简介很好，它介绍了如何从文本字段中提取值并将其保存在自定义模型对象中。 该文档还演示了如何使用运算符对所涉及的流执行一些更高级的修改。 <br><br><h2> 例子 </h2><br> 让我们继续到文档的结尾，代码示例为： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { ($<span class="hljs-number"><span class="hljs-number">0</span></span>.object <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSTextField</span></span>).stringValue } ) .assign(to: \<span class="hljs-type"><span class="hljs-type">MyViewModel</span></span>.filterString, on: myViewModel)</code> </pre> <br> 我有很多问题。 <br><br><h2> 通知您我不喜欢它 </h2><br> 前两行引起我最多的问题： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NotificationCenter</a>类似于应用程序总线（甚至是系统总线），其中许多人可以抛出数据或捕获经过的信息。 根据创建者的意图，此解决方案来自“万事通”类别。 实际上，在很多情况下，您可能需要找出键盘刚刚被显示或隐藏的情况。  NotificationCenter是在整个系统中分发此消息的好方法。 <br><br> 但是对我而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NotificationCenter</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码很扼杀</a> 。 有时（例如获取有关键盘的通知）NotificationCenter实际上是解决该问题的<i>最佳</i>方法。 但是对于我来说，NotificationCenter经常是<i>最方便的</i>解决方案。 将某些内容放入NotificationCenter并将其拾取到应用程序中的其他位置确实非常方便。 <br><br> 另外，NotificationCenter是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“字符串”类型的</a> ，也就是说，您可以很容易地犯下您尝试发布或收听的通知的错误。  Swift正在尽一切可能改善这种情况，但是仍然存在相同的NSString。 <br><br><h2> 关于KVO </h2><br> 在Apple平台上，一直存在一种流行的方式来接收代码不同部分中的更改通知：键值观察（KVO）。 苹果这样描述： <br><br><blockquote> 这是一种机制，允许对象接收其他对象的指定属性更改的通知。 </blockquote><br> 多亏了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gui Rambo的</a>一条<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">推文，</a>我注意到Apple向Kombine添加了KVO绑定。 这可能意味着我可以摆脱对Combine中缺少RxCocoa类似物的许多失望。 如果我可以使用KVO，可以这么说，这可能会消除对CombineCocoa的需求。 <br><br> 我试图找出一个使用KVO从<code>UITextField</code>获取值并将其输出到控制台的示例： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textField.publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \<span class="hljs-type"><span class="hljs-type">UITextField</span></span>.text) .sink(receiveCompletion: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) }, receiveValue: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Text field is currently \"\($0)\""</span></span>) })</code> </pre> <br> 看起来不错，继续吗？ <br><br> 没那么快，朋友。 <br><br> 我忘记了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">令人不安的事实</a> ： <br><br>  UIKit基本上与KVO不兼容。 <br><br> 没有KVO的支持，我的想法将行不通。 我的检查确认了这一点：当我在字段中输入文本时，代码不会向控制台输出任何内容。 <br><br> 因此，我希望摆脱UIKit绑定的希望是美好的，但时间不长。 <br><br><h2> 清洁用品 </h2><br> 另一个合并问题是，仍然完全不清楚在何处以及如何释放<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可取消</a>对象中的资源。  <i>似乎</i>我们应该将它们存储在实例变量中。 但是我不记得官方文档中有关于清洁的内容。 <br><br>  RxSwift有一个名字叫<a href="">得很</a>方便的<a href="">DisposeBag</a> 。 在Combine中创建CancelBag并非易事，但我不太确定在这种情况下它是最佳解决方案。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在下一篇文章中，</a>我们将讨论RxSwift和Combine中的错误处理，以及这两种方法的优缺点。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470117/">https://habr.com/ru/post/zh-CN470117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470103/index.html">从头开始创建简单的答题器游戏</a></li>
<li><a href="../zh-CN470105/index.html">oktech Data Sense＃3：推荐系统</a></li>
<li><a href="../zh-CN470107/index.html">来自我的Telegram频道@pythonetc的提示和技巧，2019年9月</a></li>
<li><a href="../zh-CN470109/index.html">@Pythonetc 2019年9月</a></li>
<li><a href="../zh-CN470115/index.html">您的移动导航器使驾驶变得困难</a></li>
<li><a href="../zh-CN470121/index.html">公司编程学校或如何进入IT</a></li>
<li><a href="../zh-CN470123/index.html">Yandex.Money金融陷阱</a></li>
<li><a href="../zh-CN470125/index.html">不要严格判断别人的代码</a></li>
<li><a href="../zh-CN470127/index.html">作曲家有很长的短期记忆</a></li>
<li><a href="../zh-CN470129/index.html">声明式内存管理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>