<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¢ ü•ï üë©üèæ‚Äçüé® Wir programmieren den Schalter durch Passage. MicroPython auf esp8266 (sonoff) mit OTA. Teil 1 üêÉ üëµüèæ ‚ùÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. 


 W√§hrend des Reparaturprozesses entstand die Aufgabe, einen Durchgangsschalter herzustellen. Nat√ºrlich wollte ich es auf einfachste ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir programmieren den Schalter durch Passage. MicroPython auf esp8266 (sonoff) mit OTA. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438624/"><p>  Hallo an alle. </p><br><p>  W√§hrend des Reparaturprozesses entstand die Aufgabe, einen Durchgangsschalter herzustellen.  Nat√ºrlich wollte ich es auf einfachste und bequemste Weise tun und grundlegende Steuerfunktionen vom Telefon aus hinzuf√ºgen.  Ich entschied mich f√ºr die einfachste und bequemste Technologie (nat√ºrlich meiner Meinung nach) - MicroPython - und begann damit.  Ich habe das fertige Board auf esp8266 genommen und daf√ºr eine Stunde Freizeit eingeplant.  Da dies jedoch bei nicht sehr beliebten und nicht eingef√ºhrten Projekten der Fall ist, zog sich die Aufgabe etwas hin. </p><br><p>  Wie sich herausstellte, funktioniert das Design, das ich am bequemsten fand, √ºberhaupt nicht.  Ich musste einige Zeit damit verbringen, dies zu analysieren, au√üerdem beschloss ich, den gesamten Prozess ausreichend detailliert zu beschreiben.  Das Volumen des Artikels nahm rasant zu, und so beschloss ich, ihn in Teile zu teilen und alle Details zu verwerfen, die meiner Meinung nach unn√∂tig sind. </p><a name="habracut"></a><br><p>  Der erste Teil besteht aus drei Teilen: </p><br><ol><li>  Theoretische √úberlegungen zur Auswahl des einfachsten Mediums f√ºr die Entwicklung eines Durchgangsschalters, </li><li>  Praktischer Start der ausgew√§hlten Basis-Firmware auf den ausgew√§hlten Ger√§ten, Fallstricke, </li><li>  Firmware-Entwicklung </li></ol><br><h1>  Auswahl der einfachsten Entwicklungsumgebung </h1><br><p>  F√ºr ein Smart Home wie ‚ÄûMachen Sie es sich selbst, wenn Sie eine Minute Freizeit haben‚Äú bietet die Liste der obligatorischen Ausr√ºstungsanforderungen neben den klassischen Elementen (z. B. Stabilit√§t) auch eine einfache Entwicklung, Installation und Unterst√ºtzung.  Die Ger√§te m√ºssen die erforderlichen Sensoren oder Steuerger√§te problemlos an sie anschlie√üen k√∂nnen.  Dass es bequeme und einfache M√∂glichkeiten gab, mit dem gesamten System zu kommunizieren.  Es muss sichergestellt werden, dass das Schreiben von Firmware auf dieses Ger√§t einfach ist, wobei zu ber√ºcksichtigen ist, dass sich das Ger√§t dort befindet, wo es schwer zu erreichen ist.  Und nat√ºrlich ist die einfache Entwicklung besonders f√ºr Heimwerker von entscheidender Bedeutung, wenn beispielsweise 2 Jahre nach dem Arbeiten ohne Ausf√§lle des gesamten Systems gearbeitet wird <br>  pl√∂tzlich m√∂chte ich einige Anpassungen an der Firmware hinzuf√ºgen.  Um diese Korrekturen vornehmen zu k√∂nnen, m√ºssen Sie sich daran erinnern, wie dieses System funktioniert. Dies kann manchmal l√§nger dauern als die Anpassung selbst. </p><br><p>  Stellen Sie sich ein banales Beispiel vor: Sie m√ºssen einen einfachen Durchgangsschalter mit der M√∂glichkeit erstellen, ihn zu steuern, auch von einem PC aus.  In letzter Zeit war diese Aufgabe ziemlich kompliziert, es war notwendig, eine Art Mikrocontroller zu nehmen (die beliebtesten waren avr oder pic), und um Firmware zu schreiben, muss man in der Regel die Dokumentation dazu lesen.  Wenn Sie alles sofort erledigen m√∂chten, m√ºssen Sie die Karte trennen, auf der sich AC / DC, ein Mikrocontroller und eine Kommunikationsschnittstelle befinden.  L√∂ten Sie nach der LUT (oder Bestellung von Leiterplatten) alles, kaufen Sie einen Programmierer und eine Flash-Firmware.  Und dann, nach 2-3 Jahren, wenn n√∂tig, um etwas zu reparieren, suchen Sie nach allen Ger√§ten und lernen Sie alles von Grund auf neu ... </p><br><p>  Um diesen Prozess zu vereinfachen, wurden vorgefertigte L√∂sungen auf den Markt gebracht.  Die erfolgreichste L√∂sung ist Arduino.  Diese L√∂sung wird von der IDE bereitgestellt, dem Bootloader mit der Update-Funktion, mit der Sie ohne Programmierer ausschlie√ülich √ºber die Standardschnittstelle mit dem Ger√§t arbeiten k√∂nnen.  Es macht es m√∂glich, Firmware nur mit zu machen <br>  ein sehr oberfl√§chliches Verst√§ndnis daf√ºr, wie dort alles angeordnet ist.  Ein Satz externer Module erm√∂glicht den Anschluss von Ger√§ten ohne L√∂tkolben.  Um √Ñnderungen vornehmen zu k√∂nnen, m√ºssen Sie die Arduino-Software installieren und die Firmware irgendwo speichern. </p><br><p>  Unser Durchgangsschalter wird gro√ü genug sein und ein Arduino-Board + AC / DC + Relaismodul enthalten.  Und wenn Sie Anpassungen vornehmen m√ºssen, m√ºssen Sie sich schmerzhaft merken, wo der Code liegt, und die Arduino-Software erneut installieren. </p><br><p>  Um sich die Notwendigkeit zu ersparen, den Quellcode zu kompilieren (d. H. Zus√§tzliche Software zu installieren und zu speichern), scheint die logischste L√∂sung darin zu bestehen, Interpreter zu verwenden oder den Code direkt auf dem Mikrocontroller selbst zu kompilieren.  Gl√ºcklicherweise sind jetzt Projekte erschienen, die dies erm√∂glichen.  Zum Beispiel NodeMCU, der Lua-Sprachinterpreter f√ºr den esp8266-Mikrocontroller: Die Firmware selbst unterst√ºtzt das Dateisystem, mit dem Sie Skripte auf das / vom Ger√§t laden / lesen k√∂nnen.  Ein weiteres ziemlich ernstes Projekt ist Micropython, eine abgespeckte Version von Python, die speziell auf Mikrocontroller zugeschnitten ist.  Es wird diskutiert. </p><br><p>  MicroPython ist eine Implementierung einer der beliebtesten Python-Programmiersprachen.  Es unterst√ºtzt eine gro√üe Anzahl von Architekturen und SoC (Bare-Arm, CC3200, esp8266, esp32, nRF, pic16bit, stm32).  Das Projekt entwickelt sich aktiv und verf√ºgt √ºber eine Vielzahl zus√§tzlicher Module. </p><br><p>  Der Mikroprozessor esp8266 eignet sich sehr gut als Hardware-Teil, da auf ihm aufgebaute preisg√ºnstige WLAN-Switch-Module auf dem Markt verkauft werden.  Sie enthalten alles, was wir brauchen: AC / DC, einen Mikrocontroller mit integrierter Kommunikationsschnittstelle (WLAN).  Erh√§ltlich unter dem Markennamen Sonoff.  Die esp8266-Mikroprozessoren enthalten keinen Speicher, sie sind separat verl√∂tet und k√∂nnen eine andere Gr√∂√üe haben.  F√ºr Sonoff Basic setzen sie 1Mb Module. </p><br><h1>  Starten der Basis-Firmware auf esp8266.  Sonoff Basic. </h1><br><p>  Ohne Fallstricke w√§re es m√∂glich, sofort mit der Programmierung in Python fortzufahren.  Leider gibt es eine Reihe von Problemen, die gel√∂st werden m√ºssen. Um die Firmware zu programmieren und zu √§ndern, war dies sehr einfach und unkompliziert.  Nat√ºrlich sind wir daran interessiert, dies √ºber WLAN zu tun, ohne zus√§tzliche Ger√§te au√üer einem Laptop zu verwenden. </p><br><p>  Die erste Gefahr ist nat√ºrlich die grundlegende Firmware, die auf Ihrem Board aufgezeichnet ist.  Wenn Sie ein Debug-Board gekauft haben, finden Sie h√∂chstwahrscheinlich NodeMCU darauf, wenn Sonoff Basic, dann propriet√§re Firmware.  Um dieses Board f√ºr sich selbst vorzubereiten, m√ºssen Sie dort die erforderliche Firmware notieren.  Bei einigen Mikrocontrollern ist der Kauf erforderlich <br>  Als spezieller Programmierer, in unserem Fall hatten wir Gl√ºck, brauchen Sie nur einen USB &lt;-&gt; UART-Konverter.  Wenn Sie mit Mikrocontrollern arbeiten, ist dies mehr als einmal n√ºtzlich, und der Preis liegt normalerweise im Bereich von 3 US-Dollar. </p><br><p>  Es gibt keinen Kamm f√ºr Sonoff Basic, mit dem Sie eine Verbindung √ºber UART herstellen k√∂nnen, und wir ben√∂tigen diesen, um das Ger√§t zu programmieren.  Um das Ger√§t einfach zu programmieren, ist es nicht erforderlich, den L√∂tkolben in die Hand zu nehmen. Es reicht aus, die Kontakte zu lehnen und die Firmware aufzuschreiben.  Da die weitere Arbeit √ºber WLAN erfolgen wird, werden wir diese Kontakte nicht mehr ben√∂tigen.  Aber wir implementieren einen Schalter durch Passage, was bedeutet, dass wir gel√∂tet werden m√ºssen, <br>  mindestens drei Beine. </p><br><p>  F√ºr Sonoff Basic gibt es nur 1 freien GPIO-Anschluss und 2 RX, TX-Anschl√ºsse.  In Anbetracht der Tatsache, dass wir RX, TX selbst einmal ben√∂tigen (um die Firmware zu flashen), k√∂nnen sie in Zukunft dank esp8266 auf GPIO umprogrammiert werden.  In diesem Fall m√ºssen wir das Debuggen √ºber UART abbrechen. Gl√ºcklicherweise haben wir dies bereits geplant, da das Debuggen √ºber WLAN aus praktischen Gr√ºnden viel einfacher ist. </p><br><p>  Da sich die Version von MicroPython dabei √§ndern kann, m√∂chten wir die Update-Methode √ºber WLAN debuggen.  OTA kommt zur Rettung.  OTA ist eine Firmware, mit der Sie ein Ger√§t neu programmieren k√∂nnen.  Es funktioniert ganz einfach.  Nach dem Einschalten des Ger√§tes bestimmt die Firmware, ob es neu programmiert werden muss, startet ggf. ein Special <br>  Wenn nicht, startet der WLAN-Updater die Benutzer-Firmware.  Die Implementierung kann unterschiedlich sein, die Firmware kann sich selbst √ºberschreiben oder in einen freien Speicherbereich schreiben.  Sie k√∂nnen auch festlegen, ob das √úberspielprogramm √ºberhaupt auf unterschiedliche Weise ausgef√ºhrt werden soll.  Betrachten Sie beispielsweise das cxumma der benutzerdefinierten Firmware, wenn diese nicht konvergiert. <br>  dann gewaltsam zum blinken gehen.  Sie k√∂nnen Daten vom GPIO lesen oder Informationen √ºber die Notwendigkeit schreiben, das Update an einer anderen Stelle zu starten. </p><br><p>  Als Updater verweist das MicroPython-Projekt auf das yaota8266-Projekt.  Yaota8266 behauptet, das Ger√§t zu flashen und jedes Paket zu signieren.  Es ist zu beachten, dass der √∂ffentliche Schl√ºssel in die Firmware selbst eingebettet ist, weshalb es keinen Sinn macht, die bereits zusammengestellte Firmware hochzuladen, da Sie Ihren Schl√ºssel dort n√§hen m√ºssen. <br>  Es gibt keine Funktion zum √Ñndern des privaten Schl√ºssels im zusammengestellten Image. In unserem Fall ist es daher einfacher, die Firmware selbst zusammenzustellen.  Ein interessantes Merkmal ist, dass die Signatur√ºberpr√ºfungsfunktion im Code auskommentiert ist, d. H.  Tats√§chlich bekommen wir Schwierigkeiten ohne Sicherheitsgewinne.  Die Basisversion von yaota8266 wird nicht, <br>  Gl√ºcklicherweise gibt es Gabeln auf Github, die dieses Problem l√∂sen, und sie bieten die M√∂glichkeit, anhand des Schreibens in den RTC-Bereich zu bestimmen, ob das Flashen durchgef√ºhrt werden soll, wodurch MicroPython in den Bootloader-Modus geschaltet werden kann. </p><br><p>  Auch nach Einbeziehung aller Korrekturen schreibt unsere OTA-Firmware fehlerhaft, funktioniert jedoch erfolgreich auf NodeMCU-Debug-Boards.  Dies ist auf Zeit√ºberschreitungen zur√ºckzuf√ºhren.  Beim Aktualisieren vom Host-Computer werden UDP-Pakete gesendet und eine Antwort wird erwartet, wenn die Aufzeichnung in Flash l√§nger als gew√∂hnlich dauert, eine Zeit√ºberschreitung auftritt und das Paket erneut gesendet wird.  Der Vorteil ist leicht zu beheben, <br>  Erh√∂hen Sie einfach die Zeit√ºberschreitungen im ota-Client-Code. </p><br><p>  Das OTA + MicroPython-Bundle auf Sonoff weist ebenfalls interessante Kuriosit√§ten auf.  Eine davon h√§ngt mit der Tatsache zusammen, dass die Standardfunktionen f√ºr die Arbeit mit SPI Flash in esp-sdk mit 4k-Bl√∂cken arbeiten und diese Blockgr√∂√üe f√ºr die Implementierung des FAT-Dateisystems ausgew√§hlt wurde.  Aufgrund der Tatsache, dass SPI Flash nur 1 MB gro√ü ist, von denen ~ 300 KB OTA-Firmware und ~ 500 KB MicroPython-Firmware sind, verbleiben weniger als 200 KB f√ºr das Dateisystem, d. H.  weniger als 50 Bl√∂cke.  Die ausgew√§hlte Bibliothek, die fatfs implementiert, kann jedoch keine FS erstellen, wenn weniger als 50 Bl√∂cke vorhanden sind. Es gibt verschiedene M√∂glichkeiten, das Problem zu l√∂sen: Reduzieren Sie die Blockgr√∂√üe (mit FAT k√∂nnen Sie 512 festlegen), korrigieren Sie die FatFs-Bibliothek, verwenden Sie SPI FS (in der Hoffnung, dass es keine solchen Kuriosit√§ten gibt).  Ich ging den Weg, den Block auf 512 zu reduzieren. </p><br><p>  Mikrocontroller verwenden SPI-Flash - dies ist NOR- und / oder NAND-Speicher.  Das Bemerkenswerte an diesem Speicher ist, dass es kein Konzept gibt, "irgendwelche Daten zu schreiben".  Sie k√∂nnen nur den Wert zur√ºcksetzen (bei 0xff) oder die gew√ºnschten Bits auf "0" setzen.  SPI Flash ist normalerweise ein NOR-Speicher. Es hat die Funktion, jedes Byte auf 0xff zur√ºckzusetzen, w√§hrend NAND nur durch Bl√∂cke zur√ºckgesetzt werden kann.  Das hei√üt,  Wenn die Mindestgr√∂√üe des R√ºcksetzblocks 4 KB betr√§gt, um zu schreiben <br>  1 Byte Speicher, es ist notwendig, den gesamten Block zu lesen, ihn auf 0xFF zur√ºckzusetzen und dann den Block zu schreiben, indem das gew√ºnschte Byte auf den gew√ºnschten Wert gesetzt wird.  Hersteller von SPI Flash haben ungef√§hr die gleichen APIs f√ºr die Arbeit, aber wie die Praxis gezeigt hat, kann der Befehl zum Schreiben eines Bytes SPI Flash unterschiedlich sein.  Irgendwo wird es automatisch zur√ºckgesetzt, bevor in 0xFF geschrieben wird, irgendwo nicht. </p><br><p>  Wenn Sie den FAT-Abschnitt auf 512 Byte √§ndern, besteht die M√∂glichkeit, dass ein System defekt ist, wenn ein bestimmter SPI-Flash das automatische Zur√ºcksetzen von Bytes bei der Aufnahme nicht unterst√ºtzt.  Und es war eine solche Erinnerung, die mir in Sonoff Basic begegnet ist.  Ger√ºchten zufolge haben sie dort fr√ºher Winbond 25q80bv installiert, jetzt jedoch PUYA 25q80h mit einem Mindestreinigungsblock von 256 Bytes.  L√∂sung scheint <br>  Einfach, Sie m√ºssen nur zwei Seiten l√∂schen, auf denen es geschrieben wird, bevor Sie den FAT-Block schreiben. Die Implementierung wird jedoch durch die Tatsache erschwert, dass sdk-esp nur das L√∂schen in 4k-Bl√∂cken unterst√ºtzt.  Da das Schreiben an die FAT f√ºr unseren Wechsel sehr selten sein wird, <br>  Nur wenn Sie die Firmware-Skripte aktualisieren, k√∂nnen Sie den 512-Byte-Block in 4-KB-Bl√∂cken aktualisieren.  Die Dokumentation f√ºr diesen Speicher besagt, dass der Speicher 100.000 Umschreibzyklen standhalten kann, d.h.  Eine √§hnliche Umgehung des Problems verringert diesen Wert um das Vierfache, d.h.  bis zu 25.000. </p><br><p>  MicroPython verf√ºgt standardm√§√üig √ºber eine Konsole, die REPL hei√üt und √ºber den COM-Port funktioniert.  Wir sind mit diesem Zustand nicht sehr zufrieden, da wir √ºber WLAN mit dem Ger√§t kommunizieren m√∂chten.  Gl√ºcklicherweise ist WebRepl in MicroPython ebenfalls Standard, startet jedoch nicht automatisch.  Sie k√∂nnen autorun in boot.py registrieren, aber ich habe beschlossen, es direkt von _boot.py, der Systemdatei, auszuf√ºhren. Es ist in die Firmware-Datei selbst eingen√§ht. </p><br><p>  Nach dem ersten Start erstellt unsere Firmware ein Dateisystem, startet webrepl und erstellt einen Zugriffspunkt.  Sie k√∂nnen eine Verbindung herstellen und die Parameter f√ºr die Verbindung mit Ihrem lokalen Netzwerk vorschreiben oder wie ich das Netzwerk √ºber den COM-Port konfigurieren. Danach sollte nur noch WLAN verwendet werden. </p><br><p>  F√ºr Testarbeiten k√∂nnen Sie den in Javascript geschriebenen Webrepl-Client verwenden.  Der Client kann in einem Browser auf der entsprechenden Seite des Projekts gestartet werden.  Eine weitere Option ist die Verwendung des mpfshell-Projekts. Es bietet bequemere Funktionen f√ºr die Arbeit mit dem Ger√§t. </p><br><p>  Nachdem Sie alle diese Fallstricke √ºberwunden haben, k√∂nnen Sie direkt mit der Programmierung des Schalters fortfahren. </p><br><h1>  Firmware-Entwicklung </h1><br><p>  Um die Firmware zu entwickeln, m√ºssen wir eine ungef√§hre Vorstellung davon haben, wie GPIO funktioniert.  Im Allgemeinen kann dies rein intuitiv verstanden werden: </p><br><ol><li>  Wenn wir den Ausgabemodus (OUT) einstellen, erzeugt das Bein entweder GND oder Vcc. </li><li>  Wenn wir den Eingabemodus (IN) einstellen, baumelt das Bein "in der Luft". In diesem Fall kann der Mikrocontroller alles ausgeben </li><li>  Damit der Mikrocontroller nichts abgibt, kann das Bein mit dem eingebauten Mikrocontroller auf den gew√ºnschten Wert gezogen werden <br>  Pull-up-Widerst√§nde PULL_UP oder PULL_DOWN. </li></ol><br><p>  Sie m√ºssen auch eine Vorstellung davon haben, was Interrupts sind: In unserem Fall ist dies der Code, der ausgef√ºhrt werden muss, wenn ein Ereignis auftritt: Eine Taste wurde gedr√ºckt / losgelassen oder es kam eine Nachricht vom lokalen Netzwerk, dass das Ger√§t aus- / eingeschaltet werden soll. </p><br><p>  Lassen Sie uns zun√§chst ein einfaches Switch-Programm (kein Pass-Through-Programm) in Python schreiben. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> machine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pin <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SW</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, portin, portout)</span></span></span><span class="hljs-function">:</span></span> self.pin = Pin(portin , Pin.PULL_UP) <span class="hljs-comment"><span class="hljs-comment">#  self.pout = Pin(portout, Pin.OUT) #  #  self._auto(),       self.pin.irq(trigger=Pin.IRQ_RISING|Pin.IRQ_FALLING, handler=self._auto) self.value = 0 def _auto(self, _=0): if self.value: res = self.pin.value() else: res = not self.pin.value() self.pout.value(res) def change(self, val=2): """   0, ,  1, ,  2  """ if val == 2: self.value = not self.value else: self.value = val self._auto() sw = SW(14, 12)</span></span></code> </pre> <br><p>  Ich habe diese switch.py-Datei benannt und befohlen, sie in boot.py auszuf√ºhren: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> switch <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sw</code> </pre> <br><p>  Nach dem Starten der Firmware habe ich ein sw-Objekt erhalten. Wenn ich sw.change () ausf√ºhre, erfolgt ein Programmwechsel <br>  in eine andere Position wechseln.  Wenn ein freier Pin im Mikrocontroller mit Vcc kurzgeschlossen ist <br>  Das Relais schaltet sich ein bzw. aus. </p><br><p>  Der n√§chste Schritt ist der Start des MQTT-Clients und die M√∂glichkeit, den Switch vom Telefon aus zu wechseln. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438624/">https://habr.com/ru/post/de438624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438610/index.html">Responsive Figma-Vorlagen: Erstellen einer flexiblen Designkomponente f√ºr die mobile iOS-Navigation</a></li>
<li><a href="../de438614/index.html">Was ist eine hochwertige Leerlaufanimation? Entwickler teilen ihre Lieblingsbeispiele.</a></li>
<li><a href="../de438618/index.html">Herstellung eines DIY-Textlaserprojektors</a></li>
<li><a href="../de438620/index.html">Mein Weg als unerfahrener Spieleentwickler</a></li>
<li><a href="../de438622/index.html">Bonsai: Familien-Wiki-Engine</a></li>
<li><a href="../de438626/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 284 (28. Januar - 3. Februar)</a></li>
<li><a href="../de438628/index.html">Benachrichtigung √ºber den Status der √Ñnderung der SharedState-Komponente</a></li>
<li><a href="../de438630/index.html">Google+ Sic Transit Gloria Mundi ...</a></li>
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In B√ºros ist es entweder zu hei√ü oder zu kalt: Gibt es eine bessere M√∂glichkeit, die Temperatur anzupassen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>