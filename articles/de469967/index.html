<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 🥀 🚚 Datenstrukturen für die Grafikspeicherung: eine Überprüfung bestehender und zwei "fast neuer" 👩🏽‍🔧 🥂 👨🏾‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. 

 In dieser Notiz habe ich beschlossen, die wichtigsten Datenstrukturen aufzulisten, die zum Speichern von Graphen in der Informatik v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen für die Grafikspeicherung: eine Überprüfung bestehender und zwei "fast neuer"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/">  Hallo an alle. <br><br>  In dieser Notiz habe ich beschlossen, die wichtigsten Datenstrukturen aufzulisten, die zum Speichern von Graphen in der Informatik verwendet werden, und auch über einige andere Strukturen zu sprechen, die sich irgendwie aus mir herauskristallisiert haben. <br><br>  Also fangen wir an.  Aber nicht von Anfang an - ich denke, was ein Graph ist und was er ist (orientiert, nicht orientiert, gewichtet, ungewichtet, mit mehreren Kanten und Schleifen oder ohne sie), wissen wir alle bereits. <br><br>  Also lass uns gehen.  Welche Möglichkeiten haben wir für Datenstrukturen zur "Graphspeicherung"? <br><a name="habracut"></a><br><h2>  1. Matrixdatenstrukturen </h2><br>  1.1 <b>Adjazenzmatrix.</b>  Die Adjazenzmatrix ist eine Matrix, in der die Zeilen- und Spaltenüberschriften den Nummern der Eckpunkte des Graphen entsprechen und der Wert jedes seiner Elemente a (i, j) durch das Vorhandensein oder Fehlen von Kanten zwischen den Eckpunkten i und j bestimmt wird (es ist klar, dass eine solche Matrix für einen ungerichteten Graphen gilt wird symmetrisch sein, gut, oder Sie können zustimmen, dass wir alle Werte nur über der Hauptdiagonale speichern).  Für ungewichtete Graphen kann a (i, j) durch die Anzahl der Kanten von i bis j angegeben werden (wenn es keine solche Kante gibt, dann ist a (i, j) = 0), und für gewichtete durch das Gewicht (Gesamtgewicht) der genannten Kanten. <br><br>  1.2 <b>Die Inzidenzmatrix.</b>  In diesem Fall wird unser Diagramm auch in einer Tabelle gespeichert, in der in der Regel die Zeilennummern den Nummern seiner Eckpunkte und die Spaltennummern vornummerierten Kanten entsprechen.  Wenn der Scheitelpunkt und die Kante aufeinander treffen, wird ein Wert ungleich Null in die entsprechende Zelle geschrieben (für ungerichtete Diagramme wird 1 für den Fall des Scheitelpunkts und der Kante geschrieben, für orientierte Diagramme "1", wenn die Kante den Scheitelpunkt "verlässt" und "-1", wenn dies der Fall ist es "tritt ein" (es ist ziemlich leicht zu merken, da das Minuszeichen auch in der Zahl "-1" "enthalten" zu sein scheint)).  Bei gewichteten Diagrammen können Sie anstelle von 1 und -1 auch das Gesamtgewicht der Kante angeben. <br><br><h2>  2. Aufzählungsdatenstrukturen </h2><br>  2.1 <b>Adjazenzliste.</b>  Nun, alles scheint einfach zu sein.  Im Allgemeinen kann jeder Scheitelpunkt eines Graphen einer beliebigen Aufzählungsstruktur (Liste, Vektor, Array, ...) zugeordnet werden, in der die Nummern aller Scheitelpunkte neben diesem gespeichert werden.  Bei orientierten Graphen werden nur Scheitelpunkte aufgelistet, bei denen es eine "gerichtete" Kante vom Scheitelpunktattribut gibt.  Bei gewichteten Diagrammen ist die Implementierung komplexer. <br><br>  2.2 <b>Liste der Rippen.</b>  Ziemlich beliebte Datenstruktur.  Die Liste der Kanten ist, wie Captain Evidence uns sagt, eine Liste der Kanten des Diagramms, von denen jede durch einen anfänglichen Scheitelpunkt, einen Endscheitelpunkt, definiert ist (für ungerichtete Diagramme ist die Reihenfolge hier nicht wichtig, obwohl verschiedene Regeln für die Vereinheitlichung verwendet werden können, z. B. Scheitelpunkte in der Reihenfolge angeben aufsteigend) und Gewicht (nur für gewichtete Diagramme). <br><br>  Informationen zu den oben aufgeführten Matrixlisten finden Sie (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) ausführlicher. <br><br>  2.3 <b>Adjazenzarray.</b>  Nicht die häufigste Struktur.  Im Kern handelt es sich um eine Form des "Packens" von Adjazenzlisten in eine Aufzählungsstruktur (Array, Vektor).  Die ersten n (nach Anzahl der Graphenscheitelpunkte) Elemente eines solchen Arrays enthalten Startindizes desselben Arrays, ab denen alle angrenzenden Scheitelpunkte in einer Reihe darin geschrieben werden. <br><br>  Hier fand ich die für mich verständlichste Erklärung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ejuo.livejournal.com/4518.html</a> <br><br><h2>  3. Adjazenzvektor und assoziatives Adjazenzarray </h2><br>  Es kam vor, dass der Autor dieser Zeilen, der kein professioneller Programmierer war, sondern sich regelmäßig mit Graphen befasste, sich am häufigsten mit Kantenlisten befasste.  In der Tat ist es praktisch, wenn der Graph mehrere Schleifen und Kanten hat.  Und jetzt, bei der Entwicklung der klassischen Kantenlisten, schlage ich vor, auf ihre „Entwicklung / Verzweigung / Modifikation / Mutation“ zu achten, nämlich auf den Adjazenzvektor und das assoziative Array der Adjazenz. <br><br>  <b>3.1 Adjazenzvektor</b> <br><br>  <i>Fall (A1): Ungewichtete Anzahl</i> <br><br>  Wir werden den Adjazenzvektor für einen ungewichteten Graphen eine geordnete Menge einer geraden Anzahl von ganzen Zahlen (a [2i], a [2i + 1], ..., wobei i mit c 0 nummeriert ist) bezeichnen, in der jedes Zahlenpaar a [2i], a [2i +1] definiert die Kante des Graphen zwischen den Eckpunkten a [2i] und a [2i + 1]. <br>  Dieses Aufnahmeformat enthält keine Informationen darüber, ob das Diagramm ausgerichtet ist (beide Optionen sind möglich).  Bei Verwendung des Digraphenformats wird angenommen, dass die Kante von a [2i] nach a [2i + 1] gerichtet ist.  Im Folgenden: Bei ungerichteten Diagrammen können bei Bedarf die Anforderungen für die Reihenfolge der Aufzeichnung von Scheitelpunkten angewendet werden (z. B. so, dass der Scheitelpunkt mit dem niedrigeren Wert der ihm zugewiesenen Zahl an erster Stelle steht). <br><br>  In C ++ ist es ratsam, den Adjazenzvektor mit std :: vector anzugeben, aus dem der Name dieser Datenstruktur ausgewählt wurde. <br><br>  <i>Fall (a2): ungewichteter Graph, ganzzahlige Kantengewichte</i> <br><br>  In Analogie zu Fall (a1) nennen wir den Adjazenzvektor für einen gewichteten Graphen mit ganzzahligen Kantengewichten eine geordnete Menge (dynamisches Array) von Zahlen (a [3i], a [3i + 1], a [3i + 2], ..., wobei i ist mit c 0) nummeriert, wobei jedes "Triplett" der Zahlen a [3i], a [3i + 1], a [3i + 2] die Kante des Graphen zwischen den Eckpunkten unter den Zahlen a [3i] bzw. a [3i + 1] definiert und Der Wert von a [3i + 2] ist das Gewicht dieser Kante.  Ein solcher Graph kann auch entweder orientiert sein oder nicht. <br><br>  <i>Fall (b): ungewichteter Graph, nicht ganzzahlige Kantengewichte</i> <br><br>  Da die heterogenen Elemente nicht in einem Array (Vektor) gespeichert werden können, ist beispielsweise die folgende Implementierung möglich.  Der Graph wird in einem Vektorpaar gespeichert, wobei der erste Vektor der Adjazenzvektor des Graphen ohne Angabe von Gewichten ist und der zweite Vektor die entsprechenden Gewichte enthält (eine mögliche Implementierung für C ++ ist: std :: pair &lt;std :: vector, std :: vector&gt;).  Somit ist für eine Kante, die durch ein Paar von Eckpunkten unter den Indizes 2i, 2i + 1 des ersten Vektors definiert ist, das Gewicht gleich dem Element unter dem Index i des zweiten Vektors. <br><br>  <i>Nun, warum ist das notwendig?</i> <br><br>  Für den Autor dieser Zeilen zur Lösung einer Reihe von Problemen schien dies sehr nützlich zu sein.  Aus formaler Sicht wird es solche Vorteile geben: <br><br><ul><li>  Der Adjazenzvektor ist wie jede andere "Aufzählungs" -Struktur kompakt genug, benötigt weniger Speicher als die Adjazenzmatrix (für spärliche Graphen) und ist relativ einfach zu implementieren. </li><li>  Die Eckpunkte des Graphen können grundsätzlich mit negativen Zahlen markiert werden.  Plötzlich ist auch eine solche „Perversion“ erforderlich. </li><li>  Diagramme können mehrere Kanten und mehrere Schleifen mit unterschiedlichen Gewichten (positiv, negativ, sogar null) enthalten.  Hier gibt es keine Einschränkungen. </li><li>  Und Rippen können unterschiedliche Eigenschaften zugewiesen werden - dazu siehe Absatz 4. </li></ul><br>  Ich muss jedoch zugeben, dass dieser „Listot“ keinen schnellen Zugang zur Rippe bedeutet.  Und hier beeilt sich das assoziative Adjazenz-Array, um zu helfen, worüber - unten. <br><br>  <b>3.2 Assoziatives Adjazenzarray</b> <br><br>  Wenn für uns der Zugriff auf eine bestimmte Kante, deren Gewicht und andere Eigenschaften von entscheidender Bedeutung ist und die Speicheranforderungen die Verwendung einer Adjazenzmatrix nicht zulassen, sollten wir uns überlegen, wie Sie den Adjazenzvektor ändern können, um dieses Problem zu lösen.  Der Schlüssel ist also die Kante des Graphen, die als geordnetes Paar von ganzen Zahlen definiert werden kann.  Wie sieht es aus?  Könnte es ein Schlüssel in einem assoziativen Array sein?  Und wenn ja, warum setzen wir das nicht um?  Lassen Sie uns ein solches assoziatives Array haben, in dem jeder Schlüssel - ein geordnetes Paar von Ganzzahlen - einem Wert zugeordnet wird - einer Ganzzahl oder einer reellen Zahl, die das Gewicht der Kante angibt.  In C ++ ist es ratsam, diese Struktur auf der Basis des std :: map-Containers zu implementieren (std :: map &lt;std :: pair &lt;int, int&gt;, int&gt; oder std :: map &lt;std :: pair &lt;int, int&gt;, double&gt;). oder std :: multimap, wenn mehrere Kanten angenommen werden.  Nun, und hier haben wir eine Struktur zum Speichern von Graphen, die weniger Speicher benötigt als "Matrix" -Strukturen, Graphen mit mehreren Schleifen und Kanten definieren können und auch ohne strenge Anforderungen an die Nicht-Negativität von Scheitelpunktzahlen (ich weiß nicht, wer sie benötigt). aber immer noch). <br><br><h2>  4. Datenstrukturen zumindest "fluten", aber etwas fehlt </h2><br>  Und die Wahrheit ist: Wenn wir eine Reihe von Problemen lösen, müssen wir möglicherweise den Rändern des Diagramms einige Attribute zuweisen und sie entsprechend speichern.  Wenn es möglich ist, diese Merkmale eindeutig auf ganze Zahlen zu reduzieren, ist es möglich, solche "Graphen mit zusätzlichen Merkmalen" unter Verwendung erweiterter Versionen des Adjazenzvektors und des assoziativen Adjazenzarrays zu speichern. <br><br>  Lassen Sie uns also ein ungewichtetes Diagramm haben, für das für jede Kante beispielsweise zwei zusätzliche Zeichen gespeichert werden müssen, die durch Ganzzahlen angegeben werden.  In diesem Fall ist es möglich, seinen Adjazenzvektor als eine geordnete Menge von nicht "Paaren", sondern "Quartetten" von ganzen Zahlen (a [2i], a [2i + 1], a [2i + 2], a [2i + 3] anzugeben. .), wobei a [2i + 2] und a [2i + 3] die Merkmale der entsprechenden Kante bestimmen.  Bei einem Diagramm mit ganzzahligen Kantengewichten ist die Reihenfolge im Allgemeinen ähnlich (der einzige Unterschied besteht darin, dass die Vorzeichen dem Kantengewicht folgen und durch die Elemente a [2i + 3] und a [2i + 4] gegeben sind und die Kante selbst angegeben wird nicht 4, sondern 5 bestellte Nummern).  Bei einem Diagramm mit nicht ganzzahligen Kantengewichten können die Attribute in die ungewichtete Komponente geschrieben werden. <br><br>  Wenn Sie ein assoziatives Adjazenzarray für Diagramme mit ganzzahligen Kantengewichten verwenden, können Sie nicht eine einzelne Zahl, sondern ein Array (einen Vektor) von Zahlen angeben, das neben dem Kantengewicht alle anderen erforderlichen Attribute angibt.  Gleichzeitig besteht die Unannehmlichkeit für den Fall von nicht ganzzahligen Gewichten darin, dass ein Zeichen mit einer Gleitkommazahl angegeben werden muss (ja, dies ist eine Unannehmlichkeit, aber wenn es nicht so viele solcher Zeichen gibt und Sie sie nicht zu "knifflig" doppelt setzen, kann es nichts sein). .  In C ++ können erweiterte assoziative Adjazenz-Arrays wie folgt definiert werden: std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector&gt; oder std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector, wobei der erste Wert in "vector-value-by-key" das Gewicht der Kante ist und dann die numerischen Bezeichnungen ihrer Merkmale gefunden werden. <br><br><h2>  Referenzen: </h2><br>  <i>Über Grafiken und Algorithmen im Allgemeinen:</i> <br><br>  1. Cormen, Thomas H., Leiserson, Charles I., Rivest, Ronald L., Stein, Clifford.  Algorithmen: Konstruktion und Analyse, 2. Auflage: Per.  aus dem Englischen  - M.: Williams Verlag, 2011. <br>  2. Harari Frank.  Graphentheorie.  M.: Mir, 1973. <br>  <i>Der Bericht des Autors über denselben Vektor und dieselbe assoziative Nachbarschaft:</i> <br>  3. Chernoukhov S.A.  Adjazenzvektor und assoziatives Adjazenzarray als Mittel zur Darstellung und Speicherung von Graphen / SA Chernouhov.  Adjazenzvektor und Adjazenzkarte als Datenstrukturen zur Darstellung eines Graphen // Sammlung von Artikeln der Internationalen wissenschaftlichen und praktischen Konferenz "Probleme bei der Umsetzung der Ergebnisse innovativer Entwicklungen und Lösungswege" (Saratov, 14. September 2019).  - Sterlitamak: AMI, 2019, p.  65-69 <br>  <i>Nützliche Internetquellen zum Thema:</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.prog-cpp.ru/data-graph</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ejuo.livejournal.com/4518.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469967/">https://habr.com/ru/post/de469967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469949/index.html">Zum Geburtstag von Juri Knorozow: Wir lernen die Grundlagen des Maya-Schreibens</a></li>
<li><a href="../de469951/index.html">DIY Segmented Control, wie in iOS 13.0 und höher</a></li>
<li><a href="../de469955/index.html">Custdev, anspruchsvolle Dienstleistungen und die Kunst der Präsentation: Was wir den Teilnehmern des VTB-Beschleunigers beigebracht haben</a></li>
<li><a href="../de469961/index.html">Rust bei Microsoft (oder die Erstellung von Security Daemon Azure IoT Edge)</a></li>
<li><a href="../de469963/index.html">SonarQube und IntelliJ IDEA: Richtige Integration</a></li>
<li><a href="../de469975/index.html">Santiago Weg mit Laptop</a></li>
<li><a href="../de469977/index.html">Wie drei Klassenkameraden zu Facebook-Partnern wurden - Revealbot-Geschichte</a></li>
<li><a href="../de469979/index.html">Aufzeichnungen von Berichten aus dem zweiten iOS mitap Redmadrobot</a></li>
<li><a href="../de469981/index.html">Was ist im Chat-Bot?</a></li>
<li><a href="../de469983/index.html">Wie kann man eine Strategie entwickeln, um das Altern zu besiegen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>