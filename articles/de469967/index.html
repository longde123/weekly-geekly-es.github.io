<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòá ü•Ä üöö Datenstrukturen f√ºr die Grafikspeicherung: eine √úberpr√ºfung bestehender und zwei "fast neuer" üë©üèΩ‚Äçüîß ü•Ç üë®üèæ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. 

 In dieser Notiz habe ich beschlossen, die wichtigsten Datenstrukturen aufzulisten, die zum Speichern von Graphen in der Informatik v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen f√ºr die Grafikspeicherung: eine √úberpr√ºfung bestehender und zwei "fast neuer"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/">  Hallo an alle. <br><br>  In dieser Notiz habe ich beschlossen, die wichtigsten Datenstrukturen aufzulisten, die zum Speichern von Graphen in der Informatik verwendet werden, und auch √ºber einige andere Strukturen zu sprechen, die sich irgendwie aus mir herauskristallisiert haben. <br><br>  Also fangen wir an.  Aber nicht von Anfang an - ich denke, was ein Graph ist und was er ist (orientiert, nicht orientiert, gewichtet, ungewichtet, mit mehreren Kanten und Schleifen oder ohne sie), wissen wir alle bereits. <br><br>  Also lass uns gehen.  Welche M√∂glichkeiten haben wir f√ºr Datenstrukturen zur "Graphspeicherung"? <br><a name="habracut"></a><br><h2>  1. Matrixdatenstrukturen </h2><br>  1.1 <b>Adjazenzmatrix.</b>  Die Adjazenzmatrix ist eine Matrix, in der die Zeilen- und Spalten√ºberschriften den Nummern der Eckpunkte des Graphen entsprechen und der Wert jedes seiner Elemente a (i, j) durch das Vorhandensein oder Fehlen von Kanten zwischen den Eckpunkten i und j bestimmt wird (es ist klar, dass eine solche Matrix f√ºr einen ungerichteten Graphen gilt wird symmetrisch sein, gut, oder Sie k√∂nnen zustimmen, dass wir alle Werte nur √ºber der Hauptdiagonale speichern).  F√ºr ungewichtete Graphen kann a (i, j) durch die Anzahl der Kanten von i bis j angegeben werden (wenn es keine solche Kante gibt, dann ist a (i, j) = 0), und f√ºr gewichtete durch das Gewicht (Gesamtgewicht) der genannten Kanten. <br><br>  1.2 <b>Die Inzidenzmatrix.</b>  In diesem Fall wird unser Diagramm auch in einer Tabelle gespeichert, in der in der Regel die Zeilennummern den Nummern seiner Eckpunkte und die Spaltennummern vornummerierten Kanten entsprechen.  Wenn der Scheitelpunkt und die Kante aufeinander treffen, wird ein Wert ungleich Null in die entsprechende Zelle geschrieben (f√ºr ungerichtete Diagramme wird 1 f√ºr den Fall des Scheitelpunkts und der Kante geschrieben, f√ºr orientierte Diagramme "1", wenn die Kante den Scheitelpunkt "verl√§sst" und "-1", wenn dies der Fall ist es "tritt ein" (es ist ziemlich leicht zu merken, da das Minuszeichen auch in der Zahl "-1" "enthalten" zu sein scheint)).  Bei gewichteten Diagrammen k√∂nnen Sie anstelle von 1 und -1 auch das Gesamtgewicht der Kante angeben. <br><br><h2>  2. Aufz√§hlungsdatenstrukturen </h2><br>  2.1 <b>Adjazenzliste.</b>  Nun, alles scheint einfach zu sein.  Im Allgemeinen kann jeder Scheitelpunkt eines Graphen einer beliebigen Aufz√§hlungsstruktur (Liste, Vektor, Array, ...) zugeordnet werden, in der die Nummern aller Scheitelpunkte neben diesem gespeichert werden.  Bei orientierten Graphen werden nur Scheitelpunkte aufgelistet, bei denen es eine "gerichtete" Kante vom Scheitelpunktattribut gibt.  Bei gewichteten Diagrammen ist die Implementierung komplexer. <br><br>  2.2 <b>Liste der Rippen.</b>  Ziemlich beliebte Datenstruktur.  Die Liste der Kanten ist, wie Captain Evidence uns sagt, eine Liste der Kanten des Diagramms, von denen jede durch einen anf√§nglichen Scheitelpunkt, einen Endscheitelpunkt, definiert ist (f√ºr ungerichtete Diagramme ist die Reihenfolge hier nicht wichtig, obwohl verschiedene Regeln f√ºr die Vereinheitlichung verwendet werden k√∂nnen, z. B. Scheitelpunkte in der Reihenfolge angeben aufsteigend) und Gewicht (nur f√ºr gewichtete Diagramme). <br><br>  Informationen zu den oben aufgef√ºhrten Matrixlisten finden Sie (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) ausf√ºhrlicher. <br><br>  2.3 <b>Adjazenzarray.</b>  Nicht die h√§ufigste Struktur.  Im Kern handelt es sich um eine Form des "Packens" von Adjazenzlisten in eine Aufz√§hlungsstruktur (Array, Vektor).  Die ersten n (nach Anzahl der Graphenscheitelpunkte) Elemente eines solchen Arrays enthalten Startindizes desselben Arrays, ab denen alle angrenzenden Scheitelpunkte in einer Reihe darin geschrieben werden. <br><br>  Hier fand ich die f√ºr mich verst√§ndlichste Erkl√§rung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ejuo.livejournal.com/4518.html</a> <br><br><h2>  3. Adjazenzvektor und assoziatives Adjazenzarray </h2><br>  Es kam vor, dass der Autor dieser Zeilen, der kein professioneller Programmierer war, sondern sich regelm√§√üig mit Graphen befasste, sich am h√§ufigsten mit Kantenlisten befasste.  In der Tat ist es praktisch, wenn der Graph mehrere Schleifen und Kanten hat.  Und jetzt, bei der Entwicklung der klassischen Kantenlisten, schlage ich vor, auf ihre ‚ÄûEntwicklung / Verzweigung / Modifikation / Mutation‚Äú zu achten, n√§mlich auf den Adjazenzvektor und das assoziative Array der Adjazenz. <br><br>  <b>3.1 Adjazenzvektor</b> <br><br>  <i>Fall (A1): Ungewichtete Anzahl</i> <br><br>  Wir werden den Adjazenzvektor f√ºr einen ungewichteten Graphen eine geordnete Menge einer geraden Anzahl von ganzen Zahlen (a [2i], a [2i + 1], ..., wobei i mit c 0 nummeriert ist) bezeichnen, in der jedes Zahlenpaar a [2i], a [2i +1] definiert die Kante des Graphen zwischen den Eckpunkten a [2i] und a [2i + 1]. <br>  Dieses Aufnahmeformat enth√§lt keine Informationen dar√ºber, ob das Diagramm ausgerichtet ist (beide Optionen sind m√∂glich).  Bei Verwendung des Digraphenformats wird angenommen, dass die Kante von a [2i] nach a [2i + 1] gerichtet ist.  Im Folgenden: Bei ungerichteten Diagrammen k√∂nnen bei Bedarf die Anforderungen f√ºr die Reihenfolge der Aufzeichnung von Scheitelpunkten angewendet werden (z. B. so, dass der Scheitelpunkt mit dem niedrigeren Wert der ihm zugewiesenen Zahl an erster Stelle steht). <br><br>  In C ++ ist es ratsam, den Adjazenzvektor mit std :: vector anzugeben, aus dem der Name dieser Datenstruktur ausgew√§hlt wurde. <br><br>  <i>Fall (a2): ungewichteter Graph, ganzzahlige Kantengewichte</i> <br><br>  In Analogie zu Fall (a1) nennen wir den Adjazenzvektor f√ºr einen gewichteten Graphen mit ganzzahligen Kantengewichten eine geordnete Menge (dynamisches Array) von Zahlen (a [3i], a [3i + 1], a [3i + 2], ..., wobei i ist mit c 0) nummeriert, wobei jedes "Triplett" der Zahlen a [3i], a [3i + 1], a [3i + 2] die Kante des Graphen zwischen den Eckpunkten unter den Zahlen a [3i] bzw. a [3i + 1] definiert und Der Wert von a [3i + 2] ist das Gewicht dieser Kante.  Ein solcher Graph kann auch entweder orientiert sein oder nicht. <br><br>  <i>Fall (b): ungewichteter Graph, nicht ganzzahlige Kantengewichte</i> <br><br>  Da die heterogenen Elemente nicht in einem Array (Vektor) gespeichert werden k√∂nnen, ist beispielsweise die folgende Implementierung m√∂glich.  Der Graph wird in einem Vektorpaar gespeichert, wobei der erste Vektor der Adjazenzvektor des Graphen ohne Angabe von Gewichten ist und der zweite Vektor die entsprechenden Gewichte enth√§lt (eine m√∂gliche Implementierung f√ºr C ++ ist: std :: pair &lt;std :: vector, std :: vector&gt;).  Somit ist f√ºr eine Kante, die durch ein Paar von Eckpunkten unter den Indizes 2i, 2i + 1 des ersten Vektors definiert ist, das Gewicht gleich dem Element unter dem Index i des zweiten Vektors. <br><br>  <i>Nun, warum ist das notwendig?</i> <br><br>  F√ºr den Autor dieser Zeilen zur L√∂sung einer Reihe von Problemen schien dies sehr n√ºtzlich zu sein.  Aus formaler Sicht wird es solche Vorteile geben: <br><br><ul><li>  Der Adjazenzvektor ist wie jede andere "Aufz√§hlungs" -Struktur kompakt genug, ben√∂tigt weniger Speicher als die Adjazenzmatrix (f√ºr sp√§rliche Graphen) und ist relativ einfach zu implementieren. </li><li>  Die Eckpunkte des Graphen k√∂nnen grunds√§tzlich mit negativen Zahlen markiert werden.  Pl√∂tzlich ist auch eine solche ‚ÄûPerversion‚Äú erforderlich. </li><li>  Diagramme k√∂nnen mehrere Kanten und mehrere Schleifen mit unterschiedlichen Gewichten (positiv, negativ, sogar null) enthalten.  Hier gibt es keine Einschr√§nkungen. </li><li>  Und Rippen k√∂nnen unterschiedliche Eigenschaften zugewiesen werden - dazu siehe Absatz 4. </li></ul><br>  Ich muss jedoch zugeben, dass dieser ‚ÄûListot‚Äú keinen schnellen Zugang zur Rippe bedeutet.  Und hier beeilt sich das assoziative Adjazenz-Array, um zu helfen, wor√ºber - unten. <br><br>  <b>3.2 Assoziatives Adjazenzarray</b> <br><br>  Wenn f√ºr uns der Zugriff auf eine bestimmte Kante, deren Gewicht und andere Eigenschaften von entscheidender Bedeutung ist und die Speicheranforderungen die Verwendung einer Adjazenzmatrix nicht zulassen, sollten wir uns √ºberlegen, wie Sie den Adjazenzvektor √§ndern k√∂nnen, um dieses Problem zu l√∂sen.  Der Schl√ºssel ist also die Kante des Graphen, die als geordnetes Paar von ganzen Zahlen definiert werden kann.  Wie sieht es aus?  K√∂nnte es ein Schl√ºssel in einem assoziativen Array sein?  Und wenn ja, warum setzen wir das nicht um?  Lassen Sie uns ein solches assoziatives Array haben, in dem jeder Schl√ºssel - ein geordnetes Paar von Ganzzahlen - einem Wert zugeordnet wird - einer Ganzzahl oder einer reellen Zahl, die das Gewicht der Kante angibt.  In C ++ ist es ratsam, diese Struktur auf der Basis des std :: map-Containers zu implementieren (std :: map &lt;std :: pair &lt;int, int&gt;, int&gt; oder std :: map &lt;std :: pair &lt;int, int&gt;, double&gt;). oder std :: multimap, wenn mehrere Kanten angenommen werden.  Nun, und hier haben wir eine Struktur zum Speichern von Graphen, die weniger Speicher ben√∂tigt als "Matrix" -Strukturen, Graphen mit mehreren Schleifen und Kanten definieren k√∂nnen und auch ohne strenge Anforderungen an die Nicht-Negativit√§t von Scheitelpunktzahlen (ich wei√ü nicht, wer sie ben√∂tigt). aber immer noch). <br><br><h2>  4. Datenstrukturen zumindest "fluten", aber etwas fehlt </h2><br>  Und die Wahrheit ist: Wenn wir eine Reihe von Problemen l√∂sen, m√ºssen wir m√∂glicherweise den R√§ndern des Diagramms einige Attribute zuweisen und sie entsprechend speichern.  Wenn es m√∂glich ist, diese Merkmale eindeutig auf ganze Zahlen zu reduzieren, ist es m√∂glich, solche "Graphen mit zus√§tzlichen Merkmalen" unter Verwendung erweiterter Versionen des Adjazenzvektors und des assoziativen Adjazenzarrays zu speichern. <br><br>  Lassen Sie uns also ein ungewichtetes Diagramm haben, f√ºr das f√ºr jede Kante beispielsweise zwei zus√§tzliche Zeichen gespeichert werden m√ºssen, die durch Ganzzahlen angegeben werden.  In diesem Fall ist es m√∂glich, seinen Adjazenzvektor als eine geordnete Menge von nicht "Paaren", sondern "Quartetten" von ganzen Zahlen (a [2i], a [2i + 1], a [2i + 2], a [2i + 3] anzugeben. .), wobei a [2i + 2] und a [2i + 3] die Merkmale der entsprechenden Kante bestimmen.  Bei einem Diagramm mit ganzzahligen Kantengewichten ist die Reihenfolge im Allgemeinen √§hnlich (der einzige Unterschied besteht darin, dass die Vorzeichen dem Kantengewicht folgen und durch die Elemente a [2i + 3] und a [2i + 4] gegeben sind und die Kante selbst angegeben wird nicht 4, sondern 5 bestellte Nummern).  Bei einem Diagramm mit nicht ganzzahligen Kantengewichten k√∂nnen die Attribute in die ungewichtete Komponente geschrieben werden. <br><br>  Wenn Sie ein assoziatives Adjazenzarray f√ºr Diagramme mit ganzzahligen Kantengewichten verwenden, k√∂nnen Sie nicht eine einzelne Zahl, sondern ein Array (einen Vektor) von Zahlen angeben, das neben dem Kantengewicht alle anderen erforderlichen Attribute angibt.  Gleichzeitig besteht die Unannehmlichkeit f√ºr den Fall von nicht ganzzahligen Gewichten darin, dass ein Zeichen mit einer Gleitkommazahl angegeben werden muss (ja, dies ist eine Unannehmlichkeit, aber wenn es nicht so viele solcher Zeichen gibt und Sie sie nicht zu "knifflig" doppelt setzen, kann es nichts sein). .  In C ++ k√∂nnen erweiterte assoziative Adjazenz-Arrays wie folgt definiert werden: std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector&gt; oder std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector, wobei der erste Wert in "vector-value-by-key" das Gewicht der Kante ist und dann die numerischen Bezeichnungen ihrer Merkmale gefunden werden. <br><br><h2>  Referenzen: </h2><br>  <i>√úber Grafiken und Algorithmen im Allgemeinen:</i> <br><br>  1. Cormen, Thomas H., Leiserson, Charles I., Rivest, Ronald L., Stein, Clifford.  Algorithmen: Konstruktion und Analyse, 2. Auflage: Per.  aus dem Englischen  - M.: Williams Verlag, 2011. <br>  2. Harari Frank.  Graphentheorie.  M.: Mir, 1973. <br>  <i>Der Bericht des Autors √ºber denselben Vektor und dieselbe assoziative Nachbarschaft:</i> <br>  3. Chernoukhov S.A.  Adjazenzvektor und assoziatives Adjazenzarray als Mittel zur Darstellung und Speicherung von Graphen / SA Chernouhov.  Adjazenzvektor und Adjazenzkarte als Datenstrukturen zur Darstellung eines Graphen // Sammlung von Artikeln der Internationalen wissenschaftlichen und praktischen Konferenz "Probleme bei der Umsetzung der Ergebnisse innovativer Entwicklungen und L√∂sungswege" (Saratov, 14. September 2019).  - Sterlitamak: AMI, 2019, p.  65-69 <br>  <i>N√ºtzliche Internetquellen zum Thema:</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.prog-cpp.ru/data-graph</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ejuo.livejournal.com/4518.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469967/">https://habr.com/ru/post/de469967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469949/index.html">Zum Geburtstag von Juri Knorozow: Wir lernen die Grundlagen des Maya-Schreibens</a></li>
<li><a href="../de469951/index.html">DIY Segmented Control, wie in iOS 13.0 und h√∂her</a></li>
<li><a href="../de469955/index.html">Custdev, anspruchsvolle Dienstleistungen und die Kunst der Pr√§sentation: Was wir den Teilnehmern des VTB-Beschleunigers beigebracht haben</a></li>
<li><a href="../de469961/index.html">Rust bei Microsoft (oder die Erstellung von Security Daemon Azure IoT Edge)</a></li>
<li><a href="../de469963/index.html">SonarQube und IntelliJ IDEA: Richtige Integration</a></li>
<li><a href="../de469975/index.html">Santiago Weg mit Laptop</a></li>
<li><a href="../de469977/index.html">Wie drei Klassenkameraden zu Facebook-Partnern wurden - Revealbot-Geschichte</a></li>
<li><a href="../de469979/index.html">Aufzeichnungen von Berichten aus dem zweiten iOS mitap Redmadrobot</a></li>
<li><a href="../de469981/index.html">Was ist im Chat-Bot?</a></li>
<li><a href="../de469983/index.html">Wie kann man eine Strategie entwickeln, um das Altern zu besiegen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>