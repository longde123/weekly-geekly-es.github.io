<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêØ üöî üî∑ El libro "Java para todos" üßòüèª üì∑ üéÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Este libro est√° destinado a principiantes. 


 Durante muchos a√±os, el lenguaje Java ha sido uno de los m√°s populares y buscados. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Java para todos"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/472076/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xs/no/fg/xsnofg4jvnjubrnjcows5mbxc3m.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Este libro est√° destinado a principiantes. </p><br><p>  Durante muchos a√±os, el lenguaje Java ha sido uno de los m√°s populares y buscados.  Es hermoso, efectivo y, lo m√°s importante, muy productivo.  Pero, desafortunadamente, no es la m√°s f√°cil.  Es por eso que la demanda de programadores Java es consistentemente alta.  El lenguaje Java es un diamante que adornar√° el bagaje de conocimiento de cualquier programador.  Y aprender Java, como espero, los lectores de este libro tendr√°n que asegurarse, no solo es √∫til, sino tambi√©n interesante.  La base del libro son los cursos de conferencias, en diferentes momentos, que le√≠ para los maestros de la Facultad de F√≠sica de la Universidad Nacional de Kiev que llevan el nombre  Tarasa Shevchenko, licenciada de la facultad de ingenier√≠a m√©dica de la Universidad T√©cnica Nacional de Ucrania "Instituto Polit√©cnico de Kiev" y estudiantes de varios cursos de programaci√≥n.  El material del libro y la forma de presentaci√≥n est√°n adaptados para todos los que quieran aprender Java, no solo en las instituciones educativas, sino tambi√©n de forma independiente.  Por lo tanto, el libro se puede usar como tutorial. </p><a name="habracut"></a><br><h2 id="massivy">  Matrices </h2><br><p>  Una matriz significa un conjunto del mismo tipo de valores (variables), al que se puede acceder mediante un nombre com√∫n.  Este cap√≠tulo est√° dedicado a las matrices. </p><br><p>  Las variables que pertenecen a una matriz se denominan elementos de esta matriz.  Para identificar de forma exclusiva un elemento de una matriz, debe conocer el nombre de la matriz y la posici√≥n (ubicaci√≥n) del elemento en la matriz.  La posici√≥n de los elementos en la matriz se determina utilizando √≠ndices enteros.  El n√∫mero de √≠ndices necesarios para identificar un elemento de una matriz se denomina dimensi√≥n de la matriz.  Una matriz unidimensional es una matriz en la que los elementos se identifican usando un √≠ndice √∫nico. </p><br><h2 id="odnomernye-massivy">  Matrices unidimensionales </h2><br><p>  Es conveniente imaginar una matriz unidimensional en forma de cadena ordenada o secuencia de variables (del mismo tipo).  Para declarar una matriz unidimensional, debe especificar el tipo al que pertenecen los elementos de la matriz, el nombre de la matriz y tambi√©n el n√∫mero de elementos incluidos en la matriz.  La sintaxis para declarar una matriz unidimensional es: </p><br><pre><code class="java hljs">[] =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [];</code> </pre> <br><p>  Primero, se indica el tipo de los elementos de la matriz, y despu√©s del identificador de tipo, seguido de corchetes vac√≠os.  A continuaci√≥n, el nombre de la matriz, el operador de asignaci√≥n, la instrucci√≥n (operador) nueva, nuevamente el tipo de los elementos de la matriz y entre corchetes el tama√±o de la matriz (el n√∫mero de elementos en la matriz).  Por ejemplo, el comando int nums = new int [20] declara una matriz de n√∫meros enteros de 20 elementos. </p><br><p>  Estrictamente hablando, el comando de declaraci√≥n de matriz presentado aqu√≠ es una simbiosis de dos comandos: el comando int [] nums declara una variable nums del tipo "matriz entera" (variable de matriz) y la nueva instrucci√≥n int [20], que, de hecho, crea la matriz.  A esta instrucci√≥n se le asigna el valor de la variable nums y, como resultado de la referencia de matriz, se escribe en la variable nums.  En otras palabras, el proceso de crear una matriz se puede realizar con dos comandos: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] nums; nums=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">20</span></span>];</code> </pre> <br><p>  Adem√°s, estos comandos se pueden publicar en el c√≥digo del programa, es decir, podemos declarar una variable de matriz y solo entonces, en otro lugar del c√≥digo, crear una matriz (y escribir un enlace a esta matriz en la variable de matriz). </p><br><blockquote>  DETALLES Anteriormente, tratamos principalmente con tipos b√°sicos o primitivos (como int, char o double).  Una variable del tipo base almacena el valor.  T√©cnicamente, se ve as√≠: se asigna un espacio para una variable en la memoria, y el valor de la variable se escribe en este lugar.  Pero hay otra forma de trabajar con datos en la que una variable se refiere a datos.  Esto es lo que les sucede a los objetos, por lo que se implementan matrices.  En realidad, hay una matriz, pero no tenemos acceso a ella directamente, sino con la ayuda de un intermediario, que es una variable de matriz.  El valor de la variable de matriz no es la matriz, sino la direcci√≥n de la matriz.  Por lo tanto, crear una variable de matriz no significa crear una matriz.  Una matriz se crea por separado.  Describiremos esta situaci√≥n como una en la que una variable de matriz se refiere a una matriz.  Cada vez que necesitemos acceder a la matriz, accederemos a la variable de matriz que se refiere a la matriz dada. <br>  Aunque a primera vista dicho esquema puede parecer redundante, sin embargo, tiene sus ventajas.  Y veremos esto. </blockquote><p>  En los casos en que no haya malentendidos, identificaremos la variable de matriz con la matriz. </p><br><p>  Al declarar una variable de matriz, se permite indicar corchetes despu√©s del identificador de tipo o despu√©s del nombre de la matriz.  Por ejemplo, en lugar del comando int [] nums, puede usar el comando int nums []. </p><br><p>  Se accede a un elemento de una matriz unidimensional a trav√©s del nombre de la matriz con el √≠ndice del elemento indicado entre corchetes.  La indexaci√≥n de elementos de la matriz comienza desde cero.  Por lo tanto, la referencia al primer elemento de la matriz nums se ver√° como nums [0].  Si hay 20 elementos en la matriz, entonces el √∫ltimo elemento de la matriz tiene un √≠ndice de 19, es decir, la instrucci√≥n para acceder al elemento parece nums [19]. </p><br><p>  La longitud de la matriz se puede encontrar utilizando la propiedad de longitud: se indica el nombre de la matriz y, a trav√©s del punto, la propiedad de longitud.  Por ejemplo, para averiguar la longitud de la matriz nums, puede usar la instrucci√≥n nums.length.  Entonces la referencia al √∫ltimo elemento de la matriz se puede escribir como nums [nums.length-1]. </p><br><blockquote>  AVISO Java utiliza una comprobaci√≥n autom√°tica para ver si sale de la matriz.  Por lo tanto, si el c√≥digo se refiere a un elemento de matriz inexistente, se produce un error. </blockquote><p>  Al declarar una matriz, se le asigna memoria.  En Java, los elementos de la matriz se inicializan autom√°ticamente con valores cero: las celdas seleccionadas se ponen a cero y los valores de estas celdas puestas a cero se interpretan seg√∫n el tipo de matriz.  Pero no debe confiar en dicha inicializaci√≥n autom√°tica.  Es aconsejable inicializar los elementos de la matriz expl√≠citamente.  Para hacer esto, use el operador de bucle o especifique una lista de valores de elementos al declarar una matriz. </p><br><p>  Para inicializar la matriz con una lista de valores al declarar una variable de matriz, despu√©s de que se indique (a trav√©s del operador de asignaci√≥n) una lista de valores encerrados entre llaves.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data={<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>};</code> </pre> <br><p>  Aqu√≠, los datos variables se declaran para una matriz de enteros, se crea una matriz y se escribe un enlace a esta variable.  El tama√±o de la matriz y los valores de los elementos se determinan autom√°ticamente de acuerdo con el n√∫mero de elementos en la lista de valores.  En este caso, se crea una matriz entera de cuatro elementos con los valores de los elementos 3, 8, 1 y 7. Se puede lograr el mismo resultado utilizando, por ejemplo, los siguientes comandos: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; data=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]{<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>};</code> </pre> <br><p>  El primer comando de datos int [] declara una variable de matriz.  La instrucci√≥n new int [] {3,8,1,7} crea una matriz de cuatro enteros, y se asigna una referencia a esta matriz a los datos variables (lo que significa que el comando data = new int [] {3,8,1,7}) . <br>  En el Listado 3.1 se muestra un ejemplo de declaraci√≥n, inicializaci√≥n y uso de matrices. </p><br><h4 id="listing-31-znakomstvo-s-odnomernymi-massivami">  Listado 3.1.  Presentaci√≥n de matrices unidimensionales </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  : int i,n; //   : int[] data; //  : data=new int[]{3,8,1,7}; //  : n=data.length; //  : int[] nums=new int[n]; //   : for(i=0;i&lt;nums.length;i++){ nums[i]=2*data[i]-3; System.out.println("nums["+i+"]="+nums[i]); } } }</span></span></code> </pre> <br><p>  El programa declara e inicializa una matriz de datos de cuatro elementos.  La longitud de la matriz se calcula mediante la declaraci√≥n data.length.  Este valor se escribe en la variable entera n (comando n = data.length).  A continuaci√≥n, el comando int [] nums = new int [n] declara otra matriz de n√∫meros enteros.  El n√∫mero de elementos en esta matriz est√° determinado por el valor de la variable n, por lo tanto, coincide con el tama√±o de la matriz de datos.  El llenado de la matriz nums se realiza mediante una declaraci√≥n de bucle.  Los valores de los elementos de la matriz nums se calculan en funci√≥n de los valores de los elementos de la matriz de datos (comando nums [i] = 2 * data [i] -3).  Para mostrar los valores de los elementos de la matriz nums, use el comando System.out.println ("nums [" + i + "] =" + nums [i]). </p><br><p>  A continuaci√≥n se muestra c√≥mo se ve el resultado de la ejecuci√≥n del programa: <br>  El resultado del programa (del Listado 3.1) </p><br><pre> <code class="java hljs">nums[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">3</span></span> nums[<span class="hljs-number"><span class="hljs-number">1</span></span>]=<span class="hljs-number"><span class="hljs-number">13</span></span> nums[<span class="hljs-number"><span class="hljs-number">2</span></span>]=-<span class="hljs-number"><span class="hljs-number">1</span></span> nums[<span class="hljs-number"><span class="hljs-number">3</span></span>]=<span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre> <br><p>  Una vez m√°s, observamos que la indexaci√≥n de los elementos de la matriz comienza desde cero.  Por lo tanto, en el operador de bucle, la variable de √≠ndice i se inicializa con el valor cero inicial, y el operador de desigualdad estricta se usa en la condici√≥n de prueba i &lt;nums.length. <br>  Tambi√©n es importante que al crear la matriz nums, su tama√±o se determine utilizando la variable n, cuyo valor se calcula durante la ejecuci√≥n del programa. </p><br><h2 id="dvumernye-i-mnogomernye-massivy">  Matrices bidimensionales y multidimensionales </h2><br><p>  La dimensi√≥n de la matriz puede ser mayor que uno.  Pero en la pr√°ctica, rara vez se utilizan matrices de dimensiones superiores a la segunda.  A continuaci√≥n, veremos formas de declarar, inicializar y usar matrices bidimensionales en las que el acceso a un elemento de una matriz se realiza utilizando dos √≠ndices.  Si representa una matriz bidimensional como una tabla, el primer √≠ndice del elemento determina la fila en la que se encuentra el elemento, y el segundo √≠ndice determina la columna en la que se encuentra el elemento. </p><br><blockquote>  DETALLES Aunque una matriz bidimensional se representa convenientemente como una tabla, se implementa de una manera completamente diferente.  De hecho, una matriz bidimensional en Java es una matriz unidimensional cuyos elementos son variables de matriz.  Cada una de esas variables se refiere a una matriz unidimensional.  Cuando se usa esta construcci√≥n, surge la ilusi√≥n de que estamos tratando con una mesa. </blockquote><p>  Crear matrices bidimensionales es tan simple como crear matrices unidimensionales.  Pero al declarar una variable para una matriz bidimensional, se indican dos pares de corchetes vac√≠os despu√©s del identificador de tipo, y las instrucciones para crear una matriz bidimensional, entre corchetes separados, indican el tama√±o de cada uno de los √≠ndices (el n√∫mero de filas y columnas en la matriz).  La sintaxis para declarar una matriz bidimensional es la siguiente: </p><br><pre> <code class="java hljs">[][] =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [][];</code> </pre> <br><p>  Como en el caso de una matriz unidimensional, este comando se puede dividir en dos: </p><br><pre> <code class="java hljs">[][] ; =<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [][];</code> </pre> <br><p>  El primer comando declara una variable para una matriz bidimensional.  El segundo comando crea una matriz bidimensional real con los tama√±os especificados, y se asigna una referencia a esta matriz como el valor de la variable de matriz.  Por ejemplo, el comando double [] [] data = new double [3] [4] crea una matriz bidimensional con elementos del tipo double.  La matriz tiene 3 filas y 4 columnas, y el enlace a la matriz se escribe en la variable de datos.  Los mismos comandos dar√°n como resultado el mismo resultado: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] data; data=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br><p>  El acceso a los elementos de una matriz bidimensional se realiza en el siguiente formato: el nombre de la matriz se indica, entre corchetes es el primer √≠ndice del elemento, en otros corchetes es el segundo √≠ndice del elemento de la matriz.  La indexaci√≥n en todas las dimensiones comienza desde cero.  Por ejemplo, el enlace de datos [0] [3] es una llamada a un elemento de la matriz de datos con los √≠ndices 0 y 3, y es un elemento en la primera fila y la cuarta columna. </p><br><p>  Para inicializar una matriz bidimensional, se utilizan operadores de bucle anidados o una lista que consiste en listas de valores.  Cada una de estas listas internas define los valores de los elementos de la matriz en una cadena.  Los siguientes son ejemplos de inicializaci√≥n de una matriz bidimensional utilizando una lista: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] data={{<span class="hljs-number"><span class="hljs-number">0.1</span></span>,<span class="hljs-number"><span class="hljs-number">0.2</span></span>,<span class="hljs-number"><span class="hljs-number">0.3</span></span>},{<span class="hljs-number"><span class="hljs-number">0.4</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.6</span></span>}}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nums[][]={{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>},{<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}};</code> </pre> <br><p>  El primer comando crea e inicializa una matriz de datos bidimensionales de 2 por 3 (dos filas y tres columnas).  El n√∫mero de filas est√° determinado por el n√∫mero de elementos en la lista externa.  Hay dos de estos elementos: estas son las listas {0.1,0.2,0.3} y {0.4,0.5,0.6}.  Cada una de estas listas tiene tres elementos.  De aqu√≠ obtenemos una matriz de tama√±o 2 por 3. La lista {0.1,0.2,0.3} define los valores de los elementos en la primera l√≠nea, la lista {0.4,0.5,0.6} define los valores de los elementos en la segunda l√≠nea.  Por ejemplo, el elemento data [0] [0] obtiene el valor 0.1, el elemento data [0] [2] obtiene el valor 0.3, el elemento data [1] [0] obtiene el valor 0.4 y el elemento data [1] [2] obtiene el valor 0.6 . </p><br><p>  El segundo comando crea una matriz de n√∫meros enteros, que consta de dos l√≠neas (ya que hay dos elementos dentro de la lista asignada: las listas {1,2,3} y {4,5}).  Sin embargo, la primera l√≠nea de la matriz creada contiene tres elementos (ya que hay tres valores en la lista {1,2,3}), y la segunda l√≠nea de la matriz contiene dos elementos (ya que hay dos valores en la lista {4,5}).  En la matriz creada, el elemento nums [0] [0] tiene el valor 1, el elemento nums [0] [1] tiene el valor 2, el elemento nums [0] [2] tiene el valor 3, el elemento nums [1] [0] tiene el valor 4 y el elemento nums [1] [1] es el valor 5. </p><br><blockquote>  DETALLES El problema es que la matriz de n√∫meros en diferentes l√≠neas contiene un n√∫mero diferente de elementos, no.  T√©cnicamente, todo se implementa m√°s que simplemente.  La variable de los n√∫meros de la matriz bidimensional en realidad se refiere a una matriz unidimensional de dos elementos (el n√∫mero de filas en la matriz bidimensional).  Pero los elementos de esta matriz no son enteros, sino variables que pueden referirse a matrices enteras unidimensionales (en t√©rminos relativos, los elementos son del tipo int []).  La primera variable se refiere a una matriz unidimensional de tres elementos (1, 2 y 3), y la segunda variable se refiere a una matriz unidimensional de tres elementos (4 y 5).  Cuando indexamos (¬°con un √≠ndice!) La variable nums, tenemos acceso al elemento de la matriz unidimensional referenciada por esta variable.  Por ejemplo, nums [0] es el primer elemento y nums [1] es el segundo elemento de la matriz mencionada de las variables de la matriz.  Y estos elementos son referencias a matrices.  Se pueden indexar.  Por lo tanto, supongamos que nums [0] [1] es el segundo elemento en la matriz a la que se refiere el primer elemento nums [0] en la matriz a la que se refiere la variable nums.  Entonces todo sucede realmente.  E interpretamos la instrucci√≥n nums [0] [1] como una apelaci√≥n a un elemento en la primera fila y en la segunda columna de una matriz bidimensional. </blockquote><p>  El Listado 3.2 muestra un ejemplo de un programa que crea una matriz bidimensional que se rellena utilizando sentencias de bucle anidado. </p><br><h4 id="listing-32-sozdanie-dvumernogo-massiva">  Listado 3.2.  Crear una matriz bidimensional </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i,j,n=<span class="hljs-number"><span class="hljs-number">3</span></span>,val=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   : int[][] nums=new int[n-1][n]; //   : for(i=0;i&lt;n-1;i++){ //    for(j=0;j&lt;n;j++){ //    //   : nums[i][j]=val++; //   : System.out.print(nums[i][j]+" "); } //    : System.out.println(); } } }</span></span></code> </pre> <br><p>  El comando int [] [] nums = new int [n-1] [n] crea una matriz de n√∫meros enteros con n-1 filas yn columnas.  A la variable n se le asigna previamente el valor 3. La matriz se llena utilizando operadores de bucle anidados.  El valor del elemento de matriz (para los √≠ndices dados i y j) se asigna mediante el comando nums [i] [j] = val ++.  Aqu√≠, al elemento nums [i] [j] se le asigna el valor actual de la variable val, e inmediatamente despu√©s, el valor de la variable val se incrementa en uno. </p><br><blockquote>  AVISO Como resultado de ejecutar la instrucci√≥n val ++, el valor de la variable val aumenta en uno.  Pero dado que se usa la forma postfix del operador de incremento, el valor de la expresi√≥n val ++ es el valor antiguo (antes de aumentar en uno) de la variable val. </blockquote><p>  Despu√©s de calcular el valor del elemento, se muestra en el √°rea de salida.  Como resultado del programa, obtenemos: <br>  El resultado del programa (del listado 3.2) </p><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><p>  El listado 3.3 muestra el c√≥digo para un programa que crea una matriz bidimensional con cadenas de diferentes longitudes. </p><br><h4 id="listing-33-massiv-so-strokami-raznoy-dliny">  Listado 3.3.  Matriz con cuerdas de diferentes longitudes. </h4><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i,j,val=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   (   ): int[][] nums=new int[4][]; //     : for(i=0;i&lt;nums.length;i++){ //    : nums[i]=new int[i+1]; } //  : for(i=0;i&lt;nums.length;i++){ for(j=0;j&lt;nums[i].length;j++){ //   : nums[i][j]=val++; //   : System.out.print(nums[i][j]+" "); } //    : System.out.println(); } } }</span></span></code> </pre> <br><p>  El comando int [] [] nums = new int [4] [] crea una matriz de n√∫meros enteros bidimensionales.  Esta matriz consta de cuatro filas.  Sin embargo, el tama√±o de las l√≠neas no se especifica: el segundo par de corchetes al final del comando est√° vac√≠o.  M√°s precisamente, todav√≠a no hay l√≠neas.  Necesitan ser creados.  Las l√≠neas se crean en la declaraci√≥n de bucle.  En esta declaraci√≥n de bucle, la variable de √≠ndice i se ejecuta a trav√©s de valores de 0 a nums.length-1, inclusive.  El comando nums [i] = new int [i + 1] crea una fila de una matriz bidimensional con √≠ndice i.  Dicha cadena contiene un elemento i + 1. </p><br><blockquote>  DETALLES T√©cnicamente, todo sucede as√≠: la nueva instrucci√≥n int [i + 1] crea una matriz unidimensional (una cadena para una matriz bidimensional) y una referencia a esta matriz se escribe en la variable nums [i].  En este caso, nums [i] puede interpretarse como un enlace a una l√≠nea con √≠ndice i.  El significado de la instrucci√≥n nums.length se aclarar√° si recuerda que, de hecho, una matriz bidimensional es una matriz unidimensional, cuyos elementos se refieren a matrices unidimensionales.  En este caso, nums.length proporciona un valor para el n√∫mero de elementos en la matriz referenciada por la variable nums, es decir, esta es la cantidad de filas en la matriz bidimensional. </blockquote><p>  Como resultado, obtenemos una matriz bidimensional de tipo triangular: en la primera l√≠nea de la matriz hay un elemento, en el segundo, dos elementos, y as√≠ sucesivamente, hasta la cuarta l√≠nea de la matriz. <br>  La matriz creada se llena con operadores de bucle anidados.  La variable de √≠ndice i en el operador de bucle externo toma valores de 0 a nums.length-1 y define una fila en la matriz bidimensional de nums.  Para la variable de √≠ndice j, el l√≠mite superior del rango de variaci√≥n est√° determinado por la instrucci√≥n nums [i] .length, que devuelve el n√∫mero de elementos en la fila con el √≠ndice i (la variable j cambia de 0 a nums [i] .length-1 inclusive). </p><br><blockquote>  DETALLES Cabe se√±alar que nums [i], de hecho, es una variable que se refiere a una matriz unidimensional que forma una cadena con √≠ndice i.  El n√∫mero de elementos en esta matriz (cadena) est√° determinado por la expresi√≥n nums [i] .length. </blockquote><p>  El valor de los elementos de la matriz se asigna mediante el comando nums [i] [j] = val ++.  A continuaci√≥n se muestra c√≥mo se ve el resultado de la ejecuci√≥n del programa: <br>  El resultado del programa (del listado 3.3) </p><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  Como se esperaba, obtuvimos una matriz que tiene diferentes n√∫meros de elementos en diferentes filas. </p><br><blockquote>  AVISO Las matrices, cuya dimensi√≥n es m√°s de dos, se crean de la misma manera.  Al declarar una variable para una matriz multidimensional, los pares de par√©ntesis vac√≠os se indican despu√©s del identificador de tipo.  El n√∫mero de tales pares est√° determinado por la dimensi√≥n de la matriz.  En el comando de creaci√≥n de matriz, el tama√±o de cada √≠ndice se indica entre corchetes separados. </blockquote><p>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> </p><br><p>  Cup√≥n de 25% de descuento para vendedores ambulantes - <strong>Java</strong> </p><br><p>  Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472076/">https://habr.com/ru/post/472076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472060/index.html">La polic√≠a alemana irrumpi√≥ en el b√∫nker militar, que albergaba el centro de datos recientemente declarado.</a></li>
<li><a href="../472062/index.html">Monitoreo + prueba de estr√©s = pron√≥stico y sin fallas</a></li>
<li><a href="../472064/index.html">Ansible + auto git pull en el cl√∫ster de m√°quinas virtuales en la nube</a></li>
<li><a href="../472068/index.html">Uso de SSD NVME como unidad de sistema en computadoras con BIOS antiguo y sistema operativo Linux</a></li>
<li><a href="../472072/index.html">PG12: una docena de parches de Postgres Professional</a></li>
<li><a href="../472078/index.html">Riesgos de banca abierta</a></li>
<li><a href="../472084/index.html">Vulnerabilidades de tel√©fonos inteligentes</a></li>
<li><a href="../472086/index.html">Usando las leyes de la psicolog√≠a gestalt en el dise√±o de la interfaz de usuario</a></li>
<li><a href="../472088/index.html">C√≥mo elegimos ServiceDesk. Parte 2</a></li>
<li><a href="../472092/index.html">Funciones PHP inseguras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>