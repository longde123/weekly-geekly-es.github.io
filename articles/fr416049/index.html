<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏼 👩🏼‍🤝‍👨🏽 🚍 Codec AV1 nouvelle génération: filtre de correction directionnelle CDEF 🌗 👨🏾‍⚖️ 👩‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publié par Monty (monty@xiph.org, cmontgomery@mozilla.com). Publié le 28 juin 2018. 

 Si quelqu'un n'a pas lu l' article précédent ... AV1 est un nou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codec AV1 nouvelle génération: filtre de correction directionnelle CDEF</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416049/"><img src="https://habrastorage.org/getpro/habr/post_images/d56/c00/8cf/d56c008cf1e5fd3a74830589173ff01d.png"><br><br>  <b><font color="gray">Publié par Monty (monty@xiph.org, cmontgomery@mozilla.com).</font></b>  <b><font color="gray">Publié le 28 juin 2018.</font></b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/c0d/bb1/fdfc0dbb1903a29218bbe7589db840f1.png" align="left">  Si quelqu'un n'a pas lu l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> ... AV1 est un nouveau codec vidéo universel développé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par l'</a> Alliance for Open Media.  L'alliance a pris comme base le codec VPX de Google, Thor de Cisco et Daala de Mozilla / Xiph.Org.  Le codec AV1 est supérieur en performances à VP9 et HEVC, ce qui en fait un codec non pas demain, mais après-demain.  Le format AV1 est libre de toute redevance et le restera à jamais avec une licence de licence. <br><br>  <i>Cet article a été conçu comme le deuxième d'une série d'articles qui décrivent en détail les fonctionnalités d'AV1 et les nouvelles technologies qui le sous-tendent et sont d'abord utilisées en production.</i>  <i>Un article précédent sur Xiph.org expliquait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction de prédiction de la luminosité de Chroma from Luma (CfL)</a> .</i>  <i>Aujourd'hui, nous allons parler d'un filtre de correction directionnelle limité (Filtre d'amélioration directionnel contraint).</i>  <i>Si vous vous êtes toujours demandé ce qu'il fallait pour écrire un codec, attachez vos ceintures et préparez-vous pour l'éducation!</i> <br><a name="habracut"></a><br><h1>  Filtres dans AV1 </h1><br>  Dans presque tous les codecs vidéo, des filtres correcteurs sont utilisés pour améliorer la qualité subjective du matériel de sortie. <br><br>  Par «filtres correcteurs», j'entends des méthodes qui ne codent pas nécessairement les informations sur l'image ni n'améliorent l'efficacité du codage objectif, mais elles améliorent le résultat d'une certaine manière.  Les filtres correcteurs doivent être utilisés avec précaution car ils perdent généralement des informations - et pour cette raison, ils sont parfois considérés comme une méthode de triche inacceptable afin que le résultat soit meilleur qu'il ne l'est réellement. <br><br>  Mais ce n'est pas juste.  Les filtres de correction sont conçus pour contourner ou éliminer des artefacts spécifiques qui sont invisibles pour les mesures objectives, mais évidents pour l'œil humain.  Et même si nous considérons les filtres comme une forme de tromperie, un bon codec vidéo a toujours besoin de tous les «tricheurs» pratiques et efficaces qu'il peut utiliser. <br><br>  Les filtres sont divisés en plusieurs catégories.  Premièrement, ils peuvent être <b>normatifs</b> ou <b>non normatifs</b> .  Le filtre normatif est une partie obligatoire du codec;  sans elle, il est impossible de décoder correctement la vidéo.  Le filtre non standard est facultatif. <br><br>  Deuxièmement, les filtres diffèrent dans le lieu d'application.  Il existe <b>des</b> filtres de prétraitement (prétraitement) appliqués aux données d'entrée avant le codage, <b>des</b> filtres de <b>post-traitement</b> (post-traitement) appliqués aux données de sortie une fois le décodage terminé, ainsi que des filtres en boucle (filtres de boucle) intégrés au processus de codage.  Les filtres de prétraitement et de post-traitement sont généralement non standard et ne seront pas inclus dans le codec.  Et les filtres de boucle sont normatifs par définition.  Cela fait partie du codec;  ils sont utilisés dans le processus d'optimisation du codage et sont appliqués aux trames de référence ou pour le codage inter-trames. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b85/434/de7/b85434de7b20d5aaca6de32b074d6da3.png"><br><br>  AV1 utilise trois filtres correcteurs réglementaires.  Le premier est un filtre de déblocage pour supprimer le «blocage» - des artefacts évidents le long des bords des blocs codés.  Bien que le DCT soit relativement bien adapté à la compression d'énergie dans les images naturelles, il a toujours tendance à accumuler des erreurs aux bords des blocs.  Si vous vous souvenez, l'élimination de ces artefacts était la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principale raison pour laquelle Daala a utilisé la</a> transformation par rodage.  Mais AV1 est un codec plus traditionnel avec des limites de bloc strictes.  Par conséquent, un filtre de déblocage traditionnel est nécessaire ici pour lisser les artefacts sur les bords des blocs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e14/07e/524/e1407e52496117647c0aa95e5e458b4a.png"><br>  <i><font color="gray">Un exemple d'artefacts aux limites de bloc dans le codec de bloc DCT traditionnel.</font></i>  <i><font color="gray">Ces erreurs sont particulièrement visibles.</font></i> <br><br>  Le dernier des trois filtres est le filtre de restauration de boucle.  Il se compose de deux filtres configurables et remplaçables: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">filtre Wiener</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">filtre</a> auto-guidé.  Ce sont deux filtres convolutionnels qui tentent de construire un noyau pour restaurer partiellement la qualité perdue de l'image d'entrée d'origine.  Ils sont généralement utilisés pour la réduction et / ou la correction du bruit sur les bords des blocs.  Dans le cas de l'AV1, ils effectuent une tâche générale de réduction du bruit, supprimant le bruit DCT de base grâce au flou réglable. <br><br>  Entre eux se trouve un <b>filtre de correction directionnelle limité</b> (Filtre à amélioration directionnelle contraint, CDEF), dont nous parlerons.  Comme le filtre de bouclage, il supprime les artefacts et le bruit de base au niveau des articulations, mais contrairement au filtre de bouclage, il s'agit d'un filtre directionnel.  Contrairement à la plupart des filtres, il ne s'applique pas à tout dans une rangée, mais trouve spécifiquement les limites des blocs.  Par conséquent, CDEF est particulièrement intéressant: c'est le premier filtre directionnel pratique et utile qui est utilisé dans le codage vidéo. <br><br><h1>  Route longue et sinueuse </h1><br>  L'histoire du CDEF ne s'est pas développée facilement.  C'est une longue route avec des virages, des chemins secondaires et des impasses.  Le CDEF rassemble plusieurs articles de recherche, chacun fournissant une idée ou une inspiration pour le filtre final dans AV1. <br><br>  L'intérêt de transformer des blocs de données de pixels à l'aide de transformations DCT et de type DCT est de représenter un bloc de pixels avec le moins de nombres possible.  Le DCT comprime assez bien l'énergie dans la plupart des images, ce qui signifie qu'il a tendance à collecter des motifs de pixels dispersés dans seulement quelques facteurs de sortie importants. <br><br>  Mais il existe des exceptions à l'efficacité de la compression DCT.  Par exemple, DCT ne traduit pas très bien les bordures ou les motifs directionnels.  Si vous regardez la sortie DCT d'un bord diagonal net, les coefficients de sortie forment également ... une diagonale nette!  Il diffère après la conversion, mais est toujours présent dans l'image, bien que généralement sous une forme plus complexe qu'au début.  La compression est en baisse! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/684/ae1/3c7/684ae13c76dd58404f4a66ad1f66460f.png"><br>  <i><font color="gray">Les limites précises sont un problème traditionnel pour les codecs basés sur DCT, car ils ne compressent pas très bien, voire pas du tout.</font></i>  <i><font color="gray">Ici, nous voyons une bordure nette (à gauche) et des coefficients de transformation DCT (à droite).</font></i>  <i><font color="gray">L'énergie de la frontière initiale se propage par DCT dans le motif d'ondulations directionnelles.</font></i> <br><br>  Au cours des deux dernières décennies, la recherche sur les codecs vidéo a de plus en plus examiné les transformations, les filtres et les méthodes de prédiction, qui sont essentiellement directionnels.  Les chercheurs ont cherché un moyen de mieux gérer ces frontières et ces modèles pour corriger cette limitation DCT fondamentale. <br><br><h1>  Prédicteurs directionnels classiques </h1><br>  L'intra-prédiction directionnelle est probablement l'une des méthodes d'action directionnelle les plus connues dans les codecs vidéo modernes.  Tout le monde connaît les modes de prédiction directionnelle h.264 et VP9, ​​où le codec transfère la prévision d'un motif spécifique vers un nouveau bloc basé sur les pixels environnants à partir de blocs déjà décodés.  Le but est d'éliminer (ou de réduire considérablement) l'énergie des bords durs et dirigés <i>avant de</i> convertir le bloc.  En prédisant et en supprimant les fonctionnalités qui ne peuvent pas être compressées, nous augmentons l'efficacité globale du codec. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55f/fa9/836/55ffa9836a87d7c73adc7e20210b5b89.png"><br>  <i><font color="gray">Illustration des modes de prédiction directionnelle en AVC / H.264 pour les blocs 4x4.</font></i>  <i><font color="gray">Le prédicteur étend les valeurs à partir de bandes d'un seul pixel de pixels voisins, les transférant vers le bloc prévu dans l'une des huit directions, plus un mode de moyenne pour une prédiction DC simple</font></i> <br><br>  Une idée encore plus ancienne est la compensation de mouvement.  Il s'agit également d'une forme de prévision directionnelle, même si nous y pensons rarement de cette façon.  Ce mode décale les blocs dans certaines directions, là encore pour prévoir et extraire l'énergie avant l'exécution du DCT.  Ce décalage de bloc est directionnel et filtré.  Comme l'intra-prédiction directionnelle, il applique des filtres de suréchantillonnage soigneusement construits si le décalage n'est pas un nombre entier de pixels. <br><br><h1>  Filtres directionnels </h1><br>  Comme indiqué précédemment, les codecs vidéo appliquent activement des filtres pour supprimer les artefacts de bloc et le bruit.  Bien que les filtres soient appliqués sur le plan 2D, les filtres eux-mêmes fonctionnent généralement en 1D, c'est-à-dire qu'ils sont exécutés horizontalement et verticalement séparément. <br><br>  Le filtrage directionnel déclenche les filtres dans des directions autres qu'horizontales et verticales.  Une telle méthode est déjà courante dans le traitement d'images statiques, où les filtres de réduction du bruit et les superpositions d'effets spéciaux prennent souvent en compte les limites et les directions.  Mais ces filtres directionnels sont souvent basés sur le filtrage de la sortie des transformées directionnelles.  Par exemple, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">filtres de réduction de bruit</a> [légèrement obsolètes] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dont j'ai parlé sont</a> basés sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">double arbre d'ondelettes complexes</a> . <br><br>  Mais pour le codage vidéo, nous nous intéressons surtout aux filtres directionnels, qui sont directement appliqués sur les pixels dans une certaine direction, plutôt que de filtrer le domaine fréquentiel à la sortie d'une conversion directionnelle.  Dès que vous essayez de créer une telle bête, la Grande Question se pose rapidement: comment formaliser une certaine direction autre qu'horizontale et verticale, lorsque les positions du filtre ne sont plus liées aux pixels de la grille? <br><br>  Une option consiste à utiliser l'approche classique utilisée dans le traitement d'image de haute qualité: transformer le noyau du filtre et rééchantillonner (rééchantillonner) l'espace en pixels selon les besoins.  Vous pourriez même dire que c'est la seule réponse «correcte» ou «complète».  Il est utilisé pour compenser le mouvement sous-pixel, où il est impossible d'obtenir un bon résultat sans un bon rééchantillonnage, et également dans la prédiction directionnelle, où une approximation rapide est généralement utilisée. <br><br>  Cependant, même une approximation rapide est coûteuse en termes de ressources de calcul, si elle est appliquée universellement, il est donc conseillé d'éviter le rééchantillonnage, si possible.  Le prix élevé de la vitesse est l'une des raisons pour lesquelles les filtres directionnels n'ont pas encore été appliqués au codage vidéo. <br><br><h1>  Transformations directionnelles </h1><br>  Les conversions directionnelles tentent de résoudre les problèmes DCT avec le compactage des bordures de blocs au niveau de la transformation elle-même. <br><br>  Les expériences dans ce domaine se répartissent en deux catégories.  Il existe des transformations qui utilisent des bases essentiellement directionnelles, telles que des ondelettes directionnelles.  En règle générale, ils sont sujets à une conversion / sur-exhaustivité excessive, c'est-à-dire qu'ils produisent plus de sortie qu'ils n'en reçoivent à l'entrée: généralement beaucoup plus.  C'est comme travailler dans la direction opposée, car nous voulons <i>réduire la</i> quantité de données, pas l'augmenter!  Mais ces conversions compressent toujours l'énergie, et l'encodeur sélectionne toujours un petit sous-ensemble de la sortie pour l'encodage, donc en réalité il y a quelques différences par rapport à l'encodage DCT avec perte habituel.  Cependant, les conversions «trop complètes» nécessitent généralement une quantité excessive de mémoire et de ressources informatiques et ne sont donc pas utilisées dans les codecs vidéo courants. <br><br>  La deuxième catégorie de conversions directionnelles prend des transformations régulières non orientées comme DCT - et les modifie, affectant l'entrée ou la sortie.  Les changements peuvent être effectués sous forme d'échantillonnage répété, de multiplication matricielle (qui peut être considérée comme une forme spécialisée d'échantillonnage répété) ou de jongler avec l'ordre des données d'entrée. <br><br>  <b>Cette dernière idée est la plus forte, car la méthode fonctionne rapidement.</b>  Une simple permutation des nombres ne nécessite aucun calcul mathématique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/905/a6b/ba8/905a6bba85a135c2e7d0d7b0018571d7.png"><br>  <i><font color="gray">Deux exemples de transformations dans différentes directions en réorganisant les pixels et les coefficients, plutôt qu'un re-filtre.</font></i>  <i><font color="gray">Un exemple est tiré de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'enquête sur les transformations directionnelles dans le codage d'image</a> , Jicheng Xu, Bing Zeng, Feng Wu</font></i> <br><br>  La mise en œuvre est compliquée par plusieurs difficultés pratiques.  La réorientation du carré donne un bord diagonal avec des lignes principalement verticales ou horizontales, ce qui conduit à une matrice de nombres non carrés en entrée.  Conceptuellement, ce n'est pas un problème.  Comme vous pouvez commencer à transformer des lignes et des colonnes indépendamment les unes des autres, nous utilisons simplement différentes tailles de DCT 1D pour chaque ligne et colonne, comme indiqué dans la figure ci-dessus.  Mais en pratique, cela signifie que nous aurons besoin d'une factorisation DCT différente pour chaque longueur de colonne possible - et dès que le service de développement matériel le comprendra, vous serez jeté par la fenêtre. <br><br>  Il existe d'autres façons de traiter les zones non carrées après le réarrangement. Vous pouvez proposer des schémas de rééchantillonnage qui enregistrent le carré d'entrée ou fonctionnent uniquement à la sortie.  La plupart des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles sur la conversion directionnelle répertoriés ci-dessous</a> proposent différents schémas à cet effet. <br><br>  Et c'est là que se termine essentiellement l'histoire des transformations dirigées.  Dès que vous contournez diverses complications des conversions directionnelles et créez un véritable filtre, il ne fonctionne normalement pas dans un codec moderne pour une raison inattendue: en raison de la concurrence avec une taille de bloc variable.  Autrement dit, dans un codec avec une taille de bloc fixe, l'ajout de transformations directionnelles donne une augmentation impressionnante de l'efficacité.  Et une taille de bloc variable en elle-même offre des avantages encore plus importants.  Mais la combinaison d'une taille de bloc variable et de transformations directionnelles conduit à un résultat pire que l'utilisation de chacune de ces méthodes individuellement.  La taille de bloc variable a déjà éliminé les redondances utilisées par les transformations directionnelles et l'a même rendue plus efficace. <br><br>  Nathan Egge et moi avons beaucoup expérimenté les transformations directionnelles lors du développement de Daala.  J'ai examiné le problème du côté entrée ainsi que du côté sortie, en utilisant des multiplications matricielles clairsemées pour convertir les bordures diagonales en position verticale / horizontale à la sortie.  Nathan a testé des approches connues des transformations directionnelles en reconstruisant les données d'entrée.  Nous sommes arrivés à une conclusion: la complexité supplémentaire ne donne aucun avantage objectif ou subjectif. <br><br>  L'utilisation de transformations directionnelles dans Daala (et d'autres codecs) pourrait être une erreur, mais la recherche a soulevé une question qui a été mentionnée plus tôt: comment filtrer rapidement le long des frontières sans rééchantillonnage coûteux?  Réponse: pas besoin de rééchantillonner.  Effectuez un zoom avant en vous déplaçant le long du pixel entier le plus proche.  Zoomez sur le noyau transformé en réorganisant littéralement ou conceptuellement les pixels.  Cette approche conduit à une certaine distorsion (aliasing), mais elle fonctionne <i>assez bien</i> et <i>assez rapidement</i> . <br><br><h1>  Prédicteurs directionnels, partie 2: Chroniques de Daala </h1><br>  L'histoire de CDEF dans le codec Daala a commencé avec des tentatives pour faire quelque chose de complètement différent: l'intra-prédiction directionnelle ennuyeuse habituelle.  Ou du moins quelque chose de normal pour le codec Daala. <br><br>  J'ai écrit sur le schéma d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intra-prédiction de Daala dans le domaine des fréquences</a> alors que nous commencions à peine à travailler dessus.  Les mathématiques ici fonctionnent très bien;  aucune raison de s'inquiéter.  Cependant, l'implémentation naïve a nécessité un grand nombre de multiplications matricielles, ce qui était trop cher pour le codec en production.  Nous espérions que la charge de calcul pourrait être réduite d'un ordre de grandeur en raison de la raréfaction - élimination des éléments de la matrice qui ne contribuaient pas beaucoup à la prévision. <br><br>  Mais l'éclaircie ne fonctionne pas comme nous le souhaiterions.  Au moins lorsque nous l'avons implémenté, il a perdu trop d'informations, ce qui rend la technique inadaptée dans la pratique. <br><br>  Bien sûr, Daala avait encore besoin d'une certaine forme d'intra-prédiction, et Jean-Marc Valin a eu l'idée: un codec de prédiction autonome qui fonctionne dans le domaine spatial parallèlement au codec Daala dans le domaine fréquentiel.  En tant que sorte de symbiote, travaillant en tandem, mais non dépendant de Daala, il ne se limite pas aux exigences de Daala pour le domaine fréquentiel.  C'est ainsi qu'est né <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intra Paint</a> . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b91/f2e/4c4/b91f2e4c441094b6057778626c7bcd3c.jpg"></a> <br>  <i><font color="gray">Un exemple d'algorithme de prédiction Intra Paint sur une <a href="">photographie du port de Sydney</a> .</font></i>  <i><font color="gray">La sortie visuelle est clairement directionnelle, correspond bien aux limites des blocs et aux caractéristiques de l'image originale, créant un résultat agréable (peut-être un peu étrange) avec des limites claires</font></i> <br><br>  Le filtre Intra Paint fonctionnait d'une nouvelle manière: il encodait des vecteurs unidimensionnels uniquement le long des limites des blocs, puis exécutait le modèle dans la direction sélectionnée.  C'est comme pulvériser de la peinture, puis l'étaler dans différentes directions dans des zones ouvertes. <br><br>  Intra Paint semblait prometteur et produisait en soi des résultats incroyablement beaux, mais encore une fois s'est avéré insuffisamment efficace pour fonctionner comme un prédicteur standard.  Il n'a tout simplement pas obtenu suffisamment de bits pour encoder ses propres informations. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a61/1c2/ce3/a611c2ce30931494eda138da56e3d715.jpg"></a> <br>  <i><font color="gray">La différence entre la photographie originale du port de Sydney et le résultat d'Intra Paint.</font></i>  <i><font color="gray">Malgré la publication visuellement agréable d'Intra Paint, objectivement, il ne peut pas être qualifié de prédicteur très précis.</font></i>  <i><font color="gray">La différence est assez importante même le long de nombreuses frontières qui semblaient bien conçues</font></i> <br><br>  L '«échec» d'Intra Paint nous a conduit à une autre idée.  Bien que ce «dessin» ne soit objectivement pas un très bon prédicteur, mais subjectivement pour la plupart, il semble bon.  Peut-être utiliser la méthode du «frottis de peinture» comme filtre de post-traitement pour améliorer la qualité visuelle subjective?  Intra Paint suit très bien le long des arêtes vives et devrait donc potentiellement éliminer le bruit qui s'accumule le long des arêtes les plus nettes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De cette idée est né le filtre Paint-Dering original à Daala, qui a finalement conduit au CDEF lui-même. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une autre chose intéressante dans la prévision directionnelle, bien que ce soit actuellement une impasse dans le codage vidéo. David Shlif implémente un filtre de récupération de bordure / direction intéressant appelé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation dirigée par le bord</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(EDI). </font><font style="vertical-align: inherit;">D'autres codecs (comme la série VPx et, à un certain moment, AV1) ont expérimenté des trames de référence réduites pour enregistrer les bits de codage, puis augmenter la résolution. </font><font style="vertical-align: inherit;">Nous espérions qu'avec une résolution accrue, une interpolation EDI considérablement améliorée améliorerait la technique au point qu'elle serait utile. </font><font style="vertical-align: inherit;">Nous espérions également utiliser l'EDI comme un filtre d'interpolation sous-pixel amélioré pour compenser le mouvement. </font><font style="vertical-align: inherit;">Malheureusement, ces idées sont restées un rêve non réalisé.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remplissage de trous, fusion de branches </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'instant, j'ai décrit toutes les conditions de base nécessaires pour approcher le CDEF, mais en réalité nous avons continué à errer dans le désert. Intra Paint a engendré le filtre Daala Paint-Dering d'origine, qui a utilisé l'algorithme Intra-Paint comme un post-filtre pour éliminer les artefacts. Il s'est avéré trop lent à utiliser dans un vrai codec. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, nous avons pris en compte les leçons d'Intra Paint et abandonné les expériences dans ce sens. Daala a emprunté CLPF à Thor pendant un certain temps, puis Jean-Marc a créé un autre filtre Deringing, beaucoup plus rapide, pour Daala, basé sur la recherche de directions aux limites intra-peinture (cela a fonctionné rapidement et bien), ainsi que le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filtre de remplacement conditionnel.</font></font></a> ,   . CRF   -       ,    ,          . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/17c/afc/5e7/17cafc5e7f055b0fbe2be90a6f266297.png"></a> <br> <i><font color="gray">   7-tap        ,        </font></i> <br><br>     Daala     CRF,  7-tap       5-tap.       ,    .     Daala     ,      CDEF. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons récemment proposé Daala comme codec AOM, et ce filtre intermédiaire est devenu une expérience daala_dering AV1. </font><font style="vertical-align: inherit;">Cisco a également présenté son filtre de réduction du bruit, le filtre passe-bas contraint (CLPF) du codec Thor. </font><font style="vertical-align: inherit;">Pendant un certain temps, les deux filtres existaient en parallèle dans l'ensemble expérimental AV1: ils pouvaient être inclus individuellement ou même ensemble. </font><font style="vertical-align: inherit;">Grâce à cela, dans leur travail, il a été possible de constater une synergie utile, ainsi que des similitudes supplémentaires de filtres à différentes étapes du travail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sommes donc finalement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arrivés au CDEF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le filtre Cisco CLPF et la deuxième version du filtre de réduction de bruit Daala ont fusionné en un seul filtre de réduction de bruit haute performance prenant en compte la direction des limites.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CDEF moderne </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le filtre CDEF est simple et très similaire à nos filtres précédents. </font><font style="vertical-align: inherit;">Il se compose de trois parties (recherche directionnelle, filtre à substitution limitée / passe-bas et placement des marques de co-pixel) que nous avons utilisées auparavant. </font><font style="vertical-align: inherit;">Compte tenu de la longue expérience, en regardant le CDEF terminé, vous pouvez demander: «Est-ce tout? </font><font style="vertical-align: inherit;">Où est le reste? " </font><font style="vertical-align: inherit;">CDEF est un exemple de la façon d'obtenir un effet utile en raison de la mise en œuvre correcte des pièces et non en raison de la complexité. </font><font style="vertical-align: inherit;">Un filtre simple et efficace est ce qu'il devrait être.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direction de recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CDEF fonctionne dans une certaine direction, vous devez donc le définir. </font><font style="vertical-align: inherit;">L'algorithme est le même que celui d'Intra Paint et Paint-Dering. </font><font style="vertical-align: inherit;">Il y a huit directions possibles. </font><i><font color="gray"><font style="vertical-align: inherit;">Huit directions possibles pour un filtre CDEF. </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">Les lignes numérotées dans chaque bloc de direction correspondent au paramètre «k» dans la recherche de direction</font></font></i></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b6f/15d/dcd/b6f15ddcddd3d41a382a821e7a7bfc22.png"></a> <br> <i><font color="gray"><font style="vertical-align: inherit;"></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous déterminons la direction du filtre en faisant des variantes «directionnelles» du bloc d'entrée, une pour chaque direction, où tous les pixels le long de la ligne dans la direction sélectionnée sont amenés à la même valeur. Ensuite, nous choisissons la direction dans laquelle le résultat correspond le mieux au bloc source. C'est-à-dire que pour chaque direction d, nous trouvons d'abord la valeur moyenne de pixel dans chaque ligne k, puis le long de chaque ligne, nous résumons l'erreur quadratique entre la valeur de pixel donnée et la valeur moyenne de cette ligne de pixel.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3da/c57/85f/3dac5785f4b82fc775e2fef721fc7983.png"></a> <br> <i><font color="gray">    d,      .           k   .          k    .      ,   ,      .         /</font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons donc l'erreur quadratique totale, et la plus petite erreur quadratique commune est la direction que nous choisirons. </font><font style="vertical-align: inherit;">Bien que l'exemple ci-dessus fasse exactement cela, en réalité, il n'est pas nécessaire de convertir l'erreur quadratique en dispersion: dans chaque direction, le même nombre de pixels, donc les deux choisiront la même réponse. </font><font style="vertical-align: inherit;">Moins de calcul! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un moyen intuitif et long de calculer les erreurs directionnelles. </font><font style="vertical-align: inherit;">L'usinage peut être simplifié par l'équation suivante:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/955/f9b/641/955f9b6418973dcbf000cab3ae860d64.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette formule </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>E</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.776ex" height="2.057ex" viewBox="0 -780.1 764.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-45" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> E </script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-70" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">p</script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>p</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.389ex" height="2.057ex" viewBox="0 -520.7 1028.5 885.9" role="img" focusable="false" style="vertical-align: -0.848ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-70" x="809" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>p</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-3">x_p</script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> k </script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>d</mi><mo>,</mo><mi>k</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.272ex" height="2.66ex" viewBox="0 -780.1 1839.4 1145.2" role="img" focusable="false" style="vertical-align: -0.848ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-4E" x="0" y="0"></use><g transform="translate(803,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMAIN-2C" x="523" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-6B" x="802" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mi>d</mi><mo>,</mo><mi>k</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-5">N_{d, k}</script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> k </script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.216ex" height="2.057ex" viewBox="0 -780.1 523.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-64" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> d </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette équation peut être simplifiée dans la pratique. </font><font style="vertical-align: inherit;">Par exemple, le premier terme est le même pour chaque</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.216ex" height="2.057ex" viewBox="0 -780.1 523.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-64" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> d </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fin de compte, la mise en œuvre de AV1 CDEF nécessite actuellement 5,875 ajouts et 1,9375 multiplications par pixel et est profondément vectorisée, ce qui entraîne un coût total inférieur à 8 × 8 DCT. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Robinets de filtre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le filtre CDEF fonctionne pixel par pixel dans un bloc complet. </font></font> Direction <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.216ex" height="2.057ex" viewBox="0 -780.1 523.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-64" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-9"> d </script><br><br><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/164/aad/bb4164aad02b4985390da15b1b3bea6f.png"></div><br> <i><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direction des filtres unidimensionnels primaire et secondaire par rapport à la direction sélectionnée d. Le filtre principal démarre dans la direction sélectionnée, les filtres secondaires fonctionnent à un angle de 45 ° par rapport à la direction principale. Chaque pixel du bloc est filtré de manière égale. Les</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filtres fonctionnent à des angles tels que les marques idéales tombent souvent entre les pixels. Au lieu de rééchantillonner, nous sélectionnons l'emplacement exact du pixel le plus proche, en tenant compte du noyau symétrique du filtre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque étiquette du filtre a également le même poids. Pendant le filtrage, sa valeur d'entrée est fournie à l'entrée, puis la fonction de contrainte est appliquée, puis le résultat est multiplié par le poids fixe de l'étiquette et cette valeur de sortie est ajoutée au pixel filtré.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6eb/6fa/217/6eb6fa217d0c2f33e6e2687232757e71.png"></a> <br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les emplacements des marques primaires et secondaires (robinets) et des poids fixes (w) dans les directions du filtre. </font><font style="vertical-align: inherit;">Pour les marques primaires et les valeurs paires de force a = 2 et b = 4, tandis que pour les marques impaires a = 3 et b = 3. Le pixel filtré est affiché en gris.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En pratique, les filtres primaire et secondaire ne fonctionnent pas séparément, mais sont combinés en un seul noyau de filtre, qui s'effectue en une seule étape.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonction de restriction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CDEF utilise un </font><font style="vertical-align: inherit;">filtre passe-bas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limité</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans lequel la valeur de chaque étiquette est d'abord traitée </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonction de contrainte avec le paramètre de différence entre la valeur de l'étiquette et le pixel filtré</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.216ex" height="2.057ex" viewBox="0 -780.1 523.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-64" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-10"> d </script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-11">S</script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.924ex" height="2.057ex" viewBox="0 -780.1 828.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-44" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi></math></span></span><script type="math/tex" id="MathJax-Element-12">D</script>  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/735/f0c/d2d/735f0cd2d0160693b784e59c0c58fce0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction de restrictions est conçue pour réduire ou abandonner complètement le traitement des pixels qui ne sont pas trop différents des pixels filtrés. </font><font style="vertical-align: inherit;">Dans la plage définie, les différences entre les valeurs des marques du pixel central (qui sont déterminées par le paramètre de force</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-13">S</script>  )<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si la différence de valeurs se situe dans la plage entre les paramètres </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-14">S</script>  et <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.924ex" height="2.057ex" viewBox="0 -780.1 828.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-44" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi></math></span></span><script type="math/tex" id="MathJax-Element-15">D</script><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.924ex" height="2.057ex" viewBox="0 -780.1 828.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-44" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi></math></span></span><script type="math/tex" id="MathJax-Element-16">D</script><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4f2/97e/e4c/4f297ee4c83fc9e7fa9eb4b280877b97.png"></a> <br> <i><font color="gray"></font></i> <br><br><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b13/7a8/408/b137a84082c7fa7ef4e18b1e4b685e6e.png"></a> <br><br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.979ex" height="2.66ex" viewBox="0 -832 1282.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-70" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMAIN-29" x="893" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-17">(p)</script>  et <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.9ex" height="2.66ex" viewBox="0 -832 1248.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMATHI-73" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/416049/&amp;usg=ALkJrhggoQVLS5clzjNNLa0YM7OeTuVJ7g#MJMAIN-29" x="859" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-18">(s)</script><i></i><i></i><br><br><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a><br><br><h1>  Résultats </h1><br>  CDEF est conçu pour supprimer ou réduire le bruit de base et les artefacts de sonnerie sur les bords nets d'une image sans flou ni dommage.  Le filtre est maintenant utilisé dans AV1 et donne un effet subtil mais cohérent.  Peut-être qu'à l'avenir, il sera possible de s'appuyer encore plus sur le CDEF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/3df/c87/7433dfc87595e78a8054fe7d954c950f.jpg"><br>  <i><font color="gray">Un exemple de réduction du bruit et d'artefacts lors de l'encodage d'images <a href="">Fruits</a> .</font></i>  <i><font color="gray">Le premier encart montre la zone sans traitement CDEF, le second montre la même zone après le traitement CDEF</font></i> <br><br>  La valeur quantitative de tout filtre correctif <i>doit être</i> déterminée par des tests subjectifs.  Les métriques objectives ne doivent pas être actualisées, mais le CDEF est conçu pour fournir un résultat qui dépasse les capacités des outils de test objectif primitifs tels que PSNR et SSIM. <br><br>  Ainsi, nous avons effectué plusieurs séries de tests subjectifs, d'abord pendant le développement du CDEF (lorsque Daala Dering et Thor CLPF étaient encore techniquement concurrents), puis avons effectué des tests plus complets du filtre CDEF combiné.  Puisqu'il s'agit d'un nouveau filtre qui est complètement absent dans les générations précédentes de codecs, les tests consistaient principalement en AV1 avec CDEF activé et AV1 sans CDEF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed2/f03/0ef/ed2f030eff2e6b1dce67a8122b6cbbb2.png"><br>  <i><font color="gray">Résultats de test subjectif AV1 A / B avec CDEF et AV1 sans CDEF pour une configuration à latence élevée</font></i> <br><br>  Les résultats subjectifs montrent une amélioration statistiquement significative (p &lt;0,05) dans trois des six clips.  En règle générale, cela correspond à une augmentation de l'efficacité de codage de 5 à 10%.  Il s'agit d'une victoire assez importante pour un outil ajouté à un codec entièrement mature. <br><br>  Comme prévu, les tests objectifs ont montré une augmentation plus modeste d'environ 1%, mais ils ne sont utiles que dans la mesure où ils sont cohérents avec les résultats subjectifs.  Les tests subjectifs sont l'étalon-or et les résultats subjectifs sont assez clairs. <br><br>  Les tests ont également montré que CDEF fonctionne mieux si des outils de codec supplémentaires sont désactivés pendant le codage.  Comme les transformations directionnelles, le CDEF est en concurrence avec d'autres méthodes AV1 plus complexes.  Le CDEF étant un filtre simple, petit et rapide, il pourrait être utile à l'avenir de réduire la complexité des encodeurs AV1.  En termes de complexité du décodeur, le CDEF représente 3% à 10% du décodeur AV1, selon la configuration. <br><br><a name="1"></a><h1>  Ressources supplémentaires </h1><br><ol><li>  Suites de tests <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">standard derf</a> Xiph.Org sur media.xiph.org </li><li>  Système de test automatisé et métriques utilisés dans le développement de Daala et AV1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Sommes-nous déjà compressés?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filtre d'amélioration directionnel contraint (CDEF) dans AV1</a> .  Steinar Midtskogen, Jean-Marc Valin, octobre 2017 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diapositives de présentation du CDEF pour ICASSP 2018</a> , Steinar Midtskogen, Jean-Marc Valin </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filtre effrayant pour Daala et développement ultérieur</a> .  Jean-Marc Valin.  Le filtre de réduction du bruit précédent créé lors du développement du codec Daala, qui a été utilisé pour créer le CDEF dans AV1. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Daala: coloriages pour le plaisir et le bien</a> .  Jean-Marc Valin.  Un filtre de correction encore plus ancien pour la base Intra-Paint, qui a conduit à la création d'un filtre de réduction du bruit à Daala, qui à son tour a conduit au CDEF </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filtre d'intersection de peinture</a> .  Jean-Marc Valin, 2015. Notes sur le filtre de correction de réduction du bruit issu de l'expérience Intra Paint à Daala </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Filtrage d'image guidé</a> .  Caiming Hye, Jian San, Xiaou Tang, 2013 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformation en ondelettes discrète adaptative directionnelle pour la compression d'image</a> .  Chuo-Ling Chang, Bernd Girod, Transactions IEEE sur le traitement d'images, volume 16, numéro 5, mai 2007 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations adaptatives directionnelles pour le partage d'images</a> .  Chuo-Ling Chang, thèse de doctorat à l'Université de Stanford, 2009. Cette thèse donne un bon aperçu du domaine des transformations directionnelles à partir de 2009;  Malheureusement, aucune copie n'était disponible en ligne </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conversion de blocage adaptatif directionnel pour coder une image couleur</a> .  Chuo-Ling Chang, Mina Makar, Sam S. Tsai, Bernd Girod, Transactions IEEE on Image Processing, Volume 19, Numéro 7, juillet 2010 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Basé sur un circuit DCT avec prédiction DC et codage adaptatif</a> .  Zhibo Chen, Xiaozhong Xu.  L'article derrière l'IEEE </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations adaptatives directionnelles pour la prédiction de codage résiduel</a> .  Robert Cohen, Sven Klomp, Anthony Vetro, Huifan Sun.  Actes de la 17e Conférence internationale IEEE 2010 sur le traitement d'images, 26-29 septembre 2010, Hong Kong </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformation orthogonale sélective en orientation avec chevauchement</a> .  Dietmar Kunz, 2008. Article par l'IEEE </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse vitesse-distorsion des ondelettes directionnelles</a> .  Arian Maleki, Boshra Rajay, Hamid Reza Purreza.  Transactions IEEE sur le traitement d'images, Volume 21, Numéro 2, février 2012 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse théorique des tendances des tendances des transformations orthogonales directionnelles</a> .  Shogo Murumatsu, Dandan Khan, Tomoya Kobayashi, Hisakazu Kikuchi.  Un article derrière le paywall IEEE.  Cependant, une version courte est disponible gratuitement. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un aperçu des transformations directionnelles dans le codage d'image</a> .  Jicheng Xu, Bing Zeng, Feng Wu. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conversion avec filtrage directionnel pour la compression d'image et les informations inter-images</a> .  Xulian Peng, Jicheng Xu, Feng Wu, IEEE Transaction in Image Processing, Volume 19, Numéro 11, novembre 2010. Article par IEEE Firewall </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Approximation et compression utilisant des transformations orthonormées clairsemées</a> .  O. G. Sezer, O. G. Guleruz, Yusel Altunbasak, 2008 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étude fiable des transformations partagées bidimensionnelles pour les codecs vidéo de nouvelle génération</a> .  O. G. Cezer, R. Cohen, A. Vetro, mars 2011 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation conjointe basée sur la rareté d'un ensemble de transformées de blocs partagés bidimensionnels orthonormés</a> .  Joel Sole, Peng Yin, Yunfei Zheng, Christina Gomila, 2009. Article par IEEE </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations de chevauchement directionnel pour le codage d'image</a> .  Jicheng Xu, Feng Wu, Jie Liang, Wenjun Zhang, Transactions IEEE on Image Processing, avril 2008 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les transformées en cosinus discrètes directionnelles sont un nouveau cadre pour le codage d'image</a> .  Bing Zeng, Jingjing Fu, Transactions IEEE sur les circuits et les systèmes de technologie vidéo, avril 2008 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Double arbre de transformées en ondelettes complexes</a> .  Ivan Seleznik, Richard Baranyuk, Nick Kingsbury, IEEE Signal Processing Magazine, novembre 2005 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416049/">https://habr.com/ru/post/fr416049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416035/index.html">Scanner 3D dentaire Shining 3D Autoscan DS EX (Unboxing) by 3Dtool</a></li>
<li><a href="../fr416037/index.html">Démarrage de la journée (avril-juin 2018)</a></li>
<li><a href="../fr416043/index.html">Les pays en développement explorent de plus en plus l'espace.</a></li>
<li><a href="../fr416045/index.html">Onduleur en ligne APC Smart-UPS SRC1KI: la fiabilité avant tout</a></li>
<li><a href="../fr416047/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 2: «Contrôle des attaques de pirates», partie 2</a></li>
<li><a href="../fr416051/index.html">Mitap d'été Apache Ignite à Moscou</a></li>
<li><a href="../fr416053/index.html">Modulation d'amplitude d'un signal arbitraire</a></li>
<li><a href="../fr416055/index.html">Affectation et prise en charge du nom de domaine complet du serveur 3QX</a></li>
<li><a href="../fr416059/index.html">Mobio s'entretient avec Daniil Shuleiko (Yandex.Taxi) sur la fusion avec Uber, le marché des taxis et la concurrence</a></li>
<li><a href="../fr416061/index.html">Tant bien que mal, je vois tout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>