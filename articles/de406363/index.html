<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôÇÔ∏è ‚ôæ üå≥ Analyse von Kryptow√§hrungsm√§rkten mit Python üôèüèº üêà üëÅÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie verhalten sich die Bitcoin-M√§rkte? Was sind die Gr√ºnde f√ºr den pl√∂tzlichen Anstieg und Abfall der Kryptow√§hrungspreise? Gibt es eine enge untrennb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse von Kryptow√§hrungsm√§rkten mit Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/406363/">  <i>Wie verhalten sich die Bitcoin-M√§rkte?</i>  <i>Was sind die Gr√ºnde f√ºr den pl√∂tzlichen Anstieg und Abfall der Kryptow√§hrungspreise?</i>  <i>Gibt es eine enge untrennbare Verbindung zwischen den Altcoin-M√§rkten oder sind sie gr√∂√ütenteils unabh√§ngig voneinander?</i>  <i>Wie k√∂nnen wir vorhersagen, was in Zukunft passieren wird?</i> <br><br><img src="https://habrastorage.org/web/74a/6d8/70f/74a6d870fa77478e950c47b297fe13c8.jpg" alt="Bild"><br><br><h3>  Informationsanalytischer Ansatz zum Denken in Kryptow√§hrung </h3><br>  Artikel, die Kryptow√§hrungen wie Bitcoin und Ethereum gewidmet sind, sind reich an Argumenten und Theorien.  Hunderte von selbsternannten Experten argumentieren f√ºr Trends, von denen sie glauben, dass sie sich bald zeigen werden.  Was vielen solcher Analysen mit Sicherheit fehlt, ist eine solide Grundlage in Form von Daten und Statistiken, die bestimmte Aussagen st√ºtzen k√∂nnen. <br><br>  Der Zweck dieses Artikels ist eine einfache Einf√ºhrung in die Kryptow√§hrungsanalyse mit Python.  Darin werden wir uns Schritt f√ºr Schritt ein einfaches Python-Skript zum Empfangen, Analysieren und Visualisieren von Daten in verschiedenen Kryptow√§hrungen ansehen.  Im Laufe der Arbeit werden wir einen interessanten Trend im Verhalten volatiler M√§rkte entdecken und herausfinden, welche Ver√§nderungen in ihnen eingetreten sind. <br><a name="habracut"></a><br> <a href=""><img src="https://habrastorage.org/web/8f9/37a/f50/8f937af50b104ff585b4571e1ae923a1.png" alt="Bild"></a> <br><br>  In diesem Beitrag wird nicht erkl√§rt, was Kryptow√§hrungen sind (wenn Sie eine solche Erkl√§rung ben√∂tigen, w√ºrde ich Ihnen diese hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewertung</a> empfehlen).  Es wird keine Diskussion dar√ºber geben, welche bestimmten W√§hrungen an Wert gewinnen oder fallen werden.  Stattdessen konzentriert sich der Leitfaden darauf, Zugriff auf grobe Rohdaten zu erhalten und den Verlauf unter Zahlenschichten zu finden. <br><br><h3>  Stufe 1. Wir r√ºsten unser Labor aus </h3><br>  Dieser Leitfaden richtet sich an eine breite Palette von Enthusiasten, Ingenieuren und Datenverarbeitungsfachleuten, unabh√§ngig von ihrer Professionalit√§t.  Von den F√§higkeiten ben√∂tigen Sie nur ein grundlegendes Verst√§ndnis von Python und die minimalen Befehlszeilenf√§higkeiten, die zum Konfigurieren des Projekts erforderlich sind. <br><br>  Die Vollversion der geleisteten Arbeit und alle Ergebnisse finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h4>  1.1 Installieren Sie Anaconda </h4><br>  Der einfachste Weg, Abh√§ngigkeiten f√ºr dieses Projekt von Grund auf neu zu installieren, ist die Verwendung von Anaconda, einem Python-√ñkosystem und Abh√§ngigkeitsmanager, der alle erforderlichen Pakete enth√§lt, um mit Daten zu arbeiten und diese zu analysieren. <br><br>  F√ºr die Installation von Anaconda w√ºrde ich empfehlen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbaren offiziellen Anweisungen zu verwenden. <br><br>  <i>Wenn Sie ein fortgeschrittener Benutzer sind und Anaconda nicht Ihren W√ºnschen entspricht, ist eine Installation nicht erforderlich.</i>  <i>In diesem Fall ben√∂tigen Sie meiner Meinung nach keine Hilfe bei der Installation der erforderlichen Abh√§ngigkeiten, und Sie k√∂nnen direkt zur zweiten Stufe √ºbergehen.</i> <br><br><h4>  1.2 Einrichten der Projektumgebung in Anaconda </h4> <br>  Sobald Anaconda installiert ist, m√∂chten wir eine neue Umgebung f√ºr die Organisation der Arbeit mit Abh√§ngigkeiten erstellen. <br><br>  Geben Sie den Befehl <code>conda create --name cryptocurrency-analysis python=3</code> , um eine neue Anaconda-Umgebung f√ºr unser Projekt zu erstellen. <br><br>  <code>source activate cryptocurrency-analysis</code> N√§chstes die <code>source activate cryptocurrency-analysis</code> und (unter Linux / macOS) oder <code>activate cryptocurrency-analysis</code> (unter Windows), um die Umgebung zu aktivieren. <br><br>  Und schlie√ülich <code>conda install numpy pandas nb_conda jupyter plotly quandl</code> die erforderlichen Abh√§ngigkeiten in der Umgebung.  Dieser Vorgang kann einige Minuten dauern. <br><br>  <i>Warum nutzen wir die Umwelt?</i>  <i>Wenn Sie gleichzeitig mit vielen Python-Projekten auf Ihrem Computer arbeiten m√∂chten, ist es hilfreich, die Abh√§ngigkeiten (Softwarebibliotheken und Pakete) separat zu platzieren, um Konflikte zu vermeiden.</i>  <i>Innerhalb jedes Projekts erstellt Anaconda ein spezielles Verzeichnis f√ºr Abh√§ngigkeiten in der Umgebung, in dem Sie sie von den Abh√§ngigkeiten anderer Projekte trennen und die Arbeit mit ihnen organisieren k√∂nnen.</i> <br><br><h4>  1.3 Starten des Jupyter Notebook Interactive Notebook </h4><br>  <code>jupyter notebook</code> nach der Installation der Umgebung und der Abh√§ngigkeiten in der Konsole <code>jupyter notebook</code> ein, um den iPython-Kernel zu starten, und √∂ffnen Sie den Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 8888 /</a> im Browser.  Erstellen Sie ein neues Python-Notizbuch und √ºberpr√ºfen Sie, ob es den <code>Python [conda env:cryptocurrency-analysis]</code> Kernel verwendet <code>Python [conda env:cryptocurrency-analysis]</code> . <br><br><img src="https://habrastorage.org/web/6ff/35b/ada/6ff35badacfd44c58a1c4e3f55a3dd9f.png" alt="Bild"><br><br><h4>  1.4 Abh√§ngigkeiten an den oberen Rand des Notebooks importieren </h4><br>  Sobald Sie ein sauberes Jupyter-Protokoll sehen, m√ºssen Sie zuerst die erforderlichen Abh√§ngigkeiten importieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> quandl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime</code> </pre> <br>  Au√üerdem m√ºssen Sie Plotly importieren und den Offline-Modus daf√ºr aktivieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.offline <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.graph_objs <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.figure_factory <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ff py.init_notebook_mode(connected=True)</code> </pre> <br><h3>  Stufe 2. Abrufen von Bitcoin-Preisdaten </h3><br>  Nachdem alle Einstellungen abgeschlossen sind, k√∂nnen wir Informationen zur Analyse empfangen.  Zun√§chst m√ºssen wir Bitcoin-Preisdaten mit der kostenlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin-API Quandl anfordern</a> . <br><br><h4>  2.1 Definieren Sie eine Quandl-Hilfsfunktion </h4><br>  Um die Datenerfassung zu erleichtern, definieren wir eine Funktion, mit der Datens√§tze von Quandl heruntergeladen und zwischengespeichert werden k√∂nnen. <br><br><pre> <code class="javascript hljs">def get_quandl_data(quandl_id): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache Quandl dataseries'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> cache_path = <span class="hljs-string"><span class="hljs-string">'{}.pkl'</span></span>.format(quandl_id).replace(<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(quandl_id)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {} from Quandl'</span></span>.format(quandl_id)) df = quandl.get(quandl_id, returns=<span class="hljs-string"><span class="hljs-string">"pandas"</span></span>) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(quandl_id, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br>  Um die heruntergeladenen Daten zu konvertieren und in einer Datei zu speichern, verwenden wir <code>pickle</code> .  Dadurch wird verhindert, dass bei jeder Ausf√ºhrung des Skripts dieselben Daten erneut heruntergeladen werden.  Die Funktion gibt Daten als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas</a> -Datenrahmen zur√ºck.  Wenn Sie mit Datenrahmen nicht vertraut sind, k√∂nnen Sie sie in Form sehr leistungsf√§higer Tabellenkalkulationen darstellen. <br><br><h4>  2.2 Wir beziehen Preisdaten von der Kraken-B√∂rse </h4><br>  Lassen Sie uns zun√§chst die historischen Daten zum Bitcoin-Wechselkurs von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kraken-</a> B√∂rse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen</a> . <br><br><pre> <code class="javascript hljs"># Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(<span class="hljs-string"><span class="hljs-string">'BCHARTS/KRAKENUSD'</span></span>)</code> </pre> <br>  Wir k√∂nnen die ersten 5 Zeilen des Datenrahmens mit der <code>head()</code> -Methode √ºberpr√ºfen. <br><br><pre> <code class="javascript hljs">btc_usd_price_kraken.head()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4c5/ee0/33f/4c5ee033ffe44eba96c137f6a3f3a828.PNG" alt="Bild"></a> <br><br>  Als N√§chstes erstellen wir ein einfaches Diagramm zur schnellen visuellen √úberpr√ºfung der Richtigkeit der Daten. <br><br><pre> <code class="javascript hljs"># Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[<span class="hljs-string"><span class="hljs-string">'Weighted Price'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/934/c62/911/934c6291184b430bac5a2cd2fcfc01af.png" alt="Bild"></a> <br><br>  Zur Visualisierung wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier Plotly</a> verwendet.  Dies ist ein weniger traditioneller Ansatz im Vergleich zu den ma√ügeblicheren Python-Visualisierungsbibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matplotlib</a> , aber meiner Meinung nach ist Plotly eine ausgezeichnete Wahl, da Sie damit mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D3.js</a> vollst√§ndig interaktive Grafiken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen k√∂nnen.</a>  Als Ergebnis erhalten Sie am Ausgang sch√∂ne visuelle Diagramme ohne Einstellungen.  Dar√ºber hinaus ist Plotly leicht zu erlernen und die Ergebnisse lassen sich leicht in Webseiten einf√ºgen. <br><br>  <i>Nat√ºrlich sollten Sie immer daran denken, dass Sie die resultierenden Visualisierungen mit √∂ffentlich verf√ºgbaren Kryptow√§hrungs-Preisdiagrammen (z. B. auf Coinbase) vergleichen m√ºssen, um die Zuverl√§ssigkeit der heruntergeladenen Daten grundlegend zu √ºberpr√ºfen.</i> <br><br><h4>  2.3 Preisdaten von anderen BTC-B√∂rsen anfordern </h4><br>  M√∂glicherweise haben Sie Abweichungen in diesem Satz festgestellt: Die Grafik sinkt an mehreren Stellen auf Null, insbesondere Ende 2014 und Anfang 2016. Diese R√ºckg√§nge sind im Kraken-Datensatz enthalten, und wir m√∂chten nat√ºrlich nicht, dass sie in unserer endg√ºltigen Preisanalyse ber√ºcksichtigt werden. <br><br>  Die Art der Bitcoin-B√∂rsen ist so, dass die Preise durch Angebot und Nachfrage bestimmt werden. Daher kann keine der bestehenden B√∂rsen behaupten, dass ihre Quotes den einzig wahren ‚ÄûReferenzpreis‚Äú von Bitcoin widerspiegeln.  Um diesen Nachteil zu ber√ºcksichtigen und den Preisverfall auf dem Chart zu beseitigen, der h√∂chstwahrscheinlich auf technische Fehler oder Datensatzfehler zur√ºckzuf√ºhren ist, werden wir zus√§tzlich Daten von drei anderen gro√üen Bitcoin-B√∂rsen sammeln, um den Gesamtpreisindex f√ºr Bitcoin zu berechnen. <br><br>  Laden Sie zun√§chst die Daten von jedem Austausch in ein W√∂rterbuch mit Datenrahmen herunter. <br><br><pre> <code class="javascript hljs"># Pull pricing data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> more BTC exchanges exchanges = [<span class="hljs-string"><span class="hljs-string">'COINBASE'</span></span>,<span class="hljs-string"><span class="hljs-string">'BITSTAMP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ITBIT'</span></span>] exchange_data = {} exchange_data[<span class="hljs-string"><span class="hljs-string">'KRAKEN'</span></span>] = btc_usd_price_kraken <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> exchange <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> exchanges: exchange_code = <span class="hljs-string"><span class="hljs-string">'BCHARTS/{}USD'</span></span>.format(exchange) btc_exchange_df = get_quandl_data(exchange_code) exchange_data[exchange] = btc_exchange_df</code> </pre> <br><h4>  2.4 Alle Preisdaten in einem Datenrahmen zusammenfassen </h4><br>  Als n√§chstes definieren wir eine einfache Funktion, die die √§hnlichen Spalten jedes Datenrahmens zu einem neuen kombinierten Rahmen kombiniert. <br><br><pre> <code class="javascript hljs">def merge_dfs_on_column(dataframes, labels, col): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Merge a single column of each dataframe into a new combined dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> series_dict = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(dataframes)): series_dict[labels[index]] = dataframes[index][col] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pd.DataFrame(series_dict)</code> </pre> <br>  Kombinieren wir nun alle Datenrahmen basierend auf der Spalte Gewichteter Preis. <br><br><pre> <code class="javascript hljs"># Merge the BTC price dataseries<span class="hljs-string"><span class="hljs-string">' into a single dataframe btc_usd_datasets = merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()), '</span></span>Weighted Price<span class="hljs-string"><span class="hljs-string">')</span></span></code> </pre> <br>  Schauen Sie sich zum Schluss die letzten f√ºnf Zeilen mit der <code>tail()</code> -Methode an, um sicherzustellen, dass das Ergebnis unserer Arbeit normal aussieht. <br><br><pre> <code class="javascript hljs">btc_usd_datasets.tail()</code> </pre> <br><img src="https://habrastorage.org/web/dff/f3c/661/dfff3c661b494648bfc0d2675d260f40.png" alt="Bild"><br><br>  Die Preise sehen wie erwartet aus: Sie liegen innerhalb √§hnlicher Grenzen, es gibt jedoch geringf√ºgige Unterschiede in Bezug auf das Verh√§ltnis von Angebot und Nachfrage an jeder einzelnen B√∂rse. <br><br><h4>  2.5 Preisdatens√§tze visualisieren </h4><br>  Der n√§chste logische Schritt besteht darin, den Vergleich der resultierenden Datens√§tze zu visualisieren.  Zu diesem Zweck definieren wir eine Hilfsfunktion, mit der mithilfe eines einzeiligen Befehls ein Diagramm basierend auf einem Datenrahmen erstellt werden kann. <br><br><pre> <code class="javascript hljs">def df_scatter(df, title, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">''</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'linear'</span></span>, initial_hide=False): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Generate a scatter plot of the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> label_arr = list(df) series_arr = list(map(lambda col: df[col], label_arr)) layout = go.Layout( title=title, legend=dict(orientation=<span class="hljs-string"><span class="hljs-string">"h"</span></span>), xaxis=dict(type=<span class="hljs-string"><span class="hljs-string">'date'</span></span>), yaxis=dict( title=y_axis_label, showticklabels= not seperate_y_axis, type=scale ) ) y_axis_config = dict( overlaying=<span class="hljs-string"><span class="hljs-string">'y'</span></span>, showticklabels=False, type=scale ) visibility = <span class="hljs-string"><span class="hljs-string">'visible'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> initial_hide: visibility = <span class="hljs-string"><span class="hljs-string">'legendonly'</span></span> # Form Trace For Each Series trace_arr = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, series <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(series_arr): trace = go.Scatter( x=series.index, y=series, name=label_arr[index], visible=visibility ) # Add seperate axis <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the series <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seperate_y_axis: trace[<span class="hljs-string"><span class="hljs-string">'yaxis'</span></span>] = <span class="hljs-string"><span class="hljs-string">'y{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>) layout[<span class="hljs-string"><span class="hljs-string">'yaxis{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>)] = y_axis_config trace_arr.append(trace) fig = go.Figure(data=trace_arr, layout=layout) py.iplot(fig)</code> </pre> <br>  Der K√ºrze halber werde ich nicht n√§her auf die Funktionsweise einer Hilfsfunktion eingehen.  Wenn Sie mehr dar√ºber erfahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten, lesen Sie die Dokumentation zu</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plotly</a> . <br><br>  Wir k√∂nnen leicht ein Diagramm f√ºr Bitcoin-Preisdaten erstellen. <br><br><pre> <code class="javascript hljs"># Plot all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the BTC exchange prices df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/1b5/f48/c9e/1b5f48c9ec2e4257a281ec2632dbec76.png" alt="Bild"><br></a> <br><h4>  2.6 Bereinigen und Kombinieren von Preisdaten </h4><br>  Wir k√∂nnen sehen, dass trotz der Tatsache, dass sich alle 4 Datenreihen ungef√§hr gleich verhalten, es einige Abweichungen von der Norm gibt, die beseitigt werden m√ºssen. <br><br>  Entfernen wir alle Nullwerte aus dem Frame, da wir wissen, dass der Preis f√ºr Bitcoin in dem von uns betrachteten Zeitraum nie Null war. <br><br><pre> <code class="javascript hljs"># Remove <span class="hljs-string"><span class="hljs-string">"0"</span></span> values btc_usd_datasets.replace(<span class="hljs-number"><span class="hljs-number">0</span></span>, np.nan, inplace=True)</code> </pre> <br>  Nachdem wir das Diagramm erneut erstellt haben, erhalten wir eine sauberere Kurve ohne scharfe Einbr√ºche. <br><br><pre> <code class="javascript hljs"># Plot the revised dataframe df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/d24/960/13e/d2496013e0ca41e1acd421ff44b97cd0.png" alt="Bild"></a> <br><br>  Und jetzt k√∂nnen wir eine neue Spalte berechnen, die den durchschnittlichen t√§glichen Bitcoin-Preis basierend auf Daten aller B√∂rsen enth√§lt. <br><br><pre> <code class="javascript hljs"># Calculate the average BTC price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>] = btc_usd_datasets.mean(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Diese neue Spalte ist unser Bitcoin-Preisindex!  Zeichnen wir es, um sicherzustellen, dass es normal aussieht. <br><br><pre> <code class="javascript hljs"># Plot the average BTC price btc_trace = go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/fad/289/9de/fad2899de9c14304a8964df909a9883f.png" alt="Bild"></a> <br><br>  Ja, es sieht gut aus.  Wir werden die kombinierten Preisreihen in Zukunft verwenden, um die Wechselkurse anderer Kryptow√§hrungen in US-Dollar umzurechnen. <br><br><h3>  Stufe 3. Abrufen von Altcoin-Preisdaten </h3><br>  Nachdem wir nun eine zuverl√§ssige Zeitreihe von Preisen f√ºr Bitcoin haben, fordern wir einige Daten f√ºr Nicht-Bitcoin-Kryptow√§hrungen an, die oft als Altcoins bezeichnet werden. <br><br><h4>  3.1 Hilfsfunktionen f√ºr die Arbeit mit der Poloniex-API definieren </h4><br>  Um Altcoin-Daten zu erhalten, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Poloniex-API</a> .  Zwei Hilfsfunktionen, die an diese API √ºbergebene JSON-Daten herunterladen und zwischenspeichern, helfen uns dabei. <br><br>  Zun√§chst definieren wir <code>get_json_data</code> , mit dem JSON-Daten unter der angegebenen URL heruntergeladen und zwischengespeichert werden. <br><br><pre> <code class="javascript hljs">def get_json_data(json_url, cache_path): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache JSON data, return as a dataframe.'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(json_url)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {}'</span></span>.format(json_url)) df = pd.read_json(json_url) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(json_url, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br>  Als N√§chstes definieren wir eine Funktion, die HTTP-Anforderungen an die Poloniex-API generiert und dann <code>get_json_data</code> , die wiederum die angeforderten Daten speichert. <br><br><pre> <code class="javascript hljs">base_polo_url = <span class="hljs-string"><span class="hljs-string">'https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}'</span></span> start_date = datetime.strptime(<span class="hljs-string"><span class="hljs-string">'2015-01-01'</span></span>, <span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) # get data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the start <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2015</span></span> end_date = datetime.now() # up until today pediod = <span class="hljs-number"><span class="hljs-number">86400</span></span> # pull daily data (<span class="hljs-number"><span class="hljs-number">86</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span> seconds per day) def get_crypto_data(poloniex_pair): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Retrieve cryptocurrency data from poloniex'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> json_url = base_polo_url.format(poloniex_pair, start_date.timestamp(), end_date.timestamp(), pediod) data_df = get_json_data(json_url, poloniex_pair) data_df = data_df.set_index(<span class="hljs-string"><span class="hljs-string">'date'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_df</code> </pre> <br>  Sie nimmt eine Zeichenfolge, die das Kryptow√§hrungspaar angibt (z. B. BTC_ETH), und gibt einen Datenrahmen zur√ºck, der historische Daten zum Wechselkurs enth√§lt. <br><br><h4>  3.2 Handelsdaten mit Poloniex herunterladen </h4><br>  Die meisten Altcoins k√∂nnen nicht direkt f√ºr US-Dollar gekauft werden.  Um sie zu erwerben, kaufen die Leute oft Bitcoins und tauschen sie an B√∂rsen gegen Altcoins ein.  Daher laden wir die BTC-Wechselkurse f√ºr jede M√ºnze herunter und verwenden die Daten zum BTC-Preis, um die Kosten f√ºr Altcoins in USD zu berechnen. <br><br>  Wir laden Bestandsdaten f√ºr die neun beliebtesten Kryptow√§hrungen herunter - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Litecoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ripple</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum Classic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stellar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dashcoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siacoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monero</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEM</a> . <br><br><pre> <code class="javascript hljs">altcoins = [<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>,<span class="hljs-string"><span class="hljs-string">'LTC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XRP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ETC'</span></span>,<span class="hljs-string"><span class="hljs-string">'STR'</span></span>,<span class="hljs-string"><span class="hljs-string">'DASH'</span></span>,<span class="hljs-string"><span class="hljs-string">'SC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XMR'</span></span>,<span class="hljs-string"><span class="hljs-string">'XEM'</span></span>] altcoin_data = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoins: coinpair = <span class="hljs-string"><span class="hljs-string">'BTC_{}'</span></span>.format(altcoin) crypto_price_df = get_crypto_data(coinpair) altcoin_data[altcoin] = crypto_price_df</code> </pre> <br>  Jetzt haben wir ein W√∂rterbuch mit 9 Datenrahmen, von denen jeder historische Daten zu den durchschnittlichen t√§glichen Wechselkurspaaren von Altcoins und Bitcoin enth√§lt. <br>  Wir werden erneut die letzten f√ºnf Zeilen der Ethereum-Preistabelle √ºberpr√ºfen, um sicherzustellen, dass alles in Ordnung ist. <br><br><pre> <code class="javascript hljs">altcoin_data[<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>].tail()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/632/68a/4ba/63268a4bae1e449cb5d0a336ae117236.png" alt="Bild"></a> <br><br><h4>  3.3 Umrechnung der Preise in US-Dollar </h4><br>  Jetzt k√∂nnen wir die Daten zu Preispaaren mit unserem Bitcoin-Preisindex vergleichen, um direkt historische Daten zum Wert von Altcoins in US-Dollar zu erhalten. <br><br><pre> <code class="javascript hljs"># Calculate USD Price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> each altcoin dataframe <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoin_data.keys(): altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>] = altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'weightedAverage'</span></span>] * btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br>  Mit diesem Code haben wir eine neue Spalte im Datenrahmen jeder Altm√ºnze mit Dollarm√ºnzenpreisen erstellt. <br><br>  Au√üerdem k√∂nnen wir die zuvor definierte Funktion <code>merge_dfs_on_column</code> , um einen <code>merge_dfs_on_column</code> zu erstellen, der Dollarpreise f√ºr jede Kryptow√§hrung enth√§lt. <br><br><pre> <code class="javascript hljs"># Merge USD price <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> each altcoin into single dataframe combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), <span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>)</code> </pre> <br>  Einfach so.  F√ºgen wir nun auch Bitcoin-Preise zur letzten Spalte des kombinierten Datenrahmens hinzu. <br><br><pre> <code class="javascript hljs"># Add BTC price to the dataframe combined_df[<span class="hljs-string"><span class="hljs-string">'BTC'</span></span>] = btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br>  Und jetzt haben wir einen einzigen Frame mit t√§glichen Dollarpreisen f√ºr die zehn Kryptow√§hrungen, die wir untersuchen. <br><br>  Lassen Sie uns die zuvor festgelegte Funktion <code>df_scatter</code> , um ein Vergleichsdiagramm der Preis√§nderungen bei <code>df_scatter</code> zu zeichnen. <br><br><pre> <code class="javascript hljs"># Chart all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the altocoin prices df_scatter(combined_df, <span class="hljs-string"><span class="hljs-string">'Cryptocurrency Prices (USD)'</span></span>, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">'Coin Value (USD)'</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'log'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/19d/b4f/4de/19db4f4de0ad482e8c92376c67fb8ebb.png" alt="Bild"></a> <br><br>  Gro√üartig!  Mit dem Diagramm k√∂nnen Sie die Dynamik der Wechselkurse jeder Kryptow√§hrung in den letzten Jahren ganz klar bewerten. <br><br>  <i>Bitte beachten Sie, dass wir die logarithmische Ordinatenskala verwenden, da wir damit alle W√§hrungen in einem Diagramm anpassen k√∂nnen.</i>  <i>Wenn Sie m√∂chten, k√∂nnen Sie verschiedene Parameterwerte (z. B. <code>scale='linear'</code> ) ausprobieren, um die Daten aus einer anderen Perspektive zu betrachten.</i> <br><br><h4>  3.4 Korrelationsanalyse </h4><br>  M√∂glicherweise haben Sie bemerkt, dass die Wechselkurse f√ºr Kryptow√§hrungen trotz ihrer v√∂llig unterschiedlichen Werte und Volatilit√§t so aussehen, als ob eine gewisse Korrelation zwischen ihnen besteht.  Insbesondere wenn Sie das Intervall nach dem Anstieg im August betrachten, treten bei verschiedenen Token sogar kleine Schwankungen auf, als ob sie synchron w√§ren. <br><br>  Eine Vorahnung, die auf √§u√üerer √Ñhnlichkeit beruht, ist jedoch nicht besser als eine einfache Vermutung, bis wir sie mit statistischen Daten belegen k√∂nnen. <br><br>  Wir k√∂nnen unsere Korrelationshypothese mit der <code>corr()</code> -Methode aus der Pandas-Sammlung testen und damit den Pearson-Korrelationskoeffizienten aller Spalten des Frames zueinander berechnen. <br><br>  <i>Korrektur vom 22.08.2017 - Dieser Teil der Arbeit wurde √ºberarbeitet.</i>  <i>Zur Berechnung der Korrelationskoeffizienten werden nun anstelle der absoluten Preiswerte die Prozentwerte ihrer t√§glichen √Ñnderungen verwendet.</i> <br><br>  Die Berechnung von Korrelationen direkt zwischen instation√§ren Zeitreihen (z. B. Rohpreisdaten) kann zu verzerrten Ergebnissen f√ºhren.  Wir werden diesen Fehler korrigieren, indem wir die Methode <code>pct_change()</code> anwenden, die den Wert jeder Rahmenzelle von einem absoluten Wert in einen Prozentsatz ihrer t√§glichen √Ñnderung umwandelt. <br><br>  Zun√§chst berechnen wir die Korrelation im Jahr 2016. <br><br><pre> <code class="javascript hljs"># Calculate the pearson correlation coefficients <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cryptocurrencies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">2016</span></span> combined_df_2016 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2016</span></span>] combined_df_2016.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/f11/5bd/753/f115bd7536414f45bbf6f509d5c76b25.png" alt="Bild"></a> <br><br>  Jetzt haben wir √ºberall Chancen.  Werte nahe 1 oder -1 geben an, dass zwischen den Zeitreihen eine starke Vorw√§rts- bzw. R√ºckw√§rtskorrelation besteht.  Koeffizienten nahe Null bedeuten, dass die Werte nicht korrelieren und unabh√§ngig voneinander variieren. <br><br>  Um die Ergebnisse zu visualisieren, m√ºssen wir eine weitere Hilfsvisualisierungsfunktion erstellen. <br><br><pre> <code class="javascript hljs">def correlation_heatmap(df, title, absolute_bounds=True): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Plot a correlation heatmap for the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> heatmap = go.Heatmap( z=df.corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>).as_matrix(), x=df.columns, y=df.columns, colorbar=dict(title=<span class="hljs-string"><span class="hljs-string">'Pearson Coefficient'</span></span>), ) layout = go.Layout(title=title) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> absolute_bounds: heatmap[<span class="hljs-string"><span class="hljs-string">'zmax'</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> heatmap[<span class="hljs-string"><span class="hljs-string">'zmin'</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> fig = go.Figure(data=[heatmap], layout=layout) py.iplot(fig)</code> </pre> <br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2016.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2016"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4f5/576/1da/4f55761daa17402ea0b059fcca93df45.png" alt="Bild"><br></a> <br>  Dunkelrote Zellen auf dem Diagramm zeigen eine starke Korrelation an (und jede der W√§hrungen korreliert offensichtlich so weit wie m√∂glich mit sich selbst), dunkelblau - eine starke inverse Korrelation.  Alle Blau-, Orange-, Grau- und Sandfarben zwischen ihnen weisen auf unterschiedliche Grade schwacher Korrelation oder deren Abwesenheit hin. <br><br>  Was sagt uns diese Tabelle?  Tats√§chlich zeigt sich, dass der statistisch signifikante Zusammenhang zwischen Preisschwankungen verschiedener Kryptow√§hrungen im Jahr 2016 gering ist. <br><br>  Um unsere Hypothese zu testen, dass Kryptow√§hrungen in den letzten Monaten st√§rker korreliert sind, wiederholen wir denselben Test mit Daten, die bereits f√ºr 2017 vorliegen. <br><br><pre> <code class="javascript hljs">combined_df_2017 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2017</span></span>] combined_df_2017.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/740/946/579/7409465791b8437582055aa2ec4297c8.png" alt="Bild"></a> <br><br>  Die erhaltenen Koeffizienten zeigen das Vorhandensein einer signifikanteren Korrelation an.  Ist sie stark genug, um diese Tatsache f√ºr Investitionen zu nutzen?  Auf keinen Fall. <br><br>  Wir sollten jedoch darauf achten, dass fast alle Kryptow√§hrungen insgesamt st√§rker miteinander korreliert sind. <br><br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2017.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2017"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/0a9/fd4/de3/0a9fd4de30f446b3aeed700aaed5e377.png" alt="Bild"></a> <br><br>  Und das ist eine ziemlich interessante Beobachtung. <br><br><h3>  Warum passiert das? </h3><br>  Gute Frage.  Ich kann es nicht sicher sagen. <br><br>  Der erste Gedanke, der mir in den Sinn kommt: Der Grund daf√ºr ist, dass Hedge-Fonds seit kurzem offen mit Kryptow√§hrungsm√§rkten handeln.  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> ] [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ] Solche Fonds haben viel mehr Kapital als Durchschnittsh√§ndler, und wenn sie sich vor Risiken sch√ºtzen, indem sie ihre Fonds auf eine Vielzahl von Kryptow√§hrungen spr√ºhen und f√ºr jeden von ihnen √§hnliche Handelsstrategien verwenden, basierend auf unabh√§ngigen Variablen (wie sie es tun) Eine logische Konsequenz dieses Ansatzes kann dann beispielsweise die Entstehung eines Trends zur Erh√∂hung der Korrelationen sein. <br><br><h4>  Eingehende Analyse: XRP und STR </h4><br>  Beispielsweise best√§tigt einer der Trends indirekt die obigen √úberlegungen.  XRP (Ripple Token) korreliert am wenigsten mit anderen Altcoins.  Es gibt jedoch eine bemerkenswerte Ausnahme: STR (das stellare Token, das offizielle hei√üt ‚ÄûLumen‚Äú), dessen Korrelationskoeffizient mit XRP 0,62 betr√§gt. <br><br>  Interessanterweise sind sowohl Stellar als auch Ripple ziemlich √§hnliche Fintech-Plattformen, deren Aktivit√§ten darauf abzielen, den Prozess internationaler Interbankenzahlungen zu vereinfachen. <br><br>  Ich sehe eine sehr reale Situation, in der einige wohlhabende Spieler und Hedgefonds √§hnliche Strategien f√ºr den Handel mit in Stellar und Ripple investierten Fonds anwenden, da beide Dienste hinter diesen Token sehr √§hnlich sind.  Diese Annahme k√∂nnte erkl√§ren, warum XRP viel st√§rker mit STR korreliert als mit anderen Kryptow√§hrungen. <br><br><h3>  Du bist dran </h3><br>  Diese Erkl√§rung ist jedoch weitgehend eine spekulative Schlussfolgerung.  Aber vielleicht kannst du es besser machen?  Das Fundament, das wir in dieser Arbeit gelegt haben, erm√∂glicht es uns, das Studium von Daten in verschiedene Richtungen fortzusetzen. <br><br>  Hier sind einige Ideen zu √ºberpr√ºfen: <br><br><ul><li>  F√ºgen Sie der Analyse Daten f√ºr weitere Kryptow√§hrungen hinzu. </li><li>  Korrigieren Sie den Zeitrahmen und den Detaillierungsgrad der Korrelationsanalyse, indem Sie die Trends detaillierter betrachten oder umgekehrt, allgemeiner ausgedr√ºckt. </li><li>  Suchen Sie nach Trends bei Handelsvolumen und / oder Datens√§tzen f√ºr das Blockchain-Mining.  Verkaufs- / Einkaufsverh√§ltnisse eignen sich besser zur Vorhersage von Preisschwankungen als Rohpreisdaten. </li><li>  F√ºgen Sie Preisdaten f√ºr Aktien, Rohstoffe und Rohstoffe sowie Fiat-W√§hrungen hinzu, um herauszufinden, welche dieser Verm√∂genswerte mit Kryptow√§hrungen korrelieren.  (Aber denken Sie immer an das gute alte Sprichwort: ‚ÄûKorrelation bedeutet noch keine Kausalit√§t.‚Äú) </li><li>  Quantifizieren Sie den Hype um einzelne Kryptow√§hrungen mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Event Registry</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDELT</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Trends</a> . </li><li>  Trainieren Sie mithilfe von maschinellem Lernen ein Programm zur Analyse von Daten, um Preisentwicklungen vorherzusagen.  Wenn es der Ehrgeiz erlaubt, k√∂nnen Sie sogar versuchen, dies mit einem wiederkehrenden neuronalen Netzwerk zu tun. </li><li>  Verwenden Sie Ihre Analyse, um einen automatisierten Bot-Trader-Handel auf Websites wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Poloniex</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coinbase</a> mithilfe der entsprechenden APIs zu erstellen.  Aber seien Sie vorsichtig: Ein schlecht optimierter Handelsbot kann Ihnen schnell alle verf√ºgbaren Mittel entziehen. </li><li>  <b>Teilen Sie Ihre Funde!</b>  Das Beste an Bitcoin und anderen Kryptow√§hrungen im Allgemeinen ist, dass sie aufgrund ihrer Dezentralit√§t im Vergleich zu fast allen anderen Verm√∂genswerten freier und demokratischer sind.     ,    ,   ,     -. </li></ul><br> HTML-  python-  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br> ,       ,           -  ,      ,  ,         . <br><br>    , ,  ,     - ,   .     -   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-</a> . <br><br>     , , ,   .   ,  ,      ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="Bild"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de406363/">https://habr.com/ru/post/de406363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de406345/index.html">NIMS - spezifische Szenariosoftware (f√ºr Rollenspiele mit Live-Action)</a></li>
<li><a href="../de406347/index.html">Die FDA genehmigt zun√§chst die Gentherapie bei Leuk√§mie</a></li>
<li><a href="../de406353/index.html">Wissenschaftler sagen, dass die Intelligenz von Affen seit Jahrzehnten falsch eingesch√§tzt wird</a></li>
<li><a href="../de406359/index.html">Details zum Erstellen eines Bots f√ºr Dota 2</a></li>
<li><a href="../de406361/index.html">M.SMART - September Hackathon "M. Video": Chatbots, KI und maschinelles Lernen</a></li>
<li><a href="../de406365/index.html">Kaspersky Lab zahlt Patenttroll f√ºr die Vermeidung von Rechtsstreitigkeiten</a></li>
<li><a href="../de406367/index.html">Canon Mobile Print: Drucken Sie von √ºberall auf der Welt</a></li>
<li><a href="../de406369/index.html">Interview mit Aubrey de Gray - K√∂nnen Menschen 1000 Jahre und mehr leben?</a></li>
<li><a href="../de406373/index.html">300.000 Meilen auf dem Tesla Model S.</a></li>
<li><a href="../de406375/index.html">Monster, Wunder und die Geburt der Wissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>