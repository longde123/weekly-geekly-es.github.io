<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèº üññ ü§∑üèΩ Pengumpulan informasi kontekstual untuk logging ‚õ∏Ô∏è üöΩ ‚ú°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seringkali Anda perlu menulis informasi tambahan dalam log, yang dapat mengklarifikasi situasi dan lebih menyederhanakan proses debug aplikasi. Misaln...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengumpulan informasi kontekstual untuk logging</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416751/"><p>  Seringkali Anda perlu menulis informasi tambahan dalam log, yang dapat mengklarifikasi situasi dan lebih menyederhanakan proses debug aplikasi.  Misalnya, jika informasi kesalahan dicatat, alangkah baiknya juga menyimpan data input dalam beberapa bentuk, sehingga lebih mudah untuk mereproduksi masalah.  Di sini saya ingin menggambarkan suatu pendekatan yang memungkinkan Anda untuk mengumpulkan informasi tambahan ini. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Misalkan kita memiliki layanan ASP.NET MVC We.  Ia menerima permintaan POST yang berisi deskripsi tentang apa yang perlu dilakukan dalam format JSON.  Setelah menganalisis deskripsi seperti itu, layanan membuat dan mengeksekusi beberapa query SQL ke database.  Dia kemudian menggabungkan hasilnya dan mengirimkannya ke klien. </p><br><p> Harus dikatakan bahwa layanan ini banyak menggunakan asynchrony dan multithreading melalui <em>async / wait</em> dan <code>Task</code> . </p><br><p>  Sekarang kita mengerti apa yang kita hadapi, mari kita beralih ke masalah. </p><br><h2 id="sbor-kontekstnoy-informacii-ob-oshibkah">  Mengumpulkan informasi kesalahan kontekstual </h2><br><p>  Terkadang layanan kami memberikan kesalahan.  Alasannya bisa berbeda: input JSON salah, bug dalam kode, masalah dengan database ... Dalam hal ini, kita harus menulis informasi kesalahan ke log. </p><br><p>  Tidak ada masalah masuk pengecualian itu sendiri.  Kita bisa menangkapnya dalam metode aksi controller kita: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServiceController</span></span> : <span class="hljs-title"><span class="hljs-title">ApiController</span></span> { [Route(<span class="hljs-string"><span class="hljs-string">"api/service"</span></span>)] [HttpPost] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> [FromBody] RequestModel requestModel </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Logger.LogError(ex); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } }</code> </pre> <br><p>  Atau kita dapat membuat atribut khusus untuk ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogErrorAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">ActionFilterAttribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnActionExecuted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionExecutedContext actionExecutedContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnActionExecuted(actionExecutedContext); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actionExecutedContext.Exception != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Logger.LogError(actionExecutedContext.Exception); } } }</code> </pre> <br><p>  dan menggunakannya pada metode tindakan: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"api/service"</span></span></span><span class="hljs-meta">)</span></span>] [HttpPost] [LogError] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> [FromBody] RequestModel requestModel </span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre> <br><p>  Tetapi kita membutuhkan lebih banyak.  Untuk setiap kesalahan, kami ingin menyimpan informasi tambahan: </p><br><ul><li>  Teks badan JSON dari permintaan. </li><li>  Teks dari semua kueri SQL yang dihasilkan. </li></ul><br><p>  Ada satu persyaratan lagi.  Informasi tambahan ini harus dicatat dalam log hanya jika kesalahan terjadi.  Kalau tidak, kita tidak membutuhkannya dalam log. </p><br><p>  Melakukan ini untuk badan permintaan tidak sulit: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServiceController</span></span> : <span class="hljs-title"><span class="hljs-title">ApiController</span></span> { [Route(<span class="hljs-string"><span class="hljs-string">"api/service"</span></span>)] [HttpPost] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> [FromBody] RequestModel requestModel </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Request.Content.ReadAsStringAsync(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Logger.LogError(ex); Logger.LogError(<span class="hljs-string"><span class="hljs-string">$"Request test is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{requestText}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } }</code> </pre> <br><p>  Tetapi untuk query SQL, semuanya tidak begitu sederhana.  Faktanya adalah bahwa permintaan ini tidak dihasilkan oleh metode tindakan.  Mereka bahkan tidak dihasilkan di controller.  Antara metode tindakan dan metode yang menghasilkan SQL, ada banyak panggilan ke metode lain dari kelas lain.  Bagaimana kita mengekstrak teks dari permintaan ini ketika kita membutuhkannya? </p><br><p>  Salah satu opsi adalah menggunakan daftar pesan (mis. <code>List&lt;string&gt;</code> ).  Kami membuatnya dalam metode tindakan kami ( <code>ServiceAction</code> ) dan meneruskannya ke metode yang menghasilkan SQL.  Di sana kami akan menambahkan teks kueri SQL ke daftar ini.  Jika terjadi kesalahan, metode tindakan akan memiliki daftar pesan yang perlu ditempatkan di log. </p><br><p>  Metode ini memiliki kelemahan yang sangat signifikan, menurut saya,.  Kita harus melewati daftar pesan di sepanjang rantai panggilan metode sampai kita mencapai metode yang menghasilkan SQL.  Ini berarti bahwa di banyak tempat daftar pesan ini hanya diperlukan untuk meneruskannya.  Ini menyulitkan kode, dan saya akan mencoba menghindarinya. </p><br><p>  Jika Anda menggunakan wadah DI dan Anda dapat membuat kelas dari itu, maka Anda dapat mencoba untuk menempatkan daftar pesan dalam wadah dengan masa hidup "per permintaan".  Kelas generasi SQL akan menerima daftar pesan ini sebagai parameter konstruktor.  Kemudian instance dari kelas ini dan instance dari controller akan dapat mengakses instance yang sama dari daftar pesan. </p><br><p>  Tetapi ada cara yang lebih mudah untuk mengumpulkan informasi kontekstual bahkan jika Anda tidak menggunakan wadah DI.  Alangkah baiknya jika kita dapat mengakses daftar pesan melalui properti statis: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;SqlDataReader&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunReaderAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SqlCommand cmd</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">$"SQL Server query is: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{cmd.CommandText}</span></span></span><span class="hljs-string">"</span></span>; ErrorContext.Current.AttachMessage(message); ... }</code> </pre> <br><p>  Ada masalah serius di sini.  Layanan kami secara bersamaan dapat melayani beberapa permintaan.  Dan setiap permintaan tersebut harus memiliki daftar pesannya sendiri.  Selain itu, ketika memproses satu permintaan, kode kami dapat menelurkan beberapa utas (misalnya, menggunakan <em>async / menunggu</em> ).  Dan semua utas ini harus memiliki akses ke daftar pesan yang sama.  Bagaimana ini bisa diterapkan? </p><br><p>  Kelas <code>AsyncLocal&lt;T&gt;</code> membantu kami.  Ini menjamin bahwa jika Anda meletakkan beberapa nilai pada instance kelas ini di satu utas, maka Anda bisa mendapatkan nilai ini di utas ini, serta di semua utas yang diluncurkan dari yang ini mulai sekarang.  Pada saat yang sama, semua utas lainnya tidak akan memiliki akses ke nilai ini. </p><br><p>  Mari kita lihat implementasi kelas <code>ErrorContext</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ErrorContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;ErrorContext&gt; CurrentErrorContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;ErrorContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Lazy&lt;ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; _attachedMessages = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt;(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ErrorContext Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (Lock) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorContext = CurrentErrorContext.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorContext == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CurrentErrorContext.Value = errorContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ErrorContext(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorContext; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ErrorContext </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNewErrorContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (Lock) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ErrorContext(); CurrentErrorContext.Value = errorContext; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorContext; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttachMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(message)) { _attachedMessages.Value.Add(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IReadOnlyList&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _attachedMessages.Value.ToArray(); } }</code> </pre> <br><p>  Metode <code>CreateNewErrorContext</code> segera membuat daftar pesan baru dan menyimpannya di bidang <code>CurrentErrorContext</code> , yang merupakan tipe <code>AsyncLocal</code> .  Anda dapat mengakses daftar saat ini di mana saja dalam kode menggunakan properti statis <code>Current</code> .  Metode <code>AttachMessage</code> menambahkan pesan baru ke daftar.  Ini menyimpan pesan dalam contoh <code>ConcurrentBag</code> , karena metode ini dapat dipanggil dari beberapa utas pada saat yang sama.  Metode <code>GetMessages</code> mengembalikan semua pesan yang disimpan, sehingga mereka dapat ditulis ke log. </p><br><p>  Sekarang Anda dapat dengan mudah menginisialisasi dan menggunakan <code>ErrorContext</code> di dalam <code>LogErrorAttribute</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogErrorAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">ActionFilterAttribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnActionExecuting</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionContext actionContext</span></span></span><span class="hljs-function">)</span></span> { ErrorContext.CreateNewErrorContext(); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnActionExecuting(actionContext); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnActionExecuted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionExecutedContext actionExecutedContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnActionExecuted(actionExecutedContext); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actionExecutedContext.Exception != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ErrorContext.Current.GetMessages()) { Logger.LogError(message); } Logger.LogError(actionExecutedContext.Exception); } } }</code> </pre> <br><p>  Di mana saja dalam kode Anda, Anda dapat menambahkan pesan Anda ke konteks kesalahan saat ini sebagai berikut: </p><br><pre> <code class="cs hljs">ErrorContext.Current.AttachMessage(message);</code> </pre> <br><h2 id="logirovanie-problem-s-proizvoditelnostyu">  Pencatatan Kinerja </h2><br><p>  Terkadang layanan saya lambat.  Tidak untuk semua pertanyaan, tetapi untuk beberapa pertanyaan, terlalu lama untuk diselesaikan.  Saya ingin menyimpan informasi tentang permintaan tersebut untuk menganalisisnya nanti.  Bagaimana ini bisa diterapkan, dan informasi apa yang kita butuhkan? </p><br><p>  Pertama-tama, saya perlu ambang runtime.  Jika memproses permintaan membutuhkan waktu lebih sedikit, maka semuanya beres.  Saya tidak akan menulis apa pun ke log dalam kasus ini.  Tetapi jika itu membutuhkan lebih banyak waktu, saya harus menambahkan beberapa informasi ke log. </p><br><p>  Informasi apa yang saya butuhkan?  Anda pasti perlu tahu berapa lama pemrosesan permintaan.  Tetapi itu tidak cukup.  Layanan saya melakukan banyak hal: memeriksa parameter kueri, mendapatkan data dari layanan lain, membuat kueri SQL, dan mengeksekusinya ... Saya perlu tahu berapa banyak waktu yang dibutuhkan setiap bagian untuk memahami di mana masalahnya disembunyikan. </p><br><p>  Selain itu, saya memerlukan informasi yang sama dengan kesalahan.  Saya membutuhkan badan permintaan untuk dapat mereproduksi masalah.  Saya membutuhkan teks-teks dari query SQL jika mereka membutuhkan waktu paling lama. </p><br><p>  Bagaimana ini bisa dicapai?  Sekali lagi, menggunakan kelas <code>AsyncLocal</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Timer</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;Timer&gt; CurrentTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;Timer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Stopwatch _stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Lazy&lt;ConcurrentQueue&lt;Timer&gt;&gt; _attachedTimers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;ConcurrentQueue&lt;Timer&gt;&gt;(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;Timer&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Lazy&lt;ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; _attachedMessages = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt;(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _description; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TimeSpan? _threshold; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Timer _previousCurrent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isDisposed; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _suspendLogging; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Timer previousCurrent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, TimeSpan? threshold = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { _previousCurrent = previousCurrent; _description = description; _threshold = threshold; _stopwatch.Start(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (Lock) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer = CurrentTimer.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CurrentTimer.Value = timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description, TimeSpan? threshold = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (Lock) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTimer = CurrentTimer.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(currentTimer, description, threshold); CurrentTimer.Value = timer; currentTimer?._attachedTimers.Value.Enqueue(timer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttachMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(message)) { _attachedMessages.Value.Enqueue(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isDisposed) { _isDisposed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _stopwatch.Stop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_attachedTimers.IsValueCreated) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attachedTimer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _attachedTimers.Value) { attachedTimer.Dispose(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_suspendLogging &amp;&amp; _threshold.HasValue &amp;&amp; _stopwatch.Elapsed &gt; _threshold.Value) { Log(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_previousCurrent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CurrentTimer.Value = _previousCurrent; } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JObject Message { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">$"It took </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{_stopwatch.ElapsedMilliseconds}</span></span></span><span class="hljs-string"> ms to execute </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{_description}</span></span></span><span class="hljs-string">."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_threshold.HasValue) { message.Append(<span class="hljs-string"><span class="hljs-string">$" Duration threshold is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{_threshold.Value.TotalMilliseconds}</span></span></span><span class="hljs-string"> ms."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JObject { [<span class="hljs-string"><span class="hljs-string">"message"</span></span>] = message.ToString(), }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_attachedTimers.IsValueCreated &amp;&amp; _attachedTimers.Value.Any()) { messageObj[<span class="hljs-string"><span class="hljs-string">"attachedTimers"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JArray(_attachedTimers.Value.Select(t =&gt; t.Message)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_attachedMessages.IsValueCreated &amp;&amp; _attachedMessages.Value.Any()) { messageObj[<span class="hljs-string"><span class="hljs-string">"attachedMessages"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JArray(_attachedMessages.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> messageObj; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { _suspendLogging = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stopwatch.Elapsed &lt; _threshold) { Logger.LogDebug(Message.ToString()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Logger.LogWarning(Message.ToString()); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _suspendLogging = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><p>  Mari kita lihat cara kerjanya.  Metode <code>SetCurrentTimer</code> membuat timer baru.  Di sini Anda dapat menentukan deskripsinya dan ambang batas waktu opsional. </p><br><p>  Mengapa ambang batas ini opsional?  Kadang-kadang saya perlu bagian dari kode saya untuk menjalankan tidak lebih dari jumlah waktu tertentu.  Jadi saya dapat berharap bahwa seluruh permintaan layanan diproses dalam 3 detik.  Dalam kasus lain, saya tidak ingin memaksakan pembatasan pada runtime.  Misalnya, tidak masalah bagi saya berapa lama waktu yang diperlukan untuk menjalankan kueri SQL hingga seluruh permintaan layanan diproses dalam waktu kurang dari 3 detik.  Untuk alasan ini, untuk beberapa timer, ambang batas waktu perlu diatur, sedangkan untuk yang lain tidak. </p><br><p>  Di dalam metode <code>SetCurrentTimer</code> , timer baru dibuat dan dimasukkan ke dalam variabel <code>CurrentTimer</code> tipe <code>AsyncLocal</code> .  Tapi itu belum semuanya.  Pada titik ini, timer aktif lain mungkin sudah ada.  Dalam hal ini, timer baru yang baru saja Anda buat bergabung dengan yang sudah ada.  Ini memungkinkan Anda untuk membuat penghitung waktu bersarang untuk mengukur waktu eksekusi dari seluruh blok kode dan bagian-bagiannya: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Timer.SetCurrentTimer(<span class="hljs-string"><span class="hljs-string">"The whole block"</span></span>)) { ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Timer.SetCurrentTimer(<span class="hljs-string"><span class="hljs-string">"Part 1"</span></span>)) { ... } ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Timer.SetCurrentTimer(<span class="hljs-string"><span class="hljs-string">"Part 2"</span></span>)) { ... } ... }</code> </pre> <br><p>  Properti <code>Current</code> ini memberikan akses ke timer saat ini.  Ini berguna jika Anda ingin menambahkan beberapa pesan ke dalamnya: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">$"SQL Server query is: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{cmd.CommandText}</span></span></span><span class="hljs-string">"</span></span>; Timer.Current.AttachMessage(message);</code> </pre> <br><p>  Di sini, pesan terlampir dan penghitung waktu bersarang disimpan dalam instance <code>ConcurrentQueue</code> , karena urutannya mungkin penting. </p><br><p>  Properti <code>Message</code> mengembalikan pesan yang dikumpulkan dalam satu unit dari arus dan semua timer ditumpuk di dalamnya.  Di sini saya menggunakan kelas JSON dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON.NET</a> untuk menyusun semua pesan.  Tetapi sebenarnya itu tidak begitu penting.  Anda dapat menggunakan format apa pun. </p><br><p>  Metode <code>Log</code> menulis informasi yang disimpan dalam timer ke log, terlepas dari apakah ambang waktu berjalan telah ditetapkan atau tidak.  Pada saat yang sama, metode <code>Dispose</code> menulis informasi ke log hanya jika ambang batas runtime yang ditetapkan telah terlampaui. </p><br><p>  Sekarang kita dapat membuat atribut lain untuk metode pengontrol kami: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TimerContextAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">ActionFilterAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _timerDescription; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _durationThresholdMs; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;Timer&gt; _timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;Timer&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimerContextAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timerDescription, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> durationThresholdMs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(timerDescription)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(timerDescription)); _timerDescription = timerDescription; _durationThresholdMs = durationThresholdMs; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnActionExecuting</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionContext actionContext</span></span></span><span class="hljs-function">)</span></span> { _timer.Value = Timer.SetCurrentTimer(_timerDescription, TimeSpan.FromMilliseconds(_durationThresholdMs)); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnActionExecuting(actionContext); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnActionExecuted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionExecutedContext actionExecutedContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnActionExecuted(actionExecutedContext); _timer.Value?.Dispose(); } }</code> </pre> <br><p>  dan menggunakannya pada metode tindakan seperti ini: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"api/service"</span></span></span><span class="hljs-meta">)</span></span>] [HttpPost] [TimerContext(<span class="hljs-string"><span class="hljs-string">"For ServiceAction method"</span></span>, <span class="hljs-number"><span class="hljs-number">3000</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> [FromBody] RequestModel requestModel </span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre> <br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dalam artikel ini, saya menjelaskan betapa sederhananya mengumpulkan informasi dari banyak tempat dalam kode dan mengaksesnya nanti.  Fungsionalitas tersebut dapat diimplementasikan menggunakan properti dan metode statis yang memanipulasi instance dari kelas <code>AsyncLocal</code> . </p><br><p>  Saya harap artikel ini akan bermanfaat untuk meningkatkan sistem logging di aplikasi Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416751/">https://habr.com/ru/post/id416751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416737/index.html">A * Path Finding Algorithm dalam Voxel 3d Unity Game</a></li>
<li><a href="../id416739/index.html">ASUS baru di Computex 2018</a></li>
<li><a href="../id416741/index.html">Penyerang menggunakan sertifikat D-Link curian dalam perangkat lunak pencurian kata sandi mereka</a></li>
<li><a href="../id416743/index.html">Bot untuk Starcraft di Rust, C dan bahasa lainnya</a></li>
<li><a href="../id416745/index.html">ASUS ROG baru di Computex 2018</a></li>
<li><a href="../id416753/index.html">Plugin Hola VPN populer dikompromikan</a></li>
<li><a href="../id416755/index.html">Suka Ekstrim - Komite Investigasi Terhadap</a></li>
<li><a href="../id416757/index.html">Tes terkelupas</a></li>
<li><a href="../id416759/index.html">Mengapa kecerdasan buatan tidak akan menyelesaikan semua masalah</a></li>
<li><a href="../id416761/index.html">Bahasa kosmik, bagian 1: apakah tata bahasa universal itu universal?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>