<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👩🏿‍⚖️ 🌮 用火箭科学简化您的代码：C ++ 20的太空船操作员 ✋🏻 👩🏽‍🔬 🎩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20添加了一个新的运算符，被亲切地称为“太空飞船”运算符： <=> 。 我们自己的西蒙·布兰德（Simon Brand）不久前发表了一篇文章 ，详细介绍了有关该新运营商的一些信息以及有关其现状和作用的一些概念性信息。 这篇文章的目的是探索这个奇怪的新运算符及其相关的对应operator==...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用火箭科学简化您的代码：C ++ 20的太空船操作员</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20添加了一个新的运算符，被亲切地称为“太空飞船”运算符： <code>&lt;=&gt;</code> 。 我们自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">西蒙·布兰德（Simon Brand）</a>不久前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发表</a>了一篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ，详细介绍了有关该新运营商的一些信息以及有关其现状和作用的一些概念性信息。 这篇文章的目的是探索这个奇怪的新运算符及其相关的对应<code>operator==</code>一些具体应用（是的，为了更好，它已经被更改了！），同时提供了在日常代码中使用它的一些准则。 <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2> 比较 </h2><br> 看到如下代码并非罕见的事情： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>注意：老鹰眼的读者会发现，这实际上比C ++ 20之前的代码更冗长，因为这些函数实际上应该都是非成员的朋友，以后再介绍。</i> <br><br> 要确保我的类型可以与相同类型的东西相比较，要编写很多样板代码。 好吧，我们处理了一段时间。 然后是写这个的人： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br> 您会注意到的第一件事是该程序将无法编译。 <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br> 啊！ 问题是我们忘记了比较函数<code>constexpr</code> ，drat！ 因此，有人将<code>constexpr</code>添加到所有比较运算符中。 几天后，有人去添加了一个<code>is_gt</code>帮助器，但是注意到所有比较运算符都没有异常规范，并且经历了相同的繁琐过程， <code>noexcept</code> 5个重载中的每个重载添加<code>noexcept</code> 。 <br><br> 这就是C ++ 20的新飞船操作员介入的地方，以帮助我们。 让我们看看如何在C ++ 20世界中编写原始的<code>IntWrapper</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br> 您可能会注意到的第一个区别是<code>&lt;compare&gt;</code>的新添加。  <code>&lt;compare&gt;</code>标头负责为编译器填充所有必要的比较类别类型，以使太空飞船操作员返回适合于我们默认功能的类型。 在上面的代码段中， <code>auto</code>返回类型将推导为<code>std::strong_ordering</code> 。 <br><br> 我们不仅删除了5条多余的行，而且甚至不必定义任何内容，编译器为我们做到了！ 即使未在默认的<code>operator&lt;=&gt;</code>明确指定，我们的<code>is_lt</code>仍保持不变，并且仍可以在<code>constexpr</code> 。 很好，但是有些人可能会scratch之以<code>is_lt</code> ，尽管为什么<code>is_lt</code>甚至根本不使用太空飞船运算符，但为什么<code>is_lt</code>允许编译<code>is_lt</code> 。 让我们探索这个问题的答案。 <br><br><h2> 重写表达式 </h2><br> 在C ++ 20中，编译器被引入了一个称为“重写”表达式的新概念。 宇宙飞船算子以及<code>operator==</code>属于前两个要重写表达式的候选对象。 有关表达式重写的更具体示例，让我们分解<code>is_lt</code>提供的<code>is_lt</code> 。 <br><br> 在重载解析期间，编译器将从一组可行的候选对象中进行选择，所有这些候选对象均与我们正在寻找的运算符匹配。 对于关系和等效操作，候选者的收集过程稍有变化，在这种情况下，编译器还必须收集经过重写和合成的特殊候选者（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[over.match.oper] /3.4</a> ）。 <br><br> 对于我们的表达式<code>a &lt; b</code> ，标准声明我们可以在a的类型中搜索一个<code>operator&lt;=&gt;</code>或一个接受其类型的名称空间作用域<code>operator&lt;=&gt;</code> 。 因此，编译器这样做，并且发现实际上，的类型确实<code>IntWrapper::operator&lt;=&gt;</code> 。 然后允许编译器使用该运算符，并将表达式<code>a &lt; b</code>重写为<code>(a &lt;=&gt; b) &lt; 0</code> 。 然后，该重写的表达式将用作正常重载解决方案的候选。 <br><br> 您可能会问自己，为什么重写后的表达式正确有效。 表达式的正确性实际上源于太空飞船运营商提供的语义。  <code>&lt;=&gt;</code>是一种三向比较，它表示您不仅得到二进制结果，而且得到排序（在大多数情况下），并且如果有排序，则可以用任何关系运算来表示该排序。 一个简单的示例，在C ++ 20中的表达式4 &lt;=&gt; 5将为您返回结果<code>std::strong_ordering::less</code> 。  <code>std::strong_ordering::less</code>结果表示<code>4</code>不仅不同于<code>5</code>而且严格小于该值，这使得应用运算<code>(4 &lt;=&gt; 5) &lt; 0</code>正确且准确地描述了我们的结果。 <br><br> 使用上面的信息，编译器可以采用任何广义关系运算符（即<code>&lt;</code> ， <code>&gt;</code>等），并根据飞船运算符进行重写。 在标准中，重写的表达式通常称为<code>(a &lt;=&gt; b) @ 0</code> ，其中<code>@</code>表示任何关系运算。 <br><br><h2> 合成表达 </h2><br> 读者可能已经注意到上面对“合成”表达式的微妙提及，并且它们在该运算符重写过程中也起作用。 考虑一个不同的谓词功能： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br> 如果我们将原始定义用于<code>IntWrapper</code>此代码将无法编译。 <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br> 这在C ++ 20之前的版本中是有道理的，解决此问题的方法是在<code>IntWrapper</code>添加一些额外的<code>friend</code>函数，这些函数采用<code>int</code>的左侧。 如果您尝试使用C ++ 20编译器和我们的<code>IntWrapper</code> C ++ 20定义来构建该示例，您可能会注意到它再次“起作用”，这是另一种方法。 让我们研究一下为什么上面的代码仍允许在C ++ 20中进行编译。 <br><br> 在重载解析期间，编译器还将收集标准所指的“综合”候选项，或以参数顺序相反的方式重写表达式。 在上面的示例中，编译器将尝试使用重写的表达式<code>(42 &lt;=&gt; a) &lt; 0</code>但会发现从<code>IntWrapper</code>到<code>int</code>没有满足左侧转换的要求，因此删除了重写的表达式。 编译器还构想出“合成的”表达式<code>0 &lt; (a &lt;=&gt; 42)</code>并发现通过其转换构造函数从<code>int</code>到<code>IntWrapper</code>进行了转换，因此使用了该候选对象。 <br><br> 合成表达式的目的是避免需要编写<code>friend</code>函数的样板来填补可能从其他类型转换对象的空白。 综合表达式一般<code>0 @ (b &lt;=&gt; a)</code> 。 <br><br><h2> 更复杂的类型 </h2><br> 编译器生成的太空飞船运算符不会停留在类的单个成员上，它将为您类型中的所有子对象生成一组正确的比较： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br> 编译器知道如何将数组的类的成员扩展到其子对象列表中，并进行递归比较。 当然，如果您想自己编写这些函数的主体，您仍然会受益于编译器为您重写表达式的好处。 <br><br><h2> 看起来像鸭子，像鸭子一样游泳，像<code>operator==</code>一样<code>operator==</code> </h2><br> 标准化委员会的一些非常聪明的人注意到，无论如何，飞船操作员将始终对元素进行词典编目比较。 无条件地执行字典比较可能会导致使用相等运算符的代码生成效率低下。 <br><br> 典型的例子是比较两个字符串。 如果您有字符串<code>"foobar"</code>并使用==将其与字符串<code>"foo"</code>进行比较，则可以预期该操作几乎是恒定的。 因此，有效的字符串比较算法为： <br><br><ul><li> 首先比较两个字符串的大小，如果大小不同则返回<code>false</code> ，否则 </li><li> 逐步遍历两个字符串的每个元素，并进行比较直到一个不同或到达末尾，然后返回结果。 </li></ul><br> 根据太空飞船操作员规则，我们需要首先对每个元素进行深度比较，直到找到一个不同的元素。 在我们的<code>"foobar"</code>和<code>"foo"</code>示例中，只有将<code>'b'</code>与<code>'\0'</code>进行比较时，您最终才返回<code>false</code> 。 <br><br> 为了解决这个问题，有一篇论文， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1185R2</a> ，详细介绍了编译器独立于飞船运算符重写和生成<code>operator==</code>的方法。 我们的<code>IntWrapper</code>可以编写如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br> 仅一步之遥……然而，有个好消息； 您实际上不需要编写上面的代码，因为只需编写<code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code>就足以使编译器为您隐式生成单独的-效率更高的<code>operator==</code> ！ <br><br> 编译器将特定于<code>==</code>和<code>!=</code> “重写”规则应用略微更改的规则，其中这些运算符是根据<code>operator==</code>而非<code>operator&lt;=&gt;</code>进行重写的。 这意味着<code>!=</code>也可以从优化中受益。 <br><br><h2> 旧代码不会中断 </h2><br> 此时，您可能会想，如果允许编译器执行此操作符重写业务，那么当我尝试使编译器的性能超出预期时会发生什么： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br> 答案是，您没有。  C ++中的重载解决方案模型具有所有候选者都在其中进行战斗的领域，在这个特定的战斗中，我们有3个候选者： <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  （改写） <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  （综合） <br><br> 如果我们接受C ++ 17中的重载解析规则，则该调用的结果将是模棱两可的，但是C ++ 20的重载解析规则已更改为允许编译器将这种情况解决为最合逻辑的重载。 <br><br> 在过载解决的阶段，编译器必须执行一系列的决胜局。 在C ++ 20中，有一个新的决胜局，它声明我们必须更喜欢未重写或合成的重载，这使我们的重载<code>IntWrapper::operator&lt;</code>最佳候选者并解决了歧义。 这种相同的机制可以防止合成的候选对象踩踏正则重写的表达式。 <br><br><h2> 总结思想 </h2><br> 太空飞船操作员是C ++的一个受欢迎的补充，它是可以简化并帮助您编写<i>更少</i>代码的功能之一，有时，更少就是更多。 因此，请使用C ++ 20的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">飞船</a>运算符！ <br><br> 我们敦促您出去尝试宇宙飞船操作员，它现在在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Visual Studio 2019中的</a> <code>/std:c++latest</code>下可用！ 请注意，通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1185R2</a>引入的更改将在Visual Studio 2019版本16.2中可用。 请记住，宇宙飞船操作员是C ++ 20的一部分，并且可能会有所变化，直到最终确定C ++ 20。 <br><br> 一如既往，我们欢迎您的反馈。 随时通过电子邮件<a href="">visualcpp @ microsoft.com</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter @visualc</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft Visual Cpp的</a> Facebook发送任何评论。 另外，请随时在Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@starfreakclone</a>上关注我。 <br><br> 如果您在VS 2019中使用MSVC遇到其他问题，请通过安装程序或Visual Studio IDE本身的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告问题</a>选项通知我们。 有关建议或错误报告，请通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DevComm</a>告诉我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458248/">https://habr.com/ru/post/zh-CN458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458230/index.html">人工智能，无人机和摄像头如何确保我们的道路和桥梁安全</a></li>
<li><a href="../zh-CN458240/index.html">人工智能，无人机和摄像头如何确保道路和桥梁的安全</a></li>
<li><a href="../zh-CN458242/index.html">C ++ 20中的新太空飞船运算符</a></li>
<li><a href="../zh-CN458244/index.html">为了安全使用公共Wi-Fi网络，您需要了解的内容无穷无尽的清单</a></li>
<li><a href="../zh-CN458246/index.html">生活中的偶然巧合，或结果证明您在拖拉机工厂被送上蛋糕</a></li>
<li><a href="../zh-CN458250/index.html">BTRFS最小</a></li>
<li><a href="../zh-CN458252/index.html">超长射电望远镜的数学模型</a></li>
<li><a href="../zh-CN458256/index.html">是不是该洗脑了？</a></li>
<li><a href="../zh-CN458260/index.html">为Java应用程序优化Docker映像的另一种方法</a></li>
<li><a href="../zh-CN458262/index.html">会议室的在线设计师-选择视频会议的最佳解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>