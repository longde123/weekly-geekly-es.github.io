<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèº üë®‚Äçüé® üí™üèø WebAssembly-Entwicklung: echter Rechen und Beispiele üö∂ üêÆ üçå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Ank√ºndigung von WebAssembly erfolgte im Jahr 2015 - aber jetzt, nach Jahren, gibt es nur noch wenige, die sich in der Produktion damit r√ºhmen k√∂nn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebAssembly-Entwicklung: echter Rechen und Beispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/441140/"><img src="https://habrastorage.org/webt/e5/pu/-s/e5pu-s7yjpdm8dddc42_nxa1uve.jpeg"><br><br>  Die Ank√ºndigung von WebAssembly erfolgte im Jahr 2015 - aber jetzt, nach Jahren, gibt es nur noch wenige, die sich in der Produktion damit r√ºhmen k√∂nnen.  Die Materialien zu solchen Erfahrungen sind umso wertvoller: Informationen dar√ºber, wie man in der Praxis damit umgeht, sind immer noch Mangelware. <br><br>  Auf der HolyJS-Konferenz erhielt ein Bericht √ºber die Erfahrungen mit der Verwendung von WebAssembly gute Noten vom Publikum, und jetzt wurde eine Textversion dieses Berichts speziell f√ºr Habr erstellt (ein Video ist ebenfalls beigef√ºgt). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uqG9DiT80UE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Mein Name ist Andrey, ich werde Ihnen von WebAssembly erz√§hlen.  Wir k√∂nnen sagen, dass ich im letzten Jahrhundert angefangen habe, mich mit dem Internet zu besch√§ftigen, aber ich bin bescheiden, also werde ich das nicht sagen.  In dieser Zeit konnte ich sowohl am Backend als auch am Frontend arbeiten und sogar ein kleines Design zeichnen.  Heute interessiere ich mich f√ºr Dinge wie WebAssembly, C ++ und andere native Dinge.  Ich liebe auch Typografie und sammle alte Technologie. <br><br>  Zuerst werde ich dar√ºber sprechen, wie das Team und ich WebAssembly in unserem Projekt implementiert haben, dann werden wir diskutieren, ob Sie etwas von WebAssembly ben√∂tigen, und mit ein paar Tipps abschlie√üen, falls Sie es selbst implementieren m√∂chten. <br><br><h2>  Wie wir WebAssembly implementiert haben </h2><br>  Ich arbeite f√ºr Inetra, wir befinden uns in Nowosibirsk und machen einige unserer eigenen Projekte.  Einer von ihnen ist ByteFog.  Dies ist eine Peer-to-Peer-Technologie zur Bereitstellung von Videos f√ºr Benutzer.  Unsere Kunden sind Dienste, die eine gro√üe Menge an Videos verbreiten.  Sie haben ein Problem: Wenn ein beliebtes Ereignis stattfindet, beispielsweise eine Pressekonferenz oder ein Sportereignis, wie man sich nicht darauf vorbereitet, kommen eine Reihe von Kunden herein, st√ºtzen sich auf den Server, und der Server ist traurig.  Kunden erhalten zu diesem Zeitpunkt eine sehr schlechte Videoqualit√§t. <br><br>  Aber jeder sieht den gleichen Inhalt.  Lassen Sie uns benachbarte Ger√§te von Benutzern bitten, Videoteile freizugeben. Anschlie√üend werden wir den Server entladen, Bandbreite sparen und Benutzer erhalten Videos in besserer Qualit√§t.  Diese Clouds sind unsere Technologie, unser ByteFog-Proxyserver. <br><br><img src="https://habrastorage.org/webt/ir/yw/xl/irywxlozwzz4kbedspsf14lx4ie.png"><br><br>  Wir m√ºssen auf jedem Ger√§t installiert sein, das Videos anzeigen kann. Daher unterst√ºtzen wir eine Vielzahl von Plattformen: Windows, Linux, Android, iOS, Web, Tizen.  Welche Sprache soll gew√§hlt werden, um auf allen diesen Plattformen eine einzige Codebasis zu haben?  Wir haben uns f√ºr C ++ entschieden, weil es die meisten Vorteile hat :-D Im Ernst, wir haben gute Kenntnisse in C ++, es ist wirklich eine schnelle Sprache und in Bezug auf die Portabilit√§t ist es wahrscheinlich die zweitwichtigste nach C. <br><br>  Wir haben eine ziemlich gro√üe Anwendung (900 Klassen), aber es funktioniert gut.  Unter Windows und Linux kompilieren wir in nativen Code.  F√ºr Android und iOS erstellen wir eine Bibliothek, die wir mit der Anwendung verbinden.  Wir werden ein anderes Mal √ºber Tizen sprechen, aber im Web haben wir fr√ºher als Browser-Plugin gearbeitet. <br><br>  Dies ist die Netscape Plugin API-Technologie.  Wie der Name schon sagt, ist es ziemlich alt und hat auch einen Nachteil: Es bietet einen sehr breiten Zugriff auf das System, sodass Benutzercode ein Sicherheitsproblem verursachen kann.  Dies ist wahrscheinlich der Grund, warum Chrome die Unterst√ºtzung f√ºr diese Technologie im Jahr 2015 deaktiviert hat und dann alle Browser diesem Flash-Mob beigetreten sind.  So blieben wir fast zwei Jahre ohne Webversion. <br><br>  2017 kam eine neue Hoffnung.  Wie Sie sich vorstellen k√∂nnen, ist dies WebAssembly.  Aus diesem Grund haben wir uns die Aufgabe gestellt, unsere Anwendung auf einen Browser zu portieren.  Da die Unterst√ºtzung f√ºr Firefox und Chrome bereits im Fr√ºhjahr und im Herbst 2017 erschien, haben sich Edge und Safari hochgezogen. <br><br>  F√ºr uns war es wichtig, vorgefertigten Code zu verwenden, da wir eine Menge Gesch√§ftslogik haben, die wir nicht verdoppeln wollten, um die Anzahl der Fehler nicht zu verdoppeln.  Nimm den Compiler Emscripten.  Er tut, was wir brauchen - kompiliert die positive Anwendung in den Browser und erstellt die Umgebung neu, die der nativen Anwendung im Browser vertraut ist.  Wir k√∂nnen sagen, dass Emscripten ein solches Browserify f√ºr C ++ - Code ist.  Au√üerdem k√∂nnen Sie Objekte von C ++ an JavaScript weiterleiten und umgekehrt.  Unser erster Gedanke war: Nehmen wir jetzt Emscripten, kompilieren Sie einfach und alles wird funktionieren.  Nat√ºrlich nicht.  Von hier aus begann unsere Reise entlang des Rechen. <br><br>  Das erste, was uns begegnete, war Sucht.  In unserer Codebasis befanden sich mehrere Bibliotheken.  Jetzt macht es keinen Sinn, sie aufzulisten, aber f√ºr diejenigen, die verstehen, haben wir Boost.  Dies ist eine gro√üe Bibliothek, mit der Sie plattform√ºbergreifenden Code schreiben k√∂nnen, aber es ist sehr schwierig, die Kompilierung damit zu konfigurieren.  Ich wollte so wenig Code wie m√∂glich in den Browser ziehen. <br><br><h3>  Bytefog-Architektur </h3><br>  Als Ergebnis haben wir den Kern identifiziert: Wir k√∂nnen sagen, dass dies ein Proxyserver ist, der die Hauptgesch√§ftslogik enth√§lt.  Dieser Proxyserver nimmt Daten aus zwei Quellen auf.  Das erste und wichtigste ist HTTP, dh ein Kanal zum Videoverteilungsserver, das zweite ist unser P2P-Netzwerk, dh ein Kanal zu einem anderen gleichen Proxy von einem anderen Benutzer.  Wir geben die Daten in erster Linie an den Player weiter, da es unsere Aufgabe ist, dem Benutzer qualitativ hochwertige Inhalte anzuzeigen.  Wenn noch Ressourcen vorhanden sind, verteilen wir den Inhalt an das P2P-Netzwerk, damit andere Benutzer ihn herunterladen k√∂nnen.  Im Inneren befindet sich ein intelligenter Cache, der die ganze Magie aus√ºbt. <br><br><img src="https://habrastorage.org/webt/vi/id/zt/viidzt9cctzun2_em3ka8jfm8pu.png"><br><br>  Nachdem wir dies alles kompiliert haben, sehen wir uns mit der Tatsache konfrontiert, dass WebAssembly in der Browser-Sandbox ausgef√ºhrt wird.  Das hei√üt, es kann nicht mehr als JavaScript.  W√§hrend native Anwendungen viele plattformspezifische Dinge verwenden, wie z. B. ein Dateisystem, ein Netzwerk oder Zufallszahlen.  Alle diese Funktionen m√ºssen mit dem, was der Browser uns gibt, in JavaScript implementiert werden.  Diese Platte listet die ziemlich offensichtlichen Ersetzungen auf, die aufgelistet sind. <br><br><img src="https://habrastorage.org/webt/ii/uv/bf/iiuvbfvwjvul6pbnkuptqku8amo.png"><br><br>  Um dies zu erm√∂glichen, ist es erforderlich, die Implementierung nativer Funktionen in einer nativen Anwendung abzuschneiden und dort eine Schnittstelle einzuf√ºgen, dh einen bestimmten Rand zu zeichnen.  Dann implementieren Sie dies in JavaScript und verlassen die native Implementierung, und bereits w√§hrend der Assembly wird die erforderliche ausgew√§hlt.  Also haben wir uns unsere Architektur angesehen und alle Orte gefunden, an denen diese Grenze gezogen werden kann.  Zuf√§lligerweise ist dies ein Transportsubsystem. <br><br><img src="https://habrastorage.org/webt/ok/eq/w-/okeqw-dc-weuwlqxed4iy2x5nn4.png"><br><br>  F√ºr jeden dieser Orte haben wir eine Spezifikation definiert, dh wir haben einen Vertrag festgelegt: Welche Methoden werden verwendet, welche Parameter werden sie haben, welche Datentypen.  Sobald Sie dies getan haben, k√∂nnen Sie parallel arbeiten, wobei jeder Entwickler auf seiner Seite steht. <br><br>  Was ist das Ergebnis?  Wir haben den Haupt-Video√ºbertragungskanal des Anbieters durch den √ºblichen AJAX ersetzt.  Wir geben Daten √ºber die beliebte HLS.js-Bibliothek an den Player aus, es besteht jedoch eine grundlegende M√∂glichkeit, diese bei Bedarf in andere Player zu integrieren.  Wir haben die gesamte P2P-Schicht durch WebRTC ersetzt. <br><br><img src="https://habrastorage.org/webt/g8/dc/mt/g8dcmtbxfugjxpycyzpabtb6nto.png"><br><br>  Durch die Kompilierung werden mehrere Dateien erhalten.  Das wichtigste ist der bin√§re .wasm.  Es enth√§lt den kompilierten Bytecode, den der Browser ausf√ºhrt und der Ihr gesamtes C ++ - Erbe enth√§lt.  Aber an sich funktioniert es nicht, der sogenannte "Klebercode" ist notwendig, er wird auch vom Compiler generiert.  Der Klebercode l√§dt eine Bin√§rdatei herunter, und Sie laden beide Dateien in die Produktion hoch.  Zu Debugging-Zwecken k√∂nnen Sie eine Textdarstellung des Assemblers generieren - eine .wast-Datei und eine Quellkarte.  Sie m√ºssen verstehen, dass sie sehr gro√ü sein k√∂nnen.  In unserem Fall erreichten sie 100 Megabyte oder mehr. <br><br><h3>  Das B√ºndel sammeln </h3><br>  Schauen wir uns den Klebercode genauer an.  Dies ist das √ºbliche gute alte ES5, das in einer einzigen Datei zusammengefasst ist.  Wenn wir es mit einer Webseite verbinden, haben wir eine globale Variable, die unser gesamtes instanziiertes Wasm-Modul enth√§lt, das bereit ist, Anforderungen an seine API anzunehmen. <br><br>  Das Einf√ºgen einer separaten Datei ist jedoch eine ziemlich schwerwiegende Komplikation f√ºr die Bibliothek, die Benutzer verwenden werden.  Wir m√∂chten alles in einem einzigen B√ºndel zusammenfassen.  Hierf√ºr verwenden wir Webpack und eine spezielle Kompilierungsoption MODULARIZE. <br><br>  Es klebt den Klebercode in das "Modul" -Muster und wir k√∂nnen ihn aufgreifen: Importieren oder Verwenden erfordern, wenn wir auf ES5 schreiben - Webpack versteht diese Abh√§ngigkeit ruhig.  Es gab ein Problem mit Babel - er mochte die gro√üe Menge an Code nicht, aber dies ist ein ES5-Code, er muss nicht transponiert werden, wir f√ºgen ihn einfach hinzu, um ihn zu ignorieren. <br><br>  Um die Anzahl der Dateien zu ermitteln, habe ich mich f√ºr die Option SINGLE_FILE entschieden.  Es √ºbersetzt alle aus der Kompilierung resultierenden Bin√§rdateien in das Base64-Formular und verschiebt sie als Zeichenfolge in den Klebecode.  Klingt nach einer gro√üartigen Idee, aber danach wurde das Bundle 100 Megabyte gro√ü.  Weder Webpack noch Babel noch der Browser funktionieren auf einem solchen Volume.  Auf jeden Fall werden wir den Benutzer nicht zwingen, 100 Megabyte zu laden ?! <br><br>  Wenn Sie dar√ºber nachdenken, wird diese Option nicht ben√∂tigt.  Adhesive Code l√§dt Bin√§rdateien selbst herunter.  Er macht das √ºber HTTP, damit wir sofort zwischenspeichern k√∂nnen. Wir k√∂nnen alle gew√ºnschten Header festlegen, z. B. die Komprimierung aktivieren, und WebAssembly-Dateien werden perfekt komprimiert. <br><br>  Die coolste Technologie ist jedoch das Streaming von Kompilierungen.  Das hei√üt, die WebAssembly-Datei kann beim Herunterladen vom Server bereits im Browser kompiliert werden, wenn Daten eintreffen. Dies beschleunigt das Laden Ihrer Anwendung erheblich.  Im Allgemeinen konzentriert sich die gesamte WebAssembly-Technologie auf den schnellen Start einer gro√üen Codebasis. <br><br><h3>  Dann m√∂glich </h3><br>  Ein weiteres Problem mit dem Modul besteht darin, dass es sich um ein Thenable-Objekt handelt, dh √ºber eine .then () -Methode.  Diese Funktion erm√∂glicht es Ihnen, einen R√ºckruf zum Zeitpunkt des Starts des Moduls aufzuh√§ngen, und ist sehr praktisch.  Aber ich m√∂chte, dass die Benutzeroberfl√§che zu Promise passt.  Thenable ist kein Versprechen, aber es ist okay, lassen Sie es uns selbst einpacken.  Schreiben wir einen so einfachen Code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { Module(config).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); }); });</code> </pre> <br>  Wir erstellen Promise, starten unser Modul und rufen als R√ºckruf die Aufl√∂sungsfunktion auf und √ºbergeben das dort installierte Modul.  Alles scheint offensichtlich zu sein, alles ist in Ordnung, wir starten - etwas stimmt nicht, unser Browser ist eingefroren, unsere DevTools h√§ngen und der Prozessor heizt sich auf dem Computer auf.  Wir verstehen nichts - eine Art Rekursion oder eine Endlosschleife.  Das Debuggen ist ziemlich schwierig, und als wir JavaScript unterbrochen haben, sind wir in der Then-Funktion im Emscripten-Modul gelandet. <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'then'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Module; };</code> </pre><br>  Schauen wir uns das genauer an.  Handlung <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); };</code> </pre><br>  verantwortlich f√ºr das Aufh√§ngen eines R√ºckrufs.  Hier ist alles klar: eine asynchrone Funktion, die unseren R√ºckruf aufruft.  Alles wie wir wollen.  Es gibt noch einen weiteren Teil dieser Funktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module);</code> </pre><br>  Es wird aufgerufen, wenn das Modul bereits gestartet wurde.  Dann wird der R√ºckruf sofort synchron aufgerufen und das Modul im Parameter an ihn √ºbergeben.  Dies ahmt das Verhalten von Promise nach und scheint das zu sein, was wir erwarten.  Aber was ist dann falsch? <br><br>  Wenn Sie die Dokumentation sorgf√§ltig lesen, stellt sich heraus, dass Promise einen sehr subtilen Punkt hat.  Wenn wir das Versprechen mit einem Thenable aufl√∂sen, packt der Browser die Werte aus diesem Thenable aus und ruft dazu die .then () -Methode auf.  Infolgedessen l√∂sen wir das Versprechen und √ºbergeben das Modul an es.  Der Browser fragt: Ist das dann ein Objekt?  Ja, das ist ein Thenable.  Dann wird die Funktion .then () f√ºr das Modul aufgerufen und die Aufl√∂sungsfunktion selbst als R√ºckruf √ºbergeben. <br><br>  Das Modul pr√ºft, ob es l√§uft.  Es wird bereits ausgef√ºhrt, sodass der R√ºckruf sofort aufgerufen wird und dasselbe Modul erneut an ihn √ºbergeben wird.  Als R√ºckruf haben wir die Aufl√∂sungsfunktion und der Browser fragt: Ist dies ein Thenable-Objekt?  Ja, das ist ein Thenable.  Und alles beginnt von vorne.  Infolgedessen geraten wir in einen endlosen Zyklus, aus dem der Browser niemals zur√ºckkehrt. <br><br><img src="https://habrastorage.org/webt/ks/rr/c-/ksrrc-zeix0ffh_uott4ahpt3qc.png"><br><br>  Ich habe keine elegante L√∂sung f√ºr dieses Problem gefunden.  Infolgedessen l√∂sche ich einfach die .then () -Methode vor dem Aufl√∂sen, und dies funktioniert. <br><br><h3>  Emscripten </h3><br>  Also haben wir das Modul kompiliert, JS zusammengestellt, aber etwas fehlt.  Wir m√ºssen wahrscheinlich n√ºtzliche Arbeit leisten.  √úbertragen Sie dazu Daten und verbinden Sie die beiden Welten - JS und C ++.  Wie kann man das machen?  Emscripten bietet drei Optionen: <br><br><ul><li>  Die erste ist die Funktionen ccall und cwrap.  Meistens werden Sie sie in einigen Tutorials zu WebAssembly kennenlernen, aber sie sind nicht f√ºr echte Arbeit geeignet, da sie die Funktionen von C ++ nicht unterst√ºtzen. </li><li>  Der zweite ist WebIDL Binder.  Es unterst√ºtzt bereits C ++ - Funktionen, Sie k√∂nnen bereits damit arbeiten.  Dies ist eine seri√∂se Schnittstellenbeschreibungssprache, die beispielsweise von W3C f√ºr ihre Dokumentation verwendet wird.  Wir wollten es aber nicht in unser Projekt aufnehmen und nutzten die dritte Option </li><li>  Einbinden.  Wir k√∂nnen sagen, dass dies eine native Methode zum Verbinden von Objekten f√ºr Emscripten ist. Sie basiert auf C ++ - Vorlagen und erm√∂glicht es Ihnen, viele Dinge zu tun, indem Sie verschiedene Entit√§ten von C ++ an JS und umgekehrt weiterleiten. </li></ul><br><br>  Mit Embind k√∂nnen Sie: <br><br><ul><li>  Rufen Sie C ++ - Funktionen aus JavaScript-Code auf </li><li>  Erstellen Sie JS-Objekte aus einer C ++ - Klasse </li><li>  Wenden Sie sich im C ++ - Code an die Browser-API (wenn Sie dies aus irgendeinem Grund m√∂chten, k√∂nnen Sie beispielsweise das gesamte Front-End-Framework in C ++ schreiben). </li><li>  Die Hauptsache f√ºr uns: Implementieren Sie die in C ++ beschriebene JavaScript-Schnittstelle. </li></ul><br><br><h3>  Datenaustausch </h3><br>  Der letzte Punkt ist wichtig, da dies genau die Aktion ist, die Sie beim Portieren der Anwendung st√§ndig ausf√ºhren.  Deshalb m√∂chte ich n√§her darauf eingehen.  Jetzt wird es C ++ - Code geben, aber keine Angst, es ist fast wie bei TypeScript :-D <br><br>  Das Schema ist wie folgt: <br><br><img src="https://habrastorage.org/webt/y8/b9/w7/y8b9w7ztnudrlcv5p0zzsezuzkm.png"><br><br>  Auf der C ++ - Seite gibt es einen Kernel, auf den wir beispielsweise Zugriff auf ein externes Netzwerk gew√§hren m√∂chten - um Videos hochzuladen.  Fr√ºher wurde dies mit nativen Sockets durchgef√ºhrt. Es gab eine Art HTTP-Client, der dies tat, aber in WebAssembly gibt es keine nativen Sockets.  Wir m√ºssen irgendwie raus, also schneiden wir den alten HTTP-Client ab, f√ºgen die Schnittstelle an dieser Stelle ein und implementieren diese Schnittstelle in JavaScript unter Verwendung von regul√§rem AJAX auf irgendeine Weise.  Danach geben wir das resultierende Objekt an C ++ zur√ºck, wo der Kernel es verwendet. <br><br>  Lassen Sie uns den einfachsten HTTP-Client erstellen, der nur Abrufanforderungen stellen kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Zur Eingabe erh√§lt es eine Zeichenfolge mit der herunterzuladenden URL und zur Ausgabe <br>  eine Zeichenfolge mit dem Ergebnis der Anforderung.  In C ++ k√∂nnen Zeichenfolgen Bin√§rdaten enthalten, daher ist dies f√ºr Videos geeignet.  Emscripten l√§sst uns hier schreiben <br>  so ein gruseliger Wrapper: <br><br><img src="https://habrastorage.org/webt/m_/dz/hg/m_dzhg7a0xrywq8rirnyeh1rswa.png"><br><br>  Die Hauptsache sind zwei Dinge - der Name der Funktion auf der C ++ - Seite (ich habe sie gr√ºn markiert) und die entsprechenden Namen auf der JavaScript-Seite (ich habe sie blau markiert).  Als Ergebnis schreiben wir eine Kommunikationserkl√§rung: <br><br><img src="https://habrastorage.org/webt/am/ob/qz/amobqzp-sx-3w12rnljcxlfh-fk.png"><br><br>  Es funktioniert wie Legobl√∂cke, aus denen wir es zusammensetzen.  Wir haben eine Klasse, diese Klasse hat eine Methode und wir m√∂chten von dieser Klasse erben, um die Schnittstelle zu implementieren.  Das ist alles.  Wir gehen zu JavaScript und erben.  Dies kann auf zwei Arten erfolgen.  Der erste ist verl√§ngern.  Dies ist sehr √§hnlich zu der guten alten Erweiterung von Backbone. <br><br><img src="https://habrastorage.org/webt/rt/6p/fi/rt6pfi7s3sfipms3y8lfusrqgy8.png"><br><br>  Das Modul enth√§lt alles, was Emscripten kompiliert hat, und verf√ºgt √ºber eine Eigenschaft mit einer exportierten Schnittstelle.  Wir rufen die Extend-Methode auf und √ºbergeben dort ein Objekt mit der Implementierung dieser Methode, dh einige Methoden werden in der get-Funktion implementiert <br>  Informationen mit AJAX abrufen. <br><br>  Bei der Ausgabe erhalten Sie mit "verl√§ngern" einen regul√§ren JavaScript-Konstruktor.  Wir k√∂nnen es so oft wie n√∂tig aufrufen und Objekte in der Menge generieren, die wir ben√∂tigen.  Es gibt jedoch eine Situation, in der wir ein Objekt haben und es nur an die C ++ - Seite √ºbergeben m√∂chten. <br><br><img src="https://habrastorage.org/webt/ky/ct/es/kycteslqo9rkbq5nyj1ilflq7g0.png"><br><br>  Binden Sie dazu dieses Objekt irgendwie an einen Typ, den C ++ versteht.  Dies ist, was die Implementierungsfunktion tut.  Bei der Ausgabe wird kein Konstruktor angegeben, sondern ein gebrauchsfertiges Objekt, unser Client, das wir an C ++ zur√ºckgeben k√∂nnen.  Sie k√∂nnen dies beispielsweise folgenderma√üen tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = Module.makeApp(client, ‚Ä¶)</code> </pre><br>  Angenommen, wir haben eine Factory, die unsere Anwendung erstellt und deren Abh√§ngigkeiten in Parameter wie Client und etwas anderes umwandelt.  Wenn diese Funktion funktioniert, erhalten wir das Objekt unserer Anwendung, das bereits die API enth√§lt, die wir ben√∂tigen.  Sie k√∂nnen das Gegenteil tun: <br><br><pre> <code class="cpp hljs">val client = val::global(‚Ä≥client‚Ä≥); client.call&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(‚Ä≥get‚Ä≥, val(...) );</code> </pre><br>  Nehmen Sie unseren Client direkt aus C ++ aus dem globalen Browserbereich.  Anstelle des Clients kann es au√üerdem eine beliebige Browser-API geben, die von der Konsole aus beginnt und mit der DOM-API WebRTC endet - was auch immer Sie m√∂chten.  Als n√§chstes rufen wir die Methoden dieses Objekts auf und verpacken alle Werte in die magische Klasse val, die Emscripten uns zur Verf√ºgung stellt. <br><br><h3>  Bindungsfehler </h3><br>  Im Allgemeinen ist das alles, aber wenn Sie mit der Entwicklung beginnen, erwarten Sie Bindungsfehler.  Sie sehen ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/bi/jy/uj/bijyujpafhw1vljtsptpvuzxztw.png"><br><br>  Emscripten versucht uns zu helfen und zu erkl√§ren, was falsch l√§uft.  Wenn dies alles zusammengefasst ist, m√ºssen Sie sicherstellen, dass sie √ºbereinstimmen (es ist leicht zu versiegeln und einen Bindungsfehler zu erhalten): <br><br><ul><li>  Namen </li><li>  Typen </li><li>  Anzahl der Parameter </li></ul><br>  Die Embind-Syntax ist nicht nur f√ºr Front-End-Anbieter ungew√∂hnlich, sondern auch f√ºr Benutzer von C ++.  Dies ist eine Art DSL, bei der es leicht ist, einen Fehler zu machen. Sie m√ºssen dies befolgen.  Apropos Schnittstellen: Wenn Sie eine Schnittstelle in JavaScript implementieren, muss diese genau mit der in Ihrem Vertrag beschriebenen √ºbereinstimmen. <br><br>  Wir hatten einen interessanten Fall.  Mein Kollege Jura, der auf der C ++ - Seite an dem Projekt beteiligt war, hat Extend verwendet, um seine Module zu testen.  Sie haben perfekt f√ºr ihn gearbeitet, also hat er sie begangen und an mich weitergegeben.  Ich habe implement verwendet, um diese Module in ein JS-Projekt zu integrieren.  Und sie haben aufgeh√∂rt f√ºr mich zu arbeiten.  Als wir es herausfanden, stellte sich heraus, dass wir beim Binden der Namen der Funktionen einen Tippfehler bekamen. <br><br>  Wie der Name schon sagt, ist Extend eine Erweiterung der Schnittstelle. Wenn Sie sie also irgendwo versiegelt haben, gibt Extend keinen Fehler aus, sondern entscheidet, dass Sie gerade eine neue Methode hinzugef√ºgt haben, und das ist in Ordnung. <br><br>  Das hei√üt, die Bindungsfehler werden ausgeblendet, bis die Methode selbst aufgerufen wird.  Ich schlage vor, Implement in allen F√§llen zu verwenden, in denen es Ihnen passt, da es sofort die Richtigkeit der weitergeleiteten Schnittstelle √ºberpr√ºft.  Wenn Sie jedoch Extend ben√∂tigen, m√ºssen Sie den Aufruf jeder Methode mit Tests abdecken, um ihn nicht zu verf√§lschen. <br><br><h3>  Erweitern und ES6 </h3><br>  Ein weiteres Problem mit Extend ist, dass ES6-Klassen nicht unterst√ºtzt werden.  Wenn Sie ein von einer ES6-Klasse abgeleitetes Objekt erben, erwartet Extend, dass alle Eigenschaften darin aufz√§hlbar sind, bei ES6 jedoch nicht.  Die Methoden befinden sich im Prototyp und haben folgende Aufz√§hlungen: false.  Ich benutze eine Kr√ºcke wie diese, in der ich √ºber den Prototyp gehe und aufz√§hlbar einschalte: wahr: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj.prototype) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj.prototype, prop, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) ) }</code> </pre><br>  Ich hoffe, dass ich es eines Tages loswerden kann, da in der Emscripten-Community √ºber die Verbesserung der Unterst√ºtzung f√ºr ES6 gesprochen wird. <br><br><h3>  Rom </h3><br>  Wenn man √ºber C ++ spricht, kann man nicht anders, als den Speicher zu erw√§hnen.  Als wir alles auf Video in SD-Qualit√§t √ºberpr√ºft haben, war bei uns alles in Ordnung, es hat einfach perfekt funktioniert!  Sobald wir den FullHD-Test durchgef√ºhrt haben, fehlte ein Speicherfehler.  Es spielt keine Rolle, es gibt die Option TOTAL_MEMORY, mit der der Startspeicherwert f√ºr das Modul festgelegt wird.  Wir haben ein halbes Gigabyte gemacht, alles ist in Ordnung, aber irgendwie ist es f√ºr Benutzer unmenschlich, weil wir den Speicher f√ºr alle reservieren, aber nicht jeder hat ein Abonnement f√ºr FullHD-Inhalte. <br><br>  Es gibt noch eine andere Option - ALLOW_MEMORY_GROWTH.  Es erm√∂glicht Ihnen, das Ged√§chtnis zu vergr√∂√üern <br>  nach Bedarf schrittweise.  Das funktioniert so: Emscripten gibt dem Modul standardm√§√üig 16 Megabyte f√ºr den Betrieb.  Wenn Sie sie alle verwendet haben, wird ein neuer Speicher zugewiesen.  Alle alten Daten werden dort kopiert, und Sie haben immer noch den gleichen Speicherplatz f√ºr neue.  Dies geschieht, bis Sie 4 GB erreichen. <br><br>  Angenommen, Sie haben 256 Megabyte Speicher zugewiesen, aber Sie wissen mit Sicherheit, dass Ihre Anwendung √ºber gen√ºgend Speicher verf√ºgt. Dann wird der Rest des Speichers ineffizient verwendet.  Sie haben es hervorgehoben, dem Benutzer abgenommen, aber nichts damit gemacht.  Ich m√∂chte das irgendwie vermeiden.  Es gibt einen kleinen Trick: Wir beginnen mit der Arbeit, wobei das Ged√§chtnis um das Eineinhalbfache erh√∂ht wird.  Dann erreichen wir im dritten Schritt 192 Megabyte, und genau das brauchen wir.  Wir haben den Speicherverbrauch um diesen Rest reduziert und unn√∂tige Speicherzuweisung gespart. Je weiter, desto l√§nger dauert dies.  Daher empfehle ich, beide Optionen zusammen zu verwenden. <br><br><h3>  Abh√§ngigkeitsinjektion </h3><br>  Es scheint, dass das alles war, aber dann ging der Rechen etwas mehr.  Es liegt ein Problem mit der Abh√§ngigkeitsinjektion vor.  Wir schreiben die einfachste Klasse, in der eine Abh√§ngigkeit ben√∂tigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient } }</code> </pre><br>  Zum Beispiel √ºbergeben wir unseren HTTP-Client an unsere Anwendung.  Wir speichern in der Klasseneigenschaft.  Es scheint, dass alles gut funktionieren wird. <br><br><pre> <code class="javascript hljs">Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(client) )</code> </pre><br>  Wir erben von der C ++ - Schnittstelle, erstellen zuerst unser Objekt, √ºbergeben die Abh√§ngigkeit daran und erben dann.  Zum Zeitpunkt der Vererbung macht Emscripten etwas Unglaubliches mit dem Objekt.  Es ist am einfachsten zu glauben, dass es ein altes Objekt t√∂tet, ein neues basierend auf seiner Vorlage erstellt und alle √∂ffentlichen Methoden dorthin zieht.  Gleichzeitig geht der Status des Objekts verloren und Sie erhalten ein Objekt, das nicht gebildet wird und nicht richtig funktioniert.  Die L√∂sung dieses Problems ist recht einfach.  Es ist erforderlich, einen Konstruktor zu verwenden, der nach der Vererbungsphase funktioniert. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ _construct(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent._construct.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Wir machen fast dasselbe: Wir speichern die Abh√§ngigkeit im Feld des Objekts, aber dies ist das Objekt, das sich nach der Vererbung herausgestellt hat.  Wir d√ºrfen nicht vergessen, den Konstruktoraufruf an das √ºbergeordnete Objekt weiterzuleiten, das sich auf der C ++ - Seite befindet.  Die letzte Zeile ist ein Analogon zur super () -Methode in ES6.  So geschieht die Vererbung in diesem Fall: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> appConstr = Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App() ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> appConstr(client)</code> </pre><br>  Zuerst erben wir, dann erstellen wir ein neues Objekt, an das die Abh√§ngigkeit bereits √ºbergeben wird, und das funktioniert. <br><br><h3>  Zeigertrick </h3><br>  Ein weiteres Problem ist die √úbergabe von Objekten per Zeiger von C ++ an JavaScript.  Wir haben bereits einen HTTP-Client erstellt.  Der Einfachheit halber haben wir ein wichtiges Detail √ºbersehen. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span></span></code> </pre><br>  Die Methode gibt den Wert sofort zur√ºck, dh es stellt sich heraus, dass die Anforderung synchron sein sollte.  Schlie√ülich fordert AJAX AJAX an und dass sie asynchron sind, sodass die Methode im wirklichen Leben entweder nichts zur√ºckgibt oder wir die Anforderungs-ID zur√ºckgeben k√∂nnen.  Damit jedoch jemand die Antwort zur√ºckgibt, √ºbergeben wir den Listener als zweiten Parameter, in dem R√ºckrufe von C ++ erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Listener listener)</span></span></span></span></code> </pre><br>  In JS sieht es so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ fetch(url).then(result) =&gt; { listener.onResult(result) }) }</code> </pre><br>  Wir haben eine get-Funktion, die dieses Listener-Objekt √ºbernimmt.  Wir starten den Dateidownload und legen den R√ºckruf auf.  Wenn die Datei heruntergeladen wird, ziehen wir die gew√ºnschte Funktion aus dem Listener und √ºbergeben das Ergebnis an ihn. <br><br>  Es scheint, dass der Plan gut ist, aber wenn die get-Funktion abgeschlossen ist, werden alle lokalen Variablen zerst√∂rt, und zusammen mit ihnen werden die Funktionsparameter, dh der Zeiger, zerst√∂rt, und emscripten zur Laufzeit zerst√∂rt das Objekt auf der C ++ - Seite. <br><br>  Wenn der Zeilenlistener.onResult (Ergebnis) aufgerufen wird, ist der Listener daher nicht mehr vorhanden. Beim Zugriff darauf tritt ein Speicherzugriffsfehler auf, der zum Absturz der Anwendung f√ºhrt. <br><br>  Ich m√∂chte dies vermeiden, und es gibt eine L√∂sung, aber es hat mehrere Wochen gedauert, bis ich sie gefunden habe. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listenerCopy = listener.clone() fetch(url).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { listenerCopy.onResult(result) listenerCopy.delete() }) }</code> </pre><br>  Es stellt sich heraus, dass es eine Methode zum Klonen eines Zeigers gibt.  Aus irgendeinem Grund ist es nicht dokumentiert, funktioniert aber einwandfrei und erm√∂glicht es Ihnen, die Referenzanzahl im Emscripten-Zeiger zu erh√∂hen.  Dies erm√∂glicht es uns, es in einem Abschluss auszusetzen. Wenn wir dann unseren R√ºckruf starten, ist unser Listener √ºber diesen Zeiger erreichbar und wir k√∂nnen nach Bedarf arbeiten. <br><br>  Das Wichtigste ist, nicht zu vergessen, diesen Zeiger zu l√∂schen, da dies sonst zu einem Speicherverlustfehler f√ºhrt, der sehr schlimm ist. <br><br><h3>  Schnelles Schreiben in den Speicher </h3><br>  Wenn wir Videos herunterladen, sind dies relativ gro√üe Informationsmengen, und ich m√∂chte die Menge des Hin- und Herkopierens von Daten reduzieren, um sowohl Speicher als auch Zeit zu sparen.  Es gibt einen Trick, wie eine gro√üe Menge von Informationen aus JavaScript direkt in den WebAssembly-Speicher geschrieben werden kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(‚Ä¶); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = newData.byteLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = Module._malloc(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>( Module.buffer, ptr, size ); memory.set(newData);</code> </pre><br>  newData sind unsere Daten als typisiertes Array.  Wir k√∂nnen seine L√§nge nehmen und die Zuweisung von Speicher der Gr√∂√üe, die wir ben√∂tigen, vom WebAssembly-Modul anfordern.  Die Malloc-Funktion gibt einen Zeiger an uns zur√ºck. Dies ist nur der Index des Arrays, das den gesamten Speicher in WebAssembly enth√§lt.  Von der JavaScript-Seite sieht es einfach wie ein ArrayBuffer aus. <br><br>  Im n√§chsten Schritt schneiden wir von einer bestimmten Stelle aus ein Fenster in diesen ArrayBuffer der richtigen Gr√∂√üe und kopieren dort unsere Daten.  Trotz der Tatsache, dass die Set-Operation eine Kopiersemantik aufweist, sah ich beim Betrachten dieses Abschnitts im Profiler keinen langen Prozess.  Ich denke, dass der Browser diesen Vorgang mit Hilfe der Verschiebungssemantik optimiert, dh den Besitz des Speichers von einem Objekt auf ein anderes √ºbertr√§gt. <br><br>  In unserer Anwendung verlassen wir uns auch auf die Verschiebungssemantik, um Speicherkopien zu sparen. <br><br><h3>  Adblock </h3><br>  Ein interessantes Problem bei der √Ñnderung mit Adblock.  Es stellt sich heraus, dass in Russland alle beliebten Blocker ein Abonnement f√ºr die RU-Adlist erhalten, und es gibt eine wunderbare Regel, die das Herunterladen von WebAssembly von Websites von Drittanbietern verbietet.  Zum Beispiel mit einem CDN. <br><br><img src="https://habrastorage.org/webt/os/wt/kg/oswtkgtaeovfuk9r4d-gehdwdwe.png"><br><br>  Der Ausweg besteht nicht darin, das CDN zu verwenden, sondern alles auf Ihrer Domain zu speichern (dies passt nicht zu uns).  Oder benennen Sie die WASM-Datei um, damit sie nicht dieser Regel entspricht.  Sie k√∂nnen immer noch zum Forum dieser Genossen gehen und versuchen, sie davon zu √ºberzeugen, diese Regel zu entfernen.  Ich denke, sie rechtfertigen sich, indem sie auf diese Weise gegen die Bergleute k√§mpfen, obwohl ich nicht wei√ü, warum die Bergleute nicht raten k√∂nnen, die Datei umzubenennen. <br><br><h2>  Produktion </h2><br>  Infolgedessen gingen wir in Produktion.  Ja, es war nicht einfach, es hat 8 Monate gedauert und ich m√∂chte mich fragen, ob es sich gelohnt hat.  Meiner Meinung nach hat es sich gelohnt: <br><br><h3>  Keine Notwendigkeit zu installieren </h3><br>  Wir haben festgestellt, dass unser Code an den Benutzer geliefert wird, ohne dass Programme installiert werden m√ºssen.  Wenn wir ein Browser-Plug-In hatten, musste der Benutzer es herunterladen und installieren, und dies ist ein riesiger Filter f√ºr die Technologieverteilung.  Jetzt sieht sich der Benutzer nur noch das Video auf der Website an und versteht nicht einmal, dass eine ganze Maschine unter der Haube arbeitet und dass dort alles kompliziert ist.  Der Browser l√§dt nur eine zus√§tzliche Datei mit dem Code herunter, z. B. ein Bild oder eine CSS-Datei. <br><br><h3>  Einheitliche Codebasis und Debugging auf verschiedenen Plattformen </h3><br>  Gleichzeitig konnten wir unsere einzelne Codebasis beibehalten.  Wir k√∂nnen denselben Code auf verschiedenen Plattformen verdrehen, und es ist wiederholt vorgekommen, dass Fehler, die auf einer der Plattformen unsichtbar waren, auf der anderen auftraten.  Auf diese Weise k√∂nnen wir versteckte Fehler mit verschiedenen Tools auf verschiedenen Plattformen erkennen. <br><br><h3>  Schnellspanner </h3><br>  Wir haben eine schnelle Version erhalten, da wir als einfache Webanwendung ver√∂ffentlicht werden k√∂nnen und den C ++ - Code mit jeder neuen Version aktualisieren k√∂nnen.  Es ist nicht vergleichbar mit der Ver√∂ffentlichung neuer Plugins, einer mobilen Anwendung oder einer SmartTV-Anwendung.  Die Ver√∂ffentlichung h√§ngt nur von uns ab: Wenn wir wollen, wird sie ver√∂ffentlicht. <br><br><h3>  Schnelles Feedback </h3><br>  Und das bedeutet schnelles Feedback: Wenn etwas schief geht, k√∂nnen wir tags√ºber feststellen, dass ein Problem vorliegt, und darauf reagieren. <br><br>  Ich glaube, dass all diese Probleme diese Vorteile wert waren.  Nicht jeder hat eine C ++ - Anwendung, aber wenn Sie eine haben und diese im Browser haben m√∂chten, ist WebAssembly ein 100% iger Anwendungsfall f√ºr Sie. <br><br><h2>  Wo bewerben? </h2><br>  Nicht jeder schreibt in C ++.  F√ºr WebAssembly ist jedoch nicht nur C ++ verf√ºgbar.  Ja, dies ist historisch gesehen die allererste Plattform, die noch in asm.js, einer fr√ºhen Mozilla-Technologie, verf√ºgbar war.  √úbrigens hat es also ziemlich gute Werkzeuge, wie  Sie sind √§lter als die Technologie selbst. <br><br><h3>  Rost </h3><br>  Die neue Rust-Sprache, die ebenfalls von Mozilla entwickelt wird, holt C ++ jetzt in Bezug auf Tools ein und √ºberholt es.  Alles geht so weit, dass sie den coolsten Entwicklungsprozess f√ºr WebAssembly machen. <br><br><h3>  Lua, Perl, Python, PHP usw. </h3><br>  Fast alle interpretierten Sprachen sind auch in WebAssembly verf√ºgbar, da ihre Interpreter in C ++ geschrieben sind. Sie wurden einfach in WebAssembly kompiliert und jetzt k√∂nnen Sie PHP in einem Browser drehen. <br><br><h3>  Geh </h3><br>  In Version 1.11 haben sie eine Beta-Version der Kompilierung in WebAssembly erstellt, in 2.0 versprechen sie Release-Unterst√ºtzung.  Ihre Unterst√ºtzung wurde sp√§ter angezeigt, da WebAssembly den Garbage Collector nicht unterst√ºtzt und Go eine Sprache f√ºr verwalteten Speicher ist.  Also mussten sie ihren Garbage Collector unter WebAssembly ziehen. <br><br><h3>  Kotlin / Native </h3><br>  √úber die gleiche Geschichte mit Kotlin.  Ihr Compiler hat experimentelle Unterst√ºtzung, aber sie m√ºssen auch etwas mit dem Garbage Collector tun.  Ich wei√ü nicht, welchen Status es gibt. <br><br><h3>  3D-Grafiken </h3><br>  Was k√∂nnen Sie noch denken? ,     ‚Äî 3D-. , ,  asm.js  WebAssembly      .  ,         WebAssembly. <br><br><img src="https://habrastorage.org/webt/lt/u2/7q/ltu27qaab_yjbryhnm_ayf-edsa.png"><br><br><h3>    </h3><br>           ,   :      ,  ,  .    ,             . <br><br><h3>   </h3><br><br><img src="https://habrastorage.org/webt/2u/mi/dz/2umidzjddihmiikdgktwjdk4hpe.png"><br><br>         . , ,      ,     ,         . , ,        ;   ‚Äî   . <br><br><img src="https://habrastorage.org/webt/0q/-e/0s/0q-e0sqshcd_t-p4ioyhtoe0z-k.png"><br><br> ,  Google Chrome,      ,    WebAssembly-.     npm-  ,   Wasm,     JS.      , ++  -  ‚Äî    . <br><br>      HunSpell ‚Äî      Wasm . <br><br><h3>  </h3><br>      ‚Äî ¬´   ¬ª.     , -        ,       ‚Äî  OpenSSL.       WebAssembly. OpenSSL ‚Äî   ,   ,    . <br><br><h3>     </h3><br>  use case    wotinspector.com.     World of Tanks.     ,  ,    ,   ,  ,      . <br><br>   ‚Äî      .      ,       ,   .    ,  ,  -  ++,    WebAssembly,            (   ,        ). <br><br>        .  ,     ,     .       .     ,     ,      ,   ,      .        .    . <br><br><h3>  </h3><br>      ,      , ++. ,  FFmpeg,      .      ,   ffmpeg.          .     , ,     ,      ,     . <br><br><img src="https://habrastorage.org/webt/aa/tu/u8/aatuu8b5uzbxmnhv_8mjb93jcxa.png"><br><br>     ‚Äî            .   OpenCV ‚Äî    ,   WebAssembly,        .    PDF.      SQLite,    SQL.  SQLite  WebAssembly   Emscripten,      . <br><br><h3>  Node.js </h3><br><br><img src="https://habrastorage.org/webt/dl/mf/tn/dlmftnxe8bjvt-ys-jyyy-aunde.png"><br><br>       WebAssembly,    Node.js. ,   Sass ‚Äî  css.     Ruby,       ++ ( libsass).          ,       Webpack',       Node.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">node-sass</a>   ,  JS-   . <br><br>  ,         ,      .       .    : <br><br><img src="https://habrastorage.org/webt/bv/s0/rp/bvs0rpy6naa9-dhac6zingbv-cw.png"><br><br>    ,     node-sass    100      .     ,        ( ) .  WebAssembly   :       ,     WebAssembly    . <br><br>                    Node.    ,   WebAssembly     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libsass-asm</a> .   ,       .      WebAssembly   ‚Ä¶ <br><br><h3>   </h3><br>    Figma ‚Äî    web-.   -   Sketch,     ,     .    ++ (    ),     asm.js.   ,    . <br><br><img src="https://habrastorage.org/webt/ht/ad/2t/htad2t3hmsfx_txwjfhk-_qlh2w.png"><br><br>   WebAssembly,    ,      3 .     ,         . <br><br>     Visual Studio Code,   ,    Electron,        ,          ,   Node-sass. ,     Node,            . ,  ,     ,      WebAssembly. <br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/tz/qg/2a/tzqg2a7sw01qlqnvwjcjzkxqkyw.png"><br><br>        ‚Äî AutoCAD.   30 ,    ++,     .      ,    ,              -  JavaScript,    ,      .    WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoCAD   -</a> ,     5      . <br><br>   ,    , ,   , ,       ,    , ,    .   FFMpeg ‚Äî   ,     ‚Äî QEMU. ,     ,       KVM,        . <br><br><img src="https://habrastorage.org/webt/zq/3c/aj/zq3cajq6z-ftdftt0a1bnveqj1m.png"><br><br>   2011   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> QEMU  </a> .  ,             .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">Linux  </a> ,  Linux-,     , -  . <br><br>   ,    .   bash,    ,     Linux.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">  ‚Äî  GUI</a> .       .  ,    ,        ‚Ä¶ <br><br><img src="https://habrastorage.org/webt/jf/zc/bo/jfzcbori9ee4oah-1nmumj8ebqk.png"><br><br> ,     ,  - . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D"> Windows 2000</a> ,  ,   18  ,       .     ,     Chrome ( FireFox). <br><br>   ,  WebAssembly ,    ,   ,      ,     . <br><br><h2>      </h2><br>       ,       WebAssembly. ,     ‚Äî  ,  .   ‚Äî  ,       . <br><br><img src="https://habrastorage.org/webt/ea/ls/ak/ealsak2klb2rgvobxmirs1rn0_s.png"><br><br>  ,     C++      web-.   ,  ,       ‚Äî      .    ‚Äî  ,      ,      ,     . <br><br>  ,      .   ,    C++,      JavaScript,        .     ,         C++.              ,       JS  C++,      . <br><br>         ‚Äî   . <br><br><img src="https://habrastorage.org/webt/fx/nj/wb/fxnjwbotpkneisrtmlze8-0afdy.png"><br><br><h2> CI Pipeline </h2><br>      ?    JS-   ,        Webpack.      ,   ,  (     ),       JS.    webpack   watch,  ,          . <br><br><img src="https://habrastorage.org/webt/zv/s_/r4/zvs_r45efsroktebku2lrdmuv9e.png"><br><br><h2>  </h2><br>  ,     .  ,  ,    . <br><br>   Chrome   DevTools,      Sources   wasm-.     (    - ), ,  ,      . <br><br><img src="https://habrastorage.org/webt/ea/ir/8u/eair8uahusoyylejgtccro0g1-a.png"><br><br>    ,        ,      : ¬´,     , ,    ,  ,   !¬ª.  ,     embedded-,    ,    -     . <br><br>   :     -g4  wast-   ,     . <br><br><img src="https://habrastorage.org/webt/0k/6w/af/0k6wafnm3pp62o-a5t8dcoxivxy.png"><br><br>   ,      100  (  FAR).  ‚Äî  ,       Chrome. E:/_work/bfg/bytefrog/‚Ä¶ ‚Äî    .    ,      ++     .   ,    SourceMap! <br><br><h2> SourceMap </h2><br>  ,     . <br><ul><li>    Firefox. </li><li> --sourcemap-base=http://localhost  ,    SourceMap   -,    . </li><li>     HTTP. </li><li>       . </li><li>  Windows    ¬´:¬ª  .     . </li></ul><br><br>     . CMake        ,        URL  -.    :  wast-       ,    . ,     . <br><br>  ,    : <br><br><img src="https://habrastorage.org/webt/ev/hn/fo/evhnfovmbp4hdynewi_r6buhx_a.png"><br><br>  ++   .    !   ,   ,  stack trace,      .  ,     wasm-  stack trace,   ,   , , ,  . <br><br><img src="https://habrastorage.org/webt/ql/zi/x8/qlzix8vqcrbdziehrmmrmq4uz0a.png"><br><br>  ,      ‚Äî SourceMap     .  ,        ,    .           ,      . <br><br><img src="https://habrastorage.org/webt/vk/e4/vk/vke4vkmnpcbp9gm8tuac-92xany.png"><br><br>             ¬´var0¬ª. <br><br><img src="https://habrastorage.org/webt/yh/rc/xx/yhrcxxqcvj0upcy6negdcw0b9c0.png"><br><br> ,           . ,      SourceMap,       ,   . <br><br><h2>  </h2><br>     .     Chrome,   Firefox.  Firefox  ‚Äî  ¬´¬ª ,    ,      . <br><br><img src="https://habrastorage.org/webt/bv/va/x1/bvvax1w0kvo4gsmx7ry0bgbekhe.png"><br><br> Chrome    ( ,  ,  Mangled  ), ,  ,  ,    . <br><br><img src="https://habrastorage.org/webt/gv/jh/rp/gvjhrpyqjxyvsyq4xjigmdmwxa8.png"><br><br><h2>  </h2><br>   .     ,   : <br><br><ul><li> .     runtime,   .   ++      Rust  Go. </li><li>    JS ‚Äî Wasm.     ,         JS  Wasm.      -,    ,    .      ,    . </li><li>  .  ,   ,     ,       . </li><li> Wasm   . Wasm  ,       JS.  WebAssembly   ,       . </li><li>        JS. </li></ul><br><br>    :    . <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasp_cpp_bench</a> </li><li> Chrome 65.0.3325.181 (64-bit) </li><li> Core i5-4690 </li><li> 24gb ram </li><li> 5 ;  max  min;  </li></ul><br><br>   .         JS ‚Äî  ,     . <br><br><img src="https://habrastorage.org/webt/sg/e7/to/sge7toujmxycrhznogviscz94dy.png"><br><br> ++,   ,   -  .      Grayscale.   C++    ,   .     ( ),   ,    JS. ,  ,       ,   ++,   . <br><h2>     </h2><br>   Sentry,      ‚Äî     wasm. ,   traceKit,    Sentry ‚Äî Raven, ‚Äî    ,    ,  wasm .   , , ,    pull request,     npm install  JS-. <br><br><img src="https://habrastorage.org/webt/rd/vm/-z/rdvm-zijheakjsktoubausmmyc8.png"><br><br>    .   production,     ,   .    debug-,     ,    : <br><br><img src="https://habrastorage.org/webt/gn/e_/_t/gne__tfliahfwe1sfndiid2tmyq.png"><br><br><h2>  </h2><br><ul><li> WebAssembly     ,     . </li><li>     ‚Äî .     8 ,           C++,   ,    . </li><li>   ,      ,   WebAssembly ‚Äî     . </li><li>  ‚Äî   JS.  JS-      ,    ¬´¬ª   ,     ,     . </li></ul><br><br>    , : <br><ul><li>  Emscripten  Embind.     . </li><li>   -   Emscripten ‚Äî   .  ,    ,     3000      Emscripten. </li><li>     Sentry. </li><li>   Firefox. </li></ul><br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit!      . <br><br><img src="https://habrastorage.org/webt/2h/qu/au/2hquauawvppoc-iu5un4wgevnvo.png"><br><br><blockquote>        HolyJS,  : <b>24-25   </b>   <b>HolyJS</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>      (,   Node.js Ryan Dahl!),      ‚Äî   1   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441140/">https://habr.com/ru/post/de441140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441130/index.html">Ausgewogene Site-Leistung. Teil 1: Strategie</a></li>
<li><a href="../de441132/index.html">Damit Roskomnadzor nicht PL√ñTZLICH kommt</a></li>
<li><a href="../de441134/index.html">Emotionen, selbst√§ndige Arbeit</a></li>
<li><a href="../de441136/index.html">Langzeitspeicherung von Prometheus-Metriken (Alexey Palazhchenko, Percona)</a></li>
<li><a href="../de441138/index.html">Echtzeit-Chat-L√∂sungen gegen Chat-Plattformen - Treffen Sie Ihre Wahl</a></li>
<li><a href="../de441142/index.html">12 Punkte Conversion-Wachstum oder Inhalte, die sich wirklich verkaufen</a></li>
<li><a href="../de441146/index.html">Industrielle drahtlose Netzwerke: Welches soll man w√§hlen?</a></li>
<li><a href="../de441148/index.html">Wie man richtig mit Fehlern umgeht: Stille ist nicht immer gut</a></li>
<li><a href="../de441150/index.html">Erste Einf√ºhrung in das HTTP-Protokoll durch Schreiben des einfachsten Java-Webservers</a></li>
<li><a href="../de441152/index.html">So minimieren Sie Fehler bei der Integration in externe Services: die Erfahrung eines Online-Brokers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>