<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 👨‍🎨 💪🏿 WebAssembly-Entwicklung: echter Rechen und Beispiele 🚶 🐮 🍌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Ankündigung von WebAssembly erfolgte im Jahr 2015 - aber jetzt, nach Jahren, gibt es nur noch wenige, die sich in der Produktion damit rühmen könn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebAssembly-Entwicklung: echter Rechen und Beispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/441140/"><img src="https://habrastorage.org/webt/e5/pu/-s/e5pu-s7yjpdm8dddc42_nxa1uve.jpeg"><br><br>  Die Ankündigung von WebAssembly erfolgte im Jahr 2015 - aber jetzt, nach Jahren, gibt es nur noch wenige, die sich in der Produktion damit rühmen können.  Die Materialien zu solchen Erfahrungen sind umso wertvoller: Informationen darüber, wie man in der Praxis damit umgeht, sind immer noch Mangelware. <br><br>  Auf der HolyJS-Konferenz erhielt ein Bericht über die Erfahrungen mit der Verwendung von WebAssembly gute Noten vom Publikum, und jetzt wurde eine Textversion dieses Berichts speziell für Habr erstellt (ein Video ist ebenfalls beigefügt). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uqG9DiT80UE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Mein Name ist Andrey, ich werde Ihnen von WebAssembly erzählen.  Wir können sagen, dass ich im letzten Jahrhundert angefangen habe, mich mit dem Internet zu beschäftigen, aber ich bin bescheiden, also werde ich das nicht sagen.  In dieser Zeit konnte ich sowohl am Backend als auch am Frontend arbeiten und sogar ein kleines Design zeichnen.  Heute interessiere ich mich für Dinge wie WebAssembly, C ++ und andere native Dinge.  Ich liebe auch Typografie und sammle alte Technologie. <br><br>  Zuerst werde ich darüber sprechen, wie das Team und ich WebAssembly in unserem Projekt implementiert haben, dann werden wir diskutieren, ob Sie etwas von WebAssembly benötigen, und mit ein paar Tipps abschließen, falls Sie es selbst implementieren möchten. <br><br><h2>  Wie wir WebAssembly implementiert haben </h2><br>  Ich arbeite für Inetra, wir befinden uns in Nowosibirsk und machen einige unserer eigenen Projekte.  Einer von ihnen ist ByteFog.  Dies ist eine Peer-to-Peer-Technologie zur Bereitstellung von Videos für Benutzer.  Unsere Kunden sind Dienste, die eine große Menge an Videos verbreiten.  Sie haben ein Problem: Wenn ein beliebtes Ereignis stattfindet, beispielsweise eine Pressekonferenz oder ein Sportereignis, wie man sich nicht darauf vorbereitet, kommen eine Reihe von Kunden herein, stützen sich auf den Server, und der Server ist traurig.  Kunden erhalten zu diesem Zeitpunkt eine sehr schlechte Videoqualität. <br><br>  Aber jeder sieht den gleichen Inhalt.  Lassen Sie uns benachbarte Geräte von Benutzern bitten, Videoteile freizugeben. Anschließend werden wir den Server entladen, Bandbreite sparen und Benutzer erhalten Videos in besserer Qualität.  Diese Clouds sind unsere Technologie, unser ByteFog-Proxyserver. <br><br><img src="https://habrastorage.org/webt/ir/yw/xl/irywxlozwzz4kbedspsf14lx4ie.png"><br><br>  Wir müssen auf jedem Gerät installiert sein, das Videos anzeigen kann. Daher unterstützen wir eine Vielzahl von Plattformen: Windows, Linux, Android, iOS, Web, Tizen.  Welche Sprache soll gewählt werden, um auf allen diesen Plattformen eine einzige Codebasis zu haben?  Wir haben uns für C ++ entschieden, weil es die meisten Vorteile hat :-D Im Ernst, wir haben gute Kenntnisse in C ++, es ist wirklich eine schnelle Sprache und in Bezug auf die Portabilität ist es wahrscheinlich die zweitwichtigste nach C. <br><br>  Wir haben eine ziemlich große Anwendung (900 Klassen), aber es funktioniert gut.  Unter Windows und Linux kompilieren wir in nativen Code.  Für Android und iOS erstellen wir eine Bibliothek, die wir mit der Anwendung verbinden.  Wir werden ein anderes Mal über Tizen sprechen, aber im Web haben wir früher als Browser-Plugin gearbeitet. <br><br>  Dies ist die Netscape Plugin API-Technologie.  Wie der Name schon sagt, ist es ziemlich alt und hat auch einen Nachteil: Es bietet einen sehr breiten Zugriff auf das System, sodass Benutzercode ein Sicherheitsproblem verursachen kann.  Dies ist wahrscheinlich der Grund, warum Chrome die Unterstützung für diese Technologie im Jahr 2015 deaktiviert hat und dann alle Browser diesem Flash-Mob beigetreten sind.  So blieben wir fast zwei Jahre ohne Webversion. <br><br>  2017 kam eine neue Hoffnung.  Wie Sie sich vorstellen können, ist dies WebAssembly.  Aus diesem Grund haben wir uns die Aufgabe gestellt, unsere Anwendung auf einen Browser zu portieren.  Da die Unterstützung für Firefox und Chrome bereits im Frühjahr und im Herbst 2017 erschien, haben sich Edge und Safari hochgezogen. <br><br>  Für uns war es wichtig, vorgefertigten Code zu verwenden, da wir eine Menge Geschäftslogik haben, die wir nicht verdoppeln wollten, um die Anzahl der Fehler nicht zu verdoppeln.  Nimm den Compiler Emscripten.  Er tut, was wir brauchen - kompiliert die positive Anwendung in den Browser und erstellt die Umgebung neu, die der nativen Anwendung im Browser vertraut ist.  Wir können sagen, dass Emscripten ein solches Browserify für C ++ - Code ist.  Außerdem können Sie Objekte von C ++ an JavaScript weiterleiten und umgekehrt.  Unser erster Gedanke war: Nehmen wir jetzt Emscripten, kompilieren Sie einfach und alles wird funktionieren.  Natürlich nicht.  Von hier aus begann unsere Reise entlang des Rechen. <br><br>  Das erste, was uns begegnete, war Sucht.  In unserer Codebasis befanden sich mehrere Bibliotheken.  Jetzt macht es keinen Sinn, sie aufzulisten, aber für diejenigen, die verstehen, haben wir Boost.  Dies ist eine große Bibliothek, mit der Sie plattformübergreifenden Code schreiben können, aber es ist sehr schwierig, die Kompilierung damit zu konfigurieren.  Ich wollte so wenig Code wie möglich in den Browser ziehen. <br><br><h3>  Bytefog-Architektur </h3><br>  Als Ergebnis haben wir den Kern identifiziert: Wir können sagen, dass dies ein Proxyserver ist, der die Hauptgeschäftslogik enthält.  Dieser Proxyserver nimmt Daten aus zwei Quellen auf.  Das erste und wichtigste ist HTTP, dh ein Kanal zum Videoverteilungsserver, das zweite ist unser P2P-Netzwerk, dh ein Kanal zu einem anderen gleichen Proxy von einem anderen Benutzer.  Wir geben die Daten in erster Linie an den Player weiter, da es unsere Aufgabe ist, dem Benutzer qualitativ hochwertige Inhalte anzuzeigen.  Wenn noch Ressourcen vorhanden sind, verteilen wir den Inhalt an das P2P-Netzwerk, damit andere Benutzer ihn herunterladen können.  Im Inneren befindet sich ein intelligenter Cache, der die ganze Magie ausübt. <br><br><img src="https://habrastorage.org/webt/vi/id/zt/viidzt9cctzun2_em3ka8jfm8pu.png"><br><br>  Nachdem wir dies alles kompiliert haben, sehen wir uns mit der Tatsache konfrontiert, dass WebAssembly in der Browser-Sandbox ausgeführt wird.  Das heißt, es kann nicht mehr als JavaScript.  Während native Anwendungen viele plattformspezifische Dinge verwenden, wie z. B. ein Dateisystem, ein Netzwerk oder Zufallszahlen.  Alle diese Funktionen müssen mit dem, was der Browser uns gibt, in JavaScript implementiert werden.  Diese Platte listet die ziemlich offensichtlichen Ersetzungen auf, die aufgelistet sind. <br><br><img src="https://habrastorage.org/webt/ii/uv/bf/iiuvbfvwjvul6pbnkuptqku8amo.png"><br><br>  Um dies zu ermöglichen, ist es erforderlich, die Implementierung nativer Funktionen in einer nativen Anwendung abzuschneiden und dort eine Schnittstelle einzufügen, dh einen bestimmten Rand zu zeichnen.  Dann implementieren Sie dies in JavaScript und verlassen die native Implementierung, und bereits während der Assembly wird die erforderliche ausgewählt.  Also haben wir uns unsere Architektur angesehen und alle Orte gefunden, an denen diese Grenze gezogen werden kann.  Zufälligerweise ist dies ein Transportsubsystem. <br><br><img src="https://habrastorage.org/webt/ok/eq/w-/okeqw-dc-weuwlqxed4iy2x5nn4.png"><br><br>  Für jeden dieser Orte haben wir eine Spezifikation definiert, dh wir haben einen Vertrag festgelegt: Welche Methoden werden verwendet, welche Parameter werden sie haben, welche Datentypen.  Sobald Sie dies getan haben, können Sie parallel arbeiten, wobei jeder Entwickler auf seiner Seite steht. <br><br>  Was ist das Ergebnis?  Wir haben den Haupt-Videoübertragungskanal des Anbieters durch den üblichen AJAX ersetzt.  Wir geben Daten über die beliebte HLS.js-Bibliothek an den Player aus, es besteht jedoch eine grundlegende Möglichkeit, diese bei Bedarf in andere Player zu integrieren.  Wir haben die gesamte P2P-Schicht durch WebRTC ersetzt. <br><br><img src="https://habrastorage.org/webt/g8/dc/mt/g8dcmtbxfugjxpycyzpabtb6nto.png"><br><br>  Durch die Kompilierung werden mehrere Dateien erhalten.  Das wichtigste ist der binäre .wasm.  Es enthält den kompilierten Bytecode, den der Browser ausführt und der Ihr gesamtes C ++ - Erbe enthält.  Aber an sich funktioniert es nicht, der sogenannte "Klebercode" ist notwendig, er wird auch vom Compiler generiert.  Der Klebercode lädt eine Binärdatei herunter, und Sie laden beide Dateien in die Produktion hoch.  Zu Debugging-Zwecken können Sie eine Textdarstellung des Assemblers generieren - eine .wast-Datei und eine Quellkarte.  Sie müssen verstehen, dass sie sehr groß sein können.  In unserem Fall erreichten sie 100 Megabyte oder mehr. <br><br><h3>  Das Bündel sammeln </h3><br>  Schauen wir uns den Klebercode genauer an.  Dies ist das übliche gute alte ES5, das in einer einzigen Datei zusammengefasst ist.  Wenn wir es mit einer Webseite verbinden, haben wir eine globale Variable, die unser gesamtes instanziiertes Wasm-Modul enthält, das bereit ist, Anforderungen an seine API anzunehmen. <br><br>  Das Einfügen einer separaten Datei ist jedoch eine ziemlich schwerwiegende Komplikation für die Bibliothek, die Benutzer verwenden werden.  Wir möchten alles in einem einzigen Bündel zusammenfassen.  Hierfür verwenden wir Webpack und eine spezielle Kompilierungsoption MODULARIZE. <br><br>  Es klebt den Klebercode in das "Modul" -Muster und wir können ihn aufgreifen: Importieren oder Verwenden erfordern, wenn wir auf ES5 schreiben - Webpack versteht diese Abhängigkeit ruhig.  Es gab ein Problem mit Babel - er mochte die große Menge an Code nicht, aber dies ist ein ES5-Code, er muss nicht transponiert werden, wir fügen ihn einfach hinzu, um ihn zu ignorieren. <br><br>  Um die Anzahl der Dateien zu ermitteln, habe ich mich für die Option SINGLE_FILE entschieden.  Es übersetzt alle aus der Kompilierung resultierenden Binärdateien in das Base64-Formular und verschiebt sie als Zeichenfolge in den Klebecode.  Klingt nach einer großartigen Idee, aber danach wurde das Bundle 100 Megabyte groß.  Weder Webpack noch Babel noch der Browser funktionieren auf einem solchen Volume.  Auf jeden Fall werden wir den Benutzer nicht zwingen, 100 Megabyte zu laden ?! <br><br>  Wenn Sie darüber nachdenken, wird diese Option nicht benötigt.  Adhesive Code lädt Binärdateien selbst herunter.  Er macht das über HTTP, damit wir sofort zwischenspeichern können. Wir können alle gewünschten Header festlegen, z. B. die Komprimierung aktivieren, und WebAssembly-Dateien werden perfekt komprimiert. <br><br>  Die coolste Technologie ist jedoch das Streaming von Kompilierungen.  Das heißt, die WebAssembly-Datei kann beim Herunterladen vom Server bereits im Browser kompiliert werden, wenn Daten eintreffen. Dies beschleunigt das Laden Ihrer Anwendung erheblich.  Im Allgemeinen konzentriert sich die gesamte WebAssembly-Technologie auf den schnellen Start einer großen Codebasis. <br><br><h3>  Dann möglich </h3><br>  Ein weiteres Problem mit dem Modul besteht darin, dass es sich um ein Thenable-Objekt handelt, dh über eine .then () -Methode.  Diese Funktion ermöglicht es Ihnen, einen Rückruf zum Zeitpunkt des Starts des Moduls aufzuhängen, und ist sehr praktisch.  Aber ich möchte, dass die Benutzeroberfläche zu Promise passt.  Thenable ist kein Versprechen, aber es ist okay, lassen Sie es uns selbst einpacken.  Schreiben wir einen so einfachen Code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { Module(config).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); }); });</code> </pre> <br>  Wir erstellen Promise, starten unser Modul und rufen als Rückruf die Auflösungsfunktion auf und übergeben das dort installierte Modul.  Alles scheint offensichtlich zu sein, alles ist in Ordnung, wir starten - etwas stimmt nicht, unser Browser ist eingefroren, unsere DevTools hängen und der Prozessor heizt sich auf dem Computer auf.  Wir verstehen nichts - eine Art Rekursion oder eine Endlosschleife.  Das Debuggen ist ziemlich schwierig, und als wir JavaScript unterbrochen haben, sind wir in der Then-Funktion im Emscripten-Modul gelandet. <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'then'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Module; };</code> </pre><br>  Schauen wir uns das genauer an.  Handlung <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); };</code> </pre><br>  verantwortlich für das Aufhängen eines Rückrufs.  Hier ist alles klar: eine asynchrone Funktion, die unseren Rückruf aufruft.  Alles wie wir wollen.  Es gibt noch einen weiteren Teil dieser Funktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module);</code> </pre><br>  Es wird aufgerufen, wenn das Modul bereits gestartet wurde.  Dann wird der Rückruf sofort synchron aufgerufen und das Modul im Parameter an ihn übergeben.  Dies ahmt das Verhalten von Promise nach und scheint das zu sein, was wir erwarten.  Aber was ist dann falsch? <br><br>  Wenn Sie die Dokumentation sorgfältig lesen, stellt sich heraus, dass Promise einen sehr subtilen Punkt hat.  Wenn wir das Versprechen mit einem Thenable auflösen, packt der Browser die Werte aus diesem Thenable aus und ruft dazu die .then () -Methode auf.  Infolgedessen lösen wir das Versprechen und übergeben das Modul an es.  Der Browser fragt: Ist das dann ein Objekt?  Ja, das ist ein Thenable.  Dann wird die Funktion .then () für das Modul aufgerufen und die Auflösungsfunktion selbst als Rückruf übergeben. <br><br>  Das Modul prüft, ob es läuft.  Es wird bereits ausgeführt, sodass der Rückruf sofort aufgerufen wird und dasselbe Modul erneut an ihn übergeben wird.  Als Rückruf haben wir die Auflösungsfunktion und der Browser fragt: Ist dies ein Thenable-Objekt?  Ja, das ist ein Thenable.  Und alles beginnt von vorne.  Infolgedessen geraten wir in einen endlosen Zyklus, aus dem der Browser niemals zurückkehrt. <br><br><img src="https://habrastorage.org/webt/ks/rr/c-/ksrrc-zeix0ffh_uott4ahpt3qc.png"><br><br>  Ich habe keine elegante Lösung für dieses Problem gefunden.  Infolgedessen lösche ich einfach die .then () -Methode vor dem Auflösen, und dies funktioniert. <br><br><h3>  Emscripten </h3><br>  Also haben wir das Modul kompiliert, JS zusammengestellt, aber etwas fehlt.  Wir müssen wahrscheinlich nützliche Arbeit leisten.  Übertragen Sie dazu Daten und verbinden Sie die beiden Welten - JS und C ++.  Wie kann man das machen?  Emscripten bietet drei Optionen: <br><br><ul><li>  Die erste ist die Funktionen ccall und cwrap.  Meistens werden Sie sie in einigen Tutorials zu WebAssembly kennenlernen, aber sie sind nicht für echte Arbeit geeignet, da sie die Funktionen von C ++ nicht unterstützen. </li><li>  Der zweite ist WebIDL Binder.  Es unterstützt bereits C ++ - Funktionen, Sie können bereits damit arbeiten.  Dies ist eine seriöse Schnittstellenbeschreibungssprache, die beispielsweise von W3C für ihre Dokumentation verwendet wird.  Wir wollten es aber nicht in unser Projekt aufnehmen und nutzten die dritte Option </li><li>  Einbinden.  Wir können sagen, dass dies eine native Methode zum Verbinden von Objekten für Emscripten ist. Sie basiert auf C ++ - Vorlagen und ermöglicht es Ihnen, viele Dinge zu tun, indem Sie verschiedene Entitäten von C ++ an JS und umgekehrt weiterleiten. </li></ul><br><br>  Mit Embind können Sie: <br><br><ul><li>  Rufen Sie C ++ - Funktionen aus JavaScript-Code auf </li><li>  Erstellen Sie JS-Objekte aus einer C ++ - Klasse </li><li>  Wenden Sie sich im C ++ - Code an die Browser-API (wenn Sie dies aus irgendeinem Grund möchten, können Sie beispielsweise das gesamte Front-End-Framework in C ++ schreiben). </li><li>  Die Hauptsache für uns: Implementieren Sie die in C ++ beschriebene JavaScript-Schnittstelle. </li></ul><br><br><h3>  Datenaustausch </h3><br>  Der letzte Punkt ist wichtig, da dies genau die Aktion ist, die Sie beim Portieren der Anwendung ständig ausführen.  Deshalb möchte ich näher darauf eingehen.  Jetzt wird es C ++ - Code geben, aber keine Angst, es ist fast wie bei TypeScript :-D <br><br>  Das Schema ist wie folgt: <br><br><img src="https://habrastorage.org/webt/y8/b9/w7/y8b9w7ztnudrlcv5p0zzsezuzkm.png"><br><br>  Auf der C ++ - Seite gibt es einen Kernel, auf den wir beispielsweise Zugriff auf ein externes Netzwerk gewähren möchten - um Videos hochzuladen.  Früher wurde dies mit nativen Sockets durchgeführt. Es gab eine Art HTTP-Client, der dies tat, aber in WebAssembly gibt es keine nativen Sockets.  Wir müssen irgendwie raus, also schneiden wir den alten HTTP-Client ab, fügen die Schnittstelle an dieser Stelle ein und implementieren diese Schnittstelle in JavaScript unter Verwendung von regulärem AJAX auf irgendeine Weise.  Danach geben wir das resultierende Objekt an C ++ zurück, wo der Kernel es verwendet. <br><br>  Lassen Sie uns den einfachsten HTTP-Client erstellen, der nur Abrufanforderungen stellen kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Zur Eingabe erhält es eine Zeichenfolge mit der herunterzuladenden URL und zur Ausgabe <br>  eine Zeichenfolge mit dem Ergebnis der Anforderung.  In C ++ können Zeichenfolgen Binärdaten enthalten, daher ist dies für Videos geeignet.  Emscripten lässt uns hier schreiben <br>  so ein gruseliger Wrapper: <br><br><img src="https://habrastorage.org/webt/m_/dz/hg/m_dzhg7a0xrywq8rirnyeh1rswa.png"><br><br>  Die Hauptsache sind zwei Dinge - der Name der Funktion auf der C ++ - Seite (ich habe sie grün markiert) und die entsprechenden Namen auf der JavaScript-Seite (ich habe sie blau markiert).  Als Ergebnis schreiben wir eine Kommunikationserklärung: <br><br><img src="https://habrastorage.org/webt/am/ob/qz/amobqzp-sx-3w12rnljcxlfh-fk.png"><br><br>  Es funktioniert wie Legoblöcke, aus denen wir es zusammensetzen.  Wir haben eine Klasse, diese Klasse hat eine Methode und wir möchten von dieser Klasse erben, um die Schnittstelle zu implementieren.  Das ist alles.  Wir gehen zu JavaScript und erben.  Dies kann auf zwei Arten erfolgen.  Der erste ist verlängern.  Dies ist sehr ähnlich zu der guten alten Erweiterung von Backbone. <br><br><img src="https://habrastorage.org/webt/rt/6p/fi/rt6pfi7s3sfipms3y8lfusrqgy8.png"><br><br>  Das Modul enthält alles, was Emscripten kompiliert hat, und verfügt über eine Eigenschaft mit einer exportierten Schnittstelle.  Wir rufen die Extend-Methode auf und übergeben dort ein Objekt mit der Implementierung dieser Methode, dh einige Methoden werden in der get-Funktion implementiert <br>  Informationen mit AJAX abrufen. <br><br>  Bei der Ausgabe erhalten Sie mit "verlängern" einen regulären JavaScript-Konstruktor.  Wir können es so oft wie nötig aufrufen und Objekte in der Menge generieren, die wir benötigen.  Es gibt jedoch eine Situation, in der wir ein Objekt haben und es nur an die C ++ - Seite übergeben möchten. <br><br><img src="https://habrastorage.org/webt/ky/ct/es/kycteslqo9rkbq5nyj1ilflq7g0.png"><br><br>  Binden Sie dazu dieses Objekt irgendwie an einen Typ, den C ++ versteht.  Dies ist, was die Implementierungsfunktion tut.  Bei der Ausgabe wird kein Konstruktor angegeben, sondern ein gebrauchsfertiges Objekt, unser Client, das wir an C ++ zurückgeben können.  Sie können dies beispielsweise folgendermaßen tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = Module.makeApp(client, …)</code> </pre><br>  Angenommen, wir haben eine Factory, die unsere Anwendung erstellt und deren Abhängigkeiten in Parameter wie Client und etwas anderes umwandelt.  Wenn diese Funktion funktioniert, erhalten wir das Objekt unserer Anwendung, das bereits die API enthält, die wir benötigen.  Sie können das Gegenteil tun: <br><br><pre> <code class="cpp hljs">val client = val::global(″client″); client.call&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(″get″, val(...) );</code> </pre><br>  Nehmen Sie unseren Client direkt aus C ++ aus dem globalen Browserbereich.  Anstelle des Clients kann es außerdem eine beliebige Browser-API geben, die von der Konsole aus beginnt und mit der DOM-API WebRTC endet - was auch immer Sie möchten.  Als nächstes rufen wir die Methoden dieses Objekts auf und verpacken alle Werte in die magische Klasse val, die Emscripten uns zur Verfügung stellt. <br><br><h3>  Bindungsfehler </h3><br>  Im Allgemeinen ist das alles, aber wenn Sie mit der Entwicklung beginnen, erwarten Sie Bindungsfehler.  Sie sehen ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/bi/jy/uj/bijyujpafhw1vljtsptpvuzxztw.png"><br><br>  Emscripten versucht uns zu helfen und zu erklären, was falsch läuft.  Wenn dies alles zusammengefasst ist, müssen Sie sicherstellen, dass sie übereinstimmen (es ist leicht zu versiegeln und einen Bindungsfehler zu erhalten): <br><br><ul><li>  Namen </li><li>  Typen </li><li>  Anzahl der Parameter </li></ul><br>  Die Embind-Syntax ist nicht nur für Front-End-Anbieter ungewöhnlich, sondern auch für Benutzer von C ++.  Dies ist eine Art DSL, bei der es leicht ist, einen Fehler zu machen. Sie müssen dies befolgen.  Apropos Schnittstellen: Wenn Sie eine Schnittstelle in JavaScript implementieren, muss diese genau mit der in Ihrem Vertrag beschriebenen übereinstimmen. <br><br>  Wir hatten einen interessanten Fall.  Mein Kollege Jura, der auf der C ++ - Seite an dem Projekt beteiligt war, hat Extend verwendet, um seine Module zu testen.  Sie haben perfekt für ihn gearbeitet, also hat er sie begangen und an mich weitergegeben.  Ich habe implement verwendet, um diese Module in ein JS-Projekt zu integrieren.  Und sie haben aufgehört für mich zu arbeiten.  Als wir es herausfanden, stellte sich heraus, dass wir beim Binden der Namen der Funktionen einen Tippfehler bekamen. <br><br>  Wie der Name schon sagt, ist Extend eine Erweiterung der Schnittstelle. Wenn Sie sie also irgendwo versiegelt haben, gibt Extend keinen Fehler aus, sondern entscheidet, dass Sie gerade eine neue Methode hinzugefügt haben, und das ist in Ordnung. <br><br>  Das heißt, die Bindungsfehler werden ausgeblendet, bis die Methode selbst aufgerufen wird.  Ich schlage vor, Implement in allen Fällen zu verwenden, in denen es Ihnen passt, da es sofort die Richtigkeit der weitergeleiteten Schnittstelle überprüft.  Wenn Sie jedoch Extend benötigen, müssen Sie den Aufruf jeder Methode mit Tests abdecken, um ihn nicht zu verfälschen. <br><br><h3>  Erweitern und ES6 </h3><br>  Ein weiteres Problem mit Extend ist, dass ES6-Klassen nicht unterstützt werden.  Wenn Sie ein von einer ES6-Klasse abgeleitetes Objekt erben, erwartet Extend, dass alle Eigenschaften darin aufzählbar sind, bei ES6 jedoch nicht.  Die Methoden befinden sich im Prototyp und haben folgende Aufzählungen: false.  Ich benutze eine Krücke wie diese, in der ich über den Prototyp gehe und aufzählbar einschalte: wahr: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj.prototype) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj.prototype, prop, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) ) }</code> </pre><br>  Ich hoffe, dass ich es eines Tages loswerden kann, da in der Emscripten-Community über die Verbesserung der Unterstützung für ES6 gesprochen wird. <br><br><h3>  Rom </h3><br>  Wenn man über C ++ spricht, kann man nicht anders, als den Speicher zu erwähnen.  Als wir alles auf Video in SD-Qualität überprüft haben, war bei uns alles in Ordnung, es hat einfach perfekt funktioniert!  Sobald wir den FullHD-Test durchgeführt haben, fehlte ein Speicherfehler.  Es spielt keine Rolle, es gibt die Option TOTAL_MEMORY, mit der der Startspeicherwert für das Modul festgelegt wird.  Wir haben ein halbes Gigabyte gemacht, alles ist in Ordnung, aber irgendwie ist es für Benutzer unmenschlich, weil wir den Speicher für alle reservieren, aber nicht jeder hat ein Abonnement für FullHD-Inhalte. <br><br>  Es gibt noch eine andere Option - ALLOW_MEMORY_GROWTH.  Es ermöglicht Ihnen, das Gedächtnis zu vergrößern <br>  nach Bedarf schrittweise.  Das funktioniert so: Emscripten gibt dem Modul standardmäßig 16 Megabyte für den Betrieb.  Wenn Sie sie alle verwendet haben, wird ein neuer Speicher zugewiesen.  Alle alten Daten werden dort kopiert, und Sie haben immer noch den gleichen Speicherplatz für neue.  Dies geschieht, bis Sie 4 GB erreichen. <br><br>  Angenommen, Sie haben 256 Megabyte Speicher zugewiesen, aber Sie wissen mit Sicherheit, dass Ihre Anwendung über genügend Speicher verfügt. Dann wird der Rest des Speichers ineffizient verwendet.  Sie haben es hervorgehoben, dem Benutzer abgenommen, aber nichts damit gemacht.  Ich möchte das irgendwie vermeiden.  Es gibt einen kleinen Trick: Wir beginnen mit der Arbeit, wobei das Gedächtnis um das Eineinhalbfache erhöht wird.  Dann erreichen wir im dritten Schritt 192 Megabyte, und genau das brauchen wir.  Wir haben den Speicherverbrauch um diesen Rest reduziert und unnötige Speicherzuweisung gespart. Je weiter, desto länger dauert dies.  Daher empfehle ich, beide Optionen zusammen zu verwenden. <br><br><h3>  Abhängigkeitsinjektion </h3><br>  Es scheint, dass das alles war, aber dann ging der Rechen etwas mehr.  Es liegt ein Problem mit der Abhängigkeitsinjektion vor.  Wir schreiben die einfachste Klasse, in der eine Abhängigkeit benötigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient } }</code> </pre><br>  Zum Beispiel übergeben wir unseren HTTP-Client an unsere Anwendung.  Wir speichern in der Klasseneigenschaft.  Es scheint, dass alles gut funktionieren wird. <br><br><pre> <code class="javascript hljs">Module.App.extend( ″App″, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(client) )</code> </pre><br>  Wir erben von der C ++ - Schnittstelle, erstellen zuerst unser Objekt, übergeben die Abhängigkeit daran und erben dann.  Zum Zeitpunkt der Vererbung macht Emscripten etwas Unglaubliches mit dem Objekt.  Es ist am einfachsten zu glauben, dass es ein altes Objekt tötet, ein neues basierend auf seiner Vorlage erstellt und alle öffentlichen Methoden dorthin zieht.  Gleichzeitig geht der Status des Objekts verloren und Sie erhalten ein Objekt, das nicht gebildet wird und nicht richtig funktioniert.  Die Lösung dieses Problems ist recht einfach.  Es ist erforderlich, einen Konstruktor zu verwenden, der nach der Vererbungsphase funktioniert. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ _construct(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent._construct.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Wir machen fast dasselbe: Wir speichern die Abhängigkeit im Feld des Objekts, aber dies ist das Objekt, das sich nach der Vererbung herausgestellt hat.  Wir dürfen nicht vergessen, den Konstruktoraufruf an das übergeordnete Objekt weiterzuleiten, das sich auf der C ++ - Seite befindet.  Die letzte Zeile ist ein Analogon zur super () -Methode in ES6.  So geschieht die Vererbung in diesem Fall: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> appConstr = Module.App.extend( ″App″, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App() ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> appConstr(client)</code> </pre><br>  Zuerst erben wir, dann erstellen wir ein neues Objekt, an das die Abhängigkeit bereits übergeben wird, und das funktioniert. <br><br><h3>  Zeigertrick </h3><br>  Ein weiteres Problem ist die Übergabe von Objekten per Zeiger von C ++ an JavaScript.  Wir haben bereits einen HTTP-Client erstellt.  Der Einfachheit halber haben wir ein wichtiges Detail übersehen. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span></span></code> </pre><br>  Die Methode gibt den Wert sofort zurück, dh es stellt sich heraus, dass die Anforderung synchron sein sollte.  Schließlich fordert AJAX AJAX an und dass sie asynchron sind, sodass die Methode im wirklichen Leben entweder nichts zurückgibt oder wir die Anforderungs-ID zurückgeben können.  Damit jedoch jemand die Antwort zurückgibt, übergeben wir den Listener als zweiten Parameter, in dem Rückrufe von C ++ erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Listener listener)</span></span></span></span></code> </pre><br>  In JS sieht es so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ fetch(url).then(result) =&gt; { listener.onResult(result) }) }</code> </pre><br>  Wir haben eine get-Funktion, die dieses Listener-Objekt übernimmt.  Wir starten den Dateidownload und legen den Rückruf auf.  Wenn die Datei heruntergeladen wird, ziehen wir die gewünschte Funktion aus dem Listener und übergeben das Ergebnis an ihn. <br><br>  Es scheint, dass der Plan gut ist, aber wenn die get-Funktion abgeschlossen ist, werden alle lokalen Variablen zerstört, und zusammen mit ihnen werden die Funktionsparameter, dh der Zeiger, zerstört, und emscripten zur Laufzeit zerstört das Objekt auf der C ++ - Seite. <br><br>  Wenn der Zeilenlistener.onResult (Ergebnis) aufgerufen wird, ist der Listener daher nicht mehr vorhanden. Beim Zugriff darauf tritt ein Speicherzugriffsfehler auf, der zum Absturz der Anwendung führt. <br><br>  Ich möchte dies vermeiden, und es gibt eine Lösung, aber es hat mehrere Wochen gedauert, bis ich sie gefunden habe. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listenerCopy = listener.clone() fetch(url).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { listenerCopy.onResult(result) listenerCopy.delete() }) }</code> </pre><br>  Es stellt sich heraus, dass es eine Methode zum Klonen eines Zeigers gibt.  Aus irgendeinem Grund ist es nicht dokumentiert, funktioniert aber einwandfrei und ermöglicht es Ihnen, die Referenzanzahl im Emscripten-Zeiger zu erhöhen.  Dies ermöglicht es uns, es in einem Abschluss auszusetzen. Wenn wir dann unseren Rückruf starten, ist unser Listener über diesen Zeiger erreichbar und wir können nach Bedarf arbeiten. <br><br>  Das Wichtigste ist, nicht zu vergessen, diesen Zeiger zu löschen, da dies sonst zu einem Speicherverlustfehler führt, der sehr schlimm ist. <br><br><h3>  Schnelles Schreiben in den Speicher </h3><br>  Wenn wir Videos herunterladen, sind dies relativ große Informationsmengen, und ich möchte die Menge des Hin- und Herkopierens von Daten reduzieren, um sowohl Speicher als auch Zeit zu sparen.  Es gibt einen Trick, wie eine große Menge von Informationen aus JavaScript direkt in den WebAssembly-Speicher geschrieben werden kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(…); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = newData.byteLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = Module._malloc(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>( Module.buffer, ptr, size ); memory.set(newData);</code> </pre><br>  newData sind unsere Daten als typisiertes Array.  Wir können seine Länge nehmen und die Zuweisung von Speicher der Größe, die wir benötigen, vom WebAssembly-Modul anfordern.  Die Malloc-Funktion gibt einen Zeiger an uns zurück. Dies ist nur der Index des Arrays, das den gesamten Speicher in WebAssembly enthält.  Von der JavaScript-Seite sieht es einfach wie ein ArrayBuffer aus. <br><br>  Im nächsten Schritt schneiden wir von einer bestimmten Stelle aus ein Fenster in diesen ArrayBuffer der richtigen Größe und kopieren dort unsere Daten.  Trotz der Tatsache, dass die Set-Operation eine Kopiersemantik aufweist, sah ich beim Betrachten dieses Abschnitts im Profiler keinen langen Prozess.  Ich denke, dass der Browser diesen Vorgang mit Hilfe der Verschiebungssemantik optimiert, dh den Besitz des Speichers von einem Objekt auf ein anderes überträgt. <br><br>  In unserer Anwendung verlassen wir uns auch auf die Verschiebungssemantik, um Speicherkopien zu sparen. <br><br><h3>  Adblock </h3><br>  Ein interessantes Problem bei der Änderung mit Adblock.  Es stellt sich heraus, dass in Russland alle beliebten Blocker ein Abonnement für die RU-Adlist erhalten, und es gibt eine wunderbare Regel, die das Herunterladen von WebAssembly von Websites von Drittanbietern verbietet.  Zum Beispiel mit einem CDN. <br><br><img src="https://habrastorage.org/webt/os/wt/kg/oswtkgtaeovfuk9r4d-gehdwdwe.png"><br><br>  Der Ausweg besteht nicht darin, das CDN zu verwenden, sondern alles auf Ihrer Domain zu speichern (dies passt nicht zu uns).  Oder benennen Sie die WASM-Datei um, damit sie nicht dieser Regel entspricht.  Sie können immer noch zum Forum dieser Genossen gehen und versuchen, sie davon zu überzeugen, diese Regel zu entfernen.  Ich denke, sie rechtfertigen sich, indem sie auf diese Weise gegen die Bergleute kämpfen, obwohl ich nicht weiß, warum die Bergleute nicht raten können, die Datei umzubenennen. <br><br><h2>  Produktion </h2><br>  Infolgedessen gingen wir in Produktion.  Ja, es war nicht einfach, es hat 8 Monate gedauert und ich möchte mich fragen, ob es sich gelohnt hat.  Meiner Meinung nach hat es sich gelohnt: <br><br><h3>  Keine Notwendigkeit zu installieren </h3><br>  Wir haben festgestellt, dass unser Code an den Benutzer geliefert wird, ohne dass Programme installiert werden müssen.  Wenn wir ein Browser-Plug-In hatten, musste der Benutzer es herunterladen und installieren, und dies ist ein riesiger Filter für die Technologieverteilung.  Jetzt sieht sich der Benutzer nur noch das Video auf der Website an und versteht nicht einmal, dass eine ganze Maschine unter der Haube arbeitet und dass dort alles kompliziert ist.  Der Browser lädt nur eine zusätzliche Datei mit dem Code herunter, z. B. ein Bild oder eine CSS-Datei. <br><br><h3>  Einheitliche Codebasis und Debugging auf verschiedenen Plattformen </h3><br>  Gleichzeitig konnten wir unsere einzelne Codebasis beibehalten.  Wir können denselben Code auf verschiedenen Plattformen verdrehen, und es ist wiederholt vorgekommen, dass Fehler, die auf einer der Plattformen unsichtbar waren, auf der anderen auftraten.  Auf diese Weise können wir versteckte Fehler mit verschiedenen Tools auf verschiedenen Plattformen erkennen. <br><br><h3>  Schnellspanner </h3><br>  Wir haben eine schnelle Version erhalten, da wir als einfache Webanwendung veröffentlicht werden können und den C ++ - Code mit jeder neuen Version aktualisieren können.  Es ist nicht vergleichbar mit der Veröffentlichung neuer Plugins, einer mobilen Anwendung oder einer SmartTV-Anwendung.  Die Veröffentlichung hängt nur von uns ab: Wenn wir wollen, wird sie veröffentlicht. <br><br><h3>  Schnelles Feedback </h3><br>  Und das bedeutet schnelles Feedback: Wenn etwas schief geht, können wir tagsüber feststellen, dass ein Problem vorliegt, und darauf reagieren. <br><br>  Ich glaube, dass all diese Probleme diese Vorteile wert waren.  Nicht jeder hat eine C ++ - Anwendung, aber wenn Sie eine haben und diese im Browser haben möchten, ist WebAssembly ein 100% iger Anwendungsfall für Sie. <br><br><h2>  Wo bewerben? </h2><br>  Nicht jeder schreibt in C ++.  Für WebAssembly ist jedoch nicht nur C ++ verfügbar.  Ja, dies ist historisch gesehen die allererste Plattform, die noch in asm.js, einer frühen Mozilla-Technologie, verfügbar war.  Übrigens hat es also ziemlich gute Werkzeuge, wie  Sie sind älter als die Technologie selbst. <br><br><h3>  Rost </h3><br>  Die neue Rust-Sprache, die ebenfalls von Mozilla entwickelt wird, holt C ++ jetzt in Bezug auf Tools ein und überholt es.  Alles geht so weit, dass sie den coolsten Entwicklungsprozess für WebAssembly machen. <br><br><h3>  Lua, Perl, Python, PHP usw. </h3><br>  Fast alle interpretierten Sprachen sind auch in WebAssembly verfügbar, da ihre Interpreter in C ++ geschrieben sind. Sie wurden einfach in WebAssembly kompiliert und jetzt können Sie PHP in einem Browser drehen. <br><br><h3>  Geh </h3><br>  In Version 1.11 haben sie eine Beta-Version der Kompilierung in WebAssembly erstellt, in 2.0 versprechen sie Release-Unterstützung.  Ihre Unterstützung wurde später angezeigt, da WebAssembly den Garbage Collector nicht unterstützt und Go eine Sprache für verwalteten Speicher ist.  Also mussten sie ihren Garbage Collector unter WebAssembly ziehen. <br><br><h3>  Kotlin / Native </h3><br>  Über die gleiche Geschichte mit Kotlin.  Ihr Compiler hat experimentelle Unterstützung, aber sie müssen auch etwas mit dem Garbage Collector tun.  Ich weiß nicht, welchen Status es gibt. <br><br><h3>  3D-Grafiken </h3><br>  Was können Sie noch denken? ,     — 3D-. , ,  asm.js  WebAssembly      .  ,         WebAssembly. <br><br><img src="https://habrastorage.org/webt/lt/u2/7q/ltu27qaab_yjbryhnm_ayf-edsa.png"><br><br><h3>    </h3><br>           ,   :      ,  ,  .    ,             . <br><br><h3>   </h3><br><br><img src="https://habrastorage.org/webt/2u/mi/dz/2umidzjddihmiikdgktwjdk4hpe.png"><br><br>         . , ,      ,     ,         . , ,        ;   —   . <br><br><img src="https://habrastorage.org/webt/0q/-e/0s/0q-e0sqshcd_t-p4ioyhtoe0z-k.png"><br><br> ,  Google Chrome,      ,    WebAssembly-.     npm-  ,   Wasm,     JS.      , ++  -  —    . <br><br>      HunSpell —      Wasm . <br><br><h3>  </h3><br>      — «   ».     , -        ,       —  OpenSSL.       WebAssembly. OpenSSL —   ,   ,    . <br><br><h3>     </h3><br>  use case    wotinspector.com.     World of Tanks.     ,  ,    ,   ,  ,      . <br><br>   —      .      ,       ,   .    ,  ,  -  ++,    WebAssembly,            (   ,        ). <br><br>        .  ,     ,     .       .     ,     ,      ,   ,      .        .    . <br><br><h3>  </h3><br>      ,      , ++. ,  FFmpeg,      .      ,   ffmpeg.          .     , ,     ,      ,     . <br><br><img src="https://habrastorage.org/webt/aa/tu/u8/aatuu8b5uzbxmnhv_8mjb93jcxa.png"><br><br>     —            .   OpenCV —    ,   WebAssembly,        .    PDF.      SQLite,    SQL.  SQLite  WebAssembly   Emscripten,      . <br><br><h3>  Node.js </h3><br><br><img src="https://habrastorage.org/webt/dl/mf/tn/dlmftnxe8bjvt-ys-jyyy-aunde.png"><br><br>       WebAssembly,    Node.js. ,   Sass —  css.     Ruby,       ++ ( libsass).          ,       Webpack',       Node.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">node-sass</a>   ,  JS-   . <br><br>  ,         ,      .       .    : <br><br><img src="https://habrastorage.org/webt/bv/s0/rp/bvs0rpy6naa9-dhac6zingbv-cw.png"><br><br>    ,     node-sass    100      .     ,        ( ) .  WebAssembly   :       ,     WebAssembly    . <br><br>                    Node.    ,   WebAssembly     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libsass-asm</a> .   ,       .      WebAssembly   … <br><br><h3>   </h3><br>    Figma —    web-.   -   Sketch,     ,     .    ++ (    ),     asm.js.   ,    . <br><br><img src="https://habrastorage.org/webt/ht/ad/2t/htad2t3hmsfx_txwjfhk-_qlh2w.png"><br><br>   WebAssembly,    ,      3 .     ,         . <br><br>     Visual Studio Code,   ,    Electron,        ,          ,   Node-sass. ,     Node,            . ,  ,     ,      WebAssembly. <br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/tz/qg/2a/tzqg2a7sw01qlqnvwjcjzkxqkyw.png"><br><br>        — AutoCAD.   30 ,    ++,     .      ,    ,              -  JavaScript,    ,      .    WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoCAD   -</a> ,     5      . <br><br>   ,    , ,   , ,       ,    , ,    .   FFMpeg —   ,     — QEMU. ,     ,       KVM,        . <br><br><img src="https://habrastorage.org/webt/zq/3c/aj/zq3cajq6z-ftdftt0a1bnveqj1m.png"><br><br>   2011   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> QEMU  </a> .  ,             .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">Linux  </a> ,  Linux-,     , -  . <br><br>   ,    .   bash,    ,     Linux.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">  —  GUI</a> .       .  ,    ,        … <br><br><img src="https://habrastorage.org/webt/jf/zc/bo/jfzcbori9ee4oah-1nmumj8ebqk.png"><br><br> ,     ,  - . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D"> Windows 2000</a> ,  ,   18  ,       .     ,     Chrome ( FireFox). <br><br>   ,  WebAssembly ,    ,   ,      ,     . <br><br><h2>      </h2><br>       ,       WebAssembly. ,     —  ,  .   —  ,       . <br><br><img src="https://habrastorage.org/webt/ea/ls/ak/ealsak2klb2rgvobxmirs1rn0_s.png"><br><br>  ,     C++      web-.   ,  ,       —      .    —  ,      ,      ,     . <br><br>  ,      .   ,    C++,      JavaScript,        .     ,         C++.              ,       JS  C++,      . <br><br>         —   . <br><br><img src="https://habrastorage.org/webt/fx/nj/wb/fxnjwbotpkneisrtmlze8-0afdy.png"><br><br><h2> CI Pipeline </h2><br>      ?    JS-   ,        Webpack.      ,   ,  (     ),       JS.    webpack   watch,  ,          . <br><br><img src="https://habrastorage.org/webt/zv/s_/r4/zvs_r45efsroktebku2lrdmuv9e.png"><br><br><h2>  </h2><br>  ,     .  ,  ,    . <br><br>   Chrome   DevTools,      Sources   wasm-.     (    - ), ,  ,      . <br><br><img src="https://habrastorage.org/webt/ea/ir/8u/eair8uahusoyylejgtccro0g1-a.png"><br><br>    ,        ,      : «,     , ,    ,  ,   !».  ,     embedded-,    ,    -     . <br><br>   :     -g4  wast-   ,     . <br><br><img src="https://habrastorage.org/webt/0k/6w/af/0k6wafnm3pp62o-a5t8dcoxivxy.png"><br><br>   ,      100  (  FAR).  —  ,       Chrome. E:/_work/bfg/bytefrog/… —    .    ,      ++     .   ,    SourceMap! <br><br><h2> SourceMap </h2><br>  ,     . <br><ul><li>    Firefox. </li><li> --sourcemap-base=http://localhost  ,    SourceMap   -,    . </li><li>     HTTP. </li><li>       . </li><li>  Windows    «:»  .     . </li></ul><br><br>     . CMake        ,        URL  -.    :  wast-       ,    . ,     . <br><br>  ,    : <br><br><img src="https://habrastorage.org/webt/ev/hn/fo/evhnfovmbp4hdynewi_r6buhx_a.png"><br><br>  ++   .    !   ,   ,  stack trace,      .  ,     wasm-  stack trace,   ,   , , ,  . <br><br><img src="https://habrastorage.org/webt/ql/zi/x8/qlzix8vqcrbdziehrmmrmq4uz0a.png"><br><br>  ,      — SourceMap     .  ,        ,    .           ,      . <br><br><img src="https://habrastorage.org/webt/vk/e4/vk/vke4vkmnpcbp9gm8tuac-92xany.png"><br><br>             «var0». <br><br><img src="https://habrastorage.org/webt/yh/rc/xx/yhrcxxqcvj0upcy6negdcw0b9c0.png"><br><br> ,           . ,      SourceMap,       ,   . <br><br><h2>  </h2><br>     .     Chrome,   Firefox.  Firefox  —  «» ,    ,      . <br><br><img src="https://habrastorage.org/webt/bv/va/x1/bvvax1w0kvo4gsmx7ry0bgbekhe.png"><br><br> Chrome    ( ,  ,  Mangled  ), ,  ,  ,    . <br><br><img src="https://habrastorage.org/webt/gv/jh/rp/gvjhrpyqjxyvsyq4xjigmdmwxa8.png"><br><br><h2>  </h2><br>   .     ,   : <br><br><ul><li> .     runtime,   .   ++      Rust  Go. </li><li>    JS — Wasm.     ,         JS  Wasm.      -,    ,    .      ,    . </li><li>  .  ,   ,     ,       . </li><li> Wasm   . Wasm  ,       JS.  WebAssembly   ,       . </li><li>        JS. </li></ul><br><br>    :    . <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasp_cpp_bench</a> </li><li> Chrome 65.0.3325.181 (64-bit) </li><li> Core i5-4690 </li><li> 24gb ram </li><li> 5 ;  max  min;  </li></ul><br><br>   .         JS —  ,     . <br><br><img src="https://habrastorage.org/webt/sg/e7/to/sge7toujmxycrhznogviscz94dy.png"><br><br> ++,   ,   -  .      Grayscale.   C++    ,   .     ( ),   ,    JS. ,  ,       ,   ++,   . <br><h2>     </h2><br>   Sentry,      —     wasm. ,   traceKit,    Sentry — Raven, —    ,    ,  wasm .   , , ,    pull request,     npm install  JS-. <br><br><img src="https://habrastorage.org/webt/rd/vm/-z/rdvm-zijheakjsktoubausmmyc8.png"><br><br>    .   production,     ,   .    debug-,     ,    : <br><br><img src="https://habrastorage.org/webt/gn/e_/_t/gne__tfliahfwe1sfndiid2tmyq.png"><br><br><h2>  </h2><br><ul><li> WebAssembly     ,     . </li><li>     — .     8 ,           C++,   ,    . </li><li>   ,      ,   WebAssembly —     . </li><li>  —   JS.  JS-      ,    «»   ,     ,     . </li></ul><br><br>    , : <br><ul><li>  Emscripten  Embind.     . </li><li>   -   Emscripten —   .  ,    ,     3000      Emscripten. </li><li>     Sentry. </li><li>   Firefox. </li></ul><br><br>  Vielen Dank für Ihre Aufmerksamkeit!      . <br><br><img src="https://habrastorage.org/webt/2h/qu/au/2hquauawvppoc-iu5un4wgevnvo.png"><br><br><blockquote>        HolyJS,  : <b>24-25   </b>   <b>HolyJS</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>      (,   Node.js Ryan Dahl!),      —   1   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441140/">https://habr.com/ru/post/de441140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441130/index.html">Ausgewogene Site-Leistung. Teil 1: Strategie</a></li>
<li><a href="../de441132/index.html">Damit Roskomnadzor nicht PLÖTZLICH kommt</a></li>
<li><a href="../de441134/index.html">Emotionen, selbständige Arbeit</a></li>
<li><a href="../de441136/index.html">Langzeitspeicherung von Prometheus-Metriken (Alexey Palazhchenko, Percona)</a></li>
<li><a href="../de441138/index.html">Echtzeit-Chat-Lösungen gegen Chat-Plattformen - Treffen Sie Ihre Wahl</a></li>
<li><a href="../de441142/index.html">12 Punkte Conversion-Wachstum oder Inhalte, die sich wirklich verkaufen</a></li>
<li><a href="../de441146/index.html">Industrielle drahtlose Netzwerke: Welches soll man wählen?</a></li>
<li><a href="../de441148/index.html">Wie man richtig mit Fehlern umgeht: Stille ist nicht immer gut</a></li>
<li><a href="../de441150/index.html">Erste Einführung in das HTTP-Protokoll durch Schreiben des einfachsten Java-Webservers</a></li>
<li><a href="../de441152/index.html">So minimieren Sie Fehler bei der Integration in externe Services: die Erfahrung eines Online-Brokers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>