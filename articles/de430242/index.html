<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó üíÜüèø üåç OpenSceneGraph: Gruppenknoten, Transformationsknoten und Switch-Knoten üêñ ü§§ üëÇüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Wenn ein Punkt, eine Linie oder ein komplexes Polygon in einer dreidimensionalen Welt gezeichnet wird, wird das Endergebnis letztendlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Gruppenknoten, Transformationsknoten und Switch-Knoten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430242/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Wenn ein Punkt, eine Linie oder ein komplexes Polygon in einer dreidimensionalen Welt gezeichnet wird, wird das Endergebnis letztendlich auf einem flachen, zweidimensionalen Bildschirm angezeigt.  Dementsprechend durchlaufen dreidimensionale Objekte einen bestimmten Transformationspfad und verwandeln sich in einen Satz von Pixeln, die in einem zweidimensionalen Fenster angezeigt werden. <br><br>  Die Entwicklung von Softwaretools, die dreidimensionale Grafiken implementieren, hat unabh√§ngig davon, welches Sie w√§hlen, ungef√§hr das gleiche Konzept sowohl der mathematischen als auch der algorithmischen Beschreibung der obigen Transformationen erreicht.  Ideologisch verwenden ‚Äûsaubere‚Äú Grafik-APIs wie OpenGL und coole Game-Engines wie Unity und Unreal √§hnliche Mechanismen zur Beschreibung der Transformation einer dreidimensionalen Szene.  OpenSceneGraph ist keine Ausnahme. <br><br>  In diesem Artikel werden die Mechanismen zum Gruppieren und Transformieren dreidimensionaler Objekte in OSG beschrieben. <br><a name="habracut"></a><br><h1>  1. Modellmatrix, Ansichtsmatrix und Projektionsmatrix </h1><br>  Drei Grundmatrizen, die an der Transformation von Koordinaten beteiligt sind, sind an der Transformation zwischen verschiedenen Koordinatensystemen beteiligt.  In OpenGL-Begriffen werden sie h√§ufig als <em>Modellmatrix</em> <em>, Ansichtsmatrix</em> und <em>Projektionsmatrix bezeichnet</em> . <br><br>  Die Matrix des Modells wird verwendet, um die Position des Objekts in der 3D-Welt zu beschreiben.  Es konvertiert Scheitelpunkte vom <em>lokalen Koordinatensystem des Objekts</em> in das <em>Weltkoordinatensystem</em> .  √úbrigens sind alle Koordinatensysteme in OSG <em>Rechtsh√§nder</em> . <br><br>  Der n√§chste Schritt ist die Transformation von Weltkoordinaten in einen Ansichtsraum, die unter Verwendung der Ansichtsmatrix durchgef√ºhrt wird.  Angenommen, wir haben eine Kamera am Ursprung des Weltkoordinatensystems.  Die zur Kameratransformationsmatrix inverse Matrix wird tats√§chlich als Ansichtsmatrix verwendet.  In einem rechtsh√§ndigen Koordinatensystem definiert OpenGL standardm√§√üig immer eine Kamera, die sich am Punkt (0, 0, 0) des globalen Koordinatensystems befindet und entlang der negativen Richtung der Z-Achse gerichtet ist. <br><br>  Ich stelle fest, dass in OpenGL die Modellmatrix und die Ansichtsmatrix nicht getrennt sind.  Dort wird jedoch die Modellansichtsmatrix bestimmt, die die lokalen Koordinaten des Objekts in die Koordinaten des Ansichtsraums umwandelt.  Diese Matrix ist tats√§chlich das Produkt der Modellmatrix und der Matrix der Form.  Somit kann die Transformation eines Scheitelpunkts V von lokalen Koordinaten in einen Raum der Form bedingt als Produkt geschrieben werden <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  Die n√§chste wichtige Aufgabe besteht darin, zu bestimmen, wie 3D-Objekte auf die Bildschirmebene projiziert werden, und die sogenannte <em>Schnittpyramide zu</em> berechnen - einen Raumbereich, der Objekte enth√§lt, die auf dem Bildschirm angezeigt werden sollen.  Die Projektionsmatrix wird verwendet, um die im Weltraum durch sechs Ebenen definierte Schnittpyramide anzugeben: links, rechts, unten, oben, nah und fern.  OpenGL bietet die Funktion gluPerapective (), mit der Sie eine Schnittpyramide angeben und eine dreidimensionale Welt auf eine Ebene projizieren k√∂nnen. <br><br>  Das nach den obigen Transformationen erhaltene <em>Koordinatensystem</em> wird als <em>normalisiertes Koordinatensystem des Ger√§ts bezeichnet</em> , hat auf jeder Achse einen Koordinatenbereich von -1 bis 1 und ist linksh√§ndig.  Als letzten Schritt werden die empfangenen Daten in den Anzeigeport (Ansichtsfenster) des Fensters projiziert, der durch das Rechteck des Clientbereichs des Fensters definiert ist.  Danach erscheint die 3D-Welt auf unserem 2D-Bildschirm.  Der Endwert der Bildschirmkoordinaten der Eckpunkte Vs kann durch die folgende Transformation ausgedr√ºckt werden <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  oder <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  Dabei ist MVPW die √§quivalente Transformationsmatrix, die dem Produkt aus drei Matrizen entspricht: Modellansichtsmatrizen, Projektionsmatrizen und Fenstermatrizen. <br><br>  Vs ist in dieser Situation ein dreidimensionaler Vektor, der die Position eines 2D-Pixels mit einem Tiefenwert bestimmt.  Durch Invertieren der Koordinatentransformationsoperation erhalten wir eine Linie im dreidimensionalen Raum.  Daher kann ein 2D-Punkt als zwei Punkte betrachtet werden - einer in der nahen (Zs = 0), der andere in der fernen Schnittebene (Zs = 1).  Die Koordinaten dieser Punkte im dreidimensionalen Raum <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  Dabei ist invMVPW die Umkehrung von MVPW. <br><br>  In allen bisher diskutierten Beispielen haben wir ein einzelnes dreidimensionales Objekt in den Szenen erstellt.  In diesen Beispielen stimmten die lokalen Koordinaten des Objekts immer mit den globalen globalen Koordinaten √ºberein.  Jetzt ist es Zeit, √ºber Werkzeuge zu sprechen, mit denen Sie viele Objekte in der Szene platzieren und ihre Position im Raum √§ndern k√∂nnen. <br><br><h1>  2. Knoten gruppieren </h1><br>  Die osg :: Group-Klasse ist der sogenannte <em>Gruppenknoten</em> eines Szenendiagramms in OSG.  Es kann eine beliebige Anzahl von untergeordneten Knoten haben, einschlie√ülich Geometrieblattknoten oder anderer Gruppenknoten.  Dies sind die am h√§ufigsten verwendeten Knoten mit umfangreichen Funktionen. <br><br>  Die Klasse osg :: Group wird von der Klasse osg :: Node abgeleitet und erbt dementsprechend von der Klasse osg :: Referenced.  osg :: Group enth√§lt eine Liste von untergeordneten Knoten, wobei jeder untergeordnete Knoten von einem intelligenten Zeiger gesteuert wird.  Dies stellt sicher, dass beim Kaskadieren eines Zweigs eines Szenenbaums keine Speicherlecks auftreten.  Diese Klasse bietet dem Entwickler eine Reihe √∂ffentlicher Methoden. <br><ol><li>  addChild () - H√§ngt den Knoten an das Ende der Liste der untergeordneten Knoten an.  Auf der anderen Seite gibt es die Methode insertChild (), mit der der untergeordnete Knoten an einer bestimmten Position in der Liste platziert wird, die durch einen ganzzahligen Index oder einen Zeiger auf den als Parameter √ºbergebenen Knoten angegeben wird. <br></li><li>  removeChild () und removeChildren () - Entfernen Sie einen einzelnen Knoten oder eine Gruppe von Knoten. <br></li><li>  getChild () - Abrufen eines Zeigers auf einen Knoten anhand seines Index in der Liste <br></li><li>  getNumChildren () - Ermittelt die Anzahl der untergeordneten Knoten, die dieser Gruppe zugeordnet sind. <br></li></ol><br><h2>  √úbergeordnete Knotenverwaltung </h2><br>  Wie wir bereits wissen, verwaltet die Klasse osg :: Group Gruppen ihrer untergeordneten Objekte, unter denen sich m√∂glicherweise osg :: Geode-Instanzen befinden, die die Geometrie von Szenenobjekten steuern.  Beide Klassen verf√ºgen √ºber eine Schnittstelle zum Verwalten √ºbergeordneter Knoten. <br><br>  Mit OSG k√∂nnen Szenenknoten mehrere √ºbergeordnete Knoten haben (wir werden sp√§ter dar√ºber sprechen).  In der Zwischenzeit werden wir uns die in osg :: Node definierten Methoden ansehen, mit denen √ºbergeordnete Knoten bearbeitet werden: <br><ol><li>  getParent () - gibt einen Zeiger vom Typ osg :: Group zur√ºck, der eine Liste der √ºbergeordneten Knoten enth√§lt. <br></li><li>  getNumParants () - Gibt die Anzahl der √ºbergeordneten Knoten zur√ºck. <br></li><li>  getParentalNodePath () - Gibt alle m√∂glichen Pfade vom aktuellen Knoten zum Wurzelknoten der Szene zur√ºck.  Es gibt eine Liste von Variablen vom Typ osg :: NodePath zur√ºck. <br></li></ol><br>  osg :: NodePath ist ein std :: -Vektor von Zeigern auf Szenenknoten. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  Beispiel f√ºr die in der Abbildung gezeigte Szene den folgenden Code <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  gibt die Knoten Root, Child1, Child2 zur√ºck. <br><br>  Sie sollten keine Speicherverwaltungsmechanismen verwenden, um auf √ºbergeordnete Knoten zu verweisen.  Wenn ein √ºbergeordneter Knoten gel√∂scht wird, werden alle untergeordneten Knoten automatisch gel√∂scht, was zu einem Anwendungsabsturz f√ºhren kann. <br><br><h1>  3. Hinzuf√ºgen mehrerer Modelle zum Szenenbaum </h1><br>  Wir veranschaulichen den Mechanismus zur Verwendung von Gruppen anhand des folgenden Beispiels. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiges Gruppenbeispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Grunds√§tzlich unterscheidet sich das Beispiel von allen vorherigen darin, dass wir zwei dreidimensionale Modelle laden. Um sie der Szene hinzuzuf√ºgen, erstellen wir einen Gruppenstammknoten und f√ºgen unsere Modelle als untergeordnete Knoten hinzu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  Als Ergebnis erhalten wir eine Szene, die aus zwei Modellen besteht - einem Flugzeug und einer lustigen Spiegelkuh.  Eine Spiegelkuh ist √ºbrigens kein Spiegel, es sei denn, Sie kopieren ihre Textur aus OpenSceneGraph-Data / Images / Reflect.rgb in das Verzeichnis data / Images unseres Projekts. <br><br>  Die osg :: Group-Klasse kann alle Knotentypen als untergeordnete Knoten akzeptieren, einschlie√ülich Knoten ihres Typs.  Im Gegenteil, die Klasse osg :: Geode enth√§lt √ºberhaupt keine untergeordneten Knoten - es handelt sich um einen Endknoten, der die Geometrie des Szenenobjekts enth√§lt.  Diese Tatsache ist praktisch, wenn Sie fragen, ob der Knoten ein Knoten vom Typ osg :: Group oder ein anderer Ableitungstyp von osg :: Node ist.  Schauen wir uns ein kleines Beispiel an. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  Der von der Funktion osgDB :: readNodeFile () zur√ºckgegebene Wert ist immer vom Typ osg :: Node *, kann jedoch in seinen Nachkommen osg :: Group * konvertiert werden.  Wenn der Cessna-Modellknoten ein Gruppenknoten ist, ist die Konvertierung erfolgreich, andernfalls gibt die Konvertierung NULL zur√ºck. <br><br>  Sie k√∂nnen auch den gleichen Trick ausf√ºhren, der bei den meisten Compilern funktioniert <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  An leistungskritischen Code-Stellen ist es besser, spezielle Konvertierungsmethoden zu verwenden <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. Knoten der Transformation </h1><br>  Osg :: Group-Knoten k√∂nnen keine Transformationen vornehmen, au√üer die M√∂glichkeit, zu ihren untergeordneten Knoten zu wechseln.  OSG bietet die Klasse osg :: Transform f√ºr die Bewegung der r√§umlichen Geometrie.  Diese Klasse ist ein Nachfolger der osg :: Group-Klasse, aber auch abstrakt - in der Praxis werden stattdessen ihre Erben verwendet, die verschiedene r√§umliche Transformationen der Geometrie implementieren.  Beim Durchlaufen des Szenendiagramms f√ºgt der Knoten osg :: Transform seine Transformation der aktuellen OpenGL-Transformationsmatrix hinzu.  Dies entspricht dem Multiplizieren der OpenGL-Transformationsmatrizen mit dem Befehl glMultMatrix () <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  Dieses Beispielszenendiagramm kann in den folgenden OpenGL-Code √ºbersetzt werden <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  Wir k√∂nnen sagen, dass die Position von Geode1 im Koordinatensystem Transform1 und die Position von Geode2 im Koordinatensystem Transform2 festgelegt ist, versetzt zu Transform1.  Gleichzeitig kann die Positionierung in absoluten Koordinaten in OSG aktiviert werden, was zum Verhalten des Objekts f√ºhrt, das dem Ergebnis des OpenGL-Befehls glGlobalMatrix () entspricht <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  Sie k√∂nnen in den relativen Positionierungsmodus zur√ºckkehren <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. Das Konzept einer Koordinatentransformationsmatrix </h1><br>  Der Typ osg :: Matrix ist ein grundlegender OSG-Typ, der nicht von intelligenten Zeigern gesteuert wird.  Es bietet eine Schnittstelle zu Operationen auf 4x4-Matrizen, die die Transformation von Koordinaten beschreiben, z. B. Verschieben, Drehen, Skalieren und Berechnen von Projektionen.  Die Matrix kann explizit angegeben werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  Die osg :: Matrix-Klasse bietet die folgenden √∂ffentlichen Methoden: <br><br><ol><li>  postMult () und operator * () - die richtige Multiplikation der aktuellen Matrix mit der als Parameter √ºbergebenen Matrix oder dem Vektor.  Die preMult () -Methode f√ºhrt eine Linksmultiplikation durch. <br></li><li>  makeTranslate (), makeRotate () und makeScale () - setzen die aktuelle Matrix zur√ºck und erstellen eine 4x4-Matrix, die die Bewegung, Drehung und Skalierung beschreibt.  Mit ihren statischen Versionen translate (), rotate () und scale () kann ein Matrixobjekt mit bestimmten Parametern erstellt werden. <br></li><li>  invert () - berechnet die Inverse der aktuellen Matrix.  Die statische Version von inverse () verwendet eine Matrix als Parameter und gibt eine neue Matrix zur√ºck, die invers zu der angegebenen Matrix ist. <br></li></ol><br>  OSG versteht Matrizen als Matrizen von Strings und Vektoren als Strings. Um eine Matrixtransformation auf einen Vektor anzuwenden, tun Sie dies <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  Die Reihenfolge der Matrixoperationen ist leicht zu verstehen, wenn man sich ansieht, wie Matrizen multipliziert werden, um eine √§quivalente Umwandlung zu erhalten <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  Der Entwickler muss den Transformationsprozess von links nach rechts lesen.  Das hei√üt, in dem beschriebenen Codefragment skaliert der Vektor zuerst und dann seine Bewegung. <br><br>  osg :: Matrixf enth√§lt Elemente vom Typ float. <br><br><h1>  6. Verwenden der osg :: MatrixTransform-Klasse </h1><br>  Wir wenden das in der Praxis gewonnene theoretische Wissen an, indem wir zwei Flugzeugmodelle an verschiedenen Stellen in der Szene laden. <br><br><div class="spoiler">  <b class="spoiler_title">Volltext des Transformationsbeispiels</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Das Beispiel ist eigentlich ziemlich trivial.  Laden des Flugzeugmodells aus der Datei <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Erstellen Sie einen Transformationsknoten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Wir stellen das Modell so ein, dass das Modell entlang der X-Achse 25 Einheiten nach links als Transformationsmatrix verschoben wird <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Wir legen unser Modell f√ºr den Transformationsknoten als untergeordneten Knoten fest <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  Wir machen dasselbe mit der zweiten Transformation, aber als Matrix setzen wir die Bewegung um 25 Einheiten nach rechts <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Wir erstellen einen Wurzelknoten und setzen als Transformationsknoten daf√ºr die Transformationsknoten transform1 und transform2 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Erstellen Sie einen Viewer und √ºbergeben Sie den Stammknoten als Szenendaten <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  Das Ausf√ºhren des Programms ergibt ein solches Bild <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  Die Struktur des Szenendiagramms in diesem Beispiel ist wie folgt. <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  Wir sollten nicht durch die Tatsache verwirrt werden, dass sich die Transformationsknoten (Child 1.1 und Child 1.2) auf dasselbe untergeordnete Objekt des Flugzeugmodells (Child 2) beziehen.  Dies ist ein regul√§rer OSG-Mechanismus, wenn ein untergeordneter Knoten eines Szenendiagramms mehrere √ºbergeordnete Knoten haben kann.  Daher m√ºssen wir nicht zwei Instanzen des Modells in unserem Speicher speichern, um zwei identische Ebenen in der Szene zu erhalten.  Mit diesem Mechanismus k√∂nnen Sie sehr effizient Speicher in der Anwendung zuweisen.  Das Modell wird erst aus dem Speicher gel√∂scht, wenn es als untergeordnetes Element, mindestens ein Knoten, bezeichnet wird. <br><br>  In ihrer Aktion entspricht die Klasse osg :: MatrixTransform den OpenGL-Befehlen glMultMatrix () und glLoadMatrix (), implementiert alle Arten von r√§umlichen Transformationen, ist jedoch schwierig zu verwenden, da die Transformationsmatrix berechnet werden muss. <br><br>  Die Klasse osg :: PositionAttitudeTransform funktioniert wie die OpenGL-Funktionen glTranslate (), glScale (), glRotate ().  Es bietet √∂ffentliche Methoden zum Konvertieren von untergeordneten Knoten: <br><br><ol><li>  setPosition () - Verschiebt den Knoten an einen bestimmten Punkt im Raum, der durch den Parameter osg :: Vec3 angegeben wird <br></li><li>  setScale () - skaliert das Objekt entlang der Koordinatenachsen.  Skalierungsfaktoren entlang der entsprechenden Achsen werden durch einen Parameter vom Typ osg :: Vec3 festgelegt <br></li><li>  setAttitude () - Legt die r√§umliche Ausrichtung des Objekts fest.  Als Parameter wird die Rotationskonvertierungsquaternion osg :: Quat verwendet, deren Konstruktor mehrere √úberladungen aufweist, mit denen Sie die Quaternion sowohl direkt (komponentenweise) als auch beispielsweise √ºber die Euler-Winkel osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg) angeben k√∂nnen :: Y_AXIS, zAngle, osg :: Z_AXIS) (Winkel werden im Bogenma√ü angegeben!) <br></li></ol><br><br><h1>  7. Knoten wechseln </h1><br>  Stellen Sie sich eine andere Klasse vor - osg :: Switch, mit der Sie das Rendern eines Szenenknotens abh√§ngig von einer logischen Bedingung anzeigen oder √ºberspringen k√∂nnen.  Es ist ein Nachkomme der osg :: Group-Klasse und f√ºgt jedem ihrer untergeordneten Elemente einen logischen Wert hinzu.  Es gibt mehrere n√ºtzliche √∂ffentliche Methoden: <br><ol><li>  √úberladenes addChild () verwendet als zweiten Parameter einen logischen Schl√ºssel, der angibt, ob dieser Knoten angezeigt werden soll oder nicht. <br></li><li>  setValue () - legt den Sichtbarkeits- / Unsichtbarkeitsschl√ºssel fest.  Es nimmt den Index des f√ºr uns interessanten untergeordneten Knotens und den gew√ºnschten Schl√ºsselwert.  Dementsprechend k√∂nnen Sie mit getValue () den aktuellen Schl√ºsselwert anhand des Index des f√ºr uns interessanten Knotens abrufen. <br></li><li>  setNewChildDefaultValue () - Legt den Standardwert f√ºr den Sichtbarkeitsschl√ºssel aller neuen Objekte fest, die als untergeordnete Objekte hinzugef√ºgt wurden. <br></li></ol><br>  Betrachten Sie die Anwendung dieser Klasse anhand eines Beispiels. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger Beispielschalter</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Das Beispiel ist trivial - wir laden zwei Modelle: eine konventionelle Cessna und eine Cessna mit der Wirkung eines brennenden Motors <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  Wir erstellen jedoch osg :: Switch als Stammknoten, sodass wir beim Hinzuf√ºgen von Modellen als untergeordnete Knoten den Sichtbarkeitsschl√ºssel f√ºr jeden von ihnen festlegen k√∂nnen <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Das hei√üt, Modell1 wird nicht gerendert, und Modell2 wird gerendert, was wir durch Ausf√ºhren des Programms beobachten werden <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  Durch Vertauschen der Tastenwerte sehen wir das entgegengesetzte Bild <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Wenn wir beide Tasten spannen, sehen wir zwei Modelle gleichzeitig <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  Mit der setValue () -Methode k√∂nnen Sie die Sichtbarkeit und Unsichtbarkeit eines Knotens, eines untergeordneten Elements von osg :: Switch, direkt unterwegs aktivieren <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Fazit </h1><br>  In diesem Tutorial haben wir uns alle wichtigen Zwischenknotenklassen angesehen, die in OpenSceeneGraph verwendet werden.  Damit haben wir einen weiteren Grundstein f√ºr das Wissen √ºber das Ger√§t dieser zweifellos interessanten Grafik-Engine gelegt.  Die im Artikel beschriebenen Beispiele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind nach</a> wie vor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in meinem Repository auf Github verf√ºgbar</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430242/">https://habr.com/ru/post/de430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430230/index.html">So behalten Sie Ihren Platz in einem wachsenden Startup</a></li>
<li><a href="../de430232/index.html">Generierung von Close Call in Spielen: "Am Rande der Niederlage" oder "Fast gewonnen"</a></li>
<li><a href="../de430236/index.html">NASA k√ºndigt Neumondflug an</a></li>
<li><a href="../de430238/index.html">Ein weiteres DSL auf Kotlin oder wie ich PDF von React gedruckt habe</a></li>
<li><a href="../de430240/index.html">Sicherheitsanf√§lligkeit in Bitcoin Pseudo Random Number</a></li>
<li><a href="../de430244/index.html">SpaceX erhielt die Erlaubnis, ein Satellitennetzwerk mit 11943 Satelliten bereitzustellen</a></li>
<li><a href="../de430252/index.html">Feind drinnen: wie ich zum Insider-Redding kam</a></li>
<li><a href="../de430256/index.html">Anwendungskonfiguration - Spring-Konfigurationsmetadaten</a></li>
<li><a href="../de430258/index.html">Nein zu M√ºlldeponien - stellen Sie eine Vermiciniferfarm unter das Fenster</a></li>
<li><a href="../de430260/index.html">Bericht des Club of Rome 2018, Kapitel 1.10, ‚ÄûAgenda 2030: Der Teufel versteckt sich in der Umsetzung‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>