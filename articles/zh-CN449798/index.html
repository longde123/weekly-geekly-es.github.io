<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂 🐏 👸🏿 在Unity中创建塔防，第1部分 🍔 🚾 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="领域 


- 创建一个图块字段。 
- 使用广度优先搜索的搜索路径。 
- 实现对空瓦和端瓦以及墙砖的支持。 
- 在游戏模式下编辑内容。 
- 网格字段和路径的可选显示。 
 这是有关创建简单塔防游戏的一系列教程的第一部分。 在这一部分中，我们将考虑创建一个运动场，寻找路径并放置最终的瓷砖和墙壁...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中创建塔防，第1部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1> 领域 </h1><br><ul><li> 创建一个图块字段。 </li><li> 使用广度优先搜索的搜索路径。 </li><li> 实现对空瓦和端瓦以及墙砖的支持。 </li><li> 在游戏模式下编辑内容。 </li><li> 网格字段和路径的可选显示。 </li></ul><br> 这是有关创建简单<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">塔防</a>游戏的一系列教程的第一部分。 在这一部分中，我们将考虑创建一个运动场，寻找路径并放置最终的瓷砖和墙壁。 <br><br> 该教程是在Unity 2018.3.0f2中创建的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>准备用于塔防类型游戏中的字段。</i> <br><br><h2> 塔防游戏 </h2><br> 塔防是一种游戏类型，玩家的目标是消灭成群的敌人，直到他们到达终点。 玩家通过建造攻击敌人的塔来实现他的目标。 这种体裁有很多变化。 我们将创建一个带有平铺场的游戏。 敌人将越过场地向终点移动，玩家将为他们制造障碍。 <br><a name="habracut"></a><br> 我假设您已经研究了一系列有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象管理</a>的教程。 <br><br><h3> 领域 </h3><br> 比赛场地是游戏中最重要的部分，因此我们将首先创建它。 这将是一个具有其自己的组件<code>GameBoard</code>的游戏对象，可以通过在两个维度中设置大小来初始化它，我们可以使用<code>Vector2Int</code>的值。 该字段可以使用任何大小，但是我们将在其他地方选择大小，因此我们将为此创建一个通用的<code>Initialize</code>方法。 <br><br> 此外，我们以一个四边形可视化该场，该四边形表示地球。 我们不会将字段对象本身设为四边形，而是向其添加子四边形对象。 初始化后，我们使地球的XY比例等于场的大小。 也就是说，每个图块的大小将为引擎的一个方形度量单位。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">为什么要明确将地面设置为默认值？</b> <div class="spoiler_text"> 这个想法是，可以通过序列化的隐藏字段访问通过Unity编辑器可自定义的所有内容。 必须仅在检查器中更改这些字段。 不幸的是，Unity编辑器将不断显示一个编译器警告，该值从未分配。 我们可以通过显式设置字段的默认值来抑制此警告。 您还可以分配<code>null</code> ，但是我这样做是为了明确表明我们只是使用默认值，它不是对地的真实引用，因此我们使用<code>default</code> 。 </div></div><br> 在新场景中创建一个野外对象，并添加一个具有类似于地球材质的子四边形。 由于我们正在创建一个简单的原型游戏，因此均匀的绿色材料就足够了。 沿X轴将四边形旋转90°，使其位于XZ平面上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>运动场。</i> <br><br><div class="spoiler">  <b class="spoiler_title">为什么不将游戏放置在XY平面上？</b> <div class="spoiler_text"> 尽管游戏将在2D空间中进行，但我们将使用3D敌人和可以相对于特定点移动的摄像头进行3D渲染。  XZ平面对此更加方便，并且对应于环境照明所使用的标准天窗方向。 </div></div><br><h3> 游戏 </h3><br> 接下来，创建一个负责整个游戏的<code>Game</code>组件。 在此阶段，这意味着它正在初始化该字段。 我们只是通过检查器使尺寸可自定义，并在组件唤醒时强制组件初始化该字段。 让我们使用默认大小11×11。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br> 字段大小只能为正，并且使用单个图块创建字段几乎没有意义。 因此，将最小值限制为2×2。 这可以通过添加<code>OnValidate</code>方法来实现，强制限制最小值。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">什么时候调用Onvalidate？</b> <div class="spoiler_text"> 如果存在，则Unity编辑器在更改组件后将其调用。 包括将它们添加到游戏对象时，加载场景之后，重新编译之后，在编辑器中更改之后，取消/重试之后以及重置组件之后。 <br><br>  <code>OnValidate</code>是代码中唯一可以为组件配置字段分配值的位置。 </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>游戏对象。</i> <br><br> 现在，当您启动游戏模式时，我们将收到一个大小正确的字段。 在游戏中，放置摄像机的位置使其可见，然后复制其转换组件，退出播放模式并粘贴该组件的值。 如果原点是11×11视场，则可以从上方（0.10.0）定位摄像头，然后将其沿X轴旋转90°，以便从上方观看，我们可以将摄像头保持在此固定位置，但可以将来进行更改。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>相机在领域。</i> <br><br><div class="spoiler">  <b class="spoiler_title">如何复制和粘贴组件值？</b> <div class="spoiler_text"> 通过单击带有齿轮在组件右上角的按钮时出现的下拉菜单。 </div></div><br><h3> 预制瓦 </h3><br> 该字段由正方形瓷砖组成。 敌人将能够在瓷砖之间移动，穿过边缘，但不能沿对角线移动。 移动将始终朝着最近的终点进行。 让我们用箭头用图形表示沿着瓷砖的移动方向。 您可以在<a href="">此处</a>下载箭头纹理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>在黑色背景上的箭头。</i> <br><br> 将箭头纹理放置在您的项目中，并启用<em>Alpha As Transparency</em>选项。 然后，为箭头创建材质，该材质可以是为其选择了剪切模式的默认材质，然后选择箭头作为主要纹理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>箭头材料。</i> <br><br><div class="spoiler">  <b class="spoiler_title">为什么要使用抠图渲染模式？</b> <div class="spoiler_text"> 它使您可以使用标准Unity渲染管道来遮盖箭头。 </div></div><br> 为了表示游戏中的每个图块，我们将使用游戏对象。 每个人都有自己的带有箭头材质的四边形，就像该字段具有一个四边形。 我们还将向图块组件添加图块，并带有指向其箭头的链接。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br> 创建一个图块对象并将其变成预制件。 瓷砖将与地面齐平，因此将箭头向上一点一点以免渲染时出现深度问题。 同时缩小一点，以使相邻箭头之间的空间很小。  Y偏移为0.001，比例为0.8，所有轴都相同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>预制瓦。</i> <br><br><div class="spoiler">  <b class="spoiler_title">预制砖的层次结构在哪里？</b> <div class="spoiler_text"> 您可以通过双击预制资产或通过选择预制并单击检查器中的“ <em>打开预制”</em>按钮来打开预制编辑模式。 您可以通过单击其层次结构标题左上角带有箭头的按钮来退出预制编辑模式。 </div></div><br> 请注意，图块本身不必一定是游戏对象。 仅为了跟踪字段状态才需要它们。 我们可以使用与“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象管理”</a>系列教程中的行为相同的方法。 但是在简单游戏或游戏对象原型的早期，我们感到很高兴。 将来可以更改。 <br><br><h3> 我们有瓷砖 </h3><br> 要创建图块， <code>GameBoard</code>必须具有指向图块预制件的链接。 <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>链接到预制砖。</i> <br><br> 然后，他可以在两个网格尺寸上使用双循环创建实例。 尽管大小表示为X和Y，但我们将在XZ平面上以及区域本身上排列图块。 由于场相对于原点居中，因此我们需要从图块位置的分量中减去相应的大小减去一除以二。 请注意，这必须是浮点除法，否则即使大小也不能使用。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>创建图块实例。</i> <br><br> 稍后，我们将需要访问这些磁贴，因此我们将在阵列中对其进行跟踪。 我们不需要列表，因为初始化后，字段的大小不会改变。 <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); … } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">这项工作如何进行？</b> <div class="spoiler_text"> 这是一个链接的作业。 在这种情况下，这意味着我们正在将指向平铺实例的链接分配给数组元素和局部变量。 这些操作与下面显示的代码相同。 <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2> 寻找方法 </h2><br> 在此阶段，每个图块都有一个箭头，但它们都指向Z轴的正方向，我们将其解释为北。 下一步是确定图块的正确方向。 我们通过找到敌人必须走到终点的路径来做到这一点。 <br><br><h3> 瓷砖邻居 </h3><br> 路径在北，东，南或西在瓷砖之间移动。 为了简化搜索，使<code>GameTile</code>跟踪到其四个邻居的链接。 <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br> 邻居之间的关系是对称的。 如果该图块是第二个图块的东邻，则第二个图块是第一个图块的西邻。 向<code>GameTile</code>添加常规静态方法以定义两个图块之间的这种关系。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">为什么要使用静态方法？</b> <div class="spoiler_text"> 我们可以使它成为具有单个参数的实例方法，在这种情况下，我们将其称为<code>eastTile.MakeEastWestNeighbors(westTile)</code>或类似的名称。 但是在不清楚应调用哪个图块的情况下，最好使用静态方法。 示例是<code>Vector3</code>类的<code>Distance</code>和<code>Dot</code>方法。 </div></div><br> 一旦连接，它就永远不会改变。 如果发生这种情况，则我们在代码中犯了一个错误。 您可以通过在将值<code>null</code>之前比较两个链接来进行验证，如果不正确则显示错误。 您可以<code>Debug.Assert</code>使用<code>Debug.Assert</code>方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Debug.Assert有什么作用？</b> <div class="spoiler_text"> 如果第一个参数为<code>false</code> ，则使用第二个参数（如果已指定）显示条件错误。 这样的调用仅包含在测试版本中，而没有包含在发行版本中。 因此，这是在开发过程中添加不会影响最终版本的检查的好方法。 </div></div><br> 添加类似的方法以在北部和南部邻居之间建立关系。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br> 我们可以在<code>GameBoard.Initialize</code>创建图块时建立这种关系。 如果X坐标大于零，则可以在当前图块与先前的图块之间创建东西向关系。 如果Y坐标大于零，则可以在当前图块和上一行中的图块之间创建南北关系。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br> 请注意，字段边缘上的图块没有四个邻居。 一两个邻居引用将保持为<code>null</code> 。 <br><br><h3> 距离和方向 </h3><br> 我们不会强迫所有敌人不断寻找道路。 每个图块只需要执行一次。 然后，敌人将能够从他们所位于的地砖上继续前进。 通过将链接添加到下一个路径图块，我们会将这些信息存储在<code>GameTile</code> 。 此外，我们还将保存到端点的距离，表示为敌人到达端点之前必须访问的图块数。 对于敌人来说，这些信息是无用的，但是我们将使用它来找到最短的路径。 <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br> 每次我们确定需要查找路径时，都需要初始化路径数据。 在找到路径之前，没有下一个图块，并且距离可以认为是无限的。 我们可以将其想象为<code>int.MaxValue</code>的最大可能整数值。 添加通用的<code>ClearPath</code>方法以将<code>GameTile</code>重置为此状态。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 只有在有端点的情况下才能搜索路径。 这意味着图块必须成为端点。 这样的图块的距离为零，并且没有最后一个图块，因为路径在其上结束。 添加将瓦片变成端点的通用方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 最终，所有图块都应变成一条路径，因此它们的距离将不再等于<code>int.MaxValue</code> 。 添加一个方便的getter属性，以检查图块当前是否具有路径。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">此属性如何工作？</b> <div class="spoiler_text"> 这是仅包含一个表达式的getter属性的简化条目。 它与以下代码相同。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br> 箭头运算符<code>=&gt;</code>也可以单独用于属性的获取器和设置器，方法的主体，构造函数以及其他一些地方。 </div></div><br><h3> 我们成长的方式 </h3><br> 如果我们有一个带有路径的图块，那么我们可以让它向其邻居之一生长一条路径。 最初，唯一具有路径的图块是终点，因此我们从零距离开始，然后从零距离开始增加，并朝与敌人移动相反的方向移动。 也就是说，端点的所有直接邻居的距离为1，而这些图块的所有邻居的距离为2，依此类推。 <br><br> 添加一个<code>GameTile</code>隐藏方法，以通过该参数指定其邻居之一的路径。 到邻居的距离比当前图块大一倍，并且邻居的路径表示当前图块。 仅应为已具有路径的图块调用此方法，因此让我们使用assert进行检查。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br> 想法是，我们对图块的四个邻居中的每一个调用一次此方法。 由于这些链接中的某些链接将为<code>null</code> ，因此我们将对此进行检查并停止执行。 另外，如果邻居已经有了路径，那么我们不应该做任何事情，也应该停止这样做。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br> 其余代码未知<code>GameTile</code>跟踪其邻居的方式。 因此， <code>GrowPathTo</code>是隐藏的。 我们将添加间接指示<code>GrowPathTo</code>通用方法，这些方法会告诉切片在特定方向上扩展其路径。 但是，在整个字段中搜索的代码应跟踪访问了哪些图块。 因此，如果执行终止，我们将使其返回邻居或<code>null</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br> 现在添加在特定方向上增长路径的方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3> 广泛搜索 </h3><br>  <code>GameBoard</code>必须<code>GameBoard</code>所有图块都包含正确的路径数据。 我们通过执行广度优先搜索来做到这一点。 让我们从端点磁贴开始，然后扩展到其邻居的路径，然后到这些磁贴的邻居，依此类推。 每走一步，距离就会增加一倍，并且路径永远不会在已具有路径的图块的方向上增长。 这样可以确保所有图块都将沿着最短路径指向端点。 <br><br><div class="spoiler">  <b class="spoiler_title">使用A *查找路径呢？</b> <div class="spoiler_text">  A <sup>*</sup>算法是广度优先搜索的进化发展。 当我们寻找唯一的最短路径时，这很有用。 但是我们需要所有最短的路径，因此A <sup>*</sup>没有任何优势。 有关广度优先搜索和带有动画的六边形网格上的A <sup>*的</sup>示例，请参阅有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">六边形图</a>的系列教程。 </div></div><br> 要执行搜索，我们需要跟踪添加到路径中但尚未从中生成路径的图块。 这种图块集合通常称为搜索边界。 重要的是，将图块按照添加到边框的顺序进行处理，因此让我们使用<code>Queue</code> 。 稍后我们将不得不执行几次搜索，因此我们将其设置为<code>GameBoard</code>的字段。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); … }</code> </pre> <br> 为了使竞争环境的状态始终为真，我们必须在<code>Initialize</code>的末尾找到路径，但是将代码放在单独的<code>FindPaths</code>方法中。 首先，您需要清除所有图块的路径，然后将一个图块作为终点并将其添加到边框。 首先选择第一个图块。 由于<code>tiles</code>是一个数组，因此我们可以使用<code>foreach</code>而不必担心内存污染。 如果以后从数组移动到列表，则还需要用<code>for</code>循环替换<code>foreach</code>循环。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br> 接下来，我们需要从边界取一个图块，并为其所有邻居增加一条路径，并将它们全部添加到边界。 首先，我们将向北移动，然后向东，向南移动，最后向西移动。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br> 当边框中有图块时，我们将重复此阶段。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br> 不断发展的道路并不总是将我们引向新的领域。 在添加到队列之前，我们需要检查<code>null</code>的值，但是我们可以将检查<code>null</code>推迟到队列的输出之后。 <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3> 显示路径 </h3><br> 现在我们有一个包含正确路径的字段，但是到目前为止我们还没有看到。 您需要配置箭头，以便它们沿着穿过其图块的路径指向。 可以通过转动它们来完成。 由于这些转弯总是相同的，因此我们向<code>GameTile</code>中的每个方向添加一个静态<code>Quaternion</code>段。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br> 还要添加常规的<code>ShowPath</code>方法。 如果距离为零，则图块为终点，没有东西可指向，因此请禁用其箭头。 否则，激活箭头并设置其旋转角度。 可以通过将<code>nextOnPath</code>及其邻居进行比较来确定所需方向。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后对所有磁贴调用此方法</font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到方法。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为什么不将箭头直接变成GrowPathTo？</font></font></b> <div class="spoiler_text">      .     .    ,          <code>FindPaths</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改搜索优先级 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，当终点为西南角时，所有路径都精确地向西移动，直到到达田野边缘，然后才向南移动。</font><font style="vertical-align: inherit;">这里的一切都是正确的，因为到终点实际上没有更短的路径，因为对角线移动是不可能的。</font><font style="vertical-align: inherit;">但是，还有许多其他最短的路径可能看起来更漂亮。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了更好地理解为什么找到这样的路径，请将端点移到地图的中心。</font><font style="vertical-align: inherit;">字段大小为奇数时，它只是数组中间的一个图块。</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">终点在中心。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您还记得搜索的工作原理，那么结果似乎合乎逻辑。由于我们按照东北-西南-西南的顺序添加邻居，因此北部具有最高优先级。由于我们的搜索顺序相反，因此这意味着我们经过的最后一个方向是南。这就是为什么只有很少的箭头指向南方而许多指向东方的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以通过设置路线的优先级来更改结果。让我们交换东方和南方。因此，我们必须获得南北对称和东西向对称性。</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索顺序为北-南-东-西。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它看起来更漂亮，但是最好改变路径的方向，使其接近自然的对角线运动。</font><font style="vertical-align: inherit;">我们可以通过以棋盘图案反转相邻图块的搜索优先级来实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需弄清楚我们在搜索过程中正在处理哪种类型的图块，而是添加到</font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general属性，</font><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">属性指示当前图块是否是替代图块。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在中设置此属性</font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，如果图块的X坐标是偶数，则将它们标记为替代。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x＆1）== 0的作用是什么？</font></font></b> <div class="spoiler_text">   —     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，如果它们的Y坐标是偶数，我们将更改结果的符号。</font><font style="vertical-align: inherit;">因此，我们将创建一个国际象棋图案。</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们保持相同的顺序寻找替代瓷砖，而是要使其恢复到所有其他的瓷砖。</font><font style="vertical-align: inherit;">这将迫使路径进行对角线移动并产生锯齿形。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变搜索顺序。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 换瓷砖 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，所有图块都为空。</font><font style="vertical-align: inherit;">一个图块用作端点，但是除了没有可见箭头之外，它看起来与其他所有图块相同。</font><font style="vertical-align: inherit;">我们将添加通过在其上放置对象来更改图块的功能。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 平铺内容 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切片对象本身只是跟踪切片信息的一种方法。</font><font style="vertical-align: inherit;">我们不会直接修改这些对象。</font><font style="vertical-align: inherit;">而是添加单独的内容并将其放在字段上。</font><font style="vertical-align: inherit;">现在，我们可以区分空白图块和端点图块。</font><font style="vertical-align: inherit;">为了说明这些情况，请创建一个枚举</font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，创建一个组件类型</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该组件类型</font><font style="vertical-align: inherit;">允许您通过检查器设置其内容的类型，并通过一个通用的getter属性对其进行访问。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们将为两种类型的内容创建预制件，每种内容都有一个</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有相应指定类型</font><font style="vertical-align: inherit;">的组件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们使用一个蓝色的扁平立方体来指定端点图块。</font><font style="vertical-align: inherit;">由于几乎是平坦的，因此他不需要对撞机。</font><font style="vertical-align: inherit;">若要预制空内容，请使用空游戏对象。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="目的地"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="空的"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端点的预制件和空内容。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将内容对象分配给空的图块，因为这样所有图块将始终具有内容，这意味着我们无需检查与内容的链接是否相等</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内容工厂 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使内容可编辑，我们还将使用与“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象管理”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教程中相同的方法为此创建一个工厂</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着您</font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须跟踪您的原始工厂（该工厂只能设置一次），然后使用方法将自己送回工厂</font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假定存在</font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此，我们将使用所需的方法为此创建可编写脚本的对象类型</font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在此阶段，我们不会为创建一个利用内容的功能齐全的工厂而烦恼，因此我们将使其简单地破坏内容。</font><font style="vertical-align: inherit;">之后，可以在不更改其余代码的情况下将对象的重用添加到工厂。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向</font><font style="vertical-align: inherit;">工厂添加隐藏的方法</font><font style="vertical-align: inherit;">，并以prefab作为参数。</font><font style="vertical-align: inherit;">在这里，我们再次跳过对象的重用。</font><font style="vertical-align: inherit;">他创建对象的实例，设置其原始工厂，将其移至工厂场景并返回。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例已移至工厂内容场景，可以根据需要创建该场景。</font><font style="vertical-align: inherit;">如果我们在编辑器中，那么在创建场景之前，我们需要检查它是否存在，以防在热重启期间看不到它。</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们只有两种类型的内容，因此只需为其添加两个预制配置字段。 </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工厂要完成的最后一件工作是创建一个</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有参数</font><font style="vertical-align: inherit;">的通用方法</font><font style="vertical-align: inherit;">，该参数</font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收相应预制件的实例。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否必须向每个图块添加空内容的单独实例？</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们创建一个工厂资产并配置其到预制件的链接。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容工厂 </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后将</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font><font style="vertical-align: inherit;">传递</font><font style="vertical-align: inherit;">到工厂。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与工厂比赛。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 攻砖瓦 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要更改字段，我们需要能够选择一个图块。我们将使其在游戏模式下成为可能。我们将向玩家在游戏窗口上单击的位置的场景发出光束。如果光束与瓷砖相交，则玩家触摸了它，即必须对其进行更改。</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将处理玩家的输入，但将负责确定玩家触摸了哪个图块</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非所有光线都与图块相交，因此有时我们什么也收不到。因此，我们将</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">添加到，该</font><font style="vertical-align: inherit;">方法</font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终始终最初返回</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（这意味着未找到图块）。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确定射线是否已经穿过瓷砖，我们需要</font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将射线指定为参数</font><font style="vertical-align: inherit;">来调用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它返回有关是否有交叉路口的信息。</font><font style="vertical-align: inherit;">如果是这样，尽管我们还不知道哪一块，但我们可以退还该瓷砖，因此现在我们将其退还</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要了解是否有瓷砖相交，我们需要有关该相交的更多信息。</font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用第二个参数提供此信息</font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是输出参数，由其</font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前面</font><font style="vertical-align: inherit;">的单词指示</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着方法调用可以为我们传递给它的变量分配一个值。</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们可以嵌入用于输出参数的变量的声明，让我们开始吧。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不在乎发生哪个对撞机相交，我们只是使用XZ相交位置来确定图块。</font><font style="vertical-align: inherit;">我们通过将场的一半大小添加到相交点的坐标中，然后将结果转换为整数值来获得图块的坐标。</font><font style="vertical-align: inherit;">结果，最终的图块索引将为其X坐标加上Y坐标乘以字段宽度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这仅在图块的坐标在字段内时才可行，因此我们将对其进行检查。</font><font style="vertical-align: inherit;">如果不是这种情况，则不会返回该图块。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内容变更 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样就可以更改磁贴的内容，将其添加到</font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general属性</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的getter简单地返回内容，而setter丢弃先前的内容（如果有），然后放置新的内容。</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是您唯一需要检查内容的地方</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为最初我们没有内容。</font><font style="vertical-align: inherit;">为了保证，我们执行assert，以便不使用调用设置器</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们需要玩家输入。</font><font style="vertical-align: inherit;">在束转换点击鼠标可以通过调用进行</font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数。</font><font style="vertical-align: inherit;">必须拨打主摄像机的电话，可以通过进行访问</font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此添加属性c </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们添加了一种</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查升级过程中是否按下了主鼠标按钮</font><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此，请</font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以零作为参数进行调用。</font><font style="vertical-align: inherit;">如果按下了该键，我们将处理玩家的触摸，即，我们从田地中取出砖块，并将端点作为其内容，并从工厂取出。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，我们可以通过按光标将任何图块变成端点。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个端点。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正确的领域 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们可以将图块转换为端点，但这并不影响到目前为止的路径。</font><font style="vertical-align: inherit;">此外，我们尚未为图块设置空内容。</font><font style="vertical-align: inherit;">维护字段的正确性和完整性是一项任务</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此让我们让他负责设置图块的内容。</font><font style="vertical-align: inherit;">为了实现这一点，我们将通过其方法为它提供到内容工厂的链接</font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并使用它为所有图块提供空内容的实例。</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须将工厂转移到现场。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么不将出厂配置字段添加到GameBoard？</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们现在有多个端点，</font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此</font><font style="vertical-align: inherit;">我们对其进行了更改，</font><font style="vertical-align: inherit;">以使其要求</font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个</font><font style="vertical-align: inherit;">端点</font><font style="vertical-align: inherit;">并将其全部添加到边界。</font><font style="vertical-align: inherit;">这就是支持多个端点所需的全部。</font><font style="vertical-align: inherit;">照常清除所有其他磁贴。</font><font style="vertical-align: inherit;">然后，我们删除中心的固定端点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果我们可以将图块变成端点，那么我们应该能够执行相反的操作，将端点变成空图块。</font><font style="vertical-align: inherit;">但是，我们可以得到一个完全没有终点的领域。</font><font style="vertical-align: inherit;">在这种情况下，</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将无法执行其任务。</font><font style="vertical-align: inherit;">当所有单元格的路径初始化后边框为空时，会发生这种情况。</font><font style="vertical-align: inherit;">我们将其表示为字段的无效状态，返回</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并完成执行；</font><font style="vertical-align: inherit;">否则最后返回</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现对删除端点的支持的最简单方法，使其成为切换操作。通过单击空白图块，我们将它们转换为端点，然后单击端点，将其删除。但是现在它正在更改内容</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们将为它提供一个通用方法</font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其参数是tile。如果图块是端点，则使其为空并调用</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。否则，我们将其作为终点，也将其称为</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加端点永远不会创建无效的字段状态，而删除端点则可以。</font><font style="vertical-align: inherit;">因此，在将</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图块清空后</font><font style="vertical-align: inherit;">，我们将检查它是否成功执行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果不是，则取消更改，将图块转回到端点，然后再次调用</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以返回到先前的正确状态。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证可以提高效率吗？</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在最后，</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以</font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用中心磁贴作为参数来调用，而不是显式调用</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是我们唯一以无效字段状态开始的时间，但是可以保证我们以正确的状态结束。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们强制</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是设置磁贴本身的内容。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有正确路径的多个端点。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不应该禁止Game直接设置图块的内容吗？</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙壁 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔防的目的是防止敌人到达终点。</font><font style="vertical-align: inherit;">该目标有两种实现方式。</font><font style="vertical-align: inherit;">首先，我们杀死它们，其次，我们放慢它们的速度，以便有更多时间杀死它们。</font><font style="vertical-align: inherit;">在方块场上，时间可以延长，增加了敌人需要走的距离。</font><font style="vertical-align: inherit;">这可以通过在野外放置障碍物来实现。</font><font style="vertical-align: inherit;">通常，这些都是也会杀死敌人的塔楼，但是在本教程中，我们将仅局限于墙壁。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内容内容 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙是另一种内容，因此让我们</font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向其中</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">元素。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后创建墙预制件。</font><font style="vertical-align: inherit;">这次，我们将创建一个包含图块内容的游戏对象，并向其添加一个子多维数据集，该子多维数据集将位于该字段的顶部并填充整个图块。</font><font style="vertical-align: inherit;">将它放高半个单位并保存对撞机，因为墙壁可以在视觉上与它后面的部分瓷砖重叠。</font><font style="vertical-align: inherit;">因此，当玩家触摸墙壁时，他会影响相应的图块。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="根"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="立方"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="预制件"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码和检查器中将墙预制件添加到工厂。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有预制墙的工厂。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 打开和关闭墙壁 </font></font></h3><br><font style="vertical-align: inherit;"></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就像我们对终点所做的那样，</font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">墙壁的开/关方法。</font><font style="vertical-align: inherit;">最初，我们不会检查字段的错误状态。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将只支持在空砖和墙砖之间切换，而不允许墙直接替换端点。</font><font style="vertical-align: inherit;">因此，我们只会在瓷砖为空时创建墙。</font><font style="vertical-align: inherit;">此外，墙壁应阻止对路径的搜索。</font><font style="vertical-align: inherit;">但是每个瓦片都必须有一条通往终点的路径，否则敌人会被卡住。</font><font style="vertical-align: inherit;">为此，我们再次需要使用validate </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果更改创建了错误的字段状态，则将其丢弃。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与打开和关闭端点相比，打开和关闭墙壁的使用要频繁得多，因此我们将主要使用切换墙壁</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可以通过额外的触摸（通常是鼠标右键）来切换端点，这可以通过传递</font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值1 </font><font style="vertical-align: inherit;">来识别</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了墙。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么在对角相邻的墙的阴影之间会出现较大的间隙？</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还要确保端点不能直接替换墙。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 路径搜索锁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了让墙壁阻止对路径的搜索，对于我们而言，不要在搜索边界添加带有墙壁的图块就足够了。</font><font style="vertical-align: inherit;">这可以通过强制</font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不返回带有墙的瓷砖</font><font style="vertical-align: inherit;">来完成</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是路径仍应沿墙的方向增长，以使场地上的所有瓷砖都具有路径。</font><font style="vertical-align: inherit;">这是必要的，因为有敌人的瓷砖可能会突然变成墙壁。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为确保所有图块都有路径，他们</font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须在搜索完成后检查此</font><font style="vertical-align: inherit;">路径</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果不是这种情况，则该字段的状态无效，需要返回</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不必为无效状态更新路径可视化，因为该字段将返回到先前的状态。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁影响道路。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保墙壁实际上具有正确的路径，您需要使立方体半透明。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明的墙壁。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，所有路径的正确性要求不允许墙壁围住没有终点的区域的一部分。</font><font style="vertical-align: inherit;">我们可以分割地图，但前提是每一部分至少有一个端点。</font><font style="vertical-align: inherit;">此外，每面墙都必须与空的瓷砖或端点相邻，否则它将无法形成路径。</font><font style="vertical-align: inherit;">例如，不可能制作出3×3的实心砖块。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径的可视化使我们能够查看路径搜索的工作原理，并确保它确实正确。</font><font style="vertical-align: inherit;">但这并不一定要显示给玩家，或者至少不一定要显示给玩家。</font><font style="vertical-align: inherit;">因此，让我们提供关闭箭头的功能。</font><font style="vertical-align: inherit;">这可以通过添加</font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规方法</font><font style="vertical-align: inherit;">来完成，该</font><font style="vertical-align: inherit;">方法</font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需禁用其箭头即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径映射状态是字段状态的一部分。</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向默认值</font><font style="vertical-align: inherit;">添加一个</font><font style="vertical-align: inherit;">布尔值字段以</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪其状态，并将一个通用属性添加为getter和setter。</font><font style="vertical-align: inherit;">设置器必须显示或隐藏所有图块上的路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当启用渲染时，</font><font style="vertical-align: inherit;">该方法才</font><font style="vertical-align: inherit;">应显示更新的路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，禁用路径可视化。</font><font style="vertical-align: inherit;">关闭瓷砖预制件中的箭头。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，预制箭头处于非活动状态。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们这样做是为了</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在按下某个键时切换可视化状态。</font><font style="vertical-align: inherit;">使用P键是合乎逻辑的，但是在Unity编辑器中启用/禁用游戏模式也是一个热键。</font><font style="vertical-align: inherit;">结果，当使用热键退出游戏模式时，可视化将切换，这看起来不太好。</font><font style="vertical-align: inherit;">因此，我们使用V键（可视化的缩写）。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有箭头。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格显示 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当箭头被隐藏时，很难分辨每个图块的位置。</font><font style="vertical-align: inherit;">让我们添加网格线。</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font><font style="vertical-align: inherit;">方形边框网格纹理</font><a href=""><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">该纹理可用作单独的图块轮廓。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格纹理。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不会将此纹理单独添加到每个图块，而是将其应用于地面。但是，我们将使此网格成为可选的，以及使路径可视化。因此，我们将添加到</font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置字段</font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并为其选择网格纹理。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与网格纹理的字段。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加另一个布尔字段和一个属性，以控制网格可视化的状态。</font><font style="vertical-align: inherit;">在这种情况下，设置者必须更改地球的材质，可以通过调用</font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地球并获得</font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font><font style="vertical-align: inherit;">的属性来实现</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果需要显示网格，则将</font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格纹理</font><font style="vertical-align: inherit;">分配给</font><font style="vertical-align: inherit;">material </font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">否则，将其分配给他</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请注意，当您更改材质的纹理时，将创建材质实例的副本，因此它独立于材质资产。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们</font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用G键切换网格的可视化。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，将默认的网格可视化添加到中</font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未缩放的网格。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们在整个领域都有边界。</font><font style="vertical-align: inherit;">它与纹理匹配，但这不是我们所需要的。</font><font style="vertical-align: inherit;">我们需要缩放材料的主要纹理，使其与网格的大小匹配。</font><font style="vertical-align: inherit;">您可以通过调用</font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有纹理属性名称（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和二维尺寸</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">material </font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">来实现</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们可以直接使用字段的大小，该字段的大小间接转换为value </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="没有"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="与"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有路径可视化功能的缩放网格已打开和关闭。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在这个阶段，我们为塔防游戏的平铺游戏找到了一个可行的领域。</font><font style="vertical-align: inherit;">在下一个教程中，我们将添加敌人。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">PDF </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料库</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449798/">https://habr.com/ru/post/zh-CN449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449784/index.html">在哪种情况下，值得使用Django（并且在没有必要的情况下）</a></li>
<li><a href="../zh-CN449788/index.html">勇敢的浏览器引入了基于奖励的广告平台</a></li>
<li><a href="../zh-CN449790/index.html">产品开发视觉辅助：设计</a></li>
<li><a href="../zh-CN449794/index.html">自适应天线阵列：如何工作？ （基本）</a></li>
<li><a href="../zh-CN449796/index.html">约一个女孩</a></li>
<li><a href="../zh-CN449802/index.html">职业程序员。 第1部分。第一个程序</a></li>
<li><a href="../zh-CN449804/index.html">针对生物黑客的抗衰老疗法概述</a></li>
<li><a href="../zh-CN449806/index.html">职业程序员。 第2部分。学校或自我教育</a></li>
<li><a href="../zh-CN449808/index.html">积极的Hack Day 9实验：批判性思维如何帮助生活和工作</a></li>
<li><a href="../zh-CN449814/index.html">Windows XP正式死亡，现在终于</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>