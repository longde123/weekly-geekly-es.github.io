<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 👴🏻 😛 Escribimos nuestra propia máquina virtual 🧑🏼 🐘 🔗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este tutorial, le mostraré cómo escribir su propia máquina virtual (VM) que puede ejecutar programas ensambladores como 2048 (mi amigo) o Roguelike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos nuestra propia máquina virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/"> En este tutorial, le mostraré cómo escribir su propia máquina virtual (VM) que puede ejecutar programas ensambladores como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2048</a> (mi amigo) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Roguelike</a> (el mío).  Si sabe programar, pero quiere comprender mejor lo que sucede dentro de la computadora y cómo funcionan los lenguajes de programación, entonces este proyecto es para usted.  Escribir su propia máquina virtual puede parecer un poco aterrador, pero prometo que el tema es sorprendentemente simple e instructivo. <br><br>  <a href="">El código final</a> es de aproximadamente 250 líneas en C. Es suficiente conocer solo los conceptos básicos de C o C ++, como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aritmética binaria</a> .  Cualquier sistema Unix (incluido macOS) es adecuado para compilar y ejecutar.  Se utilizan varias API de Unix para configurar la entrada y la pantalla de la consola, pero no son esenciales para el código principal.  (Se agradece la implementación del soporte de Windows). <br><br><blockquote>  <b>Nota:</b> esta VM es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa competente</a> .  Es decir, ¡ya estás leyendo su código fuente ahora mismo!  Cada parte del código se mostrará y explicará en detalle, para que pueda estar seguro de que no falta nada.  El código final se crea mediante bloques de código de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plexión</a> .  Repositorio del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Contenidos </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tabla de contenidos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de ensamblador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecución del programa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de instrucciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones Cheat Sheet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos de procesamiento de interrupción</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoja de trucos para rutinas de interrupción</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargar software</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registros mapeados de memoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Características de la plataforma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inicio de máquina virtual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Método alternativo en C ++</a> </li></ol><br><a name="2"></a><h1>  2. Introducción </h1><br><h3>  ¿Qué es una máquina virtual? </h3><br>  Una máquina virtual es un programa que actúa como una computadora.  Simula un procesador con varios otros componentes de hardware, lo que le permite realizar operaciones aritméticas, leer y escribir en la memoria e interactuar con dispositivos de entrada / salida como una computadora física real.  Lo más importante es que VM entiende un lenguaje de máquina que puede usar para programar. <br><br>  La cantidad de hardware que simula una VM en particular depende de su propósito.  Algunas máquinas virtuales reproducen el comportamiento de una computadora en particular.  La gente ya no tiene NES, pero aún podemos jugar juegos para NES simulando hardware a nivel de software.  Estos emuladores deben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recrear con precisión</a> cada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detalle</a> y cada componente de hardware principal del dispositivo original. <br><br>  ¡Otras máquinas virtuales no corresponden a ninguna computadora en particular, sino que corresponden parcialmente a varias a la vez!  Esto se hace principalmente para facilitar el desarrollo de software.  Imagine que desea crear un programa que se ejecute en múltiples arquitecturas de computadora.  La máquina virtual proporciona una plataforma estándar que proporciona portabilidad.  No es necesario reescribir el programa en diferentes dialectos de ensamblador para cada arquitectura.  Es suficiente hacer solo una pequeña VM en cada idioma.  Después de eso, cualquier programa puede escribirse solo una vez en el lenguaje ensamblador de una máquina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Nota: el</b> compilador resuelve tales problemas compilando un <i>lenguaje</i> estándar de <i>alto nivel</i> para diferentes arquitecturas de procesador.  VM crea una <i>arquitectura de CPU</i> estándar que se simula en varios dispositivos de hardware.  Una de las ventajas del compilador es que no hay sobrecarga en tiempo de ejecución como lo hace VM.  Aunque los compiladores funcionan bien, escribir un nuevo compilador para múltiples plataformas es muy difícil, por lo que las máquinas virtuales siguen siendo útiles.  En realidad, a diferentes niveles, tanto VM como compiladores se usan juntos. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La máquina virtual Java (JVM)</a> es un ejemplo muy exitoso.  El JVM en sí es de tamaño relativamente mediano; es lo suficientemente pequeño como para que un programador lo entienda.  Esto le permite escribir código para miles de dispositivos diferentes, incluidos los teléfonos.  Después de implementar la JVM en el nuevo dispositivo, cualquier programa escrito de Java, Kotlin o Clojure puede trabajar en él sin cambios.  Los únicos costos serán solo los gastos generales de la propia máquina virtual y una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mayor abstracción</a> del nivel de la máquina.  Esto suele ser un compromiso bastante bueno. <br><br>  Una VM no tiene que ser grande ni ubicua para proporcionar beneficios similares.  Los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">videojuegos</a> más antiguos a menudo usaban máquinas virtuales pequeñas para crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistemas de secuencias de comandos</a> simples. <br><br>  Las máquinas virtuales también son útiles para aislar programas de forma segura.  Una aplicación es la recolección de basura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No hay una forma trivial de</a> implementar la recolección de basura automática sobre C o C ++, ya que el programa no puede ver su propia pila o variables.  Sin embargo, la VM está "fuera" del programa en ejecución y puede observar todas las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencias a las celdas de memoria</a> en la pila. <br><br>  Otro ejemplo de este comportamiento lo demuestran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los contratos inteligentes de Ethereum</a> .  Los contratos inteligentes son pequeños programas que son ejecutados por cada nodo de validación en la cadena de bloques.  Es decir, los operadores permiten la ejecución en sus máquinas de cualquier programa escrito por desconocidos, sin ninguna oportunidad de estudiarlos con anticipación.  Para evitar acciones maliciosas, se realizan en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">máquina virtual</a> que no tiene acceso al sistema de archivos, red, disco, etc.  Ethereum también es un buen ejemplo de portabilidad.  Gracias a VM, puede escribir contratos inteligentes sin tener en cuenta las características de muchas plataformas. <br><br><a name="3"></a><h1>  3. Arquitectura LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  Nuestra VM simulará una computadora ficticia llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LC-3</a> .  Es popular para enseñar a los estudiantes ensamblador.  Aquí, un conjunto simplificado de comandos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparación con x86</a> , pero conserva todos los conceptos básicos que se utilizan en las CPU modernas. <br><br>  Primero, debe simular los componentes de hardware necesarios.  Intente comprender qué es cada componente, pero no se preocupe si no está seguro de cómo encaja en el panorama general.  Comencemos creando un archivo en C. Cada fragmento de código de esta sección debe colocarse en el alcance global de este archivo. <br><br><h3>  El recuerdo </h3><br>  El LC-3 tiene 65.536 celdas de memoria (2 <sup>16</sup> ), cada una de las cuales contiene un valor de 16 bits.  Esto significa que solo puede almacenar 128 KB, ¡mucho menos de lo que está acostumbrado!  En nuestro programa, esta memoria se almacena en una matriz simple: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Registros </h3><br>  Un registro es una ranura para almacenar un valor en la CPU.  Los registros son como un "banco de trabajo" de la CPU.  Para que pueda funcionar con algún dato, debe estar en uno de los registros.  Pero dado que solo hay unos pocos registros, solo se puede descargar una cantidad mínima de datos en un momento dado.  Los programas solucionan este problema cargando valores de la memoria en registros, calculando valores en otros registros y luego almacenando los resultados finales en la memoria. <br><br>  Solo hay 10 registros en el LC-3, cada uno con 16 bits.  La mayoría de ellos son de propósito general, pero algunos tienen roles asignados. <br><br><ul><li>  8 registros de uso general ( <code>R0-R7</code> ) </li><li>  1 registro del mostrador de equipos ( <code>PC</code> ) </li><li>  1 registro de bandera de condición ( <code>COND</code> ) </li></ul><br>  Los registros de propósito general se pueden usar para realizar cualquier cálculo de software.  El contador de instrucciones es un entero sin signo que es la dirección de memoria de la siguiente instrucción a ejecutar.  Las banderas de condición nos dicen información sobre el cálculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Al igual que la memoria, almacenaremos los registros en una matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Conjunto de instrucciones </h3><br>  Una instrucción es un comando que le dice al procesador que realice algún tipo de tarea fundamental, por ejemplo, sumar dos números.  La instrucción tiene un <b>código de</b> operación (código de operación) que indica el tipo de tarea que se realiza, así como un conjunto de <b>parámetros</b> que proporcionan información para la tarea que se realiza. <br><br>  Cada <b>código de operación</b> representa una tarea que el procesador "sabe" cómo realizar.  Hay 16 códigos de operación en LC-3.  Una computadora solo puede calcular la secuencia de estas sencillas instrucciones.  La longitud de cada instrucción es de 16 bits, y los 4 bits de la izquierda almacenan el código de operación.  El resto se usa para almacenar parámetros. <br><br>  Más adelante discutiremos en detalle lo que hace cada instrucción.  Defina los siguientes códigos de operación en este momento.  Asegúrese de mantener este orden para obtener el valor de enumeración correcto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Nota:</b> La arquitectura Intel x86 tiene cientos de instrucciones, mientras que otras arquitecturas como ARM y LC-3 son muy pocas.  Los conjuntos de instrucciones pequeños se denominan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RISC</a> , mientras que los más grandes se denominan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CISC</a> .  Los conjuntos de instrucciones grandes, por regla general, no proporcionan características fundamentalmente nuevas, pero a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">menudo simplifican la escritura del código de ensamblador</a> .  Una instrucción CISC puede reemplazar varias instrucciones RISC.  Sin embargo, los procesadores CISC son más complejos y costosos de diseñar y fabricar.  Esta y otras compensaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no permiten llamar al diseño "óptimo"</a> . </blockquote><br><h3>  Banderas de condición </h3><br>  El registro <code>R_COND</code> almacena indicadores de condición que proporcionan información sobre el último cálculo realizado.  Esto permite que los programas verifiquen las condiciones lógicas, como <code>if (x &gt; 0) { ... }</code> . <br><br>  Cada procesador tiene muchos indicadores de estado para indicar diversas situaciones.  El LC-3 usa solo tres indicadores de condición que muestran el signo del cálculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Nota:</b> (El carácter <code>&lt;&lt;</code> se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador de desplazamiento a la izquierda</a> . <code>(n &lt;&lt; k)</code> desplaza los bits <code>n</code> izquierda por <code>k</code> lugares. Por lo tanto, <code>1 &lt;&lt; 2</code> es igual a <code>4</code> Lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> si no está familiarizado con el concepto. Esto será muy importante). </blockquote><br>  ¡Hemos terminado de configurar los componentes de hardware de nuestra máquina virtual!  Después de agregar inclusiones estándar (ver el enlace de arriba), su archivo debería verse así: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Aquí hay enlaces a secciones numeradas del artículo, de donde provienen los fragmentos de código correspondientes.</font>  <font color="gray">Para una lista completa, vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa de trabajo</a> - aprox.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Ejemplos de ensamblador </h1><br>  Ahora, echemos un vistazo al programa ensamblador LC-3 para tener una idea de lo que realmente hace la máquina virtual.  No necesita saber cómo programar en ensamblador, ni entender todo aquí.  Solo trata de tener una idea general de lo que está sucediendo.  Aquí hay un simple "Hola Mundo": <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Como en C, el programa ejecuta una declaración de arriba a abajo.  Pero a diferencia de C, no hay áreas anidadas <code>{}</code> o estructuras de control como <code>if</code> o <code>while</code> ;  solo una simple lista de operadores.  Por lo tanto, es mucho más fácil de realizar. <br><br>  Tenga en cuenta que los nombres de algunos operadores corresponden a los códigos de operación que definimos anteriormente.  Sabemos que las instrucciones son de 16 bits, pero cada línea parece tener un número diferente de caracteres.  ¿Cómo es posible tal desajuste? <br><br>  Esto se debe a que el código que estamos leyendo está escrito en <b>lenguaje ensamblador</b> , en texto plano, legible y de escritura.  Una herramienta, llamada <b>ensamblador</b> , convierte cada línea de texto en una instrucción binaria de 16 bits que comprende una máquina virtual.  Esta forma binaria, que es esencialmente una matriz de instrucciones de 16 bits, se llama <b>código de máquina</b> y en realidad es ejecutada por una máquina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Nota:</b> aunque el compilador y el ensamblador juegan un papel similar en el desarrollo, no son lo mismo.  El ensamblador simplemente codifica lo que el programador escribió en el texto, reemplazando los caracteres con su representación binaria y empaquetándolos en instrucciones. </blockquote><br>  Los <code>.STRINGZ</code> <code>.ORIG</code> y <code>.STRINGZ</code> parecen instrucciones, pero no.  Estas son directivas de ensamblador que generan parte del código o datos.  Por ejemplo, <code>.STRINGZ</code> inserta una cadena de caracteres en una ubicación específica en un programa binario. <br><br>  Los bucles y las condiciones se ejecutan utilizando una instrucción tipo goto.  Aquí hay otro ejemplo que cuenta hasta 10. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Nota:</b> este tutorial no tiene que aprender el ensamblaje.  Pero si está interesado, puede escribir y construir sus propios programas LC-3 utilizando las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas LC-3</a> . </blockquote><br><a name="5"></a><h1>  5. Ejecución del programa </h1><br>  Una vez más, los ejemplos anteriores solo dan una idea de lo que hace la VM.  Para escribir una VM, no necesita una comprensión completa del ensamblador.  Siempre que siga el procedimiento apropiado para leer y ejecutar instrucciones, <i>cualquier programa</i> LC-3 funcionará correctamente, independientemente de su complejidad.  En teoría, ¡una VM incluso puede ejecutar un navegador o un sistema operativo como Linux! <br><br>  Si piensas profundamente, entonces esta es una idea filosóficamente maravillosa.  Los programas mismos pueden producir acciones arbitrariamente complejas que nunca esperamos y que tal vez no podamos entender.  Pero al mismo tiempo, toda su funcionalidad está limitada a un código simple, que escribiremos.  Al mismo tiempo, sabemos todo y nada sobre cómo funciona cada programa.  Turing mencionó esta maravillosa idea: <br><br><blockquote>  “La opinión de que las máquinas no pueden sorprender a una persona con nada se basa, creo, en un error, al que los matemáticos y filósofos son particularmente propensos.  Me refiero a la suposición de que, dado que algún hecho se ha convertido en propiedad de la mente, inmediatamente todas las consecuencias de este hecho se convertirán en propiedad de la mente ".  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Procedimiento </h3><br>  Aquí está la descripción exacta del procedimiento para escribir: <br><br><ol><li>  Descargue una instrucción de la memoria en la dirección del registro de la <code>PC</code> . </li><li>  Aumentar el registro de la <code>PC</code> . </li><li>  Vea el código de operación para determinar qué tipo de instrucción seguir. </li><li>  Siga las instrucciones usando sus parámetros. </li><li>  Regrese al paso 1. </li></ol><br>  Puede hacer la pregunta: "Pero si el ciclo continúa incrementando el contador en ausencia de <code>if</code> o <code>while</code> , ¿no terminarán las instrucciones?"  La respuesta es no.  Como ya mencionamos, algunas instrucciones tipo goto cambian el flujo de ejecución al saltar alrededor de la <code>PC</code> . <br><br>  Comenzamos el estudio de este proceso como un ejemplo del ciclo principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Implementación de instrucciones </h1><br>  Ahora su tarea es hacer la implementación correcta para cada código de operación.  Una especificación detallada de cada instrucción está contenida en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación del proyecto</a> .  A partir de la especificación, debe averiguar cómo funciona cada instrucción y escribir una implementación.  Esto es más fácil de lo que parece.  Aquí demostraré cómo implementar dos de ellos.  El código para el resto se puede encontrar en la siguiente sección. <br><br><h3>  AGREGAR </h3><br>  La instrucción <code>ADD</code> toma dos números, los agrega y almacena el resultado en un registro.  La especificación se encuentra en la documentación en la página 526. Cada instrucción <code>ADD</code> es la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Hay dos líneas en el diagrama, porque hay dos "modos" diferentes para esta instrucción.  Antes de explicar los modos, intentemos encontrar las similitudes entre ellos.  Ambos comienzan con cuatro bits idénticos <code>0001</code> .  Este es el valor del código de operación para <code>OP_ADD</code> .  Los siguientes tres bits están marcados <code>DR</code> para el registro de salida.  El registro de salida es el lugar donde se almacena la cantidad.  Los siguientes tres bits son: <code>SR1</code> .  Este es un registro que contiene el primer número que se agregará. <br><br>  Por lo tanto, sabemos dónde guardar el resultado, y sabemos el primer número para agregar.  Solo queda averiguar el segundo número para sumar.  Aquí las dos líneas comienzan a diferir.  Tenga en cuenta que el quinto bit es 0 en la parte superior y 1. está en la parte inferior, este bit corresponde al <i>modo directo</i> o al <i>modo de registro</i> .  En el modo de registro, el segundo número se almacena en el registro, como el primero.  Está marcado como <code>SR2</code> y está contenido en los bits del dos al cero.  Los bits 3 y 4 no se utilizan.  En ensamblador, se escribirá así: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  En el modo inmediato, en lugar de agregar el contenido del registro, el valor inmediato se incrusta en la instrucción misma.  Esto es conveniente porque el programa no necesita instrucciones adicionales para cargar este número en el registro de la memoria.  En cambio, ya está dentro de las instrucciones cuando lo necesitamos.  La compensación es que solo se pueden almacenar pequeños números allí.  Para ser precisos, un máximo de 2 <sup>5</sup> = 32.  Esto es más útil para aumentar los contadores o valores.  En ensamblador, puedes escribir así: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Aquí hay un extracto de la especificación: <br><br><blockquote>  Si el bit [5] es 0, entonces el segundo operando fuente se obtiene de SR2.  Si el bit [5] es 1, entonces el segundo operando fuente se obtiene expandiendo imm5 a 16 bits.  En ambos casos, el segundo operando fuente se agrega al contenido de SR1, y el resultado se almacena en DR.  (pág. 526) </blockquote><br>  Esto es similar a lo que discutimos.  Pero, ¿qué es una "extensión de significado"?  Aunque en modo directo el valor tiene solo 5 bits, debe agregarse con un número de 16 bits.  Estos 5 bits deben expandirse a 16 para corresponder a otro número.  Para números positivos, podemos completar los bits faltantes con ceros y obtener el mismo valor.  Sin embargo, para números negativos esto no funciona.  Por ejemplo, -1 en cinco bits es <code>1 1111</code> .  Si solo lo llena con ceros, obtenemos <code>0000 0000 0001 1111</code> , ¡que es 32!  Expandir el valor evita este problema al llenar bits con ceros para números positivos y unos para números negativos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Nota:</b> si está interesado en números binarios negativos, puede leer acerca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">códigos adicionales</a> .  Pero esto no es esencial.  Simplemente copie el código anterior y úselo cuando la especificación indique expandir el valor. </blockquote><br>  La especificación tiene la última oración: <br><br><blockquote>  Los códigos de condición se establecen dependiendo de si el resultado es negativo, cero o positivo.  (pág. 526) </blockquote><br>  Anteriormente definimos la condición de enumeración de las banderas, y ahora es el momento de usar estas banderas.  Cada vez que se escribe un valor en el registro, necesitamos actualizar las banderas para indicar su signo.  Escribimos una función para reutilizar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Ahora estamos listos para escribir el código para <code>ADD</code> : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Esta sección tiene mucha información, así que resumamos. <br><br><ul><li>  <code>ADD</code> toma dos valores y los almacena en un registro. </li><li>  En el modo de registro, el segundo valor a agregar está en el registro. </li><li>  En modo directo, el segundo valor está incrustado en los 5 bits correctos de la instrucción. </li><li>  Los valores de menos de 16 bits deben expandirse. </li><li>  Cada vez que la instrucción cambia de mayúsculas y minúsculas, los indicadores de condición deben actualizarse. </li></ul><br>  Puede sentirse abrumado al escribir 15 instrucciones más.  Sin embargo, la información obtenida aquí puede ser reutilizada.  La mayoría de las instrucciones usan una combinación de expansión de valor, varios modos y actualizaciones de banderas. <br><br><h3>  LDI </h3><br>  LDI significa carga "indirecta" o "indirecta" (carga indirecta).  Esta instrucción se utiliza para cargar un valor desde una ubicación de memoria en un registro.  Especificaciones en la página 532. <br><br>  Así es como se ve el diseño binario: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  A diferencia de <code>ADD</code> , no hay modos y menos parámetros.  Esta vez, el código de operación es <code>1010</code> , que corresponde al valor de enumeración <code>OP_LDI</code> .  Nuevamente, vemos un <code>DR</code> (registro de salida) de tres bits para almacenar el valor cargado.  Los bits restantes se marcan como <code>PCoffset9</code> .  Este es el valor inmediato incorporado en la instrucción (similar a <code>imm5</code> ).  Como la instrucción se carga desde la memoria, podemos adivinar que este número es un tipo de dirección que dice desde dónde cargar el valor.  La especificación explica con más detalle: <br><br><blockquote>  La dirección se calcula expandiendo los bits del valor <code>[8:0]</code> a 16 bits y agregando este valor a la <code>PC</code> ampliada.  Lo que se almacena en la memoria en esta dirección es la dirección de los datos que se cargarán en el <code>DR</code> .  (pág. 532) </blockquote><br>  Como antes, debe expandir este valor de 9 bits, pero esta vez agregarlo a la <code>PC</code> actual.  (Si observa el ciclo de ejecución, la <code>PC</code> aumentó inmediatamente después de cargar esta instrucción).  La suma resultante es la dirección de ubicación en la memoria, y esta dirección <i>contiene otro</i> valor, que es la dirección del valor de carga. <br><br>  Esto puede parecer una forma indirecta de leer de memoria, pero es necesario.  La instrucción <code>LD</code> está limitada a un desplazamiento de dirección de 9 bits, mientras que la memoria requiere una dirección de 16 bits.  <code>LDI</code> es útil para cargar valores que están almacenados en algún lugar fuera de la computadora actual, pero para usarlos, la dirección de la ubicación final debe almacenarse cerca.  Puede pensarlo como una variable local en C, que es un puntero a algunos datos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Como antes, después de escribir el valor en <code>DR</code> , los indicadores deberían actualizarse: <br><br><blockquote>  Los códigos de condición se establecen dependiendo de si el resultado es negativo, cero o positivo.  (pág. 532) </blockquote><br>  Aquí está el código para este caso: ( <code>mem_read</code> discutirá en la siguiente sección): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Como dije, para esta instrucción utilizamos una parte significativa del código y el conocimiento adquirido anteriormente al escribir <code>ADD</code> .  Lo mismo con el resto de las instrucciones. <br><br>  Ahora necesita implementar el resto de las instrucciones.  Siga las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones</a> y use el código ya escrito.  El código para todas las instrucciones se encuentra al final del artículo.  No se necesitarán dos de los <code>OP_RTI</code> <code>OP_RES</code> mencionados anteriormente: <code>OP_RTI</code> y <code>OP_RES</code> .  Puede ignorarlos o dar un error si se los llama.  Cuando haya terminado, ¡la mayor parte de su VM puede considerarse completa! <br><br><a name="7"></a><h1>  7. Cuna según las instrucciones. </h1><br>  Esta sección contiene implementaciones completas de las instrucciones restantes si está atascado. <br><br><h3>  RTI &amp; RES </h3><br>  (no utilizado) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bit "Y"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NO bit a bit</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Rama </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Saltar </h3><br>  <code>RET</code> se indica como una instrucción separada en la especificación, ya que este es otro comando en ensamblador.  Este es en realidad un caso especial de <code>JMP</code> .  <code>RET</code> ocurre siempre que <code>R1</code> sea ​​7. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Saltar registro </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Carga </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Registro de carga </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Dirección de carga efectiva </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Tienda </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Tienda indirecta </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Registro de tienda </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Procedimientos de manejo de interrupciones </h1><br>  LC-3 proporciona varias rutinas predefinidas para realizar tareas comunes e interactuar con dispositivos de E / S.  Por ejemplo, hay procedimientos para recibir entradas de teclado y líneas de salida a la consola.  Se llaman rutinas de trampa, que puede considerar como el sistema operativo o API para LC-3.  A cada subprograma se le asigna un código de interrupción (código de captura) que lo identifica (similar a un código de operación).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ejecutarlo, se llama a una instrucción </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el código del subprograma deseado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establezca la enumeración para cada código de interrupción: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás se pregunte por qué los códigos de interrupción no están incluidos en las instrucciones. </font><font style="vertical-align: inherit;">Esto se debe a que en realidad no agregan LC-3 ninguna funcionalidad nueva, sino que solo proporcionan una forma conveniente de completar la tarea (como las funciones del sistema en C). </font><font style="vertical-align: inherit;">En el simulador oficial LC-3, los códigos de interrupción </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se escriben en ensamblador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cuando se llama a un código de interrupción, la computadora se mueve a la dirección de este código. </font><font style="vertical-align: inherit;">La CPU ejecuta las instrucciones del procedimiento y, una vez finalizado, se </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restablece a la ubicación desde donde se activó la interrupción.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay una especificación sobre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cómo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementar las rutinas de interrupción: solo lo que deberían hacer. En nuestra VM, actuaremos de manera un poco diferente escribiéndolos en C. Cuando se llama al código de interrupción, se llamará a la función C. Después de su operación, la instrucción continuará. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque los procedimientos pueden escribirse en ensamblador y la computadora física LC-3 lo será, esta no es la mejor opción para la VM. En lugar de escribir sus propios procedimientos primitivos de entrada-salida, puede usar los que están disponibles en nuestro sistema operativo. Esto mejorará el funcionamiento de la máquina virtual en nuestras computadoras, simplificará el código y proporcionará un mayor nivel de abstracción para la portabilidad.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un ejemplo específico es la entrada de teclado. </font><font style="vertical-align: inherit;">La versión del ensamblador utiliza un bucle para verificar continuamente la entrada del teclado. </font><font style="vertical-align: inherit;">¡Pero se desperdicia mucho tiempo de procesador! </font><font style="vertical-align: inherit;">Usando la función apropiada del sistema operativo, el programa puede dormir tranquilo antes de la señal de entrada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el operador de opción múltiple para el código de operación, </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue otro interruptor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al igual que con las instrucciones, le mostraré cómo implementar un procedimiento y hacer el resto usted mismo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El código de interrupción se </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza para devolver una cadena con un cero final (de manera similar </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C). </font><font style="vertical-align: inherit;">Especificación en la página 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar una cadena, debemos darle a la rutina de interrupción una cadena para mostrar. </font><font style="vertical-align: inherit;">Esto se hace almacenando la dirección del primer carácter </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de que comience el procesamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la especificación:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar la cadena de caracteres ASCII en la pantalla de la consola. </font><font style="vertical-align: inherit;">Los caracteres están contenidos en celdas de memoria consecutivas, un caracter por celda, comenzando en la dirección especificada en </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La salida finaliza cuando se encuentra un valor en la memoria </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(pág. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que, a diferencia de las cadenas C, aquí los caracteres no se almacenan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un byte, sino en una ubicación en la memoria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La ubicación de la memoria del LC-3 es de 16 bits, por lo que cada carácter de la cadena es de 16 bits. </font><font style="vertical-align: inherit;">Para mostrar esto en la función C, debe convertir cada valor en un carácter e imprimirlos por separado.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se requiere nada más para este procedimiento. </font><font style="vertical-align: inherit;">Las rutinas de interrupción son bastante sencillas si conoce C. Ahora regrese a las especificaciones e implemente el resto. </font><font style="vertical-align: inherit;">Al igual que con las instrucciones, el código completo se puede encontrar al final de esta guía.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Cheat sheet para rutinas de interrupción </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta sección contiene implementaciones completas de las rutinas de interrupción restantes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrada de personaje </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salida de caracteres </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solicitud de entrada de caracteres </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salida de línea </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminación del programa </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Descarga de programas </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hablamos mucho sobre cargar y ejecutar instrucciones desde la memoria, pero ¿cómo entran las instrucciones en la memoria en general? </font><font style="vertical-align: inherit;">Al convertir un programa ensamblador a código de máquina, el resultado es un archivo que contiene una serie de instrucciones y datos. </font><font style="vertical-align: inherit;">Se puede descargar simplemente copiando el contenido directamente a una dirección en la memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los primeros 16 bits del archivo de programa indican la dirección en la memoria donde debe comenzar el programa. </font><font style="vertical-align: inherit;">Esta dirección se llama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Debe leerse primero, después de lo cual el resto de los datos se leen en la memoria desde el archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí está el código para cargar el programa en la memoria LC-3:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que para cada valor cargado se llama </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los programas LC-3 están escritos en orden de bytes directo, pero la mayoría de las computadoras modernas usan el orden inverso. </font><font style="vertical-align: inherit;">Como resultado, necesitamos voltear cada uno cargado </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Si accidentalmente usa una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computadora extraña</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces no necesita cambiar nada).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: El </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orden de bytes se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> refiere a cómo se interpretan los bytes de un entero. </font><font style="vertical-align: inherit;">En orden inverso, el primer byte es el dígito menos significativo, y en orden inverso, viceversa. </font><font style="vertical-align: inherit;">Hasta donde yo sé, la decisión </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es principalmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitraria. </font><font style="vertical-align: inherit;">Diferentes compañías tomaron decisiones diferentes, por lo que ahora tenemos implementaciones diferentes. </font><font style="vertical-align: inherit;">Para este proyecto, ya no necesita saber nada sobre el orden de los bytes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue también una función conveniente para </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que toma la ruta de la cadena:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Registros mapeados </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos registros especiales no están disponibles en la tabla de registro regular. En cambio, una dirección especial está reservada para ellos en la memoria. Para leer y escribir en estos registros, simplemente lea y escriba en su memoria. Se llaman </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros mapeados en memoria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por lo general, se utilizan para interactuar con dispositivos de hardware especiales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nuestro LC-3, necesitamos implementar dos registros asignables. Este es el registro de estado del teclado ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y el registro de datos del teclado ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). El primero indica si se ha presionado la tecla y el segundo determina qué tecla se ha presionado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la entrada del teclado se puede solicitar usando </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bloquea la ejecución hasta que se recibe la entrada. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitir</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrogar el estado del</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dispositivo mientras continúa ejecutando el programa, para que siga respondiendo mientras espera la entrada.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros mapeados complican un poco el acceso a la memoria. </font><font style="vertical-align: inherit;">No podemos leer y escribir directamente en la matriz de memoria, sino que debemos llamar a funciones especiales: setter y getter. </font><font style="vertical-align: inherit;">Después de leer la memoria del registro KBSR, el captador comprueba el teclado y actualiza ambas ubicaciones en la memoria.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Este es el último componente de una máquina virtual! </font><font style="vertical-align: inherit;">Si ha implementado el resto de las rutinas e instrucciones de interrupción, ¡está casi listo para probarlo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo escrito debe agregarse al archivo C en el siguiente orden:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Características de la plataforma </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta sección contiene algunos detalles tediosos necesarios para acceder al teclado y funcionar correctamente. </font><font style="vertical-align: inherit;">No hay nada interesante o informativo sobre el funcionamiento de las máquinas virtuales. </font><font style="vertical-align: inherit;">Siéntase libre de copiar y pegar! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si está intentando iniciar la VM en un sistema operativo que no sea Unix, como Windows, estas funciones deben reemplazarse con las funciones correspondientes de Windows.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código para extraer la ruta de los argumentos del programa y generar un ejemplo de uso si faltan. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código de configuración de entrada de terminal específico de Unix. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando se interrumpe el programa, queremos devolver la consola a su configuración normal. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicio de máquina virtual </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¡Ahora puede construir y ejecutar la máquina virtual LC-3! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compila el </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa con tu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilador favorito.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargue la versión compilada de </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecute el programa con el archivo obj como argumento: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¡Juega en 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuración </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el programa no funciona correctamente, lo más probable es que haya codificado incorrectamente algún tipo de instrucción. </font><font style="vertical-align: inherit;">Puede ser difícil de depurar. </font><font style="vertical-align: inherit;">Le recomiendo que lea el código de ensamblador del programa al mismo tiempo, y use el depurador para recorrer las instrucciones de la máquina virtual de una en una. </font><font style="vertical-align: inherit;">Al leer el código, asegúrese de que la VM vaya a las instrucciones previstas. </font><font style="vertical-align: inherit;">Si se produce una falta de coincidencia, descubrirá qué instrucción causó el problema. </font><font style="vertical-align: inherit;">Vuelva a leer la especificación y vuelva a verificar el código.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Método alternativo en C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay una forma avanzada de ejecutar instrucciones que reduce significativamente el tamaño del código. Esta es una sección completamente opcional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que C ++ admite genéricos potentes durante el proceso de compilación, podemos crear partes de instrucciones utilizando el compilador. Este método reduce la duplicación de código y en realidad está más cerca del nivel de hardware de la computadora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La idea es reutilizar los pasos comunes a cada instrucción. Por ejemplo, algunas instrucciones usan direccionamiento indirecto o extensión de un valor y lo agregan al valor actual </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De acuerdo, ¿sería bueno escribir este código una vez para todas las instrucciones?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considerando la instrucción como una secuencia de pasos, vemos que cada instrucción es solo una reorganización de varios pasos más pequeños. </font><font style="vertical-align: inherit;">Usaremos banderas de bits para indicar qué pasos seguir para cada instrucción. </font><font style="vertical-align: inherit;">El valor </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el bit de número de instrucción indica que para esta instrucción el compilador debe incluir esta sección de código.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aprendí sobre esta técnica del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulador NES desarrollado por Bisqwit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si está interesado en la emulación o NES, le recomiendo sus videos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otras versiones de C ++ usan el código ya escrito. </font><font style="vertical-align: inherit;">Versión completa </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434138/">https://habr.com/ru/post/es434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434128/index.html">PHP Digest No. 146 (10-24 de diciembre de 2018) + Resultados 2018</a></li>
<li><a href="../es434130/index.html">Interfaz reactiva. Conferencia de Artyom Belov en FrontTalks 2018</a></li>
<li><a href="../es434132/index.html">Compre un televisor y enróllelo: LG planea comenzar a vender televisores flexibles en el próximo año</a></li>
<li><a href="../es434134/index.html">Análisis de los resultados de la Encuesta Kaggle ML & DS 2018</a></li>
<li><a href="../es434136/index.html">Anatomía Corporativa</a></li>
<li><a href="../es434140/index.html">Una breve historia de las características asincrónicas de Javascript</a></li>
<li><a href="../es434142/index.html">El equipo de QRL estableció una fecha límite ajustada para la migración de tokens</a></li>
<li><a href="../es434146/index.html">Las 10 mejores películas de TI</a></li>
<li><a href="../es434150/index.html">Características de la búsqueda de empleo en Europa</a></li>
<li><a href="../es434154/index.html">Conjunto de datos de Año Nuevo 2018: semántica abierta del idioma ruso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>