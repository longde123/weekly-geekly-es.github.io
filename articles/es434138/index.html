<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>さ 答  Escribimos nuestra propia m谩quina virtual   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este tutorial, le mostrar茅 c贸mo escribir su propia m谩quina virtual (VM) que puede ejecutar programas ensambladores como 2048 (mi amigo) o Roguelike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos nuestra propia m谩quina virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/"> En este tutorial, le mostrar茅 c贸mo escribir su propia m谩quina virtual (VM) que puede ejecutar programas ensambladores como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2048</a> (mi amigo) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Roguelike</a> (el m铆o).  Si sabe programar, pero quiere comprender mejor lo que sucede dentro de la computadora y c贸mo funcionan los lenguajes de programaci贸n, entonces este proyecto es para usted.  Escribir su propia m谩quina virtual puede parecer un poco aterrador, pero prometo que el tema es sorprendentemente simple e instructivo. <br><br>  <a href="">El c贸digo final</a> es de aproximadamente 250 l铆neas en C. Es suficiente conocer solo los conceptos b谩sicos de C o C ++, como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aritm茅tica binaria</a> .  Cualquier sistema Unix (incluido macOS) es adecuado para compilar y ejecutar.  Se utilizan varias API de Unix para configurar la entrada y la pantalla de la consola, pero no son esenciales para el c贸digo principal.  (Se agradece la implementaci贸n del soporte de Windows). <br><br><blockquote>  <b>Nota:</b> esta VM es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa competente</a> .  Es decir, 隆ya est谩s leyendo su c贸digo fuente ahora mismo!  Cada parte del c贸digo se mostrar谩 y explicar谩 en detalle, para que pueda estar seguro de que no falta nada.  El c贸digo final se crea mediante bloques de c贸digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plexi贸n</a> .  Repositorio del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Contenidos </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tabla de contenidos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de ensamblador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecuci贸n del programa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci贸n de instrucciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones Cheat Sheet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos de procesamiento de interrupci贸n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoja de trucos para rutinas de interrupci贸n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargar software</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registros mapeados de memoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter铆sticas de la plataforma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inicio de m谩quina virtual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M茅todo alternativo en C ++</a> </li></ol><br><a name="2"></a><h1>  2. Introducci贸n </h1><br><h3>  驴Qu茅 es una m谩quina virtual? </h3><br>  Una m谩quina virtual es un programa que act煤a como una computadora.  Simula un procesador con varios otros componentes de hardware, lo que le permite realizar operaciones aritm茅ticas, leer y escribir en la memoria e interactuar con dispositivos de entrada / salida como una computadora f铆sica real.  Lo m谩s importante es que VM entiende un lenguaje de m谩quina que puede usar para programar. <br><br>  La cantidad de hardware que simula una VM en particular depende de su prop贸sito.  Algunas m谩quinas virtuales reproducen el comportamiento de una computadora en particular.  La gente ya no tiene NES, pero a煤n podemos jugar juegos para NES simulando hardware a nivel de software.  Estos emuladores deben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recrear con precisi贸n</a> cada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detalle</a> y cada componente de hardware principal del dispositivo original. <br><br>  隆Otras m谩quinas virtuales no corresponden a ninguna computadora en particular, sino que corresponden parcialmente a varias a la vez!  Esto se hace principalmente para facilitar el desarrollo de software.  Imagine que desea crear un programa que se ejecute en m煤ltiples arquitecturas de computadora.  La m谩quina virtual proporciona una plataforma est谩ndar que proporciona portabilidad.  No es necesario reescribir el programa en diferentes dialectos de ensamblador para cada arquitectura.  Es suficiente hacer solo una peque帽a VM en cada idioma.  Despu茅s de eso, cualquier programa puede escribirse solo una vez en el lenguaje ensamblador de una m谩quina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Nota: el</b> compilador resuelve tales problemas compilando un <i>lenguaje</i> est谩ndar de <i>alto nivel</i> para diferentes arquitecturas de procesador.  VM crea una <i>arquitectura de CPU</i> est谩ndar que se simula en varios dispositivos de hardware.  Una de las ventajas del compilador es que no hay sobrecarga en tiempo de ejecuci贸n como lo hace VM.  Aunque los compiladores funcionan bien, escribir un nuevo compilador para m煤ltiples plataformas es muy dif铆cil, por lo que las m谩quinas virtuales siguen siendo 煤tiles.  En realidad, a diferentes niveles, tanto VM como compiladores se usan juntos. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La m谩quina virtual Java (JVM)</a> es un ejemplo muy exitoso.  El JVM en s铆 es de tama帽o relativamente mediano; es lo suficientemente peque帽o como para que un programador lo entienda.  Esto le permite escribir c贸digo para miles de dispositivos diferentes, incluidos los tel茅fonos.  Despu茅s de implementar la JVM en el nuevo dispositivo, cualquier programa escrito de Java, Kotlin o Clojure puede trabajar en 茅l sin cambios.  Los 煤nicos costos ser谩n solo los gastos generales de la propia m谩quina virtual y una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mayor abstracci贸n</a> del nivel de la m谩quina.  Esto suele ser un compromiso bastante bueno. <br><br>  Una VM no tiene que ser grande ni ubicua para proporcionar beneficios similares.  Los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">videojuegos</a> m谩s antiguos a menudo usaban m谩quinas virtuales peque帽as para crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistemas de secuencias de comandos</a> simples. <br><br>  Las m谩quinas virtuales tambi茅n son 煤tiles para aislar programas de forma segura.  Una aplicaci贸n es la recolecci贸n de basura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No hay una forma trivial de</a> implementar la recolecci贸n de basura autom谩tica sobre C o C ++, ya que el programa no puede ver su propia pila o variables.  Sin embargo, la VM est谩 "fuera" del programa en ejecuci贸n y puede observar todas las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencias a las celdas de memoria</a> en la pila. <br><br>  Otro ejemplo de este comportamiento lo demuestran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los contratos inteligentes de Ethereum</a> .  Los contratos inteligentes son peque帽os programas que son ejecutados por cada nodo de validaci贸n en la cadena de bloques.  Es decir, los operadores permiten la ejecuci贸n en sus m谩quinas de cualquier programa escrito por desconocidos, sin ninguna oportunidad de estudiarlos con anticipaci贸n.  Para evitar acciones maliciosas, se realizan en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m谩quina virtual</a> que no tiene acceso al sistema de archivos, red, disco, etc.  Ethereum tambi茅n es un buen ejemplo de portabilidad.  Gracias a VM, puede escribir contratos inteligentes sin tener en cuenta las caracter铆sticas de muchas plataformas. <br><br><a name="3"></a><h1>  3. Arquitectura LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  Nuestra VM simular谩 una computadora ficticia llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LC-3</a> .  Es popular para ense帽ar a los estudiantes ensamblador.  Aqu铆, un conjunto simplificado de comandos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparaci贸n con x86</a> , pero conserva todos los conceptos b谩sicos que se utilizan en las CPU modernas. <br><br>  Primero, debe simular los componentes de hardware necesarios.  Intente comprender qu茅 es cada componente, pero no se preocupe si no est谩 seguro de c贸mo encaja en el panorama general.  Comencemos creando un archivo en C. Cada fragmento de c贸digo de esta secci贸n debe colocarse en el alcance global de este archivo. <br><br><h3>  El recuerdo </h3><br>  El LC-3 tiene 65.536 celdas de memoria (2 <sup>16</sup> ), cada una de las cuales contiene un valor de 16 bits.  Esto significa que solo puede almacenar 128 KB, 隆mucho menos de lo que est谩 acostumbrado!  En nuestro programa, esta memoria se almacena en una matriz simple: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Registros </h3><br>  Un registro es una ranura para almacenar un valor en la CPU.  Los registros son como un "banco de trabajo" de la CPU.  Para que pueda funcionar con alg煤n dato, debe estar en uno de los registros.  Pero dado que solo hay unos pocos registros, solo se puede descargar una cantidad m铆nima de datos en un momento dado.  Los programas solucionan este problema cargando valores de la memoria en registros, calculando valores en otros registros y luego almacenando los resultados finales en la memoria. <br><br>  Solo hay 10 registros en el LC-3, cada uno con 16 bits.  La mayor铆a de ellos son de prop贸sito general, pero algunos tienen roles asignados. <br><br><ul><li>  8 registros de uso general ( <code>R0-R7</code> ) </li><li>  1 registro del mostrador de equipos ( <code>PC</code> ) </li><li>  1 registro de bandera de condici贸n ( <code>COND</code> ) </li></ul><br>  Los registros de prop贸sito general se pueden usar para realizar cualquier c谩lculo de software.  El contador de instrucciones es un entero sin signo que es la direcci贸n de memoria de la siguiente instrucci贸n a ejecutar.  Las banderas de condici贸n nos dicen informaci贸n sobre el c谩lculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Al igual que la memoria, almacenaremos los registros en una matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Conjunto de instrucciones </h3><br>  Una instrucci贸n es un comando que le dice al procesador que realice alg煤n tipo de tarea fundamental, por ejemplo, sumar dos n煤meros.  La instrucci贸n tiene un <b>c贸digo de</b> operaci贸n (c贸digo de operaci贸n) que indica el tipo de tarea que se realiza, as铆 como un conjunto de <b>par谩metros</b> que proporcionan informaci贸n para la tarea que se realiza. <br><br>  Cada <b>c贸digo de operaci贸n</b> representa una tarea que el procesador "sabe" c贸mo realizar.  Hay 16 c贸digos de operaci贸n en LC-3.  Una computadora solo puede calcular la secuencia de estas sencillas instrucciones.  La longitud de cada instrucci贸n es de 16 bits, y los 4 bits de la izquierda almacenan el c贸digo de operaci贸n.  El resto se usa para almacenar par谩metros. <br><br>  M谩s adelante discutiremos en detalle lo que hace cada instrucci贸n.  Defina los siguientes c贸digos de operaci贸n en este momento.  Aseg煤rese de mantener este orden para obtener el valor de enumeraci贸n correcto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Nota:</b> La arquitectura Intel x86 tiene cientos de instrucciones, mientras que otras arquitecturas como ARM y LC-3 son muy pocas.  Los conjuntos de instrucciones peque帽os se denominan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RISC</a> , mientras que los m谩s grandes se denominan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CISC</a> .  Los conjuntos de instrucciones grandes, por regla general, no proporcionan caracter铆sticas fundamentalmente nuevas, pero a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">menudo simplifican la escritura del c贸digo de ensamblador</a> .  Una instrucci贸n CISC puede reemplazar varias instrucciones RISC.  Sin embargo, los procesadores CISC son m谩s complejos y costosos de dise帽ar y fabricar.  Esta y otras compensaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no permiten llamar al dise帽o "贸ptimo"</a> . </blockquote><br><h3>  Banderas de condici贸n </h3><br>  El registro <code>R_COND</code> almacena indicadores de condici贸n que proporcionan informaci贸n sobre el 煤ltimo c谩lculo realizado.  Esto permite que los programas verifiquen las condiciones l贸gicas, como <code>if (x &gt; 0) { ... }</code> . <br><br>  Cada procesador tiene muchos indicadores de estado para indicar diversas situaciones.  El LC-3 usa solo tres indicadores de condici贸n que muestran el signo del c谩lculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Nota:</b> (El car谩cter <code>&lt;&lt;</code> se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador de desplazamiento a la izquierda</a> . <code>(n &lt;&lt; k)</code> desplaza los bits <code>n</code> izquierda por <code>k</code> lugares. Por lo tanto, <code>1 &lt;&lt; 2</code> es igual a <code>4</code> Lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> si no est谩 familiarizado con el concepto. Esto ser谩 muy importante). </blockquote><br>  隆Hemos terminado de configurar los componentes de hardware de nuestra m谩quina virtual!  Despu茅s de agregar inclusiones est谩ndar (ver el enlace de arriba), su archivo deber铆a verse as铆: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Aqu铆 hay enlaces a secciones numeradas del art铆culo, de donde provienen los fragmentos de c贸digo correspondientes.</font>  <font color="gray">Para una lista completa, vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa de trabajo</a> - aprox.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Ejemplos de ensamblador </h1><br>  Ahora, echemos un vistazo al programa ensamblador LC-3 para tener una idea de lo que realmente hace la m谩quina virtual.  No necesita saber c贸mo programar en ensamblador, ni entender todo aqu铆.  Solo trata de tener una idea general de lo que est谩 sucediendo.  Aqu铆 hay un simple "Hola Mundo": <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Como en C, el programa ejecuta una declaraci贸n de arriba a abajo.  Pero a diferencia de C, no hay 谩reas anidadas <code>{}</code> o estructuras de control como <code>if</code> o <code>while</code> ;  solo una simple lista de operadores.  Por lo tanto, es mucho m谩s f谩cil de realizar. <br><br>  Tenga en cuenta que los nombres de algunos operadores corresponden a los c贸digos de operaci贸n que definimos anteriormente.  Sabemos que las instrucciones son de 16 bits, pero cada l铆nea parece tener un n煤mero diferente de caracteres.  驴C贸mo es posible tal desajuste? <br><br>  Esto se debe a que el c贸digo que estamos leyendo est谩 escrito en <b>lenguaje ensamblador</b> , en texto plano, legible y de escritura.  Una herramienta, llamada <b>ensamblador</b> , convierte cada l铆nea de texto en una instrucci贸n binaria de 16 bits que comprende una m谩quina virtual.  Esta forma binaria, que es esencialmente una matriz de instrucciones de 16 bits, se llama <b>c贸digo de m谩quina</b> y en realidad es ejecutada por una m谩quina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Nota:</b> aunque el compilador y el ensamblador juegan un papel similar en el desarrollo, no son lo mismo.  El ensamblador simplemente codifica lo que el programador escribi贸 en el texto, reemplazando los caracteres con su representaci贸n binaria y empaquet谩ndolos en instrucciones. </blockquote><br>  Los <code>.STRINGZ</code> <code>.ORIG</code> y <code>.STRINGZ</code> parecen instrucciones, pero no.  Estas son directivas de ensamblador que generan parte del c贸digo o datos.  Por ejemplo, <code>.STRINGZ</code> inserta una cadena de caracteres en una ubicaci贸n espec铆fica en un programa binario. <br><br>  Los bucles y las condiciones se ejecutan utilizando una instrucci贸n tipo goto.  Aqu铆 hay otro ejemplo que cuenta hasta 10. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Nota:</b> este tutorial no tiene que aprender el ensamblaje.  Pero si est谩 interesado, puede escribir y construir sus propios programas LC-3 utilizando las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas LC-3</a> . </blockquote><br><a name="5"></a><h1>  5. Ejecuci贸n del programa </h1><br>  Una vez m谩s, los ejemplos anteriores solo dan una idea de lo que hace la VM.  Para escribir una VM, no necesita una comprensi贸n completa del ensamblador.  Siempre que siga el procedimiento apropiado para leer y ejecutar instrucciones, <i>cualquier programa</i> LC-3 funcionar谩 correctamente, independientemente de su complejidad.  En teor铆a, 隆una VM incluso puede ejecutar un navegador o un sistema operativo como Linux! <br><br>  Si piensas profundamente, entonces esta es una idea filos贸ficamente maravillosa.  Los programas mismos pueden producir acciones arbitrariamente complejas que nunca esperamos y que tal vez no podamos entender.  Pero al mismo tiempo, toda su funcionalidad est谩 limitada a un c贸digo simple, que escribiremos.  Al mismo tiempo, sabemos todo y nada sobre c贸mo funciona cada programa.  Turing mencion贸 esta maravillosa idea: <br><br><blockquote>  La opini贸n de que las m谩quinas no pueden sorprender a una persona con nada se basa, creo, en un error, al que los matem谩ticos y fil贸sofos son particularmente propensos.  Me refiero a la suposici贸n de que, dado que alg煤n hecho se ha convertido en propiedad de la mente, inmediatamente todas las consecuencias de este hecho se convertir谩n en propiedad de la mente ".  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Procedimiento </h3><br>  Aqu铆 est谩 la descripci贸n exacta del procedimiento para escribir: <br><br><ol><li>  Descargue una instrucci贸n de la memoria en la direcci贸n del registro de la <code>PC</code> . </li><li>  Aumentar el registro de la <code>PC</code> . </li><li>  Vea el c贸digo de operaci贸n para determinar qu茅 tipo de instrucci贸n seguir. </li><li>  Siga las instrucciones usando sus par谩metros. </li><li>  Regrese al paso 1. </li></ol><br>  Puede hacer la pregunta: "Pero si el ciclo contin煤a incrementando el contador en ausencia de <code>if</code> o <code>while</code> , 驴no terminar谩n las instrucciones?"  La respuesta es no.  Como ya mencionamos, algunas instrucciones tipo goto cambian el flujo de ejecuci贸n al saltar alrededor de la <code>PC</code> . <br><br>  Comenzamos el estudio de este proceso como un ejemplo del ciclo principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Implementaci贸n de instrucciones </h1><br>  Ahora su tarea es hacer la implementaci贸n correcta para cada c贸digo de operaci贸n.  Una especificaci贸n detallada de cada instrucci贸n est谩 contenida en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci贸n del proyecto</a> .  A partir de la especificaci贸n, debe averiguar c贸mo funciona cada instrucci贸n y escribir una implementaci贸n.  Esto es m谩s f谩cil de lo que parece.  Aqu铆 demostrar茅 c贸mo implementar dos de ellos.  El c贸digo para el resto se puede encontrar en la siguiente secci贸n. <br><br><h3>  AGREGAR </h3><br>  La instrucci贸n <code>ADD</code> toma dos n煤meros, los agrega y almacena el resultado en un registro.  La especificaci贸n se encuentra en la documentaci贸n en la p谩gina 526. Cada instrucci贸n <code>ADD</code> es la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Hay dos l铆neas en el diagrama, porque hay dos "modos" diferentes para esta instrucci贸n.  Antes de explicar los modos, intentemos encontrar las similitudes entre ellos.  Ambos comienzan con cuatro bits id茅nticos <code>0001</code> .  Este es el valor del c贸digo de operaci贸n para <code>OP_ADD</code> .  Los siguientes tres bits est谩n marcados <code>DR</code> para el registro de salida.  El registro de salida es el lugar donde se almacena la cantidad.  Los siguientes tres bits son: <code>SR1</code> .  Este es un registro que contiene el primer n煤mero que se agregar谩. <br><br>  Por lo tanto, sabemos d贸nde guardar el resultado, y sabemos el primer n煤mero para agregar.  Solo queda averiguar el segundo n煤mero para sumar.  Aqu铆 las dos l铆neas comienzan a diferir.  Tenga en cuenta que el quinto bit es 0 en la parte superior y 1. est谩 en la parte inferior, este bit corresponde al <i>modo directo</i> o al <i>modo de registro</i> .  En el modo de registro, el segundo n煤mero se almacena en el registro, como el primero.  Est谩 marcado como <code>SR2</code> y est谩 contenido en los bits del dos al cero.  Los bits 3 y 4 no se utilizan.  En ensamblador, se escribir谩 as铆: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  En el modo inmediato, en lugar de agregar el contenido del registro, el valor inmediato se incrusta en la instrucci贸n misma.  Esto es conveniente porque el programa no necesita instrucciones adicionales para cargar este n煤mero en el registro de la memoria.  En cambio, ya est谩 dentro de las instrucciones cuando lo necesitamos.  La compensaci贸n es que solo se pueden almacenar peque帽os n煤meros all铆.  Para ser precisos, un m谩ximo de 2 <sup>5</sup> = 32.  Esto es m谩s 煤til para aumentar los contadores o valores.  En ensamblador, puedes escribir as铆: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Aqu铆 hay un extracto de la especificaci贸n: <br><br><blockquote>  Si el bit [5] es 0, entonces el segundo operando fuente se obtiene de SR2.  Si el bit [5] es 1, entonces el segundo operando fuente se obtiene expandiendo imm5 a 16 bits.  En ambos casos, el segundo operando fuente se agrega al contenido de SR1, y el resultado se almacena en DR.  (p谩g. 526) </blockquote><br>  Esto es similar a lo que discutimos.  Pero, 驴qu茅 es una "extensi贸n de significado"?  Aunque en modo directo el valor tiene solo 5 bits, debe agregarse con un n煤mero de 16 bits.  Estos 5 bits deben expandirse a 16 para corresponder a otro n煤mero.  Para n煤meros positivos, podemos completar los bits faltantes con ceros y obtener el mismo valor.  Sin embargo, para n煤meros negativos esto no funciona.  Por ejemplo, -1 en cinco bits es <code>1 1111</code> .  Si solo lo llena con ceros, obtenemos <code>0000 0000 0001 1111</code> , 隆que es 32!  Expandir el valor evita este problema al llenar bits con ceros para n煤meros positivos y unos para n煤meros negativos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Nota:</b> si est谩 interesado en n煤meros binarios negativos, puede leer acerca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c贸digos adicionales</a> .  Pero esto no es esencial.  Simplemente copie el c贸digo anterior y 煤selo cuando la especificaci贸n indique expandir el valor. </blockquote><br>  La especificaci贸n tiene la 煤ltima oraci贸n: <br><br><blockquote>  Los c贸digos de condici贸n se establecen dependiendo de si el resultado es negativo, cero o positivo.  (p谩g. 526) </blockquote><br>  Anteriormente definimos la condici贸n de enumeraci贸n de las banderas, y ahora es el momento de usar estas banderas.  Cada vez que se escribe un valor en el registro, necesitamos actualizar las banderas para indicar su signo.  Escribimos una funci贸n para reutilizar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Ahora estamos listos para escribir el c贸digo para <code>ADD</code> : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Esta secci贸n tiene mucha informaci贸n, as铆 que resumamos. <br><br><ul><li>  <code>ADD</code> toma dos valores y los almacena en un registro. </li><li>  En el modo de registro, el segundo valor a agregar est谩 en el registro. </li><li>  En modo directo, el segundo valor est谩 incrustado en los 5 bits correctos de la instrucci贸n. </li><li>  Los valores de menos de 16 bits deben expandirse. </li><li>  Cada vez que la instrucci贸n cambia de may煤sculas y min煤sculas, los indicadores de condici贸n deben actualizarse. </li></ul><br>  Puede sentirse abrumado al escribir 15 instrucciones m谩s.  Sin embargo, la informaci贸n obtenida aqu铆 puede ser reutilizada.  La mayor铆a de las instrucciones usan una combinaci贸n de expansi贸n de valor, varios modos y actualizaciones de banderas. <br><br><h3>  LDI </h3><br>  LDI significa carga "indirecta" o "indirecta" (carga indirecta).  Esta instrucci贸n se utiliza para cargar un valor desde una ubicaci贸n de memoria en un registro.  Especificaciones en la p谩gina 532. <br><br>  As铆 es como se ve el dise帽o binario: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  A diferencia de <code>ADD</code> , no hay modos y menos par谩metros.  Esta vez, el c贸digo de operaci贸n es <code>1010</code> , que corresponde al valor de enumeraci贸n <code>OP_LDI</code> .  Nuevamente, vemos un <code>DR</code> (registro de salida) de tres bits para almacenar el valor cargado.  Los bits restantes se marcan como <code>PCoffset9</code> .  Este es el valor inmediato incorporado en la instrucci贸n (similar a <code>imm5</code> ).  Como la instrucci贸n se carga desde la memoria, podemos adivinar que este n煤mero es un tipo de direcci贸n que dice desde d贸nde cargar el valor.  La especificaci贸n explica con m谩s detalle: <br><br><blockquote>  La direcci贸n se calcula expandiendo los bits del valor <code>[8:0]</code> a 16 bits y agregando este valor a la <code>PC</code> ampliada.  Lo que se almacena en la memoria en esta direcci贸n es la direcci贸n de los datos que se cargar谩n en el <code>DR</code> .  (p谩g. 532) </blockquote><br>  Como antes, debe expandir este valor de 9 bits, pero esta vez agregarlo a la <code>PC</code> actual.  (Si observa el ciclo de ejecuci贸n, la <code>PC</code> aument贸 inmediatamente despu茅s de cargar esta instrucci贸n).  La suma resultante es la direcci贸n de ubicaci贸n en la memoria, y esta direcci贸n <i>contiene otro</i> valor, que es la direcci贸n del valor de carga. <br><br>  Esto puede parecer una forma indirecta de leer de memoria, pero es necesario.  La instrucci贸n <code>LD</code> est谩 limitada a un desplazamiento de direcci贸n de 9 bits, mientras que la memoria requiere una direcci贸n de 16 bits.  <code>LDI</code> es 煤til para cargar valores que est谩n almacenados en alg煤n lugar fuera de la computadora actual, pero para usarlos, la direcci贸n de la ubicaci贸n final debe almacenarse cerca.  Puede pensarlo como una variable local en C, que es un puntero a algunos datos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Como antes, despu茅s de escribir el valor en <code>DR</code> , los indicadores deber铆an actualizarse: <br><br><blockquote>  Los c贸digos de condici贸n se establecen dependiendo de si el resultado es negativo, cero o positivo.  (p谩g. 532) </blockquote><br>  Aqu铆 est谩 el c贸digo para este caso: ( <code>mem_read</code> discutir谩 en la siguiente secci贸n): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Como dije, para esta instrucci贸n utilizamos una parte significativa del c贸digo y el conocimiento adquirido anteriormente al escribir <code>ADD</code> .  Lo mismo con el resto de las instrucciones. <br><br>  Ahora necesita implementar el resto de las instrucciones.  Siga las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones</a> y use el c贸digo ya escrito.  El c贸digo para todas las instrucciones se encuentra al final del art铆culo.  No se necesitar谩n dos de los <code>OP_RTI</code> <code>OP_RES</code> mencionados anteriormente: <code>OP_RTI</code> y <code>OP_RES</code> .  Puede ignorarlos o dar un error si se los llama.  Cuando haya terminado, 隆la mayor parte de su VM puede considerarse completa! <br><br><a name="7"></a><h1>  7. Cuna seg煤n las instrucciones. </h1><br>  Esta secci贸n contiene implementaciones completas de las instrucciones restantes si est谩 atascado. <br><br><h3>  RTI &amp; RES </h3><br>  (no utilizado) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bit "Y"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NO bit a bit</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Rama </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Saltar </h3><br>  <code>RET</code> se indica como una instrucci贸n separada en la especificaci贸n, ya que este es otro comando en ensamblador.  Este es en realidad un caso especial de <code>JMP</code> .  <code>RET</code> ocurre siempre que <code>R1</code> sea 7. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Saltar registro </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Carga </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Registro de carga </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Direcci贸n de carga efectiva </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Tienda </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Tienda indirecta </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Registro de tienda </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Procedimientos de manejo de interrupciones </h1><br>  LC-3 proporciona varias rutinas predefinidas para realizar tareas comunes e interactuar con dispositivos de E / S.  Por ejemplo, hay procedimientos para recibir entradas de teclado y l铆neas de salida a la consola.  Se llaman rutinas de trampa, que puede considerar como el sistema operativo o API para LC-3.  A cada subprograma se le asigna un c贸digo de interrupci贸n (c贸digo de captura) que lo identifica (similar a un c贸digo de operaci贸n).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ejecutarlo, se llama a una instrucci贸n </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el c贸digo del subprograma deseado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establezca la enumeraci贸n para cada c贸digo de interrupci贸n: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz谩s se pregunte por qu茅 los c贸digos de interrupci贸n no est谩n incluidos en las instrucciones. </font><font style="vertical-align: inherit;">Esto se debe a que en realidad no agregan LC-3 ninguna funcionalidad nueva, sino que solo proporcionan una forma conveniente de completar la tarea (como las funciones del sistema en C). </font><font style="vertical-align: inherit;">En el simulador oficial LC-3, los c贸digos de interrupci贸n </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se escriben en ensamblador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cuando se llama a un c贸digo de interrupci贸n, la computadora se mueve a la direcci贸n de este c贸digo. </font><font style="vertical-align: inherit;">La CPU ejecuta las instrucciones del procedimiento y, una vez finalizado, se </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restablece a la ubicaci贸n desde donde se activ贸 la interrupci贸n.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay una especificaci贸n sobre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c贸mo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementar las rutinas de interrupci贸n: solo lo que deber铆an hacer. En nuestra VM, actuaremos de manera un poco diferente escribi茅ndolos en C. Cuando se llama al c贸digo de interrupci贸n, se llamar谩 a la funci贸n C. Despu茅s de su operaci贸n, la instrucci贸n continuar谩. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque los procedimientos pueden escribirse en ensamblador y la computadora f铆sica LC-3 lo ser谩, esta no es la mejor opci贸n para la VM. En lugar de escribir sus propios procedimientos primitivos de entrada-salida, puede usar los que est谩n disponibles en nuestro sistema operativo. Esto mejorar谩 el funcionamiento de la m谩quina virtual en nuestras computadoras, simplificar谩 el c贸digo y proporcionar谩 un mayor nivel de abstracci贸n para la portabilidad.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un ejemplo espec铆fico es la entrada de teclado. </font><font style="vertical-align: inherit;">La versi贸n del ensamblador utiliza un bucle para verificar continuamente la entrada del teclado. </font><font style="vertical-align: inherit;">隆Pero se desperdicia mucho tiempo de procesador! </font><font style="vertical-align: inherit;">Usando la funci贸n apropiada del sistema operativo, el programa puede dormir tranquilo antes de la se帽al de entrada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el operador de opci贸n m煤ltiple para el c贸digo de operaci贸n, </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue otro interruptor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al igual que con las instrucciones, le mostrar茅 c贸mo implementar un procedimiento y hacer el resto usted mismo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c贸digo de interrupci贸n se </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza para devolver una cadena con un cero final (de manera similar </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C). </font><font style="vertical-align: inherit;">Especificaci贸n en la p谩gina 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar una cadena, debemos darle a la rutina de interrupci贸n una cadena para mostrar. </font><font style="vertical-align: inherit;">Esto se hace almacenando la direcci贸n del primer car谩cter </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de que comience el procesamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la especificaci贸n:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar la cadena de caracteres ASCII en la pantalla de la consola. </font><font style="vertical-align: inherit;">Los caracteres est谩n contenidos en celdas de memoria consecutivas, un caracter por celda, comenzando en la direcci贸n especificada en </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La salida finaliza cuando se encuentra un valor en la memoria </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(p谩g. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que, a diferencia de las cadenas C, aqu铆 los caracteres no se almacenan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un byte, sino en una ubicaci贸n en la memoria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La ubicaci贸n de la memoria del LC-3 es de 16 bits, por lo que cada car谩cter de la cadena es de 16 bits. </font><font style="vertical-align: inherit;">Para mostrar esto en la funci贸n C, debe convertir cada valor en un car谩cter e imprimirlos por separado.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se requiere nada m谩s para este procedimiento. </font><font style="vertical-align: inherit;">Las rutinas de interrupci贸n son bastante sencillas si conoce C. Ahora regrese a las especificaciones e implemente el resto. </font><font style="vertical-align: inherit;">Al igual que con las instrucciones, el c贸digo completo se puede encontrar al final de esta gu铆a.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Cheat sheet para rutinas de interrupci贸n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta secci贸n contiene implementaciones completas de las rutinas de interrupci贸n restantes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrada de personaje </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salida de caracteres </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solicitud de entrada de caracteres </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salida de l铆nea </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminaci贸n del programa </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Descarga de programas </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hablamos mucho sobre cargar y ejecutar instrucciones desde la memoria, pero 驴c贸mo entran las instrucciones en la memoria en general? </font><font style="vertical-align: inherit;">Al convertir un programa ensamblador a c贸digo de m谩quina, el resultado es un archivo que contiene una serie de instrucciones y datos. </font><font style="vertical-align: inherit;">Se puede descargar simplemente copiando el contenido directamente a una direcci贸n en la memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los primeros 16 bits del archivo de programa indican la direcci贸n en la memoria donde debe comenzar el programa. </font><font style="vertical-align: inherit;">Esta direcci贸n se llama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Debe leerse primero, despu茅s de lo cual el resto de los datos se leen en la memoria desde el archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 est谩 el c贸digo para cargar el programa en la memoria LC-3:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que para cada valor cargado se llama </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los programas LC-3 est谩n escritos en orden de bytes directo, pero la mayor铆a de las computadoras modernas usan el orden inverso. </font><font style="vertical-align: inherit;">Como resultado, necesitamos voltear cada uno cargado </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Si accidentalmente usa una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computadora extra帽a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces no necesita cambiar nada).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: El </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orden de bytes se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> refiere a c贸mo se interpretan los bytes de un entero. </font><font style="vertical-align: inherit;">En orden inverso, el primer byte es el d铆gito menos significativo, y en orden inverso, viceversa. </font><font style="vertical-align: inherit;">Hasta donde yo s茅, la decisi贸n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es principalmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitraria. </font><font style="vertical-align: inherit;">Diferentes compa帽铆as tomaron decisiones diferentes, por lo que ahora tenemos implementaciones diferentes. </font><font style="vertical-align: inherit;">Para este proyecto, ya no necesita saber nada sobre el orden de los bytes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue tambi茅n una funci贸n conveniente para </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que toma la ruta de la cadena:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Registros mapeados </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos registros especiales no est谩n disponibles en la tabla de registro regular. En cambio, una direcci贸n especial est谩 reservada para ellos en la memoria. Para leer y escribir en estos registros, simplemente lea y escriba en su memoria. Se llaman </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros mapeados en memoria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por lo general, se utilizan para interactuar con dispositivos de hardware especiales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nuestro LC-3, necesitamos implementar dos registros asignables. Este es el registro de estado del teclado ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y el registro de datos del teclado ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). El primero indica si se ha presionado la tecla y el segundo determina qu茅 tecla se ha presionado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la entrada del teclado se puede solicitar usando </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bloquea la ejecuci贸n hasta que se recibe la entrada. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitir</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrogar el estado del</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dispositivo mientras contin煤a ejecutando el programa, para que siga respondiendo mientras espera la entrada.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros mapeados complican un poco el acceso a la memoria. </font><font style="vertical-align: inherit;">No podemos leer y escribir directamente en la matriz de memoria, sino que debemos llamar a funciones especiales: setter y getter. </font><font style="vertical-align: inherit;">Despu茅s de leer la memoria del registro KBSR, el captador comprueba el teclado y actualiza ambas ubicaciones en la memoria.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隆Este es el 煤ltimo componente de una m谩quina virtual! </font><font style="vertical-align: inherit;">Si ha implementado el resto de las rutinas e instrucciones de interrupci贸n, 隆est谩 casi listo para probarlo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo escrito debe agregarse al archivo C en el siguiente orden:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Caracter铆sticas de la plataforma </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta secci贸n contiene algunos detalles tediosos necesarios para acceder al teclado y funcionar correctamente. </font><font style="vertical-align: inherit;">No hay nada interesante o informativo sobre el funcionamiento de las m谩quinas virtuales. </font><font style="vertical-align: inherit;">Si茅ntase libre de copiar y pegar! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si est谩 intentando iniciar la VM en un sistema operativo que no sea Unix, como Windows, estas funciones deben reemplazarse con las funciones correspondientes de Windows.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C贸digo para extraer la ruta de los argumentos del programa y generar un ejemplo de uso si faltan. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C贸digo de configuraci贸n de entrada de terminal espec铆fico de Unix. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando se interrumpe el programa, queremos devolver la consola a su configuraci贸n normal. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicio de m谩quina virtual </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隆Ahora puede construir y ejecutar la m谩quina virtual LC-3! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compila el </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa con tu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilador favorito.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargue la versi贸n compilada de </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecute el programa con el archivo obj como argumento: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隆Juega en 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuraci贸n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el programa no funciona correctamente, lo m谩s probable es que haya codificado incorrectamente alg煤n tipo de instrucci贸n. </font><font style="vertical-align: inherit;">Puede ser dif铆cil de depurar. </font><font style="vertical-align: inherit;">Le recomiendo que lea el c贸digo de ensamblador del programa al mismo tiempo, y use el depurador para recorrer las instrucciones de la m谩quina virtual de una en una. </font><font style="vertical-align: inherit;">Al leer el c贸digo, aseg煤rese de que la VM vaya a las instrucciones previstas. </font><font style="vertical-align: inherit;">Si se produce una falta de coincidencia, descubrir谩 qu茅 instrucci贸n caus贸 el problema. </font><font style="vertical-align: inherit;">Vuelva a leer la especificaci贸n y vuelva a verificar el c贸digo.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. M茅todo alternativo en C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 hay una forma avanzada de ejecutar instrucciones que reduce significativamente el tama帽o del c贸digo. Esta es una secci贸n completamente opcional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que C ++ admite gen茅ricos potentes durante el proceso de compilaci贸n, podemos crear partes de instrucciones utilizando el compilador. Este m茅todo reduce la duplicaci贸n de c贸digo y en realidad est谩 m谩s cerca del nivel de hardware de la computadora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La idea es reutilizar los pasos comunes a cada instrucci贸n. Por ejemplo, algunas instrucciones usan direccionamiento indirecto o extensi贸n de un valor y lo agregan al valor actual </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De acuerdo, 驴ser铆a bueno escribir este c贸digo una vez para todas las instrucciones?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considerando la instrucci贸n como una secuencia de pasos, vemos que cada instrucci贸n es solo una reorganizaci贸n de varios pasos m谩s peque帽os. </font><font style="vertical-align: inherit;">Usaremos banderas de bits para indicar qu茅 pasos seguir para cada instrucci贸n. </font><font style="vertical-align: inherit;">El valor </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el bit de n煤mero de instrucci贸n indica que para esta instrucci贸n el compilador debe incluir esta secci贸n de c贸digo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aprend铆 sobre esta t茅cnica del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulador NES desarrollado por Bisqwit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si est谩 interesado en la emulaci贸n o NES, le recomiendo sus videos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otras versiones de C ++ usan el c贸digo ya escrito. </font><font style="vertical-align: inherit;">Versi贸n completa </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu铆</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434138/">https://habr.com/ru/post/es434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434128/index.html">PHP Digest No. 146 (10-24 de diciembre de 2018) + Resultados 2018</a></li>
<li><a href="../es434130/index.html">Interfaz reactiva. Conferencia de Artyom Belov en FrontTalks 2018</a></li>
<li><a href="../es434132/index.html">Compre un televisor y enr贸llelo: LG planea comenzar a vender televisores flexibles en el pr贸ximo a帽o</a></li>
<li><a href="../es434134/index.html">An谩lisis de los resultados de la Encuesta Kaggle ML & DS 2018</a></li>
<li><a href="../es434136/index.html">Anatom铆a Corporativa</a></li>
<li><a href="../es434140/index.html">Una breve historia de las caracter铆sticas asincr贸nicas de Javascript</a></li>
<li><a href="../es434142/index.html">El equipo de QRL estableci贸 una fecha l铆mite ajustada para la migraci贸n de tokens</a></li>
<li><a href="../es434146/index.html">Las 10 mejores pel铆culas de TI</a></li>
<li><a href="../es434150/index.html">Caracter铆sticas de la b煤squeda de empleo en Europa</a></li>
<li><a href="../es434154/index.html">Conjunto de datos de A帽o Nuevo 2018: sem谩ntica abierta del idioma ruso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>