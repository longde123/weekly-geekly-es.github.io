<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 🐐 🧗🏾 Seluruh kebenaran tentang RTOS. Artikel # 29. Gangguan pada Nucleus SE ✋🏻 🦑 👩🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua mikroprosesor dan mikrokontroler modern mengandung semacam mekanisme interupsi. Mekanisme ini diperlukan untuk memberikan respons yang diperluka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 29. Gangguan pada Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Semua mikroprosesor dan mikrokontroler modern mengandung semacam mekanisme interupsi.  Mekanisme ini diperlukan untuk memberikan respons yang diperlukan oleh banyak aplikasi.  Tentu saja, responsif dan prediktabilitas adalah tujuan utama saat menggunakan RTOS, tetapi pada saat yang sama mereka saling bertentangan.  Menggunakan interupsi dapat mengganggu integritas OS waktu nyata.  Masalah ini dan solusinya disebutkan dalam salah satu artikel sebelumnya (# 4 dan # 6).  Pada artikel ini, kita akan melihat strategi penanganan interupsi yang digunakan dalam Nucleus SE.  Dalam semua kasus, interupsi TIDAK dikendalikan oleh Nucleus SE: mereka diproses ketika terjadi sesuai dengan prioritas dan vektor dengan cara biasa.  Waktu eksekusi mereka hanya "dicuri" dari waktu yang tersedia dalam kode aplikasi utama dan penjadwal.  Jelas, itu berarti bahwa semua penangan interrupt harus sederhana, pendek, dan cepat. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artikel sebelumnya dalam seri:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengatur waktu perangkat lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu sistem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran Data: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br></div></div><br><h2>  Interupsi reguler dan terkontrol </h2><br>  Nucleus SE menawarkan dua cara untuk menangani interupsi: "asli" atau "reguler" (Asli), di mana interupsi tidak istimewa dan sampai batas tertentu memiliki interaksi terbatas dengan OS (setidaknya ketika menggunakan penjadwal prioritas), dan " Dikelola, di mana Anda dapat mengakses lebih banyak panggilan API dari interrupt handler. <br><br>  Menggunakan makro I / O, pengendali interupsi Nucleus SE dapat digunakan dalam mode standar atau terkelola. <br><br><h3>  Interupsi staf </h3><br>  Interupsi Staf SE Inti adalah pengendali interupsi standar dan dapat dianggap "tidak dikelola."  Mereka biasanya digunakan ketika gangguan dapat terjadi dengan frekuensi tinggi dan membutuhkan pemrosesan dengan penggunaan sumber daya komputasi yang rendah.  Handler seperti itu kemungkinan besar ditulis dalam C, karena banyak kompiler tertanam modern mendukung pengembangan interrupt handler menggunakan kata kunci interrupt.  Hanya informasi kontekstual yang dianggap perlu disimpan oleh penyusun.  Ini mengarah pada batasan signifikan tentang apa yang dapat dilakukan oleh penangan interupsi standar, yang akan segera kita lihat. <br><br>  Untuk membuat interrupt handler reguler di Nucleus SE, Anda hanya perlu menulis handler interrupt biasa, termasuk memanggil makro <b>NUSE_NISR_Enter ()</b> di awal dan memanggil <b>NUSE_NISR_Exit ()</b> di akhir.  Makro ini didefinisikan dalam file <b>nuse_types.</b>  h dan atur variabel global <b>NUSE_Task_State</b> ke <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Dipandu interupsi </h3><br>  Jika Anda membutuhkan lebih banyak fleksibilitas untuk operasi interrupt handler, interupsi terkelola Nucleus SE mungkin menjadi solusinya.  Perbedaan utama dari interupsi standar adalah mempertahankan konteks.  Alih-alih membiarkan kompiler menyimpan beberapa register di stack, interrupt yang terkontrol menyimpan seluruh konteks tugas (dalam blok konteksnya sendiri) di input.  Kemudian konteks tugas saat ini dipulihkan dari blok konteks di output.  Ini memberikan kemampuan untuk mengubah tugas saat ini dengan pekerjaan kode penangan interrupt, yang dimungkinkan saat menggunakan penjadwal prioritas.  Deskripsi lengkap tentang pelestarian konteks dan restorasi di Nucleus SE disediakan dalam artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 10</a> ). <br><br>  Jelas, pelestarian penuh konteks memerlukan peningkatan penggunaan sumber daya komputasi dibandingkan dengan penyimpanan beberapa register pada stack, yang terjadi selama gangguan standar.  Harga ini harus dibayar untuk fleksibilitas tambahan, dan inilah yang menjadi alasan mengapa pilihan pendekatan penanganan interupsi disediakan. <br><br>  Interupsi terkelola dibangun menggunakan <b>NUSE_MANAGED_ISR ()</b> makro yang dijelaskan dalam <b>nuse_types.h</b> .  Makro ini membuat fungsi yang berisi tindakan berikut: <br><br><ul><li>  mempertahankan konteks tugas; </li><li>  Menetapkan <b>NUSE_Task_State ke</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  kode fungsi penangan interupsi yang disediakan pengguna; </li><li>  mengembalikan <b>NUSE_Task_State</b> ke kondisi sebelumnya; </li><li>  mengembalikan konteks tugas. </li></ul><br>  Makro mengambil dua parameter: nama interrupt digunakan sebagai nama fungsi untuk handler yang dihasilkan, dan nama fungsi yang berisi logika pengguna untuk interrupt handler. <br><br><h3>  Panggilan API dari interrupt handler </h3><br>  Himpunan fungsi API yang dapat dipanggil dari penangan interupsi standar atau terkelola tergantung pada penjadwal yang digunakan.  Secara umum, menggunakan penjadwal prioritas menyediakan banyak opsi untuk mengakses penjadwal melalui panggilan fungsi API, yang sulit ketika menggunakan penangan interupsi standar. <br><br>  <b><i>Panggilan API ke pengendali interupsi standar saat menggunakan penjadwal prioritas</i></b> <br><br>  Saat menggunakan penjadwal prioritas, sejumlah kecil panggilan fungsi API dari penangan interupsi standar diperbolehkan.  Batasan ini adalah hasil dari fleksibilitas Nucleus SE API: banyak panggilan dapat menyebabkan tugas menjadi siap dan penjadwal mungkin tidak dipanggil oleh pengendali interupsi standar (karena konteks tugas tidak disimpan).  Mematikan kunci tugas memberikan fleksibilitas yang lebih besar. <br><br>  Panggilan API berikut selalu diizinkan: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Namun, hanya <b>NUSE_Signals_Send ()</b> yang berguna untuk mereka, karena memberikan cara yang mudah untuk menunjukkan kepada tugas bahwa beberapa tindakan diperlukan. <br><br>  Jika kunci dinonaktifkan, yaitu, tugas tidak dapat dimasukkan ke status siap oleh banyak panggilan API, panggilan API tambahan menjadi tersedia: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Beberapa panggilan API selalu tidak dapat diakses oleh penangan interupsi standar, karena mereka pasti akan membutuhkan pekerjaan penjadwal: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Panggilan API ke pengendali interupsi yang dikelola atau pengendali interupsi standar saat menggunakan penjadwal apa pun selain penjadwal prioritas</i></b> <br><br>  Banyak fungsi API lainnya dapat dipanggil dari interrupt handler ketika menggunakan penjadwal Run to Completion, Round Robin, atau Time Slice.  Jika penjadwal prioritas digunakan, penangan interupsi yang dikelola memiliki serangkaian fungsi yang serupa.  Ini karena panggilan diperbolehkan, yang dapat menyebabkan penjadwalan tugas lain.  Fitur ini disediakan oleh kode <b>NUSE_Reschedule ()</b> , yang mendeteksi konteks panggilan dalam interrupt handler dan menekan perubahan konteks (memungkinkannya terjadi pada akhir interrupt handler).  Analisis lengkap pekerjaan penjadwal diberikan di salah satu artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 9</a> ). <br><br>  Persyaratan utama adalah bahwa panggilan API di dalam interrupt handler tidak boleh mengarah pada penangguhan tugas saat ini, misalnya, menunggu untuk membebaskan sumber daya. <br><br>  Dengan kata lain, panggilan semacam itu harus dilakukan dengan <b>opsi</b> jeda <b>NUSE_NO_SUSPEND</b> . <br><br>  Dengan mengingat hal ini, panggilan API berikut dapat digunakan: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Beberapa panggilan selalu dilarang, karena mereka langsung berhubungan dengan tugas saat ini: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Penangan Interupsi Jam Waktu Nyata </h2><br>  Penangan interupsi Real Time Clock (RTC) adalah satu-satunya penangan interupsi yang lengkap di Nucleus SE.  Selain menyediakan semua fungsi yang diperlukan untuk manajemen waktu di Nucleus SE, ini juga berfungsi sebagai contoh penulisan interrupt handler yang dikelola. <br><br><h3>  Operasi Handler Interrupt RTC </h3><br>  Fungsi-fungsi yang disediakan oleh pengendali interupsi RTC tercantum dalam salah satu artikel sebelumnya, yang membahas topik luas waktu sistem dalam Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 27</a> ).  Fungsionalitas yang dijelaskan adalah opsional tergantung pada konfigurasi aplikasi. <br><br><div class="spoiler">  <b class="spoiler_title">Berikut ini adalah kode penangan interupsi RTC lengkap.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Selanjutnya, kita melihat empat bidang fungsi utama untuk pengendali interupsi RTC. <br><br>  <b><i>Pengatur waktu</i></b> <br>  Jika pengatur waktu aplikasi dikonfigurasikan, interrupt handler masuk ke loop untuk memproses setiap pengatur waktu dengan mengurangi penghitungnya dengan 1. Jika pengukur waktu penghitungan berakhir (mis. Penghitung mencapai 0), dua tindakan dimungkinkan: <br><br><ul><li>  jika penangan penyelesaian waktu dikonfigurasikan dan timer memiliki penunjuk fungsi yang benar (non- <b>NULL</b> ) (dalam <b>NUSE_Timer_Expiration_Routine_Address []</b> ), penangan dijalankan dengan mengambil parameter dari <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  jika timer dikonfigurasikan untuk diinisialisasi setelah selesai (yaitu, <b>NUSE_Timer_Reschedule_Time []</b> memiliki nilai non-nol), timer akan memuat ulang dengan nilai ini. </li></ul><br>  Pengatur waktu aplikasi dijelaskan secara rinci dalam artikel sebelumnya (# 28). <br><br>  <b><i>Jam Sistem</i></b> <br>  Jika pengatur waktu sistem dikonfigurasi, nilai <b>NUSE_Tick_Cloc</b> k meningkat dengan 1. Informasi lebih lanjut dapat ditemukan di artikel # 28. <br><br>  <b><i>Tangguhkan tugas (Tugas Tidur)</i></b> <br>  Jika dukungan untuk tugas jeda diaktifkan (yaitu, <b>NUSE_Task_Sleep ()</b> panggilan API dikonfigurasikan), penghitung waktu habis dari setiap tugas (nilai dalam <b>NUSE_Task_Timeout_Counter []</b> ) dicentang, dan jika tidak sama dengan nol, berkurang sebesar 1. Jika tugasnya mencapai nol, tugas yang terkait akan dilanjutkan kembali. . <br><br>  <b><i>Penjadwalan Irisan Waktu</i></b> <br>  Jika penjadwal Time Slice digunakan, penghitung penjadwal ( <b>NUSE_Time_Slice_Ticks</b> ) dikurangi.  Jika mencapai nol, penjadwal disebut.  Panggilan ke <b>NUSE_Reschedule ()</b> bertanggung jawab untuk mengatur ulang penghitung. <br><br><h3>  Gangguan terkendali </h3><br>  Penting untuk menjelaskan mengapa pengendali interupsi RTC dapat dikontrol, karena dalam keadaan tertentu pengguna dapat memutuskan untuk menulis ulang sebagai interupsi standar untuk mengurangi penggunaan sumber daya komputasi.  Misalnya, jika hanya satu fungsi waktu sistem yang digunakan (yaitu, tidak ada pengatur waktu aplikasi, tidak ada penangguhan tugas, dan tidak ada penjadwal Time Slice), gangguan teratur akan berfungsi.  Gangguan terpandu diperlukan dalam kasus berikut: <br><br><ul><li>  jika penghitung waktu digunakan dan penangan untuk penyelesaiannya telah dikonfigurasi, karena penangan ini dapat melakukan panggilan API (dari konteks interupsi), yang akan menyebabkan penjadwalan baru.  Mereka memiliki batasan yang sama dengan panggilan API yang dibuat dari penangan interrupt (lihat sebelumnya dalam artikel ini); </li><li>  jika penjadwal prioritas digunakan, menyelesaikan penangguhan tugas mungkin memerlukan bangun tugas dengan prioritas lebih tinggi; </li><li>  jika penjadwal Time Slice digunakan, itu akan dipanggil dari pengendali interupsi RTC, oleh karena itu, diperlukan interupsi terkontrol. </li></ul><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Karena implementasi interupsi Nucleus SE sangat berbeda dari Nucleus RTOS, Anda seharusnya tidak mengharapkan kompatibilitas dalam hal ini.  Nucleus RTOS memiliki skema interupsi standar / level rendah / level tinggi, yang sedikit mirip dengan skema interupsi standar / terkontrol di Nucleus SE. <br><br><h3>  Penangan interupsi level rendah dan level tinggi </h3><br>  <b><i>Penangan Interupsi Tingkat Rendah</i></b> <br>  Low-Level Interrupt Service Routin (LISR) dilakukan dengan cara yang sama seperti pengendali biasa, termasuk menggunakan tumpukan saat ini.  Nucleus RTOS mempertahankan konteks sampai handler interrupt level rendah dipanggil, dan mengembalikan konteks setelah handler selesai.  Oleh karena itu, penangan interupsi tingkat rendah dapat ditulis dalam C dan dapat memanggil penangan lain dalam C. Namun, hanya beberapa layanan RTOS Inti yang tersedia untuk penangan tingkat rendah.  Jika penanganan interupsi membutuhkan layanan Nucleus RTOS tambahan, Anda perlu mengaktifkan pengendali interupsi tingkat tinggi.  Nucleus RTOS mendukung penggunaan beberapa penangan interupsi tingkat rendah. <br><br>  <b><i>Handler Interrupt Tingkat Tinggi</i></b> <br>  Routing Layanan Interupsi Tingkat Tinggi (HISR) dibuat dan dihapus secara dinamis.  Setiap prosesor tingkat tinggi memiliki ruang stack dan unit kontrolnya sendiri.  Memori dialokasikan oleh aplikasi.  Dan, tentu saja, penangan interupsi tingkat tinggi harus dibuat sebelum penangan interupsi tingkat rendah dapat mengaktifkannya. <br><br>  Karena interrupt handler tingkat tinggi memiliki stack dan unit kontrol sendiri, ia dapat diblokir sementara jika mencoba mengakses struktur data RTOS Nucleus yang saat ini digunakan. <br><br>  Ada tiga tingkat prioritas yang tersedia untuk penangan interupsi tingkat tinggi.  Jika pawang tingkat yang lebih tinggi dengan prioritas yang lebih tinggi diaktifkan selama pekerjaan pawang dengan prioritas yang lebih rendah, pawang dengan prioritas yang lebih rendah akan dieksekusi ketika tugas selesai.  Penangan interupsi tingkat tinggi dengan prioritas yang sama dijalankan sesuai urutan pengaktifannya.  Semua penangan interupsi tingkat tinggi yang diaktifkan harus diselesaikan sebelum melanjutkan untuk menjadwalkan tugas dalam mode normal. <br><br><h3>  Utilitas API RTOS Nucleus Menyerukan Gangguan </h3><br>  Nucleus RTOS memiliki beberapa panggilan API untuk mendukung interupsi.  Tak satu pun dari mereka diimplementasikan dalam Nucleus SE. <br><br>  Untuk interupsi standar, panggilan API menyediakan fungsi-fungsi berikut: <br><br><ul><li>  kontrol (aktivasi / deaktivasi) dari gangguan (lokal dan global); </li><li>  mengatur vektor interupsi. </li></ul><br>  Untuk gangguan tingkat rendah: <br><br><ul><li>  mendaftarkan pengendali interupsi tingkat rendah di kernel. </li></ul><br>  Untuk gangguan tingkat tinggi: <br><br><ul><li>  pembuatan / penghapusan gangguan tingkat tinggi; </li><li>  aktivasi interupsi tingkat tinggi; </li><li>  mendapatkan jumlah interupsi tingkat tinggi dalam aplikasi (saat ini); </li><li>  mendapatkan petunjuk untuk mengontrol unit-unit dari semua gangguan tingkat tinggi; </li><li>  mendapatkan petunjuk untuk mengontrol unit interupsi tingkat tinggi saat ini; </li><li>  Mendapatkan informasi interupsi tingkat tinggi. </li></ul><br>  <b><i>Kontrol interupsi global</i></b> <br><br>  Panggilan ini mengaktifkan atau menonaktifkan interupsi terlepas dari tugasnya.  Oleh karena itu, interupsi yang dinonaktifkan oleh panggilan ini akan tetap demikian hingga diaktifkan dengan menggunakan kembali panggilan ini. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - level interupsi baru untuk sistem.  Itu selalu dapat mengambil nilai <b>NU_DISABLE_INTERRUPTS</b> (menonaktifkan semua interupsi) dan <b>NU_ENABLE_INTERRUPTS</b> (mengaktifkan semua interupsi).  Nilai-nilai lain mungkin tersedia tergantung pada arsitekturnya. <br><br>  Nilai pengembalian: <br><br>  Panggilan layanan ini mengembalikan tingkat interupsi yang diaktifkan sebelumnya. <br><br>  <b><i>Kontrol interupsi lokal</i></b> <br><br>  Panggilan layanan ini memungkinkan Anda untuk mengaktifkan atau menonaktifkan interupsi tergantung pada tugas.  Panggilan ini mengubah register status ke nilai yang ditentukan.  Register status akan dikembalikan ke nilai yang ditentukan oleh panggilan terakhir ke <b>NU_Control_Interrupts ()</b> saat konteks berikutnya diubah. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - level interupsi baru untuk tugas saat ini.  Itu selalu dapat mengambil nilai <b>NU_DISABLE_INTERRUPTS</b> (menonaktifkan semua interupsi) dan <b>NU_ENABLE_INTERRUPTS</b> (mengaktifkan semua interupsi).  Nilai-nilai lain mungkin tersedia tergantung pada arsitekturnya. <br><br>  Nilai pengembalian: <br>  Panggilan layanan ini mengembalikan tingkat interupsi yang diaktifkan sebelumnya. <br><br>  <b><i>Mengatur vektor interupsi</i></b> <br><br>  Overhead ini menggantikan vektor interupsi yang ditentukan oleh vektor yang dikendalikan oleh pengendali interupsi. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Parameter: <br><br>  <b>vektor</b> - <b>vektor</b> interupsi di mana interupsi akan didaftarkan; <br>  <b>baru</b> adalah interrupt handler yang ditulis untuk vektor. <br><br>  Nilai pengembalian: <br><br>  Panggilan utilitas ini mengembalikan pointer ke interrupt handler yang sebelumnya terdaftar untuk vektor interrupt. <br><br>  <b><i>Logging Interupsi Tingkat Rendah</i></b> <br><br>  Overhead ini memanggil fungsi interrupt handler level rendah dengan vektor interrupt.  Konteks sistem secara otomatis disimpan sebelum pengendali interupsi tingkat rendah yang ditentukan dipanggil dan dipulihkan setelah penangan interupsi selesai. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Parameter: <br><br>  <b>vektor</b> - <b>vektor</b> interupsi di mana interupsi akan didaftarkan; <br>  <b>lisr_entry</b> - fungsi yang akan didaftarkan untuk vektor, nilai <b>NU_NULL</b> akan menghapus vektor; <br>  <b>old_lisr</b> adalah fungsi yang sebelumnya terdaftar untuk vektor yang ditentukan. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_VECTOR</b> - vektor tidak valid; <br>  <b>NU_NOT_Rektor</b> - saat ini vektor tidak terdaftar, karena de-registrasi ditentukan di l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - Jumlah maksimum penangan interupsi tingkat rendah terdaftar telah tercapai. <br><br>  <b><i>Menciptakan pengendali interupsi tingkat tinggi</i></b> <br>  Panggilan utilitas ini menciptakan pengendali interupsi tingkat tinggi. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - pointer ke blok kontrol yang disediakan pengguna untuk pengendali interupsi tingkat tinggi; <br>  <b>name</b> - pointer ke nama 7-karakter untuk pengendali interupsi tingkat tinggi dengan nol penghentian; <br>  <b>hisr_entry</b> - titik masuk dari fungsi pengendali interupsi tingkat tinggi; <br>  <b>prioritas</b> - ada tiga prioritas untuk penangan interupsi tingkat tinggi (0-2);  prioritas 0 adalah yang tertinggi; <br>  <b>stack_pointer</b> - penunjuk ke area tumpukan penangan interupsi tingkat tinggi; <br>  <b>stack_size</b> - jumlah byte dalam stack dari interrupt handler tingkat tinggi. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_HISR</b> - pointer nol ke unit kontrol penangan interupsi tingkat tinggi ( <b>NULL</b> ) atau unit kontrol sudah digunakan; <br>  <b>NU_INVALID_ENTRY</b> - pointer nol ke titik masuknya interrupt handler tingkat tinggi ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - prioritas yang salah untuk penangan interupsi tingkat tinggi; <br>  <b>NU_INVALID_MEMORY</b> - penunjuk tumpukan tidak valid; <br>  <b>NU_INVALID_SIZE</b> - ukuran tumpukan terlalu kecil. <br><br>  <b><i>Menghapus pawang interrupt tingkat tinggi</i></b> <br>  Panggilan utilitas ini menghapus penangan interupsi tingkat tinggi yang sebelumnya dibuat. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> adalah sebuah penunjuk ke blok kontrol penangan interupsi tingkat tinggi yang disediakan oleh pengguna. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_HISR</b> - Pointer <b>tidak valid</b> ke pengendali interupsi tingkat tinggi. <br><br>  <b><i>Mengaktifkan penangan interupsi tingkat tinggi</i></b> <br><br>  Panggilan utilitas ini mengaktifkan penangan interupsi tingkat tinggi.  Jika penangan interupsi tingkat tinggi yang ditentukan saat ini sedang dieksekusi, permintaan aktivasi tidak dieksekusi sampai penangan berhenti bekerja.  Penangan interupsi tingkat tinggi dijalankan sekali untuk setiap permintaan aktivasi. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> adalah pointer ke blok kontrol dari penangan interupsi tingkat tinggi. <br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_HISR</b> - penunjuk yang tidak valid ke unit kontrol penangan interupsi tingkat tinggi. <br><br>  <b><i>Mendapatkan jumlah penangan interupsi tingkat tinggi dalam suatu sistem</i></b> <br>  Panggilan utilitas ini mengembalikan jumlah penangan interupsi tingkat tinggi yang diinstal.  Semua penangan interupsi tingkat tinggi yang dibuat dianggap diinstal.  Penangan interupsi tingkat tinggi jarak jauh tidak dianggap diinstal. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Panggilan utilitas ini mengembalikan jumlah penangan interupsi tingkat tinggi yang diinstal dalam sistem. <br><br>  <b><i>Mendapatkan pointer untuk mengontrol blok penangan interupsi tingkat tinggi</i></b> <br><br>  Panggilan layanan ini membentuk daftar penunjuk berurutan untuk semua penangan interupsi tingkat tinggi yang terpasang dalam sistem. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Parameter: <br><br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_HISR</b> ;  array ini akan diisi dengan pointer ke penangan interupsi tingkat tinggi yang diinstal dalam sistem; <br>  maksimum_pointers - jumlah maksimum pointer <b>NU_HISR</b> yang dapat ditempatkan dalam array;  biasanya sama dengan ukuran array <b>pointer_list</b> . <br><br>  Nilai pengembalian: <br>  Panggilan utilitas ini mengembalikan jumlah penangan interupsi tingkat tinggi yang aktif dalam sistem. <br><br>  <b><i>Mendapatkan pointer ke penangan interupsi tingkat tinggi saat ini</i></b> <br>  Panggilan utilitas ini mengembalikan pointer ke penangan interupsi tingkat tinggi yang sedang dijalankan. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Panggilan layanan ini mengembalikan pointer ke unit kontrol penangan interupsi tingkat tinggi yang sedang dijalankan.  Jika penangan interupsi tingkat tinggi memanggil fungsi ini, <b>NU_NULL</b> dikembalikan. <br><br>  <b><i>Mendapatkan informasi tentang pengendali interupsi tingkat tinggi</i></b> <br>  Panggilan utilitas ini mengembalikan berbagai informasi tentang penangan interupsi tingkat tinggi yang ditentukan. <br><br>  Prototipe panggilan layanan: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - pointer ke pengendali interrupt tingkat tinggi; <br>  <b>name</b> - pointer ke wilayah 8 karakter untuk nama interrupt level handler tinggi, termasuk nol terminating; <br>  <b>dijadwalkan_count</b> - penunjuk ke variabel untuk jumlah total kali penangan interupsi tingkat tinggi ini dijadwalkan; <br>  <b>priority</b> - pointer ke variabel untuk menyimpan prioritas pengendali interupsi tingkat tinggi; <br>  <b>stack_base</b> - pointer ke pointer untuk menyimpan pointer asli ke stack;  ini adalah pointer yang sama yang dilewatkan saat membuat pengendali interupsi tingkat tinggi; <br>  <b>stack_size</b> - pointer ke variabel untuk menyimpan ukuran tumpukan total dari penangan interupsi tingkat tinggi; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pointer ke variabel untuk menyimpan jumlah minimum ruang stack yang tersedia yang terdeteksi selama eksekusi penangan interupsi tingkat tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai kembali: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - panggilan berhasil diselesaikan; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Pointer </font><b><font style="vertical-align: inherit;">tidak valid</font></b><font style="vertical-align: inherit;"> ke pengendali interupsi tingkat tinggi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panggilan API dari penangan interupsi </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan API dari penangan interupsi tingkat rendah Penangan interupsi tingkat rendah</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya dapat menggunakan fitur Nucleus RTOS berikut:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan layanan API dari penangan interupsi tingkat</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tinggi</font><b><i><font style="vertical-align: inherit;"> Penangan interupsi tingkat</font></i></b><font style="vertical-align: inherit;"> tinggi memiliki akses ke sebagian besar fungsi Nucleus RTOS, kecuali untuk fungsi penghentian sendiri, karena penangan interupsi tingkat tinggi tidak dapat menunda fungsi Nucleus RTOS, parameternya harus selalu</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel selanjutnya dalam seri ini akan membahas prosedur inisialisasi dan startup Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang penulis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, menghabiskan sebagian besar waktunya untuk firmware. </font><font style="vertical-align: inherit;">Dia sekarang seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware. </font><font style="vertical-align: inherit;">Tinggal di Inggris. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profesional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Colin</font></a><font style="vertical-align: inherit;"> , email: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458770/">https://habr.com/ru/post/id458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458758/index.html">Kemegahan dan kemiskinan literatur yang diterjemahkan</a></li>
<li><a href="../id458760/index.html">Pameran Las Vegas adalah untuk pengembang elektronik, bukan konsumen. Laporan dari Design Automation Conference</a></li>
<li><a href="../id458764/index.html">Praktek Agile Dasar untuk Tim Teknis dan Non-Teknis pada tahun 2019</a></li>
<li><a href="../id458766/index.html">IronPython di sisi kejahatan: bagaimana kami menemukan serangan cyber pada layanan publik di negara Eropa</a></li>
<li><a href="../id458768/index.html">5-6 alasan untuk datang ke GolangConf</a></li>
<li><a href="../id458774/index.html">DBMS fungsional</a></li>
<li><a href="../id458778/index.html">Satellite 6.5 Engine Reporting: Apa dan Mengapa</a></li>
<li><a href="../id458782/index.html">Adaptasi program untuk ZX Spectrum ke TR-DOS dengan cara modern. Bagian 3</a></li>
<li><a href="../id458784/index.html">Menyiarkan proyek dan perpustakaan dari Altium Designer ke PADS Professional</a></li>
<li><a href="../id458786/index.html">Penjaga video game menjaga budaya game langkah demi langkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>