<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📲 🧑‍🤝‍🧑 🐔 Winstar grafik dan mode teks ditampilkan 👨‍🔧 👨🏻‍⚕️ 🕍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tampilan grafik, termasuk yang dari tipe OLED, yang paling terwakili di pasar kami oleh Winstar, memiliki permintaan yang jauh lebih rendah sehubungan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winstar grafik dan mode teks ditampilkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402517/"> Tampilan grafik, termasuk yang dari tipe OLED, yang paling terwakili di pasar kami oleh Winstar, memiliki permintaan yang jauh lebih rendah sehubungan dengan huruf kecil dan publikasi tentang penggunaannya juga jauh lebih sedikit.  Sementara itu, ini adalah tampilan OLED grafis yang, karena kurangnya pengikatan pada tabel font dari pola yang telah ditentukan, memberikan cara terbaik untuk mendapatkan perangkat tampilan ergonomis untuk berbagai kebutuhan.  Selain itu, ternyata mode grafis pada pengontrol WS0010 lebih mudah dimulai dan berfungsi lebih stabil daripada mode teks. <br><br>  Sebelum melanjutkan ke pertimbangan tampilan grafik aktual, kami akan mempertimbangkan masalah hijau dengan masalah beralih pada mode teks dari pengontrol WS0010, yang menerima solusi yang tidak terduga dan jelas (oh, di mana mataku!). <br><a name="habracut"></a><br><h3>  Menyelesaikan Masalah Mode Teks WS0010 </h3><br>  Diketahui bahwa tampilan garis Winstar memiliki masalah stabilitas selama inisialisasi.  Ngomong-ngomong, ternyata ini tidak unik untuk "orang Cina terkutuk": sampel Newhaven Display 16x2, yang saya peroleh dengan susah payah, terletak di sisi lain dunia, secara eksternal merupakan salinan lengkap Winstar, kecuali untuk lokasi beberapa tulisan dan nama perusahaan pada blotch ( bentuk dan font yang sama): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5c4/0e4/db8/5c40e4db8577cfcdacad5ecdf2652606.jpg" width="600" alt="gambar"><br><br>  Mengandung, seperti yang tertulis dalam lembar data, pengontrol "sebanding LCD" tertentu, layar ini berperilaku sama persis dengan orang Cina dan memiliki kelemahan yang sama.  Jelas, Anda tidak boleh menghabiskan waktu memeriksa perusahaan lain, seperti Midas: menilai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi</a> ini, itu tidak akan bisa dilakukan tanpa kerja sama internasional.  Aturan ekonomi global! <br><br>  Kesulitan mode teks dinyatakan dalam fakta bahwa ketika memulai (misalnya, ketika me-reboot atau mengatur ulang program pengontrol pengendali secara manual), sampah dapat muncul pada layar, dan garis 0 dan 1 secara acak mengubah tempat.  Percobaan menunjukkan bahwa itu tidak tergantung pada metode inklusi (8-bit atau 4-bit).  Masalah ini sangat akut ketika reboot perangkat lunak berkala diperlukan, misalnya, oleh Watchdog-timer. <br><br>  Bagian dari masalah adalah sikap rapi terhadap kekuasaan (dari sumber yang terpisah, dan sama sekali tidak dari USB Arduino), dan reboot terpisah dengan mematikan dan menghidupkan layar setelah memulai program kontrol (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi</a> penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> ).  Ternyata, penulis baris-baris ini bukan satu-satunya yang mengusulkan solusi serupa untuk masalah: penulis add-on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuquidCrystal</a> bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WinstarOLED</a> juga termasuk pw_pin khusus di dalamnya, dengan mana daya tampilan terdistorsi pada saat program dimulai. <br><br>  Tapi ini semua, tentu saja, inisiatif dan setengah langkah.  Seseorang SeregaB menemukan cara yang radikal (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi</a> tentang easyelectronics.ru - terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tomasina</a> untuk tipnya).  Bahkan, ia mengajukan tugas yang sama sekali berbeda: belajar cara bekerja hanya dengan mode grafis daripada mode teks.  Mencoba beralih di antara mode, ia dengan cepat menemukan bahwa " <i>beralih ke mode grafis adalah normal, dan dari gambar ke" teks "itu sangat canggung</i> ."  Lalu dia ingat bahwa " <i>dulu, dulu sekali, ketika DShs masih dicetak di atas kertas, di beberapa DShs di HD44780 saya membaca bahwa beralih mode hanya boleh dilakukan ketika layar mati</i> ."  Dan itu berhasil. <br><br>  Dari publikasi yang dikutip, saya hanya akan mereproduksi dua prosedur switching di sini, sedikit mengadaptasinya untuk digunakan dengan LuquidCrystal (instance kelas disebut OLED1 di sini). <br><br>  Beralih ke mode grafis: <br><pre><code class="hljs cmake">OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x1F);//   OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08|<span class="hljs-number"><span class="hljs-number">0</span></span>x04);// </code> </pre> <br>  Beralih ke mode teks: <br><pre> <code class="hljs cmake"> OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x17);//    OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x04 | <span class="hljs-number"><span class="hljs-number">0</span></span>x08);// </code> </pre> <br>  Seperti yang akan kita lihat nanti, prosedur pertama tidak benar-benar diperlukan: WS0010 beralih ke mode grafis dari setengah tendangan, cukup kirim perintah 0x1F ke sana.  Tetapi urutan kedua dari perintah sangat banyak terjadi.  Untuk sampel, itu dimasukkan langsung ke dalam sketsa menggunakan LuquidCrystal dalam formulir ini: <br><pre> <code class="hljs ruby">void reset_textmode() /<span class="hljs-regexp"><span class="hljs-regexp">/     { OLED1.command(0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  OLED1.command(0x17);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x01);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x04 | 0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  }</span></span></code> </pre> <br>  Kemudian fungsi ini dipanggil dalam pengaturan tepat setelah inisiasi perpustakaan: <br><br><pre> <code class="hljs ruby"> . . . . . OLED1.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  reset_textmode(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  clear() . . . . .</code> </pre> <br>  Jika Anda memasukkan beberapa penundaan (500) sebelum ini, demonstrasi menjadi sangat jelas: setelah menekan tombol reset papan Arduino di layar, seperti biasa, sampah muncul, tetapi hanya sesaat: setelah fungsi dipicu, layar dibersihkan dan semua garis kembali ke tempatnya . <br><br>  Fungsi berfungsi seperti itu, tetapi untuk kenyamanan, saya mengganti konten fungsi LiquidCrystalRus :: clear () dalam file perpustakaan LiquidCrystalRus_OLED.cpp yang ditingkatkan yang dibahas sebelumnya dengan urutan perintah ini (saya ingatkan Anda bahwa <a href="">Anda dapat mengunduhnya</a> dari situs penulis).  Tidak ada menunggu perintah untuk dieksekusi di perpustakaan, oleh karena itu, untuk keandalan, setelah setiap perintah ada penundaan 100 μs dimasukkan dalam gaya umum perpustakaan.  Dalam sketsa menggunakan varian LiquidCrystalRus_OLED ini, pada awal setup, perlu memanggil fungsi clear (), dan pada saat yang sama akan menghapus layar. <br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  Ada satu masalah dengan membersihkan layar: dalam lembar data dari tabel perintah dicatat bahwa perintah 0x01 dapat bertahan selama 6,2 ms “ketika fsp atau fosc = 250KHz”.  Apa jenis "fsp atau fosc" sebenarnya dalam pengendali tertentu, mereka terlalu malas untuk menulis, tetapi dalam kasus apa pun, bahkan jika itu megahertz, penundaan untuk perintah ini harus signifikan (dan penulis LiquidCrystal menyebutkan ini).  Namun, dalam praktiknya, ternyata tim kebersihan bekerja sendiri jika tidak ada penundaan sama sekali.  Jadi saya tidak mengerti, tetapi bertindak berdasarkan aturan pemrograman yang terkenal: "berfungsi - jangan sentuh!". <br></div></div><br>  Sekarang mari kita akhirnya berurusan dengan mode grafis. <br><br><h3>  Mode grafis dalam teks menampilkan WEH001602 </h3><br>  Untuk memulainya, saya mencoba mengalihkan tampilan teks yang saya punya WEH001602BG ke mode grafis.  Perhatikan bahwa tampilan grafis 100x16 dan teks (konfigurasi 20x2, 16x2 hanya memiliki lebih sedikit titik horizontal) memiliki matriks yang identik, hanya tampilan teks yang dipisahkan oleh interval dalam keakraban.  Ini sangat membatasi penggunaan mode grafis dalam tampilan teks, dan bahkan lebih banyak mode teks dalam grafik.  Tetapi untuk menguji cara kerjanya, Anda dapat menggunakan salah satunya. <br><br>  Layar bersama dengan DS1307 terhubung ke Arduino Nano sesuai dengan skema berikut: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/606/8e2/216/6068e2216b082857a72cd76f322628e3.png" width="600" alt="gambar"><br><br>  Menurut skema yang sama, kami akan menghubungkan tampilan grafis di masa depan.  Warna abu-abu dalam diagram menunjukkan koneksi layar kedua, jika perlu. <br><br>  Untuk beralih ke mode grafis, Anda dapat menggunakan prosedur yang ditingkatkan dari bagian sebelumnya, tetapi fungsi sederhana dari satu perintah berfungsi: <br><pre> <code class="hljs cs">. . . . . <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_SETGRAPHICMODE 0x1f LiquidCrystal lcd(9, 4, 8, 7, 6, 5); void setGraphicMode(){ lcd.command(LCD_SETGRAPHICMODE); } . . . . .</span></span></code> </pre> <br>  Kami tidak memerlukan meja Rusia di sini, oleh karena itu, LiquidCrystal standar (tidak diluruskan) digunakan, yang bekerja dengan sempurna dalam mode grafis.  Agar tidak dipusingkan dengan debugging semua opsi perpustakaan, dalam kasus ketika teks dan tampilan grafis dimasukkan secara paralel, maka untuk setiap saya menggunakan perpustakaan saya sendiri (untuk upgrade teks Rus_OLED, untuk grafis normal).  Dalam hal ini, koneksi masih dapat dibuat ke kaki pengontrol yang sama, dengan pengecualian pin keluaran E, menurut diagram di atas. <br><br>  Lebih lanjut, saya sebagian menggunakan pencapaian penulis perpustakaan WinstarOLED yang disebutkan (dalam dirinya sendiri, add-on untuk LuquidCrystal ini, menurut pendapat saya, belum selesai, dan tidak praktis untuk menggunakannya sebagai).  Dia memperkenalkan fungsi yang nyaman untuk mengatur kursor grafis (kesalahan awal mengenai nilai <i>x</i> maksimum diperbaiki di sini): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | x); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | y); } }</code> </pre> <br>  LCD_SETDDRAMADDR konstan didefinisikan dalam perpustakaan LiquidCrystal.  Tampilan 100x16, seperti tampilan teks, dibagi menjadi dua baris, 0 dan 1, karena Anda hanya dapat mengambil dua nilai di sini.  Dan koordinat horizontal <i>x</i> bervariasi dari 0 hingga 99. Satu byte dikirim dengan perintah lcd.write (), bit-bit individual yang menentukan posisi bercahaya garis vertikal dengan panjang 8 poin.  Posisi paling kiri di baris atas memiliki koordinat 0,0, paling kanan di bawah - 99,1.  Selain itu, titik terendah akan sesuai dengan bit paling tidak signifikan, dan titik terendah - tertinggi. <br><br>  Untuk kenyamanan penyandian gambar, saya menggambar piring di mana Anda dapat dengan cepat membuat kode yang diinginkan secara manual.  Untuk tabel font lengkap, tentu saja, disarankan untuk menggunakan editor khusus (setidaknya ada sejuta derajat aktivitas amatir), tetapi 10 digit dengan urutan bit yang diinginkan lebih cepat diproses secara manual, terutama karena font yang dibuat secara otomatis seringkali masih harus diselesaikan dengan tangan.  Sesuai dengan di atas, mesin terbang, misalnya, font nomor 2 10x16 akan dikodekan sebagai berikut: <br><br><img src="http://revich.lib.ru/AVR/TableCod2.png" width="400" alt="gambar"><br><br>  Semua ini ditulis dalam bentuk dua dimensi: <br><pre> <code class="hljs markdown">const byte Data2[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">10</span></span>]={{0x06,0x07,0x03,0x03,0x03,0x83,0xc3,0x63,0x3f,0x1e}, {0xf0,0xf8,0xcc,0xc6,0xc3,0xc1,0xc0,0xc0,0xc0,0xc0}};</code> </pre> <br>  Untuk setiap digit 0-9, array seperti itu dibuat: Data0, Data1, Data2, dan sebagainya.  Untuk jam tangan, selain angka, Anda perlu titik ganda lainnya.  Itu bisa dibuat lebih pendek: <br><pre> <code class="hljs markdown">const byte DataDP[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x70,0x70}, {0x1c,0x1c}};// </code> </pre> <br>  Karena pengontrol tidak tahu bagaimana "berkedip" dalam mode grafik, maka secara pemrograman perlu mengedipkan titik dua.  Anda dapat memadamkan titik ganda hanya dengan menampilkan nol di posisi yang sesuai, tetapi untuk keseragaman saya membuat array terpisah <br><pre> <code class="hljs markdown">const byte DataDPclr[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x00,0x00}, {0x00,0x00}};// . </code> </pre> <br>  Untuk menampilkan setiap digit dan secara terpisah untuk titik ganda, fungsi terpisah ditulis: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // “<span class="hljs-number"><span class="hljs-number">2</span></span>” { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} }</code> </pre> <br>  Semua fungsi adalah sama, tetapi menggunakan array yang berbeda, dan untuk titik ganda, batas lain dari loop juga digunakan.  Ternyata tidak terlalu ekonomis dalam hal jumlah kode (lihat lebih lanjut tentang ini nanti), tetapi jelas dan mudah untuk memperbaiki kesalahan.  Kesenjangan antara karakter diperhitungkan pada tahap output, menunjukkan posisi yang sesuai ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan RTClib</a> digunakan untuk membaca jam): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { DateTime clock = RTC.now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()!=old_second) { uint8_t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()%<span class="hljs-number"><span class="hljs-number">2</span></span>) drawDP(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drawDPclr(<span class="hljs-number"><span class="hljs-number">24</span></span>); old_second=clock.second(); }//<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clocksecond }</code> </pre> <br>  Sepuluh digit dari 20 byte masing-masing akan menempati 200 byte dalam memori - sekitar 10% dari volumenya (dan font lebar adalah 16x16, seperti pada contoh di bawah ini, dan semuanya 16%).  Fon satu bahasa penuh dengan ukuran ini, bersama-sama dengan angka, tanpa memperhitungkan segala macam tanda baca dan spesial.  karakter, terdiri dari 62 (Inggris) hingga 74 (Rusia tanpa E) karakter, nilainya akan mengambil hampir setengah dari RAM ATmega328.  Oleh karena itu, trik dengan fungsi array dan output secara terpisah untuk setiap karakter harus dibatalkan, dan lakukan seperti yang diharapkan.  Artinya, font harus dibiarkan dalam memori program dan diunduh melalui PROGMEM, dan semua pola mesin terbang harus disusun sebagai array font tunggal, dan dimuat untuk output dengan nomor simbol dalam satu tabel.  Jika tidak, tidak akan ada cukup memori dan kode program akan mengembang ke volume yang tidak terkendali.  Di sini kita tidak akan membahas hal ini, karena dalam contoh sederhana kita semua ini tidak diperlukan - setiap kali kita akan terbatas pada sejumlah kecil karakter yang sangat diperlukan. <br><br>  Karena teks sketsa GraphicOLED_DC1307 berukuran besar, saya tidak membawanya; Anda dapat mengunduhnya di <a href="">sini</a> .  Fungsi resetOLED disimpan dalam teks, yang mendistorsi daya tampilan ketika controller reboot (melalui pwrPin D2), tetapi tidak pernah diperlukan, sehingga dapat dihapus dengan aman.  Hasil program ditunjukkan pada foto: <br><br><img src="http://revich.lib.ru/AVR/WEH1602_clock.jpg" width="600" alt="gambar"><br><br>  Sayangnya, tetap simultan dalam mode teks dan grafik dikecualikan, oleh karena itu, jika Anda ingin menggunakan ruang yang tersisa, Anda harus menggambar font Anda sendiri (masih ada ruang untuk sekitar 7 karakter font 5x7 di setiap baris). <br><br><h3>  Tampilan grafik WEG010016A </h3><br>  Ketika, akhirnya, tampilan grafik berurutan WEG010016AL tiba, saya mulai dengan mencoba memasukkannya ke mode teks untuk melihat apa yang terjadi. <br><br>  Untuk memeriksa mode teks, sebuah program untuk mensimulasikan tampilan jam-kalender dengan sensor suhu eksternal, dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam publikasi sebelumnya,</a> telah diunduh.  Hasilnya membuat saya ingat bahwa tampilan Winstar yang berbeda dapat diorientasikan secara berbeda sehubungan dengan konektor (dalam hal ini, WEG010016A memiliki konektor di bagian atas, untuk teks WEH001602B, yang kami gunakan di atas, di bawah, dan untuk tipe C di samping): <br><br><img src="http://revich.lib.ru/AVR/WEG10016_test.jpg" width="600" alt="gambar"><br><br>  Kami akan berurusan dengan orientasi tampilan lebih lanjut, tetapi untuk sekarang kita akan melihat apa yang terjadi.  Tapi ternyata tidak ada yang baik: mode teks (tentu saja, dilengkapi dengan kruk, yang dibahas pada awal artikel) bekerja dengan sempurna, tetapi dalam praktiknya tidak masuk akal karena kurangnya ruang antara karakter.  Oleh karena itu, kami tidak akan berlama-lama di sana, tetapi melanjutkan ke pertimbangan mode grafis. <br><br>  Prosedur pemasangan mode grafis itu sendiri sama dengan yang dibahas di atas untuk versi teks.  Tetap berurusan dengan flip layar jika memiliki konektor di bagian atas layar.  Tentu saja, Anda bisa membalikkan layar, tetapi posisi dengan konektor menghadap ke bawah menurut saya lebih alami dan nyaman.  Selain itu, saat menggunakan jenis dengan konektor di samping, Anda mungkin perlu mengarahkan konektor ke kanan daripada ke kiri.  Untuk orientasi "terbalik", perlu untuk mengubah gambar - yaitu, menukar posisi horisontal pertama dan terakhir, garis, dan juga membalik urutan bit dalam byte yang membentuk array (bit paling tidak signifikan akan sesuai dengan titik bawah). <br><br>  Karena saya sudah melukis sepuluh digit untuk kasus sebelumnya, untuk tugas terakhir itu tetap memperkenalkan prosedur pembalikan program: <br><pre> <code class="hljs matlab">byte reverse(byte x) { byte result=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)) { result |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">7</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Anda dapat mengubah urutan koordinat horizontal dan garis vertikal dengan membuat perubahan pada fungsi setGraphicCursor: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">99</span></span>-x)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | (<span class="hljs-number"><span class="hljs-number">1</span></span>-y)); } }</code> </pre> <br>  Fungsi output array setiap digit tetap sama, hanya sedikit pembalikan ditambahkan: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} }</code> </pre> <br>  Sketsa lengkap dari output arloji GraphicOLED_DC1307_100x16 dapat diunduh <a href="">dari sini</a> , dan hasil untuk tampilan WEG010016AL ditampilkan dalam foto: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_clock.jpg" width="600" alt="gambar"><br><br>  Tetapi dalam foto ini font dari tipe yang berbeda (16x16) pada layar WEG010016CG (tampilan juga terbalik): <br><br><img src="http://revich.lib.ru/AVR/WEG10016CG_clock.jpg" width="600" alt="gambar"><br><br>  Jika Anda membuat ulang font dengan mengubah urutan bit secara manual, maka tidak perlu melakukan sebaliknya dan program akan berjalan lebih cepat (walaupun tidak ada keterlambatan yang terlihat di mata).  Tetapi prosedur membalik bit yang diberikan berguna dalam hal apa pun - untuk menampilkan berbagai gambar.  Misalnya, dari satu panah yang menunjuk ke atas dan ke kanan, Anda secara terprogram dapat memperoleh empat arah sekaligus. <br><div class="spoiler">  <b class="spoiler_title">Menggambar panah</b> <div class="spoiler_text">  Gambar dan kode panah (koordinat dan bit dalam tabel terbalik sesuai dengan posisi konektor yang lebih rendah untuk tampilan WEG010016AL, lihat di atas): <br><br><img src="http://revich.lib.ru/AVR/TableCodArray.png" alt="gambar"><br><pre> <code class="hljs markdown">const byte DataATR[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">8</span></span>]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x01,0x02,0x04,0x28,0x30,0x78,0x60,0x80}};</code> </pre> <br>  Fungsi untuk output panah multi arah: <br><pre> <code class="hljs powershell">. . . . . void drawSW (byte x) //   (  ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} } void drawNW (byte x) //   (  ) {//   : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} } void drawNE (byte x) //   (  ) {//  ,    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b);} } void drawSE (byte x) //   (  ) {//   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]);} } . . . . .</code> </pre> </div></div><br>  Foto di bawah ini menunjukkan hasil program kosong untuk menampilkan sensor kecepatan dan arah angin.  Seperti yang Anda lihat, ternyata sangat mudah untuk mengimplementasikan font dengan ukuran berbeda dalam satu baris bersama dengan gambar: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_wind.jpg" width="600" alt="gambar"><br><br>  Sebagai kesimpulan, saya akan menambahkan bahwa ini adalah perpustakaan yang sangat menarik untuk bekerja dengan WS0010 dalam mode grafis dan tekstual menggunakan SPI.  Dalam teks, sebagian besar salinan Liquid Crystal (dan apa lagi yang bisa Anda pikirkan?), Dan dalam grafik itu memiliki fungsi menggambar primitif grafis, font bawaan (tebal, seperti milik saya, dan 5x7 biasa) dan banyak lagi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id402517/">https://habr.com/ru/post/id402517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id402505/index.html">Realitas yang diperbesar mulai diterapkan secara besar-besaran di industri Amerika.</a></li>
<li><a href="../id402507/index.html">Pengelolaan kekayaan pribadi sebagai hak asasi manusia yang mendasar</a></li>
<li><a href="../id402509/index.html">Navigasi Satelit Nonaktifkan Routing</a></li>
<li><a href="../id402511/index.html">Bagaimana kehidupan dilahirkan</a></li>
<li><a href="../id402515/index.html">Braun Oral-B Genius 9000: ketika sikat memberikan tips melalui smartphone</a></li>
<li><a href="../id402521/index.html">WiFi inframerah 17 kali lebih cepat dari biasanya, tetapi satu arah</a></li>
<li><a href="../id402523/index.html">"Dunia kurus." Bab 9</a></li>
<li><a href="../id402525/index.html">Mengapa OneDrive melambat di Linux</a></li>
<li><a href="../id402527/index.html">Empat sampai tiga dua</a></li>
<li><a href="../id402529/index.html">Mengapa lebih baik dengan kaos cardio daripada tanpa itu: beberapa kata tentang pakaian pintar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>