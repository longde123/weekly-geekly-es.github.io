<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏿 🖐🏻 🔡 IPFS ohne Schmerzen (aber das ist nicht genau) 🤱 🍍 🐚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trotz der Tatsache, dass es auf Habré bereits keinen Artikel über IPFS gab . 

 Ich werde sofort klarstellen, dass ich kein Experte auf diesem Gebiet ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IPFS ohne Schmerzen (aber das ist nicht genau)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465599/"><img src="https://habrastorage.org/webt/wi/od/vh/wiodvhs9bp_gm6uff-4kp8ly0ni.jpeg"><br><br>  Trotz der Tatsache, dass es auf Habré bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keinen Artikel über IPFS gab</a> . <br><br>  Ich werde sofort klarstellen, dass ich kein Experte auf diesem Gebiet bin, aber ich habe mehr als einmal Interesse an dieser Technologie gezeigt, aber der Versuch, damit zu spielen, verursachte oft Schmerzen.  Heute habe ich die Experimente wieder aufgenommen und einige Ergebnisse erhalten, die ich gerne teilen möchte.  Kurz gesagt, der Prozess der Installation von IPFS und einigen Chips wird beschrieben (alles wurde auf Ubuntu gemacht, auf anderen Plattformen, die ich nicht ausprobiert habe). <br><a name="habracut"></a><br>  <i>Wenn Sie verpasst haben, was IPFS ist, wird es hier ausführlich beschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/en/post/314768</a></i> <br><br><h2>  Installation </h2><br>  <i>Aus Gründen der Reinheit des Experiments schlage ich vor, es sofort auf einem externen Server zu installieren, da wir einige Fallstricke bei der Arbeit im lokalen Modus und auf Remote-Basis berücksichtigen werden.</i>  <i>Dann, wenn gewünscht, wird es nicht lange abgerissen, es gibt nicht viele.</i> <br><br><h3>  Los geht's </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> <br>  Die aktuelle Version finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golang.org/dl</a> <br><br>  <i>Hinweis: Es ist besser, IPFS im Namen des Benutzers zu installieren, der die häufigsten verwenden soll.</i>  <i>Tatsache ist, dass wir im Folgenden die Option der Montage über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FUSE</a> in Betracht ziehen und es dort Feinheiten gibt.</i> <br><br><pre><code class="plaintext hljs">cd ~ curl -O https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz tar xvf go1.12.9.linux-amd64.tar.gz sudo chown -R root:root ./go sudo mv go /usr/local rm go1.12.9.linux-amd64.tar.gz</code> </pre> <br>  Dann müssen Sie die Umgebung aktualisieren (weitere Details hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golang.org/doc/code.html#GOPATH</a> ). <br><br><pre> <code class="plaintext hljs">echo 'export GOPATH=$HOME/work' &gt;&gt; ~/.bashrc echo 'export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin' &gt;&gt; ~/.bashrc source ~/.bashrc</code> </pre><br>  Überprüfen Sie, ob go installiert ist <br><br><pre> <code class="plaintext hljs">go version</code> </pre> <br><h3>  Installieren Sie IPFS </h3><br>  Die Installation über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipfs-update hat mir am besten</a> gefallen. <br><br>  Installieren Sie es mit dem Befehl <br><br><pre> <code class="plaintext hljs">go get -v -u github.com/ipfs/ipfs-update</code> </pre><br>  Danach können Sie folgende Befehle ausführen: <br><br>  <b>ipfs-update-Versionen</b> - um alle verfügbaren Versionen zum Download <b>anzuzeigen</b> . <br>  <b>ipfs-update version</b> - um die aktuell installierte Version anzuzeigen (bis wir IPFS installiert haben, wird es keine sein). <br>  <b>ipfs-update Neueste installieren</b> - Installieren Sie die neueste Version von IPFS.  Anstelle der neuesten können Sie eine beliebige gewünschte Version aus der Liste der verfügbaren Versionen angeben. <br><br>  Installieren Sie ipfs <br><br><pre> <code class="plaintext hljs">ipfs-update install latest</code> </pre><br>  Überprüfen Sie <br><br><pre> <code class="plaintext hljs">ipfs --version</code> </pre> <br>  Direkt mit der Installation im Allgemeinen alles. <br><br><h2>  IPFS-Start </h2><br><h3>  Initialisierung </h3><br>  Zuerst müssen Sie die Initialisierung durchführen. <br><br><pre> <code class="plaintext hljs">ipfs init</code> </pre> <br>  Als Antwort erhalten Sie ungefähr Folgendes: <br><br><pre> <code class="plaintext hljs"> ipfs init initializing IPFS node at /home/USERNAME/.ipfs generating 2048-bit RSA keypair...done peer identity: QmeCWX1DD7HnXXXXXXXXXXXXXXXXXXXXXXXXxxx to get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre><br>  Sie können den vorgeschlagenen Befehl ausführen <br><br><pre> <code class="plaintext hljs">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Hello and Welcome to IPFS! ██╗██████╗ ███████╗███████╗ ██║██╔══██╗██╔════╝██╔════╝ ██║██████╔╝█████╗ ███████╗ ██║██╔═══╝ ██╔══╝ ╚════██║ ██║██║ ██║ ███████║ ╚═╝╚═╝ ╚═╝ ╚══════╝ If you're seeing this, you have successfully installed IPFS and are now interfacing with the ipfs merkledag! ------------------------------------------------------- | Warning: | | This is alpha software. Use at your own discretion! | | Much is missing or lacking polish. There are bugs. | | Not yet secure. Read the security notes for more. | ------------------------------------------------------- Check out some of the other files in this directory: ./about ./help ./quick-start &lt;-- usage examples ./readme &lt;-- this file ./security-notes</code> </pre><br></div></div><br>  Hier fängt meiner Meinung nach das Interessante schon an.  In der Installationsphase beginnen die Jungs bereits, ihre eigenen Technologien einzusetzen.  Der vorgeschlagene Hash QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv - nicht speziell für Sie generiert, sondern in die Version eingenäht.  Das heißt, vor der Veröffentlichung haben sie einen Begrüßungstext vorbereitet, ihn in IPFS eingefügt und die Adresse dem Installationsprogramm hinzugefügt.  Meiner Meinung nach ist das sehr cool.  Und diese Datei (genauer gesagt der gesamte Ordner) kann jetzt nicht nur lokal, sondern auch auf dem offiziellen Gateway <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipfs.io/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv angezeigt werden</a> .  Gleichzeitig können Sie sicher sein, dass sich der Inhalt des Ordners in keiner Weise geändert hat, denn wenn er sich geändert hätte, hätte sich auch der Hash geändert. <br><br>  <i>Übrigens hat IPFS in diesem Fall einige Ähnlichkeiten mit dem Versionskontrollserver.</i>  <i>Wenn Sie Änderungen an den Quelldateien des Ordners vornehmen und den Ordner erneut in IPFS einfügen, erhält er eine neue Adresse.</i>  <i>Gleichzeitig wird der alte Ordner nicht einfach so irgendwohin gehen und unter seiner früheren Adresse verfügbar sein.</i> <br><br><h3>  Direkter Start </h3><br><pre> <code class="plaintext hljs">ipfs daemon</code> </pre> <br>  Sie sollten eine Antwort wie diese erhalten: <br><br><pre> <code class="plaintext hljs">ipfs daemon Initializing daemon... go-ipfs version: 0.4.22- Repo version: 7 System version: amd64/linux Golang version: go1.12.7 Swarm listening on /ip4/xxxx/tcp/4001 Swarm listening on /ip4/127.0.0.1/tcp/4001 Swarm listening on /ip6/::1/tcp/4001 Swarm listening on /p2p-circuit Swarm announcing /ip4/127.0.0.1/tcp/4001 Swarm announcing /ip6/::1/tcp/4001 API server listening on /ip4/127.0.0.1/tcp/5001 WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080 Daemon is ready</code> </pre><br><h4>  Wir öffnen die Tür zum Internet </h4><br>  Beachten Sie diese beiden Zeilen: <br><br><pre> <code class="plaintext hljs">WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</code> </pre><br>  Wenn Sie IPFS lokal installiert haben, greifen Sie auf IPFS-Schnittstellen unter lokalen Adressen zu und alles steht Ihnen zur Verfügung (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 5001 / webui /).  Bei der Installation auf einem externen Server sind die Gateways jedoch standardmäßig für das Internet geschlossen.  Es gibt zwei Gateways: <br><br><ol><li>  Admin Webui ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> ) auf Port 5001. </li><li>  Externe API an Port 8080 (schreibgeschützt). </li></ol><br>  Bisher können Sie beide Ports für Experimente öffnen (5001 und 8080), aber auf dem Battle Server sollte Port 5001 natürlich mit einer Firewall geschlossen werden.  Es gibt 4001 Ports, die benötigt werden, damit andere Peers Sie finden können.  Es sollte für externe Anfragen offen bleiben. <br><br>  Öffnen Sie ~ / .ipfs / config zum Bearbeiten und suchen Sie die folgenden Zeilen darin: <br><br><pre> <code class="plaintext hljs">"Addresses": { "Swarm": [ "/ip4/0.0.0.0/tcp/4001", "/ip6/::/tcp/4001" ], "Announce": [], "NoAnnounce": [], "API": "/ip4/127.0.0.1/tcp/5001", "Gateway": "/ip4/127.0.0.1/tcp/8080" }</code> </pre> <br>  Ändern Sie 127.0.0.1 in die IP Ihres Servers und speichern Sie die Datei. Starten Sie dann ipfs neu (stoppen Sie den laufenden Befehl Strg + C und führen Sie ihn erneut aus). <br><br>  Muss bekommen <br><br><pre> <code class="plaintext hljs">... WebUI: http://ip__:5001/webui Gateway (readonly) server listening on /ip4/ip__/tcp/8080</code> </pre><br>  Jetzt sollten externe Schnittstellen verfügbar sein. <br><br>  Auschecken <br><br><pre> <code class="plaintext hljs">http://__ip_:8080/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br>  Die obige Readme-Datei sollte geöffnet werden. <br><br><pre> <code class="plaintext hljs">http://__ip_:5001/webui/</code> </pre> <br>  Das Webinterface sollte sich öffnen. <br><br>  <i>Wenn webui für Sie funktioniert, können die IPFS-Einstellungen direkt darin geändert werden, einschließlich der Anzeige von Statistiken. Im Folgenden werden jedoch Konfigurationsoptionen direkt über die Konfigurationsdatei betrachtet, was im Allgemeinen nicht kritisch ist.</i>  <i>Es ist nur besser, sich genau zu merken, wo die Konfiguration liegt und was damit zu tun ist. Wenn die Web-Schnauze nicht funktioniert, wird es schwieriger.</i> <br><br><h3>  Richten Sie eine Weboberfläche für die Arbeit mit Ihrem Server ein </h3><br>  Hier ist die erste Falle, die etwa drei Stunden verbracht wurde. <br><br>  Wenn Sie IPFS auf einem externen Server installiert haben, IPFS jedoch nicht lokal installiert oder gestartet haben, sollte beim Zugriff auf / webui in der Weboberfläche ein Verbindungsfehler angezeigt werden: <br><br><img src="https://habrastorage.org/webt/bp/l7/jj/bpl7jjxzunvmtl9ffvvkiwphmue.png"><br><br>  Tatsache ist, dass Webui meiner Meinung nach sehr vieldeutig funktioniert.  Zunächst versucht er, eine Verbindung zur API des Servers herzustellen, auf dem die Schnittstelle geöffnet ist (natürlich basierend auf der Adresse im Browser).  und wenn es dort nicht funktioniert, versucht es, eine Verbindung zum lokalen Gateway herzustellen.  Und wenn IPFS lokal ausgeführt wird, funktioniert Ihr Webui einwandfrei. Nur Sie arbeiten mit lokalem IPFS, nicht mit externem, obwohl Sie Webui auf einem externen Server geöffnet haben.  Laden Sie dann Dateien hoch, aber aus irgendeinem Grund werden sie auf einem externen Server nicht einfach so angezeigt ... <br><br>  Und wenn es nicht lokal ausgeführt wird, wird ein Verbindungsfehler angezeigt.  In unserem Fall ist der Fehler höchstwahrscheinlich auf CORS zurückzuführen, das auch von webui angezeigt wird und vorschlägt, eine Konfiguration hinzuzufügen. <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["http://ip_ :5001", "http://127.0.0.1:5001", "https://webui.ipfs.io"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST"]'</code> </pre> <br>  Ich habe gerade einen Platzhalter registriert <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'</code> </pre> <br>  Hinzugefügte Header befinden sich alle in derselben ~ / .ipfs / config.  In meinem Fall ist es <br><br><pre> <code class="plaintext hljs"> "API": { "HTTPHeaders": { "Access-Control-Allow-Origin": [ "*" ] } },</code> </pre><br>  Wir starten ipfs neu und stellen fest, dass webui erfolgreich eine Verbindung hergestellt hat (zumindest sollte dies der Fall sein, wenn Sie die Gateways für Anfragen von außen geöffnet haben, wie oben beschrieben). <br><br>  Jetzt können Sie Ordner und Dateien direkt über die Weboberfläche hochladen und eigene Ordner erstellen. <br><br><h3>  Hängen Sie das FUSE-Dateisystem ein </h3><br>  Das ist ein ziemlich interessanter Trick. <br><br>  Wir können Dateien (sowie Ordner) nicht nur über die Weboberfläche, sondern auch direkt im Terminal hinzufügen <br><br><pre> <code class="plaintext hljs">ipfs add test -r added QmfYuz2gegRZNkDUDVLNa5DXzKmxxxxxxxxxx test/test.txt added QmbnzgRVAP4fL814h5mQttyqk1aURxxxxxxxxxxxx test</code> </pre><br>  Der letzte Hash ist der Root-Ordner-Hash. <br><br>  Mit diesem Hash können wir den Ordner auf jedem ipfs-Knoten öffnen (der unseren Knoten finden und den Inhalt abrufen kann), in der Weboberfläche auf Port 5001 oder 8080 oder lokal über ipfs. <br><br><pre> <code class="plaintext hljs">ipfs ls QmbnzgRVAP4fL814h5mQttyqk1aUxxxxxxxxxxxxx QmfYuz2gegRZNkDUDVLNa5DXzKmKVxxxxxxxxxxxxxx 10 test.txt</code> </pre><br>  Sie können es aber trotzdem wie einen normalen Ordner öffnen. <br><br>  Lassen Sie uns zwei Ordner im Stammverzeichnis erstellen und sie unserem Benutzer zuweisen. <br><br><pre> <code class="plaintext hljs">sudo mkdir /ipfs /ipns sudo chown USERNAME /ipfs /ipns</code> </pre><br>  und starten Sie ipfs mit dem Flag --mount neu <br><br><pre> <code class="plaintext hljs">ipfs daemon --mount</code> </pre> <br>  <i>Sie können Ordner an anderen Stellen erstellen und den Pfad zu ihnen über den ipfs-Daemon --mount --mount-ipfs / ipfs_path --mount-ipns / ipns_path angeben</i> <br><br>  Jetzt ist das Lesen aus diesem Ordner etwas ungewöhnlich. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs ls: reading directory '/ipfs': Operation not permitted total 0</code> </pre><br>  Das heißt, es gibt keinen direkten Zugriff auf das Stammverzeichnis dieses Ordners.  Aber dann können Sie den Inhalt erhalten, indem Sie den Hash kennen. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx total 0 -r--r--r-- 1 root root 10 Aug 31 07:03 test.txt</code> </pre><br><pre> <code class="plaintext hljs">cat /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx/test.txt test test</code> </pre><br>  Darüber hinaus funktioniert bei der Angabe eines Pfads auch die automatische Vervollständigung innerhalb des Ordners. <br><br>  Wie oben erwähnt, gibt es bei einem solchen Mount Feinheiten: Standardmäßig sind gemountete FUSE-Ordner nur für den aktuellen Benutzer zugänglich (selbst root kann nicht aus einem solchen Ordner lesen, ganz zu schweigen von anderen Benutzern im System).  Wenn Sie diese Ordner anderen Benutzern zugänglich machen möchten, müssen Sie in der Konfiguration "FuseAllowOther": false in "FuseAllowOther": true ändern.  Das ist aber noch nicht alles.  Wenn Sie IPFS als root ausführen, ist alles in Ordnung.  Und wenn Sie im Auftrag eines regulären Benutzers (wenn auch sudo) eine Fehlermeldung erhalten <br><br><pre> <code class="plaintext hljs">mount helper error: fusermount: option allow_other only allowed if 'user_allow_other' is set in /etc/fuse.conf</code> </pre> <br>  In diesem Fall müssen Sie /etc/fuse.conf reparieren, indem Sie die Zeile #user_allow_other auskommentieren. <br><br>  Danach starten wir ipfs neu. <br><br><h4>  Bekannte Probleme mit FUSE </h4><br>  Mehr als einmal wurde das Problem festgestellt, dass nach dem Neustart von ipfs mit dem Mounten (oder in anderen Fällen) die Mountpunkte / ipfs und / ipns nicht mehr verfügbar sind.  Es gibt keinen Zugriff auf sie, aber ls -la / ipfs zeigt ????  in der Liste der Rechte. <br><br>  Eine solche Lösung gefunden: <br><br><pre> <code class="plaintext hljs">fusermount -z -u /ipfs fusermount -z -u /ipns</code> </pre> <br>  Starten Sie dann ipfs neu. <br><br><h3>  Service hinzufügen </h3><br>  Der Start im Terminal ist natürlich nur für Primärtests geeignet.  Im Kampfmodus sollte der Dämon beim Systemstart automatisch gestartet werden. <br><br>  Erstellen Sie im Auftrag von sudo die Datei /etc/systemd/system/ipfs.service und schreiben Sie darauf: <br><br><pre> <code class="plaintext hljs">[Unit] Description=IPFS Daemon After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/home/USERNAME/work/bin/ipfs daemon --mount User=USERNAME Restart=always [Install] WantedBy=multi-user.target</code> </pre><br>  USERNAME muss natürlich durch Ihren Benutzer ersetzt werden (und möglicherweise unterscheidet sich der vollständige Pfad zum ipfs-Programm für Sie (Sie müssen den vollständigen Pfad angeben)). <br><br>  Wir aktivieren den Service. <br><br><pre> <code class="plaintext hljs">sudo systemctl enable ipfs.service</code> </pre> <br>  Wir starten den Service. <br><br><pre> <code class="plaintext hljs">sudo service ipfs start</code> </pre> <br>  Überprüfen Sie den Status des Dienstes. <br><br><pre> <code class="plaintext hljs">sudo service ipfs status</code> </pre> <br>  Aus Gründen der Reinheit des Experiments kann der Server in Zukunft neu gestartet werden, um zu überprüfen, ob ipfs automatisch erfolgreich gestartet wird. <br><br><h3>  Fügen Sie die Feste hinzu, die wir kennen </h3><br>  Betrachten Sie die Situation, in der IPFS-Knoten sowohl auf einem externen Server als auch lokal installiert sind.  Auf einem externen Server fügen wir eine Art Datei hinzu und versuchen, diese lokal per CID über IPFS abzurufen.  Was wird passieren?  Natürlich weiß der lokale Server höchstwahrscheinlich nichts über unseren externen Server und versucht einfach, die Datei anhand der CID zu finden, indem er alle ihm zur Verfügung stehenden IPFS-Peers "fragt" (mit denen er es bereits geschafft hat, sich "kennenzulernen").  Diese wiederum werden andere fragen.  Und so weiter, bis die Datei gefunden ist.  Das gleiche passiert, wenn wir versuchen, die Datei über das offizielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipfs.io-</a> Gateway <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abzurufen</a> .  Wenn Sie Glück haben, wird die Datei in wenigen Sekunden gefunden.  Wenn nicht, wird es in wenigen Minuten nicht gefunden, was den Arbeitskomfort stark beeinträchtigt.  Wir wissen jedoch, wo diese Datei zuerst angezeigt wird.  Warum sagen wir unserem lokalen Server nicht sofort "Schau zuerst dort"?  Anscheinend kann dies getan werden. <br><br>  1. Gehen Sie zum Remote-Server und suchen Sie in der Konfiguration nach ~ / .ipfs / config <br><br><pre> <code class="plaintext hljs">"Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuxxxxxxxxxxxxxxxx",</code> </pre><br>  2. Wir führen den ipfs-Status des sudo-Dienstes aus und suchen darin nach Swarm-Einträgen, zum Beispiel: <br><br><pre> <code class="plaintext hljs">Swarm announcing /ip4/ip__/tcp/4001</code> </pre> <br>  3. Daraus fügen wir die allgemeine Adresse des Formulars "/ ip4 / ip_your_server / tcp / 4001 / ipfs / $ PeerID" hinzu. <br><br>  4. Aus Gründen der Zuverlässigkeit werden wir über unser lokales Webui versuchen, diese Adresse Peers hinzuzufügen. <br><br><img src="https://habrastorage.org/webt/g5/y2/oh/g5y2ohfylmp2be51tzh0iohq1y8.png"><br><br>  5. Wenn alles in Ordnung ist, öffnen Sie die lokale Konfiguration ~ / .ipfs / config und suchen Sie darin "Bootstrap": [... <br>  und fügen Sie zuerst die empfangene Adresse zum Array hinzu. <br><br>  Starten Sie IPFS neu. <br><br>  Fügen Sie nun die Datei zum externen Server hinzu und versuchen Sie, sie auf dem lokalen Server anzufordern.  Muss schnell fliegen. <br><br>  Diese Funktionalität ist jedoch immer noch instabil.  Soweit ich weiß, ändert ipfs im Laufe der Arbeit die Liste der aktiven Verbindungen mit Peers, auch wenn wir die Peer-Adresse in Bootstrap angeben.  In jedem Fall wird hier eine Diskussion darüber und über die Möglichkeit der Anzeige konstanter Peers geführt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> und es scheint, dass ipfs@5.0+ einige Funktionen hinzufügen soll <br><br>  Eine Liste der aktuellen Peers kann sowohl im Webui als auch im Terminal angezeigt werden. <br><br><pre> <code class="plaintext hljs">ipfs swarm peers</code> </pre> <br>  Sowohl dort als auch dort können Sie Ihr Fest manuell hinzufügen. <br><br><pre> <code class="plaintext hljs">ipfs swarm connect "/ip4/ip__/tcp/4001/ipfs/$PeerID"</code> </pre> <br>  Bis Sie diese Funktionalität verbessert haben, können Sie ein Tool schreiben, um nach einer Verbindung mit dem gewünschten Peer zu suchen und, falls nicht, eine Verbindung hinzuzufügen. <br><br><h2>  Argumentation </h2><br>  Unter denjenigen, die bereits mit IPFS vertraut sind, gibt es sowohl Argumente für als auch gegen IPFS.  Im Prinzip hat mich der Tag vor der gestrigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion dazu</a> veranlasst, IPFS erneut zu graben.  Und in Bezug auf die oben erwähnte Diskussion: Ich kann nicht sagen, dass ich stark gegen einige der oben genannten Argumente bin (ich bin nur nicht einverstanden mit der Tatsache, dass eineinhalb Programmierer IPFS verwenden).  Im Allgemeinen haben beide auf ihre Weise Recht (insbesondere der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar zu Schecks</a> lässt Sie nachdenken).  Aber wenn Sie die moralische und rechtliche Bewertung beiseite lassen, wer wird dann eine technische Bewertung dieser Technologie abgeben?  Persönlich habe ich eine Art inneres Gefühl, dass "dies sicher notwendig ist, es hat bestimmte Perspektiven."  Aber warum genau, es gibt keinen klaren Wortlaut.  Wenn Sie sich beispielsweise die vorhandenen zentralisierten Tools ansehen, sind sie in vielerlei Hinsicht weit voraus (Stabilität, Geschwindigkeit, Verwaltbarkeit usw.).  Trotzdem habe ich einen Gedanken, der sinnvoll erscheint und der ohne solche dezentralen Systeme kaum umgesetzt werden kann.  Natürlich winke ich wirklich, aber ich würde es so formulieren: Das Prinzip der Verbreitung von Informationen im Internet muss geändert werden. <br><br>  Ich werde es erklären.  Wenn Sie so denken, werden unsere Informationen jetzt nach dem Prinzip verbreitet: "Ich hoffe, dass die Person, an die ich sie übertragen habe, sie schützt und sie nicht verloren geht oder an diejenigen geht, für die sie nicht bestimmt waren."  Zum Beispiel ist es einfach, verschiedene Mail-Dienste, Cloud-Speicher usw. in Betracht zu ziehen.  Und was haben wir am Ende?  Auf dem Habré Hub steht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationssicherheit</a> an erster Stelle und fast jeden Tag erhalten wir Nachrichten über ein weiteres globales Leck.  Im Prinzip ist das Interessanteste in dem wunderbaren Artikel &lt;irony&gt; &lt;/ ironony&gt; aufgeführt. Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sommer ist fast vorbei.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es sind fast keine Daten durchgesickert</a> .  Das heißt, die wichtigsten Internetgiganten werden immer größer, sie sammeln immer mehr Informationen und solche Lecks sind eine Art informative atomare Explosionen.  Das ist noch nie passiert und hier wieder.  Obwohl viele verstehen, dass Risiken bestehen, werden sie ihre Daten weiterhin Drittunternehmen anvertrauen.  Erstens gibt es nicht viel Alternative, und zweitens versprechen sie, dass sie alle Löcher geflickt haben und dies nie wieder passieren wird. <br><br>  Welche Option sehe ich?  Es scheint mir, dass Daten zunächst offen verteilt werden sollten.  Offenheit bedeutet in diesem Fall jedoch nicht, dass alles leicht zu lesen sein sollte.  Ich spreche von der Offenheit der Speicherung und Verteilung, aber nicht von der völligen Offenheit beim Lesen.  Ich gehe davon aus, dass Informationen mit öffentlichen Schlüsseln verteilt werden sollten.  Immerhin ist das Prinzip der öffentlichen / privaten Schlüssel schon alt, fast wie im Internet.  Wenn die Informationen nicht vertraulich sind und für einen weiten Bereich ausgelegt sind, werden sie sofort mit dem öffentlichen Schlüssel angelegt (aber immer noch in verschlüsselter Form, nur jeder kann sie mit dem vorhandenen Schlüssel entschlüsseln).  Wenn nicht, wird es ohne öffentlichen Schlüssel angelegt, und der Schlüssel selbst wird an denjenigen übertragen, der Zugriff auf diese Informationen haben muss.  Gleichzeitig sollte derjenige, der es lesen muss, nur einen Schlüssel haben, und wo diese Informationen zu erhalten sind, sollte es nicht in die Höhe schnellen - er zieht sie einfach aus dem Netzwerk (dies ist das neue Prinzip der Verteilung auf den Inhalt und nicht auf die Adresse). <br><br>  Für einen Massenangriff müssen Angreifer daher eine große Anzahl privater Schlüssel erhalten, und es ist unwahrscheinlich, dass sie dies an einem Ort tun können.  Diese Aufgabe ist meines Erachtens schwieriger als das Hacken eines bestimmten Dienstes. <br><br>  Und hier schließt sich ein weiteres Problem: die Bestätigung der Urheberschaft.  Jetzt finden Sie im Internet viele Zitate unserer Freunde.  Aber wo ist die Garantie, dass sie sie geschrieben haben?  Wenn nun jede solche Aufnahme von einer digitalen Signatur begleitet würde, wäre dies viel einfacher.  Und egal wo diese Informationen liegen, die Hauptsache ist die Unterschrift, die offensichtlich schwer zu fälschen ist. <br><br>  Und hier ist das Interessante: IPFS enthält bereits Verschlüsselungstools (schließlich basiert es auf Blockchain-Technologie).  Der private Schlüssel wird sofort in der Konfiguration angegeben. <br><br><pre> <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> + / NDI51jA0MRzpBviM3o / c / Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m + JoEplHjtc4KS5 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> 7LMS7jKpwJNJBiFAa / Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj / Fb + GJMiciJUZaAjgHoaZrrf2b / Eii3z0i + QIVG7OypXT3Z9JUS60 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> Zijgq27oLyxKNr9T7 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> </pre> <br>  Ich bin kein Sicherheitsspezialist und kann nicht genau wissen, wie ich es richtig verwenden soll, aber es scheint mir, dass diese Schlüssel auf der Ebene des Austauschs zwischen IPFS-Knoten verwendet werden.  Und auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">js-ipfs</a> und solche Beispielprojekte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">orbit-db</a> , auf denen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">orbit.chat</a> funktioniert.  Das heißt, theoretisch kann jedes Gerät (mobil und nicht nur) einfach mit seinen eigenen Verschlüsselungs- / Entschlüsselungsmaschinen ausgestattet werden.  In diesem Fall muss sich nur jeder um die Pflege seiner privaten Schlüssel kümmern, und jeder ist für seine eigene Sicherheit verantwortlich und nicht als Geisel eines anderen menschlichen Faktors in einem sehr beliebten Internetgiganten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465599/">https://habr.com/ru/post/de465599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465587/index.html">Analyse: Was ist der OTC-Markt und welche Transaktionen werden dort durchgeführt?</a></li>
<li><a href="../de465589/index.html">Pilot- und PoC-Kurzanleitung</a></li>
<li><a href="../de465591/index.html">Die PHP Central Europe-Konferenz wurde abgesagt, da keine Frauen unter den Rednern waren</a></li>
<li><a href="../de465595/index.html">5G kommt zu uns?</a></li>
<li><a href="../de465597/index.html">STM8S Slow Start lernen. Teil 0</a></li>
<li><a href="../de465601/index.html">Warum brauchen Sie DevOps und wer sind DevOps-Spezialisten?</a></li>
<li><a href="../de465603/index.html">Kurse gegen Praktikum. Wie unterrichten wir Midbells bei SimbirSoft?</a></li>
<li><a href="../de465605/index.html">Das Buch „Deep Reinforcement Learning in Python. OpenAI Gym und TensorFlow für Profis »</a></li>
<li><a href="../de465607/index.html">Lean und Agile in der Softwareentwicklung verstehen</a></li>
<li><a href="../de465609/index.html">Warum 1C-Bitrix ab dem 1. Dezember 2019 zu einem Kürbis werden kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>