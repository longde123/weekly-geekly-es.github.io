<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👧 🙆🏾 🌪️ 为我的游戏生成地牢和洞穴 🎎 📔 😭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本周，我开始研究一个新主题：地下城和洞穴的产生。 我使用空间分区来生成房间，使用迷宫生成算法来生成走廊，并使用元胞自动机使洞穴看起来更自然。 

 空间分割 
 有很多方法可以生成地牢室（ 随机放置 ， 基于代理的生成 ，使用分离转向行为或物理引擎等）。 但是我最喜欢的方法是分割空间，因为它易于控制...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为我的游戏生成地牢和洞穴</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461087/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f40/e6c/e0bf40e6c33ed78da13006970a027378.gif" width="400"></div><br> 本周，我开始研究一个新主题：地下城和洞穴的产生。 我使用空间分区来生成房间，使用迷宫生成算法来生成走廊，并使用元胞自动机使洞穴看起来更自然。 <br><br><h1> 空间分割 </h1><br> 有很多方法可以生成地牢室（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随机放置</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于代理的生成</a> ，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分离转向行为</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">物理引擎</a>等）。 但是我最喜欢的方法是分割空间，因为它易于控制和扩展。 <br><br> 还有很多划分空间的方式：划分为网格，空间的二进制划分，用象限树划分空间，Voronoi图等。 我决定使用空间的二进制分区，因为它非常适合生成矩形房间。 由于在RogueBasin上发表了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a> ，此方法已广受欢迎。 <br><br> 该算法的唯一复杂性是分离位置的选择。 如果我们不对分隔位置施加限制，则会得到奇怪的空间分区： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/f0a/38c/699f0a38c5800499dad98b63e811ace3.gif" width="400"></div><br> 有几种方法可以避免这种现象。 其中之一是将分离位置限制为两个纵横比，例如在30％至70％或40％至60％的范围内。 另一种方法是使用正态分布或二项式分布而不是均匀分布，从而增加了在边的中心而不是在边缘处分离的可能性。 这些方法解决了这个问题，但是很难理解参数如何精确地影响最终结果。 <br><a name="habracut"></a><br> 因此，我使用了另一种方法，其优点是它具有一个参数并且易于理解：单元格的长度和宽度之间的最大允许比率。 在对新分离进行采样时，我首先计算它可以具有的最小值和最大值，以使两个新像元的比率小于限制，然后在这两个边界之间进行均匀采样。 这是更改最大允许比率时的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cff/6c0/eed/cff6c0eed66a7b26ddad9f3506fc0874.gif" width="400"></div><br> 以2.0至3.0的最大比率可获得良好的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/a66/805/531a66805a7c2e60db79e8eec25badd9.gif" width="400"></div><br><h1> 房间生成 </h1><br> 下一阶段是房间中每个单元的生成。 这里没有特别的问题，我只是设置了限制，以使房间不会太小且离牢房壁也不太近。 <br><br> 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/609/782/4e960978275052a4669fda6e7e531ea6.gif" width="400"></div><br><h1> 排骨选择 </h1><br> 在二元分割地牢生成器中，分割步骤中使用的二叉树通常会重新用于生成通道。 我没有这样做，因为这种方法似乎限制了我。 <br><br> 取而代之的是，在划分空间的阶段，我建立了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个双边连接的列表结构</a> ，这使我们能够知道哪些单元格彼此相邻。 这样，我得到以下图形： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe1/a31/828/fe1a31828c8ee1abb2a6bb5921d65e07.gif" width="400"></div><br> 这种方法有三个优点。 首先：如果将来我想改变空间的划分方式，则生成器的其余部分将保持有效，因为它在输入端仅接收半边缘数据结构。 第二：现在选择要成为走廊的边缘，我可以使用任何<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法生成迷宫</a> 。 第三：如果我想向地牢中添加循环，则可以轻松实现。 <br><br> 现在，我仅使用Kruskal算法和城市街区的距离来选择边。 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/927/6a4/0959276a4b2a8e10f5a95d7c3c7417f2.gif" width="400"></div><br><h1> 走廊生成 </h1><br> 下一步是从选定的边缘生成道路。 这可能是生成器中最棘手的部分，因为我需要小心，以免走廊与另一个走廊相交。 <br><br> 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/ac8/5cb/240ac85cb6edcf3a4cd91129b0c22c36.gif" width="400"></div><br><h1> 洞穴产生 </h1><br> 先前的结果适合创建地牢，地穴和其他人造结构，但我想给洞穴和矿山一个更自然的外观。 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a> RogueBasin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>所述，生成洞穴的经典方法是使用元胞自动机。 细胞自动机的最大问题是其结果未得到完全控制。 <br><br> 无论如何，我决定使用元胞自动机来创建自然外观，但对它们施加限制以得到可控制的结果。 我不仅使用两种状态：已死和还活着，还使用四种：绝对已死，已死，还活着，肯定还活着。  “完全准确”的状态不能在过程中更改；它们用于限制结果。 <br><br> 前面步骤中生成的房间和走廊中充满了“确实存在”的单元格。 也就是说，我们仍然有支持室，我们保证它们将相互连接。 尚未选择的边缘填充有“完全死”单元，因此在房间之间不会出现新路径。 最后，在房间和走廊周围，我们随机地使一些细胞存活。 这是初始配置： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/014/95f/b66/01495fb6695a82de2a9164864b27f08f.png" width="400"></div><br> 然后我们启动元胞自动机： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/408/05e/9e840805e01204122e2eb0252bded4f7.gif" width="400"></div><br><br> 以下是一些示例结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/bd6/c9d/3aabd6c9daa127050f84687ef1731e95.gif" width="400"></div><br> 稍后，我将添加填充以删除不可达的部分。 <br><br> 这是创建有趣的地牢生成器的漫长旅程的第一步。 我对结果感到满意。 对于创建受控的自然洞穴的受限细胞自动机方法，我尤其感到自豪。 我也喜欢这样一个事实，每个生成阶段都是彼此独立的，可以单独修改。 <br><br><h1> 删除隔离的单元格 </h1><br> 然后，我实现了填充以删除无法访问的单元格： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/4bb/f55/7c34bbf55808cd689bc3b7456ea8e2d7.gif" width="400"></div><br><h1> 房间之间有多个走廊 </h1><br> 通过试验发电机的参数，我发现，如果在连通室之间添加一点噪音，就会得到有趣的结果。 <br><br> 这是在向连接房间施加噪音之前和之后参数仅以一个单位改变之后的结果差异： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/f26/263/f7bf2626343bcee26f2afc42e037d314.png" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a6/1de/10c/7a61de10c6b53dab00ede8554a4d78de.png" width="400"></div><br> 如果将房间扩大一点，结果将变得更加有趣： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/7a8/486/ebc7a8486cbfd1251ac03f87c4cf079b.png" width="400"></div><br> 发生事故真是太好了，并且出现了漂亮的结构，但是同时，图形的结构和房间的名称也得以保留，这将非常有用： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/818/658/0ed/8186580ed4aca49f61e2841c7afe043e.png" width="400"></div><br><h1> 洞穴的瓷砖生成 </h1><br> 我大部分时间都花在瓷砖上。 这不是很困难，但是对于正确的实现它需要一些技巧。 <br><br> 以下是示例结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/d48/470/7bcd484707cb39ee084496297c9856b4.gif" width="400"></div><br> 很棒的是，您可以轻松地从石洞切换为沙子或冰块： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/e53/825/12be53825f1d1c3d9156a98265bd7600.gif" width="400"></div><br> 生成地牢的下一步将是添加风景和怪物。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461087/">https://habr.com/ru/post/zh-CN461087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461077/index.html">渗透测试者如何烹饪？ 数字安全实习生的入学测试</a></li>
<li><a href="../zh-CN461079/index.html">没有交通拥堵的城市</a></li>
<li><a href="../zh-CN461081/index.html">渡渡鸟停泊的那一天。 异步脚本</a></li>
<li><a href="../zh-CN461083/index.html">编写具有客户端服务器实用程序Windows功能的软件，第02部分</a></li>
<li><a href="../zh-CN461085/index.html">在Android应用中切换语言</a></li>
<li><a href="../zh-CN461091/index.html">LED天花灯</a></li>
<li><a href="../zh-CN461093/index.html">OpenStreetMap第469号世界新闻（07/09/2019-07/07/2019）</a></li>
<li><a href="../zh-CN461095/index.html">Apollo指导计算机-体系结构和系统软件。 第一部分</a></li>
<li><a href="../zh-CN461099/index.html">游戏空中攻击！ -我们的第一个VR开发经验</a></li>
<li><a href="../zh-CN461101/index.html">Android Jetpack构成第一印象</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>