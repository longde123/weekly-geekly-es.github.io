<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ ‚è≤Ô∏è ‚ôêÔ∏è "Hallo Checkmarx!" Wie schreibe ich eine Anfrage f√ºr Checkmarx SAST und finde coole Schwachstellen üèûÔ∏è ‚úçüèª üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 In dem Artikel m√∂chte ich √ºber unsere Erfahrungen bei der Erstellung meiner Abfragen in Checkmarx SAST sprechen. 

 Wenn Sie sich zum er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Hallo Checkmarx!" Wie schreibe ich eine Anfrage f√ºr Checkmarx SAST und finde coole Schwachstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Hallo habr <br><br>  In dem Artikel m√∂chte ich √ºber unsere Erfahrungen bei der Erstellung meiner Abfragen in Checkmarx SAST sprechen. <br><br>  Wenn Sie sich zum ersten Mal mit diesem Analyseger√§t vertraut machen, haben Sie m√∂glicherweise den Eindruck, dass es nicht nur nach schwachen Verschl√ºsselungs- / Hashing-Algorithmen und einer Menge falsch positiver Ergebnisse sucht, sondern auch nichts anderes zur√ºckgibt.  Aber wenn es richtig konfiguriert ist, ist es ein sehr leistungsf√§higes Tool, das nach schweren Fehlern suchen kann. <br><br>  Wir werden die Feinheiten der Checkmarx SAST-Abfragesprache verstehen und 2 Abfragen schreiben, um nach SQL-Injections und Insecure Direct Object References zu suchen. <br><a name="habracut"></a><br><br><h2>  Eintrag </h2><br>  Nach langem Suchen nach Anleitungen oder Artikeln zu Checkmarx wurde mir klar, dass es neben der offiziellen Dokumentation nicht gen√ºgend n√ºtzliche Informationen gab.  Und die offizielle Dokumentation besagt nicht, dass alles sehr klar und verst√§ndlich wird.  Zum Beispiel konnte ich keine Best Practices finden, wie man √úberschreibungsabfragen richtig organisiert, wie man Abfragen "f√ºr Dummies" schreibt usw. Ja, es gibt eine Dokumentation zu den CMx Query Language-Funktionen, aber hier ist, wie man diese Funktionen in einer einzigen Abfrage kombiniert. Die Dokumentation ist nicht geschrieben. <br><br>  Vielleicht ist das Fehlen von Artikeln und Anleitungen aus der Checkmarx-Community mit den hohen Kosten des Tools und demzufolge einem kleinen Publikum verbunden.  Oder vielleicht k√ºmmern sich nur wenige Leute um die Feinabstimmung und verwenden die L√∂sung wie sie ist. <br><br>  Meiner Erfahrung nach wird SAST eher zur Erf√ºllung von Formalit√§ten im Zusammenhang mit verschiedenen Kundenanforderungen verwendet, als zur Suche nach echten Fehlern.  Infolgedessen haben wir bestenfalls eine relativ kleine Anzahl von ‚ÄûSchwachstellen‚Äú, die fast automatisch als ‚Äûnicht ausnutzbar‚Äú bezeichnet werden (da dies in 99,9% der F√§lle der Fall ist). <br><br>  Es sollte beachtet werden, dass Checkmarx selbst versucht, ihre Abfragen zu aktualisieren, damit sie sofort das beste Ergebnis liefern.  CMx Query Language-Abfragen sind jedoch auf den ‚Äûallgemeinen Fall‚Äú zugeschnitten.  Die anf√§ngliche Suche nach Tokens basiert auf dem Namen.  CMx SAST geht beispielsweise davon aus, dass alle Abfragen an die Datenbank folgenderma√üen aussehen: * createQuery * oder * createSQLQuery *.  Wenn jedoch die interne Entwicklung f√ºr die Arbeit mit der Datenbank verwendet wird und die Methode zum Abfragen der Datenbank anders aufgerufen wird, z. B. * driveMyQuery *, werden alle SQL-Methoden √ºbersprungen.  Beispielsweise verwendet unser Kunde benutzerdefiniertes ORM f√ºr SQL DB.  In diesem Fall haben CMx-Abfragen alle SQL-Injections √ºbersprungen. <br><br><h4>  Abk√ºrzungen und Definitionen </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - Checkmarx SAST-Abfragesprache <br>  <b>Token</b> - Ein String mit einem bestimmten Wert ist das Ergebnis der Arbeit des lexikalischen Analysators (auch Tokenisierung genannt). <br><br><h3>  Anwendung testen </h3><br>  Um einen Artikel zu schreiben, skizzierte ich Java-Code, eine kleine Testanwendung.  Dieser Code ist eine ungef√§hre Kopie eines kleinen Teils des realen Systems.  Obwohl sich der Code der Testanwendung im Allgemeinen von keinem anderen HTTP-Backend-Code stark unterscheidet.  Wichtige Abschnitte des Testanwendungscodes werden in den Screenshots angezeigt. <br><br><h4>  Die Testanwendung hat folgenden Aufbau </h4><br>  <i>WebRouter-</i> Klasse zur Verarbeitung eingehender HTTP-Anfragen, 4 Methoden zur Verarbeitung von URLs: <br><ul><li>  <i>/ getTransaction</i> - akzeptiert die Transaktions- <i>ID</i> bei der Eingabe <i>und gibt die Informationen</i> dazu zur√ºck, nimmt sie als Zeichenfolge und √ºbergibt sie an <i>getTransactionInfo (transactionId)</i> =&gt; <i>getTransactionInfo (transactoinId</i> ). </li><li>  <i>/ getSecureTransaction</i> - akzeptiert die Transaktions- <i>ID</i> als Eingabe <i>und gibt die Informationen</i> dazu zur√ºck. <i>id</i> nimmt sie als Zeichenfolge und √ºbergibt sie Fall, dass die Injektion nicht ausgenutzt wird); </li><li>  <i>/ getSettings</i> - akzeptiert die <i>Benutzer-</i> <i>ID</i> und die Postfach- <i>ID als Eingabe</i> - und gibt die Postfacheinstellungen aus.  √úberpr√ºft nicht, ob die <i>Mailbox-ID</i> dem Benutzer geh√∂rt. </li><li>  <i>/ getSecureSettings</i> - akzeptiert auch die <i>Benutzer-</i> <i>ID</i> und die Postfach- <i>ID f√ºr die Eingabe</i> und zeigt die Postfacheinstellungen an.  ABER pr√ºft, ob die <i>Mailbox-ID</i> dem Benutzer geh√∂rt. </li></ul><br><br><h2>  CMx: Allgemeine Informationen und grundlegende Definitionen </h2><br><h3>  Bevor Sie mit der Entwicklung von Abfragen beginnen </h3><br>  Die Entwicklung von Abfragen erfolgt in einem separaten Programm CxAuditor.  In CxAuditor m√ºssen Sie den gesamten Code scannen (lokales Projekt erstellen), f√ºr das wir Abfragen schreiben.  Danach k√∂nnen Sie neue Abfragen schreiben und ausf√ºhren.  Bei einer gro√üen Codebasis kann das prim√§re Scannen Stunden dauern und Gigabyte an Speicher beanspruchen.  Danach wird jede Anfrage nicht schnell genug ausgef√ºhrt.  Dies ist f√ºr die Entwicklung v√∂llig ungeeignet. <br><br>  Aus diesem Grund k√∂nnen Sie eine kleine Menge von Dateien aus dem Projekt entnehmen, idealerweise mit einem Fehler, der im Code vor dem Typ gefunden wurde, unter dem die Anforderung geschrieben wird (oder den Fehler manuell dort abgelegt), und nur diese Dateien durchsuchen.  Es ist nicht erforderlich, die Dateistruktur des Projekts einzuhalten.  Das hei√üt, wenn Sie √ºber Java-Paket A und B verf√ºgen und die Klassen in Paket B die Klassen und Methoden von Paket A verwenden, k√∂nnen Sie all dies in ein einziges Verzeichnis packen, und CMx wird die Beziehungen und Aufrufketten zwischen Dateien immer noch richtig (gut oder fast) verstehen immer korrekt, obwohl Fehler kaum mit der Dateistruktur des Projekts zusammenh√§ngen). <br><br><h3>  Grundlegende Definitionen </h3><br><h4>  Cxlist </h4><br>  Der Hauptdatentyp in CMx.  Das Ergebnis fast aller CMxQL-Funktionen ist <i>CxList</i> .  Dies sind viele Elemente mit bestimmten Eigenschaften.  Die Eigenschaften, die f√ºr die Entwicklung am n√ºtzlichsten sind, werden unten betrachtet. <br><br><h4>  Ergebnis </h4><br>  CMxQL hat ein eingebautes variables <i>Ergebnis</i> .  Die Menge, die die <i>Ergebnisvariable</i> enth√§lt, wird nach Ausf√ºhrung der gesamten Abfrage als Ergebnis angezeigt. <br><br>  Das hei√üt, die letzte Operation einer Abfrage sollte das Zeichenfolgenergebnis <i>= WHATEVER sein</i> , zum Beispiel: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  Flow- und Code-Element </h4><br>  Die meisten CMxQL-Funktionen werden nach dem Typ der zur√ºckgegebenen Werte in zwei Funktionen unterteilt, die "Codeelemente" zur√ºckgeben und die Flow zur√ºckgeben.  In beiden F√§llen ist das Ergebnis eine <i>CxList</i> .  Der Inhalt unterscheidet sich jedoch geringf√ºgig f√ºr Flow- und Code-Elemente. <br><ul><li>  <b>Codeelement</b> - Token - zum Beispiel eine Variable, ein Methodenaufruf, eine Zuweisung usw .; </li><li>  <b>Flow</b> - die Beziehung zwischen den gegebenen Token. </li></ul><br><br><h4>  Alle und "Unter" Alle </h4><br>  Jede CMxQL-Funktion kann entweder f√ºr die Gruppe " <i>Alle"</i> (sie enth√§lt alle Token des gesamten gescannten Codes, wir haben bereits ein Beispiel mit <i>Ergebnis gesehen</i> ) oder f√ºr die <i>Gruppe "CxList" ausgef√ºhrt werden</i> , die wiederum als Ergebnis einiger Operationen in der Abfrage abgerufen wurde, beispielsweise der Abfrage: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  erstellt eine leere Menge, die wir dann mit der <i>Add ()</i> -Methode mit Elementen f√ºllen und dann bereits nach den Elementen der neuen Menge suchen k√∂nnen: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Eigenschaften der gefundenen Gegenst√§nde </h4><br>  Jedes Element der CxList-Gruppe verf√ºgt √ºber mehrere Eigenschaften.  Bei der Analyse der Ergebnisse zum Schreiben von Abfragen sind die folgenden am n√ºtzlichsten: <br><br><ul><li>  <b>SourceFile</b> - der Name der Datei, die dieses Element enth√§lt; </li><li>  <b>Source Line</b> - Zeilennummer mit Token; </li><li>  <b>Quellenname</b> - Der Name des Tokens.  Entspricht dem Token, d. H. Wenn die Variable var1 hei√üt, ist der Quellenname = var1; </li><li>  <b>Quelltyp</b> - Der Typ des Tokens.  Wenn es sich beispielsweise um eine Zeichenfolge handelt, ist dies StringLiteral, wenn die Methode aufgerufen wird, MethodInvokeExpr und viele andere. </li><li>  <b>Zieldatei</b> </li><li>  <b>Ziellinie;</b> </li><li>  <b>Zielname;</b> </li><li>  <b>Zieltyp.</b> </li></ul><br><br>  Quelle und Ziel unterscheiden sich, wenn die Elemente der Ergebnismenge Flow sind, und umgekehrt, wenn das Ergebnis Codeelemente sind. <br><br><h2>  Erstellen Sie Abfragen </h2><br>  Alle CMxQL-Funktionen k√∂nnen in verschiedene Typen unterteilt werden.  Hier kann man meiner Meinung nach den Hauptnachteil der CMxQL-Dokumentation bemerken, alle Funktionen im Dock werden einfach in alphabetischer Reihenfolge beschrieben, w√§hrend es viel bequemer w√§re, sie nach der Funktionalit√§t und nur dann alphabetisch zu strukturieren. <br><br><ul><li>  Suchfunktionen - fast alle CMxQL-Funktionen mit den Namen <b>FindBy *</b> und <b>GetBy *</b> ; </li><li>  Die Funktionen von Operationen auf Mengen sind Addition, Subtraktion, Schnittmenge, Iteration √ºber Elemente usw. </li><li>  Analysefunktionen - Dies sind im Grunde <b>* InfluencedBy *</b> <b>* InfluencingOn *</b> -Funktionen. </li></ul><br><br>  Das Grundprinzip von Abfragen ist die Abwechslung dieser Arten von Funktionen.  Zun√§chst w√§hlen wir mithilfe der Suchfunktionen nur die Token aus, die uns aufgrund bestimmter Eigenschaften interessieren.  Mit Operationen auf Mengen k√∂nnen wir verschiedene Mengen mit verschiedenen Token-Eigenschaften zu einer kombinieren oder umgekehrt die andere von einer subtrahieren.  Anschlie√üend erstellen wir mithilfe der Analysefunktionen den Code Flow und versuchen zu verstehen, ob die potenziellen Schwachstellen von den Parametern an den Einstiegspunkten abh√§ngen. <br><br>  Die Wahl des Ortes, von dem aus die Suche gestartet werden soll, und im Allgemeinen der gesamte Suchpfad, h√§ngt vom spezifischen Code ab, genauer gesagt sogar vom ‚ÄûText‚Äú.  In einigen F√§llen ist es bequem, vom Einstiegspunkt aus nach Benutzerabfragen zu suchen, in einigen F√§llen ist es bequemer, vom ‚ÄûEnde‚Äú oder sogar von der Mitte aus zu beginnen.  Es h√§ngt alles vom spezifischen Code ab und Sie m√ºssen jedes Repository einzeln ansprechen. <br><br><h2>  Beispiel: SQL-Injection durchsuchen </h2><br>  Suchplan, in Klammern habe ich den Namen der Mengen angegeben (Variablen in der Abfrage): <br><br><ol><li>  Ausnahmen definieren - Token, die sofort aus dem Suchbereich entfernt werden k√∂nnen ( <i>exclusionList</i> ); </li><li>  Bestimmen Sie den Ort der Desinfektion / Sicherheitskontrollen ( <i>Desinfektion</i> ); </li><li>  Finde alle Low-Level-Stellen mit Abfrageausf√ºhrung in der Datenbank ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Finde alle Parameter der aufgerufenen Methoden <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Suchen von Einstiegspunkten (√ºbergeordnete Methoden und deren Parameter) f√ºr die Orte der Abfrageausf√ºhrung in der Datenbank ( <i>entryPointsParameters</i> ); </li><li>  <i>Ermitteln</i> Sie die Abh√§ngigkeiten von <i>runSSSQParams-</i> Parametern von <i>entryPoints</i> , w√§hrend nur die Stellen <i>angezeigt werden</i> , an denen keine <i>Bereinigung der</i> Eingabebereinigung <i>erfolgt</i> . </li></ol><br><br>  Als Ergebnis erhalten wir Low-Level-Methoden mit SQL-Abfragen, bei denen die Parameter der SQL-Abfrage: <br><br><ul><li>  h√§ngen von den Parametern der Methode ab; </li><li>  Parameter werden als Zeichenfolgen akzeptiert. </li><li>  Parameter werden mit der Anforderung verkn√ºpft. </li></ul><br>  Wir werden nicht pr√ºfen, ob wir diese Parameter kontrollieren k√∂nnen  Wir glauben, dass es einen Mechanismus zum Zuordnen von Variablen zu einer Abfrage gibt und dass Zahlen in einen numerischen Typ umgewandelt werden. Die Verkettung von Zeichenfolgen wird immer als gef√§hrlich angesehen.  Auch wenn die Leitung derzeit nicht kontrolliert wird, wird sie m√∂glicherweise in der neuen Version angezeigt. <br><br><h3>  SQLi: Schritt 1. Ausnahmen definieren </h3><br>  In Ausnahmef√§llen m√ºssen Sie die Klassen oder Dateien hinzuf√ºgen, deren Tokennamen mit den gesuchten √ºbereinstimmen k√∂nnen, weil  Diese Token f√ºhren zu ung√ºltigen Eintr√§gen. <br><br>  Eine Methode f√ºr den Zugriff auf eine Datenbank hei√üt beispielsweise <i>runSuperSecureSQLquery</i> .  Wir gehen davon aus, dass die <i>darin enthaltene</i> Methode <i>runSuperSecureSQLquery</i> sicher implementiert ist.  Und unsere Aufgabe ist es, Orte zu finden, an denen es nicht sicher ist, die Methode selbst anzuwenden.  Bei der SQL-Injection sind Orte der Verkettung von benutzergesteuerten Parametern keine sicheren Orte.  Und sichere Orte f√ºr die Zuordnung von Parametern in die ORM-Struktur oder zum Beispiel f√ºr numerische Parameter, dies ist eine Umwandlung in den entsprechenden Typ.  Wir m√ºssen nicht den gesamten Code scannen, der "tiefer" liegt als <i>runSuperSecureSQLquery</i> . Das hei√üt, es ist besser, ihn auszuschlie√üen, um unn√∂tige Fundstellen zu vermeiden. <br><br>  Um nach solchen Ausnahmen zu suchen, ist es zweckm√§√üig, die CMxQL-Funktionen zu verwenden: <br><ul><li>  <b>FindByFileName ()</b> - <b>Findet</b> die Menge aller Token in einer bestimmten Datei. </li><li>  <b>GetByClass ()</b> - <b>Findet</b> die Menge aller Token in der Klasse mit dem angegebenen Namen. </li></ul><br><br>  Bei einer <i>Testanwendung</i> ist dies die <i>Session-</i> Klasse, die die Implementierung der <i>runSuperSecureSQLquery-</i> Methode enth√§lt. <br>  Ein Beispiel f√ºr eine Anforderung zum Ausschlie√üen von Code in der <i>Session-</i> Klasse (die <i>GetByClass ()</i> -Methode √ºberpr√ºft, welche der an die Eingabe √ºbergebenen Token einen CMx-Typ von <i>ClassDecl aufweisen</i> und viele Token dieser Klasse ausgeben). <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  Eine andere M√∂glichkeit besteht darin, Code in die gesamte <i>Session.java-</i> Datei zu werfen: <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  Das Sternchen vor dem Namen ist wichtig, da der Dateiname den gesamten Pfad enth√§lt. <br>  Jetzt haben wir viele Token, die in den n√§chsten Schritten vom Suchbereich abgezogen werden k√∂nnen. <br><br>  Das Ergebnis der Suche nach Tokens in der <i>Session-</i> Klasse: <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: Schritt 2. Bestimmen der Desinfektionsorte </h3><br>  Die Testanwendung enth√§lt 2 API-Methoden (siehe kurze Beschreibung der Testanwendung).  Der Unterschied zwischen den beiden API-Methoden besteht darin, dass <i>getTransactionInfo ()</i> den transactionId-Parameter in der SQL-Abfrage verkettet und <i>getTransactionInfoSecured ()</i> zuerst transactionId in Long <i>konvertiert</i> und dann als Zeichenfolge √ºbergibt.  Sicherheitsl√ºcke (Parameterverkettung) ist in beide Methoden eingebettet.  Dank dem Casting auf Long in <i>getTransactionInfoSecured ()</i> ist die letzte Methode jedoch nicht anf√§llig f√ºr Injection, da beim Versuch, eine Injection (String) zu √ºbergeben, eine Java-Ausnahme auftritt. <br><br>  In diesem Beispiel betrachten wir die Besetzung von Long als Sanit√§rstandort.  So finden Sie diese Token: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Beispielergebnis: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  Das Ergebnis enthielt Token mit den YP-Methoden <i>Long</i> und <i>getValueAsLong</i> , die <i>den</i> Wert intern <i>in den</i> Typ <i>Long</i> <i>konvertieren</i> .  Sie m√ºssen das Ergebnis sorgf√§ltig pr√ºfen, um sicherzustellen, dass keine zus√§tzlichen Informationen vorhanden sind. <br><br><h3>  SQLi: Schritt 3. Finden Sie alle Low-Level-Stellen mit Abfrageausf√ºhrung in der Datenbank </h3><br>  Die folgende Abfrage findet alle Orte mit dem runSuperSecureSQLQuery-Token (mit dem auf die Datenbank zugegriffen wird): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  Suchergebnis nach Tokenname runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  Au√üerdem werden f√ºr Stellen, an denen diese Methode aufgerufen wird ( <i>Abrechnungsklasse</i> ), nur Methodenaufruftoken (Typ <i>MethodInvokeExpr</i> ) und f√ºr die Methodendeklarationsstelle ( <i>Sitzungsklasse</i> ) auch alle Token - Variablen gefunden. <br><br>  Wir filtern nur die Methodenaufruftoken heraus: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  Ergebnis: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  Als Ergebnis erhielten wir 7 Stellen, davon 4 die erforderlichen Aufrufe der <i>runSuperSecureSQLQuery ()</i> -Methode ( <i>Billing-</i> und <i>User-</i> Klassen).  2 - ruft die interne Methode runSuperSecureSQLQuery () in der <i>Session-</i> Klasse auf, und eine weitere Methode ist die <i>add-</i> Methode, bei der es sich eher um eine CMxQL-Suche handelt.  Sagen wir einfach, dass ich nicht damit gerechnet habe, dass es in der Liste enthalten ist =) Die Token in der <i>Session-</i> Klasse, wie wir in Schritt 1 herausgefunden haben, sind f√ºr uns nicht interessant, deshalb werden wir sie einfach vom Ergebnis abziehen: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Wir erhalten eine g√ºltige Liste der Aufrufe der gew√ºnschten Methode: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Beachten Sie die Funktionen <i>FindByType ()</i> und <i>typeof ()</i> in der vorherigen Abfrage.  Wenn wir nach CMx-Typ suchen m√∂chten, dh nach der <i>CxList-</i> Eigenschaft ‚ÄûSource Type‚Äú - dann verwenden wir <i>typeof (Source Type)</i> .  Wenn wir eine Suche nach Datentyp durchf√ºhren m√∂chten, m√ºssen wir den Parameter nur als Zeichenfolge √ºbergeben.  Zum Beispiel: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  findet alle Java-Token mit dem Typ String. <br><br><h3>  SQLi: Schritt 4. Suchen Sie alle Parameter der runSuperSecureSQLQuery-Methode </h3><br>  Zur Suche nach Methodenparametern wird die CMxQL-Funktion <i>GetParameters () verwendet</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: Schritt 5. Suchen Sie Einstiegspunkte f√ºr Abfrageausf√ºhrungsorte in der Datenbank </h3><br>  Dazu erhalten wir zuerst die Namen der √ºbergeordneten Methoden, in denen sich die Aufrufe der <i>runSuperSecureSQLQuery-</i> Datenbank befinden, und dann deren Parameter.  Um nach √ºbergeordneten Token zu suchen, wird die CMxQL-Funktion <i>GetAncOfType () verwendet</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  Geben Sie in dieser Abfrage f√ºr die Gruppe runSuperSecureSQLQuery alle √ºbergeordneten Token des Typs MethodDecl zur√ºck. Dies ist die vorherige Methode im Aufrufstapel: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Zur Suche nach Methodenparametern verwenden wir auch <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  Die Abfrage gibt die Parameter einer Teilmenge von <i>entryPoints</i> mit dem Java-Typ String zur√ºck: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: Schritt 6. Ermitteln Sie die Abh√§ngigkeiten der runSSSQParams-Parameter von entryPointsParameters, w√§hrend nur an den Stellen keine Eingabe f√ºr die Bereinigung erfolgt </h3><br>  In diesem Schritt verwenden wir die Analysefunktionen.  Die folgenden Funktionen werden verwendet, um den Flow-Code zu analysieren: <br><br><ul><li>  Beeinflusst durch () </li><li>  InfluencedByAndNotSanitized () </li><li>  InfluencingOn () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  So ermitteln Sie den <i>Ablauf</i> von <i>runSSSQParams-</i> Anforderungsparametern in Abh√§ngigkeit von den Parametern der √ºbergeordneten Methode <i>entryPointsParameters</i> und schlie√üen <i>Bereinigungstoken</i> aus: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  Ich bin mir jedoch nicht sicher, ob die <i>* AndNotSanitized-</i> Funktionen etwas Magie <i>bewirken</i> , und es sieht eher so aus, als w√ºrde die Methode die bereinigte Menge einfach von ihrem Ergebnis subtrahieren.  Das hei√üt, wenn Sie tun: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  es stellt sich das gleiche heraus.  Obwohl ich vielleicht einfach keine Option gefunden habe, wenn es immer noch Unterschiede gibt. <br><br>  Das Ergebnis der Abfrage ergibt einen korrekt aufgebauten Flow: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Got Flow mit potenzieller SQL-Injection.  Wie aus dem Screenshot hervorgeht, hat Checkmarx 3 Flow zur√ºckgegeben.  Der Ablauf im Screenshot ist der k√ºrzeste. Er beginnt und endet in einer Datei und einer Methode.  Der n√§chste Flow geht bereits in die Session-Klasse.  Achten Sie auf Quelle / Ziel.  Und die letzte ist eine andere Methode in der Session-Klasse.  Der Ablauf in der <i>Sitzung</i> sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Um einen Flow auszuw√§hlen, wird die <i>ReduceFlow-</i> Methode <i>(CxList.ReduceFlowType flowType) verwendet</i> , wobei flowType Folgendes sein kann: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> - <i>W√§hlen</i> Sie den k√ºrzesten Flow aus </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> - <i>W√§hlen</i> Sie den l√§ngsten Flow aus </li></ul><br><br><h3>  SQLi: Letzte Abfrage zum Auffinden der SQL-Injection </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Beispiel 2: Suchen nach unsicheren direkten Objektreferenzen </h2><br>  In dieser Anfrage werden wir nach allen Stellen suchen, an denen mit Objekten gearbeitet wird, ohne den Eigent√ºmer des Objekts zu √ºberpr√ºfen.  In diesem Fall k√∂nnen unterschiedliche Namen von HTTP-Parametern f√ºr mailboxid verwendet werden (wir gehen davon aus, dass dies Legacy ist), und die √úberpr√ºfung selbst kann in verschiedenen Phasen erfolgen: irgendwo direkt am HTTP-Eintrags-API-Punkt, irgendwo vor der Anforderung an die Datenbank und manchmal in Zwischenmethoden. <br><br>  Plan suchen <br><ol><li>  Ausnahmen definieren ( <i>exclusionList</i> ); </li><li>  Stellen f√ºr Berechtigungspr√ºfungen identifizieren ( <i>idorSanitizer</i> ); </li><li>  Einstiegspunkte <i>suchen</i> - Orte f√ºr die prim√§re Verarbeitung von HTTP-Anforderungen ( <i>webRemoteMethods</i> ); </li><li>  Nur nach Einstiegspunkt-Token, um den Extraktionsort des HTTP-Parameters <i>mailboxid</i> ( <i>mailboxidInit</i> ) zu ermitteln. </li><li>  Suchen Sie alle Aufrufe von webRemoteMethods an Middleware-Methoden und Parameter dieser Aufrufe ( <i>middlewareMethods</i> ). </li><li>  Finden Sie Middleware-Methoden, die von mailboxid ( <i>apiPotentialIDOR</i> ) abh√§ngen. </li><li>  Suchen Sie alle Stellen, an denen Middleware-Methoden definiert sind ( <i>middlewareDecl</i> ). </li><li>  Gehen Sie alle <i>apiPotentialIDOR durch</i> und w√§hlen Sie nur die <i>MiddlewareDecl aus,</i> in denen keine √úberpr√ºfung des Besitzers des <i>Mailboxid-</i> Objekts erfolgt. </li></ol><br><br><h3>  IDOR: Schritt 1. Ausnahmen identifizieren </h3><br>  In diesem Fall schlie√üen Sie alle Token in einer bestimmten Datei aus: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i> enth√§lt eine Implementierung von Methoden wie <i>getMailboxId</i> und <i>getUserId</i> sowie die Zeichenfolge "mailboxid".  Da der Name der Token mit dem √ºbereinstimmt, den wir f√ºr die Suche nach Sicherheitsl√ºcken ben√∂tigen, gibt diese Datei falsche Ergebnisse aus. <br><br><h3>  IDOR: Schritt 2. Suchen Sie die Berechtigungspr√ºfungen </h3><br>  In der Testanwendung wird mit der <i>validateMailbox ()</i> -Methode bestimmt, ob das angeforderte Objekt dem Benutzer geh√∂rt: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: Schritt 3. Suchen Sie Einstiegspunkte f√ºr benutzerdefinierte HTTP-API-Anforderungen </h3><br>  HTTP-Request-Handler sind mit einer speziellen Anmerkung versehen, die das Auffinden erleichtert.  In meinem Fall ist dies "WebRemote", die CMxQL-Funktion <i>FindByCustomAttribute () wird</i> verwendet, um nach Anmerkungen zu suchen.  F√ºr <i>FindByCustomAttribute ()</i> gibt die Suchfunktion des √ºbergeordneten Tokens <i>GetAncOfType ()</i> die Methode unter der Anmerkung zur√ºck: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  Anforderungsergebnis: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: Schritt 4. Verwenden Sie nur Einstiegspunkt-Token, um die HTTP-Extraktionspositionen f√ºr den Parameter mailboxid zu ermitteln </h3><br>  So finden Sie Token, die sich auf die Verarbeitung des HTTP-Parameters mailboxid beziehen: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  Wir haben 3 Sets mit 3 verschiedenen Zeilen hinzugef√ºgt, weil  Der Legende nach kann der Name des HTTP-Parameters in verschiedenen Teilen des Systems unterschiedlich sein. <br><br>  Die Abfrage findet alle Stellen, an denen <i>mailboxid / mid / boxid</i> als Zeichenfolge geschrieben ist (in doppelten Anf√ºhrungszeichen).  Aber diese Abfrage wird eine Menge Funde zur√ºckgeben, tk.  Eine solche Zeichenfolge befindet sich nicht nur an Stellen, an denen HTTP-Parameter extrahiert werden.  Wenn wir mit diesem Set weiterarbeiten, werden wir eine gro√üe Anzahl falscher Funde erhalten. <br><br>  Aus diesem <i>Grund</i> suchen wir nur nach Token f√ºr Einstiegspunkte ( <i>webRemoteMethods</i> ).  Um alle untergeordneten Token zu finden, wird die CMBQL-Funktion <i>GetByAncs () verwendet</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  Die Anforderung gibt alle Token zur√ºck, die zu als <i>WebRemote gekennzeichneten</i> Methoden <i>geh√∂ren</i> .  Bereits jetzt k√∂nnen wir die Token der Methoden filtern, bei denen der Eigent√ºmer des Objekts √ºberpr√ºft wird.  Daher schreiben wir die vorherige Abfrage neu, um nach <i>untergeordneten</i> Token zu <i>suchen</i> , <i>sodass</i> nur die <i>untergeordneten</i> Token der <i>WebRemote-</i> Methoden <i>ausgew√§hlt</i> werden, bei denen keine Sicherheits√ºberpr√ºfung f√ºr den Eigent√ºmer des Objekts erfolgt.  Verwenden Sie dazu eine Schleife mit der Bedingung: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Jetzt k√∂nnen wir mithilfe der HTTP- <i>Mailbox-ID-</i> Parameter eine genauere Auswahl <i>treffen</i> : <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Uns interessieren jedoch nicht die Stellen, an denen die HTTP-Parameter abgerufen werden, sondern die Variablen, denen letztendlich die Werte der HTTP-Parameter zugewiesen werden.  Da es zuverl√§ssiger ist, Flow genau nach Variablen zu suchen. <br><br>  Die CMxQL-Funktion <i>FindByInitialization ()</i> findet die Stellen der Variableninitialisierung f√ºr die angegebenen Token: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: Schritt 5. Alle Aufrufe von webRemoteMethods an Middleware-Methoden und -Parameter dieser Aufrufe suchen </h3><br>  Mit Middleware meine ich Code, der tiefer geht als die Verarbeitungsmethoden von HTTP-API-Anforderungen, dh tiefer als die Einstiegspunkte von Benutzeranforderungen.  F√ºr den obigen Screenshot sind dies beispielsweise Methoden der <i>User-</i> Klasse, Aufrufe von <i>user.getSettings ()</i> und <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Zuerst w√§hlen wir alle Token mit dem Namen user aus, und dann <i>w√§hlen wir</i> mit <i>GetRightmostMember ()</i> die <i>Aufruftoken</i> f√ºr Middleware aus.  <i>GetRightmostMember ()</i> in der Kette der Methodenaufrufe gibt das am weitesten rechts stehende zur√ºck.  Dann leiten wir die Parameter der gefundenen Methode mit <i>GetParameters () ab</i> . <br><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: Schritt 6. Suchen Sie nach Middleware-Methoden, die von der Mailbox-ID abh√§ngen </h3><br>  Die Durchflussanalyse verwendet die <i>Methoden</i> <i>* InfluencedBy *</i> und <i>* InfluncingOn *</i> .  Der Unterschied zwischen ihnen ist durch den Namen klar. <br><br>  Zum Beispiel: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  <i>Durchl√§uft</i> die Gruppe Alle und findet alle Token, die von <i>getMailboxHTTPParams</i> abh√§ngen. <br><br>  Das gleiche kann auf andere Weise geschrieben werden: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  So suchen Sie nach Token, die von <i>mailboxidInit</i> abh√§ngig <i>sind</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: Schritt 7. Finden Sie alle Stellen, an denen Sie Middleware-Methoden definieren k√∂nnen </h3><br>  Lassen Sie uns die Definitionen aller Zwischenmethoden finden, die an Stellen verwendet werden k√∂nnen, an denen Benutzeranforderungen verarbeitet werden.  Dazu heben wir ihre gemeinsame Eigenschaft hervor. In all diesen Methoden wird beispielsweise ein <i>Request ()</i> -Objekt erstellt. Das Erstellen eines Objekts ist vom CMx-Typ <i>ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(All - exclusionList)</i> - Sie k√∂nnen diese Subtraktion von Mengen durchf√ºhren und dann die gew√ºnschte CMxQL-Funktion aus dem Ergebnis aufrufen.  <i>Requests</i> enth√§lt jetzt alle Token mit dem Namen <i>Request</i> und dem Typ, der der Erstellung des Objekts entspricht. <br><br>  Als n√§chstes finden wir mit dem bekannten <i>GetAncOfType ()</i> das √ºbergeordnete Token vom Typ <i>MethodDecl</i> . <br><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: Schritt 8. Durchlaufen Sie alle apiPotentialIDOR und w√§hlen Sie nur die MiddlewareDecl aus, in denen keine √úberpr√ºfung des Besitzers des Mailboxid-Objekts erfolgt </h3><br>  Im letzten Teil der Anforderung bestimmen wir, welche der Middleware-Methoden direkt von den Einstiegspunktmethoden aufgerufen werden, und √ºberpr√ºfen nicht, wem die <i>Mailbox-ID</i> geh√∂rt.  Kombinieren Sie dann Flow f√ºr eine bequemere Analyse der Ergebnisse. <br><br>  Neue Funktionen, die wir noch nicht genutzt haben: <br>  <i>GetCxListByPath ()</i> - Diese Funktion wird ben√∂tigt, um den Flow zu durchlaufen. Wenn sie NICHT verwendet wird, komprimiert CMx den Flow im Code-Element (im ersten Flow-Knoten). <br>  <i>Verketten * ()</i> - Eine Reihe von Funktionen, die zum Kombinieren mehrerer Flows zu einem Flow erforderlich sind <br>  <i>FindByParameters ()</i> - <i>Findet</i> eine Methode anhand eines bestimmten Parameter-Tokens <br>  <i>GetName ()</i> - <i>Gibt</i> eine Zeichenfolge mit dem Tokennamen zur√ºck. Befindet sich mehr als ein Element in CxList, wird die erste zur√ºckgegeben.  Die Methode wird nur verwendet, wenn Elemente einer Menge durchlaufen werden. <br><br>  Der letzte Teil der Anfrage: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i>CocatenatePath</i>  ,          .     Code Element  Flow <br><br><h3> IDOR:     IDOR </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    ‚Äì    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Fazit </h2><br> Checkmarx      ,     .        ,      ,   ,     ..      Flow (    ).           ,         ,    ¬´¬ª . <br><br>     false positive,     : <br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     ¬´Privacy Violation¬ª,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     ¬´hello world¬ª  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477742/">https://habr.com/ru/post/de477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477732/index.html">Falsche Fingerklassifizierung von Unterwassernavigationssystemen</a></li>
<li><a href="../de477734/index.html">Grundlegendes zum UICollectionViewLayout mit der Photos-App</a></li>
<li><a href="../de477736/index.html">Der Weg des Testers: von der ‚ÄûHandbremse‚Äú bis zur Automatisierung</a></li>
<li><a href="../de477738/index.html">iKassa oder wie wir die "digitale Kasse" gez√§hmt haben</a></li>
<li><a href="../de477740/index.html">Und wo kann man mit dem Auge in dieses Teleskop schauen?</a></li>
<li><a href="../de477746/index.html">Monetarisierungsdesigner: Wer er ist und wie man einer wird</a></li>
<li><a href="../de477752/index.html">Backend United # 5: Shawarma - Microservices, Distributed Systems und Kafka</a></li>
<li><a href="../de477754/index.html">Vergleiche micro: bit mit Arduino. Und wie bekommst du micro: bit kostenlos, wenn du kein Englischsch√ºler bist?</a></li>
<li><a href="../de477756/index.html">Wie wir zwei Banking-CRM-Systeme heirateten</a></li>
<li><a href="../de477758/index.html">"Doktor, entfernen Sie dies von der Rechnung": wie wir nach illegalen Diensten in VHI gesucht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>