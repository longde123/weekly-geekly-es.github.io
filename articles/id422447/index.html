<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗾 🛀🏽 🙎🏼 bytes.Buffer in Go: optimasi yang tidak berfungsi 👉🏾 👩‍⚕️ 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak programmer Go yang akrab dengan byte . Buffer . Salah satu kelebihannya adalah memungkinkan Anda untuk menghindari mengalokasikan memori pada h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bytes.Buffer in Go: optimasi yang tidak berfungsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/422447/"><p>  Banyak programmer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go</a> yang akrab dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">byte</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer</a> .  Salah satu kelebihannya adalah memungkinkan Anda untuk menghindari mengalokasikan memori pada heap dengan cara yang sama seperti " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimasi buffer / ukuran kecil</a> ": </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  Hanya ada satu masalah.  Pengoptimalan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tidak berfungsi</a> . </p><br><p>  Pada akhir artikel ini, Anda akan mengetahui mengapa pengoptimalan ini tidak berfungsi dan apa yang dapat kami lakukan. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  Seperti yang dimaksud, "optimasi buffer kecil" </h1><br><p>  Mari kita perkenalkan definisi <code>bytes.Buffer</code> sedikit disederhanakan. <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  Ketika kita melakukan tindakan pada <code>Buffer</code> , misalnya, memanggil metode <code>Buffer.Write</code> , catatan selalu dibuat di <code>buf</code> , namun, sebelum catatan ini, <code>Buffer.grow(n)</code> diluncurkan di dalam setiap metode yang serupa, yang memastikan bahwa ada cukup ruang dalam irisan ini untuk <code>n</code> byte berikutnya. </p><br><p>  Grow mungkin terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Asumsi yang digunakan dalam implementasi Buffer.grow kami</b> <div class="spoiler_text"><hr><br><p>  Kami membuat asumsi bahwa <code>len(b.buf)</code> adalah panjang data aktual dalam Buffer, yang akan membutuhkan <code>Write</code> untuk menggunakan metode append untuk menambahkan byte baru ke slice.  Ini bukan kasus dalam <code>bytes.Buffer</code> dari perpustakaan standar, tetapi sebagai contoh, ini adalah detail implementasi yang tidak relevan. </p><br><hr></div></div><br><p>  Jika <code>b</code> dialokasikan pada stack, maka <code>bootstrap</code> di dalamnya dialokasikan pada stack, yang berarti bahwa slice <code>b.buf</code> akan menggunakan kembali memori di dalam <code>b</code> tanpa memerlukan alokasi tambahan. </p><br><p>  Ketika <code>grow</code> mengungkapkan bahwa array <code>bootstrap</code> sudah tidak cukup, irisan "nyata" baru akan dibuat, di mana elemen dari penyimpanan sebelumnya (dari "buffer kecil") kemudian akan disalin.  Setelah itu, <code>Buffer.bootstrap</code> akan kehilangan relevansinya.  Jika <code>Buffer.Reset</code> , <code>cap(b.buf)</code> akan tetap sama dan tidak akan ada lagi kebutuhan untuk array <code>bootstrap</code> . </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  Memori hilang dalam tumpukan </h1><br><p>  Lebih lanjut diharapkan bahwa pembaca setidaknya secara dangkal akrab dengan apa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis pelarian</a> di Go. </p><br><p>  Pertimbangkan situasi berikut: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Di sini <code>b</code> akan dialokasikan pada heap.  Alasan untuk ini adalah pointer bocor ke <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminologi</b> <div class="spoiler_text"><hr><br><p>  Dalam artikel ini, "bocor" dan "melarikan diri" digunakan hampir secara sinonim. </p><br><p>  Ada beberapa perbedaan dalam kompiler itu sendiri, misalnya, nilai "lolos ke tumpukan", tetapi parameter fungsi adalah "bocor param x". </p><br><p>  Parameter bocor berarti bahwa argumen yang lolos untuk parameter ini akan dialokasikan pada heap.  Dengan kata lain, parameter bocor menyebabkan argumen untuk melarikan diri ke tumpukan. </p><br><hr></div></div><br><p>  Di atas adalah kasus yang jelas, tetapi bagaimana dengan ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Di sini kita hanya perlu 1 byte, semuanya cocok dengan <code>bootstrap</code> , buffer itu sendiri bersifat lokal dan tidak "lepas" dari fungsinya.  Anda mungkin terkejut, tetapi hasilnya akan sama, alokasi <code>b</code> di heap. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  Yang pasti, Anda dapat memeriksa ini menggunakan patokan: </p><br><pre> <code class="hljs powershell">BenchmarkLength<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">90.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">112</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Daftar patokan</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Penjelasan 112 B / op</b> <div class="spoiler_text"><hr><br><p>  Ketika runtime meminta pengalokasi untuk <code>N</code> byte, tidak perlu tepatnya <code>N</code> byte dialokasikan. </p><br><blockquote>  Semua hasil di bawah ini adalah untuk kombinasi <code>GOOS=linux</code> dan <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  Jika Anda menjalankan <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> dengan tes ini: </p><br><pre> <code class="hljs powershell">BenchmarkAlloc9<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">33.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><p>  9 byte diminta, dialokasikan 16. Sekarang kembali ke <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Mari kita lihat <a href="">$ GOROOT / src / runtime / sizeclasses.go</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  Itu tidak masuk ke dalam 96 byte, 112 dipilih. </p><br><hr></div></div><br><p>  Tetapi mengapa ini terjadi? </p><br><h1 id="chto-proishodit-i-pochemu">  Apa yang terjadi dan mengapa </h1><br><p>  Beberapa analisis situasi dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang</a> disebutkan di awal. <br>  Ada juga alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reproduksi sederhana</a> . </p><br><p>  Tempat masalahnya hanya dalam penugasan <code>b.buf = b.bootstrap[:]</code> .  Kode ini membuat analisis melarikan diri berasumsi bahwa <code>b.bootstrap</code> "melarikan diri", dan karena ini adalah array, maka ia disimpan di dalam objek itu sendiri, yang berarti bahwa semua <code>b</code> harus dialokasikan pada heap. </p><br><p>  Jika bootstrap adalah slice, bukan array, maka ini tidak akan terjadi, karena ada optimasi adhoc untuk menetapkan irisan dari objek ke objek itu sendiri: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  Jawaban mengapa optimisasi ini tidak berfungsi untuk array telah dirumuskan di atas, tetapi di sini ada <a href="">penekanan</a> dari <a href="">esc.go # L835-L866 itu sendiri</a> (seluruh kode optimasi disorot oleh referensi): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Perlu ditambahkan di sini bahwa untuk penganalisa pointer ada beberapa level "kebocoran", utamanya: </p><br><ol><li>  Objek itu sendiri lolos (b lolos).  Dalam hal ini, objek itu sendiri perlu dialokasikan di heap. </li><li>  Unsur-unsur objek (b isi melarikan diri) melarikan diri.  Dalam hal ini, pointer pada objek dianggap melarikan diri. </li></ol><br><p>  Kasing dengan array adalah spesial karena jika array bocor, objek yang memuatnya juga harus bocor. </p><br><p>  melarikan diri analisis membuat keputusan tentang apakah mungkin untuk menempatkan objek pada tumpukan atau tidak, hanya mengandalkan informasi yang tersedia di tubuh fungsi yang dianalisis.  Metode <code>Buffer.grow</code> mengambil <code>b</code> oleh pointer, sehingga perlu menghitung tempat yang sesuai untuk diletakkan.  Karena dalam kasus array kita tidak dapat membedakan antara <code>"b escape"</code> dan <code>"b contents escape"</code> , kita harus lebih pesimis dan sampai pada kesimpulan bahwa <code>b</code> tidak aman untuk ditempatkan pada stack. </p><br><p>  Asumsikan sebaliknya, bahwa pola <code>self-assignment</code> menyelesaikan yang sama untuk array seperti halnya untuk irisan: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  Keputusan untuk menempatkan <code>b</code> pada tumpukan dalam situasi ini akan menyebabkan bencana: setelah keluar dari fungsi di mana <code>b</code> dibuat, memori yang akan <code>sink</code> akan merujuk tidak lebih dari sampah. </p><br><h1 id="ukazateli-na-massivy">  Array pointer </h1><br><p>  Bayangkan <code>Buffer</code> kita dinyatakan sedikit berbeda: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Tidak seperti array biasa, pointer ke array tidak akan menyimpan semua elemen di dalam <code>Buffer</code> itu sendiri.  Ini berarti bahwa jika alokasi <code>bootstrap</code> di heap tidak memerlukan alokasi <code>Buffer</code> di heap.  Karena analisis pelarian dapat mengalokasikan bidang penunjuk pada tumpukan jika memungkinkan, kita dapat mengasumsikan bahwa definisi <code>Buffer</code> seperti itu lebih berhasil. </p><br><p>  Tapi ini dalam teori.  Dalam praktiknya, penunjuk ke array tidak memiliki banyak pemrosesan dan jatuh ke dalam kategori yang sama dengan potongan dari array biasa, yang tidak sepenuhnya benar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CL133375: cmd / compile / internal / gc: handle slice yang ditugaskan sendiri di esc.go</a> bertujuan untuk memperbaiki situasi ini. </p><br><p>  Misalkan perubahan ini telah diterima ke kompiler Go. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  Nilai nol kami hilang </h1><br><p>  Sayangnya, transisi dari <code>[64]byte</code> ke <code>*[64]byte</code> memiliki masalah: sekarang kita tidak dapat menggunakan <code>bootstrap</code> tanpa menginisialisasi secara eksplisit, nilai nol <code>Buffer</code> tidak lagi berguna, kita memerlukan konstruktor. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  Kami mengembalikan <code>Buffer</code> , bukan <code>*Buffer</code> , untuk menghindari masalah dengan analisis pointer (sangat konservatif di Go), dan dengan mempertimbangkan fakta bahwa <code>NewBuffer</code> selalu dibangun di tempat panggilan, tidak akan ada penyalinan yang tidak perlu. </p><br><p>  Setelah menyematkan tubuh <code>NewBuffer</code> di tempat panggilan, analisis pelarian dapat mencoba untuk membuktikan bahwa <code>new(*[smallBufSize]byte)</code> tidak melebihi umur bingkai fungsi yang disebutnya.  Jika demikian, maka alokasi akan berada di tumpukan. </p><br><h1 id="intel-bytebuf">  Intel bytebuf </h1><br><p>  Optimasi yang dijelaskan di atas diterapkan dalam paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intel-go / bytebuf</a> . </p><br><p>  Perpustakaan ini mengekspor tipe <code>bytebuf.Buffer</code> , yang menduplikasi 99,9% <code>bytes.Buffer</code> .  Semua perubahan <code>bytebuf.New</code> untuk memperkenalkan konstruktor ( <code>bytebuf.New</code> ) dan pointer ke array bukan array biasa: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Berikut ini adalah perbandingan kinerja dengan <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs powershell">name old time/op new time/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-82</span></span>.<span class="hljs-number"><span class="hljs-number">94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns ±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-67</span></span>.<span class="hljs-number"><span class="hljs-number">82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns ±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns ± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-literal"><span class="hljs-literal">-52</span></span>.<span class="hljs-number"><span class="hljs-number">26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns ±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-literal"><span class="hljs-literal">-28</span></span>.<span class="hljs-number"><span class="hljs-number">57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-16</span></span>.<span class="hljs-number"><span class="hljs-number">78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op new alloc/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-95</span></span>.<span class="hljs-number"><span class="hljs-number">73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-63</span></span>.<span class="hljs-number"><span class="hljs-number">64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-30</span></span>.<span class="hljs-number"><span class="hljs-number">43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-5</span></span>.<span class="hljs-number"><span class="hljs-number">19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op new allocs/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Semua informasi lain tersedia di <a href="">README</a> . </p><br><p>  Karena ketidakmampuan untuk menggunakan nilai nol dan mengikat ke fungsi membangun <code>New</code> , tidak mungkin untuk menerapkan optimasi ini ke <code>bytes.Buffer</code> . <code>bytes.Buffer</code> . </p><br><p>  Apakah ini satu-satunya cara untuk membuat <code>bytes.Buffer</code> lebih cepat. <code>bytes.Buffer</code> ?  Jawabannya adalah tidak.  Tapi ini jelas merupakan metode yang membutuhkan perubahan minimal dalam implementasi. </p><br><h1 id="plany-na-escape-analysis">  Rencana Analisis Pelarian </h1><br><p>  Dalam bentuknya saat ini, analisis pelarian di Go cukup lemah.  Hampir semua operasi dengan nilai pointer mengarah ke alokasi di heap, bahkan jika ini bukan keputusan yang masuk akal. </p><br><p>  Saya akan mencoba mengarahkan sebagian besar waktu yang saya curahkan untuk proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang / go</a> untuk menyelesaikan masalah ini, sehingga beberapa perbaikan mungkin terjadi pada rilis mendatang (1.12). </p><br><p>  Anda dapat membaca tentang hasil dan detail struktur internal bagian kompiler ini di salah satu artikel saya berikutnya.  Saya akan mencoba untuk memberikan serangkaian rekomendasi yang akan membantu dalam beberapa kasus untuk menyusun kode sehingga memiliki alokasi memori yang kurang diinginkan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422447/">https://habr.com/ru/post/id422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422437/index.html">Game pengalaman pengguna dan kecepatan situs web dan aplikasi</a></li>
<li><a href="../id422439/index.html">Pertarungan dengan Yandex: bagaimana saya menghabiskan lebih dari setahun untuk membawa situs ke puncak</a></li>
<li><a href="../id422441/index.html">Menemukan formula untuk transisi tanpa rasa sakit ke .Net Core</a></li>
<li><a href="../id422443/index.html">Timer Tepat Corona SDK</a></li>
<li><a href="../id422445/index.html">Implementasi BottomAppBar. Bagian 3: Perilaku untuk Android</a></li>
<li><a href="../id422449/index.html">Senator versus Amazon: apa yang telah dilakukan toko online</a></li>
<li><a href="../id422451/index.html">Untuk mendengarkan tentang pemasaran game dan tentang tempat penulis skenario di industri game pada 26 September di VShBI</a></li>
<li><a href="../id422453/index.html">SmartData 2018: Konferensi Grup JUG.ru Pertama yang Dibatalkan</a></li>
<li><a href="../id422455/index.html">EPAM + university: bagaimana kami bekerja dengan universitas Ukraina</a></li>
<li><a href="../id422457/index.html">“Tidak masuk akal bagi kami untuk menggunakan Retrofit”: tentang pengembangan Android di Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>