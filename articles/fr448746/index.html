<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÑ ‚ôàÔ∏è üò´ Index dans PostgreSQL - 7 (GIN) ü§ó üìú üôáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† fait la connaissance du moteur d'indexation PostgreSQL et de l'interface des m√©thodes d'acc√®s et discut√© des index de hachage , des ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Nous avons d√©j√† fait la connaissance du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL et de l'interface des m√©thodes d'acc√®s et discut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des index de hachage</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres B</a> , ainsi que des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">index GiST</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SP-GiST</a> .  Et cet article pr√©sentera l'index GIN. <br><br><h1>  Gin </h1><br>  <em>"Gin? ... Le Gin est, semble-t-il, une telle liqueur am√©ricaine? .."</em> <em><br></em>  <em>"Je ne suis pas un verre, oh, gar√ßon curieux!"</em>  <em>le vieil homme s'embrasa de nouveau, il se rendit compte de nouveau et se reprit en main.</em>  <em>"Je ne suis pas un verre, mais un esprit puissant et intr√©pide, et il n'y a pas une telle magie dans le monde que je ne pourrais pas faire."</em> <br>  - Lazar Lagin, ¬´Old Khottabych¬ª. <br><br>  <em>Gin signifie Index g√©n√©ralis√© invers√© et doit √™tre consid√©r√© comme un g√©nie, pas comme une boisson.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LISEZ</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MOI</a> <br><a name="habracut"></a><br><h2>  Concept g√©n√©ral </h2><br>  GIN est l'index invers√© g√©n√©ralis√© abr√©g√©.  Il s'agit d'un soi-disant <em>index invers√©</em> .  Il manipule des types de donn√©es dont les valeurs ne sont pas atomiques, mais constitu√©es d'√©l√©ments.  Nous appellerons ces types compos√©s.  Et ce ne sont pas les valeurs qui sont index√©es, mais les √©l√©ments individuels;  chaque √©l√©ment fait r√©f√©rence aux valeurs dans lesquelles il se produit. <br><br>  Une bonne analogie avec cette m√©thode est l'index √† la fin d'un livre qui, pour chaque terme, fournit une liste de pages o√π ce terme appara√Æt.  La m√©thode d'acc√®s doit assurer une recherche rapide des √©l√©ments index√©s, tout comme l'index dans un livre.  Par cons√©quent, ces √©l√©ments sont stock√©s sous la forme d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre B</a> familier (une impl√©mentation diff√©rente et plus simple est utilis√©e pour cela, mais cela n'a pas d'importance dans ce cas).  Un ensemble ordonn√© de r√©f√©rences aux lignes de table qui contiennent des valeurs compos√©es avec l'√©l√©ment est li√© √† chaque √©l√©ment.  L'ordre n'est pas essentiel pour la r√©cup√©ration des donn√©es (l'ordre de tri des TID ne signifie pas grand-chose), mais il est important pour la structure interne de l'index. <br><br>  Les √©l√©ments ne sont jamais supprim√©s de l'index GIN.  On suppose que les valeurs contenant des √©l√©ments peuvent dispara√Ætre, appara√Ætre ou varier, mais l'ensemble des √©l√©ments qui les composent est plus ou moins stable.  Cette solution simplifie consid√©rablement les algorithmes pour le travail simultan√© de plusieurs processus avec l'index. <br><br>  Si la liste des TID est assez petite, elle peut tenir dans la m√™me page que l'√©l√©ment (et s'appelle "la liste de publication").  Mais si la liste est grande, une structure de donn√©es plus efficace est n√©cessaire, et nous en sommes d√©j√† conscients - c'est √† nouveau B-tree.  Un tel arbre est situ√© sur des pages de donn√©es distinctes (et est appel√© "l'arbre de publication"). <br><br>  Ainsi, l'index GIN se compose de l'arbre B des √©l√©ments, et les arbres B ou les listes plates de TID sont li√©s aux rang√©es de feuilles de cet arbre B. <br><br>  Tout comme les index GiST et SP-GiST, discut√©s pr√©c√©demment, GIN fournit √† un d√©veloppeur d'applications l'interface pour prendre en charge diverses op√©rations sur des types de donn√©es compos√©s. <br><br><h2>  Recherche plein texte </h2><br>  Le principal domaine d'application de la m√©thode GIN est l'acc√©l√©ration de la recherche en texte int√©gral, ce qui est donc raisonnable √† utiliser comme exemple dans une discussion plus d√©taill√©e de cet index. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article relatif √† GiST</a> a d√©j√† fourni une petite introduction √† la recherche en texte int√©gral, alors allons droit au but sans r√©p√©titions.  Il est clair que les valeurs compos√©es dans ce cas sont des <em>documents</em> , et les √©l√©ments de ces documents sont des <em>lex√®mes</em> . <br><br>  Prenons l'exemple de l'article li√© √† GiST: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Une structure possible de cet indice est illustr√©e dans la figure: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  Contrairement √† toutes les figures pr√©c√©dentes, les r√©f√©rences aux lignes du tableau (TID) sont indiqu√©es par des valeurs num√©riques sur fond sombre (le num√©ro de page et la position sur la page) plut√¥t que par des fl√®ches. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  Dans cet exemple sp√©culatif, la liste des TID tient dans des pages normales pour tous les lex√®mes sauf "sheet", "slit" et "slitter".  Ces lex√®mes se sont produits dans de nombreux documents, et les listes de TID pour eux ont √©t√© plac√©es dans des arbres B individuels. <br><br>  Au fait, comment savoir combien de documents contiennent un lex√®me?  Pour une petite table, une technique ¬´directe¬ª, illustr√©e ci-dessous, fonctionnera, mais nous apprendrons plus loin quoi faire avec les plus grandes. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Notez √©galement que contrairement √† un arbre B normal, les pages d'index GIN sont connect√©es par une liste unidirectionnelle plut√¥t que bidirectionnelle.  Ceci est suffisant car une travers√©e d'arbre ne se fait que dans un sens. <br><br><h3>  Exemple de requ√™te </h3><br>  Comment la requ√™te suivante sera-t-elle ex√©cut√©e pour notre exemple? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Les lex√®mes individuels (cl√©s de recherche) sont extraits de la requ√™te en premier: "mani" et "slitter".  Cela se fait par une fonction API sp√©cialis√©e qui prend en compte le type de donn√©es et la strat√©gie d√©termin√©s par la classe d'op√©rateur: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  Dans l'arborescence B des lex√®mes, nous trouvons ensuite les deux cl√©s et parcourons les listes pr√™tes de TID.  Nous obtenons: <br><br>  pour "mani" - (0,2). <br>  pour ¬´refendeuse¬ª - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Enfin, pour chaque TID trouv√©, une fonction de coh√©rence API est appel√©e, qui doit d√©terminer laquelle des lignes trouv√©es correspond √† la requ√™te de recherche.  Puisque les lex√®mes de notre requ√™te sont joints par des bool√©ens "et", la seule ligne renvoy√©e est (0,2): <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Et le r√©sultat est: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Si nous comparons cette approche avec celle d√©j√† discut√©e pour GiST, l'avantage de GIN pour la recherche en texte int√©gral appara√Æt √©vident.  Mais il y a plus que cela √† l'≈ìil nu. <br><br><h3>  La question d'une mise √† jour lente </h3><br>  Le fait est que l'insertion ou la mise √† jour des donn√©es dans l'index GIN est assez lente.  Chaque document contient g√©n√©ralement de nombreux lex√®mes √† indexer.  Par cons√©quent, lorsqu'un seul document est ajout√© ou mis √† jour, nous devons mettre √† jour massivement l'arborescence d'index. <br><br>  D'un autre c√¥t√©, si plusieurs documents sont mis √† jour simultan√©ment, certains de leurs lex√®mes peuvent √™tre les m√™mes, et la quantit√© totale de travail sera plus petite que lors de la mise √† jour des documents un par un. <br><br>  L'index GIN a un param√®tre de stockage "fastupdate", que nous pouvons sp√©cifier lors de la cr√©ation et de la mise √† jour de l'index plus tard: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Lorsque ce param√®tre est activ√©, les mises √† jour seront accumul√©es dans une liste distincte non tri√©e (sur les pages individuelles connect√©es).  Lorsque cette liste devient suffisamment grande ou lors de la mise √† vide, toutes les mises √† jour accumul√©es sont instantan√©ment apport√©es √† l'index.  La liste √† consid√©rer comme "suffisamment grande" est d√©termin√©e par le param√®tre de configuration "gin_pending_list_limit" ou par le param√®tre de stockage du m√™me nom de l'index. <br><br>  Mais cette approche pr√©sente des inconv√©nients: premi√®rement, la recherche est ralentie (car la liste non ordonn√©e doit √™tre consult√©e en plus de l'arborescence), et deuxi√®mement, une prochaine mise √† jour peut prendre de mani√®re inattendue beaucoup de temps si la liste non ordonn√©e a √©t√© d√©bord√©e. <br><br><h3>  Recherche d'une correspondance partielle </h3><br>  Nous pouvons utiliser une correspondance partielle dans la recherche en texte int√©gral.  Par exemple, consid√©rez la requ√™te suivante: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Cette requ√™te trouvera des documents contenant des lex√®mes commen√ßant par "fente".  Dans cet exemple, ces lex√®mes sont "fente" et "refendeur". <br><br>  Une requ√™te fonctionnera certainement de toute fa√ßon, m√™me sans index, mais GIN permet √©galement d'acc√©l√©rer la recherche suivante: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Ici, tous les lex√®mes ayant le pr√©fixe sp√©cifi√© dans la requ√™te de recherche sont recherch√©s dans l'arborescence et joints par des bool√©ens "ou". <br><br><h3>  Lex√®mes fr√©quents et peu fr√©quents </h3><br>  Pour voir comment l'indexation fonctionne sur les donn√©es en direct, prenons l'archive des e-mails "pgsql-hackers", que nous avons d√©j√† utilis√©s lors de la discussion sur GiST.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cette version de l'archive</a> contient 356125 messages avec la date d'envoi, le sujet, l'auteur et le texte. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Prenons un lex√®me qui appara√Æt dans de nombreux documents.  La requ√™te utilisant "unnest" ne fonctionnera pas sur une si grande taille de donn√©es, et la bonne technique consiste √† utiliser la fonction "ts_stat", qui fournit les informations sur les lex√®mes, le nombre de documents o√π ils se sont produits et le nombre total d'occurrences. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Choisissons "√©crit". <br><br>  Et nous prendrons un mot qui est peu fr√©quent pour le courrier √©lectronique des d√©veloppeurs, par exemple, "tatouage": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  Y a-t-il des documents o√π ces deux lex√®mes se produisent?  Il semble qu'il y ait: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Une question se pose comment effectuer cette requ√™te.  Si nous obtenons des listes de TID pour les deux lex√®mes, comme d√©crit ci-dessus, la recherche sera √©videmment inefficace: nous devrons parcourir plus de 200 000 valeurs, dont une seule restera.  Heureusement, en utilisant les statistiques du planificateur, l'algorithme comprend que le lex√®me "√©crit" se produit fr√©quemment, tandis que "tatoo" se produit rarement.  Par cons√©quent, la recherche du lex√®me peu fr√©quent est effectu√©e, et les deux documents r√©cup√©r√©s sont ensuite v√©rifi√©s pour l'occurrence du lex√®me "√©crit".  Et cela ressort clairement de la requ√™te, qui est effectu√©e rapidement: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  La recherche de "√©crit" √† lui seul prend beaucoup plus de temps: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Cette optimisation fonctionne certainement non seulement pour deux lex√®mes, mais aussi dans des cas plus complexes. <br><br><h3>  Limiter le r√©sultat de la requ√™te </h3><br>  Une caract√©ristique de la m√©thode d'acc√®s GIN est que le r√©sultat est toujours renvoy√© sous forme de bitmap: cette m√©thode ne peut pas renvoyer le r√©sultat TID par TID.  C'est pour cette raison que tous les plans de requ√™te de cet article utilisent l'analyse bitmap. <br><br>  Par cons√©quent, la limitation du r√©sultat de l'analyse d'index √† l'aide de la clause LIMIT n'est pas tout √† fait efficace.  Faites attention au co√ªt pr√©vu de l'op√©ration (champ "co√ªt" du n≈ìud "Limite"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  Le co√ªt est estim√© √† 1285.13, ce qui est un peu plus √©lev√© que le co√ªt de construction de la totalit√© du bitmap 1249.30 (champ "co√ªt" du n≈ìud Bitmap Index Scan). <br><br>  Par cons√©quent, l'index a une capacit√© sp√©ciale pour limiter le nombre de r√©sultats.  La valeur de seuil est sp√©cifi√©e dans le param√®tre de configuration "gin_fuzzy_search_limit" et est √©gale √† z√©ro par d√©faut (aucune limitation n'a lieu).  Mais nous pouvons d√©finir la valeur seuil: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Comme nous pouvons le voir, le nombre de lignes renvoy√©es par la requ√™te diff√®re pour diff√©rentes valeurs de param√®tre (si l'acc√®s √† l'index est utilis√©).  La limitation n'est pas stricte: plus de lignes que sp√©cifi√©es peuvent √™tre retourn√©es, ce qui justifie une partie "floue" du nom du param√®tre. <br><br><h3>  Repr√©sentation compacte </h3><br>  Parmi les autres, les indices GIN sont bons gr√¢ce √† leur compacit√©.  Premi√®rement, si un m√™me lex√®me appara√Æt dans plusieurs documents (et c'est g√©n√©ralement le cas), il n'est stock√© dans l'index qu'une seule fois.  Deuxi√®mement, les TID sont stock√©s dans l'index de mani√®re ordonn√©e, ce qui nous permet d'utiliser une compression simple: chaque TID suivant dans la liste est r√©ellement stock√© comme sa diff√©rence par rapport au pr√©c√©dent;  il s'agit g√©n√©ralement d'un petit nombre, ce qui n√©cessite beaucoup moins de bits qu'un TID complet √† six octets. <br><br>  Pour avoir une id√©e de la taille, construisons B-tree √† partir du texte des messages.  Mais une comparaison √©quitable ne va certainement pas se produire: <br><br><ul><li>  GIN est construit sur un type de donn√©es diff√©rent ("tsvector" plut√¥t que "text"), qui est plus petit, </li><li>  en m√™me temps, la taille des messages pour B-tree doit √™tre r√©duite √† environ deux kilo-octets. </li></ul><br>  N√©anmoins, nous continuons: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Nous allons √©galement construire l'index GiST: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  La taille des index sur "vide plein": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  En raison de la compacit√© de la repr√©sentation, nous pouvons essayer d'utiliser l'index GIN lors de la migration depuis Oracle en remplacement des index bitmap (sans entrer dans les d√©tails, je fournis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une r√©f√©rence √† la publication de Lewis</a> pour les esprits curieux).  En r√®gle g√©n√©rale, les index bitmap sont utilis√©s pour les champs qui ont peu de valeurs uniques, ce qui est √©galement excellent pour GIN.  Et, comme indiqu√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le premier article</a> , PostgreSQL peut cr√©er un bitmap bas√© sur n'importe quel index, y compris GIN, √† la vol√©e. <br><br><h3>  GiST ou GIN? </h3><br>  Pour de nombreux types de donn√©es, les classes d'op√©rateurs sont disponibles pour GiST et GIN, ce qui pose la question de l'index √† utiliser.  Peut-√™tre pouvons-nous d√©j√† tirer quelques conclusions. <br><br>  En r√®gle g√©n√©rale, GIN bat GiST en termes de pr√©cision et de vitesse de recherche.  Si les donn√©es ne sont pas mises √† jour fr√©quemment et qu'une recherche rapide est n√©cessaire, le GIN sera tr√®s probablement une option. <br><br>  D'un autre c√¥t√©, si les donn√©es sont intensivement mises √† jour, les frais g√©n√©raux de mise √† jour du GIN peuvent sembler trop √©lev√©s.  Dans ce cas, il faudra comparer les deux options et choisir celle dont les caract√©ristiques sont mieux √©quilibr√©es. <br><br><h2>  Tableaux </h2><br>  L'indexation des tableaux est un autre exemple d'utilisation de GIN.  Dans ce cas, les √©l√©ments du tableau entrent dans l'index, ce qui permet d'acc√©l√©rer un certain nombre d'op√©rations sur les tableaux: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base de donn√©es de d√©monstration</a> a une vue "routes" avec des informations sur les vols.  Parmi les autres, cette vue contient la colonne ¬´days_of_week¬ª - un tableau de jours de la semaine lorsque les vols ont lieu.  Par exemple, un vol de Vnoukovo √† Guelendjik part les mardis, jeudis et dimanches: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Pour construire l'index, "mat√©rialisons" la vue dans une table: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Maintenant, nous pouvons utiliser l'index pour conna√Ætre tous les vols qui partent les mardis, jeudis et dimanches: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Il semble qu'il y en ait six: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  Comment cette requ√™te est-elle ex√©cut√©e?  Exactement de la m√™me mani√®re que celle d√©crite ci-dessus: <br><br><ol><li>  √Ä partir du tableau {2,4,7}, qui joue ici le r√¥le de la requ√™te de recherche, des √©l√©ments (mots-cl√©s de recherche) sont extraits.  √âvidemment, ce sont les valeurs de "2", "4" et "7". <br></li><li>  Dans l'arborescence des √©l√©ments, les cl√©s extraites sont trouv√©es et pour chacune d'elles, la liste des TID est s√©lectionn√©e. <br></li><li>  De tous les TID trouv√©s, la fonction de coh√©rence s√©lectionne ceux qui correspondent √† l'op√©rateur dans la requ√™te.  Pour l'op√©rateur <code>=</code> , seuls les TID correspondent √† ceux qui se sont produits dans les trois listes (en d'autres termes, le tableau initial doit contenir tous les √©l√©ments).  Mais cela n'est pas suffisant: il est √©galement n√©cessaire que le tableau ne contienne aucune autre valeur, et nous ne pouvons pas v√©rifier cette condition avec l'index.  Par cons√©quent, dans ce cas, la m√©thode d'acc√®s demande au moteur d'indexation de rev√©rifier tous les TID retourn√©s avec la table. <br></li></ol><br>  Il est int√©ressant de noter qu'il existe des strat√©gies (par exemple, "contenues dans un tableau") qui ne peuvent rien v√©rifier et doivent rev√©rifier tous les TID trouv√©s avec la table. <br><br>  Mais que faire si nous avons besoin de conna√Ætre les vols qui partent de Moscou les mardis, jeudis et dimanches?  L'index ne prendra pas en charge la condition suppl√©mentaire, qui entrera dans la colonne "Filtre". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Ici, c'est OK (l'index ne s√©lectionne que six lignes de toute fa√ßon), mais dans les cas o√π la condition suppl√©mentaire augmente la capacit√© de s√©lection, il est souhaitable d'avoir un tel support.  Cependant, nous ne pouvons pas simplement cr√©er l'index: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Mais l'extension " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">btree_gin</a> " aidera, ce qui ajoute des classes d'op√©rateurs GIN qui simulent le travail d'un arbre B r√©gulier. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  JSON est un autre exemple d'un type de donn√©es compos√© qui prend en charge GIN int√©gr√©.  Pour travailler avec les valeurs JSON, un certain nombre d'op√©rateurs et de fonctions sont actuellement d√©finis, dont certains peuvent √™tre acc√©l√©r√©s √† l'aide d'index: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Comme nous pouvons le voir, deux classes d'op√©rateurs sont disponibles: "jsonb_ops" et "jsonb_path_ops". <br><br>  La premi√®re classe d'op√©rateur "jsonb_ops" est utilis√©e par d√©faut.  Toutes les cl√©s, valeurs et √©l√©ments de tableau acc√®dent √† l'index en tant qu'√©l√©ments du document JSON initial.  Un attribut est ajout√© √† chacun de ces √©l√©ments, qui indique si cet √©l√©ment est une cl√© (cela est n√©cessaire pour les strat√©gies "existe", qui distinguent les cl√©s et les valeurs). <br><br>  Par exemple, repr√©sentons quelques lignes de "routes" en JSON comme suit: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  L'index peut se pr√©senter comme suit: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Maintenant, une requ√™te comme celle-ci, par exemple, peut √™tre effectu√©e √† l'aide de l'index: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  En commen√ßant par la racine du document JSON, l'op√©rateur <code>@&gt;</code> v√©rifie si l'itin√©raire sp√©cifi√© ( <code>"days_of_week": [5]</code> ) se produit.  Ici, la requ√™te renvoie une ligne: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  La requ√™te est ex√©cut√©e comme suit: <br><br><ol><li>  Dans la requ√™te de recherche ( <code>"days_of_week": [5]</code> ), des √©l√©ments (cl√©s de recherche) sont extraits: "days_of_week" et "5". <br></li><li>  Dans l'arborescence des √©l√©ments, les cl√©s extraites sont trouv√©es, et pour chacune d'elles la liste des TID est s√©lectionn√©e: pour "5" - (0.4), et pour "days_of_week" - (0,1), (0,2 ), (0,3), (0,4). <br></li><li>  De tous les TID trouv√©s, la fonction de coh√©rence s√©lectionne ceux qui correspondent √† l'op√©rateur dans la requ√™te.  Pour l'op√©rateur <code>@&gt;</code> , les documents qui ne contiennent pas tous les √©l√©ments de la requ√™te de recherche ne seront pas s√ªrs, donc il ne reste que (0,4).  Mais nous devons encore rev√©rifier le TID laiss√© avec la table car il n'est pas clair de l'index dans quel ordre les √©l√©ments trouv√©s se produisent dans le document JSON. <br></li></ol><br>  Pour d√©couvrir plus de d√©tails sur d'autres op√©rateurs, vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la documentation</a> . <br><br>  En plus des op√©rations conventionnelles pour traiter avec JSON, l'extension "jsquery" est depuis longtemps disponible, qui d√©finit un langage de requ√™te avec des capacit√©s plus riches (et certainement, avec le support des index GIN).  En outre, en 2016, une nouvelle norme SQL a √©t√© publi√©e, qui d√©finit son propre ensemble d'op√©rations et le langage de requ√™te "Chemin SQL / JSON".  Une impl√©mentation de cette norme a d√©j√† √©t√© r√©alis√©e et nous pensons qu'elle appara√Ætra dans PostgreSQL 11. <br><br><blockquote>  Le correctif de chemin SQL / JSON a finalement √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valid√©</a> pour PostgreSQL 12, tandis que d'autres √©l√©ments sont toujours en cours.  J'esp√®re que nous verrons la fonctionnalit√© enti√®rement impl√©ment√©e dans PostgreSQL 13. <br></blockquote><br><h2>  Internes </h2><br>  Nous pouvons regarder √† l'int√©rieur de l'index GIN en utilisant l'extension " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pageinspect</a> ". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Les informations de la m√©ta-page pr√©sentent des statistiques g√©n√©rales: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La structure de page</a> fournit une zone sp√©ciale o√π les m√©thodes d'acc√®s stockent leurs informations;  cette zone est "opaque" pour les programmes ordinaires tels que le vide.  La fonction "Gin_page_opaque_info" affiche ces donn√©es pour GIN.  Par exemple, nous pouvons apprendre √† conna√Ætre l'ensemble des pages d'index: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  La fonction "Gin_leafpage_items" fournit des informations sur les TID stock√©s sur les pages {donn√©es, feuille, compress√©es}: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Notez ici que les pages de gauche de l'arborescence des TID contiennent en fait de petites listes compress√©es de pointeurs vers les lignes de table plut√¥t que des pointeurs individuels. <br><br><h2>  Propri√©t√©s </h2><br>  Examinons les propri√©t√©s de la m√©thode d'acc√®s GIN (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont d√©j√† √©t√© fournies</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Fait int√©ressant, GIN prend en charge la cr√©ation d'index multicolonnes.  Cependant, contrairement √† un arbre B normal, au lieu de cl√©s compos√©es, un index multicolonne stockera toujours les √©l√©ments individuels et le num√©ro de colonne sera indiqu√© pour chaque √©l√©ment. <br><br>  Les propri√©t√©s de couche d'index suivantes sont disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Notez que le retour des r√©sultats TID par TID (balayage d'index) n'est pas pris en charge;  seul le scan bitmap est possible. <br><br>  Le scan vers l'arri√®re n'est pas pris en charge non plus: cette fonctionnalit√© est essentielle pour le scan d'index uniquement, mais pas pour le scan bitmap. <br><br>  Et ce qui suit sont des propri√©t√©s de couche de colonne: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Rien n'est disponible ici: pas de tri (ce qui est clair), pas d'utilisation de l'index comme couverture (puisque le document lui-m√™me n'est pas stock√© dans l'index), pas de manipulation de NULLs (car cela n'a pas de sens pour les √©l√©ments de type compos√©) . <br><br><h2>  Autres types de donn√©es </h2><br>  Quelques extensions suppl√©mentaires sont disponibles qui ajoutent la prise en charge de GIN pour certains types de donn√©es. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_trgm</a> " nous permet de d√©terminer la "ressemblance" des mots en comparant le nombre de s√©quences √©gales √† trois lettres (trigrammes) disponibles.  Deux classes d'op√©rateurs sont ajout√©es, "gist_trgm_ops" et "gin_trgm_ops", qui prennent en charge divers op√©rateurs, y compris la comparaison au moyen de LIKE et d'expressions r√©guli√®res.  Nous pouvons utiliser cette extension avec la recherche en texte int√©gral afin de sugg√©rer des options de mots pour corriger les fautes de frappe. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hstore</a> " impl√©mente le stockage "cl√©-valeur".  Pour ce type de donn√©es, des classes d'op√©rateur pour diff√©rentes m√©thodes d'acc√®s sont disponibles, y compris GIN.  Cependant, avec l'introduction du type de donn√©es "jsonb", il n'y a aucune raison particuli√®re d'utiliser "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intarray</a> " √©tend la fonctionnalit√© des tableaux entiers.  La prise en charge des index comprend GiST, ainsi que GIN (classe d'op√©rateur "gin__int_ops"). <br></li></ul><br>  Et ces deux extensions ont d√©j√† √©t√© mentionn√©es ci-dessus: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">btree_gin</a> " ajoute la prise en charge GIN pour les types de donn√©es r√©guliers afin qu'ils puissent √™tre utilis√©s dans un index multicolonne avec des types compos√©s. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsquery</a> " d√©finit un langage pour les requ√™tes JSON et une classe d'op√©rateur pour la prise en charge des index de ce langage.  Cette extension n'est pas incluse dans une livraison PostgreSQL standard. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448746/">https://habr.com/ru/post/fr448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448734/index.html">Des drones et des robots aident √† sauver la cath√©drale Notre-Dame de Paris</a></li>
<li><a href="../fr448738/index.html">Qui chasse les startups?</a></li>
<li><a href="../fr448740/index.html">Nous √©coutons de la musique SID (Commodore 64) via OPL3 sur des PC modernes</a></li>
<li><a href="../fr448742/index.html">Pandora's Box: nous analysons l'exploitation de la vuln√©rabilit√© WinRAR √† l'aide de l'exemple du job NeoQUEST-2019</a></li>
<li><a href="../fr448744/index.html">Comment transf√©rer une variable d'un fragment √† une activit√© dans Android?</a></li>
<li><a href="../fr448750/index.html">√Ä propos d'une vuln√©rabilit√© qui n'est pas</a></li>
<li><a href="../fr448754/index.html">Qui est qui en open source: biographies de geek</a></li>
<li><a href="../fr448756/index.html">Contexte: pourquoi Apple et Qualcomm se sont disput√©s, puis se sont r√©concili√©s</a></li>
<li><a href="../fr448758/index.html">Montre intelligente avec BASIC sur 6502 physique</a></li>
<li><a href="../fr448760/index.html">D√©veloppement dans le cloud, s√©curit√© de l'information et donn√©es personnelles: condens√© pour lecture le week-end depuis 1cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>