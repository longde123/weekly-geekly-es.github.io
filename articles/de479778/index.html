<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏾 🥃 📉 # Hinweis. Vorsicht vor atomaren Operationen in ConcurrentHashMap 🔭 🦂 👨🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java hat seit jeher eine wunderbare Kartenoberfläche und deren Implementierung, insbesondere HashMap . Und ab Java 5 gibt es auch ConcurrentHashMap . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1># Hinweis. Vorsicht vor atomaren Operationen in ConcurrentHashMap</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/krista/blog/479778/"><img src="https://habrastorage.org/webt/n3/kl/xh/n3klxhqmcb1xqgomjbzvprnoyvo.jpeg"><br><br>  Java hat seit jeher eine wunderbare <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Kartenoberfläche</a> und deren Implementierung, insbesondere <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> .  Und ab Java 5 gibt es auch <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> .  Betrachten Sie diese beiden Implementierungen, ihre Entwicklung und was diese Entwicklung zu unaufmerksamen Entwicklern führen kann. <br><br>  Warnung: In diesem Artikel werden Zitate aus dem OpenJDK 8-Quellcode verwendet, der unter der GNU General Public License Version 2 vertrieben wird. <br><a name="habracut"></a><br><h2>  Zeiten vor Java 8 </h2><br>  Diejenigen, die lange, lange Wartezeiten festgestellt haben, zuerst Java 7 und dann Java 8 (nicht wie jetzt alle sechs Monate eine neue Version), erinnern sich, welche Operationen mit Map am beliebtesten waren.  Das: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.put (K-Taste, V-Wert)</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.get (Objektschlüssel)</a> </li></ul><br>  Wenn Sie einen Wert in die Auflistung einfügen müssen, verwenden wir die erste Methode, und um den vorhandenen Wert abzurufen, verwenden Sie die zweite. <br><br>  Was aber, wenn eine verzögerte Initialisierung erforderlich ist?  Dann erschien ein Code dieser Art: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-comment"><span class="hljs-comment">//(1) if (result == null) { //(2) result = createValue(key); //(3) map.put(key, result); //(4) } return result; }</span></span></code> </pre> <br><ol><li>  Wir bekommen den Wert per Schlüssel </li><li>  Überprüfen Sie, ob der gewünschte Wert gefunden wurde </li><li>  Wenn kein Wert gefunden wird, erstellen Sie ihn </li><li>  Mehrwert für die Sammlung durch Schlüssel </li></ol><br>  Es stellt sich als etwas umständlich heraus, nicht wahr?  Wenn eine einfache HashMap verwendet wird, ist dies nur Code, dessen Lesen unbequem ist, weil  er ist nicht eingefädelt.  Bei ConcurrentHashMap wird jedoch eine zusätzliche Funktion angezeigt: Die Methode createValue (2) kann mehrmals aufgerufen werden, wenn mehrere Threads die Bedingung (1) überprüfen, bevor einer von ihnen den Wert in collection (3) schreibt.  Ein solches Verhalten kann häufig zu unerwünschten Folgen führen. <br><br>  Vor Java 8 gab es einfach keine eleganten Optionen.  Wenn Sie mehreren Wertschöpfungen ausweichen mussten, mussten Sie zusätzliche Sperren verwenden. <br>  Java 8 hat es einfacher gemacht.  Es scheint ... <br><br><h2>  Java 8 kommt zu uns ... </h2><br>  Was ist die am meisten erwartete Funktion, die uns mit Java 8 begegnet ist?  Das stimmt, Lambda.  Und nicht nur Lamas, sondern deren Unterstützung in allen APIs der Standardbibliothek.  Kartendatenstrukturen wurden nicht ignoriert.  Insbesondere gab es Methoden wie: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfAbsent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfPresent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">für jeden</a> </li><li>  usw. </li></ul><br>  Aufgrund dieser Methoden ist es viel einfacher, den zuvor angegebenen Code umzuschreiben: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br>  Es ist klar, dass niemand die Gelegenheit aufgeben wird, seinen Code zu vereinfachen.  Darüber hinaus wird im Fall von ConcurrentHashMap die <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">computeIfAbsent-</a> Methode auch atomar ausgeführt.  Das heißt  createValue wird genau einmal und nur dann aufgerufen, wenn der gewünschte Wert fehlt. <br><br>  IDE ging auch nicht vorbei.  IntelliJ IDEA bietet daher die automatische Ersetzung der alten durch die neue Version an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/5r/nr/ir5rnrjz71vghcycvujmdcunyho.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/uu/ox/eyuuoxjeyqhfc8k3wxq46dlv26m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sz/6n/br/sz6nbrvaq_-sbj2ljwxktdnxw1y.png"></div><br>  Es ist klar, dass sowohl die Code-Vereinfachung als auch die IDE-Hinweise die Entwickler ermutigen, diese neue API zu verwenden.  Infolgedessen tauchte derselbe computeIfAbsent an so vielen Stellen im Code auf. <br>  Tschüss… <br><br><h2>  Ganz plötzlich! </h2><br>  Bis die Zeit für den nächsten Belastungstest gekommen ist.  Und dann erschien eine schreckliche Sache: <br><br><img src="https://habrastorage.org/webt/1i/o1/5q/1io15qqi3scznkqnzuemfbbe61g.png"><br><br>  Die Anwendung arbeitete auf der folgenden Version von Java: <br><br><pre> openjdk version "1.8.0_222"
 OpenJDK-Laufzeitumgebung (Build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (Build 25.222-b10, gemischter Modus)
</pre><br><br>  Für diejenigen, die mit so einem wunderbaren Tool wie <a href="https://www.yourkit.com/features/">YourKit</a> nicht vertraut sind. <br><br>  Im Screenshot zeigen horizontale breite Linien die zeitliche Funktionsweise der Anwendungsthreads.  Je nach Zustand des Streams zu einem bestimmten Zeitpunkt wird der Streifen in der entsprechenden Farbe lackiert: <br><br><ul><li>  gelb - der Strom ist im Leerlauf und wartet auf Arbeit; </li><li>  grün - der Thread läuft und führt Programmcode aus; </li><li>  rot - Dieser Thread wird von einem anderen Thread blockiert. </li></ul><br>  Das heißt, es stellt sich heraus, dass fast alle Threads (und in der Tat gab es viel mehr als das, was im Screenshot gezeigt wird) fast die ganze Zeit in einem gesperrten Zustand sind.  Und für alle ist die Sperre in der gleichen computeIfAbsent von ConcurrentHashMap!  Und dies trotz der Tatsache, dass aufgrund der Besonderheiten dieses speziellen Belastungstests nicht mehr als 6-8 Werte in dieser Sammlung gespeichert werden können.  Das heißt  Bei fast allen Vorgängen an einem bestimmten Ort werden ausschließlich die vorhandenen Werte gelesen. <br><br>  Aber warte, wie so?  Selbst in der Dokumentation der Methode zum Blockieren heißt es nur in der Anwendung zum Aktualisieren: <br>  "Wenn der angegebene Schlüssel noch keinem Wert zugeordnet ist, wird versucht, seinen Wert mit der angegebenen Zuordnungsfunktion zu berechnen, und er wird in diese Zuordnung eingegeben, sofern er nicht null ist.  Der gesamte Methodenaufruf wird atomar ausgeführt, sodass die Funktion höchstens einmal pro Taste angewendet wird.  Einige versuchte Aktualisierungsvorgänge für diese Karte durch andere Threads werden möglicherweise blockiert, während die Berechnung ausgeführt wird. Daher sollte die Berechnung kurz und einfach sein und es darf nicht versucht werden, andere Zuordnungen dieser Karte zu aktualisieren. “ <br><br>  In der Tat ist nicht alles ganz so.  Wenn Sie sich den Quellcode dieser Methode ansehen, stellt sich heraus, dass sie zwei sehr dicke Synchronisationsblöcke enthält: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung von ConcurrentHashMap.computeIfAbsent</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeIfAbsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K, ? extends V&gt; mappingFunction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mappingFunction == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); V val = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> binCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, i, fh; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || (n = tab.length) == <span class="hljs-number"><span class="hljs-number">0</span></span>) tab = initTable(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((f = tabAt(tab, i = (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Node&lt;K,V&gt; r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReservationNode&lt;K,V&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (casTabAt(tab, i, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, r)) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; Node&lt;K,V&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { setTabAt(tab, i, node); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> added = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tabAt(tab, i) == f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; V ev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) { val = e.val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Node&lt;K,V&gt; pred = e; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((e = e.next) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; pred.next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TreeBin) { binCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((r = t.root) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (p = r.findTreeNode(h, key, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) val = p.val; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t.putTreeVal(h, key, val); } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!added) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) addCount(<span class="hljs-number"><span class="hljs-number">1L</span></span>, binCount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre><br></div></div><br>  Aus dem obigen Beispiel ist ersichtlich, dass das Ergebnis nur an sechs Punkten gebildet werden kann und dass sich fast alle diese Stellen innerhalb von Synchronisationsblöcken befinden.  Ganz unerwartet.  Darüber hinaus enthält ein einfaches <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">Get</a> überhaupt keine Synchronisation: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung von ConcurrentHashMap.get</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, eh; K ek; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tab = table) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (e = tabAt(tab, (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((eh = e.hash) == h) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eh &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (p = e.find(h, key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? p.val : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((e = e.next) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br></div></div><br>  Also, was ist zu tun?  Tatsächlich gibt es nur zwei Möglichkeiten: entweder zum ursprünglichen Code zurückkehren oder ihn verwenden, jedoch in einer leicht modifizierten Version: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) ? result : map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br><h2>  Fazit </h2><br>  Im Allgemeinen erwiesen sich solche fatalen Folgen von scheinbar banalem Refactoring als sehr unerwartet.  Die Situation wurde nur durch die Anwesenheit eines Stresstests gerettet, der eine Verschlechterung erfolgreich aufzeigte. <br><br>  Glücklicherweise haben neuere Versionen von Java dieses Problem <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">behoben</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> . <br><br>  Also sei vorsichtig, vertraue nicht den verlockenden Tipps und schreibe Tests.  Besonders stressig. <br><br>  Java an alle! <br><br>  <b>UPD1:</b> Wie von <a href="https://habr.com/ru/users/coldwind/" class="user_link">Kaltwind</a> richtig festgestellt, ist das Problem bekannt: <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> .  Und anscheinend wurde es für Java 9 behoben. Zum Zeitpunkt der Veröffentlichung des Artikels in Java 8, Java 11 und sogar Java 13 blieb diese Methode unverändert. <br><br>  <b>UPD2:</b> <a href="https://habr.com/ru/users/vkovalchuk/" class="user_link">vkovalchuk</a> hat mich wegen Nachlässigkeit erwischt.  Tatsächlich wird das Problem ab Java 9 behoben, indem eine weitere Bedingung mit der Rückgabe des Ergebnisses hinzugefügt wird, ohne Folgendes zu blockieren: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh == h <span class="hljs-comment"><span class="hljs-comment">// check first node without acquiring lock &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk))) &amp;&amp; (fv = f.val) != null) return fv;</span></span></code> </pre><br><br>  Anfangs bin ich in der nächsten Java-Version auf eine Situation gestoßen: <br><br><pre> openjdk version "1.8.0_222"
 OpenJDK-Laufzeitumgebung (Build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (Build 25.222-b10, gemischter Modus)
</pre><br><br>  Und als ich mir die Quellen späterer Versionen ansah, vermisste ich ehrlich diese Zeilen, was mich in die Irre führte. <br><br>  Aus Gründen der Gerechtigkeit habe ich den Haupttext des Artikels korrigiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479778/">https://habr.com/ru/post/de479778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479762/index.html">Die 6 häufigsten Fehler, die Entwickler beim Schreiben von HTML und CSS machen</a></li>
<li><a href="../de479764/index.html">Die Zahl der Privatinvestoren an der Moskauer Börse überstieg 3,5 Millionen Menschen</a></li>
<li><a href="../de479768/index.html">Installieren und Konfigurieren von AlienVault SIEM (OSSIM)</a></li>
<li><a href="../de479774/index.html">Erzählung durch die Umgebung oder warum Schnittszenen kein Allheilmittel sind</a></li>
<li><a href="../de479776/index.html">Berufsreisen: Wie Stewardessen leben</a></li>
<li><a href="../de479780/index.html">DevOps Moscow Meetup 17/12: Nehmen Sie an der Sendung teil</a></li>
<li><a href="../de479790/index.html">Drei Inkubatoren führten Prototyping-Kurse für die erste Gruppe von Studenten durch</a></li>
<li><a href="../de479794/index.html">Wir kombinieren den "Kinder" Mikrocontroller und Brettspiele</a></li>
<li><a href="../de479796/index.html">Kingstons Thanos Level-Bedrohung</a></li>
<li><a href="../de479800/index.html">Ich schreibe in C #, damit das Front-End einfacher ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>