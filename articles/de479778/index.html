<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèæ ü•É üìâ # Hinweis. Vorsicht vor atomaren Operationen in ConcurrentHashMap üî≠ ü¶Ç üë®üèª‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java hat seit jeher eine wunderbare Kartenoberfl√§che und deren Implementierung, insbesondere HashMap . Und ab Java 5 gibt es auch ConcurrentHashMap . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1># Hinweis. Vorsicht vor atomaren Operationen in ConcurrentHashMap</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/krista/blog/479778/"><img src="https://habrastorage.org/webt/n3/kl/xh/n3klxhqmcb1xqgomjbzvprnoyvo.jpeg"><br><br>  Java hat seit jeher eine wunderbare <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Kartenoberfl√§che</a> und deren Implementierung, insbesondere <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> .  Und ab Java 5 gibt es auch <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> .  Betrachten Sie diese beiden Implementierungen, ihre Entwicklung und was diese Entwicklung zu unaufmerksamen Entwicklern f√ºhren kann. <br><br>  Warnung: In diesem Artikel werden Zitate aus dem OpenJDK 8-Quellcode verwendet, der unter der GNU General Public License Version 2 vertrieben wird. <br><a name="habracut"></a><br><h2>  Zeiten vor Java 8 </h2><br>  Diejenigen, die lange, lange Wartezeiten festgestellt haben, zuerst Java 7 und dann Java 8 (nicht wie jetzt alle sechs Monate eine neue Version), erinnern sich, welche Operationen mit Map am beliebtesten waren.  Das: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.put (K-Taste, V-Wert)</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.get (Objektschl√ºssel)</a> </li></ul><br>  Wenn Sie einen Wert in die Auflistung einf√ºgen m√ºssen, verwenden wir die erste Methode, und um den vorhandenen Wert abzurufen, verwenden Sie die zweite. <br><br>  Was aber, wenn eine verz√∂gerte Initialisierung erforderlich ist?  Dann erschien ein Code dieser Art: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-comment"><span class="hljs-comment">//(1) if (result == null) { //(2) result = createValue(key); //(3) map.put(key, result); //(4) } return result; }</span></span></code> </pre> <br><ol><li>  Wir bekommen den Wert per Schl√ºssel </li><li>  √úberpr√ºfen Sie, ob der gew√ºnschte Wert gefunden wurde </li><li>  Wenn kein Wert gefunden wird, erstellen Sie ihn </li><li>  Mehrwert f√ºr die Sammlung durch Schl√ºssel </li></ol><br>  Es stellt sich als etwas umst√§ndlich heraus, nicht wahr?  Wenn eine einfache HashMap verwendet wird, ist dies nur Code, dessen Lesen unbequem ist, weil  er ist nicht eingef√§delt.  Bei ConcurrentHashMap wird jedoch eine zus√§tzliche Funktion angezeigt: Die Methode createValue (2) kann mehrmals aufgerufen werden, wenn mehrere Threads die Bedingung (1) √ºberpr√ºfen, bevor einer von ihnen den Wert in collection (3) schreibt.  Ein solches Verhalten kann h√§ufig zu unerw√ºnschten Folgen f√ºhren. <br><br>  Vor Java 8 gab es einfach keine eleganten Optionen.  Wenn Sie mehreren Wertsch√∂pfungen ausweichen mussten, mussten Sie zus√§tzliche Sperren verwenden. <br>  Java 8 hat es einfacher gemacht.  Es scheint ... <br><br><h2>  Java 8 kommt zu uns ... </h2><br>  Was ist die am meisten erwartete Funktion, die uns mit Java 8 begegnet ist?  Das stimmt, Lambda.  Und nicht nur Lamas, sondern deren Unterst√ºtzung in allen APIs der Standardbibliothek.  Kartendatenstrukturen wurden nicht ignoriert.  Insbesondere gab es Methoden wie: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfAbsent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfPresent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">f√ºr jeden</a> </li><li>  usw. </li></ul><br>  Aufgrund dieser Methoden ist es viel einfacher, den zuvor angegebenen Code umzuschreiben: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br>  Es ist klar, dass niemand die Gelegenheit aufgeben wird, seinen Code zu vereinfachen.  Dar√ºber hinaus wird im Fall von ConcurrentHashMap die <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">computeIfAbsent-</a> Methode auch atomar ausgef√ºhrt.  Das hei√üt  createValue wird genau einmal und nur dann aufgerufen, wenn der gew√ºnschte Wert fehlt. <br><br>  IDE ging auch nicht vorbei.  IntelliJ IDEA bietet daher die automatische Ersetzung der alten durch die neue Version an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/5r/nr/ir5rnrjz71vghcycvujmdcunyho.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/uu/ox/eyuuoxjeyqhfc8k3wxq46dlv26m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sz/6n/br/sz6nbrvaq_-sbj2ljwxktdnxw1y.png"></div><br>  Es ist klar, dass sowohl die Code-Vereinfachung als auch die IDE-Hinweise die Entwickler ermutigen, diese neue API zu verwenden.  Infolgedessen tauchte derselbe computeIfAbsent an so vielen Stellen im Code auf. <br>  Tsch√ºss‚Ä¶ <br><br><h2>  Ganz pl√∂tzlich! </h2><br>  Bis die Zeit f√ºr den n√§chsten Belastungstest gekommen ist.  Und dann erschien eine schreckliche Sache: <br><br><img src="https://habrastorage.org/webt/1i/o1/5q/1io15qqi3scznkqnzuemfbbe61g.png"><br><br>  Die Anwendung arbeitete auf der folgenden Version von Java: <br><br><pre> openjdk version "1.8.0_222"
 OpenJDK-Laufzeitumgebung (Build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (Build 25.222-b10, gemischter Modus)
</pre><br><br>  F√ºr diejenigen, die mit so einem wunderbaren Tool wie <a href="https://www.yourkit.com/features/">YourKit</a> nicht vertraut sind. <br><br>  Im Screenshot zeigen horizontale breite Linien die zeitliche Funktionsweise der Anwendungsthreads.  Je nach Zustand des Streams zu einem bestimmten Zeitpunkt wird der Streifen in der entsprechenden Farbe lackiert: <br><br><ul><li>  gelb - der Strom ist im Leerlauf und wartet auf Arbeit; </li><li>  gr√ºn - der Thread l√§uft und f√ºhrt Programmcode aus; </li><li>  rot - Dieser Thread wird von einem anderen Thread blockiert. </li></ul><br>  Das hei√üt, es stellt sich heraus, dass fast alle Threads (und in der Tat gab es viel mehr als das, was im Screenshot gezeigt wird) fast die ganze Zeit in einem gesperrten Zustand sind.  Und f√ºr alle ist die Sperre in der gleichen computeIfAbsent von ConcurrentHashMap!  Und dies trotz der Tatsache, dass aufgrund der Besonderheiten dieses speziellen Belastungstests nicht mehr als 6-8 Werte in dieser Sammlung gespeichert werden k√∂nnen.  Das hei√üt  Bei fast allen Vorg√§ngen an einem bestimmten Ort werden ausschlie√ülich die vorhandenen Werte gelesen. <br><br>  Aber warte, wie so?  Selbst in der Dokumentation der Methode zum Blockieren hei√üt es nur in der Anwendung zum Aktualisieren: <br>  "Wenn der angegebene Schl√ºssel noch keinem Wert zugeordnet ist, wird versucht, seinen Wert mit der angegebenen Zuordnungsfunktion zu berechnen, und er wird in diese Zuordnung eingegeben, sofern er nicht null ist.  Der gesamte Methodenaufruf wird atomar ausgef√ºhrt, sodass die Funktion h√∂chstens einmal pro Taste angewendet wird.  Einige versuchte Aktualisierungsvorg√§nge f√ºr diese Karte durch andere Threads werden m√∂glicherweise blockiert, w√§hrend die Berechnung ausgef√ºhrt wird. Daher sollte die Berechnung kurz und einfach sein und es darf nicht versucht werden, andere Zuordnungen dieser Karte zu aktualisieren. ‚Äú <br><br>  In der Tat ist nicht alles ganz so.  Wenn Sie sich den Quellcode dieser Methode ansehen, stellt sich heraus, dass sie zwei sehr dicke Synchronisationsbl√∂cke enth√§lt: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung von ConcurrentHashMap.computeIfAbsent</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeIfAbsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K, ? extends V&gt; mappingFunction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mappingFunction == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); V val = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> binCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, i, fh; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || (n = tab.length) == <span class="hljs-number"><span class="hljs-number">0</span></span>) tab = initTable(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((f = tabAt(tab, i = (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Node&lt;K,V&gt; r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReservationNode&lt;K,V&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (casTabAt(tab, i, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, r)) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; Node&lt;K,V&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { setTabAt(tab, i, node); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> added = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tabAt(tab, i) == f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; V ev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) { val = e.val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Node&lt;K,V&gt; pred = e; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((e = e.next) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; pred.next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TreeBin) { binCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((r = t.root) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (p = r.findTreeNode(h, key, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) val = p.val; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t.putTreeVal(h, key, val); } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!added) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) addCount(<span class="hljs-number"><span class="hljs-number">1L</span></span>, binCount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre><br></div></div><br>  Aus dem obigen Beispiel ist ersichtlich, dass das Ergebnis nur an sechs Punkten gebildet werden kann und dass sich fast alle diese Stellen innerhalb von Synchronisationsbl√∂cken befinden.  Ganz unerwartet.  Dar√ºber hinaus enth√§lt ein einfaches <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">Get</a> √ºberhaupt keine Synchronisation: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung von ConcurrentHashMap.get</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, eh; K ek; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tab = table) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (e = tabAt(tab, (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((eh = e.hash) == h) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eh &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (p = e.find(h, key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? p.val : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((e = e.next) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br></div></div><br>  Also, was ist zu tun?  Tats√§chlich gibt es nur zwei M√∂glichkeiten: entweder zum urspr√ºnglichen Code zur√ºckkehren oder ihn verwenden, jedoch in einer leicht modifizierten Version: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) ? result : map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br><h2>  Fazit </h2><br>  Im Allgemeinen erwiesen sich solche fatalen Folgen von scheinbar banalem Refactoring als sehr unerwartet.  Die Situation wurde nur durch die Anwesenheit eines Stresstests gerettet, der eine Verschlechterung erfolgreich aufzeigte. <br><br>  Gl√ºcklicherweise haben neuere Versionen von Java dieses Problem <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">behoben</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> . <br><br>  Also sei vorsichtig, vertraue nicht den verlockenden Tipps und schreibe Tests.  Besonders stressig. <br><br>  Java an alle! <br><br>  <b>UPD1:</b> Wie von <a href="https://habr.com/ru/users/coldwind/" class="user_link">Kaltwind</a> richtig festgestellt, ist das Problem bekannt: <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> .  Und anscheinend wurde es f√ºr Java 9 behoben. Zum Zeitpunkt der Ver√∂ffentlichung des Artikels in Java 8, Java 11 und sogar Java 13 blieb diese Methode unver√§ndert. <br><br>  <b>UPD2:</b> <a href="https://habr.com/ru/users/vkovalchuk/" class="user_link">vkovalchuk</a> hat mich wegen Nachl√§ssigkeit erwischt.  Tats√§chlich wird das Problem ab Java 9 behoben, indem eine weitere Bedingung mit der R√ºckgabe des Ergebnisses hinzugef√ºgt wird, ohne Folgendes zu blockieren: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh == h <span class="hljs-comment"><span class="hljs-comment">// check first node without acquiring lock &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk))) &amp;&amp; (fv = f.val) != null) return fv;</span></span></code> </pre><br><br>  Anfangs bin ich in der n√§chsten Java-Version auf eine Situation gesto√üen: <br><br><pre> openjdk version "1.8.0_222"
 OpenJDK-Laufzeitumgebung (Build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (Build 25.222-b10, gemischter Modus)
</pre><br><br>  Und als ich mir die Quellen sp√§terer Versionen ansah, vermisste ich ehrlich diese Zeilen, was mich in die Irre f√ºhrte. <br><br>  Aus Gr√ºnden der Gerechtigkeit habe ich den Haupttext des Artikels korrigiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479778/">https://habr.com/ru/post/de479778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479762/index.html">Die 6 h√§ufigsten Fehler, die Entwickler beim Schreiben von HTML und CSS machen</a></li>
<li><a href="../de479764/index.html">Die Zahl der Privatinvestoren an der Moskauer B√∂rse √ºberstieg 3,5 Millionen Menschen</a></li>
<li><a href="../de479768/index.html">Installieren und Konfigurieren von AlienVault SIEM (OSSIM)</a></li>
<li><a href="../de479774/index.html">Erz√§hlung durch die Umgebung oder warum Schnittszenen kein Allheilmittel sind</a></li>
<li><a href="../de479776/index.html">Berufsreisen: Wie Stewardessen leben</a></li>
<li><a href="../de479780/index.html">DevOps Moscow Meetup 17/12: Nehmen Sie an der Sendung teil</a></li>
<li><a href="../de479790/index.html">Drei Inkubatoren f√ºhrten Prototyping-Kurse f√ºr die erste Gruppe von Studenten durch</a></li>
<li><a href="../de479794/index.html">Wir kombinieren den "Kinder" Mikrocontroller und Brettspiele</a></li>
<li><a href="../de479796/index.html">Kingstons Thanos Level-Bedrohung</a></li>
<li><a href="../de479800/index.html">Ich schreibe in C #, damit das Front-End einfacher ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>