<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💿 👨🏼‍💻 👩🏻‍🍳 Nous faisons un projet d'apprentissage automatique en Python. Partie 1 👩🏿‍🍳 ㊙️ 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traduction d' une visite guidée complète d'un projet d'apprentissage automatique en Python: première partie . 

 Lorsque vous lisez un livre ou écoute...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous faisons un projet d'apprentissage automatique en Python. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/425253/"><img src="https://habrastorage.org/getpro/habr/post_images/5de/fed/62e/5defed62ea348f6e02365e283415b2fb.png"><br><br>  <i>Traduction d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une visite guidée complète d'un projet d'apprentissage automatique en Python: première partie</a> .</i> <br><br>  Lorsque vous lisez un livre ou écoutez un cours de formation sur l'analyse des données, vous avez souvent l'impression que vous êtes face à des parties distinctes d'une image qui ne peuvent pas être assemblées.  Vous pouvez être effrayé par la perspective de passer à l'étape suivante et de résoudre complètement un problème à l'aide de l'apprentissage automatique, mais avec l'aide de cette série d'articles, vous gagnerez en confiance dans la capacité de résoudre tout problème dans le domaine de la science des données. <br><br>  Afin que vous ayez enfin une image complète dans votre tête, nous vous suggérons d'analyser du début à la fin le projet d'utilisation du machine learning en utilisant des données réelles. <br><a name="habracut"></a><br>  Suivez successivement les étapes: <br><br><ol><li>  Nettoyage et formatage des données. </li><li>  Analyse exploratoire des données. </li><li>  Conception et sélection de fonctionnalités. </li><li>  Comparaison des métriques de plusieurs modèles d'apprentissage automatique. </li><li>  Réglage hyperparamétrique du meilleur modèle. </li><li>  Évaluation du meilleur modèle sur un ensemble de données de test. </li><li>  Interprétation des résultats du modèle. </li><li>  Conclusions et travail avec des documents. </li></ol><br>  Vous apprendrez comment les étapes s'enchaînent et comment les implémenter en Python.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'ensemble du projet</a> est disponible sur GitHub, la première partie se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a>  Dans cet article, nous considérerons les trois premières étapes. <br><br><h2>  Description de la tâche </h2><br>  Avant d'écrire du code, vous devez comprendre le problème résolu et les données disponibles.  Dans ce projet, nous travaillerons avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des données d'efficacité énergétique</a> accessibles au public <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour les bâtiments</a> de New York. <br><br>  Notre objectif: utiliser les données disponibles pour construire un modèle qui prédit le nombre de Energy Star Score pour un bâtiment particulier, et interpréter les résultats pour trouver des facteurs qui influencent le score final. <br><br>  Les données incluent déjà le score Energy Star attribué, notre tâche est donc l'apprentissage automatique avec régression contrôlée: <br><br><ul><li>  Supervisé: Nous connaissons les signes et le but, et notre tâche est de former un modèle qui peut comparer le premier avec le second. </li><li>  Régression: le score Energy Star est une variable continue. </li></ul><br>  Notre modèle doit être précis - afin qu'il puisse prédire la valeur du score Energy Star proche de la vérité - et interprétable - afin que nous puissions comprendre ses prédictions.  Connaissant les données cibles, nous pouvons les utiliser pour prendre des décisions à mesure que nous approfondissons les données et créons le modèle. <br><br><h2>  Nettoyage des données </h2><br>  Tous les ensembles de données ne sont pas un ensemble d'observations parfaitement assorties, sans anomalies et valeurs manquantes (un indice des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeux de données mtcars</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">iris</a> ).  Dans les données réelles, il y a peu d'ordre, donc avant de commencer l'analyse, vous devez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effacer et la mettre</a> dans un format acceptable.  Le nettoyage des données est une procédure désagréable mais obligatoire pour résoudre la plupart des tâches d'analyse des données. <br><br>  Tout d'abord, vous pouvez charger les données sous la forme d'une trame de données Pandas et les examiner: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np # <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a dataframe data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'data/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv'</span></span>) # Display top <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> dataframe data.head()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/4ac/637/b86/4ac637b8682b2fcacddd155004681a0d.png"><br>  <i>Voilà à quoi ressemblent les vraies données.</i> <br><br>  Ceci est un fragment d'un tableau de 60 colonnes.  Même ici, plusieurs problèmes sont visibles: nous devons prédire le <code>Energy Star Score</code> , mais nous ne savons pas ce que signifient toutes ces colonnes.  Bien que ce ne soit pas nécessairement un problème, car vous pouvez souvent créer un modèle précis sans rien savoir des variables.  Mais l'interprétabilité est importante pour nous, nous devons donc trouver la signification d'au moins quelques colonnes. <br><br>  Lorsque nous avons reçu ces données, nous n'avons pas posé de questions sur les valeurs, mais nous avons examiné le nom du fichier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a86/c00/ab2/a86c00ab2d64629e644e7186c78724f7.png"><br><br>  et a décidé de rechercher «Local Law 84».  Nous avons trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette page</a> , qui disait que nous parlons de la loi en vigueur à New York, selon laquelle les propriétaires de tous les bâtiments d'une certaine taille devraient rendre compte de la consommation d'énergie.  Une recherche supplémentaire a permis de trouver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">toutes les valeurs de colonne</a> .  Ne négligez donc pas les noms de fichiers, ils peuvent être un bon point de départ.  De plus, c'est un rappel que vous ne vous précipitez pas et ne manquez pas quelque chose d'important! <br><br>  Nous n'étudierons pas toutes les colonnes, mais nous traiterons certainement du score Energy Star, qui est décrit comme suit: <br><br><blockquote>  Le rang centile est compris entre 1 et 100, qui est calculé sur la base des rapports annuels sur la consommation d'énergie par les propriétaires de bâtiments eux-mêmes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le Energy Star Score</a> est une mesure relative utilisée pour comparer la performance énergétique des bâtiments. </blockquote><br>  Le premier problème a été résolu, mais le second est resté - des valeurs manquantes, marquées comme «Non disponible».  Il s'agit d'une valeur de chaîne en Python, ce qui signifie que même les chaînes avec des nombres seront stockées en tant que types de données d' <code>object</code> , car s'il y a une chaîne dans la colonne, Pandas la convertit en une colonne entièrement constituée de chaîne.  Les types de données de colonne peuvent être trouvés en utilisant la méthode <code>dataframe.info()</code> : <br><br><pre> <code class="hljs pgsql"># See the <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> non-missing <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> data.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/db3/b4d/013/db3b4d013ca25d7e5ac483f0c24fa1e4.png"><br><br>  Certes, certaines colonnes qui contiennent explicitement des nombres (comme ft²) sont stockées en tant qu'objets.  Nous ne pouvons pas appliquer l'analyse numérique aux valeurs de chaîne, nous les convertissons donc en types de données numériques (en particulier <code>float</code> )! <br><br>  Ce code remplace d'abord tous les «Non disponibles» par <i>pas un nombre</i> ( <code>np.nan</code> ), qui peut être interprété comme des nombres, puis convertit le contenu de certaines colonnes en un type <code>float</code> : <br><br><pre> <code class="hljs pgsql"># Replace <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> occurrences <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Available <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a number data = data.replace({<span class="hljs-string"><span class="hljs-string">'Not Available'</span></span>: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # Iterate through the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(data.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>): # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> that should be <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'ft²'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kBtu'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Metric Tons CO2e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kWh'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'therms'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'gal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Score'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col): # Convert the data <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> data[col] = data[col].astype(<span class="hljs-type"><span class="hljs-type">float</span></span>)</code> </pre> <br>  Lorsque les valeurs dans les colonnes correspondantes avec nous deviennent des nombres, nous pouvons commencer à examiner les données. <br><br><h4>  Données manquantes et anormales </h4><br>  Outre les types de données incorrects, l'un des problèmes les plus courants est l'absence de valeurs.  Ils peuvent être absents pour diverses raisons et avant de former le modèle, ces valeurs doivent être remplies ou supprimées.  Tout d'abord, découvrons combien de valeurs nous avons dans chaque colonne (le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code est ici</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b0/5da/a40/0b05daa40ba77acca25ed859856759f2.png"><br>  <i>Pour créer une table, une fonction d'une branche sur <u>StackOverflow a été utilisée</u> .</i> <br><br>  Les informations doivent toujours être supprimées avec prudence, et s'il existe de nombreuses valeurs dans la colonne, cela ne profitera probablement pas à notre modèle.  Le seuil après lequel il est préférable de jeter les colonnes dépend de votre tâche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici une discussion</a> ), et dans notre projet, nous supprimerons les colonnes qui sont plus de la moitié vides. <br><br>  À ce stade également, il est préférable de supprimer les valeurs anormales.  Ils peuvent se produire en raison de fautes de frappe lors de la saisie de données ou en raison d'erreurs dans les unités de mesure, ou ils peuvent être corrects, mais des valeurs extrêmes.  Dans ce cas, nous supprimerons les valeurs "extra", guidées par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">définition des anomalies extrêmes</a> : <br><br><ul><li>  Sous le premier quartile se trouve une plage interquartile de 3 ∗. </li><li>  Au-dessus du troisième quartile + 3 ∗ intervalle interquartile. </li></ul><br>  Le code qui supprime les colonnes et les anomalies est répertorié sur le Bloc-notes sur Github.  À la fin du processus de nettoyage des données et de la suppression des anomalies, nous avons plus de 11 000 bâtiments et 49 panneaux. <br><br><h2>  Analyse exploratoire des données </h2><br>  L'étape ennuyeuse mais nécessaire du nettoyage des données est terminée, vous pouvez aller à l'étude!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'analyse des données exploratoires</a> (RAD) est un processus à durée illimitée au cours duquel nous calculons des statistiques et recherchons des tendances, des anomalies, des modèles ou des relations dans les données. <br><br>  En bref, RAD est une tentative de comprendre ce que les données peuvent nous dire.  Habituellement, l'analyse commence par une revue superficielle, puis nous trouvons des fragments intéressants et les analysons plus en détail.  Les résultats peuvent être intéressants en soi, ou ils peuvent contribuer au choix du modèle, aidant à décider quelles fonctionnalités nous utiliserons. <br><br><h4>  Graphes à variable unique </h4><br>  Notre objectif est de prédire la valeur du score Energy Star (renommé notre <code>score</code> dans nos données), il est donc logique de commencer par examiner la distribution de cette variable.  Un histogramme est un moyen simple mais efficace de visualiser la distribution d'une seule variable, et il peut être facilement construit à l'aide de <code>matplotlib</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt # Histogram <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the Energy Star Score plt.style.use(<span class="hljs-string"><span class="hljs-string">'fivethirtyeight'</span></span>) plt.hist(data[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), bins = <span class="hljs-number"><span class="hljs-number">100</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'k'</span></span>); plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Score'</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Number of Buildings'</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Energy Star Score Distribution'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/f82/bf3/84a/f82bf384af1bd0c407f1e680d0b47263.png"><br><br>  Ça a l'air suspect!  Le score Energy Star est un centile, vous devez donc vous attendre à une distribution uniforme lorsque chaque point est attribué au même nombre de bâtiments.  Cependant, un nombre disproportionnellement élevé de bâtiments a obtenu les résultats les plus élevés et les plus bas (pour le Energy Star Score, le plus grand est le mieux). <br><br>  Si nous regardons à nouveau la définition de ce score, nous verrons qu'il est calculé sur la base de «rapports remplis indépendamment par les propriétaires d'immeubles», ce qui peut expliquer l'excès de très grandes valeurs.  Demander aux propriétaires de bâtiments de déclarer leur consommation d'énergie, c'est comme demander aux étudiants de déclarer leurs notes aux examens.  Ce n'est donc peut-être pas le critère le plus objectif pour évaluer l'efficacité énergétique d'un bien immobilier. <br><br>  Si nous avions une quantité illimitée de temps, nous pourrions découvrir pourquoi tant de bâtiments ont obtenu des points très élevés et très bas.  Pour ce faire, il faudrait choisir les bâtiments appropriés et les analyser soigneusement.  Mais nous devons seulement apprendre à prédire les scores et ne pas développer une méthode d'évaluation plus précise.  Vous pouvez noter que les points ont une distribution suspecte, mais nous nous concentrerons sur les prévisions. <br><br><h4>  Recherche de relation </h4><br>  La partie principale de l'AHFR est la recherche de la relation entre les signes et notre objectif.  Les variables en corrélation avec lui sont utiles pour une utilisation dans le modèle, car elles peuvent être utilisées pour la prévision.  Une façon d'étudier l'effet d'une variable catégorielle (qui ne prend qu'un ensemble limité de valeurs) sur l'objectif est de tracer la densité à l'aide de la bibliothèque Seaborn. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le graphique de densité peut être considéré comme un histogramme lissé</a> car il montre la distribution d'une seule variable.  Vous pouvez coloriser des classes individuelles sur le graphique pour voir comment une variable catégorielle modifie la distribution.  Ce code trace le graphique de densité Energy Star Score, coloré selon le type de bâtiment (pour une liste de bâtiments de plus de 100 dimensions): <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> a list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> more than <span class="hljs-number"><span class="hljs-number">100</span></span> measurements <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = data.dropna(subset=[<span class="hljs-string"><span class="hljs-string">'score'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>].value_counts() <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = list(<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span> &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> distribution <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> scores <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building categories figsize(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> building <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the building <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subset = data[data[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>] == b_type] # Density plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Energy Star Scores sns.kdeplot(subset[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), label = b_type, shade = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.8</span></span>); # label the plot plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Energy Star Score'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Density'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Density Plot of Energy Star Scores by Building Type'</span></span>, size = <span class="hljs-number"><span class="hljs-number">28</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/23a/718/fd3/23a718fd3139123b609e2521ffe46e3c.png"><br><br>  Comme vous pouvez le voir, le type de bâtiment affecte considérablement le nombre de points.  Les immeubles de bureaux ont généralement un score plus élevé et les hôtels plus bas.  Vous devez donc inclure le type de bâtiment dans le modèle, car ce signe affecte notre objectif.  En tant que variable catégorielle, nous devons effectuer un codage à chaud du type de bâtiment. <br><br>  Un graphique similaire peut être utilisé pour estimer le score Energy Star par quartier de ville: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/224/c69/820/224c69820a5c0362f804e37ae7d5de55.png"><br><br>  La zone n'affecte pas autant le score que le type de bâtiment.  Néanmoins, nous l'inclurons dans le modèle, car il existe une légère différence entre les régions. <br><br>  Pour calculer la relation entre les variables, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le coefficient de corrélation de Pearson</a> .  Il s'agit d'une mesure de l'intensité et de la direction d'une relation linéaire entre deux variables.  Une valeur de +1 signifie une relation positive parfaitement linéaire et -1 signifie une relation négative parfaitement linéaire.  Voici quelques exemples de valeurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coefficient de corrélation</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pearson</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/455/654/0b34556548ab206112024fb0e8f69c01.png"><br><br>  Bien que ce coefficient ne puisse pas refléter les dépendances non linéaires, il est possible de commencer par lui pour évaluer les relations des variables.  Dans Pandas, vous pouvez facilement calculer les corrélations entre toutes les colonnes d'une trame de données: <br><br><pre> <code class="hljs pgsql"># Find <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> correlations <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the score <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sort correlations_data = data.corr()[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].sort_values()</code> </pre> <br>  Les corrélations les plus négatives avec l'objectif: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b62/181/178/b62181178669962fccf7caa472d9e2e8.png"><br><br>  et le plus positif: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/598/47f/14a/59847f14a4d8afe1ce8ff237c5d3fa36.png"><br><br>  Il existe plusieurs fortes corrélations négatives entre les attributs et l'objectif, et les plus importants d'entre eux appartiennent à différentes catégories d'IUE (les méthodes de calcul de ces indicateurs diffèrent légèrement).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EUI (Energy Use Intensity</a> ) est la quantité d'énergie consommée par un bâtiment divisée par un pied carré de surface.  Cette valeur spécifique est utilisée pour évaluer l'efficacité énergétique, et plus elle est petite, mieux c'est.  La logique suggère que ces corrélations sont justifiées: si l'EUI augmente, alors le Energy Star Score devrait diminuer. <br><br><h4>  Graphiques à deux variables </h4><br>  Nous utilisons des nuages ​​de points pour visualiser les relations entre deux variables continues.  Vous pouvez ajouter des informations supplémentaires aux couleurs des points, par exemple une variable catégorielle.  La relation entre l'Energy Star Score et l'IUE est illustrée ci-dessous, les couleurs indiquent différents types de bâtiments: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/204/7de/9742047ded29c74a9a8e6df9bf6396d1.png"><br><br>  Ce graphique vous permet de visualiser un coefficient de corrélation de -0,7.  À mesure que l'IUE diminue, le score Energy Star augmente, cette relation est observée dans différents types de bâtiments. <br><br>  Notre dernier tableau de recherche s'appelle le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tracé des paires</a> .  C'est un excellent outil pour voir les relations entre différentes paires de variables et la distribution de variables uniques.  Nous utiliserons la bibliothèque Seaborn et la fonction PairGrid pour créer un diagramme de paires avec un diagramme de dispersion dans le triangle supérieur, avec un histogramme diagonal, un diagramme de densité de noyau bidimensionnel et des coefficients de corrélation dans le triangle inférieur. <br><br><pre> <code class="hljs pgsql"># Extract the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> plot plot_data = features[[<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft²)'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft²)'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>]] # Replace the inf <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> plot_data = plot_data.replace({np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>, -np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Rename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> plot_data = plot_data.<span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> = {<span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft²)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Site EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft²)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Weather Norm EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>: <span class="hljs-string"><span class="hljs-string">'log GHG Emissions'</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Drop</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> plot_data = plot_data.dropna() # <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate correlation coefficient <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> two <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> def corr_func(x, y, **kwargs): r = np.corrcoef(x, y)[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ax = plt.gca() ax.annotate("r = {:.2f}".format(r), xy=(<span class="hljs-number"><span class="hljs-number">.2</span></span>, <span class="hljs-number"><span class="hljs-number">.8</span></span>), xycoords=ax.transAxes, size = <span class="hljs-number"><span class="hljs-number">20</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> the pairgrid <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> grid = sns.PairGrid(data = plot_data, size = <span class="hljs-number"><span class="hljs-number">3</span></span>) # Upper <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a scatter plot grid.map_upper(plt.scatter, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.6</span></span>) # Diagonal <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a histogram grid.map_diag(plt.hist, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'black'</span></span>) # Bottom <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> density plot grid.map_lower(corr_func); grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds) # Title <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entire plot plt.suptitle(<span class="hljs-string"><span class="hljs-string">'Pairs Plot of Energy Data'</span></span>, size = <span class="hljs-number"><span class="hljs-number">36</span></span>, y = <span class="hljs-number"><span class="hljs-number">1.02</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/4cc/94f/5fa4cc94f9b91df5ad4fda37aa3ae1f0.png"><br><br>  Pour voir la relation des variables, recherchez l'intersection des lignes et des colonnes.  Supposons que vous vouliez regarder la corrélation entre la <code>Weather Norm EUI</code> et le <code>score</code> , alors nous recherchons la série <code>Weather Norm EUI</code> et la colonne de <code>score</code> , à l'intersection de laquelle il existe un coefficient de corrélation de -0,67.  Ces graphiques ont non seulement l'air cool, mais aident également à choisir les variables pour le modèle. <br><br><h2>  Conception et sélection de fonctionnalités </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La conception et la sélection de fonctionnalités</a> apportent souvent le meilleur rendement en termes de temps consacré à l'apprentissage automatique.  Nous donnons d'abord les définitions: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construction de caractéristiques:</a> processus d'extraction ou de création de nouvelles caractéristiques à partir de données brutes.  Pour utiliser des variables dans le modèle, vous devrez peut-être les transformer, par exemple, prendre le logarithme naturel, ou extraire la racine carrée, ou appliquer un codage à chaud des variables catégorielles.  La conception caractéristique peut être considérée comme créant des fonctionnalités supplémentaires à partir de données brutes. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sélection des fonctionnalités:</a> processus de sélection des fonctionnalités les plus pertinentes à partir des données, au cours duquel nous supprimons certaines fonctionnalités pour aider le modèle à mieux généraliser les nouvelles données afin d'obtenir un modèle plus interprétable.  Le choix des signes peut être considéré comme la suppression du «superflu» afin qu'il ne reste que les plus importants. </li></ul><br>  Le modèle d'apprentissage automatique ne peut apprendre que des données que nous fournissons, il est donc extrêmement important de s'assurer que nous incluons toutes les informations pertinentes pour notre tâche.  Si vous ne fournissez pas au modèle les données correctes, il ne pourra pas apprendre et ne produira pas de prévisions précises! <br><br>  Nous ferons ce qui suit: <br><br><ul><li>  Applicable aux variables catégorielles (trimestre et type de propriété) codage unique. </li><li>  Ajoutez le logarithme naturel de toutes les variables numériques. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un codage à chaud est</a> nécessaire pour inclure des variables catégorielles dans le modèle.  L'algorithme d'apprentissage automatique ne pourra pas comprendre le type de "bureau", donc si le bâtiment est un bureau, on lui attribuera un signe de 1, et sinon un bureau, alors 0. <br><br>  L'ajout d'entités transformées aidera le modèle à en savoir plus sur les relations non linéaires au sein des données.  Dans l'analyse des données, il est normal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'extraire des racines carrées, de prendre des logarithmes naturels ou de transformer les signes d'une manière ou d'une autre</a> , cela dépend de la tâche spécifique ou de votre connaissance des meilleures techniques.  Dans ce cas, nous ajouterons le logarithme naturel de tous les signes numériques. <br><br>  Ce code sélectionne les signes numériques, calcule leurs logarithmes, sélectionne deux signes catégoriels, leur applique un codage à chaud et combine les deux ensembles en un seul.  À en juger par la description, beaucoup de travail reste à faire, mais dans Pandas, tout est assez simple! <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span> the original data features = data.<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>() # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> numeric_subset = data.select_dtypes(<span class="hljs-string"><span class="hljs-string">'number'</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numeric_subset.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>: # Skip the Energy Star Score <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> col == <span class="hljs-string"><span class="hljs-string">'score'</span></span>: next <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: numeric_subset[<span class="hljs-string"><span class="hljs-string">'log_'</span></span> + col] = np.log(numeric_subset[col]) # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the categorical <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> categorical_subset = data[[<span class="hljs-string"><span class="hljs-string">'Borough'</span></span>, <span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>]] # One hot encode categorical_subset = pd.get_dummies(categorical_subset) # <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> the two dataframes <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> concat # Make sure <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use axis = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> bind features = pd.concat([numeric_subset, categorical_subset], axis = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Nous avons maintenant plus de 11 000 observations (bâtiments) avec 110 colonnes (balises).  Tous les signes ne seront pas utiles pour prédire le score Energy Star, nous allons donc reprendre la sélection des signes et supprimer certaines des variables. <br><br><h4>  Sélection des fonctionnalités </h4><br>  Bon nombre des 110 panneaux disponibles sont redondants car ils sont fortement corrélés les uns aux autres.  Par exemple, voici un graphique de l'IUE et du site normalisé par temps EUI, avec un coefficient de corrélation de 0,997. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ab/c4f/ad8/4abc4fad887ef202d8d40961a8b02c34.png"><br><br>  Les signes fortement corrélés sont appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">colinéaires</a> .  La suppression d'une variable dans de telles paires d'attributs aide souvent le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle à se généraliser et à être plus interprétable</a> .  Veuillez noter que nous parlons de la corrélation de certains signes avec d'autres, et non de la corrélation avec l'objectif, ce qui n'aiderait que notre modèle! <br><br>  Il existe un certain nombre de méthodes pour calculer la colinéarité des caractéristiques, et l'une des plus populaires est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facteur d'inflation de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">variance</a> .  Nous utiliserons le coefficient de corrélation pour rechercher et supprimer des entités colinéaires.  Nous rejetons une paire de signes si le coefficient de corrélation entre eux est supérieur à 0,6.  Le code est dans le bloc-notes (et en réponse à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stack Overflow</a> ). <br><br>  Cette valeur semble arbitraire, mais en fait j'ai essayé différents seuils, et ce qui précède m'a permis de créer le meilleur modèle.  L'apprentissage automatique est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">empirique</a> et doit souvent expérimenter pour trouver la meilleure solution.  Après la sélection, nous avons 64 attributs et un objectif. <br><br><pre> <code class="hljs pgsql"># Remove <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> features = features.dropna(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, how = <span class="hljs-string"><span class="hljs-string">'all'</span></span>) print(features.shape) (<span class="hljs-number"><span class="hljs-number">11319</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>)</code> </pre> <br><h2>  Choisissez un niveau de base </h2><br>  Nous avons effacé les données, effectué une analyse exploratoire et construit les panneaux.  Et avant de procéder à la création du modèle, vous devez sélectionner le niveau de base initial (base naïve) - une sorte d'hypothèse avec laquelle nous comparerons les résultats des modèles.  S'ils tombent en dessous du niveau de base, nous supposerons que l'apprentissage automatique n'est pas applicable pour cette tâche, ou qu'une approche différente doit être essayée. <br><br>  Pour les tâches de régression, en tant que niveau de base, il est raisonnable de deviner la valeur médiane de l'objectif sur l'ensemble d'entraînement pour tous les exemples de l'ensemble de test.  Ces kits définissent une barrière relativement faible pour tous les modèles. <br><br>  En tant que mesure, nous prenons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">erreur absolue moyenne (mae)</a> dans les prévisions.  Il existe de nombreuses autres métriques pour les régressions, mais j'aime les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conseils</a> pour choisir une métrique et l'utiliser pour évaluer les modèles.  Et l'erreur absolue moyenne est facile à calculer et à interpréter. <br><br>  Avant de calculer le niveau de base, vous devez diviser les données en ensembles de formation et de test: <br><br><ol><li>  Un ensemble d'attributs de formation est ce que nous fournissons à notre modèle avec les réponses pendant la formation.  Le modèle doit apprendre à correspondre aux caractéristiques de l'objectif. </li><li>  Un ensemble de fonctionnalités de test est utilisé pour évaluer le modèle formé.  Lorsqu'elle traite la suite de tests, elle ne voit pas les bonnes réponses et doit prévoir uniquement en fonction des fonctionnalités disponibles.  Nous connaissons les réponses pour les données de test et pouvons comparer les résultats des prévisions avec eux. </li></ol><br>  Pour la formation, nous utilisons 70% des données et pour les tests - 30%: <br><br><pre> <code class="hljs pgsql"># Split <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>% training <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>% testing <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> X, X_test, y, y_test = train_test_split(features, targets, test_size = <span class="hljs-number"><span class="hljs-number">0.3</span></span>, random_state = <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br>  Maintenant, nous calculons l'indicateur pour le niveau de base initial: <br><br><pre> <code class="hljs vhdl"># <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate mean absolute <span class="hljs-literal"><span class="hljs-literal">error</span></span> def mae(y_true, y_pred): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.mean(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(y_true - y_pred)) baseline_guess = np.median(y) print(<span class="hljs-symbol"><span class="hljs-symbol">'The</span></span> baseline guess <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a score <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> %<span class="hljs-number"><span class="hljs-number">0.2</span></span>f' % baseline_guess) print(<span class="hljs-string"><span class="hljs-string">"Baseline Performance on the test set: MAE = %0.4f"</span></span> % mae(y_test, baseline_guess))</code> </pre> <br>  <b>La supposition de base est un score de 66,00</b> <b><br></b>  <b>Performances de base sur l'ensemble de test: MAE = 24,5164</b> <br><br>  L'erreur absolue moyenne sur l'ensemble de test était d'environ 25 points.  Puisque nous évaluons dans la plage de 1 à 100, l'erreur est de 25% - une barrière plutôt faible pour le modèle! <br><br><h2>  Conclusion </h2><br>  Dans cet article, vous êtes passés par les trois premières étapes de la résolution d'un problème à l'aide de l'apprentissage automatique.  Après avoir défini la tâche, nous: <br><br><ol><li>  Données brutes effacées et formatées. </li><li>  Réalisation d'une analyse exploratoire pour étudier les données disponibles. </li><li>  Nous avons développé un ensemble de fonctionnalités que nous utiliserons pour nos modèles. </li></ol><br> ,    ,       . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scikit-Learn</a>    ,        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425253/">https://habr.com/ru/post/fr425253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425243/index.html">Le manuel de John Willis</a></li>
<li><a href="../fr425245/index.html">Annonce de RamblerFront & # 6</a></li>
<li><a href="../fr425247/index.html">Crowdsourcing dans les tests</a></li>
<li><a href="../fr425249/index.html">Comment est la connaissance du LLP à l'Université ITMO: le cours "Programmation de bas niveau"</a></li>
<li><a href="../fr425251/index.html">LoJax: le premier rootkit UEFI connu utilisé dans une campagne malveillante</a></li>
<li><a href="../fr425255/index.html">Algorithme de compression sans perte Broo et codage delta, comparaison avec Xdelta3. Développement de projets à domicile</a></li>
<li><a href="../fr425259/index.html">Sauvegarder votre site en utilisant git et Makefile</a></li>
<li><a href="../fr425261/index.html">Les certificats EV sont morts</a></li>
<li><a href="../fr425263/index.html">Le festival iFEST se tiendra à Nijni Novgorod</a></li>
<li><a href="../fr425265/index.html">Règles de développement chez Yandex.Health</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>