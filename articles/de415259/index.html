<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ø üë©üèª‚Äçüéì ü§º select / poll / epoll: praktischer Unterschied üë©üèª‚Äçü§ù‚Äçüë®üèº ü§∏üèø üë©‚Äç‚ù§Ô∏è‚Äçüë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Entwerfen von Hochleistungsnetzwerkanwendungen mit nicht blockierenden Sockets ist es wichtig zu entscheiden, welche Methode zur √úberwachung von ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>select / poll / epoll: praktischer Unterschied</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415259/">  Beim Entwerfen von Hochleistungsnetzwerkanwendungen mit nicht blockierenden Sockets ist es wichtig zu entscheiden, welche Methode zur √úberwachung von Netzwerkereignissen verwendet wird.  Es gibt mehrere von ihnen, und jede ist auf ihre Weise gut und schlecht.  Die Auswahl der richtigen Methode kann f√ºr die Architektur Ihrer Anwendung von entscheidender Bedeutung sein. <br><br>  In diesem Artikel werden wir Folgendes ber√ºcksichtigen: <br><br><ul><li>  w√§hle () </li><li>  Umfrage () </li><li>  epoll () </li><li>  libevent </li></ul><a name="habracut"></a><br><h3>  Mit select () </h3><br>  Das alte, im Laufe der Jahre bew√§hrte Hard Worker select () wurde in jenen Tagen erstellt, als ‚ÄûSockets‚Äú als ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berkeley-Sockets</a> ‚Äú bezeichnet wurden.  Diese Methode war in der allerersten Spezifikation dieser Berkeley-Buchsen selbst nicht enthalten, da es damals noch kein Konzept f√ºr nicht blockierende E / A gab.  Aber irgendwo in den 80ern erschien sie und w√§hlte damit ().  Seitdem hat sich an der Benutzeroberfl√§che nichts wesentlich ge√§ndert. <br><br>  Um select () verwenden zu k√∂nnen, muss der Entwickler mehrere fd_set-Strukturen initialisieren und mit Deskriptoren und Ereignissen f√ºllen, die √ºberwacht werden m√ºssen, und dann select () aufrufen.  Ein typischer Code sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="cpp hljs">fd_set fd_in, fd_out; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   FD_ZERO( &amp;fd_in ); FD_ZERO( &amp;fd_out ); //        sock1 FD_SET( sock1, &amp;fd_in ); //        sock2 FD_SET( sock2, &amp;fd_out ); //       (select   ) int largest_sock = sock1 &gt; sock2 ? sock1 : sock2; //    10  tv.tv_sec = 10; tv.tv_usec = 0; //  select int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { if ( FD_ISSET( sock1, &amp;fd_in ) ) //    sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) //    sock2 }</span></span></code> </pre> <br>  Als select () entworfen wurde, hatte niemand damit gerechnet, dass wir in Zukunft Multithread-Anwendungen schreiben m√ºssen, die Tausende von Verbindungen bedienen.  Select () weist mehrere wesentliche Nachteile auf, die es f√ºr die Arbeit an solchen Systemen schlecht geeignet machen.  Die wichtigsten sind: <br><br><ul><li>  select √§ndert die an ihn √ºbergebenen fd_sets-Strukturen so, dass keine von ihnen wiederverwendet werden kann.  Auch wenn Sie nichts √§ndern m√ºssen (z. B. m√∂chten Sie nach dem Empfang eines Datenelements mehr erhalten), m√ºssen die Strukturen fd_sets neu initialisiert werden.  Nun, oder kopieren Sie mit FD_COPY aus einem zuvor gespeicherten Backup.  Und dies muss vor jedem ausgew√§hlten Anruf immer wieder erfolgen. </li><li>  Um genau herauszufinden, welcher Deskriptor das Ereignis generiert hat, m√ºssen Sie alle manuell mit FD_ISSET abfragen.  Wenn Sie 2000 Deskriptoren √ºberwachen und das Ereignis nur f√ºr einen von ihnen aufgetreten ist (der nach dem Gesetz der Gemeinheit der letzte auf der Liste ist), verschwenden Sie eine Menge Prozessorressourcen. </li><li>  Habe ich gerade 2000 Deskriptoren erw√§hnt?  Ich war begeistert davon.  select unterst√ºtzt nicht so viel.  Zumindest unter normalem Linux mit dem √ºblichen Kernel.  Die maximale Anzahl gleichzeitig beobachteter Deskriptoren wird durch die Konstante FD_SETSIZE begrenzt, die unter Linux starr gleich 1024 ist. Bei einigen Betriebssystemen k√∂nnen Sie einen Hack implementieren, indem Sie den FD_SETSIZE-Wert √ºberschreiben, bevor Sie die Header-Datei sys / select.h einschlie√üen. Dieser Hack ist jedoch nicht Teil eines g√§ngigen Standards.  Das gleiche Linux wird es ignorieren. </li><li>  Sie k√∂nnen nicht mit Deskriptoren aus einer beobachtbaren Menge eines anderen Threads arbeiten.  Stellen Sie sich einen Thread vor, der den obigen Code ausf√ºhrt.  Also startete es und wartet auf Ereignisse in seiner select ().  Stellen Sie sich nun vor, Sie haben einen anderen Thread, der die Gesamtlast des Systems √ºberwacht, und jetzt hat er entschieden, dass die Daten vom Socket sock1 nicht zu lange angekommen sind und es Zeit war, die Verbindung zu trennen.  Da dieser Socket wiederverwendet werden kann, um neue Clients zu bedienen, ist es gut, ihn korrekt zu schlie√üen.  Aber der erste Thread beobachtet diesen Deskriptor gerade.  Was passiert, wenn wir es trotzdem schlie√üen?  Oh, die Dokumentation hat eine Antwort auf diese Frage und es wird Ihnen nicht gefallen: "Wenn das mit select () beobachtete Handle von einem anderen Thread geschlossen wird, erhalten Sie ein undefiniertes Verhalten." </li><li>  Das gleiche Problem tritt auf, wenn versucht wird, einige Daten √ºber sock1 zu senden.  Wir werden nichts senden, bis select seine Arbeit beendet hat. </li><li>  Die Auswahl an Ereignissen, die wir √ºberwachen k√∂nnen, ist sehr begrenzt.  Um beispielsweise festzustellen, dass ein Remote-Socket geschlossen wurde, sollten Sie zum einen die Ereignisse des Eintreffens von Daten √ºberwachen und zum anderen versuchen, diese Daten zu lesen (read gibt 0 f√ºr den geschlossenen Socket zur√ºck).  Dies kann immer noch als akzeptabel bezeichnet werden, wenn Daten von einem Socket gelesen werden (0 lesen - der Socket ist geschlossen). Was ist jedoch, wenn unsere aktuelle Aufgabe darin besteht, Daten an diesen Socket zu senden und derzeit keine Daten von diesem zu lesen? </li><li>  select belastet Sie unn√∂tig, den ‚Äûgr√∂√üten Deskriptor‚Äú zu berechnen und als separaten Parameter zu √ºbergeben </li></ul><br>  Nat√ºrlich ist all das keine Neuigkeit.  Betriebssystementwickler sind sich dieser Probleme seit langem bewusst und viele von ihnen wurden bei der Entwicklung der Abfragemethode ber√ºcksichtigt.  An dieser Stelle fragen Sie sich vielleicht, warum wir uns jetzt √ºberhaupt mit alter Geschichte befassen und gibt es heute Gr√ºnde, die alte Auswahl zu verwenden?  Ja, es gibt zwei solche Gr√ºnde.  Nicht die Tatsache, dass sie Ihnen irgendwann n√ºtzlich sein werden, aber warum nicht etwas √ºber sie herausfinden? <br><br>  Der erste Grund ist die Portabilit√§t.  select () ist seit einer Million Jahren bei uns.  Egal, was der Dschungel der Hardware- und Softwareplattformen Ihnen bringt, wenn dort ein Netzwerk vorhanden ist, wird eine Auswahl getroffen.  Es gibt m√∂glicherweise keine anderen Methoden, aber die Auswahl ist fast garantiert.  Und denken Sie nicht, dass ich jetzt in senile Senilit√§t falle und erinnere mich an etwas wie Lochkarten und ENIAC, nein.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In Windows XP</a> gibt es beispielsweise keine modernere Abfragemethode.  Aber w√§hlen ist. <br><br>  Der zweite Grund ist exotischer und h√§ngt mit der Tatsache zusammen, dass select (theoretisch) mit Timeouts in der Gr√∂√üenordnung von einer Nanosekunde arbeiten kann (sofern die Hardware dies zul√§sst), w√§hrend Poll und Epoll nur die Millisekundengenauigkeit unterst√ºtzen.  Dies sollte auf normalen Desktops (oder sogar Servern), auf denen Sie noch keinen Hardware-Timer f√ºr die Genauigkeit von Nanosekunden haben, keine besondere Rolle spielen.  Aber immer noch auf der Welt gibt es Echtzeitsysteme mit solchen Timern.  Ich bitte Sie, wenn Sie die Firmware eines Kernreaktors oder einer Rakete schreiben - seien Sie nicht zu faul, um die Zeit in Nanosekunden zu messen.  Wei√üt du, ich m√∂chte leben. <br><br>  Der oben beschriebene Fall ist wahrscheinlich der einzige, bei dem Sie wirklich keine Wahl haben, was Sie verwenden m√∂chten (nur select ist geeignet).  Wenn Sie jedoch eine regul√§re Anwendung f√ºr die Arbeit mit normaler Hardware schreiben und mit einer angemessenen Anzahl von Sockets (Zehn, Hunderte - und nicht mehr) arbeiten, ist der Unterschied in der Abfrage- und Auswahlleistung nicht erkennbar, sodass die Auswahl auf anderen Faktoren basiert. <br><br><h3>  Abstimmung mit Umfrage () </h3><br>  poll ist eine neuere Methode zum Abrufen von Sockets, die erstellt wurde, nachdem Benutzer versucht haben, gro√üe und stark ausgelastete Netzwerkdienste zu schreiben.  Es ist viel besser gestaltet und leidet nicht unter den meisten Nachteilen der Auswahlmethode.  In den meisten F√§llen k√∂nnen Sie beim Schreiben moderner Anwendungen zwischen poll und epoll / libevent w√§hlen. <br><br>  Um poll verwenden zu k√∂nnen, muss ein Entwickler Mitglieder der pollfd-Struktur mit beobachtbaren Deskriptoren und Ereignissen initialisieren und dann poll () aufrufen. <br>  Ein typischer Code sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct pollfd fds[2]; //  sock1      fds[0].fd = sock1; fds[0].events = POLLIN; //   sock2 -  fds[1].fd = sock2; fds[1].events = POLLOUT; //   10  int ret = poll( &amp;fds, 2, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //  ,  revents      if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; //     sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; //     sock2 }</span></span></code> </pre> <br>  Die Umfrage wurde erstellt, um die Probleme der Auswahlmethode zu l√∂sen. Mal sehen, wie sich herausstellte: <br><br><ul><li>  Die Anzahl der beobachteten Deskriptoren ist unbegrenzt, mehr als 1024 k√∂nnen √ºberwacht werden </li><li>  Die pollfd-Struktur wird nicht ge√§ndert, sodass sie zwischen den Aufrufen von poll () wiederverwendet werden kann. Sie m√ºssen lediglich das Feld revents zur√ºcksetzen. </li><li>  Beobachtete Ereignisse sind besser strukturiert.  Sie k√∂nnen beispielsweise bestimmen, ob ein Remoteclient getrennt wird, ohne Daten vom Socket lesen zu m√ºssen. </li></ul><br>  Wir haben bereits √ºber die M√§ngel der Umfragemethode gesprochen: Sie ist auf einigen Plattformen wie Windows XP nicht verf√ºgbar.  Seit Vista existiert es, hei√üt aber WSAPoll.  Der Prototyp ist derselbe, sodass Sie f√ºr plattformunabh√§ngigen Code eine √úberschreibung schreiben k√∂nnen, z. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (WIN32) static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Nun, die Genauigkeit von Timeouts betr√§gt 1 ms, was sehr selten nicht ausreicht.  Die Umfrage hat jedoch andere Nachteile: <br><br><ul><li>  Wie bei der Verwendung von select ist es unm√∂glich zu bestimmen, welche Deskriptoren die Ereignisse generiert haben, ohne alle beobachteten Strukturen vollst√§ndig zu durchlaufen und die darin enthaltenen Revents-Felder zu √ºberpr√ºfen.  Schlimmer noch, es ist auch im Kernel des Betriebssystems implementiert. </li><li>  Wie bei select gibt es keine M√∂glichkeit, die beobachteten Ereignisse dynamisch zu √§ndern </li></ul><br>  All dies kann jedoch f√ºr die meisten Clientanwendungen als relativ unbedeutend angesehen werden.  Die Ausnahme sind wahrscheinlich nur P2P-Protokolle, bei denen jeder der Clients Tausenden von anderen zugeordnet werden kann.  Diese Probleme k√∂nnen selbst von den meisten Serveranwendungen ignoriert werden.  Daher sollte die Umfrage Ihre Standardeinstellung gegen√ºber der Auswahl sein, es sei denn, einer der beiden oben genannten Gr√ºnde schr√§nkt Sie ein. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass Umfragen in den folgenden F√§llen sogar im Vergleich zu den moderneren Epolls (siehe unten) vorzuziehen sind: <br><br><ul><li>  Sie m√∂chten plattform√ºbergreifenden Code schreiben (epoll ist nur unter Linux verf√ºgbar) </li><li>  Sie m√ºssen nicht mehr als 1000 Sockets √ºberwachen (epoll gibt Ihnen in diesem Fall nichts Bedeutendes) </li><li>  Sie m√ºssen mehr als 1000 Sockets √ºberwachen, aber die Verbindungszeit mit jedem von ihnen ist sehr gering (in diesen F√§llen ist die Leistung von Poll und Epoll sehr gering - der Gewinn durch das Warten auf weniger Ereignisse in Epoll wird durch den Aufwand beim Hinzuf√ºgen / Entfernen dieser Sockets durchgestrichen). </li><li>  Ihre Anwendung ist nicht daf√ºr ausgelegt, Ereignisse von einem Thread zu √§ndern, w√§hrend ein anderer auf sie wartet (oder Sie ben√∂tigen sie nicht). </li></ul><br><h3>  Abstimmung mit epoll () </h3><br>  epoll ist die neueste und beste Methode, um auf Ereignisse unter Linux (und nur unter Linux) zu warten.  Nun, es ist nicht so, dass das "neueste" direkt ist - es ist seit 2002 das Kernst√ºck.  Es unterscheidet sich von Umfrage und Auswahl dadurch, dass es eine API zum Hinzuf√ºgen / Entfernen / √Ñndern der Liste der beobachteten Deskriptoren und Ereignisse bereitstellt. <br><br>  Die Verwendung von Epoll erfordert etwas gr√ºndlichere Vorbereitungen.  Der Entwickler muss: <br><br><ul><li>  Erstellen Sie einen Epoll-Deskriptor, indem Sie epoll_create aufrufen </li><li>  Initialisieren Sie die epoll_event-Struktur mit den erforderlichen Ereignissen und Zeigern auf Verbindungskontexte.  Der "Kontext" hier kann alles sein, epoll √ºbergibt diesen Wert nur in den zur√ºckgegebenen Ereignissen </li><li>  Rufen Sie epoll_ctl (... EPOLL_CTL_ADD) auf, um der Liste der Observablen ein Handle hinzuzuf√ºgen </li><li>  Rufen Sie epoll_wait () auf, um auf Ereignisse zu warten (wir geben genau an, wie viele Ereignisse gleichzeitig empfangen werden sollen, z. B. 20).  Im Gegensatz zu den vorherigen Methoden erhalten wir diese Ereignisse separat und nicht in den Eigenschaften der Eingabestrukturen.  Wenn wir 200 Deskriptoren beobachten und 5 von ihnen neue Daten erhalten haben, gibt epoll_wait nur 5 Ereignisse zur√ºck.  Wenn 50 Ereignisse eintreten, werden die ersten 20 an uns zur√ºckgeschickt und die restlichen 30 warten auf den n√§chsten Anruf. Sie gehen nicht verloren </li><li>  Verarbeitete Ereignisse verarbeiten.  Dies ist eine relativ schnelle Verarbeitung, da wir uns nicht die Deskriptoren ansehen, bei denen nichts passiert ist </li></ul><br>  Ein typischer Code sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   epoll.       ,      //    (    ,   ),        int pollingfd = epoll_create( 0xCAFE ); if ( pollingfd &lt; 0 ) //  //   epoll_event struct epoll_event ev = { 0 }; //     .    ,   // epoll     . , ,       ev.data.ptr = pConnection1; //    ,     ev.events = EPOLLIN | EPOLLONESHOT; //     .        //      epoll_wait -    if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error //       20    struct epoll_event pevents[ 20 ]; //  10  int ready = epoll_wait( pollingfd, pevents, 20, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //     for ( int i = 0; i &lt; ret; i++ ) { if ( pevents[i].events &amp; EPOLLIN ) { //        ,   Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); } } }</span></span></code> </pre> <br>  Beginnen wir mit den Fehlern von epoll - sie sind aus dem Code ersichtlich.  Diese Methode ist schwieriger zu verwenden, Sie m√ºssen mehr Code schreiben, es werden mehr Systemaufrufe ausgef√ºhrt. <br><br>  Vorteile liegen auch auf der Hand: <br><br><ul><li>  epoll gibt nur eine Liste der Deskriptoren zur√ºck, f√ºr die die beobachteten Ereignisse tats√§chlich aufgetreten sind.  Sie m√ºssen nicht Tausende von Strukturen durchsuchen, um nach der zu suchen, m√∂glicherweise nach der, in der das erwartete Ereignis funktioniert hat. </li><li>  Sie k√∂nnen jedem beobachteten Ereignis einen sinnvollen Kontext zuordnen.  Im obigen Beispiel haben wir daf√ºr einen Zeiger auf ein Objekt der Verbindungsklasse verwendet - dies hat uns eine weitere m√∂gliche Suche nach einem Array von Verbindungen erspart. </li><li>  Sie k√∂nnen jederzeit Sockets zur Liste hinzuf√ºgen oder daraus entfernen.  Sie k√∂nnen sogar beobachtete Ereignisse √§ndern.  Alles wird korrekt funktionieren, dies wird offiziell unterst√ºtzt und dokumentiert. </li><li>  Mit epoll_wait k√∂nnen Sie mehrere Threads starten, die auf Ereignisse aus derselben Warteschlange warten.  Etwas, das mit select / poll in keiner Weise m√∂glich ist. </li></ul><br>  Sie m√ºssen sich aber auch daran erinnern, dass Epoll keine ‚Äûvollst√§ndig verbesserte Umfrage‚Äú ist.  Es hat Nachteile gegen√ºber der Umfrage: <br><br><ul><li>  Das √Ñndern von Ereignisflags (z. B. das Wechseln von READ zu WRITE) erfordert einen zus√§tzlichen Systemaufruf epoll_ctl, w√§hrend Sie f√ºr die Abfrage nur die Bitmaske √§ndern (vollst√§ndig im Benutzermodus).  Das Umschalten von 5.000 Sockets vom Lesen zum Schreiben erfordert 5.000 Systemaufrufe und Kontextwechsel f√ºr epoll, w√§hrend es f√ºr die Abfrage eine triviale Bitoperation in einer Schleife ist. </li><li>  F√ºr jede neue Verbindung m√ºssen Sie accept () aufrufen, und epoll_ctl () sind zwei Systemaufrufe.  Wenn Sie eine Umfrage verwenden, wird nur ein Anruf get√§tigt.  Bei einer sehr kurzen Verbindungslebensdauer kann dies einen Unterschied machen. </li><li>  epoll ist nur unter Linux verf√ºgbar.  Andere Betriebssysteme haben √§hnliche Mechanismen, sind aber immer noch nicht vollst√§ndig identisch.  Sie k√∂nnen keinen Code mit epoll schreiben, damit er beispielsweise auf FreeBSD erstellt und funktioniert. </li><li>  Das Schreiben von hoch geladenem parallelem Code ist schwierig.  Viele Anwendungen ben√∂tigen keinen so grundlegenden Ansatz, da ihr Lastniveau mit einfacheren Methoden leicht verarbeitet werden kann. </li></ul><br>  Daher sollte epoll nur verwendet werden, wenn alle der folgenden Bedingungen erf√ºllt sind: <br><br><ul><li>  Ihre Anwendung verwendet einen Thread-Pool, um Netzwerkverbindungen zu verarbeiten.  Der Gewinn von epoll in einer Single-Threaded-Anwendung ist vernachl√§ssigbar, und Sie sollten sich nicht um die Implementierung k√ºmmern. </li><li>  Sie erwarten eine relativ gro√üe Anzahl von Verbindungen (ab 1000).  Bei einer kleinen Anzahl von beobachteten Steckdosen f√ºhrt epoll nicht zu einem Leistungsgewinn, und wenn es buchst√§blich einige Steckdosen gibt, kann es sogar langsamer werden. </li><li>  Ihre Verbindungen leben relativ lange.  In einer Situation, in der eine neue Verbindung nur wenige Datenbytes √ºbertr√§gt und genau dort geschlossen wird, funktioniert die Abfrage schneller, da weniger Systemaufrufe erforderlich sind, um sie zu verarbeiten. </li><li>  Sie beabsichtigen, Ihren Code unter Linux und nur unter Linux auszuf√ºhren. </li></ul><br>  Wenn eines oder mehrere der Elemente fehlschlagen, sollten Sie die Verwendung von poll oder libevent in Betracht ziehen. <br><br><h3>  libevent </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libevent</a> ist eine Bibliothek, die die in diesem Artikel aufgef√ºhrten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfragemethoden</a> (sowie einige andere) in einer einheitlichen API zusammenfasst.  Der Vorteil hierbei ist, dass Sie den Code nach dem Schreiben auf verschiedenen Betriebssystemen erstellen und ausf√ºhren k√∂nnen.  Es ist jedoch wichtig zu verstehen, dass libevent nur ein Wrapper ist, in dem alle oben genannten Methoden mit all ihren Vor- und Nachteilen funktionieren.  libevent erzwingt nicht, dass select mehr als 1024 Sockets abh√∂rt, und epoll √§ndert die Liste der Ereignisse nicht ohne einen zus√§tzlichen Systemaufruf.  Daher ist es immer noch wichtig, die zugrunde liegenden Technologien zu kennen. <br><br>  Die Notwendigkeit, verschiedene Abfragemethoden zu unterst√ºtzen, macht die API der Libevent-Bibliothek komplexer.  Die Verwendung ist jedoch einfacher als das manuelle Schreiben von zwei verschiedenen Ereignisauswahl-Engines f√ºr beispielsweise Linux und FreeBSD (unter Verwendung von epoll und kqueue). <br><br>  Erw√§gen Sie die Verwendung von libevent, wenn Sie zwei Ereignisse kombinieren: <br><br><ul><li>  Sie haben sich Auswahl- und Abfragemethoden angesehen und sie haben definitiv nicht f√ºr Sie funktioniert. </li><li>  Sie m√ºssen mehrere Betriebssysteme unterst√ºtzen </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415259/">https://habr.com/ru/post/de415259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415249/index.html">Ein kleiner Schritt f√ºr einen Programmierer ist ein gro√üer Schritt f√ºr eine NGO</a></li>
<li><a href="../de415251/index.html">Mitarbeiter von Amazon, Google und Microsoft protestieren gegen die Zusammenarbeit mit Milit√§r und Polizei</a></li>
<li><a href="../de415253/index.html">Fotografien aus dem 19. Jahrhundert wurden mithilfe der Technologie des 21. Jahrhunderts restauriert</a></li>
<li><a href="../de415255/index.html">Roskosmos k√ºndigte die Beendigung der Fl√ºge von Protonenraketen an</a></li>
<li><a href="../de415257/index.html">8 M√∂glichkeiten zur Verbesserung der Datenvisualisierung</a></li>
<li><a href="../de415261/index.html">VFX-K√ºnstler in der Spieleentwicklung: Features, Karriere, Entwicklung</a></li>
<li><a href="../de415263/index.html">Wie wir der Karte Eing√§nge hinzugef√ºgt und die Gr√∂√üe der Basen um 10% reduziert haben</a></li>
<li><a href="../de415265/index.html">Auf der Suche nach einem Nachfolger des KL-7: RACE und AROFLEX</a></li>
<li><a href="../de415269/index.html">Funktionsweise von JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</a></li>
<li><a href="../de415271/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>