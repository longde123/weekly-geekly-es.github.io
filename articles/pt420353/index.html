<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° ü§ñ üë®üèæ Tornamos o Camar√£o ainda mais √∫til: adicione transcodifica√ß√£o de imagem a outros formatos üëçüèΩ ü•ñ üöµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde o in√≠cio de 2017, nossa pequena equipe desenvolve a biblioteca RESTinio OpenSource para incorporar um servidor HTTP em aplicativos C ++. Para no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornamos o Camar√£o ainda mais √∫til: adicione transcodifica√ß√£o de imagem a outros formatos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Desde o in√≠cio de 2017, nossa pequena equipe desenvolve a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca RESTinio OpenSource</a> para incorporar um servidor HTTP em aplicativos C ++.  Para nossa grande surpresa, de tempos em tempos, recebemos perguntas da categoria "E por que um servidor HTTP C ++ incorporado pode ser necess√°rio?"  Infelizmente, perguntas simples s√£o as mais dif√≠ceis de responder.  √Äs vezes, a melhor resposta √© um c√≥digo de exemplo. <br><br>  H√° alguns meses, iniciamos um pequeno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto de demonstra√ß√£o, o Shrimp</a> , que demonstra claramente um cen√°rio t√≠pico, sob o qual nossa biblioteca √© "afiada".  O projeto de demonstra√ß√£o √© um servi√ßo da Web simples que recebe solicita√ß√µes de dimensionamento de imagens armazenadas no servidor e retorna uma imagem do tamanho que o usu√°rio precisa. <br><br>  Este projeto de demonstra√ß√£o √© bom, pois requer, em primeiro lugar, a integra√ß√£o com um c√≥digo escrito h√° muito tempo e funcionando corretamente em C ou C ++ (neste caso, ImageMagick).  Portanto, deve ficar claro por que faz sentido incorporar o servidor HTTP em um aplicativo C ++. <br><br>  Al√©m disso, nesse caso, o processamento de solicita√ß√µes ass√≠ncronas √© necess√°rio para que o servidor HTTP n√£o bloqueie enquanto a imagem est√° sendo dimensionada (e isso pode levar centenas de milissegundos ou mesmo segundos).  Iniciamos o desenvolvimento do RESTinio precisamente porque n√£o conseguimos encontrar um servidor incorporado C ++ sadio focado especificamente no processamento de solicita√ß√µes ass√≠ncronas. <br><br>  Constru√≠mos o trabalho sobre o Shrimp de forma iterativa: primeiro, a vers√£o mais simples foi criada e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrita</a> , que apenas ampliava as imagens.  Em seguida, corrigimos v√°rias defici√™ncias da primeira vers√£o e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrevemos isso no segundo artigo</a> .  Finalmente, conseguimos expandir a funcionalidade do Shrimp mais uma vez: a convers√£o de imagens de um formato para outro foi adicionada.  Sobre como isso foi feito e ser√° discutido neste artigo. <br><a name="habracut"></a><br><h1>  Suporte ao formato de destino </h1><br>  Portanto, na pr√≥xima vers√£o do Shrimp, adicionamos a capacidade de fornecer uma imagem em escala em um formato diferente.  Portanto, se voc√™ emitir uma solicita√ß√£o de camar√£o no formul√°rio: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  o Shrimp renderizar√° a imagem no mesmo formato JPG da imagem original. <br><br>  Mas se voc√™ adicionar o par√¢metro de formato de destino √† URL, o Shrimp converter√° a imagem no formato de destino especificado.  Por exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  Nesse caso, o Shrimp renderizar√° a imagem no formato webp. <br><br>  O Shrimp atualizado suporta cinco formatos de imagem: jpg, png, gif, webp e heic (tamb√©m conhecido como HEIF).  Voc√™ pode experimentar v√°rios formatos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em uma p√°gina da web especial</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (nesta p√°gina, n√£o h√° como selecionar o formato heic, porque os navegadores comuns da √°rea de trabalho n√£o suportam esse formato por padr√£o). <br><br>  Para suportar o formato de destino no Shrimp, foi necess√°rio modificar levemente o c√≥digo do Shrimp (o que n√≥s mesmos ficamos surpresos, porque realmente havia poucas altera√ß√µes).  Mas, por outro lado, tive que brincar com a montagem do ImageMagick, com a qual ficamos ainda mais surpresos, pois  Antes, tivemos que lidar com esta cozinha, por uma feliz coincid√™ncia.  Mas vamos falar sobre tudo em ordem. <br><br><h2>  O ImageMagick deve entender diferentes formatos </h2><br>  O ImageMagick usa bibliotecas externas para codificar / decodificar imagens: libjpeg, libpng, libgif, etc.  Essas bibliotecas devem ser instaladas no sistema antes que o ImageMagick seja configurado e constru√≠do. <br><br>  O mesmo deve acontecer para o ImageMagick suportar os formatos webp e heic: primeiro voc√™ precisa criar e instalar libwebp e libheif, depois configurar e instalar o ImageMagick.  E se tudo √© simples com a libwebp, ent√£o em torno da libhe se eu tivesse que dan√ßar com um pandeiro.  Embora, depois de algum tempo, depois que tudo finalmente se reunisse e funcionasse, j√° n√£o estava claro: por que voc√™ teve que recorrer a um pandeiro, tudo parece ser trivial?  ;) <br><br>  Em geral, se algu√©m quiser fazer amizade com o heic e o ImageMagick, voc√™ precisar√° instalar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">x265 de videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libheif</a> </li></ul><br>  Est√° nesta ordem (pode ser necess√°rio instalar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nasm</a> para que o x265 funcione na velocidade m√°xima).  Em seguida, ao emitir o comando <i>./configure</i> , o ImageMagick poder√° encontrar tudo o que precisa para suportar arquivos .heic. <br><br><h2>  Suporte ao formato de destino na sequ√™ncia de consultas de solicita√ß√µes recebidas </h2><br>  Depois de fazer o ImageMagick fazer amizade com os formatos webp e heic, √© hora de modificar o c√≥digo do camar√£o.  Primeiro de tudo, precisamos aprender como reconhecer o argumento do formato de destino nas solicita√ß√µes HTTP recebidas. <br><br>  Do ponto de vista do RESTinio, isso n√£o √© um problema.  Bem, outro argumento apareceu na string de consulta, e da√≠?  Mas, do ponto de vista do Shrimp, a situa√ß√£o acabou sendo um pouco mais complicada, de modo que o c√≥digo da fun√ß√£o respons√°vel pela an√°lise da solicita√ß√£o HTTP se tornou mais complicado. <br><br>  O fato √© que antes era necess√°rio distinguir apenas duas situa√ß√µes: <br><br><ul><li>  veio uma solicita√ß√£o no formato "/filename.ext" sem nenhum outro par√¢metro.  Ent√£o voc√™ s√≥ precisa dar o arquivo "filename.ext" como est√°; </li><li>  Uma solicita√ß√£o veio no formato "/filename.ext?op=resize &amp; ...".  Nesse caso, voc√™ precisa dimensionar a imagem a partir do arquivo "filename.ext". </li></ul><br>  Por√©m, ap√≥s adicionar o formato de destino, precisamos distinguir entre quatro situa√ß√µes: <br><br><ul><li>  veio uma solicita√ß√£o no formato "/filename.ext" sem nenhum outro par√¢metro.  Ent√£o voc√™ s√≥ precisa dar o arquivo "filename.ext" como est√°, sem redimensionar e sem transcodificar para outro formato; </li><li>  veio uma solicita√ß√£o no formato "/filename.ext?target-format=fmt" sem nenhum outro par√¢metro.  Significa pegar uma imagem do arquivo "filename.ext" e transcodific√°-la para o formato "fmt", preservando os tamanhos originais; </li><li>  uma solicita√ß√£o veio no formato "/filename.ext?op=resize &amp; ...", mas sem o formato de destino.  Nesse caso, voc√™ precisa dimensionar a imagem no arquivo ‚Äúfilename.ext‚Äù e fornec√™-la no formato original; </li><li>  Uma solicita√ß√£o veio no formato "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  Nesse caso, voc√™ precisa executar a escala e depois transcodificar o resultado no formato "fmt". </li></ul><br>  Como resultado, a fun√ß√£o para determinar os par√¢metros da consulta assumiu o <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">seguinte formato</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Na vers√£o anterior do Shrimp, onde voc√™ n√£o precisava transcodificar a imagem, trabalhar com os par√¢metros de solicita√ß√£o <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">parecia um pouco mais f√°cil</a> . <br><br><h2>  Fila de solicita√ß√£o e cache de imagem adaptados ao formato de destino </h2><br>  O pr√≥ximo ponto na implementa√ß√£o do suporte ao formato de destino foi o trabalho na fila de solicita√ß√µes em espera e um cache de imagens prontas no agente a_transform_manager.  Falamos sobre essas coisas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com</a> mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no artigo anterior</a> , mas vamos lembr√°-lo um pouco do que se tratava. <br><br>  Quando uma solicita√ß√£o de convers√£o de imagem chega, pode ser que a imagem finalizada com esses par√¢metros j√° esteja no cache.  Nesse caso, voc√™ n√£o precisa fazer nada, basta enviar a imagem do cache em resposta.  Se a imagem precisar ser transformada, √© poss√≠vel que n√£o haja trabalhadores livres no momento e voc√™ precisar√° esperar at√© que ela apare√ßa.  Para fazer isso, as informa√ß√µes da solicita√ß√£o devem estar na fila.  Mas, ao mesmo tempo, √© necess√°rio verificar a exclusividade das solicita√ß√µes - se tivermos tr√™s solicita√ß√µes id√™nticas aguardando processamento (ou seja, precisamos converter a mesma imagem da mesma maneira), devemos processar a imagem apenas uma vez e fornecer o resultado do processamento em resposta para esses tr√™s pedidos.  I.e.  Na fila de espera, solicita√ß√µes id√™nticas devem ser agrupadas. <br><br>  No Shrimp, usamos uma chave composta simples para pesquisar o cache da imagem e a fila de espera: uma <a href="">combina√ß√£o do nome do arquivo original + das op√ß√µes de redimensionamento da imagem</a> .  Agora, dois novos fatores precisavam ser levados em considera√ß√£o: <br><br><ul><li>  em primeiro lugar, o formato da imagem de destino (ou seja, a imagem original pode estar em jpg e a imagem resultante pode estar em png); </li><li>  segundo, o fato de n√£o ser necess√°rio dimensionar a imagem.  Isso acontece em uma situa√ß√£o em que o cliente solicita apenas a convers√£o da imagem de um formato para outro, mas com o tamanho original da imagem preservado. </li></ul><br>  Devo dizer que aqui seguimos o caminho mais simples, sem tentar otimizar algo.  Por exemplo, pode-se tentar fazer dois caches: um armazenaria imagens no formato original, mas redimensionadas para o tamanho desejado e, no segundo, as imagens redimensionadas convertidas para o formato de destino. <br><br>  Por que esse cache duplo seria necess√°rio?  O fato √© que, ao transformar imagens, as duas opera√ß√µes mais caras no tempo est√£o redimensionando e serializando a imagem para o formato de destino.  Portanto, se recebemos uma solicita√ß√£o para dimensionar a imagem example.jpg para um tamanho de 1920 na largura e transform√°-la no formato webp, poder√≠amos armazenar duas imagens em nossa mem√≥ria: example_1920px_width.jpg e example_1920px_width.webp.  Damos uma imagem example_1920px_width.webp quando recebemos uma segunda solicita√ß√£o.  Mas a imagem example_1920px_width.jpg pode ser usada ao receber solicita√ß√µes para dimensionar example.jpg para um tamanho de 1920 na largura e transform√°-lo em formato heic.  Poder√≠amos pular a opera√ß√£o de redimensionamento e fazer apenas a convers√£o de formato (ou seja, a imagem final example_1920px_width.jpg seria transcodificada para o formato heic). <br><br>  Outra oportunidade potencial: quando uma solicita√ß√£o √© transcodificar uma imagem para outro formato sem redimensionar, voc√™ pode determinar o tamanho real da imagem e usar esse tamanho dentro da chave composta.  Por exemplo, deixe exemplo.jpg ter um tamanho de 3000x2000 pixels.  Se, em seguida, recebermos uma solicita√ß√£o para dimensionar example.jpg para 2000 px de altura, poderemos determinar imediatamente que j√° temos uma imagem desse tamanho. <br><br>  Em teoria, todas essas considera√ß√µes merecem aten√ß√£o.  Mas, do ponto de vista pr√°tico, n√£o est√° claro qu√£o alta √© a probabilidade de tal desenvolvimento de eventos.  I.e.  com que frequ√™ncia receberemos uma solicita√ß√£o de dimensionamento example.jpg para 1920px com convers√£o para webp e, em seguida, uma solicita√ß√£o para o mesmo dimensionamento da mesma imagem, mas com convers√£o para png?  N√£o ter estat√≠sticas reais √© dif√≠cil de dizer.  Portanto, decidimos n√£o complicar nossas vidas em nosso projeto de demonstra√ß√£o, mas seguir o caminho mais simples.  Com a expectativa de que se algu√©m precisar de esquemas de armazenamento em cache mais avan√ßados, isso poder√° ser adicionado posteriormente, a partir de cen√°rios reais, n√£o fict√≠cios, para o uso do Shrimp. <br><br>  Como resultado, na vers√£o atualizada do Shrimp, expandimos ligeiramente a chave, adicionando a ela tamb√©m um par√¢metro como o formato de destino: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  I.e.  solicita√ß√£o de redimensionamento example.jpg at√© 1920px com convers√£o para png difere do mesmo redimensionamento, mas com convers√£o para webp ou heic. <br><br>  Mas o foco principal est√° oculto <a href="">na nova implementa√ß√£o da classe resize_params_t</a> , que determina os novos tamanhos da imagem em escala.  <a href="">Anteriormente, essa classe</a> suportava tr√™s op√ß√µes: apenas a largura era definida, apenas a altura era definida ou o lado longo era definido (a altura ou a largura √© determinada pelo tamanho da imagem atual).  Assim, o <a href="">m√©todo resize_params_t :: value ()</a> sempre retornava algum valor real (que valor foi determinado pelo <a href="">m√©todo resize_params_t :: mode ()</a> ). <br><br>  Mas no novo camar√£o, outro modo foi adicionado - keep_original, o que significa que a escala n√£o √© executada e a imagem √© renderizada em seu tamanho original.  Para suportar esse modo, o resize_params_t precisou fazer algumas altera√ß√µes.  Primeiro, agora o <a href="">m√©todo resize_params_t :: make ()</a> determina se o modo keep_original √© usado (considera-se que esse modo √© usado se nenhum dos par√¢metros width, height e max na cadeia de consulta da solicita√ß√£o de entrada for especificado).  Isso nos permitiu n√£o reescrever a fun√ß√£o <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , que empurra a solicita√ß√£o de dimensionamento da imagem a ser executada. <br><br>  Em segundo lugar, o <a href="">m√©todo resize_params_t :: value ()</a> agora pode ser chamado nem sempre, mas apenas quando o modo de dimensionamento difere de keep_original. <br><br>  Mas o mais importante √© que <a href="">resize_params_t :: operator &lt;()</a> continuou a funcionar como pretendido. <br><br>  Gra√ßas a todas essas altera√ß√µes no a_transform_manager, o cache de imagem em escala e a fila de solicita√ß√µes em espera permaneceram os mesmos.  Mas agora, informa√ß√µes sobre v√°rias consultas s√£o armazenadas nessas estruturas de dados.  Portanto, a chave {"example.jpg", "jpg", keep_original} ser√° diferente da chave {"example.jpg", "png", keep_original} e da chave {"example.jpg", "jpg", width = 1920 px}. <br><br>  Aconteceu que, com a defini√ß√£o de estruturas de dados simples como resize_params_t e resize_params_key_t, evitamos alterar estruturas mais complexas, como o cache das imagens resultantes e a fila de solicita√ß√µes em espera. <br><br><h2>  Suporte para formato de destino no a_transformer </h2><br>  Bem, a etapa final no suporte ao formato de destino √© expandir a l√≥gica do agente a_transformer para que a imagem, possivelmente j√° em escala, seja convertida no formato de destino. <br><br>  Acabou sendo o mais f√°cil de fazer isso, <a href="">bastava</a> expandir o c√≥digo do <a href="">m√©todo a_transform_t :: handle_resize_request ()</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  Comparado <a href="">com a vers√£o anterior,</a> existem duas adi√ß√µes fundamentais. <br><br>  Primeiro, chamando o m√©todo verdadeiramente m√°gico image.magick () ap√≥s o redimensionamento.  Este m√©todo informa ao ImageMagick o formato da imagem resultante.  Ao mesmo tempo, a representa√ß√£o da imagem na mem√≥ria n√£o muda - o ImageMagick continua a armazen√°-lo da maneira que mais lhe conv√©m.  Mas o valor definido pelo m√©todo magick () ser√° levado em considera√ß√£o durante a chamada subsequente para Image :: write (). <br><br>  Em segundo lugar, a vers√£o atualizada registra o tempo necess√°rio para serializar a imagem no formato especificado.  A nova vers√£o do Shrimp agora corrige separadamente o tempo gasto no dimensionamento e o tempo gasto na convers√£o para o formato de destino. <br><br>  O restante do agente a_transformer_t n√£o sofreu nenhuma altera√ß√£o. <br><br><h1>  Paraleliza√ß√£o ImageMagick </h1><br>  Por padr√£o, o ImageMagic √© constru√≠do com suporte ao OpenMP.  I.e.  √© poss√≠vel paralelizar opera√ß√µes nas imagens que o ImageMagick executa.  Voc√™ pode controlar o n√∫mero de fluxos de trabalho que o ImageMagick usa nesse caso, usando a vari√°vel de ambiente MAGICK_THREAD_LIMIT. <br><br>  Por exemplo, na minha m√°quina de teste com o valor MAGICK_THREAD_LIMIT = 1 (ou seja, sem paraleliza√ß√£o real), obtenho os seguintes resultados: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  O tempo gasto no redimensionamento √© indicado no cabe√ßalho Shrimp-Resize-Time.  Nesse caso, s√£o 1086.72ms. <br><br>  Mas se voc√™ definir MAGICK_THREAD_LIMIT = 3 na mesma m√°quina e executar o Shrimp, obteremos valores diferentes: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  I.e.  o tempo de redimensionamento foi reduzido para 558,25 ms. <br><br>  Consequentemente, como o ImageMagick oferece a capacidade de paralelizar c√°lculos, voc√™ pode usar esta oportunidade.  Mas, ao mesmo tempo, √© desej√°vel poder controlar quantos threads de trabalho o Shrimp leva para si.  Nas vers√µes anteriores do Shrimp, n√£o era poss√≠vel influenciar quantos fluxos de trabalho o Shrimp cria.  E na vers√£o atualizada do Shrimp, isso pode ser feito.  Ou atrav√©s de vari√°veis ‚Äã‚Äãde ambiente, por exemplo: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  Ou atrav√©s de argumentos de linha de comando, por exemplo: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Os valores especificados na linha de comando t√™m uma prioridade mais alta. <br><br>  Deve-se enfatizar que MAGICK_THREAD_LIMIT afeta apenas as opera√ß√µes que o ImageMagick executa por si s√≥.  Por exemplo, o redimensionamento √© feito pelo ImageMagick.  Mas a convers√£o de um formato para outro ImageMagick delega para bibliotecas externas.  E como as opera√ß√µes nessas bibliotecas externas s√£o paralelizadas √© uma quest√£o separada que n√£o entendemos. <br><br><h1>  Conclus√£o </h1><br>  Talvez, nesta vers√£o do Shrimp, tenhamos trazido nosso projeto de demonstra√ß√£o para um estado aceit√°vel.  Quem quiser ver e experimentar pode encontrar os textos de origem do Shrimp no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BitBucket</a> ou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Voc√™ tamb√©m pode encontrar o Dockerfile l√° para criar camar√£o para suas experi√™ncias. <br><br>  Em geral, alcan√ßamos nossos objetivos que estabelecemos ao iniciar este projeto de demonstra√ß√£o.  Surgiram v√°rias id√©ias para o desenvolvimento futuro do RESTinio e do SObjectizer, e algumas delas j√° encontraram sua forma de realiza√ß√£o.  Portanto, se o camar√£o se desenvolver√° em algum lugar ainda mais completamente depende de perguntas e desejos.  Se houver, o camar√£o pode se expandir.  Caso contr√°rio, o Shrimp continuar√° sendo um projeto de demonstra√ß√£o e um campo de treinamento para experimentar novas vers√µes do RESTinio e SObjectizer. <br><br>  Concluindo, gostaria de expressar um agradecimento especial √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">aensidhe</a> por sua ajuda e conselhos, sem os quais nossas dan√ßas com um pandeiro seriam muito mais longas e tristes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420353/">https://habr.com/ru/post/pt420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420343/index.html">L√¢mpadas LED OK</a></li>
<li><a href="../pt420345/index.html">Vis√£o geral do centro de dados IXcellerate (a maior sala de m√°quinas na Federa√ß√£o Russa)</a></li>
<li><a href="../pt420347/index.html">Aprenda a criar seus pr√≥prios comandos bash em menos de 4 minutos</a></li>
<li><a href="../pt420349/index.html">Lista de verifica√ß√£o de terceiriza√ß√£o de TI: trabalhando sem riscos</a></li>
<li><a href="../pt420351/index.html">Como fazer pesquisas de usu√°rios no GitHub usando o Vue</a></li>
<li><a href="../pt420355/index.html">Rel√≥gio inteligente Pebble: como se tornar uma raridade da noite para o dia</a></li>
<li><a href="../pt420357/index.html">Vuex: estruturando grandes projetos e trabalhando com m√≥dulos</a></li>
<li><a href="../pt420359/index.html">Var, let ou const? Problemas de escopo vari√°vel e ES6</a></li>
<li><a href="../pt420361/index.html">Erro ao executar o TextBox.GetLineText no .NET WPF</a></li>
<li><a href="../pt420363/index.html">Webinars da HPE de agosto a outubro: novos t√≥picos (+ SHD, pr√°tica de IA, armazenamento de petabytes pronto para uso)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>