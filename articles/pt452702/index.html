<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèø üë©üèæ‚Äçüî¨ üôÖüèΩ Testes para c√≥digo e c√≥digo para testes üì∑ üè¶ üèÇüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em linguagens din√¢micas, como python e javascript, √© poss√≠vel substituir m√©todos e classes nos m√≥dulos diretamente durante a opera√ß√£o. Isso √© muito co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes para c√≥digo e c√≥digo para testes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452702/"><p>  Em linguagens din√¢micas, como python e javascript, √© poss√≠vel substituir m√©todos e classes nos m√≥dulos diretamente durante a opera√ß√£o.  Isso √© muito conveniente para testes - voc√™ pode simplesmente colocar "patches" que excluir√£o l√≥gica pesada ou desnecess√°ria no contexto deste teste. </p><br><p>  Mas o que fazer em C ++?  Vai?  Java?  Nesses idiomas, o c√≥digo n√£o pode ser modificado para testes em tempo real, e a cria√ß√£o de patches requer ferramentas separadas. </p><br><p>  Nesses casos, voc√™ deve escrever especificamente o c√≥digo para que seja testado.  Este n√£o √© apenas um desejo man√≠aco de ver 100% de cobertura em seu projeto.  Este √© um passo para escrever c√≥digo de qualidade e suportado. </p><br><p>  Neste artigo, tentarei falar sobre as principais id√©ias por tr√°s da escrita de c√≥digo test√°vel e mostrar como elas podem ser usadas com um exemplo de um programa go simples. </p><a name="habracut"></a><br><h2 id="beshitrostnaya-programma">  Programa n√£o complicado </h2><br><p> Escreveremos um programa simples para fazer uma solicita√ß√£o √† API do VK.  Este √© um programa bastante simples que gera uma solicita√ß√£o, faz, l√™ a resposta, decodifica a resposta do JSON em uma estrutura e exibe o resultado para o usu√°rio. </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/url"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = <span class="hljs-string"><span class="hljs-string">"token here"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//     var requestURL = fmt.Sprintf( "https://api.vk.com/method/%s?&amp;access_token=%s&amp;v=5.95", "users.get", token, ) //   resp, err := http.PostForm(requestURL, nil) //   if err != nil { fmt.Println(err) return } //       defer resp.Body.Close() //     body, err := ioutil.ReadAll(resp.Body) //   if err != nil { fmt.Println(err) return } //      var result struct { Response []struct { ID int `json:"id"` FirstName string `json:"first_name"` LastName string `json:"last_name"` } `json:"response"` } //        err = json.Unmarshal(body, &amp;result) //   if err != nil { fmt.Println(err) return } // ,    if len(result.Response) &lt; 1 { fmt.Println("No values in response array") return } //    fmt.Printf( "Your id: %d\nYour full name: %s %s\n", result.Response[0].ID, result.Response[0].FirstName, result.Response[0].LastName, ) }</span></span></code> </pre> <br><p>  Como profissionais de nossa √°rea, decidimos que era necess√°rio escrever testes para nossa aplica√ß√£o.  Crie um arquivo de teste ... </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { main() }</code> </pre> <br><p>  N√£o parece muito atraente.  Essa verifica√ß√£o √© um simples lan√ßamento de um aplicativo que n√£o podemos influenciar.  N√£o podemos excluir o trabalho com a rede, verificar a operacionalidade quanto a v√°rios erros e at√© substituir o token para verifica√ß√£o falhar√°.  Vamos tentar descobrir como melhorar este programa. </p><br><h2 id="pattern-vnedrenie-zavisimosti">  Padr√£o de inje√ß√£o de depend√™ncia </h2><br><p>  Primeiro, voc√™ precisa implementar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o "inje√ß√£o de depend√™ncia"</a> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> VKClient <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client VKClient)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestURL = fmt.Sprintf( <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/%s?&amp;access_token=%s&amp;v=5.95"</span></span>, <span class="hljs-string"><span class="hljs-string">"users.get"</span></span>, client.Token, ) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Adicionando uma estrutura, criamos uma depend√™ncia (chave de acesso) para o aplicativo, que pode ser transferida de diferentes fontes, o que evita os valores "com fio" e simplifica o teste. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workingToken = <span class="hljs-string"><span class="hljs-string">"workingToken"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo_Successful</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{workingToken} client.ShowUserInfo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo_EmptyToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{<span class="hljs-string"><span class="hljs-string">""</span></span>} client.ShowUserInfo() }</code> </pre> <br><h2 id="razdelenie-polucheniya-informacii-i-eyo-vyvoda">  Separa√ß√£o de recebimento de informa√ß√µes e sua sa√≠da </h2><br><p>  Agora apenas uma pessoa pode cometer um erro, e somente se souber qual deve ser a conclus√£o.  Para resolver esse problema, √© necess√°rio n√£o enviar informa√ß√µes diretamente para o fluxo de sa√≠da, mas adicionar m√©todos separados para obter informa√ß√µes e sua sa√≠da.  Essas duas partes independentes ser√£o mais f√°ceis de verificar e manter. </p><br><p>  Vamos criar o m√©todo <code>GetUserInfo()</code> , que retornar√° uma estrutura com informa√ß√µes do usu√°rio e um erro (se isso aconteceu).  Como esse m√©todo n√£o produz nada, os erros que ocorrerem ser√£o transmitidos ainda mais sem sa√≠da, para que o c√≥digo que precisa dos dados descubra a situa√ß√£o. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserInfo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> FirstName <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"first_name"`</span></span> LastName <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"last_name"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client VKClient)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserInfo, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestURL = fmt.Sprintf( <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/%s?&amp;access_token=%s&amp;v=5.95"</span></span>, <span class="hljs-string"><span class="hljs-string">"users.get"</span></span>, client.Token, ) resp, err := http.PostForm(requestURL, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UserInfo{}, err } <span class="hljs-comment"><span class="hljs-comment">// ... var result struct { Response []UserInfo `json:"response"` } // ... return result.Response[0], nil }</span></span></code> </pre> <br><p>  Altere <code>ShowUserInfo()</code> para que ele use <code>GetUserInfo()</code> e manipule erros. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client VKClient)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { userInfo, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } fmt.Printf( <span class="hljs-string"><span class="hljs-string">"Your id: %d\nYour full name: %s %s\n"</span></span>, userInfo.ID, userInfo.FirstName, userInfo.LastName, ) }</code> </pre> <br><p>  Agora, nos testes, voc√™ pode verificar se a resposta correta foi recebida do servidor e, se o token estiver incorreto, ser√° retornado um erro. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_GetUserInfo_Successful</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{workingToken} userInfo, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userInfo.ID == <span class="hljs-number"><span class="hljs-number">0</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"ID is empty"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userInfo.FirstName == <span class="hljs-string"><span class="hljs-string">""</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"FirstName is empty"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userInfo.LastName == <span class="hljs-string"><span class="hljs-string">""</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"LastName is empty"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo_EmptyToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{<span class="hljs-string"><span class="hljs-string">""</span></span>} _, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"Expected error but found &lt;nil&gt;"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err.Error() != <span class="hljs-string"><span class="hljs-string">"No values in response array"</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">`Expected "No values in response array", but found "%s"`</span></span>, err) } }</code> </pre> <br><p>  Al√©m de atualizar os testes existentes, voc√™ precisa adicionar novos testes para o m√©todo <code>ShowUserInfo()</code> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{workingToken} client.ShowUserInfo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo_WithError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := VKClient{<span class="hljs-string"><span class="hljs-string">""</span></span>} client.ShowUserInfo() }</code> </pre> <br><h2 id="nastraivaemye-alternativy">  Alternativas personalizadas </h2><br><p>  Os testes para <code>ShowUserInfo()</code> assemelham ao que tentamos evitar inicialmente.  Nesse caso, o √∫nico ponto do m√©todo √© enviar informa√ß√µes para o fluxo de sa√≠da padr√£o.  Por um lado, voc√™ pode tentar redefinir os.Stdout e verificar a sa√≠da, parece uma solu√ß√£o redundante quando voc√™ pode agir com mais eleg√¢ncia. </p><br><p>  Em vez de usar o <code>fmt.Printf</code> , voc√™ pode usar o <code>fmt.Fprintf</code> , que permite a sa√≠da para qualquer <code>io.Writer</code> .  <code>os.Stdout</code> implementa essa interface, o que nos permite substituir <code>fmt.Printf(text)</code> por <code>fmt.Fprintf(os.Stdout, text)</code> .  Depois disso, podemos colocar <code>os.Stdout</code> em um campo separado, que pode ser definido com os valores desejados (para testes - uma string, para trabalho - um fluxo de sa√≠da padr√£o). </p><br><p>  Como a capacidade de alterar o Writer para sa√≠da raramente ser√° usada, principalmente para testes, faz sentido definir um valor padr√£o.  Al√©m disso, faremos isso - tornar o tipo <code>VKClient</code> export√°vel e criar uma fun√ß√£o construtora para ele. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> vkClient <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> OutputWriter io.Writer } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVKClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vkClient</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vkClient{ token, os.Stdout, } }</code> </pre> <br><p>  Na fun√ß√£o <code>ShowUserInfo()</code> , substitu√≠mos as chamadas de <code>Print</code> por <code>Fprintf</code> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client vkClient)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { userInfo, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Fprintf(client.OutputWriter, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } fmt.Fprintf( client.OutputWriter, <span class="hljs-string"><span class="hljs-string">"Your id: %d\nYour full name: %s %s\n"</span></span>, userInfo.ID, userInfo.FirstName, userInfo.LastName, ) }</code> </pre> <br><p>  Agora voc√™ precisa atualizar os testes para que eles criem o cliente usando o construtor e instale outro gravador, quando necess√°rio. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := CreateVKClient(workingToken) buffer := bytes.NewBufferString(<span class="hljs-string"><span class="hljs-string">""</span></span>) client.OutputWriter = buffer client.ShowUserInfo() result, _ := ioutil.ReadAll(buffer) matched, err := regexp.Match( <span class="hljs-string"><span class="hljs-string">`Your id: \d+\nYour full name: [^\n]+\n`</span></span>, result, ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !matched { t.Fatalf(<span class="hljs-string"><span class="hljs-string">`Expected match but failed with "%s"`</span></span>, result) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_ShowUserInfo_WithError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := CreateVKClient(<span class="hljs-string"><span class="hljs-string">""</span></span>) buffer := bytes.NewBufferString(<span class="hljs-string"><span class="hljs-string">""</span></span>) client.OutputWriter = buffer client.ShowUserInfo() result, _ := ioutil.ReadAll(buffer) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(result) != <span class="hljs-string"><span class="hljs-string">"No values in response array"</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"Wrong error"</span></span>) } }</code> </pre> <br><p>  Para cada teste em que produzimos algo, criamos um buffer que desempenhar√° o papel de um fluxo de sa√≠da padr√£o.  Depois que a fun√ß√£o √© executada, verifica-se que os resultados correspondem √†s nossas expectativas - usando express√µes regulares ou uma compara√ß√£o simples. </p><br><p>  Por que estou usando express√µes regulares?  Para que os testes funcionem com qualquer token v√°lido que forne√ßo ao programa, independentemente do nome e ID do usu√°rio. </p><br><h2 id="pattern-vnedrenie-zavisimosti---2">  Padr√£o de inje√ß√£o de depend√™ncia - 2 </h2><br><p>  No momento, o programa tem uma cobertura de 86,4%.  Por que n√£o 100%?  N√£o podemos provocar erros de <code>http.PostForm()</code> , <code>ioutil.ReadAll()</code> e <code>json.Unmarshal()</code> , o que significa que n√£o podemos verificar cada " <code>return UserInfo, err</code> ". </p><br><p>  Para se dar ainda mais controle sobre a situa√ß√£o, voc√™ precisa criar uma interface na qual o <code>http.Client</code> se ajustar√°, cuja implementa√ß√£o ser√° no vkClient e usado para opera√ß√µes de rede.  Para n√≥s, na interface, apenas um m√©todo √© <code>PostForm</code> - <code>PostForm</code> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Networker <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { PostForm(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, url.Values) (*http.Response, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> vkClient <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> OutputWriter io.Writer Networker Networker } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVKClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vkClient</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vkClient{ token, os.Stdout, &amp;http.Client{}, } }</code> </pre> <br><p>  Tal movimento elimina a necessidade de executar opera√ß√µes de rede em geral.  Agora podemos simplesmente retornar os dados esperados do VKontakte usando o falso <code>Networker</code> .  Obviamente, n√£o se livre de testes que verificar√£o solicita√ß√µes ao servidor, mas n√£o h√° necessidade de fazer solicita√ß√µes em cada teste. </p><br><p>  Criaremos implementa√ß√µes para o <code>Networker</code> e <code>Reader</code> falsos, para que possamos testar os erros em cada caso - mediante solicita√ß√£o, ao ler o corpo e durante a desserializa√ß√£o.  Se queremos um erro ao chamar o PostForm, simplesmente o retornamos neste m√©todo.  Se queremos um erro <br>  ao ler o corpo da resposta - √© necess√°rio retornar um <code>Reader</code> falso, o que gerar√° um erro.  E se precisamos que o erro se manifeste durante a desserializa√ß√£o, retornamos a resposta com uma string vazia no corpo.  Se n√£o queremos erros, simplesmente retornamos o corpo com o conte√∫do especificado. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> fakeReader <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fakeReader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"Error on read"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> fakeNetworker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ErrorOnPostForm <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ErrorOnBodyRead <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ErrorOnUnmarchal <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RawBody <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn *fakeNetworker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PostForm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, url.Values)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*http.Response, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.ErrorOnPostForm { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"Error on PostForm"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.ErrorOnBodyRead { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;http.Response{Body: ioutil.NopCloser(fakeReader{})}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.ErrorOnUnmarchal { fakeBody := ioutil.NopCloser(bytes.NewBufferString(<span class="hljs-string"><span class="hljs-string">""</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;http.Response{Body: fakeBody}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } fakeBody := ioutil.NopCloser(bytes.NewBufferString(fn.RawBody)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;http.Response{Body: fakeBody}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Para cada situa√ß√£o problem√°tica, adicionamos um teste.  Eles criar√£o o <code>Networker</code> falso com as configura√ß√µes necess√°rias, de acordo com as quais ele lan√ßar√° um erro em um determinado momento.  Depois disso, chamamos a fun√ß√£o a ser verificada e garantimos que ocorreu um erro e esper√°vamos esse erro. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_GetUserInfo_ErrorOnPostForm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := CreateVKClient(workingToken) client.Networker = &amp;fakeNetworker{ErrorOnPostForm: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} _, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"Expected error but none found"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err.Error() != <span class="hljs-string"><span class="hljs-string">"Error on PostForm"</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">`Expected "Error on PostForm" but got "%s"`</span></span>, err.Error()) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_GetUserInfo_ErrorOnBodyRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := CreateVKClient(workingToken) client.Networker = &amp;fakeNetworker{ErrorOnBodyRead: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} _, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"Expected error but none found"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err.Error() != <span class="hljs-string"><span class="hljs-string">"Error on read"</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">`Expected "Error on read" but got "%s"`</span></span>, err.Error()) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_GetUserInfo_ErrorOnUnmarchal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := CreateVKClient(workingToken) client.Networker = &amp;fakeNetworker{ErrorOnUnmarchal: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} _, err := client.GetUserInfo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"Expected error but none found"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expectedError = <span class="hljs-string"><span class="hljs-string">"unexpected end of JSON input"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err.Error() != expectedError { t.Fatalf(<span class="hljs-string"><span class="hljs-string">`Expected "%s" but got "%s"`</span></span>, expectedError, err.Error()) } }</code> </pre> <br><p>  Usando o campo <code>RawBody</code> , <code>RawBody</code> pode se livrar das solicita√ß√µes de rede (basta retornar o que esperamos receber do VKontakte).  Isso pode ser necess√°rio para evitar exceder os limites de consulta durante o teste ou acelerar os testes. </p><br><h2 id="itogi">  Sum√°rio </h2><br><p>  Ap√≥s todas as opera√ß√µes no projeto, recebemos um pacote de 91 linhas (+170 linhas de testes), que suporta sa√≠da para qualquer <code>io.Writer</code> , permite usar m√©todos alternativos de trabalho com a rede (usando o adaptador para nossa interface), no qual existe um m√©todo como para produzir dados e obt√™-los.  O projeto tem 100% de cobertura.  Os testes verificam totalmente todas as respostas de linha e aplicativo a todos os erros poss√≠veis. </p><br><p>  Cada etapa no caminho para 100% de cobertura aumentou a modularidade, a manuten√ß√£o e a confiabilidade do aplicativo, portanto, n√£o h√° nada errado com os testes que determinam a estrutura do pacote. </p><br><p>  A testabilidade de qualquer c√≥digo √© uma qualidade que n√£o aparece no ar.  A testabilidade aparece quando o desenvolvedor usa padr√µes adequadamente em situa√ß√µes apropriadas e escreve c√≥digo personalizado e modular.  A principal tarefa foi mostrar o processo de racioc√≠nio ao executar programas de refatora√ß√£o.  Pensamentos semelhantes podem se estender a qualquer aplicativo e biblioteca, al√©m de outros idiomas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452702/">https://habr.com/ru/post/pt452702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452690/index.html">O que h√° de t√£o interessante na Ferrovia Transiberiana?</a></li>
<li><a href="../pt452692/index.html">O autor do projeto rePalm reescreveu o Palm OS do zero e planeja transform√°-lo em uma plataforma de rel√≥gio inteligente</a></li>
<li><a href="../pt452696/index.html">Como iniciar micropagamentos em seu aplicativo</a></li>
<li><a href="../pt452698/index.html">Dois em um: dados tur√≠sticos e ingressos para eventos culturais estavam dispon√≠veis ao p√∫blico</a></li>
<li><a href="../pt452700/index.html">Not√≠cias do mundo do OpenStreetMap No. 460 (7 de maio de 2019 a 13 de maio de 2019)</a></li>
<li><a href="../pt452704/index.html">Depura√ß√£o post-mortem no Cortex-M</a></li>
<li><a href="../pt452706/index.html">Em 1983, este computador da Bella Labs se tornou o primeiro grande mestre.</a></li>
<li><a href="../pt452712/index.html">Como tentamos trabalhar em equipe e o que aconteceu</a></li>
<li><a href="../pt452714/index.html">Preste aten√ß√£o # 5: Resumo de artigos sobre pensamento de produto, psicologia comportamental e produtividade</a></li>
<li><a href="../pt452716/index.html">Em busca de um ponto √≥timo de aplica√ß√£o de recursos humanos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>