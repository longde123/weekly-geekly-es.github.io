<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 👩🏿‍🤝‍👨🏾 🥪 Celesta 7.x：“打包”的ORM，迁移和测试 ✍🏻 🛥️ ✏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="也许您已经对开源Celesta库有所了解。 如果没有，没关系，现在我们将告诉您一切。 一年过去了，发布了7.x版，很多事情都发生了变化，是时候总结这些变化了，同时提醒人们Celesta的总体含义。 



如果您还没有听说过Celesta，并且在阅读本文时想了解其应用程序对哪些业务任务最有效，我可以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Celesta 7.x：“打包”的ORM，迁移和测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455746/"><p> 也许您已经对开源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Celesta</a>库有所了解。 如果没有，没关系，现在我们将告诉您一切。 一年过去了，发布了7.x版，很多事情都发生了变化，是时候总结这些变化了，同时提醒人们Celesta的总体含义。 </p><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/webt/jj/7z/jt/jj7zjthmrh2dhdo4v0ueefqj6uq.png"></div><a name="habracut"></a><br><p>如果您还没有听说过Celesta，并且在阅读本文时想了解其应用程序对哪些业务任务最有效，我可以推荐<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">旧文章</a>的第一部分或这段<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">半小时的视频</a> （关于使用Python语言的单词除外）。 但更好的是，请先阅读本文。 我将首先从版本7中发生的更改开始，然后再介绍一个完整的技术示例，该示例使用现代版本的Celesta使用Spring Boot为Java应用程序编写小型后端服务。 </p><br><h2 id="chto-izmenilos-v-versii-7x">  7.x版中有哪些更改？ </h2><br><ol><li> 我们拒绝将Jython用作Celesta内置的语言。 如果早些时候我们以业务逻辑是用Python编写的事实开始谈论Celesta，现在……任何Java语言都可以用作业务逻辑语言：Java，Groovy，JRuby或同一个Jython。 现在Celesta不再调用业务逻辑代码，但是业务逻辑代码使用Celesta及其数据访问类作为最常见的Java库。 是的，因此违反了向后兼容性，但这是我们愿意付出的代价。 不幸的是，我们对Jython的赌注失败了。 几年前，当我们开始使用Jython时，这是一个活跃而有希望的项目，但是多年来，它的开发速度减慢了，语言规范的积压工作积压了，大多数pip库的兼容性问题都没有解决。 最后一根稻草是最新语言版本中的新错误，这些错误在处理生产负荷时表现出来。 我们自己没有资源来支持Jython项目，因此我们决定退出该项目。  Celesta不再依赖Jython。 </li><li> 现在，数据访问类是使用Maven插件以Java语言（而不是Python）生成的。 因此，由于我们从动态类型转换为静态类型，因此存在更多的重构机会，并且编写主观正确的代码变得更加容易。 </li><li> 出现了对JUnit5的扩展，因此在JUnit5中编写与数据库一起使用的逻辑测试变得非常方便（稍后将进行讨论）。 </li><li> 出现了一个单独的项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-spring-boot-starter-celesta</a> ，顾名思义，它是Spring Boot中的Celesta启动器。 将Celesta应用程序打包到易于部署的Spring Boot服务中的能力弥补了通过使用Python脚本简单地更改文件夹来失去在服务器上更新应用程序的能力的损失。 </li><li> 我们将所有文档从Wiki转移为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AsciiDoctor</a>格式，并将其与代码一起置于版本控制中，现在我们拥有每个Celesta版本的最新文档。 对于最新版本，可在此处找到在线文档： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//courseorchestra.github.io/celesta/</a> </li><li> 经常被问到是否有可能通过与Celesta分开的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幂等DDL</a>使用数据库迁移。 现在，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2bass</a>工具就有了这样的机会。 </li></ol><br><h2 id="chto-takoe-selesta-i-chto-ona-umeet"> 什么是Celesta，她能做什么？ </h2><br><p> 简而言之，Celesta是： </p><br><ul><li> 基于<em>数据库优先</em>设计方法的关系数据库和业务逻辑代码之间的中间层， </li><li> 数据库结构迁移机制， </li><li> 测试与数据一起使用的代码的框架。 </li></ul><br><p> 我们支持四种类型的关系数据库：PostgreSQL，MS SQL Server，Oracle和H2。 </p><br><p>  Celesta的主要特点： </p><br><ol><li> 一个与Java基本原理非常相似的原理：“编写一次，在每个受支持的RDBMS上运行”。 业务逻辑代码不知道它将在哪种数据库上运行。 您可以编写业务逻辑代码并在MS SQL Server中运行它，然后切换到PostgreSQL，这将毫无复杂性地发生（嗯，几乎是:) </li><li> 在实时数据库上自动重组。  Celesta项目的整个生命周期都发生在工作数据库已经存在并且充满了需要保存的数据的情况下，但是也有必要不断更改其结构。  Celesta的主要功能之一是能够自动将数据库结构“适合”您的数据模型。 </li><li> 测试。 人们非常注意确保Celesta的代码是可测试的，以便我们可以自动测试修改数据库中数据的方法，而无需使用诸如DbUnit和容器之类的外部工具，即可轻松，快速，优雅地进行操作。 </li></ol><br><h2 id="dlya-chego-nuzhna-nezavisimost-ot-tipa-subd"> 为什么需要与DBMS类型无关？ </h2><br><p> 业务逻辑代码与DBMS类型的独立性并不是我们要讲的重点：为Celesta编写的代码根本不知道它运行在哪个DBMS上。 怎么了 </p><br><p> 首先，由于选择DBMS类型不是一个技术问题，而是一个政治问题。 来到一个新的商业客户时，我们经常发现他已经拥有一种喜欢的DBMS类型的投资资金，并且该客户希望在现有基础架构上查看其他解决方案。 技术格局正在发生变化：尽管MS SQL Server几年前在我们的实践中盛行，但在政府机构和私人公司中越来越发现PostgreSQL。  Celesta支持最常见的DBMS，我们并不担心这些更改。 </p><br><p> 其次，我想将已经创建的用于解决标准问题的代码从一个项目转移到另一个项目，以创建可重用的库。 诸如分层目录或电子邮件通知分发模块之类的东西本质上是标准的，为什么我们需要为具有不同关系的客户支持多个版本？ </p><br><p> 第三，最后但并非最不重要的一点是，无需使用内存中的H2数据库即可使用DbUnit和容器来运行单元测试的能力。 在此模式下，H2基础立即启动。  Celesta可以在其中快速创建一个数据方案，之后您可以进行必要的测试并“忘记”数据库。 由于业务逻辑代码实际上不知道它是在什么基础上执行的，因此，如果它在H2上运行时没有错误，那么就可以在PostgreSQL上运行。 当然，Celesta系统本身的开发人员的任务是使用真实的DBMS进行所有测试，以确保我们的平台在不同关系上平等地执行其API。 而我们做到了。 但是不再需要业务逻辑开发人员。 </p><br><h2 id="celestasql">  CelestaSQL </h2><br><p> 跨基础主义如何实现？ 当然，仅通过将逻辑与任何数据库细节隔离开的特殊API来处理数据为代价。  Celesta一方面生成用于访问数据的Java类，另一方面生成SQL代码和数据库内部的一些辅助对象。 </p><br><p>  Celesta不会以最纯粹的形式提供对象关系映射，因为在设计数据模型时，我们不是来自类，而是来自数据库结构。 也就是说，首先我们建立表的ER模型，然后，基于此模型，Celesta本身会生成用于访问数据的游标类。 </p><br><p> 您只能在每个受支持的DBMS上实现几乎相同功能的功能上才能完成相同的工作。 如果我们以“欧拉圈”的形式有条件地描述我们所支持的每个基地的功能能力，那么我们将得到以下图片： </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/getpro/habr/post_images/7d9/2ad/1e1/7d92ad1e1a3bc0bb83b5c4bcc511ec66.png"></div><br><p> 如果我们提供与数据库类型的完全独立性，那么我们向业务逻辑程序员开放的功能应位于所有基础的交集内。 乍一看，这似乎是一个重大限制。 是：某些特定功能，例如，我们不能使用SQL Server。 但无一例外，关系数据库支持表，外键，视图，序列，JOIN和GROUP BY的SQL查询。 因此，我们可以将这些机会提供给开发人员。 我们为开发人员提供“个性化的SQL”（我们称为“ CelestaSQL”），并在此过程中为相应数据库的方言生成SQL查询。 </p><br><p>  CelestaSQL语言包括用于定义数据库对象的DDL以及用于视图和过滤器的SELECT查询，但不包含DML命令：游标用于修改数据，尚待讨论。 </p><br><p> 每个数据库都有其自己的数据类型集。  CelestaSQL也有自己的一组类型。 在撰写本文时，其中有九种，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此表</a>将它们与各种数据库和Java数据类型中的真实类型进行了比较。 </p><br><p> 似乎九种类型是不够的（例如，与PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持的</a>类型相比），但实际上这些类型足以存储财务，贸易和物流信息：字符串，整数，小数，日期，布尔值和Blob始终足以表示此类数据。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>使用大量的语法图描述了CelestaSQL语言本身。 </p><br><h2 id="modifikaciya-struktury-bazy-dannyh-idempotentnyy-ddl"> 修改数据库结构。 幂等DDL </h2><br><p>  Celesta的另一个主要功能是随着项目的发展迁移工作数据库的结构的方法。 为此，使用内置于幂等DDL的Celesta中的方法。 </p><br><p> 简而言之，当我们用CelestaSQL编写以下文本时： </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) );</code> </pre> <br><p>  -Celesta不会将此文本解释为“创建表，但是如果已有表，则给出错误”，而是“将表带至所需的结构”。 也就是说：“如果没有表，请创建它，如果有表，请查看其中的字段，类型，索引，外键，默认值等，以及是否需要更改某些内容。这张桌子使它适合正确的种类。” </p><br><p> 通过这种方法，我们实现了重构和版本控制脚本以确定数据库结构的功能： </p><br><ul><li> 我们在脚本中看到了结构的当前“所需图像”， </li><li> 随着时间的推移，结构中发生了什么，由谁以及为什么发生了变化，我们可以查看版本控制系统， </li><li> 对于ALTER命令，Celesta会根据需要在“幕后”自动生成并执行它们。 </li></ul><br><p> 当然，这种方法有其局限性。  Celesta尽一切努力确保自动迁移是无痛且无缝的，但这并非在所有情况下都可行。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a>概述了这种方法的动机，可能性和局限性（也提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英语版本</a> ）。 </p><br><p> 为了加快检查/更新数据库结构的过程，Celesta在数据库中应用了DDL脚本校验和的存储（直到校验和被更改，才开始检查和更新数据库结构的过程）。 为了使更新过程继续进行而不会出现与彼此依赖的对象的更改顺序有关的问题，使用外键对方案之间的依赖关系进行拓扑排序。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>中将详细介绍自动迁移过程。 </p><br><h2 id="sozdanie-proekta-celesta-i-modeli-dannyh"> 创建Celesta项目和数据模型 </h2><br><p> 我们将考虑的演示项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">位于github上</a> 。 让我们看看在编写Spring Boot应用程序时如何使用Celesta。 这是您需要的Maven依赖项： </p><br><ul><li>  <code>org.springframework.boot:spring-boot-starter-web</code>和<code>ru.curs:spring-boot-starter-celesta</code> （有关更多详细信息， <code>ru.curs:spring-boot-starter-celesta</code>文档）。 </li><li> 如果您没有使用Spring Boot，则可以直接连接<code>ru.curs:celesta-system-services</code>依赖项。 </li><li> 为了基于<code>ru.curs:celesta-maven-plugin</code> -SQL脚本生成数据访问类的代码，需要使用<code>ru.curs:celesta-maven-plugin</code>演示示例或文档的源代码描述了如何连接它。 </li><li> 要利用为修改数据的方法编写JUnit5单元测试的功能，必须在测试范围内连接<code>ru.curs:celesta-unit</code> 。 </li></ul><br><p> 现在创建一个数据模型并编译数据访问类。 </p><br><p> 假设我们正在为一家电子商务公司做一个项目，该项目最近与另一家公司合并。 每个都有自己的数据库。 他们收集订单，但是在合并数据库之前，他们需要一个入口点才能从外部收集订单。 </p><br><p> 这个“入口点”的实现应该非常传统：带有CRUD操作的HTTP服务，该操作将数据存储在关系数据库中。 </p><br><p> 由于Celesta实施数据库优先设计方法，因此首先我们需要创建一个存储订单的表结构。 如您所知，订单是一个复合实体：它由一个标题组成，该标题存储了有关客户，订单日期和该订单其他属性的信息，以及许多行（商品）。 </p><br><p> 因此，为工作：创建 </p><br><ul><li>  <code>src/main/celestasql</code> -默认情况下，这是CelestaSQL项目脚本的路径 </li><li> 它包含重复Java包的文件夹结构的子文件夹（在本例中为<code>ru/curs/demo</code> ）。 </li><li> 在包文件夹中，创建一个具有以下内容的<code>.sql</code>文件： </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> demo <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderHeader( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> DATETIME, customer_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> customer_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), manager_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Pk_OrderHeader PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) ); <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk_OrderLine <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> OrderHeader(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> item_id;</code> </pre> <br><p> 在这里，我们描述了通过外键连接的两个表，以及一个视图，该视图将返回所有订单中存在的商品的汇总数量。 如您所见，这与常规SQL没什么不同，除了<code>CREATE SCHEMA</code>命令，我们在其中声明了<code>demo</code>模式版本（有关版本号如何影响自动迁移的信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ）。 但是也有功能。 例如，我们使用的所有表和字段名称都只能使它们可以用Java语言转换为有效的类和变量名称。 因此，排除空格，特殊字符。 您还可以注意到，我们放在表名和某些字段上的注释不是像往常一样以/ *开头，而是以/ **开头，JavaDoc注释是如何开始的-这绝非偶然！ 以/ **开头的实体定义的注释将在运行时在该实体的<code>.getCelestaDoc()</code>属性中提供。 当我们希望为数据库元素提供其他元信息时，这很有用：例如，人类可读的字段名称，有关如何在用户界面中表示字段的信息等。 </p><br><p>  CelestaSQL脚本执行两个同样重要的任务：首先，用于部署/修改关系数据库的结构，其次，用于数据访问类的代码生成。 </p><br><p> 我们现在可以生成数据访问类，只需运行<code>mvn generate-sources</code>命令，或者，如果您使用的是IDEA，请单击Maven控制面板中的“生成源和更新文件夹”按钮。 在第二种情况下，IDEA会“ <code>target/generated-sources/celesta</code>在<code>target/generated-sources/celesta</code>创建<code>target/generated-sources/celesta</code>文件夹，并将其内容可导入项目源代码中。 代码生成的结果如下所示-数据库中每个对象的一个​​类： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2x/3q/cs/2x3qcsydsu3y5vplbyh7oz15z-s.png"></div><br><p> 在应用程序设置中（在我们的情况下）在<code>src/main/resources/application.yml</code>文件中指定了到数据库的连接。 使用spring-boot-starter-celesta时，IDEA会告诉您代码完成中可用的代码选项。 </p><br><p> 如果我们不想为演示目的而使用“真实的” RDBMS，可以使用以下配置让Celesta在内存模式下使用内置H2数据库： </p><br><pre> <code class="plaintext hljs">celesta: h2: inMemory: true</code> </pre> <br><p> 要连接“真实”数据库，请将配置更改为类似 </p><br><pre> <code class="plaintext hljs">celesta: jdbc: url: jdbc:postgresql://127.0.0.1:5432/celesta username: &lt;your_username&gt; password: &lt;your_password&gt;</code> </pre> <br><p>  （在这种情况下，您还需要通过Maven依赖项将PostgreSQL JDBC驱动程序添加到应用程序中）。 </p><br><p> 当启动与数据库服务器连接的Celesta应用程序时，可以观察到为空数据库创建了必要的表，视图，索引等，而对于非空数据库，则将它们更新为DDL中指定的结构。 </p><br><h2 id="sozdanie-metodov-rabotayuschih-s-dannymi"> 创建数据处理方法 </h2><br><p> 一旦确定了如何创建数据库结构，就可以开始编写业务逻辑。 </p><br><p> 为了能够实现分配访问权限和日志记录操作的要求，对Celesta中数据的任何操作均代表用户执行，没有“匿名”操作。 因此，任何Celesta代码都在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CallContext</a>类中描述<em>的调用上下文中</em>执行。 </p><br><ul><li> 在开始可以修改数据库中数据的操作之前，请激活<code>CallContext</code> 。 </li><li> 激活时，将从连接池中获取与数据库的连接，然后事务开始。 </li><li> 操作<code>CallContext</code>如果操作成功，则<code>CallContext</code>执行<code>commit()</code>如果执行过程中发生未处理的异常，则执行<code>rollback()</code> ， <code>CallContext</code>关闭并且数据库连接将返回到池中。 </li></ul><br><p> 如果我们使用spring-boot-starter-celesta，那么<code>@CelestaTransaction</code>注释的所有方法自动执行这些操作。 </p><br><p> 假设我们要编写一个将文档保存到数据库的处理程序。 其控制器级别的代码可能如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/api"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DocumentService srv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DocumentService srv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.srv = srv; } <span class="hljs-meta"><span class="hljs-meta">@PutMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/save"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody OrderDto order)</span></span></span><span class="hljs-function"> </span></span>{ CallContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallContext(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//new SystemCallContext(); srv.postOrder(ctx, order); }</span></span></code> </pre> <br><p> 通常，在控制器方法级别（即，已经通过身份验证时），我们知道用户ID，并且可以在创建<code>CallContext</code>时使用它。 将用户绑定到上下文可以确定访问表的权限，还可以记录代表他所做的更改。 的确，在这种情况下，为了使代码与数据库进行交互的可操作性，必须在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统表中</a>指示对用户“ user1”的权限。 如果您不想使用Celesta访问分配系统，并赋予会话上下文对任何表的所有权限，则可以创建<code>SystemCallContext</code>对象。 </p><br><p> 在服务级别保存发票的方法可能如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context, OrderDto doc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); OrderLineCursor line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLineCursor(context)) { header.setId(doc.getId()); header.setDate(Date.from(doc.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant())); header.setCustomer_id(doc.getCustomerId()); header.setCustomer_name(doc.getCustomerName()); header.insert(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderLineDto docLine : doc.getLines()) { lineNo++; line.setLine_no(lineNo); line.setOrder_id(doc.getId()); line.setItem_id(docLine.getItemId()); line.setQty(docLine.getQty()); line.insert(); } } }</code> </pre> <br><p> 请注意<code>@CelestaTransaction</code>批注。 多亏了它，代理对象<code>DocumentService</code>将使用上述<code>CallContext ctx</code>参数执行所有这些服务操作。 也就是说，在方法执行的开始，它将已经绑定到数据库连接，并且事务将准备开始。 我们可以专注于编写业务逻辑。 在我们的例子中，读取<code>OrderDto</code>对象并将其保存到数据库。 </p><br><p> 为此，我们使用所谓的游标-使用<code>celesta-maven-plugin</code>生成的类。 我们已经看到了它们是什么。 为每个架构对象创建一个类-两个表和一个视图。 现在，我们可以使用这些类在业务逻辑中访问数据库对象。 </p><br><p> 要在订单表上创建游标并选择第一条记录，您需要编写以下代码： </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.tryFirst();</code> </pre> <br><p> 创建标题对象后，我们可以通过getter和setter访问表条目的字段： </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/webt/_8/gl/9i/_8gl9ikjbprpjano2dbvj0reme8.png"></div><br><p> 创建游标时，我们必须使用活动调用上下文-这是创建游标的唯一方法。 呼叫上下文携带有关当前用户及其访问权限的信息。 </p><br><p> 使用游标对象，我们可以做不同的事情：过滤，浏览记录，以及自然地插入，删除和更新记录。 整个游标API在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>中进行了详细描述。 </p><br><p> 例如，我们的示例代码可以按如下方式开发： </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.setRange(<span class="hljs-string"><span class="hljs-string">"manager_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"manager1"</span></span>); header.tryFirst(); header.setCounter(header.getCounter() + <span class="hljs-number"><span class="hljs-number">1</span></span>); header.update();</code> </pre> <br><p> 在此示例中，我们通过manager_id字段设置过滤器，然后使用tryFirst方法找到第一条记录。 </p><br><div class="spoiler">  <b class="spoiler_title">（为什么“尝试”）</b> <div class="spoiler_text"><p>  <code>get</code> ， <code>first</code> ， <code>insert</code> ， <code>update</code>方法有两个选项：不带try前缀（如<code>get(...)</code>等）和带try前缀（ <code>tryGet(...)</code> ， <code>tryFirst()</code>等）。 。 如果数据库没有适当的数据来执行操作，则没有try前缀的方法将引发异常。 例如，如果没有记录进入游标上的过滤器集，则first（）将引发异常。 同时，带有try前缀的方法不会引发异常，而是返回一个布尔值，该值指示相应操作的成功或失败。 建议的做法是尽可能使用不带try前缀的方法。 通过这种方式，创建了“自检”代码，及时在逻辑和/或数据库数据中发出错误信号。 </p></div></div><br><p> 触发<code>tryFirst</code> ， <code>tryFirst</code>变量将填充一条记录的数据，我们可以读取它们并为其分配值。 当游标中的数据完全准备好后，我们执行<code>update()</code> ，它将游标的内容存储在数据库中。 </p><br><p> 此代码可能会受到什么问题影响？ 当然，比赛条件的出现/丢失的更新！ 因为在我们收到带有“ tryFirst”行的数据的那一刻到我们试图在“ update”点更新该数据的那一刻之间，其他人已经可以在数据库中接收，修改和更新该数据。 读取数据后，游标绝不会阻止其他用户使用它们！ 为了防止丢失更新，Celesta使用了乐观锁定原则。 默认情况下，在每个表中， <code>recversion</code>都会创建一个<code>recversion</code>字段，并在UPDATE触发器的ON级别上递增版本号并验证更新的数据是否具有与该表相同的版本。 如果发生问题，则引发异常。 您可以在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">防止丢失的更新</a> ”中阅读有关此内容的更多信息。 </p><br><p> 再次回顾事务与CallContext对象相关联。 如果Celesta过程成功，则会发生提交。 如果Celesta方法以未处理的异常结束，则会发生回滚。 因此，如果在某个复杂的过程中发生错误，则会回滚与调用上下文有关的整个事务，就像我们尚未开始对数据做任何事情一样，数据也不会损坏。 如果由于某种原因，您需要在某种大型过程中间进行提交，则可以通过调用<code>context.commit()</code>来执行显式提交。 </p><br><h2 id="testirovanie-metodov-rabotayuschih-s-dannymi"> 测试数据方法 </h2><br><p> 让我们创建一个单元测试，以检查将<code>OrderDto</code>存储在数据库中的服务方法的正确性。 </p><br><p> 当使用JUnit5和<code>celesta-unit</code>模块中提供的JUnit5扩展时，这非常容易。 测试的结构如下： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentServiceTest</span></span></span><span class="hljs-class"> </span></span>{ DocumentService srv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentService(); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">documentIsPutToDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ OrderDto doc =... srv.postOrder(context, doc); <span class="hljs-comment"><span class="hljs-comment">//Check the fact that records are in the database OrderHeaderCursor header = new OrderHeaderCursor(context); header.tryFirst(); assertEquals(doc.getId(), header.getId()); OrderLineCursor line = new OrderLineCursor(context); line.setRange("order_id", doc.getId()); assertEquals(2, line.count()); } }</span></span></code> </pre> <br><p> 感谢注解<code>@CelestaTest</code> （它是<code>@CelestaTest</code>的扩展），我们能够在测试方法中声明<code>CallContext context</code>参数。 该上下文已被激活并绑定到数据库（内存中的H2），因此我们不需要将服务类包装在代理中-我们使用<code>new</code>而不是使用Spring创建它。 但是，如有必要，请使用Spring工具将服务注入测试中，这没有任何障碍。 </p><br><p> 我们创建单元测试的前提是，在执行之前，数据库将完全为空，但是具有所需的结构，并且在执行之后，我们不必担心我们在数据库中留下了“垃圾”。 这些测试以很高的速度执行。 </p><br><p> 让我们创建第二个过程，该过程返回带有聚合值的JSON，以显示我们订购了多少产品。 </p><br><p> 该测试将两个订单写入数据库，然后检查新的<code>getAggregateReport</code>方法返回的<code>getAggregateReport</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportReturnsAggregatedQuantities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ srv.postOrder(context, . . .); srv.postOrder(context, . . .); Map&lt;String, Integer&gt; result = srv.getAggregateReport(context); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"A"</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">7</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"B"</span></span>).intValue()); }</code> </pre> <br><p> 为了实现<code>getAggregateReport</code>方法<code>getAggregateReport</code>我们将使用OrderedQty视图，我记得，在CelestaSQL文件中，该视图如下所示： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p> 要求是标准的：我们按数量汇总订单行，并按产品代码分组。 已经为该视图创建了OrderedQtyCursor游标，我们可以使用它。 我们声明此游标，对其进行迭代并收集所需的<code>Map&lt;String, Integer&gt;</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAggregateReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderedQtyCursor ordered_qty = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedQtyCursor(context)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderedQtyCursor line : ordered_qty) { result.put(ordered_qty.getItem_id(), ordered_qty.getQty()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2 id="materializovannye-predstavleniya-celesta"> 物化Celesta视图 </h2><br><p> 为什么使用视图不利于获取聚合数据？ 这种方法是可行的，但实际上，它在整个系统中都放置了定时炸弹：毕竟，作为SQL查询的视图在系统中累积数据时运行的速度越来越慢。 他将不得不总结和分组越来越多的行。 如何避免这种情况？ </p><br><p>  Celesta尝试实现在平台级别上业务逻辑程序员经常面临的所有标准任务。 </p><br><p>  MS SQL Server具有实例化（索引）视图的概念，这些视图存储为表并随着源表中数据的更改而快速更新。 如果我们在“干净​​的” MS SQL Server中工作，那么对于我们而言，用索引视图替换视图将正是我们所需要的：检索汇总的报告不会因为累积的数据而减慢速度，并且此时将执行更新汇总的报告的工作。将数据插入订单行表中，并且随着行数的增加也不会增加太多。 </p><br><p> 但是，如果我们通过Celesta使用PostgreSQL，该怎么办？ 通过添加物化这个词来重新定义视图： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">materialized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p> 让我们启动系统，看看数据库发生了什么。 </p><br><p> 我们将注意到<code>OrderedQty</code>消失了，而出现了<code>OrderedQty</code>表。 同时，在OrderLine表中填充数据后，OrderedQty表中的信息将被“神奇地”更新，就像OrderedQty将是一个视图一样。 </p><br><p> 如果我们看一下基于<code>OrderLine</code>表构建的触发器，那么这里没有魔术。  Celesta收到了创建“物化视图”的任务，分析了查询并在<code>OrderLine</code>表上创建了用于更新<code>OrderedQty</code> 。 通过在CelestaSQL文件中插入一个具体化的关键字，我们解决了性能下降的问题，甚至不需要更改业务逻辑代码！ </p><br><p> ,    ,   , . «»  Celesta    ,    ,  JOIN-,    GROUP BY.     ,  , ,     ,      . .     . </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>       Celesta.     —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455746/">https://habr.com/ru/post/zh-CN455746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455736/index.html">通过混合和Multi-PoW挖矿实现加密货币共识</a></li>
<li><a href="../zh-CN455738/index.html">如何通过数据获利十亿美元？</a></li>
<li><a href="../zh-CN455740/index.html">投资公司的机器学习：我们将技术支持电话分类</a></li>
<li><a href="../zh-CN455742/index.html">制作音乐：简单的解决方案胜过深度学习</a></li>
<li><a href="../zh-CN455744/index.html">具有改善的视觉真实感的迷宫景观生成系统[Jimmo Kim的翻译]</a></li>
<li><a href="../zh-CN455754/index.html">漂移平流器的测试。 将Rogozin和LoRa发射到平流层</a></li>
<li><a href="../zh-CN455756/index.html">是[喜欢]</a></li>
<li><a href="../zh-CN455758/index.html">零售火箭的增长黑客：从假设搜索到测试技术</a></li>
<li><a href="../zh-CN455760/index.html">SwiftUI或关于功能构建器的魔力</a></li>
<li><a href="../zh-CN455762/index.html">马尔可夫链条简介</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>