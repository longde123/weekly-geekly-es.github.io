<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë ü§òüèø ‚è´ Des philosophes bien nourris ou une programmation .NET comp√©titive üëèüèº üö∂üèº üåä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voyons comment fonctionne la programmation simultan√©e et parall√®le dans .Net, en utilisant le probl√®me des philosophes de la restauration comme exempl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des philosophes bien nourris ou une programmation .NET comp√©titive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447898/"><p><img src="https://habrastorage.org/webt/ox/lr/6d/oxlr6dmndsfjh_zjsowzpozt-30.png"></p><br><p>  Voyons comment fonctionne la programmation simultan√©e et parall√®le dans .Net, en utilisant le probl√®me des philosophes de la restauration comme exemple.  Un tel plan, de la synchronisation des threads / processus, au mod√®le des acteurs (dans les parties suivantes).  L'article peut √™tre utile pour une premi√®re connaissance ou pour rafra√Æchir vos connaissances. </p><br><p>  Pourquoi √™tre capable de faire √ßa?  Les transistors atteignent leur taille minimale, la loi de Moore repose sur la limitation de la vitesse de la lumi√®re, et donc la croissance est observ√©e en quantit√©, plus de transistors peuvent √™tre r√©alis√©s.  Dans le m√™me temps, la quantit√© de donn√©es augmente et les utilisateurs attendent une r√©action imm√©diate des syst√®mes.  Dans une telle situation, la programmation ¬´normale¬ª, lorsque nous avons un thread d'ex√©cution, n'est plus efficace.  Il est n√©cessaire de r√©soudre en quelque sorte le probl√®me de l'ex√©cution simultan√©e ou comp√©titive.  De plus, ce probl√®me existe √† diff√©rents niveaux: au niveau des flux, au niveau des processus, au niveau des machines du r√©seau (syst√®mes distribu√©s).  .NET dispose de technologies de haute qualit√© et √©prouv√©es pour r√©soudre rapidement et efficacement ces probl√®mes. </p><a name="habracut"></a><br><br><h2 id="anchorproblemanchor-zadacha"><a name="problem"></a>  D√©fi </h2><br><p>  Edsger Dijkstra a pos√© ce probl√®me √† ses √©l√®ves d√®s 1965. Le libell√© √©tabli est le suivant.  Il y a un certain nombre (g√©n√©ralement cinq) de philosophes et autant de fourchettes.  Ils sont assis √† la table ronde, fourchettes entre les deux.  Les philosophes peuvent manger dans leur assiette avec une nourriture sans fin, penser ou attendre.  Pour manger le philosophe, vous devez prendre deux fourchettes (cette derni√®re partage la fourchette avec la premi√®re).  Pour prendre et mettre une fourchette - deux actions distinctes.  Tous les philosophes se taisent.  La t√¢che est de trouver un tel algorithme qu'ils pensent tous et en ont marre m√™me apr√®s 54 ans. </p><br><p>  Tout d'abord, essayons de r√©soudre ce probl√®me en utilisant l'espace partag√©.  Les fourchettes sont sur la table et les philosophes les prennent quand elles sont et les remettent.  Il y a des probl√®mes de synchronisation, quand exactement prendre les bouchons?  Que faire s'il n'y a pas de prise?  et d'autres. Mais d'abord, lan√ßons les philosophes. </p><br><p> Pour d√©marrer les threads, utilisez le pool de threads via la m√©thode <code>Task.Run</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelTokenSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; philosophersAmount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> icopy = i; <span class="hljs-comment"><span class="hljs-comment">//      .  RunDeadlock   // ,    .  . philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token); }</span></span></code> </pre> <br><p>  Pool de threads cr√©√© pour optimiser la cr√©ation et la suppression de threads.  Ce pool poss√®de une file d'attente de t√¢ches et le CLR cr√©e ou supprime des unit√©s d'ex√©cution en fonction du nombre de ces t√¢ches.  Un pool pour tous les AppDomains.  Ce pool doit √™tre utilis√© presque toujours, car  vous n'avez pas besoin de vous soucier de cr√©er, supprimer des threads, leurs files d'attente, etc. C'est possible sans pool, mais vous devez alors utiliser <code>Thread</code> directement, il est conseill√© dans les cas o√π vous devez changer la priorit√© d'un thread, lorsque nous avons une longue op√©ration, pour le premier plan d'un thread, etc. </p><br><p>  Et la classe <code>System.Threading.Tasks.Task</code> permet simplement de travailler avec ce pool de threads (ou m√™me de s'en passer).  Il s'agit d'une op√©ration asynchrone.  En gros, c'est le m√™me <code>Thread</code> , mais avec toutes sortes de commodit√©s: la possibilit√© de lancer des t√¢ches apr√®s un bloc d'autres t√¢ches, de les renvoyer des fonctions, il est pratique de les interrompre, et bien d'autres.  etc. Ils sont n√©cessaires pour prendre en charge les constructions asynchrones / en attente (mod√®le asynchrone bas√© sur les t√¢ches, sucre syntaxique pour attendre le fonctionnement d'E / S).  Nous en reparlerons. </p><br><p>  <code>CancelationTokenSource</code> est n√©cessaire ici afin que le thread lui-m√™me puisse √™tre termin√© par le signal du thread appelant. </p><br><h2 id="problemy-s-sinhronizaciey">  Probl√®mes de synchronisation </h2><br><h3 id="blokirovannye-filosofy">  Philosophes bloqu√©s </h3><br><p>  Ok, on peut cr√©er des threads, essayons de d√©jeuner: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    .  : 1 1 3 3 - 1  3    . private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray(); //  ,  RunPhilosopher() private void RunDeadlock(int i, CancellationToken token) { //  ,  . : // while(true) // if forks[fork] == 0 // forks[fork] = i+1 // break // Thread.Sleep()  Yield()  SpinWait() void TakeFork(int fork) =&gt; SpinWait.SpinUntil(() =&gt; Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0); //  ,    Interlocked.Exchange: void PutFork(int fork) =&gt; forks[fork] = 0; while (true) { TakeFork(Left(i)); TakeFork(Right(i)); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutFork(Left(i)); PutFork(Right(i)); Think(i); //   -. token.ThrowIfCancellationRequested(); } }</span></span></code> </pre> <br><p>  Ici, nous essayons d'abord de prendre les fourchettes de gauche puis de droite, et si cela fonctionne, nous les mangeons et les remettons.  Prendre une fourchette est atomique, c'est-√†-dire  deux flux ne peuvent pas prendre un en m√™me temps (√† tort: ‚Äã‚Äãle premier lit que la prise est libre, le second aussi, le premier prend, le second prend).  Pour ce faire, <code>Interlocked.CompareExchange</code> , qui doit √™tre impl√©ment√© √† l'aide d'une instruction de processeur ( <code>TSL</code> , <code>XCHG</code> ), qui bloque un morceau de m√©moire pour la lecture et l'√©criture atomiques s√©quentielles.  Et SpinWait est √©quivalent √† une construction <code>while(true)</code> avec seulement un peu de "magie" - le thread prend le processeur ( <code>Thread.SpinWait</code> ), mais transf√®re parfois le contr√¥le √† un autre thread ( <code>Thread.Yeild</code> ) ou s'endort ( <code>Thread.Sleep</code> ). </p><br><p>  Mais cette solution ne fonctionne pas, car  les flux seront bient√¥t bloqu√©s (pour moi dans une seconde): tous les philosophes prennent leur fourche gauche, mais pas celle de droite.  Le tableau des fourches a alors des valeurs: 1 2 3 4 5. </p><br><p><img src="https://habrastorage.org/webt/4l/0x/h9/4l0xh9rwiyjh1l8u2z2szlnv--o.png" alt="Livelock"></p><br><p>  Sur la figure, blocage des threads (blocage).  Le vert indique l'ex√©cution, le rouge indique la synchronisation et le gris indique le sommeil.  Les losanges indiquent l'heure de d√©but de la t√¢che. </p><br><h3 id="golod-filosofov">  La faim des philosophes </h3><br><p>  Bien qu'il ne soit pas n√©cessaire de penser particuli√®rement √† la nourriture, vous devez obliger quiconque √† abandonner la philosophie.  Essayons de simuler la situation des flux de je√ªne dans notre probl√®me.  La famine, c'est quand le ruisseau fonctionne, mais sans travail important, en d'autres termes, c'est la m√™me impasse, seulement maintenant le ruisseau ne dort pas, mais cherche activement quelque chose √† manger, mais il n'y a pas de nourriture.  Afin d'√©viter un blocage fr√©quent, nous remettrons la fiche si nous ne pouvions pas en prendre une autre. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      RunDeadlock,         . private void RunStarvation(int i, CancellationToken token) { while (true) { bool hasTwoForks = false; var waitTime = TimeSpan.FromMilliseconds(50); //      : bool hasLeft = forks[Left(i)] == i + 1; if (hasLeft || TakeFork(Left(i), i + 1, waitTime)) { if (TakeFork(Right(i), i + 1, TimeSpan.Zero)) hasTwoForks = true; else PutFork(Left(i)); //      . } if (!hasTwoForks) { if (token.IsCancellationRequested) break; continue; } eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); bool goodPhilosopher = i % 2 == 0; //        : if (goodPhilosopher) PutFork(Left(i)); //      ,      . PutFork(Right(i)); Think(i); if (token.IsCancellationRequested) break; } } //     . bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null) { return SpinWait.SpinUntil( () =&gt; Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0, waitTime ?? TimeSpan.FromMilliseconds(-1) ); }</span></span></code> </pre> <br><p>  Dans ce code, il est important que deux philosophes sur quatre oublient de mettre leur fork gauche.  Et il s'av√®re qu'ils mangent plus de nourriture, tandis que d'autres commencent √† mourir de faim, bien que les flux aient la m√™me priorit√©.  Ici, ils ne meurent pas de faim, car  les mauvais philosophes remettent parfois leurs fourchettes.  Il s'av√®re que les bons mangent environ 5 fois moins que les mauvais.  Une petite erreur dans le code entra√Æne donc une baisse des performances.  Ici, il convient de noter qu'une situation rare est possible lorsque tous les philosophes prennent la fourche gauche, il n'y a pas de droite, ils mettent la gauche, attendent, reprennent la gauche, etc.  Cette situation est √©galement la famine, plus comme une impasse.  Je n'ai pas pu le r√©p√©ter.  Ci-dessous, une image d'une situation o√π deux mauvais philosophes ont pris les deux fourchettes et deux bons philosophes meurent de faim. </p><br><p><img src="https://habrastorage.org/webt/2v/iw/b_/2viwb_qgxqznj1timeklnwscluw.png" alt="Famine"></p><br><p>  Ici, vous pouvez voir que les threads se r√©veillent parfois et essaient d'obtenir une ressource.  Deux des quatre c≈ìurs ne font rien (le graphique vert en haut). </p><br><h3 id="smert-filosofa">  La mort du philosophe </h3><br><p>  Eh bien, un autre probl√®me qui peut interrompre le glorieux d√Æner des philosophes est si l'un d'eux meurt soudainement avec des fourchettes dans ses mains (et ils l'enterreront comme √ßa).  Ensuite, les voisins seront laiss√©s sans d√©jeuner.  Vous pouvez <code>NullReferenceException</code> exemple de code pour ce cas vous-m√™me, par exemple, une <code>NullReferenceException</code> lev√©e apr√®s que le philosophe a pris les fourchettes.  Et, soit dit en passant, l'exception ne sera pas trait√©e et le code appelant ne la d√©tectera tout simplement pas (pour cela, <code>AppDomain.CurrentDomain.UnhandledException</code> , etc.).  Par cons√©quent, les gestionnaires d'erreurs sont n√©cessaires dans les threads eux-m√™mes et avec la terminaison correcte. </p><br><h2 id="oficiant">  Serveur </h2><br><p>  Eh bien, comment pouvons-nous r√©soudre ce probl√®me avec les impasses, la famine et la mort?  Nous n'autoriserons qu'un seul philosophe √† bifurquer, ajouter l'exclusion mutuelle des flux pour ce lieu.  Comment faire  Supposons qu'un serveur se trouve √† c√¥t√© des philosophes qui autorise un philosophe √† prendre des fourchettes.  Comment faire de ce serveur et comment les philosophes lui posent des questions int√©ressantes. </p><br><p>  La mani√®re la plus simple est lorsque les philosophes demandent simplement constamment au serveur l'acc√®s aux fourches.  C'est-√†-dire  maintenant les philosophes n'attendront pas une prise √† proximit√©, mais attendent ou demandent √† un serveur.  Tout d'abord, nous n'utilisons que l'espace utilisateur pour cela, nous n'utilisons pas d'interruptions pour appeler des proc√©dures √† partir du noyau (√† leur sujet ci-dessous). </p><br><h3 id="resheniya-v-prostranstve-polzovatelya">  Solutions d'espace utilisateur </h3><br><p>  Ici, nous ferons la m√™me chose que nous faisions avec une fourchette et deux philosophes, nous tournerons dans un cycle et attendrons.  Mais maintenant, ce seront tous les philosophes et comme si une seule fourchette, c'est-√†-dire  on peut dire qu'il n'y aura que ce philosophe qui aura pris cette "fourchette d'or" au serveur.  Pour cela, nous utilisons SpinLock. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SpinLock spinLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinLock(); <span class="hljs-comment"><span class="hljs-comment">//  "" private void RunSpinLock(int i, CancellationToken token) { while (true) { //    busy waiting.   try,  //        SpinLock. bool hasLock = false; spinLock.Enter(ref hasLock); try { //       (mutual exclusion). forks[Left(i)] = i + 1; //   ,  . forks[Right(i)] = i + 1; eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); forks[Left(i)] = 0; forks[Right(i)] = 0; } finally { if(hasLock) spinLock.Exit(); //     . } Think(i); if (token.IsCancellationRequested) break; } }</span></span></code> </pre> <br><p>  <code>SpinLock</code> est un bloqueur, avec, grosso modo, le m√™me <code>while(true) { if (!lock) break; }</code>  <code>while(true) { if (!lock) break; }</code> , mais avec encore plus de "magie" que dans <code>SpinWait</code> (qui y est utilis√©).  Maintenant, il sait compter ceux qui attendent, les endormir un peu, et plus encore.  etc. En g√©n√©ral, fait tout son possible pour optimiser.  Mais nous devons nous rappeler que c'est toujours le m√™me cycle actif qui mange les ressources du processeur et conserve un thread qui peut conduire √† la famine si l'un des philosophes devient une priorit√© sur les autres, mais n'a pas de fourche dor√©e (probl√®me d'inversion de priorit√©).  Par cons√©quent, nous l'utilisons uniquement pour des changements tr√®s tr√®s courts dans la m√©moire partag√©e, sans aucun appel tiers, verrous imbriqu√©s, etc. surprises. </p><br><p><img src="https://habrastorage.org/webt/ev/wu/kk/evwukkxrcgfutky1cihoe5dns0e.png" alt="Spinlock"></p><br><p>  Figure pour <code>SpinLock</code> .  Les streams se "battent" constamment pour la fourchette dor√©e.  Des √©checs se produisent - dans la figure, la zone s√©lectionn√©e.  Les noyaux ne sont pas pleinement utilis√©s: seulement environ 2/3 de ces quatre fils. </p><br><p>  Une autre solution ici serait d'utiliser uniquement <code>Interlocked.CompareExchange</code> avec la m√™me attente active, comme indiqu√© dans le code ci-dessus (chez les philosophes affam√©s), mais cela, comme d√©j√† mentionn√©, pourrait th√©oriquement conduire au blocage. </p><br><p>  √Ä propos d' <code>Interlocked</code> il convient de dire qu'il existe non seulement <code>CompareExchange</code> , mais √©galement d'autres m√©thodes de lecture et d'√©criture atomiques.  Et en r√©p√©tant les modifications dans le cas o√π un autre thread parvient √† effectuer ses modifications (lecture 1, lecture 2, √©criture 2, √©criture 1 est mauvaise), il peut √™tre utilis√© pour des modifications complexes d'une valeur (motif interverrouill√©). </p><br><h3 id="resheniya-v-rezhime-yadra">  Solutions en mode noyau </h3><br><p>  Pour √©viter de perdre des ressources dans une boucle, voyons comment vous pouvez bloquer un flux.  En d'autres termes, en poursuivant notre exemple, nous verrons comment le serveur endort le philosophe et ne le r√©veille qu'en cas de besoin.  Voyons d'abord comment proc√©der via le mode noyau du syst√®me d'exploitation.  Toutes les structures se r√©v√®lent souvent plus lentes que celles de l'espace utilisateur.  Plusieurs fois plus lent, par exemple <code>AutoResetEvent</code> peut √™tre 53 fois plus lent que <code>SpinLock</code> [Richter].  Mais avec leur aide, vous pouvez synchroniser les processus √† travers le syst√®me, g√©r√©s ou non. </p><br><p>  La construction principale ici est le s√©maphore propos√© par Dijkstroy il y a plus d'un demi-si√®cle.  Un s√©maphore est, en termes simples, un entier positif contr√¥l√© par un syst√®me, et deux op√©rations sur lui - augmenter et diminuer.  Si la r√©duction ne fonctionne pas, z√©ro, le thread appelant est bloqu√©.  Lorsque le nombre est augment√© par un autre thread / processus actif, les threads sont ignor√©s et le s√©maphore diminue √† nouveau du nombre de ceux pass√©s.  Vous pouvez imaginer des trains dans un goulot d'√©tranglement avec un s√©maphore.  .NET propose plusieurs conceptions avec des fonctionnalit√©s similaires: <code>AutoResetEvent</code> , <code>ManualResetEvent</code> , <code>Mutex</code> et <code>Semaphore</code> lui-m√™me.  Nous utiliserons <code>AutoResetEvent</code> , c'est la plus simple de ces constructions: seules deux valeurs sont 0 et 1 (false, true).  Sa m√©thode <code>WaitOne()</code> bloque le thread appelant si la valeur √©tait 0, et si 1, puis s'abaisse √† 0 et la saute.  Et la m√©thode <code>Set()</code> augmente √† 1 et saute une attente, qui diminue √† nouveau √† 0. Elle agit comme un tourniquet dans le m√©tro. </p><br><p>  Nous compliquerons la solution et utiliserons le verrou pour chaque philosophe, et pas pour tout le monde √† la fois.  C'est-√†-dire  maintenant il peut y avoir plusieurs philosophes √† la fois, et pas un.  Mais encore une fois, nous bloquons l'acc√®s √† la table afin de prendre correctement les fourchettes, en √©vitant les courses (conditions de course). </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    . // : new AutoResetEvent(true)  . private AutoResetEvent[] philosopherEvents; //     /   . private AutoResetEvent tableEvent = new AutoResetEvent(true); //  . public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); //  . // .    . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); //     . Think(i); if (token.IsCancellationRequested) break; } } //    . void TakeForks(int i) { bool hasForks = false; while (!hasForks) //    (  ). { //    ,    . tableEvent.WaitOne(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) forks[Left(i)] = forks[Right(i)] = i + 1; hasForks = forks[Left(i)] == i + 1 &amp;&amp; forks[Right(i)] == i + 1; if (hasForks) //   ,   .  Set //  ,   true. philosopherEvents[i].Set(); //   .    tableEvent  false. tableEvent.Set(); //   true,  ,   false,    Set  . philosopherEvents[i].WaitOne(); } } //     . void PutForks(int i) { tableEvent.WaitOne(); //    . forks[Left(i)] = 0; //  ,     ,  AutoResetEvent  true. philosopherEvents[LeftPhilosopher(i)].Set(); forks[Right(i)] = 0; philosopherEvents[RightPhilosopher(i)].Set(); tableEvent.Set(); }</span></span></code> </pre> <br><p>  Pour comprendre ce qui se passe ici, consid√©rons le cas o√π le philosophe n'a pas pris les fourchettes, alors ses actions seront comme √ßa.  Il attend l'acc√®s √† la table.  L'ayant re√ßu, il essaie de prendre les fourchettes.  √áa n'a pas march√©.  Il donne acc√®s √† la table (exclusion mutuelle).  Et il passe son "tourniquet" ( <code>AutoResetEvent</code> ) (au d√©but ils sont ouverts).  Il entre √† nouveau dans le cycle, car  il n'a pas de fourches.  Tente de les prendre et s'arr√™te √† son tourniquet.  Un voisin plus chanceux √† droite ou √† gauche, ayant fini de manger, d√©verrouille notre philosophe, "ouvrant son tourniquet".  Notre philosophe le passe (et il se ferme derri√®re) pour la deuxi√®me fois.  Tente pour la troisi√®me fois de prendre les fourchettes.  Bonne chance  Et passe son tourniquet pour d√Æner. </p><br><p>  Lorsqu'il y a des erreurs al√©atoires dans un tel code (elles existent toujours), par exemple, un voisin est incorrectement sp√©cifi√© ou le m√™me objet <code>AutoResetEvent</code> est <code>AutoResetEvent</code> pour tout le monde ( <code>Enumerable.Repeat</code> ), alors les philosophes attendront les d√©veloppeurs, car  trouver des erreurs dans un tel code est une t√¢che assez difficile.  Un autre probl√®me avec cette solution est qu'elle ne garantit pas qu'aucun philosophe ne mourra de faim. </p><br><h3 id="gibridnye-resheniya">  Solutions hybrides </h3><br><p>  Nous avons examin√© deux approches de synchronisation lorsque nous restons en mode utilisateur et tournons en boucle et lorsque nous bloquons un thread via le noyau.  La premi√®re m√©thode convient aux verrous courts, la seconde aux verrous longs.  Souvent, vous devez d'abord attendre bri√®vement qu'une variable change dans la boucle, puis bloquer le thread lorsque l'attente est longue.  Cette approche est mise en ≈ìuvre dans le  conceptions hybrides.  Il y a les m√™mes constructions que pour le mode noyau, mais maintenant avec une boucle en mode utilisateur: <code>SemaphorSlim</code> , <code>ManualResetEventSlim</code> , etc. La construction la plus populaire ici est <code>Monitor</code> , car  C # a une syntaxe de <code>lock</code> bien connue.  <code>Monitor</code> est le m√™me s√©maphore avec une valeur maximale de 1 (mutex), mais avec un support pour l'attente dans une boucle, la r√©cursivit√©, le mod√®le de variable de condition (√† ce sujet ci-dessous), etc. Voyons une solution avec. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   . private readonly object _lock = new object(); //   . private DateTime?[] _waitTimes = new DateTime?[philosophersAmount]; public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } //     Condition Variable . bool CanIEat(int i) { //   : if (forks[Left(i)] != 0 &amp;&amp; forks[Right(i)] != 0) return false; var now = DateTime.Now; // ,     ,  . foreach(var p in new int[] {LeftPhilosopher(i), RightPhilosopher(i)}) if (_waitTimes[p] != null &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i]) return false; return true; } void TakeForks(int i) { //   .   : lock(_lock) {..}. //   try,     . bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { _waitTimes[i] = DateTime.Now; // Condition Variable .  ,    //  .    -  Pulse / PulseAll. while (!CanIEat(i)) Monitor.Wait(_lock); forks[Left(i)] = i + 1; forks[Right(i)] = i + 1; _waitTimes[i] = null; } finally { if (lockTaken) Monitor.Exit(_lock); } } void PutForks(int i) { //   : lock (_lock) {..}. bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { forks[Left(i)] = 0; forks[Right(i)] = 0; //        Monitor.Exit. Monitor.PulseAll(_lock); } finally { if (lockTaken) Monitor.Exit(_lock); } }</span></span></code> </pre> <br><p>  Ici, nous verrouillons √† nouveau toute la table pour acc√©der aux fourches, mais maintenant nous d√©bloquons tous les ruisseaux en m√™me temps, et non les voisins lorsque quelqu'un a fini de manger.  C'est-√†-dire  premi√®rement, quelqu'un mange et bloque les voisins, et quand celui-ci a fini, mais veut √† nouveau manger tout de suite, il va dans la serrure et r√©veille ses voisins, parce que  son temps d'attente est plus court. </p><br><p>  Nous √©vitons donc les blocages et la famine d'un philosophe.  Nous utilisons une boucle pour une courte attente et bloquons le flux pour une longue.  Le d√©verrouillage <code>AutoResetEvent</code> fonctionne plus lentement que si seul le voisin √©tait d√©verrouill√©, comme dans la solution avec <code>AutoResetEvent</code> , mais la diff√©rence ne devrait pas √™tre grande, car  les threads doivent d'abord rester en mode utilisateur. </p><br><p>  Le <code>lock</code> syntaxe <code>lock</code> mauvaises surprises.  Ils recommandent d'utiliser <code>Monitor</code> directement [Richter] [Eric Lippert].  L'un d'eux est que le <code>lock</code> quitte toujours <code>Monitor</code> , m√™me s'il y avait une exception, puis un autre thread peut changer l'√©tat de la m√©moire partag√©e.  Dans de tels cas, il est souvent pr√©f√©rable d'aller dans l'impasse ou de terminer le programme en toute s√©curit√©.  Une autre surprise est que Monitor utilise des blocs de synchronisation ( <code>SyncBlock</code> ), qui se trouvent dans tous les objets.  Par cons√©quent, si vous s√©lectionnez le mauvais objet, vous pouvez facilement obtenir un blocage (par exemple, si vous verrouillez la cha√Æne intern√©e).  Nous utilisons toujours un objet cach√© pour cela. </p><br><p>  Condition Le mod√®le variable vous permet de mettre en ≈ìuvre de mani√®re plus concise les attentes d'une condition complexe.  En .NET, elle est incompl√®te, √† mon avis, car  en th√©orie, il devrait y avoir plusieurs files d'attente sur plusieurs variables (comme dans Posix Threads), et non sur un verrou.  Ensuite, on pourrait les faire pour tous les philosophes.  Mais m√™me sous cette forme, cela vous permet de r√©duire le code. </p><br><h3 id="mnogo-filosofov-ili-async--await">  Beaucoup de philosophes ou <code>async</code> / <code>await</code> </h3><br><p>  Ok, maintenant nous pouvons bloquer efficacement les threads.  Mais que se passe-t-il si nous recevons beaucoup de philosophes?  100?  10000?  Par exemple, nous avons re√ßu 100 000 demandes √† un serveur Web.  La cr√©ation d'un flux pour chaque demande sera une surcharge, car  tant de threads ne seront pas ex√©cut√©s en parall√®le.  Seulement autant de c≈ìurs logiques seront ex√©cut√©s (j'en ai 4).  Et tout le monde prendra simplement des ressources.  Une solution √† ce probl√®me est le mod√®le asynchrone / attente.  Son id√©e est qu'une fonction ne contient pas de flux, si vous devez attendre qu'elle continue.  Et quand elle fait √ßa, quelque chose arrive, elle reprend son ex√©cution (mais pas forc√©ment dans le m√™me fil!).  Dans notre cas, nous attendrons la prise. </p><br><p>  <code>SemaphoreSlim</code> a une m√©thode <code>WaitAsync()</code> pour cela.  Voici une impl√©mentation utilisant ce mod√®le. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  . -  : Task.Run(() =&gt; Run(i, cancelTokenSource.Token)); //  . //   async --      . public async Task Run(int i, CancellationToken token) { while (true) { // await --   - . await TakeForks(i); //  await,     . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); //      . await PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } async Task TakeForks(int i) { bool hasForks = false; while (!hasForks) { //    : await _tableSemaphore.WaitAsync(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) { forks[Left(i)] = i+1; forks[Right(i)] = i+1; hasForks = true; } _tableSemaphore.Release(); //  ,    : if (!hasForks) await _philosopherSemaphores[i].WaitAsync(); } } //       . async Task PutForks(int i) { await _tableSemaphore.WaitAsync(); forks[Left(i)] = 0; // "" ,   "". _philosopherSemaphores[LeftPhilosopher(i)].Release(); forks[Right(i)] = 0; _philosopherSemaphores[RightPhilosopher(i)].Release(); _tableSemaphore.Release(); }</span></span></code> </pre> <br><p>   <code>async</code> / <code>await</code>     ,      <code>Task</code> .      ,     ,     Task.  ,  ,  .   ,    ,   ,   ,   .         .      <code>async</code> / <code>await</code> . </p><br><p> .  100     4  , 8 .    Monitor   4  ,     .    4    2.    async / await   100,       6.8 . ,      6         .    Monitor    . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      , .NET    .  , , ,   .     .    ,     ,   , TPL Dataflow, Reactive , Software Transaction   . </p><br><h2 id="istochniki">  Les sources </h2><br><ul><li>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concurrency Visualizer</a> </li><li> MSDN: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Threading</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Asynchronous programming patterns</a>  . . </li><li> [] ‚Äî CLR via C#, Jeffrey Richter </li><li> [ ] ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> lock</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> </li><li>  ‚Äî "  ", .  </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447898/">https://habr.com/ru/post/fr447898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447886/index.html">Analyse des journaux Nginx √† l'aide d'Amazon Athena et Cube.js</a></li>
<li><a href="../fr447890/index.html">Dieu merci, je ne suis pas manager</a></li>
<li><a href="../fr447892/index.html">Deux nouveaux concours PHDays: contournement IDS et piratage d'usine</a></li>
<li><a href="../fr447894/index.html">MODX Digest # 3 (25 mars - 8 avril 2019)</a></li>
<li><a href="../fr447896/index.html">Images d'esquisses: exactement comment fonctionne le r√©seau neuronal NVIDIA GAUGAN</a></li>
<li><a href="../fr447900/index.html">Fermer les contacts ADL</a></li>
<li><a href="../fr447902/index.html">GitHub a compl√®tement ¬´supprim√©¬ª le r√©f√©rentiel de l'utilitaire de r√©f√©rentiel de verrouillage et l'int√©gralit√© du compte cr√©ateur</a></li>
<li><a href="../fr447904/index.html">Les experts de Positive Technologies identifient les tentatives d'exploitation massive d'une vuln√©rabilit√© critique dans Confluence</a></li>
<li><a href="../fr447906/index.html">Innovations r√©elles: qu'attendre du march√© des datacenters en 2019?</a></li>
<li><a href="../fr447908/index.html">Deux fa√ßons de collecter des r√©compenses pour la publicit√© dans les jeux mobiles, ou les robots devraient fonctionner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>