<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏻 🧛🏼 🚔 Verbessern Sie Ihre JavaScript-Kenntnisse, indem Sie den Quellcode analysieren 🧑🏾‍🤝‍🧑🏻 🧑 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie Ihre Programmierkarriere beginnen, kann es ein wenig beängstigend sein, im Quellcode offener Bibliotheken und Frameworks zu stöbern. In diese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbessern Sie Ihre JavaScript-Kenntnisse, indem Sie den Quellcode analysieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460181/"> <i>Wenn Sie Ihre Programmierkarriere beginnen, kann es ein wenig beängstigend sein, im Quellcode offener Bibliotheken und Frameworks zu stöbern.</i>  <i>In diesem Artikel teilt Karl Mungazi seine Erfahrungen mit, wie er seine Angst überwunden hat, und begann, den Quellcode zu verwenden, um Wissen zu erwerben und Fähigkeiten zu entwickeln.</i>  <i>Er verwendet Redux auch, um zu zeigen, wie er die Bibliothek „analysiert“.</i> <br><a name="habracut"></a><br>  Erinnerst du dich, als du zum ersten Mal in den Code einer Bibliothek oder eines Frameworks eingetaucht bist, die du oft verwendest?  In meinem Leben kam dieser Moment bei meinem ersten Job als Front-End-Entwickler vor drei Jahren. <br><br>  Wir haben gerade ein veraltetes proprietäres Framework neu geschrieben, mit dem interaktive Schulungskurse erstellt wurden.  Zu Beginn der Umschreibungsarbeit haben wir uns einige schlüsselfertige Lösungen angesehen, darunter Mithril, Inferno, Angular, React, Aurelia, Vue und Polymer.  Da ich noch ein junger Padawan war (der gerade vom Journalismus zur Webentwicklung gewechselt war), hatte ich schreckliche Angst vor der Komplexität der einzelnen Frameworks und dem Unverständnis darüber, wie sie funktionieren. <br><br>  Das Verständnis begann zu kommen, als ich begann, das Mithril-Gerüst sorgfältig zu erforschen.  Seitdem wurden meine Kenntnisse in JavaScript - und in der Programmierung im Allgemeinen - dank der Stunden, die ich in den Interna der Bibliothek verbracht habe, die ich täglich bei der Arbeit und in meinen eigenen Projekten verwendet habe, erheblich vertieft.  In diesem Artikel werde ich Ihnen erklären, wie Sie Ihre Lieblingsbibliothek als Tutorial verwenden können <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbe/3d3/fad/bbe3d3fadd117038a615108327f4c867.png" alt="Bild"><br>  <i>Ich begann den Quellcode mit der Hyperscript-Funktion von Mithril zu lesen</i> <br><br><h3>  Vorteile des Parsens von Quellcode </h3><br>  Einer der Hauptvorteile beim Parsen von Quellcode besteht darin, dass Sie viel lernen können.  Als ich anfing, den Mithril-Code zu analysieren, hatte ich eine sehr schlechte Vorstellung davon, was das virtuelle DOM war.  Als ich fertig war, wusste ich bereits, dass das virtuelle DOM eine Technik ist, bei der ein Baum von Objekten erstellt wird, die die Benutzeroberfläche beschreiben.  Dieser Baum kann dann mithilfe einer DOM-API wie document.createElement in DOM-Elemente konvertiert werden.  Zum Aktualisieren wird ein neuer Baum erstellt, der den zukünftigen Status der Schnittstelle beschreibt und dann mit der vorherigen Version dieses Baums verglichen wird. <br><br>  Ich habe darüber in vielen Artikeln und Handbüchern gelesen, aber am lehrreichsten war es, dies alles zu beobachten, während ich an unserer Anwendung arbeitete.  Ich habe auch gelernt, beim Vergleich von Frameworks die richtigen Fragen zu stellen.  Anstatt beispielsweise Bewertungen zu vergleichen, können Sie die Frage stellen: "Wie wirkt sich die Funktionsweise dieses Frameworks auf Änderungen auf die Leistung und den Komfort des Endbenutzers aus?" <br><br>  Ein weiteres Plus ist die Entwicklung eines Verständnisses für eine gute Anwendungsarchitektur.  Trotz der Tatsache, dass die meisten Open-Source-Projekte im Allgemeinen mehr oder weniger ähnlich aufgebaut sind wie ihre Repositories, weisen sie immer noch Unterschiede auf.  Die Struktur von Mithril ist sehr flach. Wenn Sie mit der API vertraut sind, können Sie durchaus realistische Annahmen über den Code in den Ordnern Rendering, Router und Request treffen.  Die Struktur von React spiegelt andererseits die neue Architektur wider.  Die Entwickler trennten das Modul, das für die Aktualisierung der Benutzeroberfläche (React-Reconciler) verantwortlich ist, von dem Modul, das für das Rendern der DOM-Elemente (React-Dom) verantwortlich ist. <br><br>  Einer der Vorteile dieser Trennung für Entwickler besteht darin, dass sie ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigenen Renderer</a> mithilfe von Hooks im React-Reconciler schreiben können.  Parcel, der Modul-Builder, den ich kürzlich studiert habe, hat ebenso wie React einen Paketordner.  Das Schlüsselmodul heißt Paketbündler und enthält Code, der für die Erstellung von Assemblys, den Betrieb des Modulaktualisierungsservers (Hot Module Server) und des Befehlszeilentools verantwortlich ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdd/7ef/ac1/fdd7efac1030c6d2678f44dd39a223cc.png" alt="Bild"><br>  <i>Wenn Sie den Quellcode bald analysieren, lesen Sie die JavaScript-Spezifikationen.</i> <br><br>  Ein weiteres Plus, das mich sehr überrascht hat, ist, dass Sie die offizielle JavaScript-Spezifikation leichter lesen können.  Das erste Mal habe ich mich an sie gewandt, als ich versucht habe herauszufinden, was der Unterschied zwischen Wurffehler und Wurffehler ist (Spoiler - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nichts</a> ).  Ich habe diese Frage gestellt, weil Mithril bei der Implementierung der m-Funktion einen Wurffehler verwendet hat und ich mich gefragt habe, warum es besser ist, als einen neuen Fehler zu werfen.  Dann habe ich auch erfahren, dass die Operatoren &amp;&amp; und ||  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln gefunden,</a> nach denen der Operator des nicht strengen Vergleichs == die Werte "auflöst" und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grund,</a> warum Object.prototype.toString.call ({}) '[object Object]' zurückgibt. <br><br><h3>  So analysieren Sie den Quellcode </h3><br>  Es gibt viele Möglichkeiten, den Quellcode zu analysieren.  Der einfachste Weg scheint mir der folgende zu sein: Wählen Sie eine Methode aus Ihrer Bibliothek aus und beschreiben Sie, was passiert, wenn Sie sie aufrufen.  Es lohnt sich nicht, jeden Schritt zu beschreiben, Sie müssen nur versuchen, seine allgemeinen Prinzipien und Strukturen zu verstehen. <br><br>  Kürzlich habe ich ReactDOM.render auf diese Weise analysiert und viel über React Fibre und einige der Schwierigkeiten bei der Implementierung gelernt.  Glücklicherweise ist React sehr beliebt und das Vorhandensein einer großen Anzahl von Artikeln zum gleichen Thema von anderen Entwicklern hat den Prozess beschleunigt. <br><br>  Dieser Einblick in den Code führte mich auch in das Konzept der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kooperativen Planung</a> , die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">window.requestIdleCallback-</a> Methode und ein Live- <a href="">Beispiel einer verknüpften Liste ein</a> (Reagiert verarbeitet Aktualisierungen, indem sie an die Warteschlange <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesendet</a> werden, bei der es sich um eine vorrangig verknüpfte Liste von Aktualisierungen handelt).  Dabei wäre es schön, mit der Bibliothek eine einfache Anwendung zu erstellen.  Dies erleichtert das Debuggen, da Sie sich nicht mit dem Stack-Trace anderer Bibliotheken befassen müssen. <br><br>  Wenn ich keine detaillierte Überprüfung durchführe, öffne ich den Ordner node_modules in dem Projekt, an dem ich arbeite, oder schaue mir GitHub an.  Ich mache das immer, wenn ich auf einen Fehler oder eine interessante Funktion stoße.  Stellen Sie beim Lesen des Codes auf GitHub sicher, dass dies die neueste Version ist.  Der Code der neuesten Version wird angezeigt, indem Sie auf die Schaltfläche zum Ändern der Zweige klicken und "Tags" auswählen.  Änderungen an Bibliotheken und Frameworks werden derzeit durchgeführt, sodass Sie wahrscheinlich nicht etwas analysieren möchten, das möglicherweise nicht in der nächsten Version enthalten ist. <br><br>  Eine oberflächlichere Version des Lernens von Quellcode ist das, was ich als "Schnellblick" bezeichne.  Irgendwie habe ich express.js installiert, den Ordner node_modules geöffnet und die Abhängigkeiten durchgesehen.  Wenn README mir keine zufriedenstellende Erklärung gegeben hat, habe ich die Quelle gelesen.  Dies führte mich zu interessanten Entdeckungen: <br><br><ul><li>  Express verwendet zwei Module zum Zusammenführen von Objekten, und die Funktionsweise dieser Module ist sehr unterschiedlich.  Merge-Deskriptoren fügen nur die im Quellobjekt gefundenen Eigenschaften hinzu und fügen auch nicht aufzählbare Eigenschaften hinzu, während utils-merge die aufgezählten Eigenschaften des Objekts und seiner gesamten Prototypkette behandelt.  Merge-Descriptors verwendet Object.getOwnPropertyNames () und Object.getOwnPropertyDescriptor (), und Utils-Merge verwendet for..in; </li><li>  Das Modul setprototypeof bietet eine plattformübergreifende Option zum Angeben des Prototyps des erstellten (instanziierten) Objekts. </li><li>  Escape-HTML ist ein Escape-Modul mit 78 Zeilen, nach dem der Inhalt in HTML eingefügt werden kann. </li></ul><br>  Obwohl diese Entdeckungen höchstwahrscheinlich nicht sofort nützlich sind, ist ein allgemeines Verständnis der Abhängigkeiten Ihrer Bibliothek oder Ihres Frameworks sehr hilfreich. <br><br>  Debugging-Browser-Tools sind Ihre besten Freunde beim Debuggen von Code im Frontend.  Unter anderem können Sie das Programm jederzeit stoppen und gleichzeitig seinen Status überprüfen, die Funktion überspringen oder sie betreten oder verlassen.  In minimiertem Code ist dies nicht möglich - deshalb entpacke ich diesen Code und lege ihn in die entsprechende Datei im Ordner node_modules. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/0b7/2b1/ad00b72b170fb59cbc2d87ba99892a1f.png" alt="Bild"><br>  <i>Verwenden Sie den Debugger als nützliche Anwendung.</i>  <i>Machen Sie eine Annahme und testen Sie sie dann.</i> <br><br><h3>  Fallstudie: Verbindungsfunktion in Redux </h3><br>  React-Redux ist eine Bibliothek zum Verwalten des Status von React-Anwendungen.  Wenn ich mit solchen populären Bibliotheken arbeite, suche ich zunächst nach Artikeln über deren Verwendung.  Bei der Vorbereitung dieses Beispiels habe ich diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> überprüft.  Dies ist ein weiterer Pluspunkt beim Erlernen des Quellcodes. Er führt Sie zu informativen Artikeln wie diesem, die Ihr Denken und Verstehen verbessern. <br><br>  Connect ist eine React-Redux-Funktion, die die React-Komponente und den Redux-Speicher einer Anwendung verbindet.  Wie?  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation macht</a> sie Folgendes: <br><blockquote>  "... gibt eine neue verwandte Komponentenklasse zurück, die ein Wrapper der an sie übergebenen Komponente ist." </blockquote>  Nachdem ich dies gelesen habe, stelle ich folgende Fragen: <br><br><ul><li>  Kenne ich Muster oder Konzepte, bei denen Funktionen Eingabeparameter mit zusätzlichen Funktionen zurückgeben? </li><li>  Wenn ja, wie verwende ich dies basierend auf der Beschreibung aus der Dokumentation? </li></ul><br>  Normalerweise besteht der nächste Schritt darin, eine primitive Anwendung mit der Verbindungsfunktion zu erstellen.  Trotzdem habe ich in dieser Situation eine neue Anwendung für React verwendet, an der wir gearbeitet haben, weil ich Connect im Kontext einer Anwendung verstehen wollte, die höchstwahrscheinlich bald in Produktion gehen würde. <br><br>  Die Komponente, auf die ich mich konzentriert habe, sieht ungefähr so ​​aus: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MarketContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// code omitted for brevity } const mapDispatchToProps = dispatch =&gt; { return { updateSummary: (summary, start, today) =&gt; dispatch(updateSummary(summary, start, today)) } } export default connect(null, mapDispatchToProps)(MarketContainer);</span></span></code> </pre> <br>  Dies ist eine Containerkomponente, die als Wrapper für die vier kleineren verwandten Komponenten dient.  Eines der ersten Dinge in der <a href="">Datei</a> , die Connect exportiert, ist der Kommentar „Connect ist die Fassade für connectAdvanced“.  Bereits in dieser Phase können wir etwas lernen: Wir haben die Möglichkeit, das Fassadenmuster in Aktion zu beobachten.  Am Ende der Datei sehen wir, wie connect einen Aufruf an die Funktion createConnect exportiert.  Seine Parameter sind eine Reihe von Standardwerten, die wie folgt destrukturiert sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory } = {}</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Und wir haben noch einen lehrreichen Moment: Export der aufgerufenen Funktion und standardmäßige Destrukturierung der Funktionsargumente.  Die Umstrukturierung ist für uns aufschlussreich, da der Code folgendermaßen geschrieben werden könnte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory }</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Als Ergebnis würden wir einen Fehler erhalten - Uncaught TypeError: Die Eigenschaft 'connectHOC' von 'undefined' oder 'null' kann nicht zerstört werden.  Dies würde passieren, weil die Funktion keine Standardargumentwerte hat. <br><br>  <i>Hinweis: Um die Umstrukturierung von Argumenten besser zu verstehen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Artikel von David Walsh</a> lesen.</i>  <i>Abhängig von Ihren Sprachkenntnissen mögen einige Punkte trivial erscheinen. Dann können Sie sich auf die Punkte konzentrieren, mit denen Sie nicht vertraut sind.</i> <br><br>  Die Funktion createConnect selbst führt nichts aus.  Es gibt nur die Verbindungsfunktion zurück, die ich hier verwendet habe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, mapDispatchToProps)(MarketContainer)</code> </pre><br>  Es werden vier optionale Argumente benötigt, und die ersten drei durchlaufen die <a href="">Übereinstimmungsfunktion</a> , mit deren Hilfe sie ihr Verhalten anhand der übergebenen Argumente sowie ihres Typs bestimmen können.  Es stellt sich heraus, dass ich wählen muss, wohin ich als nächstes gehen soll, da das zweite Argument, das an match übergeben wird, eine der drei in connect importierten Funktionen ist. <br><br>  Es gibt auch etwas zu lernen von der <a href="">Proxy-Funktion,</a> die zum Umschließen des ersten Arguments in connect verwendet wird, wenn diese Argumente Funktionen sind.  über das Dienstprogramm <a href="">isPlainObject</a> , mit dem einfache Objekte überprüft werden, oder über das <a href="">Warnmodul</a> , das zeigt, wie Sie einen Debugger <a href="">erstellen</a> können, der bei allen Fehlern funktioniert.  Nach der Match-Funktion fahren wir mit connectHOC fort, der Funktion, die unsere Reaktionskomponente aufnimmt und sie mit Redux verknüpft.  Es gibt einen weiteren Funktionsaufruf, der <a href="">wrapWithConnect zurückgibt</a> - eine Funktion, die die Bindung der Komponente an das Repository übernimmt. <br><br>  Wenn ich mir die connectHOC-Implementierung anschaue, kann ich mir vorstellen, warum die Details der connect-Implementierung ausgeblendet werden sollten.  Dies ist im Wesentlichen das Herzstück von React-Redux und enthält Logik, auf die über Connect nicht zugegriffen werden sollte.  Selbst wenn wir uns damit befassen, haben wir später, wenn wir tiefer graben müssen, bereits das Quellmaterial mit einer detaillierten Erläuterung des Codes. <br><br><h3>  Fassen Sie zusammen </h3><br>  Das Erlernen des Quellcodes ist zunächst sehr kompliziert.  Aber wie alles andere wird es mit der Zeit einfacher.  Seine Aufgabe ist es nicht, alles zu verstehen, sondern etwas Nützliches für sich herauszubringen - ein gemeinsames Verständnis und neues Wissen.  Es ist sehr wichtig, während des gesamten Prozesses vorsichtig zu sein und sich mit den Details zu befassen. <br><br>  Zum Beispiel fand ich die Funktion isPlainObject interessant, weil sie diese verwendet, wenn (typeof obj! == 'object' || obj === null) false zurückgibt, um sicherzustellen, dass das übergebene Argument ein einfaches Objekt ist.  Als ich diesen Code zum ersten Mal las, dachte ich mir, warum nicht einfach Object.prototype.toString.call (opts)! == '[object Object]' verwenden, um den Code zu reduzieren und Objekte von ihren Untertypen wie Date zu trennen.  Aber bereits in der nächsten Zeile ist klar, dass selbst wenn plötzlich (plötzlich!) Ein Entwickler, der connect verwendet, ein Date-Objekt zurückgibt, z. B. durch Überprüfen von Object.getPrototypeOf (obj) === null. <br><br>  Ein weiterer unerwarteter Punkt in isPlainObject an dieser Stelle: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(baseProto) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { baseProto = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(baseProto) }</code> </pre><br>  Das Finden einer Antwort bei Google führte mich zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Thread</a> in StackOverflow und zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Kommentar</a> zu GitHubs Redux, in dem erläutert wird, wie dieser Code Situationen behandelt, in denen beispielsweise ein Objekt von einem iFrame übertragen wird. <br><br>  - - <br><br>  <i>Zuerst beschlossen, den Artikel zu übersetzen.</i>  <i>Ich wäre dankbar für Klarstellungen, Ratschläge und Empfehlungen</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460181/">https://habr.com/ru/post/de460181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460169/index.html">Das R-Handbuch war kürzlich die am häufigsten zitierte nicht-akademische Veröffentlichung in wissenschaftlichen Arbeiten.</a></li>
<li><a href="../de460173/index.html">Entwicklung für Docker. Lokale Umgebung. Teil 2 - Nginx + PHP + MySql + phpMyAdmin</a></li>
<li><a href="../de460175/index.html">Semiotik im Marketing: Was bedeutet das für Ihre Marke?</a></li>
<li><a href="../de460177/index.html">Drahtloser Wasserlecksensor auf nRF52832, DIY-Projekt</a></li>
<li><a href="../de460179/index.html">LEAN + AGILE = AGILEAN oder wir sammeln das Ganze in Teilen</a></li>
<li><a href="../de460185/index.html">Onlinedienst "Geschwindigkeitsanalyse bei Unfällen per Video"</a></li>
<li><a href="../de460187/index.html">Stellen Sie sich Ihre Daten vor, bevor Sie sie erfassen.</a></li>
<li><a href="../de460189/index.html">14 besten Kanban Board Tools im Jahr 2019</a></li>
<li><a href="../de460191/index.html">Stoppen Sie die Leitung oder pumpen Sie Ihre Pipeline, yo</a></li>
<li><a href="../de460193/index.html">Überwachen des Ablaufs von Zertifikaten unter Windows unter NetXMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>