<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚫 ⚖️ 🈸 React教程第19部分：组件生命周期方法 👩🏼‍⚕️ 👨‍👩‍👧‍👧 🤶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在React教程的今天翻译的这一部分，您将获得组件生命周期方法的概述。 

  

 → 第1部分：课程概述，React，ReactDOM和JSX普及的原因 
 → 第2部分：功能组件 
 → 第3部分：组件文件，项目结构 
 → 第4部分：父级和子级组件 
 → 第5部分：TODO应用程序的开始工...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React教程第19部分：组件生命周期方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/"> 在React教程的今天翻译的这一部分，您将获得组件生命周期方法的概述。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="图片"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：课程概述，React，ReactDOM和JSX普及的原因</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：功能组件</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：组件文件，项目结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：父级和子级组件</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：TODO应用程序的开始工作，样式设计的基础</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：关于本课程的一些功能，JSX和JavaScript</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：内联样式</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：继续研究TODO应用程序，熟悉组件的属性</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：组件属性</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10部分：有关使用组件特性和样式的讲习班</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11部分：动态标记生成和映射数组方法</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第12部分：研讨会，TODO应用程序的第三阶段工作</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第13部分：基于类的组件</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第14部分：关于基于类的组件，组件状态的研讨会</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第15部分：组件健康研讨会</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第16部分：TODO应用程序的第四阶段工作，事件处理</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第17部分：TODO应用程序的第五阶段工作，修改组件的状态</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第18部分：TODO应用程序的第六阶段工作</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第19部分：组件生命周期方法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20部分：条件渲染的第一课</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21部分：关于条件渲染的第二课​​和研讨会</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22部分：TODO应用程序的第七阶段工作，从外部资源下载数据</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第23部分：关于使用表格的第一课</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24部分：第二形式课</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第25部分：使用表单的研讨会</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第26部分：应用程序体系结构，容器/组件模式</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第27部分：课程项目</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">课34.组件生命周期方法，第1部分</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原创</a> <br><br> 开发React应用程序的功能之一是事实，我们编写了相当简单的JavaScript代码来驱动React的内部机制，从而为我们提供了开发应用程序接口和处理数据的巨大机会。 同时，我们在生命周期中使用的组件会经历某些阶段。 通常，将应用程序中某个组件发生的事情与一个人的生活进行比较。 人们出生，生活，生活中都会发生一些重大事件，然后死亡。  React中的组件与人相似，因为它们也是“出生”，“活着”和“死亡”的。 使用组件，由于它们的生命周期方法在其“生命”的特殊时刻被调用，我们可以对它们发生的事情做出反应。 <br><br> 最近，React开发团队已经淘汰了三种组件生命周期方法。 但是，我们将考虑这些方法，因为它们仍然可以使用，并且可以在现有代码中找到它们。 另外，React中增加了两个新的组件生命周期方法，我们将在下一课中进行讨论。 <br><br> 我们将只考虑与刚开始学习React的人最相关的最重要方法。 当您继续掌握该库时，将可以尝试其他方法。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>一些关于React组件生命周期方法的好材料，这些方法在React 16.3之前是相关的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> ，可以从React开发人员官方博客的出版物中找到有关React 16.3中发生的更改的信息。 <br><br> 现在，让我们开始讨论您最常遇到的React组件的生命周期方法。 <br><br> 我们将一如既往在这里使用演示项目。 在这种情况下，我们从<code>App.js</code>文件中的使用create-react-app创建的标准项目开始，该文件包含以下代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br> 首先，让我们看一下已经用于基于类的组件的方法。 这是<code>render()</code>方法。 <br><br> 通常，在谈到组件生命周期方法时不会提到他。 我认为，将这种方法与一个人进行比较时，可以与外出之前的穿戴进行比较。 此方法的目的是确定屏幕上将显示的内容，即组件的外观。 在组件的生命周期中，可以多次调用<code>render()</code>方法。 因此，当React确定与组件相关的某些事物已经改变时，例如状态或属性，即可能影响组件外观的事物，React可以调用此方法。 如果我们继续与人进行类比，则可以进行比较，以便一个人可以决定换衣服。 例如，为了在工作日后准备某种假日活动。 <br><br> 现在，让我们看看另一个组件生命周期方法<code>componentDidMount()</code> 。 与其他任何基于类的组件方法一样，在组件类的主体中声明此方法： <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br> 该方法在组件的生命周期中被调用，可以与该组件的“出生”进行比较。 在将组件安装（插入）到DOM树中之后，将触发此方法。 同时，例如，如果在更改了一些会影响组件外观的数据后，将再次呈现该数据，则不会调用<code>componentDidMount()</code>方法。 发生这种情况的原因是，在执行此类操作时，并未从DOM树中删除该组件，然后将该组件再次包含在该树中。 <br><br> 如果开发人员需要来自外部源的数据，则<code>componentDidMount()</code>方法通常用于对某些API进行调用。 假设我们在这里考虑的组件实际上称为<code>TodoList</code>并且是在Todo应用程序中形成待办事项列表的组件。 这种<code>componentDidMount()</code>方法可以从服务器数据库加载正确显示存储在服务器上的待办事项列表所需的资料。 结果，在完成组件的安装之后，我们可以在<code>componentDidMount()</code>方法中加载组件正确显示在页面上所需的数据。 我们还将讨论如何加载组件所需的数据，但是现在您可以记住，这是<code>componentDidMount()</code>最常见的用例。 <br><br> 我们讨论的下一个组件生命周期方法称为<code>componentWillReceiveProps()</code> 。 可以将此方法与某人收到某人的礼物时发生的情况进行比较。 因此，组件可以从父组件接收属性。 每次组件获取属性时，都会调用此方法。 同时，每次父组件将属性传递给子组件时（不仅是第一次发生这种情况时），都会调用此方法。 例如，如果父组件决定更改传递给子组件的属性，则例如，在<code>componentWillReceiveProps()</code>方法中，我们可以检查新属性是否与已经传递给组件的属性不同。 事实是，如果新属性与旧属性没有不同，这意味着它们的收据不会发生任何变化，这意味着在找出之后，我们将无能为力。 如果新属性与旧属性不同，我们可以执行某些操作。 通常，此方法在组件类的主体中声明如下： <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br> 在这里，通常将它用作参数名称<code>nextProps</code> ，但是您可以根据需要命名该参数。 为了比较已经转移到组件的某些特定属性与之前已经传递给它的属性，并决定进一步的操作，可以使用以下构造： <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br> 通常以这种方式使用此方法。 <br><br> 但是，正如已经提到的，在React 16.3发行之后，组件生命周期中的某些方法已被弃用， <code>componentWillReceiveProps()</code>是其中一种方法。 <br><br> 在React 17之前，这些传统方法仍然可以使用，尽管最好不要使用。 如果您无法使用所讨论的方法，则需要将其称为<code>UNSAFE_componentWillReceiveProps()</code> 。 在React 17之后， <code>componentWillReceiveProps()</code>方法的名称将没有任何特殊含义。 <br><br> 知道此方法很有用，以便能够理解过时的代码，但不会在现代React应用程序的开发中使用。 <br><br> 另一个有趣的组件生命周期方法称为<code>shouldComponentUpdate()</code> 。 如果我们继续与某人进行比较，他会回忆起某人正在考虑是否需要换衣服的那一刻。 在正常情况下，如果React无法完全确定是否重新渲染组件，它将以防万一。 不管是否必要，根据应用程序逻辑是否如此。 <br><br> 即使没有与组件相关的更改，这也会导致React重新渲染组件。 这可能会使应用程序变慢，因为按照这种原理，React会处理组成应用程序的所有组件。  <code>shouldComponentUpdate()</code>方法允许开发人员优化应用程序。 在这里，您可以实现一些逻辑，以帮助您确定需要更新组件。 此方法通常这样声明： <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br> 而且，从该方法开始，如果组件需要重新渲染，并且考虑到新的属性和状态，则需要返回<code>true</code> 。 否则，必须从中返回<code>false</code> 。 实际上，从此方法返回<code>false</code>会导致以下事实：未更新组件，并且应用程序运行得更快，但是通过这样做，您需要确保该组件确实不需要重新渲染。 如果需要更新组件，并且此方法返回<code>false</code> ，则将导致错误，这些错误将很难处理。 <br><br> 我们将讨论的另一个组件生命周期方法称为<code>componentWillUnmount()</code> 。 此方法标记了组件的“寿命”的结束-从DOM树中将其删除并从屏幕上消失的那一刻。 <br><br> 此方法主要用于释放组件占用的资源，并在删除组件之前对其进行排序。 例如，如果<code>componentDidMount()</code>方法配置了类似事件侦听器的功能，则当用户滚动页面时，将执行某些代码，因此可以在<code>componentWillUnmount()</code>删除此类事件侦听器。 实际上，此方法具有许多应用程序，旨在从应用程序中删除在组件消失后原来不需要的所有内容。 <br><br> 这是我们<code>App</code>组件的完整代码，其中添加了生命周期方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br> 这节课到此结束，尽管应该注意，React组件的生命周期方法不仅限于我们今天回顾的方法。 <br><br><h2>  <font color="#3AC1EF">课程35.组件生命周期方法，第2部分</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原创</a> <br><br> 正如上一课中已经提到的那样，当React 16.3发布时，据报道这三种组件生命周期方法已经过时了。 这些方法是<code>componentWillMount()</code> ， <code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code> 。 还报告了两种新方法。 这是静态的<code>getDerivedStateFromProps()</code>方法和<code>getSnapshotBeforeUpdate()</code>方法。 不能说这些方法将在本课程的未来课程中发挥重要作用，但是尽管如此，我们仍将在这里了解它们。 <br><br> 我们将在上次使用的同一项目中进行实验。 <br><br> 以下是<code>getDerivedStateFromProps()</code>方法的声明： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br> 注意方法名称前的<code>static</code> 。 根据他接受的属性，他必须返回更新的状态。 当某些组件必须接受其从父组件接收的传入属性并根据这些属性配置其状态时，将使用此方法。 有关此方法的详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 在React博客上发布的这份材料说，在似乎有用的所有情况下，使用这种方法远非合理。 不当使用它会导致各种错误，并降低应用程序性能，因此请谨慎使用。 您不应该尝试使用它的帮助来解决问题，而这并不是它想要的解决方案。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>此方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>文档。 <br><br> 现在让我们谈谈<code>getSnapshotBeforeUpdate()</code>方法。 这是他在班级正文中的声明： <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br> 可以将其视为生命周期方法，它允许您在更新组件之前创建类似组件中内容的备份。 它类似于应用程序状态的快照。 应该注意的是，React的开发者说这种方法的范围是有限的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>文档。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了组件生命周期方法。 当您进一步开发React应用程序时，它们肯定会派上用场。 在本课程的其他课程中，我们将介绍这些方法，尤其是<code>componentDidMount()</code> 。 下次我们将讨论条件渲染。 <br><br>  <b>亲爱的读者们！</b> 如果您是专业开发React应用程序，请告诉我们您如何使用组件生命周期方法。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441578/">https://habr.com/ru/post/zh-CN441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441568/index.html">Python内存管理</a></li>
<li><a href="../zh-CN441570/index.html">353上周的前端世界摘要（2019年2月17日至24日）</a></li>
<li><a href="../zh-CN441572/index.html">前端每周摘要（2019年2月18日至24日）</a></li>
<li><a href="../zh-CN441574/index.html">学习Docker第6部分：处理数据</a></li>
<li><a href="../zh-CN441576/index.html">Kubernetes网络：Pod</a></li>
<li><a href="../zh-CN441580/index.html">React教程第20部分：第一个条件渲染课程</a></li>
<li><a href="../zh-CN441582/index.html">LQR控制系统优化</a></li>
<li><a href="../zh-CN441584/index.html">PHP文摘第150号（2019年2月11日至25日）</a></li>
<li><a href="../zh-CN441586/index.html">如何推荐几乎没人听的音乐。 Yandex报告</a></li>
<li><a href="../zh-CN441590/index.html">集群交互的演变。 我们如何实现ActiveMQ和Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>