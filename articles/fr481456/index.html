<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛓️ 😭 ⏭️ Swift: conteneurs pour stocker les valeurs clés 👨🏿‍🚀 🕍 🧕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imaginez que vous devez enregistrer l'ID utilisateur dans UserDefaults . Quelle sera la première étape? 


 Habituellement, une entreprise commence pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift: conteneurs pour stocker les valeurs clés</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481456/"><p><img src="https://habrastorage.org/webt/8h/go/fu/8hgofu1j5ia4yksf2g3mtytxcji.png"></p><br><p>  Imaginez que vous devez enregistrer l'ID utilisateur dans <a href="https://developer.apple.com/documentation/foundation/userdefaults" rel="nofollow">UserDefaults</a> .  Quelle sera la première étape? </p><br><p>  Habituellement, une entreprise commence par ajouter une constante pour une clé et vérifier son caractère unique.  Cela est vrai pour la plupart des autres magasins de valeurs-clés.  Et les conséquences de la conception primitive de tels référentiels ne se limitent pas aux clés; une interface sous la forme d'un ensemble de méthodes non systématique entraîne un certain nombre de problèmes possibles: </p><br><ul><li> <strong>Erreurs d'écriture des clés</strong> : différentes clés peuvent être utilisées pour lire et écrire la même entité. </li><li>  <strong>Type de valeur non fixé</strong> : par exemple, avec la même clé, vous pouvez écrire un nombre et lire une chaîne. </li><li>  <strong>Collision de clés</strong> : différentes entités avec la même clé peuvent être enregistrées dans différentes parties du projet. </li></ul><br><p> Dans un monde idéal, le compilateur devrait se protéger contre ces problèmes, ne vous permettant pas de créer un projet en cas de conflit de clé ou si le type de valeur ne correspond pas.  Pour implémenter un tel stockage sécurisé, vous pouvez utiliser des conteneurs pour les valeurs, et cette procédure pas à pas vous aidera à les préparer en utilisant <code>UserDefaults</code> comme exemple. </p><a name="habracut"></a><br><h2 id="protokol-hranilischa">  Protocole de stockage </h2><br><p>  Donc, la première chose dont nous avons besoin est un protocole pour le référentiel lui-même, ce qui aidera à faire abstraction de son type.  Par conséquent, nous aurons une interface unique pour travailler à la fois avec <code>UserDefaults</code> , avec un trousseau de clés et avec un autre stockage de valeur-clé.  Ce protocole semble assez simple: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function">&lt;T: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forKey key: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-function">&lt;T: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: T?, forKey key: String)</span></span></span></span> }</code> </pre> <br><p>  Ainsi, tout stockage conforme au protocole <code>KeyValueStorage</code> doit implémenter deux <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="nofollow">méthodes génériques</a> : getter et setter de valeurs de clé sous la forme d'une chaîne.  Dans le même temps, les valeurs elles-mêmes correspondent au protocole <code>Codable</code> , qui permet de stocker des instances de types qui ont une représentation universelle (par exemple, <a href="https://ru.wikipedia.org/wiki/JSON" rel="nofollow">JSON</a> ou <a href="https://en.wikipedia.org/wiki/Property_list" rel="nofollow">PropertyList</a> ). </p><br><p>  Les implémentations standard de l'entrepôt de données ne prennent pas en charge le type <code>Codable</code> pour les valeurs, par exemple, les mêmes <code>UserDefaults</code> .  Par conséquent, cette distinction de type est un bonus supplémentaire qui vous permet de stocker à la fois des primitives Swift (nombres, chaînes, etc.) et des structures de données entières, tout en conservant une interface de stockage simple. </p><br><h3 id="realizaciya-protokola">  Mise en œuvre du protocole </h3><br><p>  Il existe deux façons d'implémenter le protocole <code>KeyValueStorage</code> : </p><br><ul><li>  Signez le stockage existant sous le protocole et ajoutez les méthodes nécessaires: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDefaults</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function">&lt;T: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forKey key: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } func setValue&lt;T: Codable&gt;(_ value: T?, forKey key: String) { //   } }</span></span></code> </pre> <br><ul><li>  Enveloppez le stockage dans un type distinct, en cachant ses champs pour une utilisation externe: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersistentStorage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDefaults: <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suiteName: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyPrefix: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(suiteName: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, keyPrefix: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDefaults = <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>(suiteName: suiteName) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.userDefaults = userDefaults <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.suiteName = suiteName <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.keyPrefix = keyPrefix } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function">&lt;T: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forKey key: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } func setValue&lt;T: Codable&gt;(_ value: T?, forKey key: String) { //   } }</span></span></code> </pre> <br><p>  La deuxième méthode semble plus compliquée, mais évolue mieux, par exemple, vous pouvez définir le préfixe de clé pour chaque instance de stockage.  De plus, l'encapsuleur masque les champs supplémentaires et ne laisse que les champs de protocole disponibles, résolvant ainsi les problèmes potentiels de conflits de signature. </p><br><p>  Pour implémenter les méthodes <code>value(forKey:)</code> et <code>setValue(:forKey:)</code> il est important de prévoir la compatibilité des données.  Cela est nécessaire pour que les valeurs stockées par les outils standard <code>UserDefaults</code> puissent être récupérées par des méthodes de <code>KeyValueStorage</code> , et vice versa. </p><br><p>  Un exemple complet de la classe <code>PersistentStorage</code> prête à l'emploi est disponible <a href="https://github.com/almazrafi/KeyValueContainer/blob/master/Sources/PersistentStorage.swift" rel="nofollow">ici</a> . </p><br><h2 id="konteyner-znacheniya">  Conteneur de valeur </h2><br><p>  Maintenant que nous avons extrait du type de stockage, nous allons ajouter un conteneur pour la valeur par clé.  Il sera utile pour encapsuler tous les champs nécessaires dans une entité pratique, qui peut être transférée et utilisée séparément du stockage lui-même.  Un tel conteneur est implémenté comme une petite <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="nofollow">classe générique</a> : </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> storage: <span class="hljs-type"><span class="hljs-type">KeyValueStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { storage.value(forKey: key) } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { storage.setValue(newValue, forKey: key) } } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(storage: <span class="hljs-type"><span class="hljs-type">KeyValueStorage</span></span>, key: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage = storage <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.key = key } }</code> </pre> <br><p>  Le type de valeur pour le conteneur est limité par le protocole <code>Codable</code> de la même manière que dans les méthodes du magasin lui-même, de sorte que la propriété <code>value</code> calculée calcule simplement les appels avec une clé fixe et un type de valeur. </p><br><p>  Si vous le souhaitez, vous pouvez étendre les fonctionnalités du conteneur, par exemple, ajouter une valeur par défaut qui sera utilisée s'il n'y a pas de données pour la clé dans le magasin. </p><br><div class="spoiler">  <b class="spoiler_title">Exemple d'implémentation d'un conteneur avec une valeur par défaut</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> storage: <span class="hljs-type"><span class="hljs-type">KeyValueStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultValue: <span class="hljs-type"><span class="hljs-type">T?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { storage.value(forKey: key) ?? defaultValue } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { storage.setValue(newValue, forKey: key) } } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(storage: <span class="hljs-type"><span class="hljs-type">KeyValueStorage</span></span>, key: <span class="hljs-type"><span class="hljs-type">String</span></span>, defaultValue: <span class="hljs-type"><span class="hljs-type">T?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage = storage <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.key = key <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.defaultValue = defaultValue } }</code> </pre> </div></div><br><p>  Le conteneur résout nos deux premiers problèmes - il corrige la clé et le type des données lues et écrites.  Ainsi, toute tentative d'écriture d'une valeur d'un type incorrect sera arrêtée par le compilateur au stade de la construction: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with container: KeyValueContainer&lt;Int&gt;)</span></span></span></span> { container.value = <span class="hljs-string"><span class="hljs-string">"Text"</span></span> <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Il reste à résoudre le dernier problème - garantir l'unicité des clés de stockage.  Cette préoccupation peut également être "bloquée" sur le compilateur en utilisant une astuce plutôt intéressante. </p><br><h2 id="unikalnost-klyuchey">  Unicité clé </h2><br><p>  Pour résoudre le problème de conflit, nous utilisons le nom de la propriété calculée dans laquelle le conteneur lui-même sera créé comme clé.  Pour ce faire, ajoutez une extension simple à notre protocole <code>KeyValueStorage</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeContainer</span></span></span><span class="hljs-function">&lt;T: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String = #function)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">KeyValueContainer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-type"><span class="hljs-type">KeyValueContainer</span></span>(storage: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, key: key) } }</code> </pre> <br><p>  Ainsi, dans toutes les implémentations du protocole de stockage, une méthode générique sera ajoutée qui renvoie un conteneur avec la clé spécifiée.  Un intérêt particulier dans cette méthode est le paramètre <code>key</code> , qui par défaut a une valeur égale à l'expression spéciale <code>#function</code> ( <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html" rel="nofollow">documentation</a> ).  Cela signifie qu'au stade de la construction, le littéral <code>#function</code> remplacé par le nom de la déclaration à partir de laquelle la <code>makeContainer(key:)</code> été appelée. </p><br><p>  Cette construction vous permet de déclarer des conteneurs dans des extensions de stockage, et leurs noms seront les noms des propriétés calculées si la méthode <code>makeContainer()</code> est appelée sans le paramètre <code>key</code> en eux: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersistentStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foobar: <span class="hljs-type"><span class="hljs-type">KeyValueContainer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; { makeContainer() } }</code> </pre> <br><p>  Dans l'exemple, les instances de stockage <code>PersistentStorage</code> recevront la propriété <code>foobar</code> du conteneur avec la clé <code>foobar</code> du même nom, dont le type de valeur sera un entier.  Tenter d'ajouter un deuxième conteneur <code>foobar</code> pour le stockage entraînera une erreur de compilation, ce qui nous garantit l'unicité des clés. </p><br><p><img src="https://habrastorage.org/webt/xz/3g/tt/xz3gttetpukkd5fgf-mbbmyualm.png"></p><br><h2 id="podvodya-itog">  Pour résumer </h2><br><p>  Les conteneurs de valeurs résolvent tous les problèmes d'interface de stockage mentionnés et ne sont pas limités aux <code>UserDefaults</code> .  Il suffit de signer (envelopper) tout stockage de valeur de clé sous le protocole <code>KeyValueStorage</code> avec l'implémentation correspondante, et il peut déjà être utilisé pour créer des conteneurs sécurisés. </p><br><p>  Séparément, il convient de noter la commodité d'ajouter et d'utiliser de tels conteneurs, tout est limité à des conceptions simples et compréhensibles: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersistentStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var foobar: KeyValueContainer&lt;Int&gt; { makeContainer() } } //   let foobar = storageInstance.foobar.value //   storageInstance.foobar.value = 123</span></span></code> </pre> <br><p>  Il vous suffit de vous habituer au fait que le nom de la propriété calculée est la clé de la valeur, ce qui est particulièrement important lors de la refactorisation du code.  N'oubliez pas non plus la migration du référentiel, si vous ne pouviez toujours pas vous passer de renommer. </p><br><p>  C’est tout.  Je serai heureux de faire part de vos commentaires dans les commentaires.  Salut! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481456/">https://habr.com/ru/post/fr481456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481440/index.html">Deux points au bord du monde</a></li>
<li><a href="../fr481444/index.html">Règles strictes pour une nouvelle application Angular</a></li>
<li><a href="../fr481446/index.html">Introduction à l'architecture de sécurité 5G: NFV, clés et 2 authentifications</a></li>
<li><a href="../fr481450/index.html">Comment automatiser la livraison de nourriture sur Aiko</a></li>
<li><a href="../fr481452/index.html">Les investisseurs russes pourront acheter des actions sur les bourses de Londres et Hong Kong</a></li>
<li><a href="../fr481458/index.html">Programmeur fanatique. Résumé partie 2 + tableau abstrait. Poissons, géants et mentors</a></li>
<li><a href="../fr481460/index.html">Messagerie -> PubSub dans OTP</a></li>
<li><a href="../fr481462/index.html">L'histoire des logiciels éducatifs: le développement des ordinateurs personnels et des enseignants virtuels</a></li>
<li><a href="../fr481466/index.html">Comment construire des projets dans Jenkins, si vous avez besoin de beaucoup d'environnements différents</a></li>
<li><a href="../fr481470/index.html">Guirlande intelligente pour toute l'année</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>