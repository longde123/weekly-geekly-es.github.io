<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 🧔🏿 👙 Analyse de la charge CPU générée par les composants JavaScript individuels 🍡 🕋 🌭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parlons un peu de la façon d'observer la quantité de ressources CPU consommées par le code JavaScript de l'application. Dans le même temps, je propose...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse de la charge CPU générée par les composants JavaScript individuels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Parlons un peu de la façon d'observer la quantité de ressources CPU consommées par le code JavaScript de l'application.  Dans le même temps, je propose de construire notre conversation autour des composants - les blocs de construction de base de l'application.  Avec cette approche, tous les efforts pour améliorer la productivité (ou les efforts pour trouver les causes des ralentissements des programmes) peuvent se concentrer sur (espérons-le) de petits fragments autosuffisants du projet.  Dans le même temps, je suppose que votre application frontale, comme de nombreux autres projets modernes, a été créée en assemblant de petits fragments de l'interface adaptés à une utilisation répétée.  Si ce n'est pas le cas, alors notre raisonnement peut être appliqué à une autre application, mais vous devrez trouver votre propre façon de diviser votre code à grande échelle en fragments et vous devrez réfléchir à la façon d'analyser ces fragments. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pourquoi est-ce nécessaire?</font> </h2><br>  Pourquoi mesurer la consommation CPU par JavaScript?  Le fait est que de nos jours, les performances des applications sont le plus souvent liées aux capacités du processeur.  Permettez-moi de citer librement les paroles de Steve Soders et Pat Minan d'une interview que j'ai prise pour <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> .  Tous deux ont déclaré que les performances des applications ne se limitaient plus aux capacités réseau ou aux latences réseau.  Les réseaux deviennent de plus en plus rapides.  Les développeurs ont en outre appris à compresser les réponses textuelles du serveur à l'aide de GZIP (ou plutôt à l'aide de brotli) et ont compris comment optimiser les images.  C'est très simple. <br><br>  Le goulot d'étranglement des performances des applications modernes est les processeurs.  Cela est particulièrement vrai dans l'environnement mobile.  Et dans le même temps, nos attentes concernant les capacités interactives des applications Web modernes ont augmenté.  Nous nous attendons à ce que les interfaces de ces applications fonctionnent très rapidement et en douceur.  Et tout cela nécessite de plus en plus de code JavaScript.  De plus, nous devons nous rappeler que 1 Mo d'images n'est pas la même chose que 1 Mo de JavaScript.  Les images sont téléchargées progressivement et l'application résout actuellement d'autres problèmes.  Mais le code JavaScript est souvent une telle ressource, sans laquelle l'application s'avère inopérante.  Pour garantir le fonctionnement d'une application moderne, de grandes quantités de code JS sont nécessaires, qui, avant de vraiment fonctionner, doivent être analysées et exécutées.  Et ce sont des tâches qui dépendent fortement des capacités du processeur. <br><br><h2>  <font color="#3AC1EF">Indicateur de performance</font> </h2><br>  Nous utiliserons un tel indicateur de la vitesse des fragments de code comme le nombre d'instructions du processeur nécessaires pour les traiter.  Cela nous permettra de séparer les mesures des propriétés d'un ordinateur particulier et de l'état dans lequel il se trouve au moment de la mesure.  Les mesures basées sur le temps (comme TTI) ont trop de «bruit».  Ils dépendent de l'état de la connexion réseau, ainsi que de tout ce qui se passe sur l'ordinateur au moment de la mesure.  Par exemple, certains scripts exécutés lors du chargement de la page examinée, ou des virus qui sont occupés par quelque chose dans les processus d'arrière-plan, peuvent affecter les indicateurs de performance temporels.  La même chose peut être dite à propos des extensions de navigateur, qui peuvent consommer beaucoup de ressources système et ralentir la page.  En revanche, lors du calcul du nombre d'instructions du processeur, le temps n'a pas d'importance.  Ces indicateurs peuvent être, comme vous le verrez bientôt, vraiment stables. <br><br><h2>  <font color="#3AC1EF">Idée</font> </h2><br>  Voici l'idée qui sous-tend notre travail: nous devons créer un «laboratoire» dans lequel le code sera lancé et examiné lorsque des modifications y seront apportées.  Par «laboratoire», je veux dire un ordinateur ordinaire, peut-être celui que vous utilisez constamment.  Les systèmes de contrôle de version nous donnent à notre disposition des crochets avec lesquels vous pouvez intercepter certains événements et effectuer certaines vérifications.  Bien entendu, les mesures en «laboratoire» peuvent être effectuées après validation.  Mais vous savez probablement que les modifications apportées au code qui a atteint l'étape de validation seront apportées plus lentement qu'au code en cours d'écriture (le cas échéant).  La même chose s'applique à la correction du code bêta du produit et à la correction du code entré en production. <br><br>  Nous avons besoin à chaque fois que le code est modifié, que ses performances soient comparées avant et après les modifications.  Ce faisant, nous nous efforçons d'étudier les composants de manière isolée.  Nous pourrons ainsi voir clairement les problèmes et savoir exactement où ils se posent. <br><br>  La bonne chose est que de telles études peuvent être effectuées dans un vrai navigateur, en utilisant, par exemple, Puppeteer.  Il s'agit d'un outil qui vous permet de contrôler le navigateur sans interface utilisateur à partir de Node.js. <br><br><h2>  <font color="#3AC1EF">Code de recherche pour la recherche</font> </h2><br>  Afin de trouver le code de l'étude, nous pouvons nous référer à n'importe quel guide de style, ou à n'importe quel système de conception.  En général, nous sommes satisfaits de tout ce qui fournit des exemples brefs et isolés d'utilisation de composants. <br><br>  Qu'est-ce qu'un «guide de style»?  Il s'agit généralement d'une application Web qui montre tous les composants ou «blocs de construction» des éléments de l'interface utilisateur disponibles pour le développeur.  Il peut s'agir d'une certaine bibliothèque de composants tiers ou de quelque chose créé par vos propres efforts. <br><br>  En recherchant de tels projets sur Internet, je suis tombé sur un récent <a href="https://twitter.com/toggleModal/status/1189913353902276608">fil de</a> discussion sur Twitter qui parlait de bibliothèques relativement nouvelles de composants React.  J'ai regardé plusieurs des bibliothèques mentionnées ici. <br><br>  Sans surprise, les bibliothèques modernes de haute qualité sont fournies avec une documentation qui inclut des exemples de code de travail.  Voici quelques bibliothèques et composants <code>Button</code> implémentés par leurs moyens.  La documentation de ces bibliothèques contient des exemples d'utilisation de ces composants.  Nous parlons de la bibliothèque Chakra et de la bibliothèque Semantic UI React. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Documentation des composants des boutons du chakra</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Bouton Documentation sémantique de l'interface utilisateur React</font></i> <br><br>  C'est exactement ce dont nous avons besoin.  Ce sont des exemples dont nous pouvons examiner le code pour leur consommation de ressources processeur.  Des exemples similaires peuvent être trouvés dans les entrailles de la documentation, ou dans les commentaires de code écrits dans le style JSDoc.  Si vous avez de la chance, vous trouverez peut-être de tels exemples, conçus sous forme de fichiers séparés, par exemple sous la forme de fichiers de tests unitaires.  Il en sera sûrement ainsi.  Après tout, nous écrivons tous des tests unitaires.  Non? <br><br><h2>  <font color="#3AC1EF">Fichiers</font> </h2><br>  Imaginez, afin de démontrer la méthode d'analyse des performances décrite, qu'il existe un composant <code>Button</code> dans la bibliothèque que nous étudions, dont le code se trouve dans le fichier <code>Button.js</code> . Le fichier avec le test unitaire <code>Button-test.js</code> est attaché à ce fichier, ainsi qu'un fichier avec un exemple d'utilisation du composant - <code>Button-example.js</code> .  Nous devons créer une sorte de page de test, dans l'environnement dont le code de test peut être exécuté.  Quelque chose comme <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Composant</font> </h2><br>  Voici un simple composant <code>Button</code> .  J'utilise React ici, mais vos composants peuvent être écrits en utilisant n'importe quelle technologie qui vous convient. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Exemple</font> </h2><br>  Et voici un exemple d'utilisation du composant <code>Button</code> .  Comme vous pouvez le voir, dans ce cas, il existe deux options de composants qui utilisent des propriétés différentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Test</font> </h2><br>  Voici la page <code>test.html</code> qui peut charger tous les composants.  Notez les appels de méthode à l'objet de <code>performance</code> .  C'est avec leur aide que nous, à notre demande, écrivons dans le fichier journal des performances de Chrome.  Très bientôt, nous utiliserons ces enregistrements. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Runner de test</font> </h2><br>  Afin de charger une page de test dans Chrome, nous pouvons utiliser la bibliothèque <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js, qui nous donne accès à l'API pour gérer le navigateur.  Vous pouvez utiliser cette bibliothèque sur n'importe quel système d'exploitation.  Il a sa propre copie de Chrome, mais il peut également être utilisé pour fonctionner avec une instance de Chrome ou de Chrome de différentes versions déjà existantes sur l'ordinateur du développeur.  Chrome peut être lancé pour que sa fenêtre soit invisible.  Les tests sont effectués automatiquement, tandis que le développeur n'a pas besoin de voir la fenêtre du navigateur.  Chrome peut être lancé en mode normal.  Ceci est utile à des fins de débogage. <br><br>  Voici un exemple de script Node.js exécuté à partir de la ligne de commande qui charge une page de test et écrit des données dans un fichier journal de performances.  Tout ce qui se passe dans le navigateur entre les commandes <code>tracing.start()</code> et <code>end()</code> est écrit (je veux le noter en détail) dans le fichier <code>trace.json</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  Le développeur peut gérer le «détail» des données de performance en spécifiant les «catégories» de traçage.  Vous pouvez voir la liste des catégories disponibles si vous allez dans Chrome sur <code>chrome://tracing</code> , cliquez sur <code>Record</code> et ouvrez la section <code>Edit categories</code> dans la fenêtre qui apparaît. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Configuration de la composition des données écrites dans le journal des performances</font></i> <br><br><h2>  <font color="#3AC1EF">Résultats</font> </h2><br>  Après avoir examiné la page de test à l'aide de Puppeteer, vous pouvez analyser les résultats des mesures de performances en accédant au navigateur à l' <code>trace.json</code> <code>chrome://tracing</code> et en téléchargeant le fichier <code>trace.json</code> vient d'être enregistré. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Visualisation Trace.json</font></i> <br><br>  Ici, vous pouvez voir les résultats de l'appel de la méthode <code>performance.measure('my mark')</code> .  L'appel de <code>measure()</code> est uniquement à des fins de débogage, au cas où le développeur souhaite ouvrir le fichier <code>trace.json</code> et le voir.  Tout ce qui s'est passé avec la page est enfermé dans le bloc <code>my mark</code> . <br><br>  Voici un <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragment du fichier trace.json</font></i> <br><br>  Pour savoir ce dont nous avons besoin, il suffit de soustraire l'indicateur du nombre d'instructions du processeur ( <code>ticount</code> ) du marqueur de <code>Start</code> du même indicateur du marqueur de <code>End</code> .  Cela vous permet de savoir combien d'instructions de processeur sont nécessaires pour afficher le composant dans le navigateur.  Il s'agit du même nombre que vous pouvez utiliser pour savoir si un composant est devenu plus rapide ou plus lent. <br><br><h2>  <font color="#3AC1EF">Le diable est dans les détails</font> </h2><br>  Nous avons maintenant mesuré uniquement les indicateurs caractérisant la première sortie sur la page d'un seul composant.  Et rien de plus.  Il est impératif de mesurer les indicateurs liés à la plus petite quantité de code pouvant être exécutée.  Cela vous permet de réduire le niveau de "bruit".  Le diable est dans les détails.  Plus les performances sont mesurées, mieux c'est.  Après les mesures, il est nécessaire d'éliminer des résultats obtenus ce qui est au-delà de l'influence du développeur.  Par exemple, les données liées aux opérations de récupération de place.  Le composant ne contrôle pas ces opérations.  S'ils sont exécutés, cela signifie que le navigateur, en train de rendre le composant, a décidé de les lancer lui-même.  Par conséquent, les ressources du processeur qui sont allées à la récupération de place doivent être supprimées des résultats finaux. <br><br>  Le bloc de données lié à la récupération de place (ce «bloc de données» est plus correctement appelé un «événement») est appelé <code>V8.GCScavenger</code> .  Sa <code>tidelta</code> doit être soustraite du nombre d'instructions du processeur qui entrent dans le rendu du composant.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Voici la</a> documentation des événements de trace.  Certes, il est obsolète et ne contient pas d'informations sur les indicateurs dont nous avons besoin: <br><br><ul><li>  <code>tidelta</code> - le nombre d'instructions de processeur requises pour traiter un événement. </li><li>  <code>ticount</code> - le nombre d'instructions pour démarrer l'événement. </li></ul><br>  Vous devez faire très attention à ce que nous mesurons.  Les navigateurs sont des entités hautement intelligentes.  Ils optimisent le code qui s'exécute plus d'une fois.  Dans le graphique suivant, vous pouvez voir le nombre d'instructions de processeur nécessaires pour sortir un certain composant.  La première opération de rendu nécessite le plus de ressources.  Les opérations suivantes créent une charge beaucoup plus faible sur le processeur.  Il convient de garder cela à l'esprit lors de l'analyse des performances du code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 opérations de rendu du même composant</font></i> <br><br>  Voici un autre détail: si le composant effectue des opérations asynchrones (par exemple, il utilise <code>setTimeout()</code> ou <code>fetch()</code> ), alors la charge sur le système créée par le code asynchrone n'est pas prise en compte.  C'est peut-être bien.  C'est peut-être mauvais.  Si vous étudiez les performances de ces composants, envisagez une étude distincte du code asynchrone. <br><br><h2>  <font color="#3AC1EF">Signal fort</font> </h2><br>  Si vous adoptez une approche responsable pour résoudre le problème de ce qui est exactement mesuré, vous pouvez obtenir un signal vraiment stable qui reflète l'impact sur les performances de tout changement.  J'adore la finesse des lignes dans le graphique suivant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">Résultats de mesure stables</font></i> <br><br>  Le graphique du bas montre les résultats de mesure de 10 opérations de rendu d'un élément <code>&lt;span&gt;</code> simple dans React.  Rien d'autre n'est inclus dans ces résultats.  Il s'avère que cette opération nécessite de 2,15 à 2,2 millions d'instructions de processeur.  Si vous encapsulez <code>&lt;span&gt;</code> dans la <code>&lt;p&gt;</code> , pour générer une telle conception, vous avez besoin d'environ 2,3 millions d'instructions.  Ce niveau de précision me frappe.  Si un développeur peut voir la différence de performances qui apparaît lorsqu'un seul élément <code>&lt;p&gt;</code> est ajouté à une page, cela signifie que le développeur a un outil vraiment puissant entre ses mains. <br><br>  La manière exacte de représenter les mesures d'une telle précision dépend du développeur.  S'il n'a pas besoin d'une telle précision, il peut toujours mesurer les performances de rendu de fragments plus gros. <br><br><h2>  <font color="#3AC1EF">Informations supplémentaires sur les performances</font> </h2><br>  Maintenant que le développeur a à sa disposition un système de recherche d'indicateurs numériques qui caractérisent très précisément les performances des plus petits fragments de code, le développeur peut utiliser ce système pour résoudre divers problèmes.  Ainsi, en utilisant <code>performance.mark()</code> vous pouvez écrire des informations utiles supplémentaires sur <code>trace.json</code> .  Vous pouvez dire aux membres de l'équipe de développement ce qui se passe et ce qui provoque une augmentation du nombre d'instructions de processeur nécessaires pour exécuter du code.  Vous pouvez inclure dans les rapports de performances des informations sur le nombre de nœuds DOM ou sur le nombre d'opérations d'écriture dans le DOM effectuées par React.  En fait, ici, vous pouvez afficher des informations sur un lot.  Vous pouvez compter le nombre de recalculs de mise en page.  En utilisant Puppeteer, vous pouvez prendre des captures d'écran des pages et comparer l'apparence de l'interface avant et après avoir apporté des modifications.  Parfois, l'augmentation du nombre d'instructions du processeur nécessaires pour afficher une page ne semble pas du tout surprenante.  Par exemple, si 10 boutons et 12 champs pour l'édition et la mise en forme du texte sont ajoutés à la nouvelle version de la page. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Est-il possible pour tout le monde qui a été discuté ici de l'utiliser aujourd'hui?  Oui tu peux.  Pour ce faire, vous avez besoin de Chrome version 78 ou supérieure.  Si <code>trace.json</code> a des <code>tidelta</code> <code>ticount</code> et <code>tidelta</code> , alors ce qui précède est à votre disposition.  Les versions antérieures de Chrome ne le font pas. <br><br>  Malheureusement, les informations sur le nombre d'instructions du processeur ne peuvent pas être obtenues sur la plate-forme Mac.  Je n'ai pas encore essayé Windows, donc je ne peux rien dire de précis sur cet OS.  En général - nos amis sont Unix et Linux. <br><br>  Il convient de noter que pour que le navigateur puisse fournir des informations sur les instructions du processeur, vous devrez utiliser quelques indicateurs - ce sont <code>--no-sandbox</code> et <code>--enable-thread-instruction-count</code> .  Voici comment les transmettre à un navigateur lancé par Puppeteer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Avec un peu de chance, vous pouvez maintenant faire passer l'analyse des performances de votre application Web au niveau supérieur. <br><br>  <b>Chers lecteurs!</b>  Envisagez-vous d'utiliser la méthodologie d'analyse des performances des projets Web présentée ici? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479266/">https://habr.com/ru/post/fr479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479252/index.html">Compréhension de la liste et carte</a></li>
<li><a href="../fr479256/index.html">Dans le sillage de l'Astrotracker en deux soirées - Mon expérience</a></li>
<li><a href="../fr479258/index.html">IGF 2019. Internet est-il en train de s'effondrer?</a></li>
<li><a href="../fr479262/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 392 (2 - 8 décembre 2019)</a></li>
<li><a href="../fr479264/index.html">La couleur de la Lune et du Soleil depuis l'espace en termes de RVB et de température de couleur</a></li>
<li><a href="../fr479268/index.html">Écouteurs d'événements et travailleurs du Web</a></li>
<li><a href="../fr479270/index.html">Quelles nouveautés pouvez-vous attendre de Node.js en 2020?</a></li>
<li><a href="../fr479272/index.html">[signet] 9 outils qui augmentent la productivité des développeurs Web</a></li>
<li><a href="../fr479274/index.html">10 astuces Python à connaître</a></li>
<li><a href="../fr479276/index.html">Trois méthodes Pandas que vous ne connaissez peut-être pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>