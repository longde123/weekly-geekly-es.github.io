<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüç≥ üßîüèø üëô Analyse de la charge CPU g√©n√©r√©e par les composants JavaScript individuels üç° üïã üå≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parlons un peu de la fa√ßon d'observer la quantit√© de ressources CPU consomm√©es par le code JavaScript de l'application. Dans le m√™me temps, je propose...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse de la charge CPU g√©n√©r√©e par les composants JavaScript individuels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Parlons un peu de la fa√ßon d'observer la quantit√© de ressources CPU consomm√©es par le code JavaScript de l'application.  Dans le m√™me temps, je propose de construire notre conversation autour des composants - les blocs de construction de base de l'application.  Avec cette approche, tous les efforts pour am√©liorer la productivit√© (ou les efforts pour trouver les causes des ralentissements des programmes) peuvent se concentrer sur (esp√©rons-le) de petits fragments autosuffisants du projet.  Dans le m√™me temps, je suppose que votre application frontale, comme de nombreux autres projets modernes, a √©t√© cr√©√©e en assemblant de petits fragments de l'interface adapt√©s √† une utilisation r√©p√©t√©e.  Si ce n'est pas le cas, alors notre raisonnement peut √™tre appliqu√© √† une autre application, mais vous devrez trouver votre propre fa√ßon de diviser votre code √† grande √©chelle en fragments et vous devrez r√©fl√©chir √† la fa√ßon d'analyser ces fragments. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pourquoi est-ce n√©cessaire?</font> </h2><br>  Pourquoi mesurer la consommation CPU par JavaScript?  Le fait est que de nos jours, les performances des applications sont le plus souvent li√©es aux capacit√©s du processeur.  Permettez-moi de citer librement les paroles de Steve Soders et Pat Minan d'une interview que j'ai prise pour <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> .  Tous deux ont d√©clar√© que les performances des applications ne se limitaient plus aux capacit√©s r√©seau ou aux latences r√©seau.  Les r√©seaux deviennent de plus en plus rapides.  Les d√©veloppeurs ont en outre appris √† compresser les r√©ponses textuelles du serveur √† l'aide de GZIP (ou plut√¥t √† l'aide de brotli) et ont compris comment optimiser les images.  C'est tr√®s simple. <br><br>  Le goulot d'√©tranglement des performances des applications modernes est les processeurs.  Cela est particuli√®rement vrai dans l'environnement mobile.  Et dans le m√™me temps, nos attentes concernant les capacit√©s interactives des applications Web modernes ont augment√©.  Nous nous attendons √† ce que les interfaces de ces applications fonctionnent tr√®s rapidement et en douceur.  Et tout cela n√©cessite de plus en plus de code JavaScript.  De plus, nous devons nous rappeler que 1 Mo d'images n'est pas la m√™me chose que 1 Mo de JavaScript.  Les images sont t√©l√©charg√©es progressivement et l'application r√©sout actuellement d'autres probl√®mes.  Mais le code JavaScript est souvent une telle ressource, sans laquelle l'application s'av√®re inop√©rante.  Pour garantir le fonctionnement d'une application moderne, de grandes quantit√©s de code JS sont n√©cessaires, qui, avant de vraiment fonctionner, doivent √™tre analys√©es et ex√©cut√©es.  Et ce sont des t√¢ches qui d√©pendent fortement des capacit√©s du processeur. <br><br><h2>  <font color="#3AC1EF">Indicateur de performance</font> </h2><br>  Nous utiliserons un tel indicateur de la vitesse des fragments de code comme le nombre d'instructions du processeur n√©cessaires pour les traiter.  Cela nous permettra de s√©parer les mesures des propri√©t√©s d'un ordinateur particulier et de l'√©tat dans lequel il se trouve au moment de la mesure.  Les mesures bas√©es sur le temps (comme TTI) ont trop de ¬´bruit¬ª.  Ils d√©pendent de l'√©tat de la connexion r√©seau, ainsi que de tout ce qui se passe sur l'ordinateur au moment de la mesure.  Par exemple, certains scripts ex√©cut√©s lors du chargement de la page examin√©e, ou des virus qui sont occup√©s par quelque chose dans les processus d'arri√®re-plan, peuvent affecter les indicateurs de performance temporels.  La m√™me chose peut √™tre dite √† propos des extensions de navigateur, qui peuvent consommer beaucoup de ressources syst√®me et ralentir la page.  En revanche, lors du calcul du nombre d'instructions du processeur, le temps n'a pas d'importance.  Ces indicateurs peuvent √™tre, comme vous le verrez bient√¥t, vraiment stables. <br><br><h2>  <font color="#3AC1EF">Id√©e</font> </h2><br>  Voici l'id√©e qui sous-tend notre travail: nous devons cr√©er un ¬´laboratoire¬ª dans lequel le code sera lanc√© et examin√© lorsque des modifications y seront apport√©es.  Par ¬´laboratoire¬ª, je veux dire un ordinateur ordinaire, peut-√™tre celui que vous utilisez constamment.  Les syst√®mes de contr√¥le de version nous donnent √† notre disposition des crochets avec lesquels vous pouvez intercepter certains √©v√©nements et effectuer certaines v√©rifications.  Bien entendu, les mesures en ¬´laboratoire¬ª peuvent √™tre effectu√©es apr√®s validation.  Mais vous savez probablement que les modifications apport√©es au code qui a atteint l'√©tape de validation seront apport√©es plus lentement qu'au code en cours d'√©criture (le cas √©ch√©ant).  La m√™me chose s'applique √† la correction du code b√™ta du produit et √† la correction du code entr√© en production. <br><br>  Nous avons besoin √† chaque fois que le code est modifi√©, que ses performances soient compar√©es avant et apr√®s les modifications.  Ce faisant, nous nous effor√ßons d'√©tudier les composants de mani√®re isol√©e.  Nous pourrons ainsi voir clairement les probl√®mes et savoir exactement o√π ils se posent. <br><br>  La bonne chose est que de telles √©tudes peuvent √™tre effectu√©es dans un vrai navigateur, en utilisant, par exemple, Puppeteer.  Il s'agit d'un outil qui vous permet de contr√¥ler le navigateur sans interface utilisateur √† partir de Node.js. <br><br><h2>  <font color="#3AC1EF">Code de recherche pour la recherche</font> </h2><br>  Afin de trouver le code de l'√©tude, nous pouvons nous r√©f√©rer √† n'importe quel guide de style, ou √† n'importe quel syst√®me de conception.  En g√©n√©ral, nous sommes satisfaits de tout ce qui fournit des exemples brefs et isol√©s d'utilisation de composants. <br><br>  Qu'est-ce qu'un ¬´guide de style¬ª?  Il s'agit g√©n√©ralement d'une application Web qui montre tous les composants ou ¬´blocs de construction¬ª des √©l√©ments de l'interface utilisateur disponibles pour le d√©veloppeur.  Il peut s'agir d'une certaine biblioth√®que de composants tiers ou de quelque chose cr√©√© par vos propres efforts. <br><br>  En recherchant de tels projets sur Internet, je suis tomb√© sur un r√©cent <a href="https://twitter.com/toggleModal/status/1189913353902276608">fil de</a> discussion sur Twitter qui parlait de biblioth√®ques relativement nouvelles de composants React.  J'ai regard√© plusieurs des biblioth√®ques mentionn√©es ici. <br><br>  Sans surprise, les biblioth√®ques modernes de haute qualit√© sont fournies avec une documentation qui inclut des exemples de code de travail.  Voici quelques biblioth√®ques et composants <code>Button</code> impl√©ment√©s par leurs moyens.  La documentation de ces biblioth√®ques contient des exemples d'utilisation de ces composants.  Nous parlons de la biblioth√®que Chakra et de la biblioth√®que Semantic UI React. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Documentation des composants des boutons du chakra</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Bouton Documentation s√©mantique de l'interface utilisateur React</font></i> <br><br>  C'est exactement ce dont nous avons besoin.  Ce sont des exemples dont nous pouvons examiner le code pour leur consommation de ressources processeur.  Des exemples similaires peuvent √™tre trouv√©s dans les entrailles de la documentation, ou dans les commentaires de code √©crits dans le style JSDoc.  Si vous avez de la chance, vous trouverez peut-√™tre de tels exemples, con√ßus sous forme de fichiers s√©par√©s, par exemple sous la forme de fichiers de tests unitaires.  Il en sera s√ªrement ainsi.  Apr√®s tout, nous √©crivons tous des tests unitaires.  Non? <br><br><h2>  <font color="#3AC1EF">Fichiers</font> </h2><br>  Imaginez, afin de d√©montrer la m√©thode d'analyse des performances d√©crite, qu'il existe un composant <code>Button</code> dans la biblioth√®que que nous √©tudions, dont le code se trouve dans le fichier <code>Button.js</code> . Le fichier avec le test unitaire <code>Button-test.js</code> est attach√© √† ce fichier, ainsi qu'un fichier avec un exemple d'utilisation du composant - <code>Button-example.js</code> .  Nous devons cr√©er une sorte de page de test, dans l'environnement dont le code de test peut √™tre ex√©cut√©.  Quelque chose comme <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Composant</font> </h2><br>  Voici un simple composant <code>Button</code> .  J'utilise React ici, mais vos composants peuvent √™tre √©crits en utilisant n'importe quelle technologie qui vous convient. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Exemple</font> </h2><br>  Et voici un exemple d'utilisation du composant <code>Button</code> .  Comme vous pouvez le voir, dans ce cas, il existe deux options de composants qui utilisent des propri√©t√©s diff√©rentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Test</font> </h2><br>  Voici la page <code>test.html</code> qui peut charger tous les composants.  Notez les appels de m√©thode √† l'objet de <code>performance</code> .  C'est avec leur aide que nous, √† notre demande, √©crivons dans le fichier journal des performances de Chrome.  Tr√®s bient√¥t, nous utiliserons ces enregistrements. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Runner de test</font> </h2><br>  Afin de charger une page de test dans Chrome, nous pouvons utiliser la biblioth√®que <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js, qui nous donne acc√®s √† l'API pour g√©rer le navigateur.  Vous pouvez utiliser cette biblioth√®que sur n'importe quel syst√®me d'exploitation.  Il a sa propre copie de Chrome, mais il peut √©galement √™tre utilis√© pour fonctionner avec une instance de Chrome ou de Chrome de diff√©rentes versions d√©j√† existantes sur l'ordinateur du d√©veloppeur.  Chrome peut √™tre lanc√© pour que sa fen√™tre soit invisible.  Les tests sont effectu√©s automatiquement, tandis que le d√©veloppeur n'a pas besoin de voir la fen√™tre du navigateur.  Chrome peut √™tre lanc√© en mode normal.  Ceci est utile √† des fins de d√©bogage. <br><br>  Voici un exemple de script Node.js ex√©cut√© √† partir de la ligne de commande qui charge une page de test et √©crit des donn√©es dans un fichier journal de performances.  Tout ce qui se passe dans le navigateur entre les commandes <code>tracing.start()</code> et <code>end()</code> est √©crit (je veux le noter en d√©tail) dans le fichier <code>trace.json</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  Le d√©veloppeur peut g√©rer le ¬´d√©tail¬ª des donn√©es de performance en sp√©cifiant les ¬´cat√©gories¬ª de tra√ßage.  Vous pouvez voir la liste des cat√©gories disponibles si vous allez dans Chrome sur <code>chrome://tracing</code> , cliquez sur <code>Record</code> et ouvrez la section <code>Edit categories</code> dans la fen√™tre qui appara√Æt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Configuration de la composition des donn√©es √©crites dans le journal des performances</font></i> <br><br><h2>  <font color="#3AC1EF">R√©sultats</font> </h2><br>  Apr√®s avoir examin√© la page de test √† l'aide de Puppeteer, vous pouvez analyser les r√©sultats des mesures de performances en acc√©dant au navigateur √† l' <code>trace.json</code> <code>chrome://tracing</code> et en t√©l√©chargeant le fichier <code>trace.json</code> vient d'√™tre enregistr√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Visualisation Trace.json</font></i> <br><br>  Ici, vous pouvez voir les r√©sultats de l'appel de la m√©thode <code>performance.measure('my mark')</code> .  L'appel de <code>measure()</code> est uniquement √† des fins de d√©bogage, au cas o√π le d√©veloppeur souhaite ouvrir le fichier <code>trace.json</code> et le voir.  Tout ce qui s'est pass√© avec la page est enferm√© dans le bloc <code>my mark</code> . <br><br>  Voici un <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragment du fichier trace.json</font></i> <br><br>  Pour savoir ce dont nous avons besoin, il suffit de soustraire l'indicateur du nombre d'instructions du processeur ( <code>ticount</code> ) du marqueur de <code>Start</code> du m√™me indicateur du marqueur de <code>End</code> .  Cela vous permet de savoir combien d'instructions de processeur sont n√©cessaires pour afficher le composant dans le navigateur.  Il s'agit du m√™me nombre que vous pouvez utiliser pour savoir si un composant est devenu plus rapide ou plus lent. <br><br><h2>  <font color="#3AC1EF">Le diable est dans les d√©tails</font> </h2><br>  Nous avons maintenant mesur√© uniquement les indicateurs caract√©risant la premi√®re sortie sur la page d'un seul composant.  Et rien de plus.  Il est imp√©ratif de mesurer les indicateurs li√©s √† la plus petite quantit√© de code pouvant √™tre ex√©cut√©e.  Cela vous permet de r√©duire le niveau de "bruit".  Le diable est dans les d√©tails.  Plus les performances sont mesur√©es, mieux c'est.  Apr√®s les mesures, il est n√©cessaire d'√©liminer des r√©sultats obtenus ce qui est au-del√† de l'influence du d√©veloppeur.  Par exemple, les donn√©es li√©es aux op√©rations de r√©cup√©ration de place.  Le composant ne contr√¥le pas ces op√©rations.  S'ils sont ex√©cut√©s, cela signifie que le navigateur, en train de rendre le composant, a d√©cid√© de les lancer lui-m√™me.  Par cons√©quent, les ressources du processeur qui sont all√©es √† la r√©cup√©ration de place doivent √™tre supprim√©es des r√©sultats finaux. <br><br>  Le bloc de donn√©es li√© √† la r√©cup√©ration de place (ce ¬´bloc de donn√©es¬ª est plus correctement appel√© un ¬´√©v√©nement¬ª) est appel√© <code>V8.GCScavenger</code> .  Sa <code>tidelta</code> doit √™tre soustraite du nombre d'instructions du processeur qui entrent dans le rendu du composant.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Voici la</a> documentation des √©v√©nements de trace.  Certes, il est obsol√®te et ne contient pas d'informations sur les indicateurs dont nous avons besoin: <br><br><ul><li>  <code>tidelta</code> - le nombre d'instructions de processeur requises pour traiter un √©v√©nement. </li><li>  <code>ticount</code> - le nombre d'instructions pour d√©marrer l'√©v√©nement. </li></ul><br>  Vous devez faire tr√®s attention √† ce que nous mesurons.  Les navigateurs sont des entit√©s hautement intelligentes.  Ils optimisent le code qui s'ex√©cute plus d'une fois.  Dans le graphique suivant, vous pouvez voir le nombre d'instructions de processeur n√©cessaires pour sortir un certain composant.  La premi√®re op√©ration de rendu n√©cessite le plus de ressources.  Les op√©rations suivantes cr√©ent une charge beaucoup plus faible sur le processeur.  Il convient de garder cela √† l'esprit lors de l'analyse des performances du code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 op√©rations de rendu du m√™me composant</font></i> <br><br>  Voici un autre d√©tail: si le composant effectue des op√©rations asynchrones (par exemple, il utilise <code>setTimeout()</code> ou <code>fetch()</code> ), alors la charge sur le syst√®me cr√©√©e par le code asynchrone n'est pas prise en compte.  C'est peut-√™tre bien.  C'est peut-√™tre mauvais.  Si vous √©tudiez les performances de ces composants, envisagez une √©tude distincte du code asynchrone. <br><br><h2>  <font color="#3AC1EF">Signal fort</font> </h2><br>  Si vous adoptez une approche responsable pour r√©soudre le probl√®me de ce qui est exactement mesur√©, vous pouvez obtenir un signal vraiment stable qui refl√®te l'impact sur les performances de tout changement.  J'adore la finesse des lignes dans le graphique suivant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">R√©sultats de mesure stables</font></i> <br><br>  Le graphique du bas montre les r√©sultats de mesure de 10 op√©rations de rendu d'un √©l√©ment <code>&lt;span&gt;</code> simple dans React.  Rien d'autre n'est inclus dans ces r√©sultats.  Il s'av√®re que cette op√©ration n√©cessite de 2,15 √† 2,2 millions d'instructions de processeur.  Si vous encapsulez <code>&lt;span&gt;</code> dans la <code>&lt;p&gt;</code> , pour g√©n√©rer une telle conception, vous avez besoin d'environ 2,3 millions d'instructions.  Ce niveau de pr√©cision me frappe.  Si un d√©veloppeur peut voir la diff√©rence de performances qui appara√Æt lorsqu'un seul √©l√©ment <code>&lt;p&gt;</code> est ajout√© √† une page, cela signifie que le d√©veloppeur a un outil vraiment puissant entre ses mains. <br><br>  La mani√®re exacte de repr√©senter les mesures d'une telle pr√©cision d√©pend du d√©veloppeur.  S'il n'a pas besoin d'une telle pr√©cision, il peut toujours mesurer les performances de rendu de fragments plus gros. <br><br><h2>  <font color="#3AC1EF">Informations suppl√©mentaires sur les performances</font> </h2><br>  Maintenant que le d√©veloppeur a √† sa disposition un syst√®me de recherche d'indicateurs num√©riques qui caract√©risent tr√®s pr√©cis√©ment les performances des plus petits fragments de code, le d√©veloppeur peut utiliser ce syst√®me pour r√©soudre divers probl√®mes.  Ainsi, en utilisant <code>performance.mark()</code> vous pouvez √©crire des informations utiles suppl√©mentaires sur <code>trace.json</code> .  Vous pouvez dire aux membres de l'√©quipe de d√©veloppement ce qui se passe et ce qui provoque une augmentation du nombre d'instructions de processeur n√©cessaires pour ex√©cuter du code.  Vous pouvez inclure dans les rapports de performances des informations sur le nombre de n≈ìuds DOM ou sur le nombre d'op√©rations d'√©criture dans le DOM effectu√©es par React.  En fait, ici, vous pouvez afficher des informations sur un lot.  Vous pouvez compter le nombre de recalculs de mise en page.  En utilisant Puppeteer, vous pouvez prendre des captures d'√©cran des pages et comparer l'apparence de l'interface avant et apr√®s avoir apport√© des modifications.  Parfois, l'augmentation du nombre d'instructions du processeur n√©cessaires pour afficher une page ne semble pas du tout surprenante.  Par exemple, si 10 boutons et 12 champs pour l'√©dition et la mise en forme du texte sont ajout√©s √† la nouvelle version de la page. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Est-il possible pour tout le monde qui a √©t√© discut√© ici de l'utiliser aujourd'hui?  Oui tu peux.  Pour ce faire, vous avez besoin de Chrome version 78 ou sup√©rieure.  Si <code>trace.json</code> a des <code>tidelta</code> <code>ticount</code> et <code>tidelta</code> , alors ce qui pr√©c√®de est √† votre disposition.  Les versions ant√©rieures de Chrome ne le font pas. <br><br>  Malheureusement, les informations sur le nombre d'instructions du processeur ne peuvent pas √™tre obtenues sur la plate-forme Mac.  Je n'ai pas encore essay√© Windows, donc je ne peux rien dire de pr√©cis sur cet OS.  En g√©n√©ral - nos amis sont Unix et Linux. <br><br>  Il convient de noter que pour que le navigateur puisse fournir des informations sur les instructions du processeur, vous devrez utiliser quelques indicateurs - ce sont <code>--no-sandbox</code> et <code>--enable-thread-instruction-count</code> .  Voici comment les transmettre √† un navigateur lanc√© par Puppeteer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Avec un peu de chance, vous pouvez maintenant faire passer l'analyse des performances de votre application Web au niveau sup√©rieur. <br><br>  <b>Chers lecteurs!</b>  Envisagez-vous d'utiliser la m√©thodologie d'analyse des performances des projets Web pr√©sent√©e ici? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479266/">https://habr.com/ru/post/fr479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479252/index.html">Compr√©hension de la liste et carte</a></li>
<li><a href="../fr479256/index.html">Dans le sillage de l'Astrotracker en deux soir√©es - Mon exp√©rience</a></li>
<li><a href="../fr479258/index.html">IGF 2019. Internet est-il en train de s'effondrer?</a></li>
<li><a href="../fr479262/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 392 (2 - 8 d√©cembre 2019)</a></li>
<li><a href="../fr479264/index.html">La couleur de la Lune et du Soleil depuis l'espace en termes de RVB et de temp√©rature de couleur</a></li>
<li><a href="../fr479268/index.html">√âcouteurs d'√©v√©nements et travailleurs du Web</a></li>
<li><a href="../fr479270/index.html">Quelles nouveaut√©s pouvez-vous attendre de Node.js en 2020?</a></li>
<li><a href="../fr479272/index.html">[signet] 9 outils qui augmentent la productivit√© des d√©veloppeurs Web</a></li>
<li><a href="../fr479274/index.html">10 astuces Python √† conna√Ætre</a></li>
<li><a href="../fr479276/index.html">Trois m√©thodes Pandas que vous ne connaissez peut-√™tre pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>