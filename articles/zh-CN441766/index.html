<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 🤞🏻 🌲 扑 利弊 👩‍⚖️ 🖕🏻 🧦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="首先，让我们谈谈Flutter是什么。 这是用于从Google创建移动应用程序的框架。 它是跨平台的，允许您为3个操作系统编译创建的项目： 


- 安卓系统 
- 的iOS 
- 紫红色 


 此外，对于最新的操作系统-Fuchsia-这是创建应用程序的唯一方法。 
 自2015年以来，Flut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>扑 利弊</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/441766/"><img src="https://habrastorage.org/webt/4y/yp/p-/4yypp--haehfxzyw1qhyepx5wo4.png"><br><br> 首先，让我们谈谈Flutter是什么。 这是用于从Google创建移动应用程序的框架。 它是跨平台的，允许您为3个操作系统编译创建的项目： <br><ul><li> 安卓系统 </li><li> 的iOS </li><li> 紫红色 </li></ul><br><p> 此外，对于最新的操作系统-Fuchsia-这是创建应用程序的唯一方法。 <br> 自2015年以来，Flutter长期以来仅以alpha和beta版本提供。 第一个稳定版本于2018年12月4日发布。 </p><br><p>  Google积极推动Flutter的发展，并逐渐获得欢迎，并且很可能会继续淘汰当前使用的其他跨平台开发工具（React Native，Xamarin），尤其是在樱红色广泛分布的情况下。 鉴于Google将该操作系统定位为Android的替代产品，Flutter迟早将取代本地Android开发。 因此，展望和积极发展是Flutter的主要优势。 <a name="habracut"></a></p><br><p>  <strong>+展望与积极发展</strong> </p><br><p> 让我们看看它是如何工作的。 </p><br><p> 使用Dart编程语言，将创建一个移动应用程序，其中包含图形界面的描述以及整个工作逻辑。 工作结果将添加到本机应用程序中，例如图片，字体等（当然，此过程是自动化的）。 </p><br><p> 同时，在应用程序的本机部分中，创建了一个屏幕，在该屏幕中加载了运行Flutter的Dart虚拟机。 </p><br><p> 请注意，Flutter的缺点之一来自于此： </p><br><p>  <strong>-随着将Dart虚拟机添加到其中，最终安装包会更大。</strong> </p><br><p> 因此，存在Flutter文件，并且根据编译的类型（iOS或Android）添加了虚拟机。 </p><br><p> 虚拟机具有自己的图形引擎，它使用屏幕，对话框，片段等之间的所有转换来绘制应用程序界面。 在这种情况下，Flutter下的开发与使用真正的Android和iOS组件的Xamarin和React Native进行的开发明显不同。 对于它们，不可能使用特定于平台的组件（如果有此需要，则必须创建两个版本的UI）。 使用Flutter选择设计时，只需专注于一个平台（例如Android）即可。 在为iOS构建项目时，您会看到一个标准的Android界面。 看起来有些奇怪和出乎意料，但是很有用（以后可以改进界面）。 </p><br><p>  <strong>+自己的图形引擎（无需为Android和iOS单独创建界面）</strong> </p><br><p> 现在关于印象。 </p><br><p> 在将多个应用程序从Android移植到Flutter时，我们注意到了一些差异，这些差异可以视为正负。 </p><br><p>首先引起您注意的是创建屏幕的方法，该方法与Android和iOS上使用的显着不同。 在Android中，逻辑和接口是分开的：逻辑由代码设置，接口由xml中的布局设置。 在Flutter上，全部使用代码进行设置。 尽管此处使用了一种特殊的界面样式-创建的界面元素彼此嵌套。 这有点像布局，在React Native中工作的方式非常相似。 但是，不可能直接访问这些元素。 要更改屏幕上的某些内容，您必须更新整个屏幕，或者使用在创建过程中预先添加到窗口小部件的特殊控制器。 </p><br><p>  <strong>-接口是使用代码创建的，这使得逻辑和设计之间的界限变得更细。</strong> </p><br><p> 另一方面，这种方法可以更轻松地将屏幕拆分为单独的组件。 实际上，任何嵌套接口元素块都可以通过几个步骤移动到单独的小部件中，这比创建自定义View和片段要容易得多。 </p><br><p>  <strong>+接口很容易分成单独的模块</strong> </p><br><p> 最后两句话可能值得研究。 为此，我们将编写一个简单的应用程序，演示Flutter的某些功能。 这将是具有标准导航栏和标签栏的应用程序。 </p><br><p> 让我们制作三个标签： </p><br><p>  1）首先-使用文字和滑块调整文字的大小和颜色 <br>  2）将可下载的图像添加到第二个图像（带有进度指示器） <br>  3）第三名示例列表 <br></p><br><img src="https://habrastorage.org/webt/60/hq/wk/60hqwkx7tixpuvfqsgf1-isigqo.jpeg"><br><br> 还要假设我们最初并未将应用程序界面拆分为单独的选项卡。 在Flutter中，您可以在不使用片段的情况下实现此屏幕。 当然，仍然需要这样的分区，但是假设他们忘记这样做了，或者设计发生了变化，此后，由于惯性而继续进行了一级开发。 <br><p> 现在考虑实现此布局的源代码： </p><br><pre><code class="bash hljs">void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> MaterialApp( title: <span class="hljs-string"><span class="hljs-string">'Flutter Demo'</span></span>, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: <span class="hljs-string"><span class="hljs-string">'Home Page'</span></span>), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState(); }</code> </pre> <br><p> 该代码段几乎是所有Flutter应用程序的标准代码（它与项目一起创建）。 </p><br><p>  MyApp是应用程序本身的类，它描述创建MaterialApp时的常规参数：应用程序名称，字体，颜色和样式。 该应用程序的主屏幕也在此处显示（对于我们来说，这是MyHomePage）。 </p><br><p> 让我们做一个重要的说明：在Flutter中，小部件分为两种类型： </p><br><p>  1）StatefulWidget <br>  2）StatelessWidget </p><br><p> 需要两个类来描述StatefulWidget：小部件本身的类及其状态的类（将在其中进行主要工作）。 </p><br><p>  StatelessWidget由具有固定状态的一个类描述，并且只能通过从主窗口小部件重新创建来更改。 因此，出于我们的目的，需要StatefulWidget。 </p><br><p> 现在考虑_MyHomePageState： </p><br><pre> <code class="bash hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; { int _currentIndex = 0; double _size = 14; double _r = 0; double _g = 0; double _b = 0; @override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Scaffold( appBar: AppBar( title: Text(widget.title), ), body: &lt;Widget&gt;[</code> </pre> <br><p> 为了便于理解，带有文本的选项卡用红色标记，带有图片的选项卡用绿色标记，列表选项卡用蓝色标记，导航菜单用黄色标记。 如您所见，该接口被描述为彼此嵌入的一组小部件（及其数组）： <br></p><br><img src="https://habrastorage.org/webt/fu/id/fs/fuidfs_cy5qi8pw7t0tmgkjwbbi.jpeg"><br><br><img src="https://habrastorage.org/webt/48/_n/1w/48_n1wljocvubvciojokcwfawoy.jpeg"><br><br><img src="https://habrastorage.org/webt/ap/wd/nk/apwdnk3swtrssocrru64alm1vva.jpeg"><br><br><img src="https://habrastorage.org/webt/xe/hs/gy/xehsgyarrpxsp1j-cgzgllrdqmi.jpeg"><br><br> 使用的功能： <br><pre> <code class="bash hljs"> void _onTapped(int index) { setState(() { _currentIndex = index; }); } void _setTextStyle( {double size = -1, double r = -1, double g = -1, double b = -1}) { setState(() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; 0) { _size = size; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &gt; 0) { _r = r; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g &gt; 0) { _g = g; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &gt; 0) { _b = b; } }); } }</code> </pre> <br><p> 让我们更详细地考虑它们： </p><br><p>  onTapped-切换底部菜单中的选项卡时调用的函数。 它调用特殊的setState函数，该函数允许您使用新数据更新当前窗口小部件（并且我们更新了_currentIndex变量）。 </p><br><p> 让我们看看它的适用范围： </p><br><pre> <code class="plaintext hljs">body: &lt;Widget&gt;[    ][_currentIndex]</code> </pre> <br><p> 在这里，我们处理一个数组，从中使用_currentIndex选择一个屏幕布局选项，并将其替换为选项卡之一。 </p><br><p> 接下来是_setTextStyle函数。 对于类似C的语言，它的广告非常不寻常。 </p><br><pre> <code class="plaintext hljs">void _setTextStyle({double size = -1, double r = -1, double g = -1,double b = -1})</code> </pre> <br><p> 参数不是作为列表而是作为数组传递给它的。 这是Dart非常有趣的功能之一，与大多数其他语言相比，它允许您创建具有可变数量的参数的函数。 </p><br><p> 由于每个参数都是命名的，因此我们可以采用随机顺序。 例如： </p><br><pre> <code class="plaintext hljs">_setTextStyle(size: 24, b: 255)</code> </pre> <br><p> 让我们将大屏幕类分解为小部件。 最好按逻辑元素细分，在我们的例子中，这些是制表符。 感谢Flutter的功能，为此，我们足以获取负责每个选项卡的代码片段，并将它们与逻辑一起使用build方法转移到单独的类中。 </p><br><p>  <strong>第一个标签：</strong> </p><br><pre> <code class="bash hljs">class TextWidget extends StatefulWidget { @override _TextWidgetState createState() =&gt; _TextWidgetState(); } class _TextWidgetState extends State&lt;TextWidget&gt; { double _size = 14; double _r = 0; double _g = 0; double _b = 0; @override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Column( children: &lt;Widget&gt;[ Text(<span class="hljs-string"><span class="hljs-string">"Example String"</span></span>, style: TextStyle( fontSize: _size, color: Color.fromRGBO(_r.toInt(), _g.toInt(), _b.toInt(), 1))), Container(constraints: BoxConstraints.expand(height: 32.0)), Slider( label: <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${_size.toInt()}</span></span></span><span class="hljs-string"> sp"</span></span>, value: _size, min: 10, max: 48, divisions: 38, activeColor: Colors.black, inactiveColor: Colors.grey, onChanged: (val) =&gt; _setTextStyle(size: val)), Slider( label: _r.toInt().toString(), value: _r, min: 0, max: 255, divisions: 255, activeColor: Colors.red, inactiveColor: Colors.grey, onChanged: (val) =&gt; _setTextStyle(r: val), ), Slider( label: _g.toInt().toString(), value: _g, min: 0, max: 255, divisions: 255, activeColor: Colors.green, inactiveColor: Colors.grey, onChanged: (val) =&gt; _setTextStyle(g: val), ), Slider( label: _b.toInt().toString(), value: _b, min: 0, max: 255, divisions: 256, activeColor: Colors.blue, inactiveColor: Colors.grey, onChanged: (val) =&gt; _setTextStyle(b: val), ), ], ); } }</code> </pre> <br><p> 由于窗口小部件需要更新（_setTextStyle方法），因此我们使用StatefulWidget。 <br> 接下来的两个选项卡无需更新，因此我们将使用StatelessWidget。 </p><br><p>  <strong>第二个标签：</strong> </p><br><pre> <code class="bash hljs">class ImageWidget extends StatelessWidget { @override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Stack( children: &lt;Widget&gt;[ Center(child: CircularProgressIndicator()), Center( child: FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: <span class="hljs-string"><span class="hljs-string">'https://picsum.photos/250?image=9'</span></span>, ), ), ], ); } }</code> </pre> <br><p>  <strong>第三个标签：</strong> </p><br><pre> <code class="bash hljs">class ListWidget extends StatelessWidget { @override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> ListView.builder( itemCount: 25, itemBuilder: (BuildContext context, int index) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Container( child: Text( <span class="hljs-string"><span class="hljs-string">'entry $index'</span></span>, style: TextStyle(color: Colors.white), ), margin: EdgeInsets.all(16.0), padding: EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.blue, borderRadius: BorderRadius.all( Radius.circular(16.0), ), ), ); }, ); } }</code> </pre> <br><p> 更改了主屏幕状态代码： </p><br><pre> <code class="bash hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; { int _currentIndex = 0; Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Scaffold( appBar: AppBar( title: Text(widget.title), actions: &lt;Widget&gt;[ IconButton(icon: Icon(Icons.navigate_next), onPressed: next) ], ), body: &lt;Widget&gt;[ TextWidget(), ImageWidget(), ListWidget(), ][_currentIndex], bottomNavigationBar: BottomNavigationBar( currentIndex: _currentIndex, onTap: _onTapped, items: [ BottomNavigationBarItem( icon: new Icon(Icons.text_format), title: new Text(<span class="hljs-string"><span class="hljs-string">'Text'</span></span>), ), BottomNavigationBarItem( icon: new Icon(Icons.image), title: new Text(<span class="hljs-string"><span class="hljs-string">'Image'</span></span>), ), BottomNavigationBarItem( icon: Icon(Icons.list), title: Text(<span class="hljs-string"><span class="hljs-string">'ListView'</span></span>), ) ], )); }</code> </pre> <br><p> 因此，我们可以轻松地将一个大屏幕拆分为一个小屏幕和三个小窗口部件。 您会注意到，在Flutter屏幕上，概念上与小部件没有什么不同（更确切地说，小部件承担着活动，片段和自定义视图的功能）。 当应用程序需要任何元素的全屏视图时，此功能非常方便-为此，您可以以最小的改进使用我们的小部件。 </p><br><p> 但是，用作屏幕的窗口小部件和常规窗口小部件之间的差异很小。 屏幕小部件的根元素应为Scaffold对象（允许您添加appBar，bottomNavigationBar，floatingActionButton，抽屉等）。 </p><br><p> 常规窗口小部件没有此限制，因为使用构建方法，它们将被嵌入在已有Scaffold的主屏幕中。 </p><br><p> 幸运的是，将Scaffold添加到常规窗口小部件不会影响其性能。 </p><br><p> 您还可以添加SafeArea（为状态栏提供缩进）。 获得以下简单转换： </p><br><p> 来自： </p><br><pre> <code class="bash hljs">@override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> []; }</code> </pre> <br><p> 至： </p><br><pre> <code class="bash hljs">@override Widget build(BuildContext context) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> Scaffold( body: SafeArea( child: [] ), ); }</code> </pre><br><p> 好了，现在回到Flutter利弊的讨论。 </p><br><p>  Flutter最近已发布，因此错误很常见。 在更新Flutter时，这一点尤其明显-一些库开始出现错误。 </p><br><p>  <strong>-不稳定（最近才发布Beta版）</strong> </p><br><p> 显然，使用新框架时，与本地Android / iOS开发相比，您拥有的库要少得多。 但是，Flutter仍然有很多库，并且它们继续以很高的速度出现。 例如，显然是在2018年下半年添加了许多库，以准备发布第一个稳定版本，而在此之前存在最重要的库（Google Analytics，Firebase，Maps等）。 </p><br><p>  <strong>-比本地开发更少的库</strong> <br>  <strong>+最重要的库已经存在，新库不断涌现</strong> </p><br><p> 现在该盘点一下！ 让我们回顾一下所有的利弊，从最重要的优点到最重要的缺点进行排列： </p><br><p>  <strong>+跨平台</strong> <br>  <strong>+展望与积极发展</strong> <br>  <strong>+最重要的库已经存在，新库不断涌现</strong> <br>  <strong>+自己的图形引擎</strong> <br>  <strong>+接口很容易分成单独的模块</strong> </p><br><p>  <strong>-最终安装包较大，因为Dart虚拟机已添加到其中</strong> <br>  <strong>-使用代码创建接口，这使逻辑和设计之间的界线变得更薄</strong> <br>  <strong>-比本地开发少的库（和信息）</strong> <br>  <strong>-不稳定（最近才发布Beta版）</strong> </p><br><p> 感谢您的关注！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441766/">https://habr.com/ru/post/zh-CN441766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441754/index.html">Kubernetes在生产中的成功案例。 第10部分：Reddit</a></li>
<li><a href="../zh-CN441756/index.html">对于俄罗斯的工业PC平台，他们采用了Baikal-T1处理器和Alt OS</a></li>
<li><a href="../zh-CN441758/index.html">眼科手术“在梦中”-睡觉还是不睡觉-这就是问题所在</a></li>
<li><a href="../zh-CN441762/index.html">VMmanager 6：用于从ISPsystem创建虚拟机的新工具</a></li>
<li><a href="../zh-CN441764/index.html">数字取证技巧和窍门：增强的命令行审核</a></li>
<li><a href="../zh-CN441768/index.html">面向企业和初创公司的十大移动应用开发公司</a></li>
<li><a href="../zh-CN441770/index.html">在哈萨克斯坦实施仅数字移动银行</a></li>
<li><a href="../zh-CN441772/index.html">英特尔PAC N3000-网络应用FPGA</a></li>
<li><a href="../zh-CN441774/index.html">服务器登录通知（SSH / TERMINAL）便宜而愉快</a></li>
<li><a href="../zh-CN441780/index.html">使用无共享架构降低停机风险</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>