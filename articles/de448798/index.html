<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛 🌽 👇🏽 Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7 👧🏾 ☯️ 👍🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zurück 


 In der Regel wird pytest nicht unabhängig verwendet, sondern in einer Testumgebung mit anderen Tools. In diesem Kapitel werden andere Tools...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448798/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> </p><br><p>  <em>In der Regel wird pytest nicht unabhängig verwendet, sondern in einer Testumgebung mit anderen Tools.</em>  <em>In diesem Kapitel werden andere Tools erläutert, die häufig in Verbindung mit pytest für effektive und effiziente Tests verwendet werden.</em>  <em>Obwohl dies keine vollständige Liste ist, geben Ihnen die hier beschriebenen Werkzeuge einen Eindruck vom Geschmack der Fähigkeit, Pytest mit anderen Werkzeugen zu mischen.</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Die Beispiele in diesem Buch wurden mit Python 3.6 und pytest 3.2 geschrieben.  pytest 3.2 unterstützt Python 2.6, 2.7 und Python 3.3+. </p><br><blockquote> Der Quellcode für das Aufgabenprojekt sowie für alle in diesem Buch gezeigten Tests ist unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">Link</a> auf der Webseite des Buches unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com verfügbar</a> .  Sie müssen den Quellcode nicht herunterladen, um den Testcode zu verstehen.  Der Testcode wird in den Beispielen in einer praktischen Form dargestellt.  Um jedoch die Aufgaben des Projekts zu verfolgen oder Testbeispiele anzupassen, um Ihr eigenes Projekt zu testen (Ihre Hände sind losgebunden!), Müssen Sie auf die Webseite des Buches gehen und die Arbeit herunterladen.  Dort, auf der Webseite des Buches, gibt es einen Link für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://pragprog.com/titles/bopytest/errata">Errata-</a> Nachrichten und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="https://forums.pragprog.com/forums/438">Diskussionsforum</a> . </blockquote><p>  Unter dem Spoiler befindet sich eine Liste der Artikel dieser Reihe. </p><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Einführung</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 1: Erste Schritte mit Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 2: Schreiben von Testfunktionen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 3: Pytest-Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 4: Eingebaute Vorrichtungen</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Kapitel 6: Konfiguration</strong></a> </li><li>  [ <strong>Kapitel 7: Verwenden von pytest mit anderen Tools</strong> ] (Dieser Artikel) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/en/post/448798/</a> ) </li></ul></div></div><br><h2 id="pdb-debugging-test-failures">  pdb: Debuggen von Testfehlern </h2><br><p> Das <code>pdb</code> Modul ist ein Python-Debugger in der Standardbibliothek.  Sie verwenden <code>--pdb</code> damit pytest an der Fehlerstelle eine Debugging-Sitzung startet.  Schauen wir uns <code>pdb</code> in Aktion im Kontext des Aufgabenprojekts an. </p><br><p>  In „Parametrisierung der Vorrichtung“ auf Seite 64 haben wir das Aufgabenprojekt mit einigen Fehlern verlassen: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/c/tasks_proj $ pytest --tb=no -q .........................................FF.FFFF FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF........... 42 failed, 54 passed in 4.74 seconds</code> </pre> <br><p>  Bevor wir uns ansehen, wie <code>pdb</code> uns beim Debuggen dieses Tests helfen kann, <code>pdb</code> wir einen Blick auf die verfügbaren Pytest-Optionen, um das Debuggen der Testfehler zu beschleunigen, die wir zuerst im Abschnitt „Verwenden von Optionen“ auf Seite 9 untersucht haben: </p><br><ul><li>  <code>--tb=[auto/long/short/line/native/no]</code> : Steuert den Trace-Stil. </li><li>  <code>-v / --verbose</code> : Zeigt alle <code>-v / --verbose</code> , die bestanden oder nicht bestanden wurden. </li><li>  <code>-l / --showlocals</code> : Zeigt lokale Variablen neben dem Stack-Trace an. </li><li>  <code>-lf / --last-failed</code> : <code>-lf / --last-failed</code> nur <code>-lf / --last-failed</code> Tests aus. </li><li>  <code>-x / --exitfirst</code> : Stoppt die <code>-x / --exitfirst</code> beim ersten Fehler. </li><li>  <code>--pdb</code> : Startet eine interaktive Debugging-Sitzung zum Zeitpunkt des Fehlers. </li></ul><br><hr><br><p>  <em>MongoDB installieren</em> </p><br><hr><br><p>  Wie in Kapitel 3, „Pytest-Vorrichtungen“, auf Seite 49 erwähnt, sind <code>pymongo</code> und <code>pymongo</code> Installationen erforderlich, um MongoDB-Tests durchzuführen. </p><br><p>  Ich habe die Version von Community Server unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.mongodb.com/download-center</a> getestet.  pymongo installiert mit <code>pip</code> : <code>pip install pymongo</code> .  Dies ist jedoch das letzte Beispiel in einem Buch, das MongoDB verwendet.  Um den Debugger ohne Verwendung von MongoDB auszuprobieren, können Sie die pytest-Befehle über den <code>code/ch2/</code> , da dieses Verzeichnis auch mehrere fehlgeschlagene Tests enthält. </p><br><hr><br><p>  Wir haben gerade die Tests mit <code>code/ch3/c</code> , um sicherzustellen, dass einige davon nicht funktionieren.  Wir haben keine Tracebacks oder <code>--tb=no</code> da <code>--tb=no</code> die Ablaufverfolgung deaktiviert und <code>--verbose</code> aktiviert hat.  Wiederholen wir die Fehler (nicht mehr als drei) mit dem detaillierten Text: </p><br><pre> <code class="plaintext hljs">$ pytest --tb=no --verbose --lf --maxfail=3 ============================= test session starts ============================= collected 96 items / 52 deselected run-last-failure: rerun previous 44 failures tests/func/test_add.py::test_add_returns_valid_id[mongo] ERROR [ 2%] tests/func/test_add.py::test_added_task_has_id_set[mongo] ERROR [ 4%] tests/func/test_add.py::test_add_increases_count[mongo] ERROR [ 6%] =================== 52 deselected, 3 error in 0.72 seconds ====================</code> </pre> <br><p>  Jetzt wissen wir, welche Tests fehlgeschlagen sind.  Schauen wir uns nur einen von ihnen an, indem wir <code>-x</code> , die Ablaufverfolgung <code>--tb=no</code> , nicht <code>--tb=no</code> und lokale Variablen mit <code>-l</code> <code>--tb=no</code> : </p><br><pre> <code class="plaintext hljs">$ pytest -v --lf -l -x ===================== test session starts ====================== run-last-failure: rerun last 42 failures collected 96 items tests/func/test_add.py::test_add_returns_valid_id[mongo] FAILED =========================== FAILURES =========================== _______________ test_add_returns_valid_id[mongo] _______________ tasks_db = None def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;) should return an integer.""" # GIVEN an initialized tasks db # WHEN a new task is added # THEN returned task_id is of type int new_task = Task('do something') task_id = tasks.add(new_task) &gt; assert isinstance(task_id, int) E AssertionError: assert False E + where False = isinstance(ObjectId('59783baf8204177f24cb1b68'), int) new_task = Task(summary='do something', owner=None, done=False, id=None) task_id = ObjectId('59783baf8204177f24cb1b68') tasks_db = None tests/func/test_add.py:16: AssertionError !!!!!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!!!! ===================== 54 tests deselected ====================== =========== 1 failed, 54 deselected in 2.47 seconds ============</code> </pre><br><p>  Sehr oft reicht dies aus, um zu verstehen, warum der Test fehlgeschlagen ist.  In diesem speziellen Fall ist es ziemlich klar, dass <code>task_id</code> keine Ganzzahl ist - es ist eine Instanz von ObjectId.  ObjectId ist der Typ, der von MongoDB für Objektkennungen in der Datenbank verwendet wird.  Meine Absicht mit der <code>tasksdb_pymongo.py</code> Ebene war es, bestimmte Details der MongoDB-Implementierung vor dem Rest des Systems zu verbergen.  Es ist klar, dass es in diesem Fall nicht funktioniert hat. </p><br><p>  Wir möchten jedoch sehen, wie pdb mit pytest verwendet wird. Stellen wir uns also vor, es ist unklar, warum dieser Test fehlgeschlagen ist.  Mit --pdb können wir pytest veranlassen, eine Debugging-Sitzung zu starten und uns direkt am Fehlerpunkt zu starten: </p><br><pre> <code class="plaintext hljs">$ pytest -v --lf -x --pdb ===================== test session starts ====================== run-last-failure: rerun last 42 failures collected 96 items tests/func/test_add.py::test_add_returns_valid_id[mongo] FAILED &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; traceback &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; tasks_db = None def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;) should return an integer.""" # GIVEN an initialized tasks db # WHEN a new task is added # THEN returned task_id is of type int new_task = Task('do something') task_id = tasks.add(new_task) &gt; assert isinstance(task_id, int) E AssertionError: assert False E + where False = isinstance(ObjectId('59783bf48204177f2a786893'), int) tests/func/test_add.py:16: AssertionError &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entering PDB &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; /path/to/code/ch3/c/tasks_proj/tests/func/test_add.py(16) &gt; test_add_returns_valid_id() -&gt; assert isinstance(task_id, int) (Pdb)</code> </pre> <br><p>  Jetzt, da wir an der Eingabeaufforderung (Pdb) sind, haben wir Zugriff auf alle interaktiven PDF-Debugging-Funktionen.  Beim Anzeigen von Abstürzen verwende ich regelmäßig die folgenden Befehle: </p><br><ul><li>  <code>p/print expr</code> : <code>p/print expr</code> den Wert von exp. </li><li>  <code>pp expr</code> : Pretty druckt den Wert von expr. </li><li>  <code>l/list</code> : Listet den Fehlerpunkt und fünf Codezeilen oben und unten auf. </li><li>  <code>l/list begin,end</code> : Listet bestimmte Zeilennummern auf. </li><li>  <code>a/args</code> : Druckt die Argumente der aktuellen Funktion mit ihren Werten. </li><li>  <code>u/up</code> : Verschiebt den Stapelpfad um eine Ebene nach oben. </li><li>  <code>d/down</code> : Verschiebt sich im Stack-Trace um eine Ebene nach unten. </li><li>  <code>q/quit</code> : Beendet eine Debugging-Sitzung. </li></ul><br><p>  Andere Navigationsbefehle wie step und next sind nicht sehr nützlich, da wir direkt in der assert-Anweisung sitzen.  Sie können auch einfach Variablennamen eingeben und Werte abrufen. </p><br><p>  Sie können <code>p/print expr</code> ähnlich wie die <code>-l/--showlocals</code> , um die Werte in einer Funktion <code>-l/--showlocals</code> : </p><br><pre> <code class="plaintext hljs">(Pdb) p new_task Task(summary='do something', owner=None, done=False, id=None) (Pdb) p task_id ObjectId('59783bf48204177f2a786893') (Pdb)</code> </pre> <br><p>  Jetzt können Sie den Debugger beenden und mit dem Testen fortfahren. </p><br><pre> <code class="plaintext hljs">(Pdb) q !!!!!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!!!! ===================== 54 tests deselected ====================== ========== 1 failed, 54 deselected in 123.40 seconds ===========</code> </pre> <br><p>  Wenn wir <code>-</code> nicht verwenden würden, würde pytest Pdb im nächsten Test erneut öffnen.  Weitere Informationen zur Verwendung des pdb-Moduls finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Dokumentation</a> . </p><br><h2 id="coveragepy-opredelenie-obema-testiruemogo-koda">  Coverage.py: Bestimmen der Menge an Testcode </h2><br><p>  Die Codeabdeckung ist ein Indikator für den Prozentsatz des getesteten Codes, der durch eine Reihe von Tests getestet wird.  Wenn Sie Tests für das Aufgabenprojekt ausführen, werden einige Aufgabenfunktionen mit jedem Test ausgeführt, jedoch nicht mit allen. </p><br><p>  Tools zur Codeabdeckung eignen sich hervorragend, um Sie darüber zu informieren, welche Teile des Systems bei Tests vollständig übersehen werden. </p><br><p>  <code>Coverage.py</code> ist das bevorzugte Python-Coverage-Tool, das die Codeabdeckung misst. </p><br><p>  Sie werden es verwenden, um den Aufgabenprojektcode mit pytest zu überprüfen. </p><br><p>  Um <code>coverage.py</code> , müssen Sie es installieren.  Es <code>pytest-cov</code> nicht weh, ein Plugin namens <code>pytest-cov</code> zu installieren, mit dem Sie <code>coverage.py</code> von pytest mit einigen zusätzlichen Pytest-Optionen aufrufen können.  Da <code>coverage</code> eine der Abhängigkeiten von <code>pytest-cov</code> , installieren <code>pytest-cov</code> einfach <code>pytest-cov</code> und es wird <code>coverage.py</code> : </p><br><pre> <code class="plaintext hljs">$ pip install pytest-cov Collecting pytest-cov Using cached pytest_cov-2.5.1-py2.py3-none-any.whl Collecting coverage&gt;=3.7.1 (from pytest-cov) Using cached coverage-4.4.1-cp36-cp36m-macosx_10_10_x86 ... Installing collected packages: coverage, pytest-cov Successfully installed coverage-4.4.1 pytest-cov-2.5.1</code> </pre> <br><p>  Lassen Sie uns den Abdeckungsbericht für die zweite Taskversion ausführen.  Wenn Sie immer noch die erste Version des Aufgabenprojekts installiert haben, deinstallieren Sie es und installieren Sie Version 2: </p><br><pre> <code class="plaintext hljs">$ pip uninstall tasks Uninstalling tasks-0.1.0: /path/to/venv/bin/tasks /path/to/venv/lib/python3.6/site-packages/tasks.egg-link Proceed (y/n)? y Successfully uninstalled tasks-0.1.0 $ cd /path/to/code/ch7/tasks_proj_v2 $ pip install -e . Obtaining file:///path/to/code/ch7/tasks_proj_v2 ... Installing collected packages: tasks Running setup.py develop for tasks Successfully installed tasks $ pip list ... tasks (0.1.1, /path/to/code/ch7/tasks_proj_v2/src) ...</code> </pre> <br><p>  Nachdem die nächste Version der Aufgaben installiert ist, können Sie den Basisabdeckungsbericht ausführen: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch7/tasks_proj_v2 $ pytest --cov=src ===================== test session starts ====================== plugins: mock-1.6.2, cov-2.5.1 collected 62 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ......... tests/func/test_unique_id.py . tests/unit/test_cli.py ..... tests/unit/test_task.py .... ---------- coverage: platform darwin, python 3.6.2-final-0 ----------- Name Stmts Miss Cover -------------------------------------------------- src\tasks\__init__.py 2 0 100% src\tasks\api.py 79 22 72% src\tasks\cli.py 45 14 69% src\tasks\config.py 18 12 33% src\tasks\tasksdb_pymongo.py 74 74 0% src\tasks\tasksdb_tinydb.py 32 4 88% -------------------------------------------------- TOTAL 250 126 50% ================== 62 passed in 0.47 seconds ===================</code> </pre> <br><p>  Da das aktuelle Verzeichnis <code>tasks_proj_v2</code> und sich der zu <code>tasks_proj_v2</code> Quellcode in src befindet, wird durch Hinzufügen der Option <code>--cov=src</code> nur für dieses zu <code>--cov=src</code> Verzeichnis ein Abdeckungsbericht generiert. </p><br><p>  Wie Sie sehen können, haben einige Dateien eine recht geringe und sogar 0% ige Abdeckung.  Dies sind nützliche Erinnerungen: <code>tasksdb_pymongo.py</code> 0%, da wir das Testen auf MongoDB in dieser Version deaktiviert haben.  Einige von ihnen sind ziemlich niedrig.  Das Projekt muss sicherlich Tests für alle diese Bereiche liefern, bevor es zur Hauptsendezeit bereit ist. </p><br><p>  Ich glaube, dass mehrere Dateien einen höheren Prozentsatz der Abdeckung haben: <code>api.py</code> und <code>tasksdb_tinydb.py</code> .  <code>tasksdb_tinydb.py</code> wir einen Blick auf <code>tasksdb_tinydb.py</code> und sehen, was fehlt.  Ich denke, der beste Weg, dies zu tun, ist die Verwendung von HTML-Berichten. </p><br><p>  Wenn Sie <code>coverage.py</code> erneut mit der Option <code>--cov-report=html</code> , wird ein <code>--cov-report=html</code> generiert: </p><br><pre> <code class="plaintext hljs">$ pytest --cov=src --cov-report=html ===================== test session starts ====================== plugins: mock-1.6.2, cov-2.5.1 collected 62 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ......... tests/func/test_unique_id.py . tests/unit/test_cli.py ..... tests/unit/test_task.py .... ---------- coverage: platform darwin, python 3.6.2-final-0 ----------- Coverage HTML written to dir htmlcov ================== 62 passed in 0.45 seconds ===================</code> </pre> <br><p>  Sie können dann <code>htmlcov/index.html</code> in einem Browser öffnen, der die Ausgabe auf dem folgenden Bildschirm anzeigt: </p><br><p><img src="https://habrastorage.org/webt/vs/sc/84/vssc84hovxefvf2g65740gu3ll0.png"></p><br><p>  Wenn Sie auf <code>tasksdb_tinydb.py</code> wird ein Bericht für eine Datei angezeigt.  Der Prozentsatz der abgedeckten Zeilen wird oben im Bericht angezeigt, plus wie viele Zeilen abgedeckt sind und wie viele nicht, wie auf dem nächsten Bildschirm angezeigt: </p><br><p><img src="https://habrastorage.org/webt/os/pc/-o/ospc-o_yzzdfh1lzllw_1qtilrc.png"></p><br><p>  Wenn Sie nach unten scrollen, sehen Sie die fehlenden Linien, wie im folgenden Bildschirm gezeigt: </p><br><p><img src="https://habrastorage.org/webt/85/rg/lt/85rgltocwrunycedzbeweix4zyc.png"></p><br><p>  Auch wenn dieser Bildschirm keine vollständige Seite für diese Datei ist, reicht dies aus, um uns Folgendes mitzuteilen: </p><br><ol><li>  Wir testen <code>list_tasks()</code> mit dem Eigentümer-Set. </li><li>  Wir testen <code>update()</code> oder <code>delete()</code> . </li><li>  Vielleicht testen wir <code>unique_id()</code> nicht gründlich. </li></ol><br><p>  Großartig.  Wir können sie zusammen mit dem Testen des Konfigurationssystems in unsere TO-DO-Testliste aufnehmen. </p><br><p>  Obwohl Tools zur Codeabdeckung äußerst nützlich sind, kann das Streben nach 100% iger Abdeckung gefährlich sein.  Wenn Sie Code sehen, der nicht getestet wird, kann dies bedeuten, dass ein Test erforderlich ist.  Es kann aber auch bedeuten, dass einige Systemfunktionen nicht benötigt werden und entfernt werden können.  Wie alle Softwareentwicklungstools ersetzt die Analyse der Codeabdeckung nicht das Denken. </p><br><p>  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>pytest-cov</code></a> Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> coverage.py</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>pytest-cov</code></a> . </p><br><h2 id="mock-podmena-chastey-sistemy">  mock: Ersatz von Systemteilen </h2><br><p>  Das Scheinpaket wird verwendet, um Teile des Systems zu ersetzen und Teile des Testcodes vom Rest des Systems zu isolieren.  Scheinobjekte werden manchmal als Testdoppel, Spione, Fälschungen oder Stummel bezeichnet. </p><br><p>  Zwischen Ihrem eigenen Pytest-Monkeypatch-Gerät (beschrieben unter Verwenden von Monkeypatch auf Seite 85) und Mock sollten Sie über alle erforderlichen Dual-Test-Funktionen verfügen. </p><br><blockquote>  Achtung!  Verspottet und sehr komisch <br>  Wenn Sie zum ersten Mal auf Testzwillinge wie Mocks, Stubs und Spione treffen, machen Sie sich bereit!  Es wird sehr seltsam sein, sehr schnell, lustig, wenn auch sehr beeindruckend. </blockquote><p>  Das <code>mock</code> Paket enthält die Standard-Python-Bibliothek wie <code>unittest.mock</code> seit Python 3.3.  In früheren Versionen ist es als separates Paket verfügbar, das über PyPI installiert wird.  Dies bedeutet, dass Sie die nachgebildete PyPI-Version von Python 2.6 bis zur neuesten Python-Version verwenden und die gleiche Funktionalität wie die neueste nachgebildete Python-Version erhalten können.  Für die Verwendung mit pytest verfügt ein Plugin namens <code>pytest-mock</code> über einige Funktionen, die es zu meiner bevorzugten Schnittstelle für das Mock-System machen. </p><br><p>  Für das Aufgabenprojekt verwenden wir <code>mock</code> , um die Befehlszeilenschnittstelle zu testen.  In Coverage.py: <code>cli.py</code> Sie ermittelt haben, wie viel Code getestet wird, haben Sie auf Seite 129 <code>cli.py</code> dass unsere Datei <code>cli.py</code> nicht getestet wurde.  Wir werden jetzt anfangen, das Problem zu beheben.  Aber lassen Sie uns zuerst über Strategie sprechen. </p><br><p>  Die erste Lösung im Aufgabenprojekt bestand darin, die meisten Funktionalitätstests über <code>api.py</code>  Eine vernünftige Lösung besteht daher darin, dass das Testen der Befehlszeile kein vollständiger Funktionstest sein muss.  Wir können sicher sein, dass das System über die CLI funktioniert, wenn wir während des CLI-Tests eine nasse API-Ebene erhalten.  Es ist auch eine bequeme Lösung, mit der wir uns Moki in diesem Abschnitt ansehen können. </p><br><p>  Die Implementierung von CLI-Aufgaben verwendet ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Click-</a> Befehlszeilenschnittstellenpaket eines Drittanbieters.  Es gibt viele Alternativen für die Implementierung der Befehlszeilenschnittstelle, einschließlich eines in Python <code>argparse</code> .  Einer der Gründe, warum ich mich für Click entschieden habe, ist, dass es eine Test-Engine enthält, mit der wir Click-Anwendungen testen können.  Obwohl wir hoffen, dass der Code in <code>cli.py</code> typisch für Click-Anwendungen ist, ist er nicht offensichtlich. </p><br><p>  Lassen Sie uns die dritte Version von Tasks verlangsamen und installieren: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install -e ch7/tasks_proj_v2 ... Successfully installed tasks</code> </pre> <br><p>  Im Rest dieses Abschnitts werden Sie mehrere Tests entwickeln, um die Funktionalität von "Liste" zu testen. <br>  Lassen Sie es uns in Aktion sehen, um zu verstehen, was wir überprüfen werden: </p><br><blockquote>  <strong><em>Hinweis für den Übersetzer:</em></strong> Bei Verwendung der Windows-Plattform sind beim Testen der folgenden Sitzung verschiedene Probleme aufgetreten. <br><ol><li>  Für die Datenbank " <strong><code>tasks_db</code></strong> im Ordner Ihres Benutzers ein Ordner erstellt werden.  Zum Beispiel <code>c:\Users\User_1\tasks_db\</code> <br>  Andernfalls erhalten wir - &gt;&gt; FileNotFoundError: [Errno 2] Keine solche Datei oder kein solches Verzeichnis: 'c: \ Benutzer \ Benutzer_1 // Aufgaben_db // Aufgaben_db.json' </li><li>  Verwenden Sie doppelte Anführungszeichen anstelle eines Apostrophs.  Andernfalls erhalten Sie einen Fehler <br>  "Mach etwas Großartiges" <br>  Verwendung: Aufgaben fügen [OPTIONEN] ZUSAMMENFASSUNG hinzu <br>  Versuchen Sie "Aufgaben add -h" für Hilfe. <br><br>  Fehler: Ich habe unerwartete zusätzliche Argumente erhalten (etwas Großartiges) <br></li></ol><br></blockquote><br><pre> <code class="plaintext hljs">$ tasks list ID owner done summary -- ----- ---- ------- $ tasks add 'do something great' $ tasks add "repeat" -o Brian $ tasks add "again and again" --owner Okken $ tasks list ID owner done summary -- ----- ---- ------- 1 False do something great 2 Brian False repeat 3 Okken False again and again $ tasks list -o Brian ID owner done summary -- ----- ---- ------- 2 Brian False repeat $ tasks list --owner Brian ID owner done summary -- ----- ---- ------- 2 Brian False repeat</code> </pre> <br><p>  Es sieht ziemlich einfach aus.  Der Befehl <code>tasks list</code> zeigt eine Liste aller Aufgaben unter der Überschrift an. <br>  Der Titel wird gedruckt, auch wenn die Liste leer ist.  Der Befehl zeigt nur Daten von einem Eigentümer an, wenn <code>-o</code> oder <code>--owner</code> .  Und wie überprüfen wir das?  Es gibt viele Möglichkeiten, aber wir werden Moki verwenden. </p><br><p>  Tests, die MOKs verwenden, sind notwendigerweise <em>White-Box-Tests</em> , und wir müssen den Code untersuchen, um zu entscheiden, was und wo wir schlagen werden.  Der Haupteinstiegspunkt ist hier: </p><br><blockquote>  ch7 / task_proj_v2 / src / task / cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: tasks_cli()</code> </pre> <br><p>  Dies ist nur ein Aufruf von <code>tasks_cli()</code> : </p><br><blockquote>  ch7 / task_proj_v2 / src / task / cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@click.group(context_settings={'help_option_names': ['-h', '--help']}) @click.version_option(version='0.1.1') def tasks_cli(): """Run the tasks application.""" pass</span></span></code> </pre> <br><p>  Offensichtlich?  Nein.  Aber warte, es wird gut (oder schlecht, abhängig von deiner Sichtweise).  Hier ist einer der <code>list</code> : </p><br><blockquote>  ch7 / task_proj_v2 / src / task / cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@tasks_cli.command(name="list", help="list tasks") @click.option('-o', '--owner', default=None, help='list tasks with this owner') def list_tasks(owner): """    .   ,      . """ formatstr = "{: &gt;4} {: &gt;10} {: &gt;5} {}" print(formatstr.format('ID', 'owner', 'done', 'summary')) print(formatstr.format('--', '-----', '----', '-------')) with _tasks_db(): for t in tasks.list_tasks(owner): done = 'True' if t.done else 'False' owner = '' if t.owner is None else t.owner print(formatstr.format( t.id, owner, done, t.summary))</span></span></code> </pre> <br><p>  Wenn Sie sich an das Schreiben von Click-Code gewöhnt haben, stellen Sie sicher, dass dieser Code nicht so schlecht ist.  Ich werde hier nicht erklären, was und wie es in dieser Funktion funktioniert, da die Entwicklung von Befehlszeilencode nicht im Mittelpunkt des Buches steht.  Obwohl ich fast absolut sicher bin, dass ich diesen richtigen Code habe, gibt es immer viel Raum für menschliches Versagen.  Aus diesem Grund ist eine gute Reihe automatisierter Tests wichtig, um sicherzustellen, dass diese Funktion ordnungsgemäß funktioniert. <br>  Diese Funktion <code>list_tasks(owner)</code> hängt von mehreren anderen Funktionen ab: <code>tasks_db()</code> und <code>tasks.list_tasks(owner)</code> (API-Funktion). </p><br><p>  Wir werden <code>mock</code> , um gefälschte Funktionen für <code>tasks_db()</code> und <code>tasks.list_tasks()</code> .  Dann können wir die <code>list_tasks</code> Methode über die Befehlszeilenschnittstelle aufrufen und sicherstellen, dass sie die <code>tasks.list_tasks()</code> -Funktion <code>tasks.list_tasks()</code> , die korrekt funktioniert und den Rückgabewert korrekt verarbeitet. <br>  <code>tasks_db()</code> wir uns eine echte Implementierung an, um <code>tasks_db()</code> zu übertönen: </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zurück</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448798/">https://habr.com/ru/post/de448798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448786/index.html">Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen</a></li>
<li><a href="../de448788/index.html">Python-Test mit Pytest. Kapitel 2, Schreiben von Testfunktionen</a></li>
<li><a href="../de448790/index.html">SpaceVIL - plattformübergreifendes GUI-Framework für die Entwicklung auf .Net Core, .Net Standard und JVM</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448796/index.html">Python-Test mit Pytest. Konfiguration, KAPITEL 6</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448802/index.html">Mit Portalen denken: Portale in Unreal Engine 4 erstellen</a></li>
<li><a href="../de448804/index.html">Vorbereitungen für die gehärtete Laufzeit und den Notar von macOS</a></li>
<li><a href="../de448806/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek</a></li>
<li><a href="../de448810/index.html">Wie habe ich einen Hacker gefangen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>