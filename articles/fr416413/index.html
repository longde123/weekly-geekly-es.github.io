<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ üßù üî∞ Entr√©, vu, g√©n√©ralis√©: immerg√© dans Java Generics üé® üìä üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics est l'un des changements les plus importants de l'histoire du langage Java. Les g√©n√©riques disponibles avec Java 5 ont rendu l'utilisati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entr√©, vu, g√©n√©ralis√©: immerg√© dans Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics est l'un des changements les plus importants de l'histoire du langage Java.  Les g√©n√©riques disponibles avec Java 5 ont rendu l'utilisation de Java Collection Framework plus facile, plus pratique et plus s√ªre.  Les erreurs associ√©es √† une mauvaise utilisation des types sont d√©sormais d√©tect√©es au stade de la compilation.  Oui, et le langage Java lui-m√™me est devenu encore plus s√ªr.  Malgr√© l'apparente simplicit√© des types g√©n√©riques, de nombreux d√©veloppeurs ont du mal √† les utiliser.  Dans cet article, je parlerai des fonctionnalit√©s de travail avec Java Generics, afin que vous ayez moins de ces difficult√©s.  Utile si vous n'√™tes pas un gourou g√©n√©rique, et vous aidera √† √©viter beaucoup de difficult√©s lors de l'immersion dans le sujet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Travailler avec des collections </h2><br>  Supposons qu'une banque ait besoin de calculer le montant des √©conomies dans les comptes clients.  Avant l'av√®nement des ¬´g√©n√©riques¬ª, la m√©thode de calcul de la somme ressemblait √† ceci: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Nous avons it√©r√©, parcouru la liste des comptes et v√©rifi√© si l'√©l√©ment de cette liste est vraiment une instance de la classe <code>Account</code> , c'est-√†-dire le compte de l'utilisateur.  Le type de notre objet de la classe <code>Account</code> et la m√©thode <code>getAmount</code> ont √©t√© <code>getAmount</code> , ce qui a renvoy√© le montant de ce compte.  Ensuite, ils ont r√©sum√© le tout et retourn√© le montant total.  Deux √©tapes ont √©t√© n√©cessaires: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Si vous ne v√©rifiez pas ( <code>instanceof</code> ) l'appartenance √† la classe <code>Account</code> , alors √† la deuxi√®me √©tape une <code>ClassCastException</code> est possible - c'est-√†-dire un plantage du programme.  Par cons√©quent, une telle v√©rification √©tait obligatoire. <br><br>  Avec l'av√®nement des g√©n√©riques, le besoin de v√©rification de type et de transtypage a disparu: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  M√©thode Now <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  accepte comme arguments uniquement une liste d'objets de la classe <code>Account</code> .  Cette restriction est indiqu√©e dans la m√©thode elle-m√™me, dans sa signature, le programmeur ne peut tout simplement pas transf√©rer d'autre liste - uniquement la liste des comptes clients. <br><br>  Nous n'avons pas besoin de v√©rifier le type d'√©l√©ments de cette liste: cela est impliqu√© par la description du type du param√®tre de m√©thode <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (peut √™tre lu comme une <code>   Account</code> ).  Et le compilateur g√©n√©rera une erreur si quelque chose ne va pas - c'est-√†-dire, si quelqu'un essaie de passer une liste d'objets autres que la classe <code>Account</code> √† cette m√©thode. <br><br>  Dans la deuxi√®me ligne du ch√®que, le besoin a √©galement disparu.  Si n√©cessaire, le <code>casting</code> sera fait lors de la compilation. <br><br><h2>  Principe de substitution </h2><br>  Le principe de substitution de Barbara Liskov est une d√©finition sp√©cifique d'un sous-type dans la programmation orient√©e objet.  L'id√©e de Liskov d'un ¬´sous-type¬ª d√©finit le concept de substitution: si <code>S</code> est un sous-type de <code>T</code> , alors les objets de type <code>T</code> dans un programme peuvent √™tre remplac√©s par des objets de type <code>S</code> sans aucune modification des propri√©t√©s souhait√©es de ce programme. <br><br><table><tbody><tr><td>  <b>Tapez</b> <br></td><td>  <b>Sous-type</b> <br></td></tr><tr><td>  <i>Num√©ro</i> <br></td><td>  <i>Entier</i> <br></td></tr><tr><td>  <i>Liste</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Collection</i> &lt;E&gt; <br></td><td>  <i>Liste</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Iterable</i> &lt;E&gt; <br></td><td>  <i>Collection</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Exemples de relations de type / sous-type</i> <br><br>  Voici un exemple d'utilisation du principe de substitution en Java: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> est un sous-type de <code>Number</code> , par cons√©quent, la variable <code>n</code> type <code>Number</code> peut recevoir la valeur <code>Integer.valueOf(42)</code> la <code>Integer.valueOf(42)</code> . <br><br><h2>  Covariance, contravariance et invariance </h2><br>  Tout d'abord, un peu de th√©orie.  La covariance est la pr√©servation de la hi√©rarchie d'h√©ritage des types source dans les types d√©riv√©s dans le m√™me ordre.  Par exemple, si le <i>chat</i> est un sous-type d' <i>animaux</i> , alors l' <i>ensemble de &lt;chats&gt;</i> est un sous-type de l' <i>ensemble de &lt;animaux&gt;</i> .  Par cons√©quent, compte tenu du principe de substitution, on peut effectuer la mission suivante: <br><br>  <i>Many &lt;Animals&gt; = Many &lt;Cats&gt;</i> <br><br>  La contravariance est l'inversion de la hi√©rarchie des types de source dans les types d√©riv√©s.  Par exemple, si le <i>chat</i> est un sous-type des <code></code> , l' <i>ensemble &lt;Animaux&gt;</i> est un sous-type de l' <i>ensemble &lt;Cats&gt;</i> .  Par cons√©quent, compte tenu du principe de substitution, on peut effectuer la mission suivante: <br><br>  <i>Many &lt;Cats&gt; = Many &lt;Animals&gt;</i> <br><br>  Invariance - manque d'h√©ritage entre les types d√©riv√©s.  Si le <i>chat</i> est un sous-type d' <i>animaux</i> , alors l' <i>ensemble de &lt;chats&gt; n'est</i> pas un sous-type de l' <i>ensemble de &lt;animaux&gt;</i> et l' <i>ensemble de &lt;animaux&gt; n'est</i> pas un sous-type de l' <i>ensemble de &lt;chats&gt;</i> . <br><br>  <b>Les tableaux en Java sont covariants</b> .  Le type <code>S[]</code> est un sous-type de <code>T[]</code> si <code>S</code> est un sous-type de <code>T</code>  Exemple d'affectation: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Nous avons attribu√© un lien vers un tableau de cha√Ænes √† la variable <code>arr</code> , dont le type est <code>¬´ ¬ª</code> .  Si les tableaux n'√©taient pas covariants, nous ne serions pas en mesure de le faire.  Java vous permet de le faire, le programme se compile et s'ex√©cute sans erreur. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Mais si nous essayons de changer le contenu du tableau via la variable <code>arr</code> et d'y √©crire le nombre 42, nous obtiendrons une <code>ArrayStoreException</code> au stade de l'ex√©cution du programme, car 42 n'est pas une cha√Æne, mais un nombre.  C'est l'inconv√©nient de la covariance des tableaux Java: nous ne pouvons pas effectuer de v√©rifications au stade de la compilation, et quelque chose peut d√©j√† se casser lors de l'ex√©cution. <br><br>  <b>Les "g√©n√©riques" sont invariants.</b>  Voici un exemple: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Si vous prenez une liste d'entiers, ce ne sera pas un sous-type de type <code>Number</code> , ni aucun autre sous-type.  Il n'est qu'un sous-type de lui-m√™me.  Autrement dit, <code>List &lt;Integer&gt;</code> est un <code>List&lt;Integer&gt;</code> et rien d'autre.  Le compilateur s'assurera que la variable <code>ints</code> d√©clar√©e comme une liste d'objets de la classe <i>Integer</i> ne contient que des objets de la classe <code>Integer</code> et rien d'autre.  Au stade de la compilation, une v√©rification est effectu√©e et rien ne tombera dans notre runtime. <br><br><h2>  Caract√®res g√©n√©riques </h2><br>  Les g√©n√©riques sont-ils toujours invariants?  Non.  Je vais donner des exemples: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  C'est la covariance.  <code>List&lt;Integer&gt;</code> - sous-type de <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  C'est de la contravariance.  <code>List&lt;Number&gt;</code> est un sous-type de <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Un enregistrement comme <code>"? extends ..."</code> ou <code>"? super ..."</code> est appel√© un caract√®re g√©n√©rique ou un caract√®re g√©n√©rique, avec une limite sup√©rieure ( <code>extends</code> ) ou une limite inf√©rieure ( <code>super</code> ). <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> peut contenir des objets dont la classe est <code>Number</code> ou h√©rite de <code>Number</code> . <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> peut contenir des objets dont la classe est <code>Number</code> ou dont <code>Number</code> est un h√©ritier (supertype from <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  √©tend <i>B</i> - caract√®re g√©n√©rique avec limite sup√©rieure <br>  super <i>B</i> - caract√®re g√©n√©rique avec une borne inf√©rieure <br>  o√π <i>B</i> - repr√©sente la fronti√®re <br><br>  Un enregistrement de la forme T <sub>2</sub> &lt;= T <sub>1</sub> signifie que l'ensemble des types d√©crits par T <sub>2</sub> est un sous-ensemble de l'ensemble des types d√©crits par T <sub>1</sub> <br><br>  c'est-√†-dire <br>  Num√©ro &lt;=?  √©tend l'objet <br>  ?  √©tend Number &lt;=?  √©tend l'objet <br>  et <br>  ?  super objet &lt;=?  super num√©ro <br><br></td></tr></tbody></table><br>  <i>Plus d'interpr√©tation math√©matique du sujet</i> <br><br>  Une paire de t√¢ches pour tester les connaissances: <br><br>  1. Pourquoi l'erreur de compilation dans l'exemple ci-dessous?  Quelle valeur puis-je ajouter √† la liste des <code>nums</code> ? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text">  Le conteneur doit-il √™tre d√©clar√© avec un caract√®re g√©n√©rique <code>? extends</code>  <code>? extends</code> , vous ne pouvez lire que les valeurs.  Rien ne peut √™tre ajout√© √† la liste sauf <code>null</code> .  Pour ajouter un objet √† la liste, nous avons besoin d'un autre type de caract√®re g√©n√©rique - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. Pourquoi ne puis-je pas obtenir un article de la liste ci-dessous? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text">  Vous ne pouvez pas lire un √©l√©ment d'un conteneur avec un caract√®re g√©n√©rique <code>? super</code>  <code>? super</code> , sauf pour un objet de classe <code>Object</code> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  Le principe Get and Put ou PECS (le producteur √©tend Consumer Super) </h3><br>  La fonctionnalit√© g√©n√©rique avec des limites sup√©rieures et inf√©rieures offre des fonctionnalit√©s suppl√©mentaires li√©es √† l'utilisation s√ªre des types.  Vous ne pouvez lire qu'√† partir d'un type de variable, seulement √©crire √† un autre (l'exception est la possibilit√© d'√©crire <code>null</code> pour <code>extends</code> et de lire <code>Object</code> pour <code>super</code> ).  Pour qu'il soit plus facile de se rappeler quand utiliser quel caract√®re g√©n√©rique, il existe le principe PECS - Producer Extends Consumer Super. <br><br><ul><li>  Si nous avons d√©clar√© un <i>caract√®re g√©n√©rique avec extend</i> , alors c'est <i>producteur</i> .  Il "produit" seulement, fournit un √©l√©ment du contenant et n'accepte rien. <br></li><li>  Si nous avons annonc√© un <i>caract√®re g√©n√©rique avec super</i> , alors c'est le <i>consommateur</i> .  Il accepte seulement, mais ne peut rien fournir. <br></li></ul><br>  Envisagez d'utiliser Wildcard et le principe PECS en utilisant la m√©thode de copie dans la classe java.util.Collections comme exemple. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  La m√©thode copie les √©l√©ments de la liste <code>src</code> origine dans la liste <code>dest</code> .  <code>src</code> - d√©clar√© avec caract√®re g√©n√©rique <code>? extends</code>  <code>? extends</code> et est le producteur, et <code>dest</code> est d√©clar√© avec un caract√®re g√©n√©rique <code>? super</code>  <code>? super</code> et est un consommateur.  √âtant donn√© la covariance et la contravariance des caract√®res g√©n√©riques, vous pouvez copier des √©l√©ments de la liste des <code>nums</code> vers la liste des <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Si nous confondons les param√®tres de la m√©thode de copie par erreur et essayons de copier de la liste <code>nums</code> vers la liste <code>ints</code> , le compilateur ne nous permettra pas de faire ceci: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; et types Raw </h3><br>  Vous trouverez ci-dessous un caract√®re g√©n√©rique avec un caract√®re g√©n√©rique illimit√©.  Nous venons de mettre <code>&lt;?&gt;</code> , Sans les mots <code>extends</code> cl√©s <code>super</code> ou <code>extends</code> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  En fait, un tel caract√®re g√©n√©rique "illimit√©" est toujours limit√©, vu d'en haut.  <code>Collection&lt;?&gt;</code> Est √©galement un caract√®re g√©n√©rique, comme " <code>? extends Object</code> ".  Un enregistrement du formulaire <code>Collection&lt;?&gt;</code> √âquivaut √† <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , ce qui signifie que la collection peut contenir des objets de n'importe quelle classe, car toutes les classes en Java h√©ritent d' <code>Object</code> - donc la substitution est appel√©e illimit√©e. <br><br>  Si nous omettons l'indication de type, par exemple, comme ici: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  puis ils disent que <code>ArrayList</code> est le type <code>Raw</code> de la <i>ArrayList</i> param√©tr√©e <i>&lt;T&gt;</i> .  En utilisant les types Raw, nous retournons √† l'√®re des g√©n√©riques et abandonnons consciemment toutes les fonctionnalit√©s inh√©rentes aux types param√©tr√©s. <br><br>  Si nous essayons d'appeler une m√©thode param√©tr√©e sur le type Raw, le compilateur nous donnera un avertissement ¬´Appel non v√©rifi√©¬ª.  Si nous essayons d'assigner une r√©f√©rence √† un type Raw param√©tr√© √† un type, le compilateur donnera un avertissement ¬´Affectation non v√©rifi√©e¬ª.  Ignorer ces avertissements, comme nous le verrons plus loin, peut entra√Æner des erreurs lors de l'ex√©cution de notre application. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Capture de caract√®res g√©n√©riques </h3><br>  Essayons maintenant d'impl√©menter une m√©thode qui permute les √©l√©ments d'une liste dans l'ordre inverse. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Une erreur de compilation s'est produite car la m√©thode <code>reverse</code> prend une liste avec un caract√®re g√©n√©rique illimit√© <code>&lt;?&gt;</code> Comme argument. <br>  <code>&lt;?&gt;</code> signifie la m√™me chose que <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Par cons√©quent, selon le principe PECS, la <code>list</code> est <code>producer</code> .  Et le <code>producer</code> ne produit que des √©l√©ments.  Et nous dans la boucle <code>for</code> appelons la m√©thode <code>set()</code> , c'est-√†-dire  essayer d'√©crire dans la <code>list</code> .  Et nous nous reposons donc sur la protection Java, qui ne nous permet pas de d√©finir une valeur par index. <br><br>  Que faire  Le mod√®le de <code>Wildcard Capture</code> nous aidera.  Ici, nous cr√©ons une m√©thode g√©n√©rique <code>rev</code> .  Il est d√©clar√© avec une variable de type <code>T</code>  Cette m√©thode accepte une liste de types <code>T</code> , et nous pouvons faire un ensemble. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Maintenant, tout va compiler avec nous.  La capture g√©n√©rique a √©t√© captur√©e ici.  Lorsque la m√©thode <code>reverse(List&lt;?&gt; list)</code> est appel√©e <code>reverse(List&lt;?&gt; list)</code> , une liste de certains objets (par exemple, des cha√Ænes ou des entiers) est pass√©e en argument.  Si nous pouvons capturer le type de ces objets et l'affecter √† une variable de type <code>X</code> , alors nous pouvons conclure que <code>T</code> est <code>X</code> <br><br>  Vous pouvez en savoir plus sur <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Conclusion </h3><br>  Si vous devez lire √† partir du conteneur, utilisez un caract√®re g√©n√©rique avec la bordure sup√©rieure " <code>? extends</code> ".  Si vous devez √©crire dans le conteneur, utilisez un caract√®re g√©n√©rique avec une bordure inf√©rieure de " <code>? super</code> ".  N'utilisez pas de caract√®res g√©n√©riques si vous devez enregistrer et lire. <br><br>  N'utilisez pas de types <code>Raw</code> !  Si l'argument type n'est pas d√©fini, utilisez le caract√®re g√©n√©rique <code>&lt;?&gt;</code> . <br><br><h2>  Variables de type </h2><br>  Lorsque nous √©crivons l'identifiant entre crochets, par exemple, <code>&lt;T&gt;</code> ou <code>&lt;E&gt;</code> lors de la d√©claration d'une classe ou d'une m√©thode, nous cr√©ons <i>une variable de type</i> .  Une variable de type est un identifiant non qualifi√© qui peut √™tre utilis√© comme type dans le corps d'une classe ou d'une m√©thode.  Une variable de type peut √™tre d√©limit√©e ci-dessus. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  Dans cet exemple, l'expression <code>T extends Comparable&lt;T&gt;</code> d√©finit <code>T</code> (une variable de type) d√©limit√©e ci-dessus par le type <code>Comparable&lt;T&gt;</code> .  Contrairement aux caract√®res g√©n√©riques, les variables de type ne peuvent √™tre limit√©es qu'en haut ( <code>extends</code> uniquement).  Impossible d'√©crire <code>super</code> .  De plus, dans cet exemple, <code>T</code> d√©pend de lui-m√™me, il est appel√© <code>recursive bound</code> - une fronti√®re r√©cursive. <br><br>  Voici un autre exemple de la classe Enum: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Ici, la classe Enum est param√©tr√©e par le type E, qui est un sous-type d' <code>Enum&lt;E&gt;</code> . <br><br><h3>  Limites multiples </h3><br>  <code>Multiple Bounds</code> multiples - contraintes multiples.  Il est √©crit par le caract√®re " <code>&amp;</code> ", c'est-√†-dire que nous disons que le type repr√©sent√© par une variable de type <code>T</code> doit √™tre limit√© par le haut par la classe <code>Object</code> et l'interface <code>Comparable</code> . <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> enregistrement <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> forme le type d'intersection <code>Multiple Bounds</code> .  La premi√®re limitation - dans ce cas, <code>Object</code> - est utilis√©e pour l' <code>erasure</code> , le processus de remplacement des types.  Il est ex√©cut√© par le compilateur au stade de la compilation. <br><br><h3>  Conclusion </h3><br>  Une variable de type ne peut √™tre limit√©e qu'au-dessus d'un ou de plusieurs types.  Dans le cas de contraintes multiples, la bordure gauche (la premi√®re contrainte) est utilis√©e dans le processus d'√©crasement (Type Erasure). <br><br><h2>  Effacement du type </h2><br>  L'effacement de type est un mappage de types (incluant √©ventuellement des types param√©tr√©s et des variables de type) avec des types qui ne sont jamais des types param√©tr√©s ou des types de variables.  Nous √©crivons le brassage de type <code>T</code> comme <code>|T|</code>  . <br><br>  L'affichage de la pur√©e est d√©fini comme suit: <br><ul><li>  √âcraser le type param√©tr√© <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; est |  <i>G</i> | </li><li>  √âcraser un <i>TC de</i> type imbriqu√© est |  <i>T</i> |.  <i>C</i> </li><li>  √âcraser le type de tableau <i>T []</i> est |  <i>T</i> | [] </li><li>  √âcraser une variable de type, c'est √©craser sa bordure gauche </li><li>  √âcraser tout autre type est ce type lui-m√™me </li></ul><br><br>  Pendant l'ex√©cution de Type Erasure (type mashing), le compilateur effectue les actions suivantes: <br><ul><li>  ajoute la coul√©e de caract√®res pour assurer la s√©curit√© des caract√®res si n√©cessaire </li><li>  g√©n√®re des m√©thodes Bridge pour maintenir le polymorphisme </li></ul><br><br><table><tbody><tr><td>  <b>T (Type)</b> <br></td><td>  <b>| T |</b>  <b>(Type de pur√©e)</b> <br></td></tr><tr><td>  <i>Liste &lt;entier&gt;, liste &lt;cha√Æne&gt;, liste &lt;liste &lt;cha√Æne &gt;&gt;</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>Liste &lt;entier&gt; []</i> <br></td><td>  <i>Liste []</i> <br></td></tr><tr><td>  <i>Liste</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Entier</i> <br></td><td>  <i>Entier</i> <br></td></tr><tr><td>  <i>&lt;T √©tend Comparable &lt;T&gt;&gt;</i> <br></td><td>  <i>Comparable</i> <br></td></tr><tr><td>  <i>&lt;T √©tend Objet &amp; Comparable &lt;?</i>  <i>super T &gt;&gt;</i> <br></td><td>  <i>Objet</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Ce tableau montre √† quoi les diff√©rents types se transforment pendant le processus de brassage, Type Erasure. <br><br>  Dans la capture d'√©cran ci-dessous sont deux exemples du programme: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  La diff√©rence entre les deux est qu'une erreur de compilation se produit √† gauche et √† droite, tout se compile sans erreur.  Pourquoi? <br><br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text">  En Java, deux m√©thodes diff√©rentes ne peuvent pas avoir la m√™me signature.  Dans le processus d'effacement de type, le compilateur ajoutera la m√©thode bridge <code>public int compareTo(Object o)</code> .  Mais la classe contient d√©j√† une m√©thode avec une telle signature qu'elle provoquera une erreur lors de la compilation. <br><br>  Compilez la classe Name en supprimant la <code>compareTo(Object o)</code> et examinez le bytecode r√©sultant √† l'aide de javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Nous voyons que la classe contient une m√©thode <code>int compareTo(java.lang.Object)</code> , bien que nous l'avons supprim√©e du code source.  Il s'agit de la m√©thode de pontage ajout√©e par le compilateur. <br></div></div><br><br><h3>  Types r√©ifiables </h3><br>  En Java, nous disons qu'un type est <code>reifiable</code> si ses informations sont enti√®rement accessibles au moment de l'ex√©cution.  Les types r√©ifiables incluent: <br><ul><li>  Types primitifs ( <i>int</i> , <i>long</i> , <i>bool√©en</i> ) </li><li>  Types non param√©tr√©s (non g√©n√©riques) ( <i>cha√Æne</i> , <i>entier</i> ) </li><li>  Types param√©tr√©s dont les param√®tres sont repr√©sent√©s comme des caract√®res g√©n√©riques non limit√©s (caract√®res g√©n√©riques illimit√©s) ( <i>Liste &lt;?&gt;</i> , <i>Collection &lt;?&gt;</i> ) </li><li>  Types <i>bruts</i> (non form√©s) ( <i>List</i> , <i>ArrayList</i> ) </li><li>  Tableaux dont les composants sont des types r√©ifiables ( <i>int []</i> , <i>Number []</i> , <i>List &lt;?&gt; []</i> , <i>List [</i> ) </li></ul><br><br>  Pourquoi des informations sur certains types sont-elles disponibles mais pas sur d'autres?  Le fait est qu'en raison du processus d'√©crasement des types par le compilateur, des informations sur certains types peuvent √™tre perdues.  S'il est perdu, ce type ne sera plus r√©ifiable.  Autrement dit, il n'est pas disponible au moment de l'ex√©cution.  Si disponibles - respectivement, r√©ifiables. <br><br>  La d√©cision de ne pas rendre tous les types g√©n√©riques disponibles au moment de l'ex√©cution est l'une des d√©cisions de conception les plus importantes et les plus conflictuelles du syst√®me de types Java.  Ceci est fait, tout d'abord, pour la compatibilit√© avec le code existant.  J'ai d√ª payer pour la compatibilit√© de la migration - l'accessibilit√© compl√®te d'un syst√®me de types g√©n√©riques au moment de l'ex√©cution n'est pas possible. <br><br>  Quels types ne sont pas r√©ifiables: <br><ul><li>  Variable de type ( <i>T</i> ) </li><li>  Type param√©tr√© avec le type de param√®tre sp√©cifi√© ( <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>List &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Un type param√©tr√© avec la limite sup√©rieure ou inf√©rieure sp√©cifi√©e ( <i>List &lt;? Extends Number&gt;, Comparable &lt;? Super String&gt;</i> ).  Mais voici une r√©serve: <i>Liste &lt;?</i>  <i>√©tend Object&gt;</i> - <b>non</b> r√©ifiable, mais <i>List &lt;?&gt;</i> - r√©ifiable </li></ul><br><br>  Et encore une t√¢che.  Pourquoi dans l'exemple ci-dessous ne peut pas cr√©er une exception param√©tr√©e? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text">  Chaque expression catch dans try-catch v√©rifie le type de l'exception re√ßue pendant l'ex√©cution du programme (ce qui √©quivaut √† instanceof), respectivement, le type doit √™tre r√©ifiable.  Par cons√©quent, Throwable et ses sous-types ne peuvent pas √™tre param√©tr√©s. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Avertissements non v√©rifi√©s </h3><br>  La compilation de notre application peut produire ce que l'on appelle un avertissement <code>Unchecked Warning</code> - un avertissement indiquant que le compilateur n'a pas pu d√©terminer correctement le niveau de s√©curit√© d'utilisation de nos types.  Ce n'est pas une erreur, mais un avertissement, vous pouvez donc l'ignorer.  Mais il est conseill√© de tout r√©parer afin d'√©viter des probl√®mes √† l'avenir. <br><br><h3>  Pollution en tas </h3><br>  Comme nous l'avons mentionn√© pr√©c√©demment, l'attribution d'une r√©f√©rence √† un type Raw √† une variable d'un type param√©tr√© conduit √† l'avertissement ¬´Affectation non v√©rifi√©e¬ª.  Si nous l'ignorons, une situation appel√©e ¬´ <code>Heap Pollution</code> ¬ª (pollution en tas) est possible.  Voici un exemple: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  Sur la ligne (1), le compilateur avertit de "Affectation non v√©rifi√©e". <br><br>  Nous devons donner un autre exemple de ¬´pollution en tas¬ª - lorsque nous utilisons des objets param√©tr√©s.  L'extrait de code ci-dessous montre clairement qu'il n'est pas autoris√© d'utiliser des types param√©tr√©s comme arguments d'une m√©thode utilisant <code>Varargs</code> .  Dans ce cas, le param√®tre de m√©thode m est <code>List&lt;String&gt;‚Ä¶</code> , i.e.  en fait, un tableau d'√©l√©ments de type <code>List&lt;String&gt;</code> .  √âtant donn√© la r√®gle d'affichage des types lors du <code>stringLists</code> , le type <code>stringLists</code> se transforme en un tableau de listes brutes ( <code>List[]</code> ), c'est-√†-dire  l'affectation peut √™tre effectu√©e <code>Object[] array = stringLists;</code>  puis √©crivez dans un <code>array</code> un objet autre que la liste des cha√Ænes (1), qui <code>ClassCastException</code> dans la cha√Æne (2). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Prenons un autre exemple: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java permet l'affectation en ligne (1).  Cela est n√©cessaire pour la compatibilit√© descendante.  Mais si nous essayons d'ex√©cuter la m√©thode <code>add</code> dans la ligne (2), nous obtenons un avertissement d' <code>Unchecked call</code> - le compilateur nous avertit d'une erreur possible.  En fait, nous essayons d'ajouter un entier √† la liste des cha√Ænes. <br><br><h3>  La r√©flexion </h3><br>  Bien que, lors de la compilation, les types param√©tr√©s subissent une proc√©dure d'effacement de type, nous pouvons obtenir des informations √† l'aide de Reflection. <br><br><ul><li>  Tous r√©ifiables sont disponibles via le m√©canisme de r√©flexion. <br></li><li>  Des informations sur le type de champs de classe, les param√®tres de m√©thode et les valeurs renvoy√©es par ceux-ci sont disponibles via Reflection. <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3>  Conclusion </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    ¬´ ¬ª      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     ¬´ ¬ª.     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   ‚Äì <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   ‚Äî   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> ‚Äî    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    ‚Äî     .        JDK 8 ‚Äî        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   ‚Äì    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    (¬´¬ª) ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      ¬´two¬ª. <br><br>   -    JDK1.7 ‚Äì    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     ¬´one¬ª. <code>Checkcast</code> ‚Äì    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Conclusion </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416413/">https://habr.com/ru/post/fr416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416403/index.html">Recueil Fintech: attaque contre la banque PIR, le Service f√©d√©ral des imp√¥ts et les taxes de transfert de carte √† carte, ainsi que certaines cha√Ænes de blocs et crypto-monnaies</a></li>
<li><a href="../fr416405/index.html">Programmes de licence en partenariat avec Yandex</a></li>
<li><a href="../fr416407/index.html">√âconomiser du trafic gr√¢ce au renifleur de Mikrotik</a></li>
<li><a href="../fr416409/index.html">5 erreurs courantes dans l'√©laboration de strat√©gies et les moyens de les g√©rer</a></li>
<li><a href="../fr416411/index.html">Racontez des histoires avec des donn√©es</a></li>
<li><a href="../fr416415/index.html">Nous d√©pla√ßons tout dans l'ensemble de test Vivaldi 1.16.1230.3</a></li>
<li><a href="../fr416417/index.html">"Heavenly River" - La Chine cr√©era une pluie artificielle d'une puissance sans pr√©c√©dent</a></li>
<li><a href="../fr416419/index.html">G√©n√©rateur de grottes bidimensionnel al√©atoire</a></li>
<li><a href="../fr416421/index.html">Une promenade dans la voie des stands, ou comment les technologies IaaS aident les √©quipes de course</a></li>
<li><a href="../fr416423/index.html">Comment les Russes ont pens√© au processeur am√©ricain, ou un examen du DVR AdvoCam-FD8 Gold-II (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>