<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 🧝 🔰 Entré, vu, généralisé: immergé dans Java Generics 🎨 📊 👨🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics est l'un des changements les plus importants de l'histoire du langage Java. Les génériques disponibles avec Java 5 ont rendu l'utilisati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entré, vu, généralisé: immergé dans Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics est l'un des changements les plus importants de l'histoire du langage Java.  Les génériques disponibles avec Java 5 ont rendu l'utilisation de Java Collection Framework plus facile, plus pratique et plus sûre.  Les erreurs associées à une mauvaise utilisation des types sont désormais détectées au stade de la compilation.  Oui, et le langage Java lui-même est devenu encore plus sûr.  Malgré l'apparente simplicité des types génériques, de nombreux développeurs ont du mal à les utiliser.  Dans cet article, je parlerai des fonctionnalités de travail avec Java Generics, afin que vous ayez moins de ces difficultés.  Utile si vous n'êtes pas un gourou générique, et vous aidera à éviter beaucoup de difficultés lors de l'immersion dans le sujet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Travailler avec des collections </h2><br>  Supposons qu'une banque ait besoin de calculer le montant des économies dans les comptes clients.  Avant l'avènement des «génériques», la méthode de calcul de la somme ressemblait à ceci: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Nous avons itéré, parcouru la liste des comptes et vérifié si l'élément de cette liste est vraiment une instance de la classe <code>Account</code> , c'est-à-dire le compte de l'utilisateur.  Le type de notre objet de la classe <code>Account</code> et la méthode <code>getAmount</code> ont été <code>getAmount</code> , ce qui a renvoyé le montant de ce compte.  Ensuite, ils ont résumé le tout et retourné le montant total.  Deux étapes ont été nécessaires: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Si vous ne vérifiez pas ( <code>instanceof</code> ) l'appartenance à la classe <code>Account</code> , alors à la deuxième étape une <code>ClassCastException</code> est possible - c'est-à-dire un plantage du programme.  Par conséquent, une telle vérification était obligatoire. <br><br>  Avec l'avènement des génériques, le besoin de vérification de type et de transtypage a disparu: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Méthode Now <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  accepte comme arguments uniquement une liste d'objets de la classe <code>Account</code> .  Cette restriction est indiquée dans la méthode elle-même, dans sa signature, le programmeur ne peut tout simplement pas transférer d'autre liste - uniquement la liste des comptes clients. <br><br>  Nous n'avons pas besoin de vérifier le type d'éléments de cette liste: cela est impliqué par la description du type du paramètre de méthode <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (peut être lu comme une <code>   Account</code> ).  Et le compilateur générera une erreur si quelque chose ne va pas - c'est-à-dire, si quelqu'un essaie de passer une liste d'objets autres que la classe <code>Account</code> à cette méthode. <br><br>  Dans la deuxième ligne du chèque, le besoin a également disparu.  Si nécessaire, le <code>casting</code> sera fait lors de la compilation. <br><br><h2>  Principe de substitution </h2><br>  Le principe de substitution de Barbara Liskov est une définition spécifique d'un sous-type dans la programmation orientée objet.  L'idée de Liskov d'un «sous-type» définit le concept de substitution: si <code>S</code> est un sous-type de <code>T</code> , alors les objets de type <code>T</code> dans un programme peuvent être remplacés par des objets de type <code>S</code> sans aucune modification des propriétés souhaitées de ce programme. <br><br><table><tbody><tr><td>  <b>Tapez</b> <br></td><td>  <b>Sous-type</b> <br></td></tr><tr><td>  <i>Numéro</i> <br></td><td>  <i>Entier</i> <br></td></tr><tr><td>  <i>Liste</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Collection</i> &lt;E&gt; <br></td><td>  <i>Liste</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Iterable</i> &lt;E&gt; <br></td><td>  <i>Collection</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Exemples de relations de type / sous-type</i> <br><br>  Voici un exemple d'utilisation du principe de substitution en Java: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> est un sous-type de <code>Number</code> , par conséquent, la variable <code>n</code> type <code>Number</code> peut recevoir la valeur <code>Integer.valueOf(42)</code> la <code>Integer.valueOf(42)</code> . <br><br><h2>  Covariance, contravariance et invariance </h2><br>  Tout d'abord, un peu de théorie.  La covariance est la préservation de la hiérarchie d'héritage des types source dans les types dérivés dans le même ordre.  Par exemple, si le <i>chat</i> est un sous-type d' <i>animaux</i> , alors l' <i>ensemble de &lt;chats&gt;</i> est un sous-type de l' <i>ensemble de &lt;animaux&gt;</i> .  Par conséquent, compte tenu du principe de substitution, on peut effectuer la mission suivante: <br><br>  <i>Many &lt;Animals&gt; = Many &lt;Cats&gt;</i> <br><br>  La contravariance est l'inversion de la hiérarchie des types de source dans les types dérivés.  Par exemple, si le <i>chat</i> est un sous-type des <code></code> , l' <i>ensemble &lt;Animaux&gt;</i> est un sous-type de l' <i>ensemble &lt;Cats&gt;</i> .  Par conséquent, compte tenu du principe de substitution, on peut effectuer la mission suivante: <br><br>  <i>Many &lt;Cats&gt; = Many &lt;Animals&gt;</i> <br><br>  Invariance - manque d'héritage entre les types dérivés.  Si le <i>chat</i> est un sous-type d' <i>animaux</i> , alors l' <i>ensemble de &lt;chats&gt; n'est</i> pas un sous-type de l' <i>ensemble de &lt;animaux&gt;</i> et l' <i>ensemble de &lt;animaux&gt; n'est</i> pas un sous-type de l' <i>ensemble de &lt;chats&gt;</i> . <br><br>  <b>Les tableaux en Java sont covariants</b> .  Le type <code>S[]</code> est un sous-type de <code>T[]</code> si <code>S</code> est un sous-type de <code>T</code>  Exemple d'affectation: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Nous avons attribué un lien vers un tableau de chaînes à la variable <code>arr</code> , dont le type est <code>« »</code> .  Si les tableaux n'étaient pas covariants, nous ne serions pas en mesure de le faire.  Java vous permet de le faire, le programme se compile et s'exécute sans erreur. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Mais si nous essayons de changer le contenu du tableau via la variable <code>arr</code> et d'y écrire le nombre 42, nous obtiendrons une <code>ArrayStoreException</code> au stade de l'exécution du programme, car 42 n'est pas une chaîne, mais un nombre.  C'est l'inconvénient de la covariance des tableaux Java: nous ne pouvons pas effectuer de vérifications au stade de la compilation, et quelque chose peut déjà se casser lors de l'exécution. <br><br>  <b>Les "génériques" sont invariants.</b>  Voici un exemple: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Si vous prenez une liste d'entiers, ce ne sera pas un sous-type de type <code>Number</code> , ni aucun autre sous-type.  Il n'est qu'un sous-type de lui-même.  Autrement dit, <code>List &lt;Integer&gt;</code> est un <code>List&lt;Integer&gt;</code> et rien d'autre.  Le compilateur s'assurera que la variable <code>ints</code> déclarée comme une liste d'objets de la classe <i>Integer</i> ne contient que des objets de la classe <code>Integer</code> et rien d'autre.  Au stade de la compilation, une vérification est effectuée et rien ne tombera dans notre runtime. <br><br><h2>  Caractères génériques </h2><br>  Les génériques sont-ils toujours invariants?  Non.  Je vais donner des exemples: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  C'est la covariance.  <code>List&lt;Integer&gt;</code> - sous-type de <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  C'est de la contravariance.  <code>List&lt;Number&gt;</code> est un sous-type de <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Un enregistrement comme <code>"? extends ..."</code> ou <code>"? super ..."</code> est appelé un caractère générique ou un caractère générique, avec une limite supérieure ( <code>extends</code> ) ou une limite inférieure ( <code>super</code> ). <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> peut contenir des objets dont la classe est <code>Number</code> ou hérite de <code>Number</code> . <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> peut contenir des objets dont la classe est <code>Number</code> ou dont <code>Number</code> est un héritier (supertype from <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  étend <i>B</i> - caractère générique avec limite supérieure <br>  super <i>B</i> - caractère générique avec une borne inférieure <br>  où <i>B</i> - représente la frontière <br><br>  Un enregistrement de la forme T <sub>2</sub> &lt;= T <sub>1</sub> signifie que l'ensemble des types décrits par T <sub>2</sub> est un sous-ensemble de l'ensemble des types décrits par T <sub>1</sub> <br><br>  c'est-à-dire <br>  Numéro &lt;=?  étend l'objet <br>  ?  étend Number &lt;=?  étend l'objet <br>  et <br>  ?  super objet &lt;=?  super numéro <br><br></td></tr></tbody></table><br>  <i>Plus d'interprétation mathématique du sujet</i> <br><br>  Une paire de tâches pour tester les connaissances: <br><br>  1. Pourquoi l'erreur de compilation dans l'exemple ci-dessous?  Quelle valeur puis-je ajouter à la liste des <code>nums</code> ? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  Le conteneur doit-il être déclaré avec un caractère générique <code>? extends</code>  <code>? extends</code> , vous ne pouvez lire que les valeurs.  Rien ne peut être ajouté à la liste sauf <code>null</code> .  Pour ajouter un objet à la liste, nous avons besoin d'un autre type de caractère générique - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. Pourquoi ne puis-je pas obtenir un article de la liste ci-dessous? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  Vous ne pouvez pas lire un élément d'un conteneur avec un caractère générique <code>? super</code>  <code>? super</code> , sauf pour un objet de classe <code>Object</code> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  Le principe Get and Put ou PECS (le producteur étend Consumer Super) </h3><br>  La fonctionnalité générique avec des limites supérieures et inférieures offre des fonctionnalités supplémentaires liées à l'utilisation sûre des types.  Vous ne pouvez lire qu'à partir d'un type de variable, seulement écrire à un autre (l'exception est la possibilité d'écrire <code>null</code> pour <code>extends</code> et de lire <code>Object</code> pour <code>super</code> ).  Pour qu'il soit plus facile de se rappeler quand utiliser quel caractère générique, il existe le principe PECS - Producer Extends Consumer Super. <br><br><ul><li>  Si nous avons déclaré un <i>caractère générique avec extend</i> , alors c'est <i>producteur</i> .  Il "produit" seulement, fournit un élément du contenant et n'accepte rien. <br></li><li>  Si nous avons annoncé un <i>caractère générique avec super</i> , alors c'est le <i>consommateur</i> .  Il accepte seulement, mais ne peut rien fournir. <br></li></ul><br>  Envisagez d'utiliser Wildcard et le principe PECS en utilisant la méthode de copie dans la classe java.util.Collections comme exemple. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  La méthode copie les éléments de la liste <code>src</code> origine dans la liste <code>dest</code> .  <code>src</code> - déclaré avec caractère générique <code>? extends</code>  <code>? extends</code> et est le producteur, et <code>dest</code> est déclaré avec un caractère générique <code>? super</code>  <code>? super</code> et est un consommateur.  Étant donné la covariance et la contravariance des caractères génériques, vous pouvez copier des éléments de la liste des <code>nums</code> vers la liste des <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Si nous confondons les paramètres de la méthode de copie par erreur et essayons de copier de la liste <code>nums</code> vers la liste <code>ints</code> , le compilateur ne nous permettra pas de faire ceci: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; et types Raw </h3><br>  Vous trouverez ci-dessous un caractère générique avec un caractère générique illimité.  Nous venons de mettre <code>&lt;?&gt;</code> , Sans les mots <code>extends</code> clés <code>super</code> ou <code>extends</code> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  En fait, un tel caractère générique "illimité" est toujours limité, vu d'en haut.  <code>Collection&lt;?&gt;</code> Est également un caractère générique, comme " <code>? extends Object</code> ".  Un enregistrement du formulaire <code>Collection&lt;?&gt;</code> Équivaut à <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , ce qui signifie que la collection peut contenir des objets de n'importe quelle classe, car toutes les classes en Java héritent d' <code>Object</code> - donc la substitution est appelée illimitée. <br><br>  Si nous omettons l'indication de type, par exemple, comme ici: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  puis ils disent que <code>ArrayList</code> est le type <code>Raw</code> de la <i>ArrayList</i> paramétrée <i>&lt;T&gt;</i> .  En utilisant les types Raw, nous retournons à l'ère des génériques et abandonnons consciemment toutes les fonctionnalités inhérentes aux types paramétrés. <br><br>  Si nous essayons d'appeler une méthode paramétrée sur le type Raw, le compilateur nous donnera un avertissement «Appel non vérifié».  Si nous essayons d'assigner une référence à un type Raw paramétré à un type, le compilateur donnera un avertissement «Affectation non vérifiée».  Ignorer ces avertissements, comme nous le verrons plus loin, peut entraîner des erreurs lors de l'exécution de notre application. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Capture de caractères génériques </h3><br>  Essayons maintenant d'implémenter une méthode qui permute les éléments d'une liste dans l'ordre inverse. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Une erreur de compilation s'est produite car la méthode <code>reverse</code> prend une liste avec un caractère générique illimité <code>&lt;?&gt;</code> Comme argument. <br>  <code>&lt;?&gt;</code> signifie la même chose que <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Par conséquent, selon le principe PECS, la <code>list</code> est <code>producer</code> .  Et le <code>producer</code> ne produit que des éléments.  Et nous dans la boucle <code>for</code> appelons la méthode <code>set()</code> , c'est-à-dire  essayer d'écrire dans la <code>list</code> .  Et nous nous reposons donc sur la protection Java, qui ne nous permet pas de définir une valeur par index. <br><br>  Que faire  Le modèle de <code>Wildcard Capture</code> nous aidera.  Ici, nous créons une méthode générique <code>rev</code> .  Il est déclaré avec une variable de type <code>T</code>  Cette méthode accepte une liste de types <code>T</code> , et nous pouvons faire un ensemble. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Maintenant, tout va compiler avec nous.  La capture générique a été capturée ici.  Lorsque la méthode <code>reverse(List&lt;?&gt; list)</code> est appelée <code>reverse(List&lt;?&gt; list)</code> , une liste de certains objets (par exemple, des chaînes ou des entiers) est passée en argument.  Si nous pouvons capturer le type de ces objets et l'affecter à une variable de type <code>X</code> , alors nous pouvons conclure que <code>T</code> est <code>X</code> <br><br>  Vous pouvez en savoir plus sur <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Conclusion </h3><br>  Si vous devez lire à partir du conteneur, utilisez un caractère générique avec la bordure supérieure " <code>? extends</code> ".  Si vous devez écrire dans le conteneur, utilisez un caractère générique avec une bordure inférieure de " <code>? super</code> ".  N'utilisez pas de caractères génériques si vous devez enregistrer et lire. <br><br>  N'utilisez pas de types <code>Raw</code> !  Si l'argument type n'est pas défini, utilisez le caractère générique <code>&lt;?&gt;</code> . <br><br><h2>  Variables de type </h2><br>  Lorsque nous écrivons l'identifiant entre crochets, par exemple, <code>&lt;T&gt;</code> ou <code>&lt;E&gt;</code> lors de la déclaration d'une classe ou d'une méthode, nous créons <i>une variable de type</i> .  Une variable de type est un identifiant non qualifié qui peut être utilisé comme type dans le corps d'une classe ou d'une méthode.  Une variable de type peut être délimitée ci-dessus. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  Dans cet exemple, l'expression <code>T extends Comparable&lt;T&gt;</code> définit <code>T</code> (une variable de type) délimitée ci-dessus par le type <code>Comparable&lt;T&gt;</code> .  Contrairement aux caractères génériques, les variables de type ne peuvent être limitées qu'en haut ( <code>extends</code> uniquement).  Impossible d'écrire <code>super</code> .  De plus, dans cet exemple, <code>T</code> dépend de lui-même, il est appelé <code>recursive bound</code> - une frontière récursive. <br><br>  Voici un autre exemple de la classe Enum: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Ici, la classe Enum est paramétrée par le type E, qui est un sous-type d' <code>Enum&lt;E&gt;</code> . <br><br><h3>  Limites multiples </h3><br>  <code>Multiple Bounds</code> multiples - contraintes multiples.  Il est écrit par le caractère " <code>&amp;</code> ", c'est-à-dire que nous disons que le type représenté par une variable de type <code>T</code> doit être limité par le haut par la classe <code>Object</code> et l'interface <code>Comparable</code> . <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> enregistrement <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> forme le type d'intersection <code>Multiple Bounds</code> .  La première limitation - dans ce cas, <code>Object</code> - est utilisée pour l' <code>erasure</code> , le processus de remplacement des types.  Il est exécuté par le compilateur au stade de la compilation. <br><br><h3>  Conclusion </h3><br>  Une variable de type ne peut être limitée qu'au-dessus d'un ou de plusieurs types.  Dans le cas de contraintes multiples, la bordure gauche (la première contrainte) est utilisée dans le processus d'écrasement (Type Erasure). <br><br><h2>  Effacement du type </h2><br>  L'effacement de type est un mappage de types (incluant éventuellement des types paramétrés et des variables de type) avec des types qui ne sont jamais des types paramétrés ou des types de variables.  Nous écrivons le brassage de type <code>T</code> comme <code>|T|</code>  . <br><br>  L'affichage de la purée est défini comme suit: <br><ul><li>  Écraser le type paramétré <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; est |  <i>G</i> | </li><li>  Écraser un <i>TC de</i> type imbriqué est |  <i>T</i> |.  <i>C</i> </li><li>  Écraser le type de tableau <i>T []</i> est |  <i>T</i> | [] </li><li>  Écraser une variable de type, c'est écraser sa bordure gauche </li><li>  Écraser tout autre type est ce type lui-même </li></ul><br><br>  Pendant l'exécution de Type Erasure (type mashing), le compilateur effectue les actions suivantes: <br><ul><li>  ajoute la coulée de caractères pour assurer la sécurité des caractères si nécessaire </li><li>  génère des méthodes Bridge pour maintenir le polymorphisme </li></ul><br><br><table><tbody><tr><td>  <b>T (Type)</b> <br></td><td>  <b>| T |</b>  <b>(Type de purée)</b> <br></td></tr><tr><td>  <i>Liste &lt;entier&gt;, liste &lt;chaîne&gt;, liste &lt;liste &lt;chaîne &gt;&gt;</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>Liste &lt;entier&gt; []</i> <br></td><td>  <i>Liste []</i> <br></td></tr><tr><td>  <i>Liste</i> <br></td><td>  <i>Liste</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Entier</i> <br></td><td>  <i>Entier</i> <br></td></tr><tr><td>  <i>&lt;T étend Comparable &lt;T&gt;&gt;</i> <br></td><td>  <i>Comparable</i> <br></td></tr><tr><td>  <i>&lt;T étend Objet &amp; Comparable &lt;?</i>  <i>super T &gt;&gt;</i> <br></td><td>  <i>Objet</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Ce tableau montre à quoi les différents types se transforment pendant le processus de brassage, Type Erasure. <br><br>  Dans la capture d'écran ci-dessous sont deux exemples du programme: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  La différence entre les deux est qu'une erreur de compilation se produit à gauche et à droite, tout se compile sans erreur.  Pourquoi? <br><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  En Java, deux méthodes différentes ne peuvent pas avoir la même signature.  Dans le processus d'effacement de type, le compilateur ajoutera la méthode bridge <code>public int compareTo(Object o)</code> .  Mais la classe contient déjà une méthode avec une telle signature qu'elle provoquera une erreur lors de la compilation. <br><br>  Compilez la classe Name en supprimant la <code>compareTo(Object o)</code> et examinez le bytecode résultant à l'aide de javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Nous voyons que la classe contient une méthode <code>int compareTo(java.lang.Object)</code> , bien que nous l'avons supprimée du code source.  Il s'agit de la méthode de pontage ajoutée par le compilateur. <br></div></div><br><br><h3>  Types réifiables </h3><br>  En Java, nous disons qu'un type est <code>reifiable</code> si ses informations sont entièrement accessibles au moment de l'exécution.  Les types réifiables incluent: <br><ul><li>  Types primitifs ( <i>int</i> , <i>long</i> , <i>booléen</i> ) </li><li>  Types non paramétrés (non génériques) ( <i>chaîne</i> , <i>entier</i> ) </li><li>  Types paramétrés dont les paramètres sont représentés comme des caractères génériques non limités (caractères génériques illimités) ( <i>Liste &lt;?&gt;</i> , <i>Collection &lt;?&gt;</i> ) </li><li>  Types <i>bruts</i> (non formés) ( <i>List</i> , <i>ArrayList</i> ) </li><li>  Tableaux dont les composants sont des types réifiables ( <i>int []</i> , <i>Number []</i> , <i>List &lt;?&gt; []</i> , <i>List [</i> ) </li></ul><br><br>  Pourquoi des informations sur certains types sont-elles disponibles mais pas sur d'autres?  Le fait est qu'en raison du processus d'écrasement des types par le compilateur, des informations sur certains types peuvent être perdues.  S'il est perdu, ce type ne sera plus réifiable.  Autrement dit, il n'est pas disponible au moment de l'exécution.  Si disponibles - respectivement, réifiables. <br><br>  La décision de ne pas rendre tous les types génériques disponibles au moment de l'exécution est l'une des décisions de conception les plus importantes et les plus conflictuelles du système de types Java.  Ceci est fait, tout d'abord, pour la compatibilité avec le code existant.  J'ai dû payer pour la compatibilité de la migration - l'accessibilité complète d'un système de types génériques au moment de l'exécution n'est pas possible. <br><br>  Quels types ne sont pas réifiables: <br><ul><li>  Variable de type ( <i>T</i> ) </li><li>  Type paramétré avec le type de paramètre spécifié ( <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>List &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Un type paramétré avec la limite supérieure ou inférieure spécifiée ( <i>List &lt;? Extends Number&gt;, Comparable &lt;? Super String&gt;</i> ).  Mais voici une réserve: <i>Liste &lt;?</i>  <i>étend Object&gt;</i> - <b>non</b> réifiable, mais <i>List &lt;?&gt;</i> - réifiable </li></ul><br><br>  Et encore une tâche.  Pourquoi dans l'exemple ci-dessous ne peut pas créer une exception paramétrée? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  Chaque expression catch dans try-catch vérifie le type de l'exception reçue pendant l'exécution du programme (ce qui équivaut à instanceof), respectivement, le type doit être réifiable.  Par conséquent, Throwable et ses sous-types ne peuvent pas être paramétrés. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Avertissements non vérifiés </h3><br>  La compilation de notre application peut produire ce que l'on appelle un avertissement <code>Unchecked Warning</code> - un avertissement indiquant que le compilateur n'a pas pu déterminer correctement le niveau de sécurité d'utilisation de nos types.  Ce n'est pas une erreur, mais un avertissement, vous pouvez donc l'ignorer.  Mais il est conseillé de tout réparer afin d'éviter des problèmes à l'avenir. <br><br><h3>  Pollution en tas </h3><br>  Comme nous l'avons mentionné précédemment, l'attribution d'une référence à un type Raw à une variable d'un type paramétré conduit à l'avertissement «Affectation non vérifiée».  Si nous l'ignorons, une situation appelée « <code>Heap Pollution</code> » (pollution en tas) est possible.  Voici un exemple: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  Sur la ligne (1), le compilateur avertit de "Affectation non vérifiée". <br><br>  Nous devons donner un autre exemple de «pollution en tas» - lorsque nous utilisons des objets paramétrés.  L'extrait de code ci-dessous montre clairement qu'il n'est pas autorisé d'utiliser des types paramétrés comme arguments d'une méthode utilisant <code>Varargs</code> .  Dans ce cas, le paramètre de méthode m est <code>List&lt;String&gt;…</code> , i.e.  en fait, un tableau d'éléments de type <code>List&lt;String&gt;</code> .  Étant donné la règle d'affichage des types lors du <code>stringLists</code> , le type <code>stringLists</code> se transforme en un tableau de listes brutes ( <code>List[]</code> ), c'est-à-dire  l'affectation peut être effectuée <code>Object[] array = stringLists;</code>  puis écrivez dans un <code>array</code> un objet autre que la liste des chaînes (1), qui <code>ClassCastException</code> dans la chaîne (2). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Prenons un autre exemple: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java permet l'affectation en ligne (1).  Cela est nécessaire pour la compatibilité descendante.  Mais si nous essayons d'exécuter la méthode <code>add</code> dans la ligne (2), nous obtenons un avertissement d' <code>Unchecked call</code> - le compilateur nous avertit d'une erreur possible.  En fait, nous essayons d'ajouter un entier à la liste des chaînes. <br><br><h3>  La réflexion </h3><br>  Bien que, lors de la compilation, les types paramétrés subissent une procédure d'effacement de type, nous pouvons obtenir des informations à l'aide de Reflection. <br><br><ul><li>  Tous réifiables sont disponibles via le mécanisme de réflexion. <br></li><li>  Des informations sur le type de champs de classe, les paramètres de méthode et les valeurs renvoyées par ceux-ci sont disponibles via Reflection. <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3>  Conclusion </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    « »      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     « ».     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   – <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   —   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> —    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    —     .        JDK 8 —        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   –    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    («») ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      «two». <br><br>   -    JDK1.7 –    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     «one». <code>Checkcast</code> –    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Conclusion </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416413/">https://habr.com/ru/post/fr416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416403/index.html">Recueil Fintech: attaque contre la banque PIR, le Service fédéral des impôts et les taxes de transfert de carte à carte, ainsi que certaines chaînes de blocs et crypto-monnaies</a></li>
<li><a href="../fr416405/index.html">Programmes de licence en partenariat avec Yandex</a></li>
<li><a href="../fr416407/index.html">Économiser du trafic grâce au renifleur de Mikrotik</a></li>
<li><a href="../fr416409/index.html">5 erreurs courantes dans l'élaboration de stratégies et les moyens de les gérer</a></li>
<li><a href="../fr416411/index.html">Racontez des histoires avec des données</a></li>
<li><a href="../fr416415/index.html">Nous déplaçons tout dans l'ensemble de test Vivaldi 1.16.1230.3</a></li>
<li><a href="../fr416417/index.html">"Heavenly River" - La Chine créera une pluie artificielle d'une puissance sans précédent</a></li>
<li><a href="../fr416419/index.html">Générateur de grottes bidimensionnel aléatoire</a></li>
<li><a href="../fr416421/index.html">Une promenade dans la voie des stands, ou comment les technologies IaaS aident les équipes de course</a></li>
<li><a href="../fr416423/index.html">Comment les Russes ont pensé au processeur américain, ou un examen du DVR AdvoCam-FD8 Gold-II (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>