<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ”§ ğŸ‘©ğŸ½â€ğŸ”§ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ» Things to Remember untuk Programmer Beralih ke Python ğŸ¦ ğŸ‘©ğŸ½â€ğŸ’¼ ğŸ•¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu ketika, di masa mahasiswa saya, saya digigit oleh python, meskipun masa inkubasi tertunda dan ternyata saya menjadi programmer mutiara. 


 Namu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Things to Remember untuk Programmer Beralih ke Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426277/"><p>  Suatu ketika, di masa mahasiswa saya, saya digigit oleh python, meskipun masa inkubasi tertunda dan ternyata saya menjadi programmer mutiara. </p><br><p>  Namun, pada suatu titik, mutiara itu kehabisan tenaga dan saya memutuskan untuk mengambil python, pada awalnya saya hanya melakukan sesuatu dan mencari tahu apa yang diperlukan untuk tugas ini, dan kemudian saya menyadari bahwa saya memerlukan semacam pengetahuan sistematis dan membaca beberapa buku: </p><br><ul><li>  Bill Lyubanovich â€œPython Sederhana.  Gaya pemrograman modern â€ </li><li>  Dan Bader "Python Murni.  Seluk-beluk pemrograman untuk pro Â» </li><li>  Brett Slatkin "Rahasia Python: 59 Tips untuk Menulis Kode Efektif" </li></ul><br><p> Yang menurut saya cukup cocok untuk memahami seluk beluk dasar bahasa, meskipun saya tidak ingat menyebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>slot</strong></a> di dalamnya, tetapi saya tidak yakin bahwa ini adalah fitur yang sangat diperlukan - jika saya menekannya dari memori, maka kemungkinan besar metode ini tidak akan cukup, tetapi tentu saja metode ini tidak akan cukup, tetapi tentu saja itu semua tergantung situasi. </p><br><p>  Sebagai hasilnya, saya telah mengumpulkan beberapa catatan tentang fitur python, yang menurut saya, dapat berguna bagi seseorang yang ingin bermigrasi ke sana dari bahasa lain. </p><a name="habracut"></a><br><p> Saya perhatikan bahwa selama wawancara pada python cukup sering mereka mengajukan pertanyaan tentang hal-hal yang tidak terkait dengan pengembangan nyata, seperti apa yang mungkin menjadi kunci dari kamus (atau apa artinya <code>x = yield y</code> ), well dudes, dalam kehidupan nyata, kuncinya mungkin hanya angka atau string, dalam kasus unik saat ini tidak begitu, Anda dapat membaca dokumentasi dan mencari tahu mengapa bertanya ini?  Untuk menemukan apa yang tidak diketahui orang yang diwawancarai?  Jadi pada akhirnya, semua orang akan mengingat jawaban untuk pertanyaan khusus ini dan itu akan berhenti berfungsi. </p><br><p>  Saya menganggap versi python lebih tinggi dari 3,5 relevan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah</a> waktunya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk melupakan</a> python kedua untuk waktu yang lama) sejak itu  ini adalah versi dalam debian stabil, yang berarti di semua tempat lain ada versi yang lebih baru) </p><br><p>  Karena saya bukan guru python sama sekali, saya berharap mereka benar di komentar jika saya tiba-tiba membeku semacam kebodohan. </p><br><h2 id="tipizaciya">  Mengetik </h2><br><p>  Python adalah bahasa yang diketik secara dinamis, mis.  itu memeriksa pencocokan jenis saat runtime, misalnya: </p><br><pre> <code class="plaintext hljs">cat type.py a=5 b='5' print(a+b)</code> </pre> <br><p>  melakukan: </p><br><pre> <code class="plaintext hljs">python3 type.py ... TypeError: unsupported operand type(s) for +: 'int' and 'str'</code> </pre> <br><p>  Namun, jika proyek Anda telah matang dengan kebutuhan untuk mengetik statis, maka python memberikan kesempatan seperti itu dengan menggunakan penganalisa statis <code>mypy</code> : </p><br><pre> <code class="plaintext hljs">mypy type.py type.py:3: error: Unsupported operand types for + ("int" and "str")</code> </pre> <br><p>  Benar, tidak semua kesalahan ditangkap dengan cara ini: </p><br><pre> <code class="plaintext hljs">cat type2.py def greeting(name): return 'Hello ' + name greeting(5)</code> </pre> <br><p>  mypy tidak akan bersumpah di sini, tetapi kesalahan akan terjadi selama eksekusi, sehingga versi python saat ini mendukung sintaks khusus untuk menentukan jenis argumen fungsi: </p><br><pre> <code class="plaintext hljs">cat type3.py def greeting(name: str) -&gt; str: return 'Hello ' + name greeting(5)</code> </pre> <br><p>  dan sekarang: </p><br><pre> <code class="plaintext hljs">mypy type3.py type3.py:4: error: Argument 1 to "greeting" has incompatible type "int"; expected "str"</code> </pre> <br><h2 id="peremennye-i-dannye">  Variabel dan Data </h2><br><p>  Variabel dalam python tidak menyimpan data, tetapi hanya merujuk padanya, dan data bisa berubah-ubah (bisa berubah) dan tidak berubah (tidak berubah). <br>  Ini mengarah ke perilaku yang berbeda tergantung pada jenis data dalam situasi yang hampir identik, misalnya, kode seperti itu: </p><br><pre> <code class="plaintext hljs">x = 1 y = x x = 2 print(y)</code> </pre> <br><p>  mengarah pada fakta bahwa variabel <code>x</code> dan <code>y</code> merujuk pada data yang berbeda, dan ini: </p><br><pre> <code class="plaintext hljs">x = [1, 2, 3] y = x x[0] = 7 print(y)</code> </pre> <br><p>  tidak, <code>x</code> dan <code>y</code> tetap tautan ke daftar yang sama (meskipun seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disebutkan dalam komentar,</a> contohnya tidak terlalu berhasil, tapi saya belum menemukan yang lebih baik) bahwa omong-omong dengan python Anda dapat memeriksa dengan operator <code>is</code> (saya yakin bahwa pencipta Jawa telah kehilangan tidur yang baik selamanya dari rasa malu ketika saya mengetahui tentang operator ini di python). </p><br><p>  Meskipun baris terlihat seperti daftar, mereka adalah tipe data yang tidak dapat diubah, ini berarti bahwa string itu sendiri tidak dapat diubah, Anda hanya dapat membuat yang baru, tetapi Anda dapat menetapkan nilai yang berbeda untuk variabel, meskipun data asli tidak akan berubah: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; mystr = 'sss' &gt;&gt;&gt; newstr = mystr #       &gt;&gt;&gt; mystr[0] = 'a' ... TypeError: 'str' object does not support item assignment &gt;&gt;&gt; mystr = 'ssa' #    &gt;&gt;&gt; newstr #         'sss'</code> </pre> <br><p>  Berbicara tentang string, karena kekebalannya, merangkai daftar string yang sangat besar dengan menambahkan atau menambahkan dalam satu lingkaran mungkin tidak terlalu efektif (tergantung pada implementasi dalam kompiler / versi tertentu), biasanya disarankan untuk menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabungan</a> untuk kasus-kasus seperti itu, yang berperilaku sedikit tidak terduga: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; str_list = ['ss', 'dd', 'gg'] &gt;&gt;&gt; 'XXX'.join(str_list) 'ssXXXddXXXgg' &gt;&gt;&gt; str = 'hello' &gt;&gt;&gt; 'XXX'.join(str) 'hXXXeXXXlXXXlXXXo'</code> </pre> <br><p>  Pertama, garis di mana metode ini disebut menjadi pemisah, dan bukan awal dari garis baru seperti yang mungkin dipikirkan orang, dan kedua, Anda perlu melewati daftar (objek yang dapat diubah), dan bukan garis yang terpisah, karena juga merupakan objek yang dapat diubah dan akan disimbolkan . </p><br><p>  Karena variabel adalah tautan, sangat normal untuk ingin membuat salinan objek agar tidak merusak objek asli, tetapi ada jebakan - fungsi salin hanya menyalin satu tingkat, yang jelas bukan apa yang diharapkan dari fungsi dengan nama ini, jadi gunakan <code>deepcopy</code> . </p><br><p>  Masalah serupa dengan penyalinan dapat terjadi ketika koleksi dikalikan dengan skalar, seperti dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="oblast-vidimosti">  Lingkup </h2><br><p>  Topik ruang lingkup mungkin layak artikel terpisah, tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban yang bagus untuk SO</a> . <br>  Singkatnya, ruang lingkupnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">leksikal</a> dan ada enam area visibilitas - variabel dalam tubuh fungsi, penutupan, dalam modul, di tubuh kelas, fungsi python bawaan dan variabel di dalam daftar dan inklusi lainnya. <br>  Ada kehalusan - variabel default dapat dibaca dalam ruang nama bersarang leksikal, tetapi modifikasi memerlukan penggunaan kata kunci khusus <code>nonlocal</code> dan <code>global</code> untuk memodifikasi variabel satu tingkat lebih tinggi atau visibilitas global, masing-masing. </p><br><p>  Misalnya, kode seperti ini: </p><br><pre> <code class="plaintext hljs">x = 7 print(id(x)) def func(): print(id(x)) return x print(func())</code> </pre> <br><p>  Ini berfungsi dengan satu variabel global, dan yang ini: </p><br><pre> <code class="plaintext hljs">x = 7 print(id(x)) def func(): x = 1 print(id(x)) return x print(func()) print(x)</code> </pre> <br><p>  sudah memunculkan yang lokal. <br>  Dari sudut pandang saya, ini tidak terlalu baik, pada prinsipnya, setiap penggunaan variabel non-lokal dalam suatu fungsi adalah bagian dari antarmuka publik dari fungsi, tanda tangannya, yang berarti harus dinyatakan secara eksplisit dan terlihat pada awal fungsi.  Juga, kata kunci tidak terlalu informatif - <code>global</code> terdengar seperti definisi fungsi global, tetapi sebenarnya <code>use global</code> . </p><br><p>  Dalam python tidak ada titik masuk wajib dari mana program dimulai, seperti yang dilakukan dalam banyak bahasa, hanya semua yang ditulis pada tingkat modul dieksekusi secara berurutan, namun, karena variabel pada tingkat modul adalah variabel global, dari sudut pandang saya, itu harus menjadi praktik yang baik menjejalkan kode utama ke fungsi <code>main()</code> , diikuti dengan panggilannya di akhir file: </p><br><pre> <code class="plaintext hljs">if __name__ == '__main__': main()</code> </pre> <br><p>  kondisi ini akan berfungsi jika file tersebut disebut sebagai skrip dan tidak diimpor sebagai modul. </p><br><h2 id="argumenty-funkciy">  Argumen fungsi </h2><br><p>  Python menyediakan peluang yang cukup bagus untuk mendefinisikan argumen fungsi - posisional, argumen bernama dan kombinasinya. </p><br><p>  Tetapi Anda perlu memahami bagaimana argumen disahkan - karena  dalam python, semua variabel adalah tautan ke data, maka Anda dapat menebak bahwa transfer dilakukan dengan referensi, tetapi ada kekhasan - tautan itu sendiri dilewatkan oleh nilai i.e.  Anda dapat mengubah nilai yang dapat diubah dengan referensi: </p><br><pre> <code class="plaintext hljs">def add_element(mylist): mylist.append(3) mylist = [1,2] add_element(mylist) print(mylist)</code> </pre> <br><p>  melakukan: </p><br><pre> <code class="plaintext hljs">python3 arg_modify.py [1, 2, 3]</code> </pre> <br><p>  namun, Anda tidak dapat menimpa tautan asli dalam suatu fungsi: </p><br><pre> <code class="plaintext hljs">def try_del(mylist): mylist = [] return mylist mylist = [1,2] try_del(mylist) print(mylist)</code> </pre> <br><p>  tautan sumber masih hidup dan berfungsi: </p><br><pre> <code class="plaintext hljs">python3 arg_kill.py [1, 2]</code> </pre> <br><p>  Anda juga dapat mengatur nilai default untuk argumen, tetapi ada satu hal yang tidak jelas untuk diingat: nilai default dihitung sekali ketika mendefinisikan fungsi, ini tidak membuat masalah jika Anda melewatkan data yang tidak berubah sebagai nilai default, dan jika Anda lulus data variabel atau nilai dinamis, hasilnya akan sedikit tidak terduga: </p><br><p>  data yang bisa diubah: </p><br><pre> <code class="plaintext hljs">cat arg_list.py def func(arg = []): arg.append('x') return arg print(func()) print(func()) print(func())</code> </pre> <br><p>  hasil: </p><br><pre> <code class="plaintext hljs">python3 arg_list.py ['x'] ['x', 'x'] ['x', 'x', 'x']</code> </pre> <br><p>  nilai dinamis: </p><br><pre> <code class="plaintext hljs">cat arg_now.py from datetime import datetime def func(arg = datetime.now()): return arg print(func()) print(func()) print(func())</code> </pre> <br><p>  kami mendapatkan: </p><br><pre> <code class="plaintext hljs">python3 arg_now.py 2018-09-28 10:28:40.771879 2018-09-28 10:28:40.771879 2018-09-28 10:28:40.771879</code> </pre> <br><h2 id="oop">  OOP </h2><br><p>  OOP dengan python telah dilakukan dengan sangat menarik (beberapa properti sepadan) dan ini adalah topik yang besar, tetapi sapiens yang akrab dengan OOP mungkin juga google segalanya (atau menemukannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub</a> ), jadi dia tidak perlu mengulanginya, meskipun perlu dikatakan bahwa python harus sedikit filosofi yang berbeda - adalah bahwa programmer cerdas mesin, dan bukan merupakan ancaman (UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih</a> ), sehingga default python tidak biasa untuk bahasa lain akses pengubah: metode swasta dilaksanakan dengan menambahkan garis bawah ganda (yang mengubah runtime dari nama metode tidak OAPC  kesempatan untuk menggunakannya), dan dilindungi satu garis bawah (yang tidak melakukan apa-apa benang, itu hanya konvensi penamaan). <br>  Mereka yang kehilangan fungsi biasa dapat mencari upaya untuk membawa peluang seperti itu ke python, beberapa opsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python-access</a> ) di-google-kan oleh saya, tetapi saya tidak menguji atau mempelajarinya. </p><br><p>  Satu-satunya minus dari kelas standar adalah kode boilerplate dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode Dunder</a> , saya pribadi suka perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">attrs</a> , itu jauh lebih pythonic. <br>  Perlu disebutkan bahwa karena dalam Python semua objek, termasuk fungsi dan kelas, kelas dapat dibuat secara dinamis (tanpa menggunakan <code>eval</code> ) oleh fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe</a> . <br>  Penting juga membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metaclasses</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang Habr</a> ) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskriptor</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Habr</a> ). <br>  Sebuah kekhasan yang patut diingat adalah bahwa atribut kelas dan objek bukan hal yang sama, dalam hal atribut abadi ini tidak menimbulkan masalah karena atributnya adalah "membayangi" - atribut objek dengan nama yang sama dibuat secara otomatis, tetapi dalam kasus atribut yang dapat diubah, Anda dapat tidak mengerti apa yang diharapkan: </p><br><pre> <code class="plaintext hljs">cat class_attr.py class MyClass: storage = [7,] def __init__(self, number): self.number = number obj = MyClass(1) obj2 = MyClass(2) obj.number = 5 obj.storage.append(8) print(obj2.storage, obj2.number)</code> </pre> <br><p>  kami mendapatkan: </p><br><pre> <code class="plaintext hljs">python3 class_attr.py [7, 8] 2</code> </pre> <br><p>  seperti yang Anda lihat - mereka mengubah <code>obj</code> , dan <code>storage</code> berubah di <code>obj2</code> juga.  atribut ini (tidak seperti <code>number</code> ) bukan milik instance, tetapi ke kelas. </p><br><h2 id="konstanty">  Konstanta </h2><br><p>  Seperti dalam kasus pengubah akses, python tidak mencoba membatasi pengembang, oleh karena itu, tidak mungkin untuk mendefinisikan variabel skalar yang dilindungi dari modifikasi dengan cara standar, hanya ada kesepakatan bahwa variabel dengan nama dalam huruf besar harus dianggap konstanta. <br>  Python, di sisi lain, memiliki struktur data yang tidak dapat diubah seperti tuple, jadi jika Anda ingin membuat beberapa struktur global seperti konfigurasi yang tidak dapat diubah dan tidak ingin dependensi tambahan, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">namupuple</a> adalah pilihan yang baik, walaupun itu akan memerlukan sedikit usaha lebih untuk menggambarkan tipe, oleh karena itu Saya suka implementasi alternatif dari struktur yang tidak dapat diubah dengan notasi titik - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Box</a> (lihat parameter frozen_box). <br>  Nah, jika Anda ingin konstanta skalar, maka Anda dapat menerapkan kontrol akses pada tahap "kompilasi" yaitu  memeriksa melalui mypy, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail</a> . </p><br><h2 id="sort-vs-sorted">  .sort () vs diurutkan () </h2><br><p>  Ada dua cara untuk mengurutkan daftar dengan python.  Yang pertama adalah metode <code>.sort()</code> yang mengubah daftar asli dan tidak mengembalikan apa pun (Tidak ada) yaitu  tidak bisa melakukan ini: </p><br><pre> <code class="plaintext hljs">my_list = my_list.sort()</code> </pre> <br><p>  Yang kedua adalah fungsi <code>sorted()</code> , yang memunculkan daftar baru dan dapat bekerja dengan semua objek yang dapat diulang.  Siapa yang mau info lebih lanjut harus mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SO</a> . </p><br><h2 id="standartnaya-biblioteka">  Perpustakaan standar </h2><br><p>  Biasanya, pustaka python standar mencakup solusi luar biasa untuk masalah umum, tetapi layak untuk dijadikan kritis, karena ada cukup keanehan.  Benar, itu juga terjadi bahwa apa yang tampak aneh pada pandangan pertama ternyata menjadi solusi terbaik, Anda hanya perlu mengetahui semua kondisi (lihat di bawah untuk kisaran), tetapi masih ada keanehan. </p><br><p>  Sebagai contoh, modul unit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unittest</a> yang datang dengan kit tidak ada hubungannya dengan python dan bernada Jawa, oleh karena itu, sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis python mengatakan</a> : "Semua orang menggunakan py.test ...".  Meskipun cukup menarik, meskipun tidak selalu cocok, modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">doctest</a> hadir sebagai standar. </p><br><p>  Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urllib yang disediakan</a> tidak memiliki antarmuka yang indah seperti modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> pihak ketiga. </p><br><p>  Kisah yang sama dengan modul untuk parsing parameter baris perintah - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">argparse yang dibundel</a> adalah demonstrasi OOP otak, dan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docopt</a> tampaknya hanya solusi cerdas - dokumentasi mandiri!  Meskipun, menurut rumor, terlepas dari doktrin dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klik,</a> ceruk tetap. </p><br><p>  Dengan debugger juga - seperti yang saya mengerti, beberapa orang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pdb yang</a> termasuk dalam paket, ada banyak alternatif, tetapi tampaknya sebagian besar pengembang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipdb</a> , yang, dari sudut pandang saya, paling nyaman untuk digunakan melalui modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">debug</a> wrapper. <br>  Ini memungkinkan alih-alih <code>import ipdb;ipdb.set_trace()</code> hanya menulis <code>import debug</code> , itu juga menambahkan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat</a> untuk memudahkan pemeriksaan objek. </p><br><p>  Untuk mengganti modul serialisasi standar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acar</a> dibuat, omong-omong, perlu diingat bahwa modul-modul ini tidak cocok untuk bertukar data dalam sistem eksternal karena  mengembalikan objek sewenang-wenang yang diterima dari sumber yang tidak terkontrol tidak aman, untuk kasus seperti itu ada json (untuk REST) â€‹â€‹dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gRPC</a> (untuk RPC). </p><br><p>  Untuk mengganti modul pemrosesan ekspresi reguler standar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kembali</a> membuat modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regex</a> dengan segala macam barang tambahan, seperti kelas karakter ala <code>\p{Cyrillic}</code> . <br>  Ngomong-ngomong, sesuatu tidak ditemukan untuk python debugger yang menyenangkan untuk regex yang mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jelai mutiara</a> . </p><br><p>  Berikut adalah contoh lain - seseorang membuat modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">in-place-nya</a> untuk memperbaiki kelengkungan dan ketidaklengkapan API dari modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">input file</a> standar di bagian menggantikan file editing. </p><br><p>  Yah, saya sering memikirkan kasus-kasus seperti itu, karena saya bahkan telah menemukan lebih dari satu, jadi berhati-hatilah dan jangan lupa untuk melihat segala macam daftar yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luar biasa</a> berguna, saya pikir seorang ahli gizi yang baik memiliki hidung untuk mengukur rasionalitas dari solusi, ini adalah dengan cara topik untuk diskusi lain - menurut perasaan saya (tentu saja, tidak ada statistik tentang hal ini dan tampaknya tidak bisa) di dunia python tingkat spesialis di atas rata-rata, karena sering kali perangkat lunak yang baik ternyata ditulis dalam python, tulis di komentar apa pendapat Anda tentang hal ini. </p><br><h2 id="parallelizm-i-konkurentnost">  Konkurensi dan Persaingan </h2><br><p>  Python memberikan banyak peluang untuk pemrograman paralel dan kompetitif, tetapi bukan tanpa fitur. </p><br><p>  Jika Anda membutuhkan paralelisme, dan ini terjadi ketika tugas Anda membutuhkan perhitungan, maka Anda harus memperhatikan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multiprosesor</a> . </p><br><p>  Dan jika tugas Anda memiliki banyak harapan IO, maka python menyediakan banyak opsi untuk dipilih, dari utas dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gevent</a> , hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asyncio</a> . <br>  Semua opsi ini terlihat cukup cocok untuk digunakan (walaupun utas membutuhkan lebih banyak sumber daya), tetapi ada perasaan bahwa asyncio secara perlahan memeras sisanya, termasuk berkat semua jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">barang</a> seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uvloop</a> . </p><br><p>  Jika seseorang tidak memperhatikan - dengan python, utas bukan tentang paralelisme, saya tidak cukup kompeten untuk berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIL dengan baik</a> , tetapi ada cukup materi tentang topik ini, oleh karena itu tidak ada kebutuhan seperti itu, hal utama yang perlu diingat adalah bahwa utas dalam python (lebih tepatnya dalam CPython) mereka berperilaku berbeda dari bahasa pemrograman lain - mereka berjalan hanya pada satu inti, yang berarti mereka tidak cocok untuk kasus-kasus di mana Anda membutuhkan paralelisme nyata, namun, eksekusi thread berhenti ketika menunggu input / output, sehingga mereka dapat digunakan  untuk bersaing. </p><br><h2 id="inye-strannosti">  Keanehan lainnya </h2><br><p>  Dalam python, <code>a = a + b</code> tidak selalu setara dengan <code>a += b</code> : </p><br><pre> <code class="plaintext hljs">a = [1] a = a + (2,3) TypeError: can only concatenate list (not "tuple") to list a += (2,3) a [1, 2, 3]</code> </pre> <br><p>  Saya mengirimnya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SO</a> untuk detail, sampai saya menemukan waktu untuk mencari tahu mengapa demikian, dalam arti untuk alasan apa mereka melakukannya, seperti ini lagi-lagi tentang mutabilitas. </p><br><h2 id="strannosti-kotorye-ne-strannosti">  Keanehan yang bukan keanehan </h2><br><p>  Pada pandangan pertama, tampak aneh bagi saya bahwa jenis jangkauan tidak termasuk perbatasan kanan, tetapi kemudian orang yang baik hati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan kepada</a> saya untuk mengabaikan mana yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perlu saya pelajari</a> dan ternyata semuanya cukup logis. </p><br><p>  Topik besar yang terpisah adalah pembulatan (meskipun masalah ini umum untuk hampir semua bahasa pemrograman), selain menggunakan pembulatan yang Anda suka, kecuali bahwa semua orang belajar di sekolah matematika, sehingga masalah mewakili angka floating-point masih ditumpangkan di atasnya, saya merujuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> rinci. <br>  Secara kasar, alih-alih algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setengah-</a> putaran yang biasa untuk matematika sekolah, algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setengah-</a> genangan digunakan, yang mengurangi kemungkinan distorsi dalam analisis statistik dan karenanya direkomendasikan oleh standar IEEE 754. </p><br><p>  Juga, saya tidak bisa mengerti mengapa <code>-22//10=-3</code> , dan kemudian orang baik lainnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> bahwa ini pasti mengikuti dari definisi matematika itu sendiri, yang menurutnya, sisanya tidak boleh negatif, yang mengarah ke perilaku yang tidak biasa seperti itu untuk angka negatif. <br>  ACHTUNG!  Sekarang ini lagi hal yang aneh dan saya tidak mengerti apa-apa, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas</a> ini. </p><br><h2 id="otladka-regulyarnyh-vyrazheniy">  Debugging Ekspresi Reguler </h2><br><p>  Dan di sini ternyata bahwa di dunia python tidak ada alat untuk debugging ekspresi reguler yang mirip dengan modul mutiara yang sangat baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Regexp :: Debugger</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi video</a> ), tentu saja ada banyak alat online, ada beberapa jenis solusi Windows-proprietary, tetapi bagi saya bukan itu, mungkin layak menggunakan alat bilah mutiara, karena rex python tidak jauh berbeda dari bilah mutiara, saya akan menulis instruksi untuk mereka yang tidak memiliki bilah mutiara: </p><br><pre> <code class="plaintext hljs">sudo apt install cpanminus cpanm Regexp::Debugger perl -I ~/perl5/lib/perl5/ -E "use Regexp::Debugger; 'ababc' =~ /(a|b) b+ c/x"</code> </pre> <br><p>  Saya pikir bahkan orang yang tidak terbiasa dengan mutiara akan mengerti di mana perlu untuk memasukkan baris, dan di mana ekspresi reguler, <code>x</code> adalah bendera yang mirip dengan python re.VERBOSE. <br>  Tekan <code>s</code> dan melangkahi ekspresi reguler, deskripsi terperinci dari perintah yang tersedia dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><h2 id="dokumentaciya">  Dokumentasi </h2><br><p>  Ada fungsi bantuan dalam python, yang memungkinkan Anda untuk mendapatkan bantuan pada setiap fungsi yang dimuat (diambil dari docstring-nya), nama fungsi dilewatkan sebagai parameter: </p><br><pre> <code class="plaintext hljs">$ python3 &gt;&gt;&gt; help(help)</code> </pre> <br><p>  tetapi ini tidak selalu merupakan cara yang nyaman dan seringkali lebih nyaman untuk menggunakan utilitas pydoc: </p><br><pre> <code class="plaintext hljs">pydoc3 urllib.parse.urlparse</code> </pre> <br><p>  utilitas ini memungkinkan Anda untuk mencari dengan kata kunci dan bahkan memulai server lokal dengan dokumentasi html, tetapi saya belum menguji yang terakhir. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426277/">https://habr.com/ru/post/id426277/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426267/index.html">Lagu tentang bagaimana pembuatan proyek berubah menjadi neraka</a></li>
<li><a href="../id426269/index.html">Aplikasi python kivy untuk diet yang bervariasi. Dari kode hingga menerima file .apk untuk Android</a></li>
<li><a href="../id426271/index.html">Keselamatan mobil Tesla Model 3</a></li>
<li><a href="../id426273/index.html">Instal dan konfigurasikan Oracle Internet Directory untuk menyelesaikan nama database</a></li>
<li><a href="../id426275/index.html">Bagaimana kami mencari tanda-tanda kesalahan medis</a></li>
<li><a href="../id426279/index.html">Bagaimana format audio dan teknologi audio â€œberjuangâ€ dan berkembang: intisari sejarah yang besar</a></li>
<li><a href="../id426281/index.html">Pendiri Amazon, Google, Microsoft dan Facebook kehilangan lebih dari $ 30 miliar selama jatuhnya pasar saham</a></li>
<li><a href="../id426283/index.html">WeChat di India: dari peluncuran yang kuat hingga hilangnya minat sepenuhnya</a></li>
<li><a href="../id426285/index.html">Di salah satu lokakarya AvtoVAZ ditemukan sebuah peternakan untuk ditambang</a></li>
<li><a href="../id426287/index.html">Mengirim ke bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>