<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚽 👂🏿 👩🏼‍🤝‍👨🏻 Paketmanager für Kubernetes - Helm: Vergangenheit, Gegenwart, Zukunft 👨🏼‍⚕️ 👏 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Mit diesem Artikel eröffnen wir eine Reihe von Veröffentlichungen über den Paketmanager für Kubernetes, die wir aktiv in der tägliche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Paketmanager für Kubernetes - Helm: Vergangenheit, Gegenwart, Zukunft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/417079/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Mit diesem Artikel eröffnen wir eine Reihe von Veröffentlichungen über den Paketmanager für Kubernetes, die wir aktiv in der täglichen Arbeit verwenden, - Helm.</i>  <i>Der ursprüngliche Autor des Materials ist Matt Butcher, einer der Gründer des Helm-Projekts, der an Open Source-Projekten bei Microsoft arbeitet und 8 technische Bücher schreibt (insbesondere „Go in Practice“).</i>  <i>Der Artikel wird jedoch durch unsere (manchmal umfangreichen) Kommentare ergänzt und in Kürze um neue Anmerkungen zu Helm mit einem praktischeren Schwerpunkt erweitert.</i>  <i><b>UPDATE</b> (09/03/2018): Die Fortsetzung erschien - " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktische Bekanntschaft mit dem Paketmanager für Kubernetes - Helm</a> ".</i> <br><br><img src="https://habrastorage.org/webt/ff/1x/js/ff1xjsnvdlnfinirlwb-0p42tlo.png"><br><br>  Im Juni wechselte Helm vom Status des leitenden Projekts von Kubernetes zur Cloud Native Computing Foundation (CNCF).  CNCF wird zur Mutterorganisation für die besten Open-Source-Cloud-Native-Tools ihrer Art.  Daher ist es für Helm eine große Ehre, Teil einer solchen Stiftung zu werden.  Und unser erstes bedeutendes Projekt unter der Schirmherrschaft von CNCF ist wirklich groß angelegt: Wir erstellen Helm 3. <a name="habracut"></a><br><br><h2>  Eine kurze Geschichte von Helm </h2><br>  Helm erschien ursprünglich als Deis Open Source-Projekt.  Es wurde nach dem Vorbild von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homebrew</a> <i>(dem Paketmanager für macOS - <b>ca. Übersetzung</b> ) erstellt</i> . Die Aufgabe, die Helm 1 hatte, bot Benutzern die Möglichkeit, ihre ersten Workloads schnell auf Kubernetes zu installieren.  Die offizielle Ankündigung von Helm erfolgte auf der ersten KubeCon San Francisco Konferenz im Jahr 2015. <br><br>  <i><b>Hinweis</b></i>  <i><b>trans .:</b> Ab der ersten Version, die als dm (Deployment Manager) bezeichnet wurde, wurde die YAML-Syntax ausgewählt, um Kubernetes-Ressourcen zu beschreiben, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jinja-Vorlagen</a> und Python-Skripte wurden beim Schreiben von Konfigurationen unterstützt.</i> <br><br>  <i>Eine einfache Webanwendungsvorlage könnte folgendermaßen aussehen:</i> <br><br><div class="spoiler">  <b class="spoiler_title">Yaml</b> <div class="spoiler_text"><pre><code class="plaintext hljs">resources: - name: frontend type: github.com/kubernetes/application-dm-templates/common/replicatedservice:v1 properties: service_port: 80 container_port: 80 external_service: true replicas: 3 image: gcr.io/google_containers/example-guestbook-php-redis:v3 - name: redis type: github.com/kubernetes/application-dm-templates/storage/redis:v1 properties: null</code> </pre> </div></div><br>  <i>Bei der Beschreibung der Komponenten der ausgerollten Anwendung werden der Name, die verwendete Vorlage sowie die erforderlichen Parameter dieser Vorlage angegeben.</i>  <i>Im obigen Beispiel verwenden die <code>frontend</code> und <code>redis</code> Vorlagen aus dem offiziellen Repository.</i> <br><br>  <i>Bereits in dieser Version können Sie Ressourcen aus einer gemeinsamen Wissensdatenbank verwenden, eigene Vorlagen-Repositorys erstellen und aufgrund der Parameter und der Verschachtelung von Vorlagen komplexe Anwendungen erstellen.</i> <br><br>  <i>Die Helm 1-Architektur besteht aus drei Komponenten.</i>  <i>Das folgende Diagramm zeigt die Beziehung zwischen ihnen:</i> <br><br><img src="https://habrastorage.org/webt/66/f8/l_/66f8l_blo_rfzohvo1wpobchuzg.png"><br><br><ol><li>  <i><code>Manager</code> führt die Funktion eines Webservers aus (die Kommunikation mit Clients erfolgt über die REST-API), verwaltet die Bereitstellungen im Kubernetes-Cluster und wird als Data Warehouse verwendet.</i> </li><li>  <i>Die <code>expandybird</code> Komponente bringt Benutzerkonfigurationen in eine flache Form, d.h.</i>  <i>wendet Jinja-Vorlagen an und führt Python-Skripte aus.</i> </li><li>  <i>Nach Erhalt einer flachen Konfiguration führt <code>resourcifier</code> die erforderlichen Aufrufe an kubectl durch und gibt gegebenenfalls Status- und Fehlermeldungen an den <code>manager</code> .</i> </li></ol><br>  <i>Um die Funktionen der ersten Version von Helm zu verstehen, werde ich beim Befehl <code>dm</code> helfen</i> : <div class="spoiler">  <b class="spoiler_title">Hilfeausgabe von dm</b> <div class="spoiler_text"><pre> <code class="bash hljs">Usage: ./dm [&lt;flags&gt;] &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt; [(&lt;template-name&gt; | &lt;deployment-name&gt; | (&lt;configuration&gt; [&lt;import1&gt;...&lt;importN&gt;]))] Commands: expand Expands the supplied configuration(s) deploy Deploys the named template or the supplied configuration(s) list Lists the deployments <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster get Retrieves the supplied deployment manifest Lists manifests <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment or retrieves the supplied manifest <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the form (deployment[/manifest]) delete Deletes the supplied deployment update Updates a deployment using the supplied configuration(s) deployed-types Lists the types deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster deployed-instances Lists the instances of the named <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster templates Lists the templates <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry (specified with --registry) registries Lists the registries available describe Describes the named template <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry getcredential Gets the named credential used by a registry setcredential Sets a credential used by a registry createregistry Creates a registry that holds charts Flags: -apitoken string Github api token that overrides GITHUB_API_TOKEN environment variable -binary string Path to template expansion binary (default <span class="hljs-string"><span class="hljs-string">"../expandybird/expansion/expansion.py"</span></span>) -httptest.serve string <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non-empty, httptest.NewServer serves on this address and blocks -name string Name of deployment, used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deploy and update commands (defaults to template name) -password string Github password that overrides GITHUB_PASSWORD environment variable -properties string Properties to use when deploying a template (eg, --properties k1=v1,k2=v2) -regex string Regular expression to filter the templates listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a template registry -registry string Registry name (default <span class="hljs-string"><span class="hljs-string">"application-dm-templates"</span></span>) -registryfile string File containing registry specification -service string URL <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment manager (default <span class="hljs-string"><span class="hljs-string">"http://localhost:8001/api/v1/proxy/namespaces/dm/services/manager-service:manager"</span></span>) -serviceaccount string Service account file containing JWT token -stdin Reads a configuration from the standard input -timeout int Time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds to <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> response (default 20) -username string Github user name that overrides GITHUB_USERNAME environment variable --stdin requires a file name and either the file contents or a tar archive containing the named file. a tar archive may include any additional files referenced directly or indirectly by the named file.</code> </pre></div></div><br>  <i>Und jetzt zurück zum Originaltext über die Geschichte von Helm ...</i> <br><br>  Einige Monate später haben wir uns mit dem Kubernetes Deployment Manager-Team von Google zusammengetan und mit der Arbeit an Helm 2 begonnen. Ziel war es, die Verwendung von Helm durch Hinzufügen der folgenden Elemente zu vereinfachen: <br><br><ol><li>  Diagrammvorlagen <i>(„Diagramm“ - ein Analogon eines Pakets im Helm-Ökosystem - <b>ca. übersetzt</b> )</i> zur Anpassung; </li><li>  Cluster-Management für Teams; </li><li>  vollständiges Diagramm-Repository; </li><li>  stabiles und signiertes Paketformat; </li><li>  starkes Engagement für die semantische Versionierung und die Aufrechterhaltung der Abwärtskompatibilität von Version zu Version. </li></ol><br>  Um diese Ziele zu erreichen, wurde dem Helm-Ökosystem eine zweite Komponente hinzugefügt.  Es wurde zum internen Tiller-Cluster, der die Installation von Helm-Diagrammen und deren Verwaltung ermöglichte. <br><br>  <i><b>Hinweis</b></i>  <i><b>perev .:</b> In der zweiten Version von Helm ist die einzige im Cluster verbleibende Komponente für den Installationslebenszyklus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Release</a> ) verantwortlich, und die Konfigurationsvorbereitung wird an den Helm-Client gesendet.</i> <br><br>  <i>Wenn ein Neustart des Clusters bei Verwendung der ersten Version von Helm zu einem vollständigen Verlust der Servicedaten führte (da diese im RAM gespeichert waren), werden in Helm 2 alle Daten in <code>ConfigMaps</code> gespeichert, d. H.</i>  <i>Ressourcen in Kubernetes.</i>  <i>Ein weiterer wichtiger Schritt war der Übergang von einer synchronen API (bei der jede Anforderung blockiert wurde) zur Verwendung von asynchronem gRPC.</i> <br><br>  Seit dem Start von Helm 2 im Jahr 2016 hat das Kubernetes-Projekt ein explosives Wachstum und bedeutende neue Möglichkeiten erfahren.  Die rollenbasierte Zugriffskontrolle (RBAC) wurde hinzugefügt.  Viele neue Ressourcentypen werden eingeführt.  Erfundene Ressourcen von Drittanbietern (Custom Resource Definitions, CRD).  Und vor allem gibt es Best Practices.  Helm ging all diese Änderungen durch und diente weiterhin den Bedürfnissen der Kubernetes-Benutzer.  Uns wurde jedoch klar, dass es an der Zeit war, wesentliche Änderungen daran vorzunehmen, damit die Bedürfnisse dieses sich entwickelnden Ökosystems weiterhin erfüllt werden. <br><br>  Also kamen wir zu Helm 3. Als nächstes werde ich über einige der Innovationen sprechen, die in der Projekt-Roadmap vorgestellt werden. <br><br><h2>  Grüße Lua </h2><br>  In Helm 2 haben wir Vorlagen eingeführt.  In der frühen Phase der Helm 2-Entwicklung unterstützten wir Go, Jinja-Vorlagen, sauberen Python-Code und hatten sogar einen Prototyp der Ksonnet-Unterstützung.  Das Vorhandensein vieler Engines für Vorlagen führte jedoch zu mehr Problemen als es löste.  Daher sind wir an dem Punkt angelangt, einen zu wählen. <br><br>  Go-Vorlagen hatten vier Vorteile: <br><br><ol><li>  Die Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist in Go integriert</a> . </li><li>  Vorlagen werden in einer streng eingeschränkten Sandbox-Umgebung ausgeführt. </li><li>  wir könnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beliebige Funktionen und Objekte</a> in die Engine einfügen; </li><li>  Sie haben gut mit YAML zusammengearbeitet. </li></ol><br>  Obwohl wir die Benutzeroberfläche in Helm beibehalten haben, um andere Template-Engines zu unterstützen, sind Go-Templates zu unserem Standardstandard geworden.  Die Erfahrung der nächsten Jahre hat gezeigt, wie Ingenieure vieler Unternehmen mithilfe von Go-Vorlagen Tausende von Diagrammen erstellt haben. <br><br>  Und wir haben von ihren Enttäuschungen erfahren: <br><br><ol><li>  Die Syntax ist schwer zu lesen und schlecht dokumentiert. </li><li>  Sprachprobleme wie unveränderliche Variablen, komplizierte Datentypen und restriktive Sichtbarkeitsregeln haben aus einfachen Dingen komplexe gemacht. </li><li>  Die Unfähigkeit, Funktionen in Vorlagen zu definieren, machte die Erstellung wiederverwendbarer Bibliotheken noch schwieriger. </li></ol><br>  Am wichtigsten ist, dass wir mithilfe der Vorlagensprache Kubernetes-Objekte auf ihre Liniendarstellung „abgeschnitten“ haben.  (Mit anderen Worten, Vorlagenentwickler mussten Kubernetes-Ressourcen als Textdokumente im YAML-Format verwalten.) <br><br><h2>  Arbeiten Sie an Objekten, nicht an YAML-Stücken </h2><br>  Immer wieder hörten wir von Benutzern eine Anfrage nach der Möglichkeit, Kubernetes-Ressourcen als Objekte und nicht als Zeichenfolgen zu überprüfen und zu ändern.  Gleichzeitig waren sie fest davon überzeugt, dass es unabhängig von der Art der Implementierung, die wir dafür gewählt haben, leicht zu erlernen und im Ökosystem gut gepflegt sein sollte. <br><br>  Nach monatelanger Recherche haben wir uns entschlossen, eine integrierte Skriptsprache bereitzustellen, die in einer Sandbox verpackt und angepasst werden kann.  Unter den Top 20 Sprachen gab es nur einen Kandidaten, der die Anforderungen erfüllte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua</a> . <br><br>  1993 erstellte eine Gruppe brasilianischer IT-Ingenieure eine einfache Skriptsprache zum Einbetten in ihre Tools.  Lua hat eine einfache Syntax, wird weitgehend unterstützt und ist seit langem in der Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Top-20-Sprachen enthalten</a> .  Es wird von IDE- und Texteditoren unterstützt, es gibt viele Handbücher und Tutorials.  In einem solchen bestehenden Ökosystem möchten wir unsere Lösung entwickeln. <br><br>  Unsere Arbeit an Helm Lua befindet sich noch im konzeptionellen Beweisstadium und wir erwarten eine Syntax, die sowohl vertraut als auch flexibel ist.  Wenn Sie die alten und die neuen Ansätze vergleichen, können Sie sehen, wohin wir uns bewegen. <br><br>  Hier ist <a href="">ein Beispiel</a> für eine Herdvorlage mit Alpine in Helm 2: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: {{ template "alpine.fullname" . }} labels: heritage: {{ .Release.Service }} release: {{ .Release.Name }} chart: {{ .Chart.Name }}-{{ .Chart.Version }} app: {{ template "alpine.name" . }} spec: restartPolicy: {{ .Values.restartPolicy }} containers: - name: waiter image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}" imagePullPolicy: {{ .Values.image.pullPolicy }} command: ["/bin/sleep", "9000"]</code> </pre> <br>  In dieser einfachen Vorlage sehen Sie sofort alle integrierten Vorlagenanweisungen, z. B. <code>{{ .Chart.Name }}</code> . <br><br>  Und hier ist die Definition desselben Herdes in der vorläufigen Version des Lua-Codes: <br><br><pre> <code class="lua hljs">unction create_alpine_pod(_) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pod = { apiVersion = <span class="hljs-string"><span class="hljs-string">"v1"</span></span>, kind = <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, metadata = { name = alpine_fullname(_), labels = { heritage = _.Release.Service <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"helm"</span></span>, release = _.Release.Name, chart = _.Chart.Name .. <span class="hljs-string"><span class="hljs-string">"-"</span></span> .. _.Chart.Version, app = alpine_name(_) } }, spec = { restartPolicy = _.Values.restartPolicy, containers = { { name = waiter, image = _.Values.image.repository .. <span class="hljs-string"><span class="hljs-string">":"</span></span> .. _.Values.image.tag, imagePullPolicy = _.Values.image.pullPolicy, command = { <span class="hljs-string"><span class="hljs-string">"/bin/sleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"9000"</span></span> } } } } } _.resources.add(pod) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Es ist nicht erforderlich, jede Zeile dieses Beispiels zu betrachten, um zu verstehen, was passiert.  Es ist sofort ersichtlich, dass der Code unter definiert ist.  Anstatt YAML-Zeichenfolgen mit integrierten Vorlagenanweisungen zu verwenden, definieren wir sie in Lua als Objekt. <br><br><h2>  Kürzen wir diesen Code </h2><br>  Da wir direkt mit Objekten arbeiten (anstatt einen großen Textball zu bearbeiten), können wir die Skripterstellung voll ausnutzen.  Die Möglichkeiten, gemeinsam genutzte Bibliotheken zu erstellen, die hier angezeigt werden, sind sehr attraktiv.  Und wir hoffen, dass wir durch die Einführung spezialisierter Bibliotheken (oder die Erlaubnis der Community, diese zu erstellen) den obigen Code auf etwa Folgendes reduzieren können: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pods = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"mylib.pods"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_alpine_pod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span></span> myPod = pods.new(<span class="hljs-string"><span class="hljs-string">"alpine:3.7"</span></span>, _) myPod.spec.restartPolicy = <span class="hljs-string"><span class="hljs-string">"Always"</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set any other properties _.Manifests.add(myPod) end</span></span></code> </pre> <br>  In diesem Beispiel verwenden wir die Möglichkeit, mit der Definition einer Ressource als Objekt zu arbeiten, wodurch Eigenschaften einfach festgelegt werden können, während die Prägnanz und Lesbarkeit des Codes erhalten bleibt. <br><br><h2>  Vorlagen ... Lua ... Warum nicht alle zusammen? </h2><br>  Obwohl die Vorlagen nicht für alle Aufgaben so wunderbar sind, haben sie dennoch gewisse Vorteile.  Templates in Go ist eine stabile Technologie mit einer etablierten Benutzerbasis und vielen vorhandenen Diagrammen.  Viele Diagrammentwickler behaupten, dass sie gerne Vorlagen schreiben.  Daher werden wir die Vorlagenunterstützung nicht entfernen. <br><br>  Stattdessen möchten wir, dass sowohl Vorlagen als auch Lua gleichzeitig verwendet werden.  Lua-Skripte haben vor und nach dem Rendern Zugriff auf Helm-Vorlagen, sodass fortgeschrittene Diagrammentwickler komplexe Transformationen an vorhandenen Diagrammen durchführen können, während die einfache Möglichkeit erhalten bleibt, Helm-Diagramme mit Vorlagen zu erstellen. <br><br>  Wir sind sehr ermutigt von der Unterstützung von Skripten auf Lua, aber gleichzeitig werden wir einen bedeutenden Teil der Helm-Architektur los ... <br><br><h2>  Abschied von Tiller </h2><br>  Während der Entwicklung von Helm 2 haben wir Tiller als Integrationskomponente mit Deployment Manager eingeführt.  Tiller spielte eine wichtige Rolle für Teams, die an demselben Cluster arbeiten: Es ermöglichte die Interaktion mit denselben Releases für viele verschiedene Administratoren. <br><br>  Tiller fungierte jedoch als riesiger Sudo-Server und gewährte jedem, der Zugriff auf Tiller hat, eine breite Palette von Rechten.  Und unser Standardinstallationsschema war eine zulässige Konfiguration.  Daher mussten die Ingenieure von DevOps und SRE die zusätzlichen Schritte zur Installation von Tiller in mandantenfähigen Clustern lernen. <br><br>  Darüber hinaus konnten wir uns mit dem Aufkommen von CRD nicht mehr zuverlässig auf Tiller verlassen, um den Status aufrechtzuerhalten oder als zentrale Drehscheibe für Helm-Release-Informationen zu fungieren.  Wir konnten diese Informationen nur als separate Einträge in Kubernetes speichern. <br><br>  Das Hauptziel von Tiller kann ohne Tiller selbst erreicht werden.  Daher war eine der ersten Entscheidungen, die während der Planungsphase von Helm 3 getroffen wurden, die vollständige Aufgabe von Tiller. <br><br><h2>  Sicherheitsverbesserung </h2><br>  Ohne Pinne wird das Helm-Sicherheitsmodell radikal vereinfacht.  Die Benutzerauthentifizierung wird von Kubernetes delegiert.  Und Autorisierung auch.  Helmrechte werden als Kubernetes-Rechte (über RBAC) definiert, und Cluster-Administratoren können Helmrechte auf jeder erforderlichen Detailebene einschränken. <br><br><h2>  Releases, ReleaseVersions und State Storage </h2><br>  In Abwesenheit von Tiller benötigen wir eine neue Art der Interaktion aller Clients (zum Release-Management), um den Status verschiedener Releases innerhalb des Clusters aufrechtzuerhalten. <br><br>  Zu diesem Zweck haben wir zwei neue Einträge eingeführt: <br><br><ol><li>  <code>Release</code> - für eine bestimmte Installation eines bestimmten Diagramms.  Wenn wir <code>helm install my-wordpress stable/wordpress</code> ausführen, wird eine Version namens <code>my-wordpress</code> erstellt und während der gesamten Lebensdauer dieser WordPress-Installation gepflegt. </li><li>  <code>ReleaseVersion</code> - Jedes Mal, wenn Sie das Helm-Diagramm aktualisieren, müssen Sie berücksichtigen, was sich geändert hat und ob die Änderung erfolgreich war.  <code>ReleaseVersion</code> an ein Release gebunden und speichert nur Datensätze mit Informationen zum Aktualisieren, <code>ReleaseVersion</code> und Löschen.  Wenn wir das <code>helm upgrade my-wordpress stable/wordpress</code> <code>ReleaseVersion</code> bleibt das ursprüngliche <code>Release</code> Objekt gleich, es wird jedoch ein <code>ReleaseVersion</code> Objekt mit Informationen zum Aktualisierungsvorgang <code>ReleaseVersion</code> . </li></ol><br>  <code>Releases</code> und <code>ReleaseVersions</code> werden in denselben Namespaces wie die Diagrammobjekte gespeichert. <br><br>  Mit diesen Funktionen können Helm-Benutzerteams die Aufzeichnungen der Helm-Installationen im Cluster verfolgen, ohne dass Tiller erforderlich ist. <br><br><h2>  Aber warte, das ist noch nicht alles! </h2><br>  In diesem Artikel habe ich versucht, über einige der wichtigsten Änderungen in Helm 3 zu sprechen. Diese Liste ist jedoch überhaupt nicht vollständig.  <a href="">Der Helm 3-Plan</a> enthält auch andere Änderungen, z. B. Verbesserungen im Diagrammformat, Leistungsverbesserungen für Diagrammrepositorys und ein neues Ereignissystem, das Diagrammentwickler verwenden können.  Wir machen Eric Raymond auch zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-Archäologie, indem</a> wir die Codebasis bereinigen und Komponenten aktualisieren, die in den letzten drei Jahren an Relevanz verloren haben. <br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Es ist ein Paradoxon, aber der Helm 2-Paketmanager, wenn die <code>install</code> oder das <code>upgrade</code> erfolgreich ist, d. H.</i>  <i>Eine Freigabe im <code>success</code> garantiert nicht, dass die Anwendungsressourcen erfolgreich eingeführt wurden (z. B. gibt es keine Fehler wie <code>ImagePullError</code> ).</i>  <i>Vielleicht können Sie mit dem neuen Ereignismodell zusätzliche Hooks für Ressourcen hinzufügen und den Rollout-Prozess besser steuern - wir werden es bald herausfinden.</i> <br><br>  Mit dem Beitritt von Helm zur CNCF lassen wir uns nicht nur von Helm 3 inspirieren, sondern auch vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chart Museum</a> , dem wunderbaren Dienstprogramm zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testen von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Charts</a> , dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Chart-Repository</a> und anderen Projekten unter der Schirmherrschaft von Helm in CNCF.  Wir sind zuversichtlich, dass ein gutes Paketmanagement für Kubernetes für das Cloud-native Ökosystem genauso wichtig ist wie ein gutes Paketmanagement für Linux. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine praktische Einführung in den Paketmanager für Kubernetes - Helm</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übe mit dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bereitstellung von Docker-Images in Kubernetes mit Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen und Installieren von Anwendungen in Kubernetes mit dapp und GitLab CI</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beste CI / CD-Praktiken mit Kubernetes und GitLab</a> “ <i>(Rezension und Videobericht)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> " <i>(Videobericht, der eine Einführung in das technische Gerät von Kubernetes enthält).</i> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417079/">https://habr.com/ru/post/de417079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417065/index.html">Splunk-Anleitung oder wie und wo man Splunk lernt</a></li>
<li><a href="../de417069/index.html">Nochmals zu OpenSSL</a></li>
<li><a href="../de417071/index.html">Freitag PHP: Kostenlose Skillbox-Webinare</a></li>
<li><a href="../de417073/index.html">Uber Mobile Developer Day</a></li>
<li><a href="../de417075/index.html">CSS Paint API</a></li>
<li><a href="../de417081/index.html">Norden, Wille, Hoffnung, Land ohne Grenzen oder wie Projekte unter schwierigen sibirischen Bedingungen durchgeführt werden</a></li>
<li><a href="../de417083/index.html">Hohe Lasten der WM 2018</a></li>
<li><a href="../de417085/index.html">Browser schalten den Sound in Ihrer WebRTC-Anwendung stumm. Hör auf was?</a></li>
<li><a href="../de417087/index.html">HPE Digitalize 2018: Event und Live-Stream</a></li>
<li><a href="../de417089/index.html">Quantencomputer: Ein Photon, um alle zu regieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>