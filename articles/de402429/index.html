<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìí üíú üë©üèº‚Äçü§ù‚Äçüë®üèª RobotDyn schl√§gt doppelt zu: Mega + ESP8266 ‚è≠Ô∏è üì¶ üçô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was macht ein Entwickler in seltenen Stunden der Freizeit? Das ist richtig, wenn Sie die Preislisten der Eisengesch√§fte durchsuchen. Es gab eine freie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RobotDyn schl√§gt doppelt zu: Mega + ESP8266</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402429/"><img src="https://habrastorage.org/files/07a/66b/52f/07a66b52ff5d4326bcef6a7fd2749aef.jpg" alt="RobotDyn Mega + ESP8266"><br>  Was macht ein Entwickler in seltenen Stunden der Freizeit?  Das ist richtig, wenn Sie die Preislisten der Eisengesch√§fte durchsuchen.  Es gab eine freie Minute und ich beschloss, die Seiten der beliebten Online-Shops zu durchsuchen - Langeweile, nichts Interessantes, wir haben das alles schon gesehen ... und dann fallen meine Augen pl√∂tzlich auf das n√§chste Mega.  Bah!  Ja, es ist nicht nur Mega, sondern kombiniert mit dem beliebten ESP8266 aller und sorgf√§ltig ausgestattet mit Switches, damit zwei Controller zusammenarbeiten k√∂nnen - verkabelt (mit Ethernet Shield) mit viel GPIO und Wi-Fi f√ºr die drahtlose Kommunikation. <br><br>  Nicht schlecht!  Ich habe an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AMS</a> gedacht und mich daran erinnert - dort k√∂nnen Sie zwei Server installieren - verkabelt und drahtlos - und sie zu einem System verbinden. Der ESP8266 empf√§ngt 54 digitale und 16 analoge Pins, und Mega erh√§lt die drahtlose Steuerung √ºber WLAN und alle ESP8266-Br√∂tchen.  Vor langer Zeit bin ich nicht auf ein so interessantes Board gesto√üen. <br><br>  - Guten Tag!  Haben Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mega + ESP8266-</a> Board? <br>  - Ja, aber wir haben nur noch einen. <br>  "Warum nur einer?" <br>  - Der Rest wurde auseinander genommen. <br>  "Reservieren Sie sie bitte f√ºr mich." <br><a name="habracut"></a><br><h2>  Ein paar Worte zum Unternehmen </h2><br>  Ich mochte RobotDyn zwei Dinge: das erste - mit seinen technologischen L√∂sungen.  Es ist nicht n√∂tig, weit zu gehen. Ein hervorragendes Beispiel ist das betrachtete Mega + ESP8266-Board.  So etwas habe ich in unseren (und nicht in unseren, aber ich habe hier nicht wirklich danach gesucht) Online-Shops nicht gesehen.  Und dies ist nicht das einzige Beispiel, es gibt immer noch die Option Uno + ESP8266 und das Unternehmen wird hier eindeutig nicht aufh√∂ren, anscheinend warten immer noch viele interessante Ger√§te auf uns. <br><br>  Und das zweite ist die Preispolitik.  Ich werde hier nicht im Detail auf dieses Thema eingehen, aber ich werde sagen, dass mich die Preise angenehm √ºberrascht haben - das Motto des Unternehmens lautet ‚ÄûPreise sind wie bei Aliexpress‚Äú. <br><br>  Kurz gesagt, ich habe den Hintergrund beschrieben, auf dem sich alle nachfolgenden Ereignisse entfalten werden. Jetzt gehen wir direkt zu den technischen Details und einer Beschreibung des Boards und wie man damit arbeitet. <br><br><h2>  Das Board selbst </h2><br>  Im Allgemeinen eine gew√∂hnliche Karte, die sich nicht wesentlich von vielen √§hnlichen unterscheidet, wenn nicht f√ºr einen kleinen Teil, n√§mlich den in die Karte integrierten ESP8266EX-Chip.  Dies versetzt das Board sofort in die Kategorie der au√üergew√∂hnlichen L√∂sungen.  Ich m√∂chte Ihre Aufmerksamkeit auf ein weiteres Detail lenken - kein Standardmodul vom Typ ESP-12 ist in die Platine integriert, sondern der Chip und die gesamte Verkabelung befinden sich auf der Platine selbst, was transparent auf die Ebene der Entwickler hinweist.  Ich m√∂chte auch darauf hinweisen, dass die Karte sowohl eine gedruckte Antenne als auch einen Anschluss zum Anschlie√üen einer externen Antenne hat, was in vielen F√§llen sehr n√ºtzlich sein kann. <br><img src="https://habrastorage.org/files/1d1/cee/155/1d1cee155967488581228289df3b6f28.jpg" alt="RobotDyn Mega + ESP8266"><br>  Auf der Platine befinden sich Pin-Anschl√ºsse f√ºr den Anschluss an die ESP8266-Klemmen und mehrere Schalter, die etwas mehr zu erw√§hnen sind.  Die Hauptidee bei der Verwendung der Karte besteht darin, dass Sie mithilfe der Schalter das Zusammenspiel der drei Komponenten auf unterschiedliche Weise konfigurieren k√∂nnen: den Atmega2560-Chip, den ESP8266EX-Chip und den CH340G USB-TTL-Konverter.  Es sind sowohl einzelne als auch komplexe Verbindungen m√∂glich, mit denen Sie viele Optionen f√ºr die Interaktion aller Teile der Platine organisieren k√∂nnen.  Dies er√∂ffnet gro√üartige M√∂glichkeiten f√ºr den Bau verschiedener Ger√§te, aber dazu sp√§ter mehr. <br><br><img src="https://habrastorage.org/files/cb4/2f4/819/cb42f4819ba940369ad71818bbc7ff03.jpg" alt="ESP8266-Stifte"><br><br>  Ich m√∂chte auch die anst√§ndige Tragf√§higkeit des Boards beachten.  Gemessen an den Beschriftungen kann es einen Laststrom von 1,6 A auf einem 5-Volt-Kanal und 1 A auf einem 3,3-Volt-Kanal liefern.  Das ist sehr gut, vor allem insgesamt. <br><br>  √úber das Board gibt es nichts mehr zu sagen. Wir wenden uns der Installation und dem Testen der Software zu. <br><br><h2>  Board-Tests </h2><br>  Da die Platine integriert ist und praktisch kein freier Speicherplatz vorhanden ist und die Verdrahtung des Hochfrequenzteils des ESP8266EX darauf erfolgt, entstanden zun√§chst Zweifel an der korrekten und st√∂rungsfreien Funktionsweise dieser gesamten Wirtschaft. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass trotz meiner Bedenken alles stabil und wie erwartet funktioniert.  Wir verbinden die Schalter auf der Atmega2560-Karte mit USB - wir bekommen den Arduino Mega, wir verbinden den ESP8266EX mit USB - wir bekommen den ESP8266, wir wechseln in den Verbindungsmodus des Atmega2560 mit dem ESP8266EX, wir bekommen die Verbindung zwischen den Chips √ºber die serielle Schnittstelle.  Alles funktioniert genau so, wie es in der Dokumentation beschrieben ist und genau so, wie es intuitiv erwartet wird. <br><br>  Ein gro√ües Plus dieser L√∂sung ist, dass die Entwickler darauf geachtet haben, die logischen Signalpegel aller Systemkomponenten anzupassen.  Jeder, der manuell versucht hat, das ESP8266-Modul zu konfigurieren und alle Pull-up-Widerst√§nde korrekt anzuschlie√üen, wird mich verstehen.  Es gibt keine derartigen Probleme. Ihre gesamte Arbeit beschr√§nkt sich auf das Klicken auf die Schalter auf der Platine gem√§√ü den Anweisungen des Herstellers. <br><br><h2>  Lasttest </h2><br>  Wie teste ich das Board?  Sie k√∂nnen eine Standardskizze herunterladen, aber es wird ein Test √ºber nichts sein.  Diese Option funktioniert m√∂glicherweise einwandfrei und unter Kampfbedingungen f√§llt das System aus.  Daher wurde die Arbeit beider Teile unter der Kontrolle der entsprechenden Versionen des Arduino Mega Servers als Hartlasttest ausgew√§hlt.  F√ºr Mega - Arduino Mega Server f√ºr Mega und f√ºr ESP8266 - Arduino Mega Server f√ºr ESP8266 in Version M1. <br><br>  Das M1-Verteilungskit wurde ausgew√§hlt, da nur 1 MB Flash-Speicher f√ºr ESP8266 auf der Karte installiert ist.  Dies ist meiner Meinung nach fast der einzige Fehler f√ºr Entwickler - in zuk√ºnftigen Revisionen des Boards w√ºrde ich empfehlen, 4 MB Speicherchips einzusetzen.  Der Preisunterschied ist gering und die M√∂glichkeiten bei Verwendung der Version mit 4 MB sind viel gr√∂√üer.  Da es jedoch eine AMS-Version f√ºr Systeme mit 1 MB gibt, habe ich diesem Punkt nicht viel Aufmerksamkeit geschenkt und die Tests fortgesetzt. <br><br>  Was soll ich sagen?  Wir schalten das Board ein, f√ºllen die Software aus und erhalten zwei unabh√§ngige Server.  Eine drahtlos √ºber Ethernet Shield und eine drahtlos √ºber WLAN.  Sch√∂nheit! <br><br>  Ich m√∂chte auch darauf hinweisen, dass selbst das Hinzuf√ºgen eines Ethernet Shield mit einem Kartenleser zu diesem bereits hoch entwickelten System keine Konflikte oder Fehler verursachte - alles hat einfach so geklappt, wie es funktionieren sollte.  In einigen F√§llen ist es sogar noch besser als gew√∂hnlich - dies ist die erste Karte, auf der die drahtlose Firmware des ESP8266 in 100% der F√§lle erfolgreich war. Auf allen anderen Karten und Modulen treten von Zeit zu Zeit Fehler mit einem solchen Blinken auf. <br><br>  Und zwei Server drehen sich, laden das Board, erf√ºllen ihre Aufgaben und ... das ist alles.  Alles funktioniert einfach, es gibt nichts zu sagen, aber dies ist wahrscheinlich das beste Lob f√ºr jedes technische System. <br><br><h2>  Am interessantesten </h2><br>  Was ich hier beschrieben habe, ist aus rein akademischer Sicht interessant: ein interessantes Board, eine interessante technische L√∂sung, aber nat√ºrlich interessiert uns seine praktische Anwendung.  Was ist das praktische und angewandte Highlight? <br><br>  Tatsache ist, dass Sie mit einem Schalter auf der Platine zwei ihrer Teile (Mega und ESP) zu einer Einheit verbinden k√∂nnen, um erstens ein neues Qualit√§tssystem zu erhalten und zweitens die inh√§renten M√§ngel jedes einzelnen Teils zu kompensieren. <br><br>  Beginnen wir mit dem ESP8266.  Der Hauptnachteil dieser im Allgemeinen ausgezeichneten L√∂sung ist das katastrophale Fehlen von GPIO-Pins.  Wie sie sagen, eins, zwei und falsch berechnet.  Es ist schwer zu sagen, was die Entwickler dieses Chips dachten, aber vor der Ver√∂ffentlichung von ESP32 hatten sie etwas mehr Zeit zum Nachdenken und haben dieses Manko im neuen Chip behoben.  Wir haben es aber speziell mit 8266 zu tun. <br><br>  Mit diesem Board k√∂nnen Sie ein Pferd bewegen und die volle Leistung von Mega nutzen. Dies sind unter anderem 54 digitale und 16 analoge Ausg√§nge im ESP8266.  Das hei√üt, unser klappriges ESP bietet pl√∂tzlich gro√üartige M√∂glichkeiten f√ºr die Arbeit mit Sensoren, Aktoren und anderen Peripherieger√§ten.  Es stellt sich sozusagen heraus, Baby ESP auf Steroiden. <br><br>  Dies ist nur eine der m√∂glichen Optionen f√ºr die Verwendung der auf der Oberfl√§che liegenden Platte. <br><br>  Nun schauen wir uns Mega an.  Sie st√∂rt die drahtlose Schnittstelle und die F√§higkeit zur Interaktion mit Wi-Fi-Ger√§ten nicht, wodurch sie in den ESP-Teil des Systems integriert werden kann.  Gleichzeitig bleibt die M√∂glichkeit des Parallelbetriebs √ºber eine kabelgebundene Ethernet-Schnittstelle bestehen. <br><br>  Und dies ist auch nur eine der m√∂glichen Anwendungen f√ºr dieses Board, das auf der Oberfl√§che liegt. <br><br>  Nun, verschiedene Bridge-Optionen: Ethernet - Wi-Fi, nRF24 - Ethernet, nRF24 - Wi-Fi, nRF24 (1) - nRF24 (2), nooLite - Wi-Fi, nooLite - Ethernet, nooLite (1) - nooLite (2) ) usw. usw. bis unendlich.  Sie k√∂nnen Signale von Dutzenden von Subsystemen, mit denen der Arduino Mega Server arbeitet, zwischen den beiden Teilen der Karte und den mit ihnen verbundenen Schnittstellen weiterleiten. <br><br>  Ich wei√ü nicht einmal, was ich sagen soll.  Sehr cool. <br><br><h2>  Technische Details </h2><br>  Nun ein wenig zu den technischen Details.  Sie sehen eine Tabelle, in der alle m√∂glichen Betriebsarten der Karte dargestellt und alle m√∂glichen Positionen der Schalter darauf angezeigt werden.  Betrachten wir kurz jeden Modus. <br><br><img src="https://habrastorage.org/files/a51/cc7/874/a51cc7874a274215b06fc93c7d7dbd4d.png" alt="Tabelle der Betriebsmodi der RobotDyn-Karte"><br><br><h4>  Arduino Mega 2560 </h4><br>  Die einfachste Funktionsweise des Boards, in der Tabelle als Modus 3 bezeichnet. Wenn Sie die Schalter 3 und 4 auf ON und den Rest auf OFF stellen, erhalten Sie den √ºblichen Arduino Mega 2560. Nichts Interessantes, aus diesem Grund hat sich der Kauf dieses Boards nicht gelohnt war das √ºbliche Mega zu kaufen. <br><br><h4>  ESP8266 </h4><br>  Auch keine sehr interessante Funktionsweise.  In der Tabelle ist es in zwei Untermodi unterteilt, die als 1 (Laden der Skizze in ESP) und 2 (Verbindungsmodus von ESP zu USB) bezeichnet werden.  Dies ist die gesamte Funktionalit√§t des Standard-ESP8266, und f√ºr eine solche Verwendung hat es sich auch nicht gelohnt, dieses Board zu kaufen. Sie k√∂nnten mit dem √ºblichen ESP-Modul auskommen. <br><br><h4>  Alle sind unabh√§ngig </h4><br>  Wir betrachten diese Option auch bei Nummer 6 nicht, da darin alle Verbindungen zwischen den Teilen der Platine unterbrochen sind und sie f√ºr uns definitiv f√ºr nichts n√ºtzlich sein kann. <br><br><h4>  Die Verbindung zwischen Mega und ESP </h4><br>  In diesem als 5 bezeichneten Modus wird die Kommunikation zwischen Mega und ESP √ºber eine serielle Schnittstelle hergestellt, es findet jedoch keine Kommunikation mit dem USB-TTL-Konverter statt.  ESP verwendet Standard Serial, w√§hrend Mega nicht weniger Standard Serial3 verwendet.  Die Verbindung funktioniert stabil und nahtlos mit einer Geschwindigkeit von 115200. Dies ist eine ziemlich spezifische Betriebsart, wenn kein Controller √ºber eine USB-Verbindung verf√ºgt.  Und so ist er auch f√ºr uns nicht sehr interessant. <br><br><h4>  Kommunikation zwischen Mega und ESP sowie Mega und USB gleichzeitig </h4><br>  Aber das nennt man Trumpfkarte.  Wir bekommen alles auf einmal - die Mega-USB-Verbindung und die M√∂glichkeit, Skizzen auf Mega hochzuladen und den Betrieb √ºber denselben USB zu steuern, die M√∂glichkeit der Kommunikation zwischen Mega und ESP und die M√∂glichkeit, Skizzen auf den ESP8266 hochzuladen und den Betrieb √ºber die USB-Schnittstelle zu steuern ... Mega!  Das hei√üt, volle F√ºllung, nicht direkt die Registrierkasse verlassen. <br><br>  Dies ist die einzig richtige Betriebsart, die in der Tabelle aufgef√ºhrt ist.  Erinnern Sie sich an seine Gewinnzahl, die vier ist.  In der Konfiguration der Schalter auf der Platine sieht es auch sch√∂n aus - 1, 2, 3, 4 sind in der EIN-Position, der Rest ist AUS. <br><br>  Ein aufmerksamer Leser wird fragen: Wie k√∂nnen wir Skizzen auf den ESP8266 hochladen, wenn der USB-Anschluss gerade mit dem Mega-Teil des Systems verbunden ist?  Und das ist die richtige Frage, die Antwort ist auf keinen Fall.  Und warum schreiben Sie dann, dass wir in dieser Konfiguration Skizzen auf ESP8266 hochladen k√∂nnen?  Da der Arduino Mega Server die M√∂glichkeit hat, Skizzen √ºber die Luft direkt von der Arduino IDE herunterzuladen, indem Sie ein paar Tasten dr√ºcken, ist das richtig - wir haben die volle F√ºllung, alles funktioniert sofort. <br><br>  Aber was ist mit denen, die das Board ohne Arduino Mega Server nutzen wollen?  Es gibt nur zwei M√∂glichkeiten: Entweder klicken Sie st√§ndig auf die Schalter oder Sie k√∂nnen Skizzen in Ihren Entw√ºrfen durch die Luft herunterladen.  Ich pers√∂nlich mag die zweite Option mehr. <br><br><h2>  Arduino IDE-Einstellungen </h2><br>  Die Arduino IDE-Einstellungen f√ºr Mega werfen keine Fragen auf, dort ist alles Standard, und f√ºr ESP8266 werde ich einen Screenshot des Men√ºs mit Einstellungen f√ºr eine bestimmte Implementierung des ESP-Teils auf der RobotDyn-Karte geben.  Sie m√ºssen dieselben Parameter f√ºr sich selbst festlegen, mit Ausnahme der Portnummer - auf Ihrem System hat sie h√∂chstwahrscheinlich einen anderen Wert. <br><br><img src="https://habrastorage.org/files/e1f/d98/bac/e1fd98bacc664b7e931699cb65b1c6ae.png" alt="ESP8266 Einstellungen in der Arduino IDE"><br><br><h2>  Arduino Mega Server f√ºr RobotDyn Mega + ESP8266 </h2><br>  F√ºr dieses Board wurde eine spezielle Dual-Version des Arduino Mega Servers ver√∂ffentlicht, die zwei Server gleichzeitig enth√§lt, die speziell f√ºr dieses Board optimiert wurden.  Dies steht au√üer Frage. Beide Server enthalten Standardfunktionen und k√∂nnen f√ºr jedes Ihrer Projekte verwendet werden. <br><br>  Sie k√∂nnen beide Server unabh√§ngig voneinander auf derselben Karte verwenden oder die erforderlichen Funktionen hinzuf√ºgen und sie im Tandem- und Bridge-Modus zwischen zwei Netzwerken und allen mit den Servern verbundenen Schnittstellen verwenden. <br><br>  Die erste Arduino Mega Server-Baugruppe f√ºr die RobotDyn Mega + ESP8266-Karte enth√§lt ein Testbeispiel f√ºr die Interaktion zweier Controller √ºber eine serielle Schnittstelle.  Dies ist eine Demonstration der F√§higkeiten der Technologie, auf deren Grundlage Sie Ihre eigenen L√∂sungen entwickeln k√∂nnen. <br><br>  Nun etwas mehr zur Entwicklung eines Protokolls f√ºr die Interaktion zweier Controller √ºber die serielle Schnittstelle im Allgemeinen und auf dieser Karte im Besonderen. <br><br><h2>  Protokollentwicklung </h2><br>  Was sollen wir ein Haus bauen?  M√ºssen Sie ein Interaktionsprotokoll zwischen den beiden Teilen des Systems √ºber die serielle Schnittstelle entwickeln?  - Wir werden uns entwickeln, hier geht es haupts√§chlich darum, die Aufgabe klar und richtig zu setzen.  Um den Tandembetrieb des Systems zu demonstrieren, zeigen wir die Betriebsanzeigen des Partners im Dashpanel jedes Servers an. <br><br>  <em><strong>Ein bisschen √ºber Terminologie.</strong></em>  <em>F√ºr Mega ist der ‚ÄûPartner‚Äú ESP8266, f√ºr ESP8266 Mega.</em> <br><br>  Wenn der Partner arbeitet, leuchtet die Anzeige gr√ºnlich, wenn sie nicht arbeitet, rot und grau, wenn der Status nicht definiert ist.  Dies ist sehr praktisch - w√§hrend des Betriebs sehen Sie sofort den Zustand des Alter Ego Ihres Systems. <br><br>  F√ºr eine praktische L√∂sung dieses Problems gibt es genau eine Million M√∂glichkeiten. Wir w√§hlen Folgendes aus: Kommunikationsbl√∂cke beider Teile des Systems sind identisch, Interaktion erfolgt im Vollduplexmodus, Informationsbl√∂cke haben ein einfaches und klares Format: <br><br><pre><code class="java hljs">?=</code> </pre> <br>  oder <br><br><pre> <code class="java hljs">?</code> </pre><br>  Dies ist nur ein Testbeispiel zum L√∂sen der Aufgabe. Sie k√∂nnen dieses Interaktionsprotokoll √§ndern oder ein eigenes schreiben, das f√ºr Ihre Aufgaben geeignet ist.  Mit dem bereits implementierten Protokoll k√∂nnen Sie jedoch nicht nur den Status des Partners √ºberwachen, sondern ihn auch f√ºr viele andere Zwecke verwenden, z. B. den Status der Controller-Pins, den Status von Sensoren √ºbertragen oder Steuerbefehle an den Partner senden. <br><br>  Insbesondere in unserem System sehen Teams folgenderma√üen aus: <br><br>  <strong>? mega = 1</strong> - Mega sendet Daten √ºber seine Leistung.  Parameter "mega", Wert "1". <br><br>  <strong>? esp = 1</strong> - ESP8266 sendet Daten √ºber seinen Zustand.  Der Parameter ist "esp", der Wert ist "1". <br><br>  Betrachten Sie beispielsweise die Implementierung des Protokolls f√ºr den Mega-Teil des Systems. <br><br>  Standardm√§√üig initialisieren wir das AMS-Modul und die Serial3 Mega-Hardware mit einer Geschwindigkeit von 115200. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial3.begin(<span class="hljs-number"><span class="hljs-number">115200</span></span>); modulRobotdyn = MODUL_ENABLE; started(<span class="hljs-string"><span class="hljs-string">"RobotDyn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre><br>  Wir √ºberpr√ºfen den Status des Serial3-Ports und bilden bei Daten vom Partner die Zeichenfolgenvariable serialReq, die die empfangenen Daten oder Befehle enth√§lt. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Serial3.available() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sFlag) { serialReq = <span class="hljs-string"><span class="hljs-string">""</span></span>; sFlag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = Serial3.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">10</span></span>) { sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; parseSerialStr(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">13</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial()</span></span></code> </pre><br>  Wir analysieren die Befehle und Daten und ergreifen bei Informationen √ºber den Status des Partners Ma√ünahmen in Form einer √Ñnderung des Status der esp-Variablen. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseSerialCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String command, parameter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pBegin = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pParam = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { command = serialReq.substring(pBegin); parameter = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command != F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { Serial.print(F(<span class="hljs-string"><span class="hljs-string">"command/parameter: "</span></span>)); Serial.print(command); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); Serial.println(parameter); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd()</span></span></code> </pre><br>  Sie k√∂nnen die Verarbeitung anderer Befehle einfach hinzuf√ºgen, indem Sie den entsprechenden Codeabschnitt √§ndern und hinzuf√ºgen. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Wenn Sie in Ihren eigenen Projekten und beim Parsen viele Befehle und Daten verwenden, ist es besser, diesen Codeabschnitt in Form entsprechender Funktionen zu entwerfen. <br><br>  Es bleibt nur die Standardfunktion des AMS-Moduls zu ber√ºcksichtigen, das f√ºr seine Arbeit verantwortlich ist.  Zuerst wird der Portstatus √ºberpr√ºft, dann wird alle vier Sekunden ein Befehl an den Partner gesendet, dass Mega lebt und funktioniert, und die Zeit, die seit dem Empfang der letzten Daten vom Partner vergangen ist, wird √ºberpr√ºft. Wenn sie 8 Sekunden √ºberschreitet, wird der Schluss gezogen, dass der Partner nicht funktioniert. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkSerial(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle4s) { Serial3.println(F(<span class="hljs-string"><span class="hljs-string">"?mega=1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (millis() - espTimer &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Das ist alles Magie.  Stimmt, nichts kompliziertes? <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger Code des Moduls, das f√ºr die system√ºbergreifende Kommunikation zwischen Mega 2560 und ESP8266 verantwortlich ist</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Modul RobotDyn part of Arduino Mega Server project */</span></span> #ifdef ROBOTDYN_FEATURE bool sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> espTimer = millis(); <span class="hljs-comment"><span class="hljs-comment">// Serial request #define MAX_SERIAL_REQ 32 String serialReq = ""; void robotdynInit() { Serial3.begin(115200); modulRobotdyn = MODUL_ENABLE; started("RobotDyn", true); } void printSerialStr() { Serial.print("["); Serial.print(serialReq); Serial.println("]"); } void parseSerialCmd() { String command, parameter; if (serialReq.indexOf(F("?")) &gt;= 0) { int pBegin = serialReq.indexOf(F("?")) + 1; if (serialReq.indexOf(F("=")) &gt;= 0) { int pParam = serialReq.indexOf(F("=")); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + 1); } else { command = serialReq.substring(pBegin); parameter = ""; } // if (command != F("esp")) { Serial.print(F("command/parameter: ")); Serial.print(command); Serial.print(F("/")); Serial.println(parameter); //} if (command == F("esp")) { if (parameter == F("1")) { esp = 1; espTimer = millis(); } else { esp = 0; } } } // if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd() void parseSerialStr() { if (serialReq[0] == '?') { parseSerialCmd(); } else { printSerialStr(); } } void checkSerial() { while (Serial3.available() &gt; 0) { if (sFlag) { serialReq = ""; sFlag = false; } char c = Serial3.read(); if (c == 10) { sFlag = true; parseSerialStr(); } else if (c == 13) { // skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial() void robotdynWork() { checkSerial(); if (cycle4s) { Serial3.println(F("?mega=1")); if (millis() - espTimer &gt; 8000) { esp = 0; } } } #endif // ROBOTDYN_FEATURE</span></span></code> </pre><br></div></div><br><h2>  Wie die Ausgabe im seriellen Monitor aussieht </h2><br>  Im Mega 2560 Serial Monitor sehen die Ausgabe, Daten und Befehle des ESP-Teils des Systems genauso aus wie die eigenen.  Um die Ausgabe des Partners von der Ausgabe von Mega zu unterscheiden, werden seine Daten in eckige Anf√ºhrungszeichen gesetzt.  In diesem Fall sehen Sie den Neustart des ESP8266 und das AMS-Startprotokoll im seriellen Monitor von Mega. <br><br><img src="https://habrastorage.org/files/a03/904/3b8/a039043b86d442d7a54e10bb73b314c7.png" alt="ESP8266-Ausgabe an den Monitor der Mega 2560-Serie"><br><br>  Und das Protokoll des tats√§chlichen Befehlsaustauschs zwischen den beiden Teilen des Systems √ºber die serielle Schnittstelle.  Sie sehen die Ausgabe von ESP8266 mit Informationen zum Dekodieren von Mega-Statusdaten in der seriellen Schnittstelle von Mega, die in eckigen Anf√ºhrungszeichen eingeschlossen sind. <br><br><img src="https://habrastorage.org/files/b5f/444/6cf/b5f4446cf54c4c048fa568f1e3418823.png" alt="ESP8266 Ausgabe bei Mega Command Decoding"><br><h2>  Sch√∂nheit in der Schnittstelle </h2><br>  Nun ein wenig dar√ºber, wie alles in der Arduino Mega Server-Oberfl√§che aussieht.  Zu Beginn werde ich Screenshots von beiden Teilen des Systems bei der Arbeit geben. <br><br><img src="https://habrastorage.org/files/774/faf/c92/774fafc92eb54ba29905a6ec201501da.png" alt="Arduino Mega Server f√ºr RobotDyn Mega + ESP8266"><br><br>  Ellipsen sind um Inschriften eingekreist, die den Controller und den Teil des Systems identifizieren, mit dem Sie gerade arbeiten.  Kreise werden um Indikatoren eingekreist, die den Status des Partners anzeigen.  Im Moment ist alles in Ordnung, beide Teile des Systems arbeiten normal und interagieren normal miteinander √ºber die interne Schnittstelle.  Wenn etwas schief geht, wissen Sie es nach maximal 8 Sekunden. <br><br><img src="https://habrastorage.org/files/f49/7ef/a1f/f497efa1ff1f427a860d4e61cdc5e13d.png" alt="Etwas ist schief gelaufen"><br><br>  Etwas ist schief gelaufen.  ESP8266 erhielt ein Firmware-Update √ºber Funk und der Mega-Teil des Systems zeichnete den Moment seines Neustarts auf.  Nach einigen Sekunden wird der ESP-Teil des Systems fortgesetzt und die Anzeige erlischt rot. <br><br>  Wenn Sie den Mauszeiger √ºber die Partnerstatusanzeige bewegen, wird zur Vereinfachung ein Hinweis angezeigt und die M√∂glichkeit, darauf zu klicken. In einem separaten Fenster wird die Schnittstelle des zweiten Teils des Systems, in diesem Fall des ESP-Teils, ge√∂ffnet.  Dies geschieht der Einfachheit halber. Sie k√∂nnen jederzeit mit einem Klick die Benutzeroberfl√§che des zweiten Teils des Systems √∂ffnen. <br><br><img src="https://habrastorage.org/files/d00/a61/a28/d00a61a28c6b439086a42e4510e896cb.png" alt="Tooltip f√ºr AMS"><br><br><h2>  Projektideen </h2><br>  Nun ein wenig dar√ºber, was Sie aus all dem machen k√∂nnen, mit ein bisschen Fantasie.  Das √ºbliche Board, das auf den ersten Blick v√∂llig diskret ist, erm√∂glicht es Ihnen, viele v√∂llig ungew√∂hnliche und interessante Dinge zu tun.  Dies gilt insbesondere f√ºr die Kombination mit dem Arduino Mega Server. <br><br>  Das erste, was mir in den Sinn kommt: <br><br>  <strong>Daten von Sensoren zwischen Steuerungen weiterleiten.</strong>  Auf beiden Seiten und in unbegrenzten Mengen.  Dies ist ein System, das die Vorteile beider Teile aufweist, und die M√∂glichkeiten summieren sich nicht nur, sondern es wird ein sogenannter synergistischer Effekt beobachtet. <br><br>  <strong>Die Br√ºcke zwischen den Schnittstellen.</strong>  Arduino Mega Server kann mit vielen Schnittstellen arbeiten. Mit diesem System k√∂nnen Sie Daten und Befehle zwischen verbundenen und drahtgebundenen Schnittstellen weiterleiten. <br><br>  <strong>Arbeiten Sie im selben Netzwerk,</strong> wenn Mega √ºber Ethernet Shield und ESP8266 √ºber Wi-Fi mit kabelgebundenen und kabellosen Ger√§ten im selben Netzwerk kommunizieren. <br><br>  <strong>Arbeiten Sie in verschiedenen Netzwerken,</strong> wenn Mega mit kabelgebundenem Ethernet und ESP8266 √ºber WLAN mit einem anderen Netzwerk verbunden ist und das System Befehle und Daten von einem Netzwerk zu einem anderen weiterleitet. <br><br>  <strong>Die Ausgabe eines Teils des Systems in der Schnittstelle eines anderen.</strong>  √úber Ethernet mit Standard-Web-Feeds oder √ºber eine interne serielle Verbindung. <br><br>  <strong>Debuggen</strong>  Ein Teil des Systems kann gem√§√ü Ihrem Programm als Debugger und Tester eines anderen Teils des Systems fungieren. <br><br>  <strong>Watchdog-Timer.</strong>  Jeder Controller kann als eine Art Watchdog in Bezug auf einen anderen fungieren. <br><br>  <strong>Protokollierungsfehler.</strong>  Jeder Controller kann Protokolle der Arbeit seines Partners f√ºhren, Statistiken erstellen und √ºber alarmierende Situationen berichten. <br><br>  <strong>Datenbank f√ºr ESP8266.</strong>  Mit diesem System k√∂nnen Sie so etwas wie eine SQL-Datenbank auf Mega f√ºr ESP8266 organisieren.  ESP erledigt seine Aufgabe und Mega fungiert als Speichersystem (bis zu 32 GB). <br><br>  <strong>Sich gegenseitig blinken.</strong>  Steuerungen k√∂nnen sich gem√§√ü der eingebetteten Logik oder beim Eintreffen eines externen Steuerbefehls dynamisch gegenseitig neu starten. <br><br>  <strong>Module anschlie√üen.</strong>  Controller k√∂nnen an verschiedene Peripherieger√§te angeschlossen werden, bei denen Probleme beim Anschlie√üen an einen Teil des Systems auftreten. <br><br>  Und so weiter und so fort, ich denke, ein neugieriger Leser wird in der Lage sein, selbst√§ndig viele nicht weniger interessante M√∂glichkeiten zu finden, um dieses System zu verwenden. <br><br><h2>  Fazit </h2><br>  Meiner Meinung nach ist dies eine sehr interessante L√∂sung, und wir m√ºssen RobotDyn f√ºr diese interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geb√ºhr</a> vielmals danken.  Zumindest sage ich das aufrichtig. <br><br>  Laden Sie das Arduino Mega Server-Distributionskit f√ºr RobotDyn Mega + ESP8266 herunter und √ºberpr√ºfen Sie pers√∂nlich die G√ºltigkeit aller hier beschriebenen Informationen. Sie k√∂nnen sie auf der offiziellen Website des Arduino Mega Server-Projekts im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Download-</a> Bereich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de402429/">https://habr.com/ru/post/de402429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de402417/index.html">Der Radfahrer kroch unbemerkt</a></li>
<li><a href="../de402419/index.html">Analysieren des neuen Nintendo Switch</a></li>
<li><a href="../de402421/index.html">Venuswoche in der n√∂rdlichen Hemisph√§re</a></li>
<li><a href="../de402423/index.html">Sprachpraxis offline</a></li>
<li><a href="../de402425/index.html">Chemiker sind die ersten, die die Vorteile von Quantencomputern sch√§tzen</a></li>
<li><a href="../de402431/index.html">ONYX BOOX Vasco Da Gama: schlauer als ein Buch, einfacher als ein Tablet</a></li>
<li><a href="../de402433/index.html">Geschichte der Wolkenkratzer</a></li>
<li><a href="../de402435/index.html">Digest "World Hi-Fi": tragbares Audio, Software, Formate und Vinyl</a></li>
<li><a href="../de402437/index.html">IPTV d√ºnner als RMB</a></li>
<li><a href="../de402439/index.html">Kommerzielle Geolokalisierung: Privatsph√§re ist billig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>