<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📒 💜 👩🏼‍🤝‍👨🏻 RobotDyn schlägt doppelt zu: Mega + ESP8266 ⏭️ 📦 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was macht ein Entwickler in seltenen Stunden der Freizeit? Das ist richtig, wenn Sie die Preislisten der Eisengeschäfte durchsuchen. Es gab eine freie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RobotDyn schlägt doppelt zu: Mega + ESP8266</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402429/"><img src="https://habrastorage.org/files/07a/66b/52f/07a66b52ff5d4326bcef6a7fd2749aef.jpg" alt="RobotDyn Mega + ESP8266"><br>  Was macht ein Entwickler in seltenen Stunden der Freizeit?  Das ist richtig, wenn Sie die Preislisten der Eisengeschäfte durchsuchen.  Es gab eine freie Minute und ich beschloss, die Seiten der beliebten Online-Shops zu durchsuchen - Langeweile, nichts Interessantes, wir haben das alles schon gesehen ... und dann fallen meine Augen plötzlich auf das nächste Mega.  Bah!  Ja, es ist nicht nur Mega, sondern kombiniert mit dem beliebten ESP8266 aller und sorgfältig ausgestattet mit Switches, damit zwei Controller zusammenarbeiten können - verkabelt (mit Ethernet Shield) mit viel GPIO und Wi-Fi für die drahtlose Kommunikation. <br><br>  Nicht schlecht!  Ich habe an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AMS</a> gedacht und mich daran erinnert - dort können Sie zwei Server installieren - verkabelt und drahtlos - und sie zu einem System verbinden. Der ESP8266 empfängt 54 digitale und 16 analoge Pins, und Mega erhält die drahtlose Steuerung über WLAN und alle ESP8266-Brötchen.  Vor langer Zeit bin ich nicht auf ein so interessantes Board gestoßen. <br><br>  - Guten Tag!  Haben Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mega + ESP8266-</a> Board? <br>  - Ja, aber wir haben nur noch einen. <br>  "Warum nur einer?" <br>  - Der Rest wurde auseinander genommen. <br>  "Reservieren Sie sie bitte für mich." <br><a name="habracut"></a><br><h2>  Ein paar Worte zum Unternehmen </h2><br>  Ich mochte RobotDyn zwei Dinge: das erste - mit seinen technologischen Lösungen.  Es ist nicht nötig, weit zu gehen. Ein hervorragendes Beispiel ist das betrachtete Mega + ESP8266-Board.  So etwas habe ich in unseren (und nicht in unseren, aber ich habe hier nicht wirklich danach gesucht) Online-Shops nicht gesehen.  Und dies ist nicht das einzige Beispiel, es gibt immer noch die Option Uno + ESP8266 und das Unternehmen wird hier eindeutig nicht aufhören, anscheinend warten immer noch viele interessante Geräte auf uns. <br><br>  Und das zweite ist die Preispolitik.  Ich werde hier nicht im Detail auf dieses Thema eingehen, aber ich werde sagen, dass mich die Preise angenehm überrascht haben - das Motto des Unternehmens lautet „Preise sind wie bei Aliexpress“. <br><br>  Kurz gesagt, ich habe den Hintergrund beschrieben, auf dem sich alle nachfolgenden Ereignisse entfalten werden. Jetzt gehen wir direkt zu den technischen Details und einer Beschreibung des Boards und wie man damit arbeitet. <br><br><h2>  Das Board selbst </h2><br>  Im Allgemeinen eine gewöhnliche Karte, die sich nicht wesentlich von vielen ähnlichen unterscheidet, wenn nicht für einen kleinen Teil, nämlich den in die Karte integrierten ESP8266EX-Chip.  Dies versetzt das Board sofort in die Kategorie der außergewöhnlichen Lösungen.  Ich möchte Ihre Aufmerksamkeit auf ein weiteres Detail lenken - kein Standardmodul vom Typ ESP-12 ist in die Platine integriert, sondern der Chip und die gesamte Verkabelung befinden sich auf der Platine selbst, was transparent auf die Ebene der Entwickler hinweist.  Ich möchte auch darauf hinweisen, dass die Karte sowohl eine gedruckte Antenne als auch einen Anschluss zum Anschließen einer externen Antenne hat, was in vielen Fällen sehr nützlich sein kann. <br><img src="https://habrastorage.org/files/1d1/cee/155/1d1cee155967488581228289df3b6f28.jpg" alt="RobotDyn Mega + ESP8266"><br>  Auf der Platine befinden sich Pin-Anschlüsse für den Anschluss an die ESP8266-Klemmen und mehrere Schalter, die etwas mehr zu erwähnen sind.  Die Hauptidee bei der Verwendung der Karte besteht darin, dass Sie mithilfe der Schalter das Zusammenspiel der drei Komponenten auf unterschiedliche Weise konfigurieren können: den Atmega2560-Chip, den ESP8266EX-Chip und den CH340G USB-TTL-Konverter.  Es sind sowohl einzelne als auch komplexe Verbindungen möglich, mit denen Sie viele Optionen für die Interaktion aller Teile der Platine organisieren können.  Dies eröffnet großartige Möglichkeiten für den Bau verschiedener Geräte, aber dazu später mehr. <br><br><img src="https://habrastorage.org/files/cb4/2f4/819/cb42f4819ba940369ad71818bbc7ff03.jpg" alt="ESP8266-Stifte"><br><br>  Ich möchte auch die anständige Tragfähigkeit des Boards beachten.  Gemessen an den Beschriftungen kann es einen Laststrom von 1,6 A auf einem 5-Volt-Kanal und 1 A auf einem 3,3-Volt-Kanal liefern.  Das ist sehr gut, vor allem insgesamt. <br><br>  Über das Board gibt es nichts mehr zu sagen. Wir wenden uns der Installation und dem Testen der Software zu. <br><br><h2>  Board-Tests </h2><br>  Da die Platine integriert ist und praktisch kein freier Speicherplatz vorhanden ist und die Verdrahtung des Hochfrequenzteils des ESP8266EX darauf erfolgt, entstanden zunächst Zweifel an der korrekten und störungsfreien Funktionsweise dieser gesamten Wirtschaft. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass trotz meiner Bedenken alles stabil und wie erwartet funktioniert.  Wir verbinden die Schalter auf der Atmega2560-Karte mit USB - wir bekommen den Arduino Mega, wir verbinden den ESP8266EX mit USB - wir bekommen den ESP8266, wir wechseln in den Verbindungsmodus des Atmega2560 mit dem ESP8266EX, wir bekommen die Verbindung zwischen den Chips über die serielle Schnittstelle.  Alles funktioniert genau so, wie es in der Dokumentation beschrieben ist und genau so, wie es intuitiv erwartet wird. <br><br>  Ein großes Plus dieser Lösung ist, dass die Entwickler darauf geachtet haben, die logischen Signalpegel aller Systemkomponenten anzupassen.  Jeder, der manuell versucht hat, das ESP8266-Modul zu konfigurieren und alle Pull-up-Widerstände korrekt anzuschließen, wird mich verstehen.  Es gibt keine derartigen Probleme. Ihre gesamte Arbeit beschränkt sich auf das Klicken auf die Schalter auf der Platine gemäß den Anweisungen des Herstellers. <br><br><h2>  Lasttest </h2><br>  Wie teste ich das Board?  Sie können eine Standardskizze herunterladen, aber es wird ein Test über nichts sein.  Diese Option funktioniert möglicherweise einwandfrei und unter Kampfbedingungen fällt das System aus.  Daher wurde die Arbeit beider Teile unter der Kontrolle der entsprechenden Versionen des Arduino Mega Servers als Hartlasttest ausgewählt.  Für Mega - Arduino Mega Server für Mega und für ESP8266 - Arduino Mega Server für ESP8266 in Version M1. <br><br>  Das M1-Verteilungskit wurde ausgewählt, da nur 1 MB Flash-Speicher für ESP8266 auf der Karte installiert ist.  Dies ist meiner Meinung nach fast der einzige Fehler für Entwickler - in zukünftigen Revisionen des Boards würde ich empfehlen, 4 MB Speicherchips einzusetzen.  Der Preisunterschied ist gering und die Möglichkeiten bei Verwendung der Version mit 4 MB sind viel größer.  Da es jedoch eine AMS-Version für Systeme mit 1 MB gibt, habe ich diesem Punkt nicht viel Aufmerksamkeit geschenkt und die Tests fortgesetzt. <br><br>  Was soll ich sagen?  Wir schalten das Board ein, füllen die Software aus und erhalten zwei unabhängige Server.  Eine drahtlos über Ethernet Shield und eine drahtlos über WLAN.  Schönheit! <br><br>  Ich möchte auch darauf hinweisen, dass selbst das Hinzufügen eines Ethernet Shield mit einem Kartenleser zu diesem bereits hoch entwickelten System keine Konflikte oder Fehler verursachte - alles hat einfach so geklappt, wie es funktionieren sollte.  In einigen Fällen ist es sogar noch besser als gewöhnlich - dies ist die erste Karte, auf der die drahtlose Firmware des ESP8266 in 100% der Fälle erfolgreich war. Auf allen anderen Karten und Modulen treten von Zeit zu Zeit Fehler mit einem solchen Blinken auf. <br><br>  Und zwei Server drehen sich, laden das Board, erfüllen ihre Aufgaben und ... das ist alles.  Alles funktioniert einfach, es gibt nichts zu sagen, aber dies ist wahrscheinlich das beste Lob für jedes technische System. <br><br><h2>  Am interessantesten </h2><br>  Was ich hier beschrieben habe, ist aus rein akademischer Sicht interessant: ein interessantes Board, eine interessante technische Lösung, aber natürlich interessiert uns seine praktische Anwendung.  Was ist das praktische und angewandte Highlight? <br><br>  Tatsache ist, dass Sie mit einem Schalter auf der Platine zwei ihrer Teile (Mega und ESP) zu einer Einheit verbinden können, um erstens ein neues Qualitätssystem zu erhalten und zweitens die inhärenten Mängel jedes einzelnen Teils zu kompensieren. <br><br>  Beginnen wir mit dem ESP8266.  Der Hauptnachteil dieser im Allgemeinen ausgezeichneten Lösung ist das katastrophale Fehlen von GPIO-Pins.  Wie sie sagen, eins, zwei und falsch berechnet.  Es ist schwer zu sagen, was die Entwickler dieses Chips dachten, aber vor der Veröffentlichung von ESP32 hatten sie etwas mehr Zeit zum Nachdenken und haben dieses Manko im neuen Chip behoben.  Wir haben es aber speziell mit 8266 zu tun. <br><br>  Mit diesem Board können Sie ein Pferd bewegen und die volle Leistung von Mega nutzen. Dies sind unter anderem 54 digitale und 16 analoge Ausgänge im ESP8266.  Das heißt, unser klappriges ESP bietet plötzlich großartige Möglichkeiten für die Arbeit mit Sensoren, Aktoren und anderen Peripheriegeräten.  Es stellt sich sozusagen heraus, Baby ESP auf Steroiden. <br><br>  Dies ist nur eine der möglichen Optionen für die Verwendung der auf der Oberfläche liegenden Platte. <br><br>  Nun schauen wir uns Mega an.  Sie stört die drahtlose Schnittstelle und die Fähigkeit zur Interaktion mit Wi-Fi-Geräten nicht, wodurch sie in den ESP-Teil des Systems integriert werden kann.  Gleichzeitig bleibt die Möglichkeit des Parallelbetriebs über eine kabelgebundene Ethernet-Schnittstelle bestehen. <br><br>  Und dies ist auch nur eine der möglichen Anwendungen für dieses Board, das auf der Oberfläche liegt. <br><br>  Nun, verschiedene Bridge-Optionen: Ethernet - Wi-Fi, nRF24 - Ethernet, nRF24 - Wi-Fi, nRF24 (1) - nRF24 (2), nooLite - Wi-Fi, nooLite - Ethernet, nooLite (1) - nooLite (2) ) usw. usw. bis unendlich.  Sie können Signale von Dutzenden von Subsystemen, mit denen der Arduino Mega Server arbeitet, zwischen den beiden Teilen der Karte und den mit ihnen verbundenen Schnittstellen weiterleiten. <br><br>  Ich weiß nicht einmal, was ich sagen soll.  Sehr cool. <br><br><h2>  Technische Details </h2><br>  Nun ein wenig zu den technischen Details.  Sie sehen eine Tabelle, in der alle möglichen Betriebsarten der Karte dargestellt und alle möglichen Positionen der Schalter darauf angezeigt werden.  Betrachten wir kurz jeden Modus. <br><br><img src="https://habrastorage.org/files/a51/cc7/874/a51cc7874a274215b06fc93c7d7dbd4d.png" alt="Tabelle der Betriebsmodi der RobotDyn-Karte"><br><br><h4>  Arduino Mega 2560 </h4><br>  Die einfachste Funktionsweise des Boards, in der Tabelle als Modus 3 bezeichnet. Wenn Sie die Schalter 3 und 4 auf ON und den Rest auf OFF stellen, erhalten Sie den üblichen Arduino Mega 2560. Nichts Interessantes, aus diesem Grund hat sich der Kauf dieses Boards nicht gelohnt war das übliche Mega zu kaufen. <br><br><h4>  ESP8266 </h4><br>  Auch keine sehr interessante Funktionsweise.  In der Tabelle ist es in zwei Untermodi unterteilt, die als 1 (Laden der Skizze in ESP) und 2 (Verbindungsmodus von ESP zu USB) bezeichnet werden.  Dies ist die gesamte Funktionalität des Standard-ESP8266, und für eine solche Verwendung hat es sich auch nicht gelohnt, dieses Board zu kaufen. Sie könnten mit dem üblichen ESP-Modul auskommen. <br><br><h4>  Alle sind unabhängig </h4><br>  Wir betrachten diese Option auch bei Nummer 6 nicht, da darin alle Verbindungen zwischen den Teilen der Platine unterbrochen sind und sie für uns definitiv für nichts nützlich sein kann. <br><br><h4>  Die Verbindung zwischen Mega und ESP </h4><br>  In diesem als 5 bezeichneten Modus wird die Kommunikation zwischen Mega und ESP über eine serielle Schnittstelle hergestellt, es findet jedoch keine Kommunikation mit dem USB-TTL-Konverter statt.  ESP verwendet Standard Serial, während Mega nicht weniger Standard Serial3 verwendet.  Die Verbindung funktioniert stabil und nahtlos mit einer Geschwindigkeit von 115200. Dies ist eine ziemlich spezifische Betriebsart, wenn kein Controller über eine USB-Verbindung verfügt.  Und so ist er auch für uns nicht sehr interessant. <br><br><h4>  Kommunikation zwischen Mega und ESP sowie Mega und USB gleichzeitig </h4><br>  Aber das nennt man Trumpfkarte.  Wir bekommen alles auf einmal - die Mega-USB-Verbindung und die Möglichkeit, Skizzen auf Mega hochzuladen und den Betrieb über denselben USB zu steuern, die Möglichkeit der Kommunikation zwischen Mega und ESP und die Möglichkeit, Skizzen auf den ESP8266 hochzuladen und den Betrieb über die USB-Schnittstelle zu steuern ... Mega!  Das heißt, volle Füllung, nicht direkt die Registrierkasse verlassen. <br><br>  Dies ist die einzig richtige Betriebsart, die in der Tabelle aufgeführt ist.  Erinnern Sie sich an seine Gewinnzahl, die vier ist.  In der Konfiguration der Schalter auf der Platine sieht es auch schön aus - 1, 2, 3, 4 sind in der EIN-Position, der Rest ist AUS. <br><br>  Ein aufmerksamer Leser wird fragen: Wie können wir Skizzen auf den ESP8266 hochladen, wenn der USB-Anschluss gerade mit dem Mega-Teil des Systems verbunden ist?  Und das ist die richtige Frage, die Antwort ist auf keinen Fall.  Und warum schreiben Sie dann, dass wir in dieser Konfiguration Skizzen auf ESP8266 hochladen können?  Da der Arduino Mega Server die Möglichkeit hat, Skizzen über die Luft direkt von der Arduino IDE herunterzuladen, indem Sie ein paar Tasten drücken, ist das richtig - wir haben die volle Füllung, alles funktioniert sofort. <br><br>  Aber was ist mit denen, die das Board ohne Arduino Mega Server nutzen wollen?  Es gibt nur zwei Möglichkeiten: Entweder klicken Sie ständig auf die Schalter oder Sie können Skizzen in Ihren Entwürfen durch die Luft herunterladen.  Ich persönlich mag die zweite Option mehr. <br><br><h2>  Arduino IDE-Einstellungen </h2><br>  Die Arduino IDE-Einstellungen für Mega werfen keine Fragen auf, dort ist alles Standard, und für ESP8266 werde ich einen Screenshot des Menüs mit Einstellungen für eine bestimmte Implementierung des ESP-Teils auf der RobotDyn-Karte geben.  Sie müssen dieselben Parameter für sich selbst festlegen, mit Ausnahme der Portnummer - auf Ihrem System hat sie höchstwahrscheinlich einen anderen Wert. <br><br><img src="https://habrastorage.org/files/e1f/d98/bac/e1fd98bacc664b7e931699cb65b1c6ae.png" alt="ESP8266 Einstellungen in der Arduino IDE"><br><br><h2>  Arduino Mega Server für RobotDyn Mega + ESP8266 </h2><br>  Für dieses Board wurde eine spezielle Dual-Version des Arduino Mega Servers veröffentlicht, die zwei Server gleichzeitig enthält, die speziell für dieses Board optimiert wurden.  Dies steht außer Frage. Beide Server enthalten Standardfunktionen und können für jedes Ihrer Projekte verwendet werden. <br><br>  Sie können beide Server unabhängig voneinander auf derselben Karte verwenden oder die erforderlichen Funktionen hinzufügen und sie im Tandem- und Bridge-Modus zwischen zwei Netzwerken und allen mit den Servern verbundenen Schnittstellen verwenden. <br><br>  Die erste Arduino Mega Server-Baugruppe für die RobotDyn Mega + ESP8266-Karte enthält ein Testbeispiel für die Interaktion zweier Controller über eine serielle Schnittstelle.  Dies ist eine Demonstration der Fähigkeiten der Technologie, auf deren Grundlage Sie Ihre eigenen Lösungen entwickeln können. <br><br>  Nun etwas mehr zur Entwicklung eines Protokolls für die Interaktion zweier Controller über die serielle Schnittstelle im Allgemeinen und auf dieser Karte im Besonderen. <br><br><h2>  Protokollentwicklung </h2><br>  Was sollen wir ein Haus bauen?  Müssen Sie ein Interaktionsprotokoll zwischen den beiden Teilen des Systems über die serielle Schnittstelle entwickeln?  - Wir werden uns entwickeln, hier geht es hauptsächlich darum, die Aufgabe klar und richtig zu setzen.  Um den Tandembetrieb des Systems zu demonstrieren, zeigen wir die Betriebsanzeigen des Partners im Dashpanel jedes Servers an. <br><br>  <em><strong>Ein bisschen über Terminologie.</strong></em>  <em>Für Mega ist der „Partner“ ESP8266, für ESP8266 Mega.</em> <br><br>  Wenn der Partner arbeitet, leuchtet die Anzeige grünlich, wenn sie nicht arbeitet, rot und grau, wenn der Status nicht definiert ist.  Dies ist sehr praktisch - während des Betriebs sehen Sie sofort den Zustand des Alter Ego Ihres Systems. <br><br>  Für eine praktische Lösung dieses Problems gibt es genau eine Million Möglichkeiten. Wir wählen Folgendes aus: Kommunikationsblöcke beider Teile des Systems sind identisch, Interaktion erfolgt im Vollduplexmodus, Informationsblöcke haben ein einfaches und klares Format: <br><br><pre><code class="java hljs">?=</code> </pre> <br>  oder <br><br><pre> <code class="java hljs">?</code> </pre><br>  Dies ist nur ein Testbeispiel zum Lösen der Aufgabe. Sie können dieses Interaktionsprotokoll ändern oder ein eigenes schreiben, das für Ihre Aufgaben geeignet ist.  Mit dem bereits implementierten Protokoll können Sie jedoch nicht nur den Status des Partners überwachen, sondern ihn auch für viele andere Zwecke verwenden, z. B. den Status der Controller-Pins, den Status von Sensoren übertragen oder Steuerbefehle an den Partner senden. <br><br>  Insbesondere in unserem System sehen Teams folgendermaßen aus: <br><br>  <strong>? mega = 1</strong> - Mega sendet Daten über seine Leistung.  Parameter "mega", Wert "1". <br><br>  <strong>? esp = 1</strong> - ESP8266 sendet Daten über seinen Zustand.  Der Parameter ist "esp", der Wert ist "1". <br><br>  Betrachten Sie beispielsweise die Implementierung des Protokolls für den Mega-Teil des Systems. <br><br>  Standardmäßig initialisieren wir das AMS-Modul und die Serial3 Mega-Hardware mit einer Geschwindigkeit von 115200. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial3.begin(<span class="hljs-number"><span class="hljs-number">115200</span></span>); modulRobotdyn = MODUL_ENABLE; started(<span class="hljs-string"><span class="hljs-string">"RobotDyn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre><br>  Wir überprüfen den Status des Serial3-Ports und bilden bei Daten vom Partner die Zeichenfolgenvariable serialReq, die die empfangenen Daten oder Befehle enthält. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Serial3.available() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sFlag) { serialReq = <span class="hljs-string"><span class="hljs-string">""</span></span>; sFlag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = Serial3.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">10</span></span>) { sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; parseSerialStr(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">13</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial()</span></span></code> </pre><br>  Wir analysieren die Befehle und Daten und ergreifen bei Informationen über den Status des Partners Maßnahmen in Form einer Änderung des Status der esp-Variablen. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseSerialCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String command, parameter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pBegin = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"?"</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pParam = serialReq.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { command = serialReq.substring(pBegin); parameter = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command != F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { Serial.print(F(<span class="hljs-string"><span class="hljs-string">"command/parameter: "</span></span>)); Serial.print(command); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); Serial.println(parameter); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd()</span></span></code> </pre><br>  Sie können die Verarbeitung anderer Befehle einfach hinzufügen, indem Sie den entsprechenden Codeabschnitt ändern und hinzufügen. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == F(<span class="hljs-string"><span class="hljs-string">"esp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter == F(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)) { esp = <span class="hljs-number"><span class="hljs-number">1</span></span>; espTimer = millis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Wenn Sie in Ihren eigenen Projekten und beim Parsen viele Befehle und Daten verwenden, ist es besser, diesen Codeabschnitt in Form entsprechender Funktionen zu entwerfen. <br><br>  Es bleibt nur die Standardfunktion des AMS-Moduls zu berücksichtigen, das für seine Arbeit verantwortlich ist.  Zuerst wird der Portstatus überprüft, dann wird alle vier Sekunden ein Befehl an den Partner gesendet, dass Mega lebt und funktioniert, und die Zeit, die seit dem Empfang der letzten Daten vom Partner vergangen ist, wird überprüft. Wenn sie 8 Sekunden überschreitet, wird der Schluss gezogen, dass der Partner nicht funktioniert. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">robotdynWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkSerial(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle4s) { Serial3.println(F(<span class="hljs-string"><span class="hljs-string">"?mega=1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (millis() - espTimer &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) { esp = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Das ist alles Magie.  Stimmt, nichts kompliziertes? <br><br><div class="spoiler">  <b class="spoiler_title">Vollständiger Code des Moduls, das für die systemübergreifende Kommunikation zwischen Mega 2560 und ESP8266 verantwortlich ist</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Modul RobotDyn part of Arduino Mega Server project */</span></span> #ifdef ROBOTDYN_FEATURE bool sFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> espTimer = millis(); <span class="hljs-comment"><span class="hljs-comment">// Serial request #define MAX_SERIAL_REQ 32 String serialReq = ""; void robotdynInit() { Serial3.begin(115200); modulRobotdyn = MODUL_ENABLE; started("RobotDyn", true); } void printSerialStr() { Serial.print("["); Serial.print(serialReq); Serial.println("]"); } void parseSerialCmd() { String command, parameter; if (serialReq.indexOf(F("?")) &gt;= 0) { int pBegin = serialReq.indexOf(F("?")) + 1; if (serialReq.indexOf(F("=")) &gt;= 0) { int pParam = serialReq.indexOf(F("=")); command = serialReq.substring(pBegin, pParam); parameter = serialReq.substring(pParam + 1); } else { command = serialReq.substring(pBegin); parameter = ""; } // if (command != F("esp")) { Serial.print(F("command/parameter: ")); Serial.print(command); Serial.print(F("/")); Serial.println(parameter); //} if (command == F("esp")) { if (parameter == F("1")) { esp = 1; espTimer = millis(); } else { esp = 0; } } } // if (request.indexOf(F("?")) &gt;= 0) } // parseSerialCmd() void parseSerialStr() { if (serialReq[0] == '?') { parseSerialCmd(); } else { printSerialStr(); } } void checkSerial() { while (Serial3.available() &gt; 0) { if (sFlag) { serialReq = ""; sFlag = false; } char c = Serial3.read(); if (c == 10) { sFlag = true; parseSerialStr(); } else if (c == 13) { // skip } else { if (serialReq.length() &lt; MAX_SERIAL_REQ) { serialReq += c; } } // if } // while (Serial3.available() &gt; 0) } // checkSerial() void robotdynWork() { checkSerial(); if (cycle4s) { Serial3.println(F("?mega=1")); if (millis() - espTimer &gt; 8000) { esp = 0; } } } #endif // ROBOTDYN_FEATURE</span></span></code> </pre><br></div></div><br><h2>  Wie die Ausgabe im seriellen Monitor aussieht </h2><br>  Im Mega 2560 Serial Monitor sehen die Ausgabe, Daten und Befehle des ESP-Teils des Systems genauso aus wie die eigenen.  Um die Ausgabe des Partners von der Ausgabe von Mega zu unterscheiden, werden seine Daten in eckige Anführungszeichen gesetzt.  In diesem Fall sehen Sie den Neustart des ESP8266 und das AMS-Startprotokoll im seriellen Monitor von Mega. <br><br><img src="https://habrastorage.org/files/a03/904/3b8/a039043b86d442d7a54e10bb73b314c7.png" alt="ESP8266-Ausgabe an den Monitor der Mega 2560-Serie"><br><br>  Und das Protokoll des tatsächlichen Befehlsaustauschs zwischen den beiden Teilen des Systems über die serielle Schnittstelle.  Sie sehen die Ausgabe von ESP8266 mit Informationen zum Dekodieren von Mega-Statusdaten in der seriellen Schnittstelle von Mega, die in eckigen Anführungszeichen eingeschlossen sind. <br><br><img src="https://habrastorage.org/files/b5f/444/6cf/b5f4446cf54c4c048fa568f1e3418823.png" alt="ESP8266 Ausgabe bei Mega Command Decoding"><br><h2>  Schönheit in der Schnittstelle </h2><br>  Nun ein wenig darüber, wie alles in der Arduino Mega Server-Oberfläche aussieht.  Zu Beginn werde ich Screenshots von beiden Teilen des Systems bei der Arbeit geben. <br><br><img src="https://habrastorage.org/files/774/faf/c92/774fafc92eb54ba29905a6ec201501da.png" alt="Arduino Mega Server für RobotDyn Mega + ESP8266"><br><br>  Ellipsen sind um Inschriften eingekreist, die den Controller und den Teil des Systems identifizieren, mit dem Sie gerade arbeiten.  Kreise werden um Indikatoren eingekreist, die den Status des Partners anzeigen.  Im Moment ist alles in Ordnung, beide Teile des Systems arbeiten normal und interagieren normal miteinander über die interne Schnittstelle.  Wenn etwas schief geht, wissen Sie es nach maximal 8 Sekunden. <br><br><img src="https://habrastorage.org/files/f49/7ef/a1f/f497efa1ff1f427a860d4e61cdc5e13d.png" alt="Etwas ist schief gelaufen"><br><br>  Etwas ist schief gelaufen.  ESP8266 erhielt ein Firmware-Update über Funk und der Mega-Teil des Systems zeichnete den Moment seines Neustarts auf.  Nach einigen Sekunden wird der ESP-Teil des Systems fortgesetzt und die Anzeige erlischt rot. <br><br>  Wenn Sie den Mauszeiger über die Partnerstatusanzeige bewegen, wird zur Vereinfachung ein Hinweis angezeigt und die Möglichkeit, darauf zu klicken. In einem separaten Fenster wird die Schnittstelle des zweiten Teils des Systems, in diesem Fall des ESP-Teils, geöffnet.  Dies geschieht der Einfachheit halber. Sie können jederzeit mit einem Klick die Benutzeroberfläche des zweiten Teils des Systems öffnen. <br><br><img src="https://habrastorage.org/files/d00/a61/a28/d00a61a28c6b439086a42e4510e896cb.png" alt="Tooltip für AMS"><br><br><h2>  Projektideen </h2><br>  Nun ein wenig darüber, was Sie aus all dem machen können, mit ein bisschen Fantasie.  Das übliche Board, das auf den ersten Blick völlig diskret ist, ermöglicht es Ihnen, viele völlig ungewöhnliche und interessante Dinge zu tun.  Dies gilt insbesondere für die Kombination mit dem Arduino Mega Server. <br><br>  Das erste, was mir in den Sinn kommt: <br><br>  <strong>Daten von Sensoren zwischen Steuerungen weiterleiten.</strong>  Auf beiden Seiten und in unbegrenzten Mengen.  Dies ist ein System, das die Vorteile beider Teile aufweist, und die Möglichkeiten summieren sich nicht nur, sondern es wird ein sogenannter synergistischer Effekt beobachtet. <br><br>  <strong>Die Brücke zwischen den Schnittstellen.</strong>  Arduino Mega Server kann mit vielen Schnittstellen arbeiten. Mit diesem System können Sie Daten und Befehle zwischen verbundenen und drahtgebundenen Schnittstellen weiterleiten. <br><br>  <strong>Arbeiten Sie im selben Netzwerk,</strong> wenn Mega über Ethernet Shield und ESP8266 über Wi-Fi mit kabelgebundenen und kabellosen Geräten im selben Netzwerk kommunizieren. <br><br>  <strong>Arbeiten Sie in verschiedenen Netzwerken,</strong> wenn Mega mit kabelgebundenem Ethernet und ESP8266 über WLAN mit einem anderen Netzwerk verbunden ist und das System Befehle und Daten von einem Netzwerk zu einem anderen weiterleitet. <br><br>  <strong>Die Ausgabe eines Teils des Systems in der Schnittstelle eines anderen.</strong>  Über Ethernet mit Standard-Web-Feeds oder über eine interne serielle Verbindung. <br><br>  <strong>Debuggen</strong>  Ein Teil des Systems kann gemäß Ihrem Programm als Debugger und Tester eines anderen Teils des Systems fungieren. <br><br>  <strong>Watchdog-Timer.</strong>  Jeder Controller kann als eine Art Watchdog in Bezug auf einen anderen fungieren. <br><br>  <strong>Protokollierungsfehler.</strong>  Jeder Controller kann Protokolle der Arbeit seines Partners führen, Statistiken erstellen und über alarmierende Situationen berichten. <br><br>  <strong>Datenbank für ESP8266.</strong>  Mit diesem System können Sie so etwas wie eine SQL-Datenbank auf Mega für ESP8266 organisieren.  ESP erledigt seine Aufgabe und Mega fungiert als Speichersystem (bis zu 32 GB). <br><br>  <strong>Sich gegenseitig blinken.</strong>  Steuerungen können sich gemäß der eingebetteten Logik oder beim Eintreffen eines externen Steuerbefehls dynamisch gegenseitig neu starten. <br><br>  <strong>Module anschließen.</strong>  Controller können an verschiedene Peripheriegeräte angeschlossen werden, bei denen Probleme beim Anschließen an einen Teil des Systems auftreten. <br><br>  Und so weiter und so fort, ich denke, ein neugieriger Leser wird in der Lage sein, selbständig viele nicht weniger interessante Möglichkeiten zu finden, um dieses System zu verwenden. <br><br><h2>  Fazit </h2><br>  Meiner Meinung nach ist dies eine sehr interessante Lösung, und wir müssen RobotDyn für diese interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gebühr</a> vielmals danken.  Zumindest sage ich das aufrichtig. <br><br>  Laden Sie das Arduino Mega Server-Distributionskit für RobotDyn Mega + ESP8266 herunter und überprüfen Sie persönlich die Gültigkeit aller hier beschriebenen Informationen. Sie können sie auf der offiziellen Website des Arduino Mega Server-Projekts im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Download-</a> Bereich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de402429/">https://habr.com/ru/post/de402429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de402417/index.html">Der Radfahrer kroch unbemerkt</a></li>
<li><a href="../de402419/index.html">Analysieren des neuen Nintendo Switch</a></li>
<li><a href="../de402421/index.html">Venuswoche in der nördlichen Hemisphäre</a></li>
<li><a href="../de402423/index.html">Sprachpraxis offline</a></li>
<li><a href="../de402425/index.html">Chemiker sind die ersten, die die Vorteile von Quantencomputern schätzen</a></li>
<li><a href="../de402431/index.html">ONYX BOOX Vasco Da Gama: schlauer als ein Buch, einfacher als ein Tablet</a></li>
<li><a href="../de402433/index.html">Geschichte der Wolkenkratzer</a></li>
<li><a href="../de402435/index.html">Digest "World Hi-Fi": tragbares Audio, Software, Formate und Vinyl</a></li>
<li><a href="../de402437/index.html">IPTV dünner als RMB</a></li>
<li><a href="../de402439/index.html">Kommerzielle Geolokalisierung: Privatsphäre ist billig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>