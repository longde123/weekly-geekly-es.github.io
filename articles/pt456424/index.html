<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ ü¶Ü üíÉ Utreexo: compactando muito Bitcoin UTXO üë∞ üö¢ üîô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 


 Na rede Bitcoin, todos os n√≥s concordam por consenso sobre os muitos UTXOs: quantas moedas est√£o dispon√≠veis para gastar, com quem e em ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: compactando muito Bitcoin UTXO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Ol√° Habr! </p><br><p>  Na rede Bitcoin, todos os n√≥s concordam por consenso sobre os muitos UTXOs: quantas moedas est√£o dispon√≠veis para gastar, com quem e em que condi√ß√µes.  Um conjunto de UTXOs √© um conjunto de dados que √© minimamente necess√°rio para um n√≥ validador, sem o qual um n√≥ n√£o pode verificar a validade das transa√ß√µes recebidas e dos blocos que as cont√™m. </p><br><p>  Nesse sentido, s√£o feitas tentativas em todos os aspectos para reduzir a representa√ß√£o armazenada desse conjunto, para compact√°-lo sem perda de garantias de seguran√ßa.  Quanto menor o volume de dados armazenados, menores os requisitos de espa√ßo em disco do n√≥ validador, o que torna mais barato o lan√ßamento do n√≥ validador, permite expandir a rede e, assim, aumentar a estabilidade da rede. </p><br><p>  Nesta nota, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abordaremos</a> o prot√≥tipo Rust de uma proposta recente do co-autor do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Utreexo: um acumulador din√¢mico baseado em hash otimizado para o conjunto Bitcoin UTXO</a> , que reduz os requisitos de espa√ßo em disco para n√≥s validadores. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Qual √© o problema? </h2><br><p>  Um dos problemas eternos do Bitcoin era sua escalabilidade.  A id√©ia de "possuir um banco" exige que os participantes da rede acompanhem todos os fundos dispon√≠veis para uso.  No Bitcoin, os fundos dispon√≠veis s√£o expressos como um conjunto de sa√≠das n√£o gastas - conjunto UTXO.  Embora essa n√£o seja uma vis√£o muito intuitiva, √© vantajosa em termos de desempenho da implementa√ß√£o, em compara√ß√£o com uma vis√£o em que cada carteira tem um "equil√≠brio" como uma entrada separada e tamb√©m adiciona privacidade (por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoinJoin</a> fornece trabalho). </p><br><p>  √â importante distinguir entre um hist√≥rico de transa√ß√µes (o que √© chamado de blockchain) e o estado atual do sistema.  O hist√≥rico de transa√ß√µes do Bitcoin atualmente ocupa cerca de 200 GB de espa√ßo em disco e continua a crescer.  No entanto, o estado do sistema √© muito menor, cerca de 4 GB, e leva em conta apenas o fato de algu√©m possuir atualmente moedas.  O volume desses dados tamb√©m aumenta com o tempo, mas a uma taxa muito mais baixa e, √†s vezes, at√© tende a diminuir (consulte KDPV). </p><br><p>  Os clientes Light (SPVs) trocam garantias de seguran√ßa pela capacidade de n√£o armazenar nenhum estado m√≠nimo (conjunto UTXO), exceto chaves privadas. </p><br><h2 id="utxo-i-utxo-set">  Conjunto UTXO e UTXO </h2><br><p>  UTXO (Sa√≠da de transa√ß√£o n√£o gasta) - sa√≠da de transa√ß√£o n√£o gasta, o ponto final da jornada de cada satoshi transmitido nas transa√ß√µes.  As sa√≠das n√£o gastas se tornam entradas de novas transa√ß√µes e, ao mesmo tempo, gastam e s√£o removidas do conjunto UTXO. </p><br><p>  Novos UTXOs s√£o sempre criados por transa√ß√µes: </p><br><ul><li>  transa√ß√µes com base de moedas sem insumos: crie novos UTXOs durante a emiss√£o de moedas por mineradores </li><li>  transa√ß√µes convencionais: crie novos UTXOs, gastando algum conjunto de UTXOs existentes </li></ul><br><p>  O processo de trabalho com o UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  As carteiras consideram o n√∫mero de moedas dispon√≠veis para gastar (saldo) com base na quantidade de UTXO dispon√≠vel para essa carteira para gastar. </p><br><p>  Cada n√≥ validador, para evitar tentativas de gasto duplo, deve rastrear a cole√ß√£o de <strong>todos os</strong> UTXOs durante a verifica√ß√£o de <strong>cada</strong> transa√ß√£o de <strong>cada</strong> bloco. </p><br><p>  O n√≥ deve ter l√≥gica: </p><br><ul><li>  Adi√ß√µes ao conjunto UTXO </li><li>  Exclus√µes do conjunto UTXO </li><li>  Verifica a presen√ßa de um √∫nico UTXO no conjunto </li></ul><br><p>  Existem maneiras de reduzir os requisitos de informa√ß√µes armazenadas sobre o conjunto, mantendo a capacidade de adicionar e remover elementos, verificar e provar a exist√™ncia de um elemento no conjunto usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baterias criptogr√°ficas</a> . </p><br><h2 id="akkumulyatory-dlya-utxo">  Baterias para UTXO </h2><br><p>  A id√©ia de usar baterias para armazenar muitos UTXOs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foi discutida</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> . </p><br><p>  O conjunto UTXO √© constru√≠do em tempo real, durante o carregamento inicial da cadeia de blocos (IBD, download inicial de bloco), √© armazenado total e constantemente, enquanto seu conte√∫do muda ap√≥s o processamento de transa√ß√µes de cada bloco de rede novo e correto.  Esse processo requer o download de aproximadamente 200 GB de blocos de dados e a verifica√ß√£o de centenas de milh√µes de assinaturas digitais.  Ap√≥s a conclus√£o do processo IBD, o res√≠duo seco UTXO-set ocupar√° cerca de 4 GB. </p><br><p>  No entanto, ao usar baterias, as regras de consenso relativas aos fundos se resumem √† verifica√ß√£o e gera√ß√£o de evid√™ncias criptogr√°ficas, e o √¥nus de rastrear os fundos dispon√≠veis √© colocado sobre os ombros do propriet√°rio desses fundos, o que fornece evid√™ncias de sua presen√ßa e propriedade. </p><br><p>  A bateria pode ser chamada de representa√ß√£o compacta do aparelho.  O tamanho da visualiza√ß√£o armazenada, neste caso, deve ser constante <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-29" x="1653" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  , ou aumentar sublinearmente em rela√ß√£o √† pot√™ncia do conjunto e tamanho do pr√≥prio elemento, por exemplo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-29" x="3797" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  onde n √© a pot√™ncia do conjunto armazenado. </p><br><p>  Nesse caso, o acumulador deve permitir gerar evid√™ncias da inclus√£o de um elemento no conjunto (prova de inclus√£o) e permitir verificar efetivamente essa prova. </p><br><p>  Uma bateria √© chamada <strong>din√¢mica</strong> se permitir adicionar e remover itens do aparelho. </p><br><p>  Um exemplo dessa bateria √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bateria RSA proposta por Boneh, Bunz, Fisch em dezembro de 2018</a> .  Essa bateria tem um tamanho constante da exibi√ß√£o armazenada, mas requer um <em>segredo compartilhado</em> (configura√ß√£o confi√°vel).  Esse requisito nega a aplicabilidade desse acumulador para redes sem confian√ßa, como o Bitcoin, pois o vazamento de dados durante a gera√ß√£o de um segredo pode permitir que os invasores criem evid√™ncias falsas da exist√™ncia do UTXO, falsificando n√≥s com um conjunto de UTXO baseado nesse acumulador. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  O projeto Thaddeus Dryja proposto pela Utreexo permite criar uma bateria <strong>din√¢mica</strong> <strong>sem</strong> uma configura√ß√£o confi√°vel. </p><br><p>  Utreexo √© uma floresta ideal de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores Merkle</a> bin√°rias e √© um desenvolvimento das id√©ias apresentadas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acumuladores ass√≠ncronos eficientes para pki distribu√≠do</a> , adicionando a capacidade de remover elementos do conjunto. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  A estrutura l√≥gica da bateria </h4><br><p>  As c√©lulas da bateria est√£o dispostas em uma floresta de √°rvores bin√°rias perfeitas.  As √°rvores s√£o ordenadas por altura.  Esta apresenta√ß√£o foi escolhida como a mais visual e permite visualizar a fus√£o de √°rvores durante as opera√ß√µes na bateria. </p><br><p>  O autor observa que, como todas as √°rvores da floresta s√£o perfeitas, sua altura √© expressa pelo poder de dois, assim como qualquer n√∫mero natural pode ser representado como a soma dos poderes de dois.  Dessa forma, qualquer conjunto de folhas pode ser agrupado na forma de √°rvores bin√°rias e, em todos os casos, a adi√ß√£o de um novo elemento requer conhecimento <em>apenas sobre os n√≥s raiz das √°rvores armazenadas</em> . </p><br><p>  Portanto, a exibi√ß√£o armazenada da bateria Utreexo √© uma lista de n√≥s raiz (raiz Merkle) <em>e n√£o toda a floresta de √°rvores</em> . </p><br><p> Imagine a lista de elementos raiz como <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  O tipo opcional <code>Option&lt;Hash&gt;</code> indica que o elemento raiz pode estar ausente, o que significa que a √°rvore n√£o possui uma √°rvore com uma altura apropriada. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Adicionando itens </h4><br><p>  Primeiro, descrevemos a fun√ß√£o <code>parent()</code> , que reconhece o n√≥ pai para dois elementos fornecidos. </p><br><div class="spoiler">  <b class="spoiler_title">Fun√ß√£o Parent ()</b> <div class="spoiler_text"><p>  Como usamos √°rvores Merkle, o pai de cada um dos dois n√≥s √© um n√≥ que armazena o hash de concatena√ß√£o dos hashes dos n√≥s descendentes: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  O autor observa que, para impedir os ataques descritos por Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir e Sebastien Zimmer em <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segundo ataques de pr√©-imagem em fun√ß√µes de hash pontilhado</a> , al√©m de dois hashes, voc√™ deve adicionar altura √† √°rvore na concatena√ß√£o. </p></div></div><br><p>  Ao adicionar itens √† bateria, voc√™ precisa acompanhar quais itens raiz est√£o sendo alterados.  Seguindo o caminho de alterar os elementos raiz de cada elemento adicionado, voc√™ pode construir posteriormente uma prova da presen√ßa desses elementos. </p><br><div class="spoiler">  <b class="spoiler_title">Rastrear altera√ß√µes durante o upload</b> <div class="spoiler_text"><p>  Para rastrear as altera√ß√µes feitas, declararemos a estrutura <code>Update</code> , que armazenar√° dados sobre as altera√ß√µes nos n√≥s. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Para adicionar um elemento √† bateria, voc√™ precisa: </p><br><ul><li>  Crie uma matriz de cestas de elementos raiz <code>new_roots</code> e coloque os elementos raiz existentes l√°, um para cada cesta: </li></ul><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Adicione os elementos adicionados (matriz de <code>insertions</code> ) ao primeiro carrinho <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  Conduza a "coalesc√™ncia" dos itens adicionados √† primeira cesta com o restante: <br><ul><li>  Para todas as cestas com mais de um item: <br><ol><li>  Pegamos dois elementos do final da cesta, calculamos o pai deles, exclu√≠mos os dois elementos </li><li>  Adicione o pai calculado √† pr√≥xima cesta. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Mova os elementos raiz dos cestos para o conjunto de baterias resultante </li></ul><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Criando evid√™ncia para itens adicionados </h4><br><p>  A prova da inclus√£o do elemento na bateria ( <code>Proof</code> ) servir√° como o caminho do Merkle (Caminho do Merkle), consistindo em uma cadeia de <code>ProofStep</code> .  Se o caminho n√£o leva a lugar algum, a prova est√° errada. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Usando as informa√ß√µes obtidas anteriormente durante a adi√ß√£o do elemento (estrutura de <code>Update</code> ), voc√™ pode criar evid√™ncias de que o elemento foi adicionado √† bateria.  Para fazer isso, contornamos a tabela de altera√ß√µes feitas e adicionamos cada etapa ao caminho do Merkle, que posteriormente servir√° como prova: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Processo de evid√™ncia</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Prova de evid√™ncia para um item </h4><br><p>  A verifica√ß√£o da prova da inclus√£o de um elemento (prova de inclus√£o) √© reduzida para seguir o caminho do Merkle, at√© que ele leve ao elemento raiz existente: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Claramente: </p><br><div class="spoiler">  <b class="spoiler_title">Processo de verifica√ß√£o de evid√™ncias para A</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Excluir itens </h4><br><p>  Para remover um elemento da bateria, voc√™ deve fornecer uma prova v√°lida de que o elemento est√° l√°.  Usando os dados da prova, podemos calcular os novos elementos raiz da bateria para os quais essa prova n√£o ser√° mais verdadeira. </p><br><p>  O algoritmo √© o seguinte: </p><br><ol><li>  Como na adi√ß√£o, organizamos um conjunto de cestas vazias correspondentes a √°rvores Merkle com uma altura igual a dois do √≠ndice da cesta </li><li>  Insira itens das etapas do caminho Merkle nas cestas;  o √≠ndice da cesta √© igual ao n√∫mero da etapa atual </li><li>  Removemos o elemento raiz ao qual o caminho da prova leva. </li><li>  Assim como na adi√ß√£o, calculamos os novos elementos raiz, combinando os elementos das cestas em pares e movendo o resultado da uni√£o para a pr√≥xima cesta </li></ol><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  O processo de remo√ß√£o do item "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integra√ß√£o em uma rede existente </h2><br><p>  Usando a bateria proposta, os n√≥s podem se recusar a usar o banco de dados para armazenar todo o UTXO, mantendo a capacidade de alterar o conjunto de UTXO.  No entanto, existe o problema de trabalhar com evid√™ncias. </p><br><p>  Chamaremos um n√≥ validador que usa uma bateria UTXO <em>compacta</em> (n√≥ de estado compacto) e um validador sem bateria - <em>cheio</em> (n√≥ completo).  A exist√™ncia de duas classes de n√≥s cria o problema de integr√°-las em uma √∫nica rede, pois os n√≥s compactos exigem a prova da exist√™ncia do UTXO, que √© gasto em transa√ß√µes, mas os n√≥s completos n√£o.  Se todos os n√≥s da rede ao mesmo tempo e de maneira coordenada n√£o mudarem para o Utreexo, os n√≥s compactos ser√£o deixados para tr√°s e n√£o poder√£o trabalhar na rede Bitcoin. </p><br><p>  Para resolver o problema de integrar n√≥s compactos √† rede, prop√µe-se a introdu√ß√£o de uma classe adicional de n√≥s - <em>pontes</em> .  Um n√≥ de ponte √© um n√≥ completo que, entre outras coisas, armazena a bateria do Utreexo e evid√™ncias de inclus√£o para <strong>todos</strong> os UTXOs do conjunto UTXO.  As pontes calculam novos hashes e atualizam a bateria e as evid√™ncias √† medida que novos blocos chegam com as transa√ß√µes.  O suporte e a atualiza√ß√£o da bateria e das evid√™ncias n√£o imp√µem carga computacional adicional a esses n√≥s.  Pontes sacrificam espa√ßo em disco: mantenha a ordem em ordem <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6E" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  hashes em compara√ß√£o com <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhjOFX4OkfDpS2tYAvqXMFSQGGAf3g#MJMAIN-29" x="2254" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  hashes para n√≥s compactos, em que n √© a pot√™ncia do conjunto UTXO. </p><br><h3 id="arhitektura-seti">  Arquitetura de rede </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  As pontes possibilitam adicionar gradualmente n√≥s compactos √† rede sem alterar o software dos n√≥s existentes.  N√≥s completos funcionam como antes, distribuindo transa√ß√µes e blocos entre si.  Os n√≥s de ponte s√£o n√≥s completos que armazenam adicionalmente dados da bateria do Utreexo e um conjunto de evid√™ncias de inclus√£o para <strong>todos os</strong> UTXO no momento.  O n√≥ da ponte n√£o se anuncia como tal, fingindo ser um n√≥ completo para todos os n√≥s completos e um n√≥ compacto para todos os n√≥s compactos.  Embora as pontes conectem as duas redes, na realidade, elas precisam estar conectadas em apenas uma dire√ß√£o: dos n√≥s completos existentes aos n√≥s compactos.  Isso √© poss√≠vel porque o formato da transa√ß√£o n√£o precisa ser alterado e as evid√™ncias do UTXO para n√≥s compactos podem ser descartadas; portanto, qualquer n√≥ compacto pode enviar transa√ß√µes para todos os participantes da rede da mesma maneira, sem a participa√ß√£o de n√≥s da ponte. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Analisamos a bateria Utreexo e implementamos seu prot√≥tipo em Rust.  Examinamos a arquitetura de rede, que integrar√° os n√≥s com base na bateria.  A vantagem da captura compacta √© o tamanho dos dados armazenados, que depende logaritmicamente da pot√™ncia de muitos UTXOs, o que reduz significativamente os requisitos de espa√ßo em disco e o desempenho de armazenamento para esses n√≥s.  A desvantagem √© o tr√°fego adicional do n√≥ para a transfer√™ncia de evid√™ncia, mas as t√©cnicas de agrega√ß√£o de evid√™ncia (quando uma prova prova a exist√™ncia de v√°rios elementos) e o armazenamento em cache podem ajudar a manter o tr√°fego dentro de limites aceit√°veis. </p><br><p>  <strong>Refer√™ncias</strong> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Prot√≥tipo de ferrugem Utreexo GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Utreexo: um acumulador din√¢mico baseado em hash otimizado para o conjunto Bitcoin UTXO</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arte animada de um artigo</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456424/">https://habr.com/ru/post/pt456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456412/index.html">Inova√ß√£o controversa da Yandex - fa√ßa login na sua conta atrav√©s de uma carta</a></li>
<li><a href="../pt456414/index.html">Prote√ß√£o contra inc√™ndio em data centers ou como os dados s√£o armazenados</a></li>
<li><a href="../pt456416/index.html">Agile for All Book</a></li>
<li><a href="../pt456418/index.html">Uma Breve Hist√≥ria da Trapa√ßa de Jogos de V√≠deo</a></li>
<li><a href="../pt456422/index.html">An√∫ncio de uma nova vers√£o do Styled Components v5: Animal Grin</a></li>
<li><a href="../pt456426/index.html">BASS - uma estrutura para s√≠ntese autom√°tica de assinaturas de antiv√≠rus</a></li>
<li><a href="../pt456428/index.html">Como implementar uma abordagem de BI para an√°lise de dados: recomenda√ß√µes pr√°ticas</a></li>
<li><a href="../pt456430/index.html">A eterna quest√£o da d√≠vida t√©cnica</a></li>
<li><a href="../pt456432/index.html">Security Week 25: vulnerabilidade do Evernote e centenas de lojas on-line invadidas</a></li>
<li><a href="../pt456434/index.html">Profiss√µes do futuro: ‚ÄúQuem voc√™ trabalhar√° em Marte?‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>