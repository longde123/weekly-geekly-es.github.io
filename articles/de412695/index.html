<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèæ üï¶ ü§õüèæ Das Gesamtbild der Unit-Tests üë®‚Äçüíª üö¥üèø üëÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist keine Anleitung, welche Zeichen Sie in den Code-Editor eingeben m√ºssen, um Unit-Tests zu erhalten. Dies ist Nahrung f√ºr den Geist, die konsum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Gesamtbild der Unit-Tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Dies ist keine Anleitung, welche Zeichen Sie in den Code-Editor eingeben m√ºssen, um Unit-Tests zu erhalten.  Dies ist Nahrung f√ºr den Geist, die konsumiert werden muss, <b>bevor</b> diese Ma√ünahmen ergriffen werden. <br><br>  Das Thema Unit-Tests ist nicht so einfach, wie es scheint.  Viele von uns Entwicklern kommen unter dem Druck von Kunden, Mitarbeitern, Kollegen, ihren Vorbildern usw. zu Unit-Tests.  Wir verstehen schnell seinen Wert und nachdem wir die technischen Vorbereitungen abgeschlossen haben, vergessen wir das allgemeine Bild, wenn √ºberhaupt, haben wir es jemals verstanden.  In diesem Artikel werde ich kurz darauf eingehen, was Unit-Tests beides sind und was nicht, und in PHP werde ich gleichzeitig beschreiben, welchen Platz Unit-Tests im Bereich der Qualit√§tssicherung einnehmen. <br><a name="habracut"></a><br><h2>  Was ist Testen? </h2><br>  Bevor Sie sich mit Unit-Tests befassen, m√ºssen Sie die Testtheorie selbst studieren, um keine Fehler zu machen, wie sie von den Autoren eines der beliebtesten PHP-Frameworks gemacht wurden: Sie zeigten Integrationstests auf ihrer Website und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nannten</a> sie Unit-Tests.  Nein, Laravel, das sind keine Unit-Tests.  Obwohl mich das nicht davon abh√§lt, diesen Rahmen immer noch zu lieben. <br><br>  Softwaretests sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">definiert</a> als "eine Untersuchung, die durchgef√ºhrt wird, um interessierten Parteien Informationen √ºber die Produktqualit√§t zu liefern".  Dies steht im Gegensatz zu "Softwaretests sind eine Verschwendung des Projektbudgets durch Entwickler, die nichts Wichtiges tun und dann mehr Zeit und Geld verlangen, weil" nichts "sehr teuer sein kann."  Hier gibt es nichts Neues. <br><br>  Hier ist meine kurze Geschichte, ein Test zu werden: <br><br><ul><li>  1822 - Differenzmaschine (Charles Babbage). </li><li>  1843 - Analytische Maschine (Ada Lovelace). </li><li>  1878 - Edison f√ºhrt den Begriff "Bug" ein. </li><li>  1957 - Testen und Debuggen von Programmen (Charles Baker). </li><li>  1958 - Das erste Software-Testteam (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  1970er Jahre - Wasserfallmodell, relationales Modell, Zerlegung, kritische Analyse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Walkthrough</a> ), Entwurf und Inspektion von Code, Qualit√§t und Metriken, Entwurfsmuster. </li><li>  1980er Jahre - CRUD-Analyse, Systemarchitektur, Autotest, V-Modell, Zuverl√§ssigkeit, Qualit√§tskosten, Verwendungsmethoden, OOP-Entwurfsmuster. </li><li>  1990er Jahre - Scrum, Usability-Tests, MoSCoW, heuristische Tests, Software-Automatisierung und -Tests. </li></ul><br>  Wenn Sie sich auf eine Generation von Millennials wie mich beziehen, werden Sie vielleicht erstaunt sein, dass die Testteams lange vor Ihrer Geburt existierten.  Halten Sie f√ºr einen Moment inne, atmen Sie ein, aus, beruhigen Sie sich. <br>  Die Geschichte zeigt, wie sich die Art der Tests, die f√ºr Interessenten als ‚Äûgut genug‚Äú angesehen wurden, im Laufe der Zeit ge√§ndert hat.  Ungef√§hre Phasen, die w√§hrend des Tests gef√ºhrt wurden: <br><br><ul><li>  ... - Debugging 1956 </li><li>  1957 - 1978 Demonstration </li><li> 1979 - 1982 Zerst√∂rung </li><li>  Sch√§tzung von 1983 - 1987 </li><li>  1988 - ... Pr√§vention </li></ul><br>  Daher sind Unit-Tests erforderlich, <b>um</b> Diskrepanzen zwischen dem Projekt und der Implementierung zu <b>vermeiden</b> . <br><br><h2>  Was ist eigentlich Testen? </h2><br>  Es gibt verschiedene Klassifikationen von Softwaretests.  Um den Ort des Unit-Tests besser zu verstehen, werde ich nur die am weitesten verbreiteten Ans√§tze erw√§hnen. <br><br>  Tests sind: statisch und dynamisch, "Box" (wei√üe Box, schwarze Box, graue Box), Ebenen und Typen.  Jeder Ansatz verwendet unterschiedliche Klassifizierungskriterien. <br><br><h2>  Statische und dynamische Pr√ºfung </h2><br>  Statische Tests werden ohne Codeausf√ºhrung durchgef√ºhrt.  Dies umfasst Korrekturlesen, Verifizieren, Code-Revision (wenn Sie die Arbeit einer anderen / Paar-Programmierung beobachten), kritische Analyse, Inspektionen und so weiter. <br><br>  Dynamische Tests, um die richtigen Ergebnisse zu erzielen, erfordern die Ausf√ºhrung von Code.  Zum Beispiel f√ºr <b>Unit-Tests</b> , Integration, System-, Akzeptanz- und andere Tests.  Das hei√üt, das Testen wird unter Verwendung dynamischer Daten, Eingabe und Ausgabe durchgef√ºhrt. <br><br><h2>  Box-Ansatz </h2><br>  Nach diesem Ansatz sind alle Softwaretests in drei Arten von Boxen unterteilt: <br><br><ul><li>  <b>White-Box-</b> Tests √ºberpr√ºfen interne Strukturen und Module und ignorieren die erwarteten Funktionen f√ºr Endbenutzer.  Dies k√∂nnen API-Tests, Fehlerinjektion, <b>Komponententests</b> und Integrationstests sein. </li><li>  <b>Black-Box-</b> Tests interessieren sich mehr f√ºr <b>die Funktionsweise der</b> Software und nicht f√ºr die <b>Funktionsweise</b> .  Dies bedeutet, dass Tester weder das Testobjekt noch dessen Funktionsweise unter der Haube verstehen m√ºssen.  Diese Art des Testens richtet sich an Endbenutzer, deren Erfahrung mit einer sichtbaren Oberfl√§che interagiert.  Black Boxes umfassen modellbasierte Tests, Verwendungstests, Status√ºbergangstabellen, Spezifikationstests usw. </li><li>  Das Testen des Typs ‚Äû <b>graue Box</b> ‚Äú basiert auf Kenntnissen √ºber Softwarealgorithmen und Datenstrukturen (wei√üe Box), wird jedoch auf Benutzerebene durchgef√ºhrt (schwarze Box).  Dies umfasst Regressionstests und Mustertests. </li></ul><br>  Um Sie zu verwirren, m√∂chte ich sagen, dass <b>Unit-Tests</b> auch f√ºr die ‚ÄûBlack Box‚Äú gelten k√∂nnen, da Sie das <b>zu testende</b> Modul verstehen k√∂nnen, aber nicht das gesamte System.  Obwohl es f√ºr mich immer noch eine "wei√üe Kiste" ist, und ich schlage vor, Sie stimmen dem zu. <br><br><h2>  Testlevel </h2><br>  Ihre Anzahl variiert, normalerweise im Bereich von 4 bis 6, und sie sind alle n√ºtzlich.  Die Namen k√∂nnen auch unterschiedlich sein. Abh√§ngig von der Unternehmenskultur k√∂nnen Sie Integrationstests als funktional, Systemtests als automatisiert usw. bezeichnen.  Der Einfachheit halber werde ich 5 Ebenen beschreiben: <br><br><ol><li>  <b>Unit Testing</b> </li><li>  Integrationstests. </li><li>  Testen von Komponentenschnittstellen. </li><li>  Systemtests. </li><li>  Pr√ºfung der Betriebsabnahme. </li></ol><br>  <b>Unit-</b> Tests <b>testen</b> die Funktionalit√§t eines bestimmten Codeteils, normalerweise jeweils eine Funktion.  Beim Integrationstest werden die Schnittstellen zwischen den Komponenten √ºberpr√ºft, sodass die zusammengesetzten Module ein System bilden, das wie vorgesehen funktioniert.  Dies ist ein wichtiger Punkt, da eine gro√üe Anzahl von Tests, die als Komponententests bezeichnet werden, tats√§chlich Integrationstests sind und Entwickler sie als Module betrachten.  Wenn Sie mehrere Module verwenden m√∂chten, wird die Integration zwischen diesen Modulen getestet, nicht die Module selbst.  Das Testen von Komponentenschnittstellen √ºberpr√ºft die zwischen verschiedenen Modulen √ºbertragenen Daten.  Zum Beispiel haben wir Daten von Modul 1 erhalten - gepr√ºft - an Modul 2 √ºbertragen - gepr√ºft.  Systemtests sind End-to-End-Tests, um die Einhaltung aller Anforderungen zu √ºberpr√ºfen.  Betriebsabnahmetests werden durchgef√ºhrt, um die Betriebsbereitschaft zu √ºberpr√ºfen.  Es ist nicht funktionsf√§hig, nur die Wartungsfreundlichkeit der Dienste wird √ºberpr√ºft, ob Subsysteme die Umgebung und andere Dienste besch√§digen. <br><br><h2>  Arten von Tests </h2><br>  Jede Art von Test kann unabh√§ngig von ihrer Stufe auch in andere Arten unterteilt werden.  Es gibt mehr als 20 g√§ngige Typen.  Am h√§ufigsten: <br><br><ul><li>  <b>Regressionstests</b> . </li><li>  Abnahmetests. </li><li>  Rauchpr√ºfung </li><li>  Uat </li><li>  <b>Zerst√∂rende Pr√ºfung</b> . </li><li>  Leistungstests. </li><li>  <b>Kontinuierliche Pr√ºfung</b> . </li><li>  Usability-Tests. </li><li>  Sicherheitstests. </li></ul><br>  Aus dem Namen geht hervor, warum diese oder jene Art von Tests beabsichtigt ist.  Fett sind die Unit-Tests in PHP.  Wenn Sie wirklich wollen, k√∂nnen Sie jeden dieser Begriffe auf Unit-Tests anwenden.  Die Hauptvielfalt der Komponententests sind jedoch Regressionstests, bei denen √ºberpr√ºft wird, ob alle Module des Systems nach √Ñnderungen am Code korrekt ausgef√ºhrt werden. <br><br>  Jetzt wissen Sie, dass Komponententests dynamisch sind, zur White-Box-Klasse geh√∂ren, auf Modulebene durchgef√ºhrt werden, Regressionstests sind, aber modulare Tests k√∂nnen als viele Arten von Tests verstanden werden.  Was sind Unit-Tests wirklich? <br><br><h2>  Was ist Unit Testing? </h2><br>  Ein V-Modell ist eine grafische Darstellung der oben genannten Ebenen, Typen und ihres Zwecks im Lebenszyklus der Softwareentwicklung. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  Nach √úberpr√ºfung und Genehmigung der detaillierten Anforderungen f√ºr das Produkt, wenn mit dem Schreiben von Code begonnen wurde, werden Unit-Tests zur ersten Verteidigungslinie gegen Inkonsistenzen.  Daher zwingen Unternehmen, die verstehen, was sie tun, Entwickler, Unit-Tests oder sogar TDD zu verwenden, da es viel billiger ist, Fehler in der Anfangsphase zu beheben als in den sp√§teren. <br><br>  Und das ist fair.  Unit-Tests haben viele Vorteile.  Sie sind: <br><br><ul><li>  Isolieren Sie jeden Teil des Programms und √ºberpr√ºfen Sie die Richtigkeit. </li><li>  Helfen Sie, Probleme fr√ºhzeitig zu erkennen. </li><li>  Sie lassen Entwickler in Bezug auf Eingabe, Ausgabe und fehlerhafte Bedingungen denken. </li><li>  Sie geben dem Code ein bequemes Aussehen zum Testen und erleichtern das zuk√ºnftige Refactoring. </li><li>  Vereinfachen Sie die Integration von Arbeitsmodulen (!). </li><li>  Ersetzen Sie die technische Dokumentation teilweise. </li><li>  Erzwungen, die Schnittstelle von der Implementierung zu trennen. </li><li>  Sie beweisen, dass der Modulcode wie erwartet funktioniert (zumindest mathematisch). </li><li>  Kann als Low-Level-Regressionstestsuite verwendet werden. </li><li>  Demonstrieren Sie Fortschritte bei der unvollst√§ndigen Systemintegration. </li><li>  Reduzieren Sie die Kosten f√ºr die Behebung von Fehlern (mit TDD - noch mehr). </li><li>  Mit ihnen k√∂nnen Sie die Architektur der Anwendung verbessern, indem Sie die Verantwortung der Module bestimmen. </li><li>  Wenn Sie es testen k√∂nnen, k√∂nnen Sie es an Ihr System anschlie√üen. </li><li>  Unit Testing macht Spa√ü! </li></ul><br>  Es gibt jedoch bestimmte Einschr√§nkungen, √ºber die Sie nachgedacht haben, wahrscheinlich beim Lesen dieser Liste: <br><br><ul><li>  Unit-Tests erkennen keine Integrationsfehler. </li><li>  Jeder Boolesche Ausdruck erfordert mindestens zwei Tests, und die Anzahl w√§chst schnell. </li><li>  Unit-Tests sind genauso fehlerhaft wie der Code, den sie testen. </li><li>  Das Verkn√ºpfen von Tests mit bestimmten Frameworks oder Bibliotheken kann den Workflow einschr√§nken. </li><li>  Die meisten Tests werden nach Abschluss der Entwicklung geschrieben.  Es ist traurig.  Verwenden Sie TDD! </li><li>  M√∂glicherweise funktioniert das System nach einer kleinen Umgestaltung wie zuvor, aber die Tests schlagen fehl. </li><li>  Die Entwicklungskosten steigen. </li><li>  Menschliches Versagen: Kommentieren gebrochener Tests. </li><li>  Menschliches Versagen: Hinzuf√ºgen von Problemumgehungen zum Code speziell zum Bestehen von Komponententests. </li></ul><br>  Letzteres bringt mich am meisten um.  (Fast) in jedem Projekt, direkt im Quellcode der Arbeitsanwendung, finde ich Zeilen wie "Wenn es sich um einen Komponententest handelt, laden Sie eine Ersatz-SQLite-Datenbank, andernfalls laden Sie eine andere Datenbank" oder "Wenn es sich um einen Komponententest handelt, senden Sie keine E-Mail, andernfalls." senden ‚Äúund so weiter.  Wenn Ihre Anwendung eine schlechte Architektur hat, tun Sie nicht so, als k√∂nnten Sie miese Software mit einem guten Testdurchlauf reparieren, da dies nicht besser wird. <br><br>  Ich habe oft mit Kollegen und Kunden dar√ºber gesprochen, was ein guter Unit-Test ist.  Er: <br><br><ul><li>  Schnell. </li><li>  Automatisiert. </li><li>  Steuert alle Abh√§ngigkeiten vollst√§ndig. </li><li>  Zuverl√§ssig: Es kann in beliebiger Reihenfolge gestartet werden, unabh√§ngig von anderen Tests. </li><li>  Es kann nur im Speicher ausgef√ºhrt werden (keine Interaktionen mit der Datenbank, Lese- / Schreibvorg√§nge im Dateisystem). </li><li>  Gibt immer ein einzelnes Ergebnis zur√ºck. </li><li>  Praktisch zum Lesen und Begleiten. </li><li>  Testet die SUT-Konfiguration nicht (System im Test). </li><li>  Hat eine klar definierte EINZELAUFGABE. </li><li>  Es ist gut benannt (und verst√§ndlich genug, um das Debuggen zu vermeiden, nur um herauszufinden, was fehlschl√§gt). </li></ul><br>  F√ºr diejenigen, die nach dem Lesen von ‚Äûautomatisiert‚Äú grinsten: Ich wollte nicht PHPUnit oder JUnit in CI-Pipelines integrieren.  Der Punkt ist, dass wenn Sie den Code √§ndern, ihn speichern und nicht wissen, ob die Module ihre Tests bestehen, sie nicht automatisiert sind, sondern sollten.  Die beste Option ist die Dateiverfolgung. <br><br><h2>  Was sollte einem Unit-Test unterzogen werden? </h2><br>  In normalen Systemen m√ºssen Komponententests geschrieben werden f√ºr: <br><br><ul><li>  Module - unteilbare isolierte Teile des Systems, die eine Aufgabe ausf√ºhren (Funktion, Methode, Klasse). </li><li>  √ñffentliche Methoden. </li><li>  Gesch√ºtzte Methoden, aber nur in seltenen F√§llen und wenn niemand sieht. </li><li>  Bugs und ihre Korrekturen. </li></ul><br>  Die Definition eines Komponententests h√§ngt vom Entwickler ab, der den Code geschrieben hat.  In PHP handelt es sich fast immer um eine Klassenmethode oder -funktion, da es sich um eine <b>unteilbare Software handelt, die f√ºr sich genommen Sinn macht</b> .  Mehrmals habe ich gesehen, wie Entwickler ein Array von Miniklassen mit einer Methode als einzelnes Modul verwendeten.  Dies ist sinnvoll, wenn f√ºr eine minimale Funktionalit√§t mehrere Objekte erforderlich sind. <br><br>  So k√∂nnen Sie selbst bestimmen, was ein Modul f√ºr Sie ist.  Oder Sie k√∂nnen die Methoden einzeln testen, um dem Kerl das Leben zu erleichtern, der dann mit dem Code arbeitet. <br><br>  Wenn Sie keine Unit-Tests durchf√ºhren, schlage ich vor, dies nach dem n√§chsten gro√üen Fehler zu tun.  √úberpr√ºfen Sie, mit welcher Methode es verkn√ºpft wird, schreiben Sie einen fehlgeschlagenen Test mit den richtigen Argumenten und Ergebnissen, beheben Sie den Fehler und f√ºhren Sie den Komponententest erneut aus.  Wenn es bestanden wird, k√∂nnen Sie sicher sein, dass dieser Fehler zum letzten Mal behoben werden musste (unter Ber√ºcksichtigung Ihrer spezifischen Eingabeszenarien). <br><br>  Dieser Ansatz erleichtert das Verst√§ndnis von Unit-Tests.  Analysieren Sie jede Methode separat.  Datenanbieter k√∂nnen Ihnen dabei helfen, die Ein- und Ausgabe f√ºr jedes Szenario zu bestimmen, das Ihnen in den Sinn kommt. Unabh√§ngig davon, was passiert, wissen Sie, was Sie erwartet. <br><br><h2>  Was muss NICHT getestet werden </h2><br>  Es ist etwas schwieriger festzustellen, dass Sie nicht testen m√ºssen.  Ich habe versucht, eine Liste von Elementen zu erstellen, <b>die keinen</b> Unit-Tests unterzogen werden m√ºssen: <br><br><ul><li>  Funktionalit√§t au√üerhalb des Modulumfangs (!) </li><li>  Integration von Modulen mit anderen Modulen (!) </li><li>  Nicht isoliertes Verhalten (nicht blockierbare Abh√§ngigkeiten, reale Datenbanken, Netzwerk) </li><li>  Private, sichere Methoden. </li><li>  Statische Methoden. </li><li>  Externe Bibliotheken. </li><li>  Ihr Rahmen. </li></ul><br>  Ich bin sicher, dass Unit-Tests auf keine der oben genannten Methoden angewendet werden sollten, au√üer auf statische Methoden.  Ich m√∂chte argumentieren, dass statisch im Wesentlichen Prozeduralit√§t bedeutet und in vielen F√§llen prozedural ist.  Wenn die statische Methode eine andere statische Methode aufruft, kann diese Abh√§ngigkeit nicht √ºberschrieben werden.  Dies bedeutet, dass Sie jetzt isoliert testen.  Und dann ist dies kein Unit-Test mehr.  Auf der anderen Seite ist dies der Teil des Codes, der f√ºr sich alleine leben kann, er hat einen Zweck und er muss getestet werden, um sicherzustellen, dass er nicht kaputt geht, egal welchen Teil dieses dummen Systems der getestete Teil des Codes aufruft.  Daher glaube ich, dass Sie statische Methoden testen k√∂nnen, wenn Sie sicher sind, dass die Ausgabe Ihres Tests durch keinen anderen Test ge√§ndert werden kann und die Sprache oder das Framework es Ihnen erm√∂glicht, nativ zu testen. <br><br><h2>  Wie schreibe ich Unit-Tests? </h2><br><ul><li>  Schreiben Sie einen Code, der f√ºr Unit-Tests geeignet ist, und testen Sie ihn dann. </li><li>  Schreiben Sie einen Code, der f√ºr Unit-Tests geeignet ist, und testen Sie ihn dann. </li><li>  Schreiben Sie einen Code, der f√ºr Unit-Tests geeignet ist, und testen Sie ihn dann. </li></ul><br>  Wenn "dann testen" nicht ausreicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bietet laracasts.com</a> sehr gute Videos zum Testen von PHP-Einheiten.  Es gibt viele Websites, die sich derselben Aufgabe in anderen Sprachen widmen.  Ich sehe keinen Grund zu erkl√§ren, wie ich Unit-Tests durchf√ºhre, da sich die Tools ziemlich schnell √§ndern und ich beim Lesen dieses Textes von PHPUnit zu Kahlan wechseln kann.  Oder nicht.  Wer wei√ü. <br><br>  Die Beantwortung der ersten Frage (Schreiben von Code, der f√ºr Unit-Tests geeignet ist) ist jedoch viel einfacher, und es ist unwahrscheinlich, dass sich die Situation im Laufe der Zeit wesentlich √§ndert: <br><br><ul><li>  <b>FEST</b> </li><li>  <b>TROCKEN</b> </li><li>  Das Fehlen <b>neuer</b> Schl√ºsselw√∂rter im Konstruktor. </li><li>  Das Fehlen von <b>Schleifen</b> im Konstruktor (und √úberg√§ngen, falls angegeben). </li><li>  Mangel an statischen Methoden, Parametern, Klassen. </li><li>  Fehlende setup () -Methoden: Objekte m√ºssen nach der Erstellung vollst√§ndig initialisiert werden. </li><li>  Das Fehlen von Singleton (globaler Status) und anderen nicht testbaren Antimustern. </li><li>  Der Mangel an allm√§chtigen Objekten (Gottobjekten). </li><li>  Mangel an Klassen mit gemischter Funktionalit√§t (gemischte Anliegenklassen). </li><li>  Keine versteckten Abh√§ngigkeiten. </li></ul><br>  Wenn Sie nun wissen, was die Komponententests sind und was nicht, was Sie ben√∂tigen und was Sie nicht testen m√ºssen, welchen Platz die Komponententests im Lebenszyklus der Softwareentwicklung einnehmen, k√∂nnen Sie sie einfacher implementieren.  Es bleibt ein Rahmen oder eine Bibliothek nach Ihren W√ºnschen zu finden.  Nehmen Sie im Zweifelsfall das De-facto-Standard-Framework / die Standardsprache. <br><br>  Fazit: Unit-Tests sind sowohl f√ºr Entwickler als auch f√ºr Unternehmen sehr wichtig.  Sie m√ºssen geschrieben werden. Es gibt bew√§hrte Methoden, mit denen Sie Module problemlos mit Tests abdecken k√∂nnen, haupts√§chlich indem Sie die Module selbst vorbereiten.  Alle diese Techniken sind jedoch ohne Kenntnis der in diesem Artikel beschriebenen Testtheorie nicht sinnvoll.  Sie m√ºssen in der Lage sein, Komponententests von Tests anderer Typen zu unterscheiden.  Und wenn Sie ein klares Verst√§ndnis in Ihrem Kopf haben, wird es f√ºr Sie viel einfacher, Tests zu schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412695/">https://habr.com/ru/post/de412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412685/index.html">Unity GPU Path Tracing - Teil 2</a></li>
<li><a href="../de412687/index.html">Implementieren Sie IdM. Verfahren und technische Mittel - von Basic bis IdM</a></li>
<li><a href="../de412689/index.html">Predictive IT Analytics optimieren die verteilte Anwendungs√ºberwachung</a></li>
<li><a href="../de412691/index.html">5 Jahre Witz auf Facebook oder forensische Geschichte</a></li>
<li><a href="../de412693/index.html">Schreiben Sie Code, der leicht zu entfernen und zu debuggen ist</a></li>
<li><a href="../de412697/index.html">IoT als universelles Fachgebiet f√ºr eine multidisziplin√§re technische Universit√§t</a></li>
<li><a href="../de412699/index.html">Einfache Erkl√§rung der SOLID-Prinzipien</a></li>
<li><a href="../de412701/index.html">Die intelligenteste Heizung</a></li>
<li><a href="../de412703/index.html">Bei einer Konferenz mit Veeam: ein R√ºckblick auf VeeamON 2018 und eine Einladung zum VeeamON-Forum in Moskau</a></li>
<li><a href="../de412705/index.html">Das System gehackt: Wie wir die Auswahl und Anpassung von Entwicklern ge√§ndert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>