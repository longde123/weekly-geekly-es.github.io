<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏾 🕦 🤛🏾 Das Gesamtbild der Unit-Tests 👨‍💻 🚴🏿 👆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist keine Anleitung, welche Zeichen Sie in den Code-Editor eingeben müssen, um Unit-Tests zu erhalten. Dies ist Nahrung für den Geist, die konsum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Gesamtbild der Unit-Tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Dies ist keine Anleitung, welche Zeichen Sie in den Code-Editor eingeben müssen, um Unit-Tests zu erhalten.  Dies ist Nahrung für den Geist, die konsumiert werden muss, <b>bevor</b> diese Maßnahmen ergriffen werden. <br><br>  Das Thema Unit-Tests ist nicht so einfach, wie es scheint.  Viele von uns Entwicklern kommen unter dem Druck von Kunden, Mitarbeitern, Kollegen, ihren Vorbildern usw. zu Unit-Tests.  Wir verstehen schnell seinen Wert und nachdem wir die technischen Vorbereitungen abgeschlossen haben, vergessen wir das allgemeine Bild, wenn überhaupt, haben wir es jemals verstanden.  In diesem Artikel werde ich kurz darauf eingehen, was Unit-Tests beides sind und was nicht, und in PHP werde ich gleichzeitig beschreiben, welchen Platz Unit-Tests im Bereich der Qualitätssicherung einnehmen. <br><a name="habracut"></a><br><h2>  Was ist Testen? </h2><br>  Bevor Sie sich mit Unit-Tests befassen, müssen Sie die Testtheorie selbst studieren, um keine Fehler zu machen, wie sie von den Autoren eines der beliebtesten PHP-Frameworks gemacht wurden: Sie zeigten Integrationstests auf ihrer Website und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nannten</a> sie Unit-Tests.  Nein, Laravel, das sind keine Unit-Tests.  Obwohl mich das nicht davon abhält, diesen Rahmen immer noch zu lieben. <br><br>  Softwaretests sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">definiert</a> als "eine Untersuchung, die durchgeführt wird, um interessierten Parteien Informationen über die Produktqualität zu liefern".  Dies steht im Gegensatz zu "Softwaretests sind eine Verschwendung des Projektbudgets durch Entwickler, die nichts Wichtiges tun und dann mehr Zeit und Geld verlangen, weil" nichts "sehr teuer sein kann."  Hier gibt es nichts Neues. <br><br>  Hier ist meine kurze Geschichte, ein Test zu werden: <br><br><ul><li>  1822 - Differenzmaschine (Charles Babbage). </li><li>  1843 - Analytische Maschine (Ada Lovelace). </li><li>  1878 - Edison führt den Begriff "Bug" ein. </li><li>  1957 - Testen und Debuggen von Programmen (Charles Baker). </li><li>  1958 - Das erste Software-Testteam (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  1970er Jahre - Wasserfallmodell, relationales Modell, Zerlegung, kritische Analyse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Walkthrough</a> ), Entwurf und Inspektion von Code, Qualität und Metriken, Entwurfsmuster. </li><li>  1980er Jahre - CRUD-Analyse, Systemarchitektur, Autotest, V-Modell, Zuverlässigkeit, Qualitätskosten, Verwendungsmethoden, OOP-Entwurfsmuster. </li><li>  1990er Jahre - Scrum, Usability-Tests, MoSCoW, heuristische Tests, Software-Automatisierung und -Tests. </li></ul><br>  Wenn Sie sich auf eine Generation von Millennials wie mich beziehen, werden Sie vielleicht erstaunt sein, dass die Testteams lange vor Ihrer Geburt existierten.  Halten Sie für einen Moment inne, atmen Sie ein, aus, beruhigen Sie sich. <br>  Die Geschichte zeigt, wie sich die Art der Tests, die für Interessenten als „gut genug“ angesehen wurden, im Laufe der Zeit geändert hat.  Ungefähre Phasen, die während des Tests geführt wurden: <br><br><ul><li>  ... - Debugging 1956 </li><li>  1957 - 1978 Demonstration </li><li> 1979 - 1982 Zerstörung </li><li>  Schätzung von 1983 - 1987 </li><li>  1988 - ... Prävention </li></ul><br>  Daher sind Unit-Tests erforderlich, <b>um</b> Diskrepanzen zwischen dem Projekt und der Implementierung zu <b>vermeiden</b> . <br><br><h2>  Was ist eigentlich Testen? </h2><br>  Es gibt verschiedene Klassifikationen von Softwaretests.  Um den Ort des Unit-Tests besser zu verstehen, werde ich nur die am weitesten verbreiteten Ansätze erwähnen. <br><br>  Tests sind: statisch und dynamisch, "Box" (weiße Box, schwarze Box, graue Box), Ebenen und Typen.  Jeder Ansatz verwendet unterschiedliche Klassifizierungskriterien. <br><br><h2>  Statische und dynamische Prüfung </h2><br>  Statische Tests werden ohne Codeausführung durchgeführt.  Dies umfasst Korrekturlesen, Verifizieren, Code-Revision (wenn Sie die Arbeit einer anderen / Paar-Programmierung beobachten), kritische Analyse, Inspektionen und so weiter. <br><br>  Dynamische Tests, um die richtigen Ergebnisse zu erzielen, erfordern die Ausführung von Code.  Zum Beispiel für <b>Unit-Tests</b> , Integration, System-, Akzeptanz- und andere Tests.  Das heißt, das Testen wird unter Verwendung dynamischer Daten, Eingabe und Ausgabe durchgeführt. <br><br><h2>  Box-Ansatz </h2><br>  Nach diesem Ansatz sind alle Softwaretests in drei Arten von Boxen unterteilt: <br><br><ul><li>  <b>White-Box-</b> Tests überprüfen interne Strukturen und Module und ignorieren die erwarteten Funktionen für Endbenutzer.  Dies können API-Tests, Fehlerinjektion, <b>Komponententests</b> und Integrationstests sein. </li><li>  <b>Black-Box-</b> Tests interessieren sich mehr für <b>die Funktionsweise der</b> Software und nicht für die <b>Funktionsweise</b> .  Dies bedeutet, dass Tester weder das Testobjekt noch dessen Funktionsweise unter der Haube verstehen müssen.  Diese Art des Testens richtet sich an Endbenutzer, deren Erfahrung mit einer sichtbaren Oberfläche interagiert.  Black Boxes umfassen modellbasierte Tests, Verwendungstests, Statusübergangstabellen, Spezifikationstests usw. </li><li>  Das Testen des Typs „ <b>graue Box</b> “ basiert auf Kenntnissen über Softwarealgorithmen und Datenstrukturen (weiße Box), wird jedoch auf Benutzerebene durchgeführt (schwarze Box).  Dies umfasst Regressionstests und Mustertests. </li></ul><br>  Um Sie zu verwirren, möchte ich sagen, dass <b>Unit-Tests</b> auch für die „Black Box“ gelten können, da Sie das <b>zu testende</b> Modul verstehen können, aber nicht das gesamte System.  Obwohl es für mich immer noch eine "weiße Kiste" ist, und ich schlage vor, Sie stimmen dem zu. <br><br><h2>  Testlevel </h2><br>  Ihre Anzahl variiert, normalerweise im Bereich von 4 bis 6, und sie sind alle nützlich.  Die Namen können auch unterschiedlich sein. Abhängig von der Unternehmenskultur können Sie Integrationstests als funktional, Systemtests als automatisiert usw. bezeichnen.  Der Einfachheit halber werde ich 5 Ebenen beschreiben: <br><br><ol><li>  <b>Unit Testing</b> </li><li>  Integrationstests. </li><li>  Testen von Komponentenschnittstellen. </li><li>  Systemtests. </li><li>  Prüfung der Betriebsabnahme. </li></ol><br>  <b>Unit-</b> Tests <b>testen</b> die Funktionalität eines bestimmten Codeteils, normalerweise jeweils eine Funktion.  Beim Integrationstest werden die Schnittstellen zwischen den Komponenten überprüft, sodass die zusammengesetzten Module ein System bilden, das wie vorgesehen funktioniert.  Dies ist ein wichtiger Punkt, da eine große Anzahl von Tests, die als Komponententests bezeichnet werden, tatsächlich Integrationstests sind und Entwickler sie als Module betrachten.  Wenn Sie mehrere Module verwenden möchten, wird die Integration zwischen diesen Modulen getestet, nicht die Module selbst.  Das Testen von Komponentenschnittstellen überprüft die zwischen verschiedenen Modulen übertragenen Daten.  Zum Beispiel haben wir Daten von Modul 1 erhalten - geprüft - an Modul 2 übertragen - geprüft.  Systemtests sind End-to-End-Tests, um die Einhaltung aller Anforderungen zu überprüfen.  Betriebsabnahmetests werden durchgeführt, um die Betriebsbereitschaft zu überprüfen.  Es ist nicht funktionsfähig, nur die Wartungsfreundlichkeit der Dienste wird überprüft, ob Subsysteme die Umgebung und andere Dienste beschädigen. <br><br><h2>  Arten von Tests </h2><br>  Jede Art von Test kann unabhängig von ihrer Stufe auch in andere Arten unterteilt werden.  Es gibt mehr als 20 gängige Typen.  Am häufigsten: <br><br><ul><li>  <b>Regressionstests</b> . </li><li>  Abnahmetests. </li><li>  Rauchprüfung </li><li>  Uat </li><li>  <b>Zerstörende Prüfung</b> . </li><li>  Leistungstests. </li><li>  <b>Kontinuierliche Prüfung</b> . </li><li>  Usability-Tests. </li><li>  Sicherheitstests. </li></ul><br>  Aus dem Namen geht hervor, warum diese oder jene Art von Tests beabsichtigt ist.  Fett sind die Unit-Tests in PHP.  Wenn Sie wirklich wollen, können Sie jeden dieser Begriffe auf Unit-Tests anwenden.  Die Hauptvielfalt der Komponententests sind jedoch Regressionstests, bei denen überprüft wird, ob alle Module des Systems nach Änderungen am Code korrekt ausgeführt werden. <br><br>  Jetzt wissen Sie, dass Komponententests dynamisch sind, zur White-Box-Klasse gehören, auf Modulebene durchgeführt werden, Regressionstests sind, aber modulare Tests können als viele Arten von Tests verstanden werden.  Was sind Unit-Tests wirklich? <br><br><h2>  Was ist Unit Testing? </h2><br>  Ein V-Modell ist eine grafische Darstellung der oben genannten Ebenen, Typen und ihres Zwecks im Lebenszyklus der Softwareentwicklung. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  Nach Überprüfung und Genehmigung der detaillierten Anforderungen für das Produkt, wenn mit dem Schreiben von Code begonnen wurde, werden Unit-Tests zur ersten Verteidigungslinie gegen Inkonsistenzen.  Daher zwingen Unternehmen, die verstehen, was sie tun, Entwickler, Unit-Tests oder sogar TDD zu verwenden, da es viel billiger ist, Fehler in der Anfangsphase zu beheben als in den späteren. <br><br>  Und das ist fair.  Unit-Tests haben viele Vorteile.  Sie sind: <br><br><ul><li>  Isolieren Sie jeden Teil des Programms und überprüfen Sie die Richtigkeit. </li><li>  Helfen Sie, Probleme frühzeitig zu erkennen. </li><li>  Sie lassen Entwickler in Bezug auf Eingabe, Ausgabe und fehlerhafte Bedingungen denken. </li><li>  Sie geben dem Code ein bequemes Aussehen zum Testen und erleichtern das zukünftige Refactoring. </li><li>  Vereinfachen Sie die Integration von Arbeitsmodulen (!). </li><li>  Ersetzen Sie die technische Dokumentation teilweise. </li><li>  Erzwungen, die Schnittstelle von der Implementierung zu trennen. </li><li>  Sie beweisen, dass der Modulcode wie erwartet funktioniert (zumindest mathematisch). </li><li>  Kann als Low-Level-Regressionstestsuite verwendet werden. </li><li>  Demonstrieren Sie Fortschritte bei der unvollständigen Systemintegration. </li><li>  Reduzieren Sie die Kosten für die Behebung von Fehlern (mit TDD - noch mehr). </li><li>  Mit ihnen können Sie die Architektur der Anwendung verbessern, indem Sie die Verantwortung der Module bestimmen. </li><li>  Wenn Sie es testen können, können Sie es an Ihr System anschließen. </li><li>  Unit Testing macht Spaß! </li></ul><br>  Es gibt jedoch bestimmte Einschränkungen, über die Sie nachgedacht haben, wahrscheinlich beim Lesen dieser Liste: <br><br><ul><li>  Unit-Tests erkennen keine Integrationsfehler. </li><li>  Jeder Boolesche Ausdruck erfordert mindestens zwei Tests, und die Anzahl wächst schnell. </li><li>  Unit-Tests sind genauso fehlerhaft wie der Code, den sie testen. </li><li>  Das Verknüpfen von Tests mit bestimmten Frameworks oder Bibliotheken kann den Workflow einschränken. </li><li>  Die meisten Tests werden nach Abschluss der Entwicklung geschrieben.  Es ist traurig.  Verwenden Sie TDD! </li><li>  Möglicherweise funktioniert das System nach einer kleinen Umgestaltung wie zuvor, aber die Tests schlagen fehl. </li><li>  Die Entwicklungskosten steigen. </li><li>  Menschliches Versagen: Kommentieren gebrochener Tests. </li><li>  Menschliches Versagen: Hinzufügen von Problemumgehungen zum Code speziell zum Bestehen von Komponententests. </li></ul><br>  Letzteres bringt mich am meisten um.  (Fast) in jedem Projekt, direkt im Quellcode der Arbeitsanwendung, finde ich Zeilen wie "Wenn es sich um einen Komponententest handelt, laden Sie eine Ersatz-SQLite-Datenbank, andernfalls laden Sie eine andere Datenbank" oder "Wenn es sich um einen Komponententest handelt, senden Sie keine E-Mail, andernfalls." senden “und so weiter.  Wenn Ihre Anwendung eine schlechte Architektur hat, tun Sie nicht so, als könnten Sie miese Software mit einem guten Testdurchlauf reparieren, da dies nicht besser wird. <br><br>  Ich habe oft mit Kollegen und Kunden darüber gesprochen, was ein guter Unit-Test ist.  Er: <br><br><ul><li>  Schnell. </li><li>  Automatisiert. </li><li>  Steuert alle Abhängigkeiten vollständig. </li><li>  Zuverlässig: Es kann in beliebiger Reihenfolge gestartet werden, unabhängig von anderen Tests. </li><li>  Es kann nur im Speicher ausgeführt werden (keine Interaktionen mit der Datenbank, Lese- / Schreibvorgänge im Dateisystem). </li><li>  Gibt immer ein einzelnes Ergebnis zurück. </li><li>  Praktisch zum Lesen und Begleiten. </li><li>  Testet die SUT-Konfiguration nicht (System im Test). </li><li>  Hat eine klar definierte EINZELAUFGABE. </li><li>  Es ist gut benannt (und verständlich genug, um das Debuggen zu vermeiden, nur um herauszufinden, was fehlschlägt). </li></ul><br>  Für diejenigen, die nach dem Lesen von „automatisiert“ grinsten: Ich wollte nicht PHPUnit oder JUnit in CI-Pipelines integrieren.  Der Punkt ist, dass wenn Sie den Code ändern, ihn speichern und nicht wissen, ob die Module ihre Tests bestehen, sie nicht automatisiert sind, sondern sollten.  Die beste Option ist die Dateiverfolgung. <br><br><h2>  Was sollte einem Unit-Test unterzogen werden? </h2><br>  In normalen Systemen müssen Komponententests geschrieben werden für: <br><br><ul><li>  Module - unteilbare isolierte Teile des Systems, die eine Aufgabe ausführen (Funktion, Methode, Klasse). </li><li>  Öffentliche Methoden. </li><li>  Geschützte Methoden, aber nur in seltenen Fällen und wenn niemand sieht. </li><li>  Bugs und ihre Korrekturen. </li></ul><br>  Die Definition eines Komponententests hängt vom Entwickler ab, der den Code geschrieben hat.  In PHP handelt es sich fast immer um eine Klassenmethode oder -funktion, da es sich um eine <b>unteilbare Software handelt, die für sich genommen Sinn macht</b> .  Mehrmals habe ich gesehen, wie Entwickler ein Array von Miniklassen mit einer Methode als einzelnes Modul verwendeten.  Dies ist sinnvoll, wenn für eine minimale Funktionalität mehrere Objekte erforderlich sind. <br><br>  So können Sie selbst bestimmen, was ein Modul für Sie ist.  Oder Sie können die Methoden einzeln testen, um dem Kerl das Leben zu erleichtern, der dann mit dem Code arbeitet. <br><br>  Wenn Sie keine Unit-Tests durchführen, schlage ich vor, dies nach dem nächsten großen Fehler zu tun.  Überprüfen Sie, mit welcher Methode es verknüpft wird, schreiben Sie einen fehlgeschlagenen Test mit den richtigen Argumenten und Ergebnissen, beheben Sie den Fehler und führen Sie den Komponententest erneut aus.  Wenn es bestanden wird, können Sie sicher sein, dass dieser Fehler zum letzten Mal behoben werden musste (unter Berücksichtigung Ihrer spezifischen Eingabeszenarien). <br><br>  Dieser Ansatz erleichtert das Verständnis von Unit-Tests.  Analysieren Sie jede Methode separat.  Datenanbieter können Ihnen dabei helfen, die Ein- und Ausgabe für jedes Szenario zu bestimmen, das Ihnen in den Sinn kommt. Unabhängig davon, was passiert, wissen Sie, was Sie erwartet. <br><br><h2>  Was muss NICHT getestet werden </h2><br>  Es ist etwas schwieriger festzustellen, dass Sie nicht testen müssen.  Ich habe versucht, eine Liste von Elementen zu erstellen, <b>die keinen</b> Unit-Tests unterzogen werden müssen: <br><br><ul><li>  Funktionalität außerhalb des Modulumfangs (!) </li><li>  Integration von Modulen mit anderen Modulen (!) </li><li>  Nicht isoliertes Verhalten (nicht blockierbare Abhängigkeiten, reale Datenbanken, Netzwerk) </li><li>  Private, sichere Methoden. </li><li>  Statische Methoden. </li><li>  Externe Bibliotheken. </li><li>  Ihr Rahmen. </li></ul><br>  Ich bin sicher, dass Unit-Tests auf keine der oben genannten Methoden angewendet werden sollten, außer auf statische Methoden.  Ich möchte argumentieren, dass statisch im Wesentlichen Prozeduralität bedeutet und in vielen Fällen prozedural ist.  Wenn die statische Methode eine andere statische Methode aufruft, kann diese Abhängigkeit nicht überschrieben werden.  Dies bedeutet, dass Sie jetzt isoliert testen.  Und dann ist dies kein Unit-Test mehr.  Auf der anderen Seite ist dies der Teil des Codes, der für sich alleine leben kann, er hat einen Zweck und er muss getestet werden, um sicherzustellen, dass er nicht kaputt geht, egal welchen Teil dieses dummen Systems der getestete Teil des Codes aufruft.  Daher glaube ich, dass Sie statische Methoden testen können, wenn Sie sicher sind, dass die Ausgabe Ihres Tests durch keinen anderen Test geändert werden kann und die Sprache oder das Framework es Ihnen ermöglicht, nativ zu testen. <br><br><h2>  Wie schreibe ich Unit-Tests? </h2><br><ul><li>  Schreiben Sie einen Code, der für Unit-Tests geeignet ist, und testen Sie ihn dann. </li><li>  Schreiben Sie einen Code, der für Unit-Tests geeignet ist, und testen Sie ihn dann. </li><li>  Schreiben Sie einen Code, der für Unit-Tests geeignet ist, und testen Sie ihn dann. </li></ul><br>  Wenn "dann testen" nicht ausreicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bietet laracasts.com</a> sehr gute Videos zum Testen von PHP-Einheiten.  Es gibt viele Websites, die sich derselben Aufgabe in anderen Sprachen widmen.  Ich sehe keinen Grund zu erklären, wie ich Unit-Tests durchführe, da sich die Tools ziemlich schnell ändern und ich beim Lesen dieses Textes von PHPUnit zu Kahlan wechseln kann.  Oder nicht.  Wer weiß. <br><br>  Die Beantwortung der ersten Frage (Schreiben von Code, der für Unit-Tests geeignet ist) ist jedoch viel einfacher, und es ist unwahrscheinlich, dass sich die Situation im Laufe der Zeit wesentlich ändert: <br><br><ul><li>  <b>FEST</b> </li><li>  <b>TROCKEN</b> </li><li>  Das Fehlen <b>neuer</b> Schlüsselwörter im Konstruktor. </li><li>  Das Fehlen von <b>Schleifen</b> im Konstruktor (und Übergängen, falls angegeben). </li><li>  Mangel an statischen Methoden, Parametern, Klassen. </li><li>  Fehlende setup () -Methoden: Objekte müssen nach der Erstellung vollständig initialisiert werden. </li><li>  Das Fehlen von Singleton (globaler Status) und anderen nicht testbaren Antimustern. </li><li>  Der Mangel an allmächtigen Objekten (Gottobjekten). </li><li>  Mangel an Klassen mit gemischter Funktionalität (gemischte Anliegenklassen). </li><li>  Keine versteckten Abhängigkeiten. </li></ul><br>  Wenn Sie nun wissen, was die Komponententests sind und was nicht, was Sie benötigen und was Sie nicht testen müssen, welchen Platz die Komponententests im Lebenszyklus der Softwareentwicklung einnehmen, können Sie sie einfacher implementieren.  Es bleibt ein Rahmen oder eine Bibliothek nach Ihren Wünschen zu finden.  Nehmen Sie im Zweifelsfall das De-facto-Standard-Framework / die Standardsprache. <br><br>  Fazit: Unit-Tests sind sowohl für Entwickler als auch für Unternehmen sehr wichtig.  Sie müssen geschrieben werden. Es gibt bewährte Methoden, mit denen Sie Module problemlos mit Tests abdecken können, hauptsächlich indem Sie die Module selbst vorbereiten.  Alle diese Techniken sind jedoch ohne Kenntnis der in diesem Artikel beschriebenen Testtheorie nicht sinnvoll.  Sie müssen in der Lage sein, Komponententests von Tests anderer Typen zu unterscheiden.  Und wenn Sie ein klares Verständnis in Ihrem Kopf haben, wird es für Sie viel einfacher, Tests zu schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412695/">https://habr.com/ru/post/de412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412685/index.html">Unity GPU Path Tracing - Teil 2</a></li>
<li><a href="../de412687/index.html">Implementieren Sie IdM. Verfahren und technische Mittel - von Basic bis IdM</a></li>
<li><a href="../de412689/index.html">Predictive IT Analytics optimieren die verteilte Anwendungsüberwachung</a></li>
<li><a href="../de412691/index.html">5 Jahre Witz auf Facebook oder forensische Geschichte</a></li>
<li><a href="../de412693/index.html">Schreiben Sie Code, der leicht zu entfernen und zu debuggen ist</a></li>
<li><a href="../de412697/index.html">IoT als universelles Fachgebiet für eine multidisziplinäre technische Universität</a></li>
<li><a href="../de412699/index.html">Einfache Erklärung der SOLID-Prinzipien</a></li>
<li><a href="../de412701/index.html">Die intelligenteste Heizung</a></li>
<li><a href="../de412703/index.html">Bei einer Konferenz mit Veeam: ein Rückblick auf VeeamON 2018 und eine Einladung zum VeeamON-Forum in Moskau</a></li>
<li><a href="../de412705/index.html">Das System gehackt: Wie wir die Auswahl und Anpassung von Entwicklern geändert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>