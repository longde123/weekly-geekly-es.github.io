<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏷️ 🕰️ 👨🏿‍🎨 UDB. O que é isso? Parte 6. Módulo de Status e Controle 🛩️ 👃🏽 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em artigos anteriores, traduções da documentação do Cypress, o autômato operacional Datapath foi considerado muito substancialmente. Gradualmente, pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB. O que é isso? Parte 6. Módulo de Status e Controle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443380/"><img src="https://habrastorage.org/webt/mf/zu/nx/mfzunxkuzhcahgj4dodvrfn2i18.jpeg"><br><br>  Em artigos anteriores, traduções da documentação do Cypress, o autômato operacional Datapath foi considerado muito substancialmente.  Gradualmente, passamos ao estudo de outros módulos UDB, em particular o módulo de gerenciamento e status. <a name="habracut"></a><br><br>  O conteúdo geral do ciclo “UDB.  O que é isso? " <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1. Introdução.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pld.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. Datapath.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3. Datapath FIFO.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4. Datapath ALU.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5. Caminho de Dados.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pequenas coisas úteis.</a> <br>  Parte 6. Módulo de gerenciamento e status.  (Artigo atual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7. Módulo de controle de tempo e redefinição</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 8. Endereçando UDB</a> <br><br><h2>  21.3.3  Módulo de Gerenciamento e Status </h2><br>  Uma visão de alto nível do módulo de controle e status é mostrada na Figura 21-28.  Os bits de status do registro de controle são transferidos para rastrear recursos, dando ao programa a capacidade de controlar o comportamento do UDB.  O registro de status recebe dados de linhas de rastreamento, para que o programa possa monitorar as operações executadas pelo UDB. <br><br><img src="https://habrastorage.org/webt/4n/0g/wf/4n0gwf_b13miix_dof5ojhxwltk.png"><br>  <i>Figura 21-28.</i>  <i>Registros de gerenciamento e status.</i> <br><br>  A estrutura do módulo de controle e o status são mostrados em mais detalhes na Figura 21-29.  O principal objetivo desta unidade é coordenar a interação do programa principal do processador com o trabalho dos elementos internos do UDB.  No entanto, devido à forte conexão com a matriz de rastreamento, esse bloco pode ser configurado para executar outras funções. <br><br><img src="https://habrastorage.org/webt/rh/ak/9e/rhak9e-mn02qvbn0-di2e_81r_i.png"><br>  <i>Figura 21-29.</i>  <i>Módulo de controle e status.</i> <br><br>  Modos de operação: <br><br><ul><li>  <b>Entrada de status</b>  O status das linhas encerradas do lado de fora pode ser inserido e capturado como status, após o qual a CPU ou o DMA é lido. </li><li>  <b>Saída de controle</b>  A CPU ou DMA pode gravar dados no registro de controle.  Esses dados determinarão o estado das linhas que vão para os recursos de rastreamento. </li><li>  <b>Entrada Paralela</b> - para o caminho de dados da entrada paralela. </li><li>  <b>Saída paralela</b> - da saída paralela do Datapath. </li><li>  <b>Modo Contador</b>  Nesse modo, o registro de controle opera como um contador decrescente de 7 bits com um período programável e redefinição automática.  As entradas do canal de rastreamento podem ser configuradas para controlar e reiniciar o contador.  Quando este modo é ativado, a funcionalidade do registro de controle não está disponível. </li><li>  <b>Modo Síncrono / Modo de Sincronização</b> .  Nesse modo, o registro de status atua como um sincronizador duplo de 4 bits.  Quando este modo é ativado, a funcionalidade do registro de status não está disponível. </li></ul><br><h2>  21.3.3.1 Status e modo de controle </h2><br>  Ao operar no modo de controle e status, este módulo atua como um registro de status, registro de substituição de máscara e registro de controle na configuração mostrada na Figura 21-30. <br><br><img src="https://habrastorage.org/webt/t3/2j/hk/t32jhkcoc-imxe6vuwpuv91b_rs.png"><br>  <i>Figura 21-30.</i>  <i>Gerenciamento de trabalho e status.</i> <br><br><h4>  Operação de registro de status </h4><br>  Cada UDB possui um registro de status de 8 bits.  A entrada para este registro vem de qualquer sinal de uma estrutura de rastreamento digital.  O registro de status é destrutível: perde seu estado durante o sono e depois de acordar tem um valor de 0x00.  Cada bit pode ser programado independentemente para operar em um dos dois modos. <br><br>  Tabela 21-19.  Status Register. <br><br><div class="scrollable-table"><table><tbody><tr><th>  <b>STAT MD</b> </th><th>  <b>Descrição do produto</b> </th></tr><tr><td>  0 0 </td><td>  Leitura normal.  Retorna o valor atual do sinal de entrada. </td></tr><tr><td>  1 </td><td>  Furar, limpo ao ler.  Travas de alto nível de entrada <br>  em um sinal de relógio.  Limpo após a leitura do registro. </td></tr></tbody></table></div><br>  Uma característica importante da operação de limpeza do registro de status é que apenas os bits engatilhados são limpos.  Isso permite que os bits restantes continuem capturando o status para manter a continuidade do processo. <br><br><h4>  Status de leitura normal </h4><br>  Por padrão, a CPU lê transparentemente o status do circuito correspondente.  Este modo pode ser usado para ler dados travados dentro do UDB. <br><br><h4>  Estado do stick com claro após a leitura </h4><br>  Nesse modo, as entradas do registro de status são amostradas em cada ciclo de controle e relógio de status.  Se o sinal em um determinado relógio for alto, ele será capturado no bit de status e permanecerá alto, independentemente dos estados de entrada subsequentes.  Quando a CPU ou o DMA lê o registro de status, o bit é limpo.  A limpeza do registro de status é independente do modo e ocorre mesmo quando o relógio UDB está desativado;  é baseado no tempo do barramento e ocorre como parte de uma operação de leitura. <br><br><h4>  Status da trava durante a leitura </h4><br>  A Figura 21-31 mostra a estrutura da lógica de leitura de status.  O registro de status fixo é seguido por uma trava que trava os dados do registro de status e os mantém estáveis ​​durante o ciclo de leitura, independentemente do número de tiques de espera na operação de leitura atual. <br><br><img src="https://habrastorage.org/webt/vc/0w/3c/vc0w3cd0tr9yc51xphqneftldra.png"><br>  <i>Figura 21-31.</i>  <i>A lógica do status de leitura.</i> <br><br><h4>  Geração de interrupção </h4><br>  Na maioria das funções, a geração de interrupção está vinculada aos parâmetros do bit de status.  Como mostra a Figura 21-31, esse recurso é incorporado à lógica do registro de status na forma de uma operação de mascaramento e a aplicação da operação <b>OR</b> ao status.  Somente os 7 bits inferiores da entrada de status podem ser usados ​​com os geradores de interrupção embutidos.  O bit mais significativo (Most Significant Bit, MSB) é geralmente usado como uma saída de interrupção e pode ser encaminhado para o controlador de interrupção usando canais de rastreamento digital.  Nesta configuração, o status do bit de solicitação de interrupção é lido no bit de registro de status alto. <br><br><h2>  21.3.3.2 Operação do registro de controle </h2><br>  Cada UDB possui um registro de controle de 8 bits disponível.  Ele funciona como um registro de leitura / gravação padrão no barramento do sistema, onde a saída desses bits de registro é controlada pelas linhas da estrutura de rastreamento digital. <br><br>  O registro de controle é destrutível: perde seu estado durante o sono e depois de acordar tem um valor de 0x00. <br><br><h4>  Modos de registro de gerenciamento </h4><br>  Cada bit pode ser configurado em um dos três modos.  A configuração é especificada combinando os bits dos dois registradores de 8 bits CTL_MD1 [7: 0] e CTL_MD0 [7: 0].  Por exemplo, {CTL_MD1 [0], CTL_MD0 [0]} controla o modo de zero bits do registro de controle (consulte a tabela 21-20). <br><br>  Tabela 21-20.  Modo Zero Bit de Registro de Controle <br><div class="scrollable-table"><table><tbody><tr><th>  <b>CTL MD</b> </th><th>  <b>Descrição do produto</b> </th></tr><tr><td>  00 </td><td>  Modo Direto </td></tr><tr><td>  01 </td><td>  Modo de sincronização </td></tr><tr><td>  10 </td><td>  (reservado) </td></tr><tr><td>  11 </td><td>  Modo de pulso </td></tr></tbody></table></div><br><h4>  Modo de registro de controle direto </h4><br>  Por padrão, o modo é direto.  Como mostra a Figura 21-32, quando a CPU ou DMA é gravada no registro de controle, a saída do registro de controle é enviada diretamente para a linha de rastreamento no mesmo ciclo. <br><br><img src="https://habrastorage.org/webt/ft/cl/q-/ftclq-bcwhq3r_kozkj3vrwuli0.png"><br>  <i>Figura 21-32.</i>  <i>Modo de registro de controle direto.</i> <br><br><h4>  Modo de registro de controle síncrono </h4><br>  No modo síncrono, como mostrado na Figura 21-33, a saída do registro de controle é ressincronizada com um relógio igual ao relógio atual do controle e status (Status e Controle, SC).  Isso permite controlar os diagramas de tempo da saída na frequência SC selecionada e não na freqüência do relógio do barramento. <br><br><img src="https://habrastorage.org/webt/jd/a6/7s/jda67s-pgp1kw-03dnttxc-zdcq.png"><br>  <i>Figura 21-33.</i>  <i>Modo de registro de controle síncrono.</i> <br><br><h4>  Registro de controle do modo de pulso </h4><br>  O modo de pulso é semelhante ao modo síncrono, pois nele o bit de controle é amostrado novamente na frequência SC;  o pulso começa no primeiro ciclo do relógio SC e segue o ciclo de gravação do barramento.  A saída do bit de controle é definida durante um ciclo completo do relógio SC.  No final deste ciclo de clock, o bit de controle é redefinido automaticamente. <br><br>  Com este modo de operação, o programa pode escrever 1 no bit de registro de controle para gerar um pulso.  Após o bit ser atribuído ao valor 1, o programa o lerá como 1 até o final do pulso, após o qual será lido como 0. Depois disso, o programa poderá escrever outro 1 para iniciar um novo pulso.  Assim, não será possível dar um pulso com mais frequência do que em cada segundo passo do sinal SC. <br><br><h4>  Redefinir registro de gerenciamento </h4><br>  O registro de controle possui dois modos de reset controlados pelo bit de configuração EXT RES, conforme mostrado na Figura 21-34.  Quando EXT RES é 0 (padrão), no modo síncrono ou de pulso, a entrada de redefinição rastreada redefine a saída sincronizada, mas não o próprio bit de controle.  Quando EXT RES é 1, a entrada de redefinição rastreável redefine o bit de controle e a saída sincronizada. <br><br><img src="https://habrastorage.org/webt/lo/ho/dl/lohodlp2-dbsqoqzpwurp8hx2di.png"><br>  <i>Figura 21-34.</i>  <i>Redefina o registro de gerenciamento.</i> <br><br><h2>  21.3.3.3 Modo de entrada / saída paralela </h2><br>  Nesse modo, o controle e o rastreamento de status são conectados aos sinais do Datapath de entrada e saída paralela.  Para ativar esse modo, você precisa armar os bits de configuração do SC OUT para selecionar a saída paralela do Datapath.  A comunicação com entrada paralela está sempre disponível, no entanto, essas conexões de rastreamento são compartilhadas com as entradas de registro de status, entradas de controle de contador e saídas de interrupção. <br><br><img src="https://habrastorage.org/webt/9c/se/c2/9csec2u290m0hm1qaecqxpyybhe.png"><br>  <i>Figura 21-35.</i>  <i>Modo de E / S paralela.</i> <br><br><h2>  21.3.3.4 Modo contador </h2><br>  Conforme mostrado na Figura 21-36, quando a unidade opera no modo contador, um contador decrescente de 7 bits está disponível para uso tanto nas operações dentro do UDB quanto para as necessidades do programa.  Os recursos do medidor incluem: <br><br><ul><li>  Registro de período de 7 bits, (leitura / gravação). </li><li>  Registro de conta de 7 bits, (leitura / gravação).  O acesso é possível apenas quando o contador está parado. </li><li>  Recarrega automaticamente o período no registro da conta quando atinge zero. </li><li>  O bit de controle acessível por software no registro de controle auxiliar CNT START, usado para iniciar e parar o contador.  (Sobrepõe o sinal de hardware ENABLE e deve ser instalado para que o sinal de hardware opcional ENABLE funcione). </li><li>  Bits selecionáveis ​​dos canais de rastreamento do controle dinâmico opcional do contador para as funções de início e carregamento: <br>  - PT, sinal rastreado para iniciar ou parar a contagem. <br>  - LD, um sinal de carga rastreável que causa uma recarga de período.  Quando esse sinal é engatilhado, ele se sobrepõe ao sinal final pendente.  É sensível ao nível e, enquanto o sinal está armado, o período continua a carregar. </li><li>  Um contador de 7 bits pode ser enviado para rastrear recursos como sc_out [6: 0]. </li><li>  O sinal de terminação pode inserir recursos de rastreamento como sc_out [7]. </li><li>  No modo "padrão", o modo de encaixe é usado para o sinal de contagem.  No modo alternativo, alterna para o modo combinado. </li><li>  No modo padrão, o sinal EN de hardware opcional, se usado, deve ser definido para ativar o sinal de hardware LD.  No modo alternativo, os sinais de hardware LD e EN são independentes. </li></ul><br><img src="https://habrastorage.org/webt/no/ov/up/noovupgcemdnnl1v6ak4tyl1rnq.png"><br>  <i>Figura 21-36.</i>  <i>Modo contador</i> <br><blockquote>  <i><b>Nota do tradutor:</b></i> <br>  Em torno deste lugar, percebi que não entendia completamente nada do documento.  Em nenhum lugar são descritos os modos "padrão" e "alternativo".  Depois de uma longa pesquisa, consegui encontrar alguns, mas um exemplo. <br>  Arquivo: C: \ Arquivos de programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ psoc \ content \ CyComponentLibrary \ CyComponentLibrary.cylib \ bScanComp_v1_10 \ bScanComp_v1_10.v <br>  Código explicativo: <br><br><img src="https://habrastorage.org/webt/ba/rf/13/barf13t7suartgjw8b0frvtsccs.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto:</b> <div class="spoiler_text"><pre><code class="plaintext hljs">cy_psoc3_count7 #(.cy_period(Period),.cy_route_ld(0),.cy_route_en(1), .cy_alt_mode(1)) ChannelCounter( /* input */ .clock(clk_int), /* input */ .reset(1'b0), /* input */ .load(1'b0), /* input */ .enable(enable_int), /* output [06:00] */ .count(count), /* output */ .tc(tc_o) );</code> </pre> <br></div></div><br>  A própria declaração do componente cy_psoc3_count7 que encontrei apenas para a linguagem VHDL, parece que para o Verilog ele está embutido nas ferramentas de desenvolvimento.  Agora você sabe aproximadamente onde procurar os bits de ajuste em discussão. <br><br>  Aqui consideramos os bits misteriosos, chamados SC OUT CTL ou SC_OUT_CTL, mas seus valores não estão documentados.  Eu não os encontrei em lugar nenhum.  Fica claro no texto que eles alternam o componente STATUS_CONTROL entre os modos.  Mas no arquivo VHDL mencionado anteriormente, C: \ Arquivos de programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ lcpsoc3 \ cpsoc3.vhd <br><br><div class="spoiler">  <b class="spoiler_title">vemos separadamente o contador já conhecido por nós</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_count7 generic(cy_period : std_logic_vector (6 downto 0) := "1111111"; cy_init_value : std_logic_vector (6 downto 0) := "0000000"; cy_route_ld : boolean := false; cy_route_en : boolean := false; cy_alt_mode : boolean := false); port (clock : in std_logic; reset : in std_logic; load : in std_logic; enable : in std_logic; count : out std_logic_vector (6 downto 0); tc : out std_logic); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">separadamente - status e gerenciamento</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> attribute atomic_rtl of cy_psoc3_status : component is rtl_generic; attribute cpu_access of cy_psoc3_status : component is true; component cy_psoc3_statusi generic(cy_force_order : boolean := false; cy_md_select : std_logic_vector (6 downto 0) := "0000000"; cy_int_mask : std_logic_vector (6 downto 0) := "0000000"); port (reset : in std_logic := '0'; clock : in std_logic := '0'; status : in std_logic_vector (6 downto 0); interrupt : out std_logic); end component; attribute atomic_rtl of cy_psoc3_statusi : component is rtl_generic; attribute cpu_access of cy_psoc3_statusi : component is true; component cy_psoc3_control generic(cy_init_value : std_logic_vector (7 downto 0) := "00000000"; cy_force_order : boolean := false; cy_ctrl_mode_1 : std_logic_vector (7 downto 0) := "00000000"; cy_ctrl_mode_0 : std_logic_vector (7 downto 0) := "00000000"; cy_ext_reset : boolean := false); port (reset : in std_logic := '0'; clock : in std_logic := '0'; control : out std_logic_vector (7 downto 0)); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">separadamente - sincronizador</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_sync port (clock : in std_logic := '0'; sc_in : in std_logic; sc_out : out std_logic); end component;</code> </pre><br></div></div><br>  Repito que o Verilog não possui uma versão dessas declarações (existem apenas modelos comportamentais no diretório C: \ Arquivos de Programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim, então acho que a configuração dos bits Os modos não são acessíveis a programadores simples Ao ler esta seção, lembre-se desse fato: algo é fornecido apenas como referência, não está sujeito a nós, programadores. </blockquote>  Para ativar o modo contador, a saída do contador deve ser selecionada nos bits SC_OUT_CTI [1: 0].  Nesse modo, a operação normal do registro de controle não está disponível.  Ao mesmo tempo, o registro de status pode ser usado para operações de leitura, mas você não deve usá-lo para gerar uma interrupção, pois o registro de mapeamento de máscara também é usado como um registro de período de contagem.  O registro do período não é destruído e mantém seu estado após acordar.  Para um período de N medidas, o valor N-1 deve ser carregado no registro de período.  O valor N = 1 (o período é zero), pois o valor do divisor de frequência não é suportado e levará a uma unidade constante na saída do TC (contagem de terminais, TC).  A disponibilidade do modo SYNC depende se o controle dinâmico (LD / EN) é usado ou não.  Se não for utilizado, não afeta o modo SYNC.  Se usado, o modo SYNC não está disponível. <br><br><h2>  21.3.3.5 Modo de sincronização </h2><br>  Conforme mostrado na Figura 21-37, o registro de status pode operar como um relógio duplo de 4 bits sincronizado com o valor atual SC_CLK se o bit SYNC MD estiver definido.  Este modo pode ser usado para implementar a sincronização local de sinais assíncronos (por exemplo, entradas GPIO).  Nesse caso, os sinais sincronizados são selecionados em SC_IN [3: 0], as saídas são roteadas para os contatos SC_IO_OUT [3: 0] e o SYNC MD alterna automaticamente os contatos SC_IO para o modo de saída.  Nesse modo, a operação normal do registro de status não está disponível e o modo de bit de status fixo é desativado à força, independentemente das configurações de controle do modo.  Este modo não afeta o registro de controle.  O contador ainda pode ser usado, mas com limitações.  Neste modo de operação, as entradas dinâmicas (LD / EN) não podem ser usadas. <br><br><img src="https://habrastorage.org/webt/ol/cw/6z/olcw6ztxrs5xqzb-9l0i6uyyqa8.png"><br>  <i>Figura 21-37.</i>  <i>Modo síncrono.</i> <br><br><h2>  21.3.3.6 Status e controle de relógio </h2><br>  Os registros de controle e status requerem uma seleção de relógio em qualquer um dos seguintes modos de operação: <br><br><ul><li>  registro de status com qualquer bit no modo pegajoso, com limpeza após a leitura, </li><li>  registro de controle no modo contador, </li><li>  modo síncrono. </li></ul><br>  O tempo é atribuído no módulo relógio e redefinição.  Veja 21.3.4.  Relógio e redefinir o módulo de controle. <br><br><h2>  21.3.3.7 Registro de controle auxiliar </h2><br>  O registro de controle auxiliar para leitura e gravação é um registro especial que controla equipamentos UDB fixos.  Esse registro permite que a CPU ou o DMA controle dinamicamente interrupções, FIFOs e operações de contador.  Os bits dos registradores e suas descrições são apresentados abaixo: <br><br><div class="scrollable-table"><table><tbody><tr><th colspan="8">  <b>Registro de controle auxiliar</b> </th></tr><tr><td>  <b>7</b> </td><td>  <b>6</b> </td><td>  <b>5</b> </td><td>  <b>4</b> </td><td>  <b>3</b> </td><td>  <b>2</b> </td><td>  <b>1</b> </td><td>  <b>0 0</b> </td></tr><tr><td></td><td></td><td>  CNT <br>  INICIAR </td><td>  INT PT </td><td>  FIFO1 <br>  LVL </td><td>  FIFO0 <br>  LVL </td><td>  FIFO1 <br>  CLR </td><td>  FIFO0 <br>  CLR </td></tr></tbody></table></div><br><h4>  Clear FIFO0 e FIFO1 (FIFO0 Clear, FIFO1 Clear) </h4><br>  Os bits FIFO0 CLR e FIFO1 CLR são usados ​​para redefinir o status dos FIFOs correspondentes.  Quando 1 é gravado nesses bits, o estado do FIFO correspondente é redefinido.  Para continuar a operação FIFO, é necessário escrever 0. Esses bits permanecem armados.O FIFOs funciona como buffers simples de byte único sem status. <br><br><h4>  Nível FIFO0 e FIFO1 (nível FIFO0, nível FIFO1) </h4><br>  Os bits FIFO0 LVL e FIFO1 LVL definem o nível no qual um FIFO de 4 bytes eleva o status do barramento (quando o barramento lê ou grava no FIFO).  O valor do status do barramento FIFO depende da direção configurada, conforme mostrado na tabela abaixo. <br><br>  Tabela 21-21.  Bits de controle de nível FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  <b>FIFOx</b> <b><br></b>  <b>LVL</b> </th><th>  <b>Modo de entrada</b> <b><br></b>  <b>(O barramento grava no FIFO)</b> </th><th>  <b>Modo de saída</b> <b><br></b>  <b>(O barramento lê do FIFO)</b> </th></tr><tr><td>  0 0 </td><td>  <b>Não está cheio.</b> <br>  Você pode escrever pelo menos 1 byte. <br></td><td>  <b>Não está vazio.</b> <br>  Pelo menos 1 byte está disponível para leitura. </td></tr><tr><td>  1 </td><td>  <b>Devastado por pelo menos metade.</b> <br>  Você pode escrever pelo menos 2 bytes. </td><td>  <b>Pelo menos meio cheio.</b> <br>  Pelo menos 2 bytes estão disponíveis para leitura. </td></tr></tbody></table></div><br><h4>  Ativar interrupção </h4><br>  Quando a lógica de geração do registro de status é ativada, o bit INT EN permite a passagem do sinal de interrupção gerado. <br><br><h4>  Iniciar contador / conta?  (Início da contagem) </h4><br>  O bit CNT START pode ser usado para iniciar e parar o contador (disponível apenas se os bits SC_OUT_CTL [1: 0] estiverem configurados para o modo de saída do contador). <br><br><h2>  21.3.3.8 Resumo dos registros de gerenciamento e status </h2><br>  A tabela abaixo resume as funções dos registros de controle e status.  Observe que os registros de máscara e controle são combinados com contadores e registros de período, e o valor desses registros não depende do modo de operação. <br><br>  Tabela 21-22.  Um breve resumo da operação dos registros de gerenciamento e status <br><div class="scrollable-table"><table><tbody><tr><th>  Mode </th><th>  Gerenciamento / Contador <br>  (Controle / contagem) </th><th>  Status / Sincronização <br>  (Status / SINCRONIZAÇÃO) </th><th>  Sobreposição / período da máscara <br>  (Máscara / Período) </th></tr><tr><td>  Controlar </td><td>  Control Out </td><td rowspan="2">  Status In ou SYNC </td><td>  Máscara de status de sobreposição </td></tr><tr><td>  Contador </td><td>  Counter Out </td><td>  Período de contagem a (Período de contagem) </td></tr><tr><td>  Status </td><td rowspan="2">  Control Out ou Count Out </td><td>  Status em </td><td>  Máscara de status de sobreposição </td></tr><tr><td>  Sincronização (SYNC) </td><td>  Sincronização (SYNC) </td><td>  Não disponível <sup>b</sup> (NA) </td></tr></tbody></table></div><br>  a.  - observe que, no modo contador, o registro de sobreposição de máscara funciona como um registro de período e não pode funcionar como um registro de máscara sobre.  Conseqüentemente, a saída de interrupção não está disponível quando o modo contador está ativado. <br><br>  b.  - observe que no modo de sincronização o registro de status não está disponível e, portanto, é impossível usar o registro de sobreposição de máscara.  No entanto, ele pode ser usado como um registro de período para o modo contador. <br><br>  Para continuar ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443380/">https://habr.com/ru/post/pt443380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443368/index.html">Estamos preparando uma pesquisa de texto completo no Postgres. Parte 2</a></li>
<li><a href="../pt443370/index.html">Conectando o Google reCAPTCHA ao Vue e validando a resposta no servidor</a></li>
<li><a href="../pt443372/index.html">Back-end no CodeFest. Tripas encomendadas?</a></li>
<li><a href="../pt443376/index.html">Conseguiu encontrar dezenas de armazenamentos corporativos da Box.com que divulgam dados da Apple, Herbalife etc.</a></li>
<li><a href="../pt443378/index.html">Estamos escrevendo um cliente http de alto desempenho usando fasthttp como exemplo. Alexander Valyalkin (VertaMedia)</a></li>
<li><a href="../pt443382/index.html">Fintech Digest: Mir Pay para Android, suspendendo a proibição de retirar dinheiro de carteiras anônimas, as startups de IA não são exatamente AI</a></li>
<li><a href="../pt443384/index.html">Slurm e MegaSlerm em Moscou no final de maio</a></li>
<li><a href="../pt443386/index.html">Como obter o log de segurança com usuário não administrativo</a></li>
<li><a href="../pt443388/index.html">Controle de iluminação multinível baseado no KTS NPL</a></li>
<li><a href="../pt443392/index.html">Histórico de salvamento de jogos: de senhas em papel a nuvens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>