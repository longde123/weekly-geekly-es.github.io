<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∑Ô∏è üï∞Ô∏è üë®üèø‚Äçüé® UDB. O que √© isso? Parte 6. M√≥dulo de Status e Controle üõ©Ô∏è üëÉüèΩ üë∂üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em artigos anteriores, tradu√ß√µes da documenta√ß√£o do Cypress, o aut√¥mato operacional Datapath foi considerado muito substancialmente. Gradualmente, pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB. O que √© isso? Parte 6. M√≥dulo de Status e Controle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443380/"><img src="https://habrastorage.org/webt/mf/zu/nx/mfzunxkuzhcahgj4dodvrfn2i18.jpeg"><br><br>  Em artigos anteriores, tradu√ß√µes da documenta√ß√£o do Cypress, o aut√¥mato operacional Datapath foi considerado muito substancialmente.  Gradualmente, passamos ao estudo de outros m√≥dulos UDB, em particular o m√≥dulo de gerenciamento e status. <a name="habracut"></a><br><br>  O conte√∫do geral do ciclo ‚ÄúUDB.  O que √© isso? " <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1. Introdu√ß√£o.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pld.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. Datapath.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3. Datapath FIFO.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4. Datapath ALU.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5. Caminho de Dados.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pequenas coisas √∫teis.</a> <br>  Parte 6. M√≥dulo de gerenciamento e status.  (Artigo atual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7. M√≥dulo de controle de tempo e redefini√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 8. Endere√ßando UDB</a> <br><br><h2>  21.3.3  M√≥dulo de Gerenciamento e Status </h2><br>  Uma vis√£o de alto n√≠vel do m√≥dulo de controle e status √© mostrada na Figura 21-28.  Os bits de status do registro de controle s√£o transferidos para rastrear recursos, dando ao programa a capacidade de controlar o comportamento do UDB.  O registro de status recebe dados de linhas de rastreamento, para que o programa possa monitorar as opera√ß√µes executadas pelo UDB. <br><br><img src="https://habrastorage.org/webt/4n/0g/wf/4n0gwf_b13miix_dof5ojhxwltk.png"><br>  <i>Figura 21-28.</i>  <i>Registros de gerenciamento e status.</i> <br><br>  A estrutura do m√≥dulo de controle e o status s√£o mostrados em mais detalhes na Figura 21-29.  O principal objetivo desta unidade √© coordenar a intera√ß√£o do programa principal do processador com o trabalho dos elementos internos do UDB.  No entanto, devido √† forte conex√£o com a matriz de rastreamento, esse bloco pode ser configurado para executar outras fun√ß√µes. <br><br><img src="https://habrastorage.org/webt/rh/ak/9e/rhak9e-mn02qvbn0-di2e_81r_i.png"><br>  <i>Figura 21-29.</i>  <i>M√≥dulo de controle e status.</i> <br><br>  Modos de opera√ß√£o: <br><br><ul><li>  <b>Entrada de status</b>  O status das linhas encerradas do lado de fora pode ser inserido e capturado como status, ap√≥s o qual a CPU ou o DMA √© lido. </li><li>  <b>Sa√≠da de controle</b>  A CPU ou DMA pode gravar dados no registro de controle.  Esses dados determinar√£o o estado das linhas que v√£o para os recursos de rastreamento. </li><li>  <b>Entrada Paralela</b> - para o caminho de dados da entrada paralela. </li><li>  <b>Sa√≠da paralela</b> - da sa√≠da paralela do Datapath. </li><li>  <b>Modo Contador</b>  Nesse modo, o registro de controle opera como um contador decrescente de 7 bits com um per√≠odo program√°vel e redefini√ß√£o autom√°tica.  As entradas do canal de rastreamento podem ser configuradas para controlar e reiniciar o contador.  Quando este modo √© ativado, a funcionalidade do registro de controle n√£o est√° dispon√≠vel. </li><li>  <b>Modo S√≠ncrono / Modo de Sincroniza√ß√£o</b> .  Nesse modo, o registro de status atua como um sincronizador duplo de 4 bits.  Quando este modo √© ativado, a funcionalidade do registro de status n√£o est√° dispon√≠vel. </li></ul><br><h2>  21.3.3.1 Status e modo de controle </h2><br>  Ao operar no modo de controle e status, este m√≥dulo atua como um registro de status, registro de substitui√ß√£o de m√°scara e registro de controle na configura√ß√£o mostrada na Figura 21-30. <br><br><img src="https://habrastorage.org/webt/t3/2j/hk/t32jhkcoc-imxe6vuwpuv91b_rs.png"><br>  <i>Figura 21-30.</i>  <i>Gerenciamento de trabalho e status.</i> <br><br><h4>  Opera√ß√£o de registro de status </h4><br>  Cada UDB possui um registro de status de 8 bits.  A entrada para este registro vem de qualquer sinal de uma estrutura de rastreamento digital.  O registro de status √© destrut√≠vel: perde seu estado durante o sono e depois de acordar tem um valor de 0x00.  Cada bit pode ser programado independentemente para operar em um dos dois modos. <br><br>  Tabela 21-19.  Status Register. <br><br><div class="scrollable-table"><table><tbody><tr><th>  <b>STAT MD</b> </th><th>  <b>Descri√ß√£o do produto</b> </th></tr><tr><td>  0 0 </td><td>  Leitura normal.  Retorna o valor atual do sinal de entrada. </td></tr><tr><td>  1 </td><td>  Furar, limpo ao ler.  Travas de alto n√≠vel de entrada <br>  em um sinal de rel√≥gio.  Limpo ap√≥s a leitura do registro. </td></tr></tbody></table></div><br>  Uma caracter√≠stica importante da opera√ß√£o de limpeza do registro de status √© que apenas os bits engatilhados s√£o limpos.  Isso permite que os bits restantes continuem capturando o status para manter a continuidade do processo. <br><br><h4>  Status de leitura normal </h4><br>  Por padr√£o, a CPU l√™ transparentemente o status do circuito correspondente.  Este modo pode ser usado para ler dados travados dentro do UDB. <br><br><h4>  Estado do stick com claro ap√≥s a leitura </h4><br>  Nesse modo, as entradas do registro de status s√£o amostradas em cada ciclo de controle e rel√≥gio de status.  Se o sinal em um determinado rel√≥gio for alto, ele ser√° capturado no bit de status e permanecer√° alto, independentemente dos estados de entrada subsequentes.  Quando a CPU ou o DMA l√™ o registro de status, o bit √© limpo.  A limpeza do registro de status √© independente do modo e ocorre mesmo quando o rel√≥gio UDB est√° desativado;  √© baseado no tempo do barramento e ocorre como parte de uma opera√ß√£o de leitura. <br><br><h4>  Status da trava durante a leitura </h4><br>  A Figura 21-31 mostra a estrutura da l√≥gica de leitura de status.  O registro de status fixo √© seguido por uma trava que trava os dados do registro de status e os mant√©m est√°veis ‚Äã‚Äãdurante o ciclo de leitura, independentemente do n√∫mero de tiques de espera na opera√ß√£o de leitura atual. <br><br><img src="https://habrastorage.org/webt/vc/0w/3c/vc0w3cd0tr9yc51xphqneftldra.png"><br>  <i>Figura 21-31.</i>  <i>A l√≥gica do status de leitura.</i> <br><br><h4>  Gera√ß√£o de interrup√ß√£o </h4><br>  Na maioria das fun√ß√µes, a gera√ß√£o de interrup√ß√£o est√° vinculada aos par√¢metros do bit de status.  Como mostra a Figura 21-31, esse recurso √© incorporado √† l√≥gica do registro de status na forma de uma opera√ß√£o de mascaramento e a aplica√ß√£o da opera√ß√£o <b>OR</b> ao status.  Somente os 7 bits inferiores da entrada de status podem ser usados ‚Äã‚Äãcom os geradores de interrup√ß√£o embutidos.  O bit mais significativo (Most Significant Bit, MSB) √© geralmente usado como uma sa√≠da de interrup√ß√£o e pode ser encaminhado para o controlador de interrup√ß√£o usando canais de rastreamento digital.  Nesta configura√ß√£o, o status do bit de solicita√ß√£o de interrup√ß√£o √© lido no bit de registro de status alto. <br><br><h2>  21.3.3.2 Opera√ß√£o do registro de controle </h2><br>  Cada UDB possui um registro de controle de 8 bits dispon√≠vel.  Ele funciona como um registro de leitura / grava√ß√£o padr√£o no barramento do sistema, onde a sa√≠da desses bits de registro √© controlada pelas linhas da estrutura de rastreamento digital. <br><br>  O registro de controle √© destrut√≠vel: perde seu estado durante o sono e depois de acordar tem um valor de 0x00. <br><br><h4>  Modos de registro de gerenciamento </h4><br>  Cada bit pode ser configurado em um dos tr√™s modos.  A configura√ß√£o √© especificada combinando os bits dos dois registradores de 8 bits CTL_MD1 [7: 0] e CTL_MD0 [7: 0].  Por exemplo, {CTL_MD1 [0], CTL_MD0 [0]} controla o modo de zero bits do registro de controle (consulte a tabela 21-20). <br><br>  Tabela 21-20.  Modo Zero Bit de Registro de Controle <br><div class="scrollable-table"><table><tbody><tr><th>  <b>CTL MD</b> </th><th>  <b>Descri√ß√£o do produto</b> </th></tr><tr><td>  00 </td><td>  Modo Direto </td></tr><tr><td>  01 </td><td>  Modo de sincroniza√ß√£o </td></tr><tr><td>  10 </td><td>  (reservado) </td></tr><tr><td>  11 </td><td>  Modo de pulso </td></tr></tbody></table></div><br><h4>  Modo de registro de controle direto </h4><br>  Por padr√£o, o modo √© direto.  Como mostra a Figura 21-32, quando a CPU ou DMA √© gravada no registro de controle, a sa√≠da do registro de controle √© enviada diretamente para a linha de rastreamento no mesmo ciclo. <br><br><img src="https://habrastorage.org/webt/ft/cl/q-/ftclq-bcwhq3r_kozkj3vrwuli0.png"><br>  <i>Figura 21-32.</i>  <i>Modo de registro de controle direto.</i> <br><br><h4>  Modo de registro de controle s√≠ncrono </h4><br>  No modo s√≠ncrono, como mostrado na Figura 21-33, a sa√≠da do registro de controle √© ressincronizada com um rel√≥gio igual ao rel√≥gio atual do controle e status (Status e Controle, SC).  Isso permite controlar os diagramas de tempo da sa√≠da na frequ√™ncia SC selecionada e n√£o na freq√º√™ncia do rel√≥gio do barramento. <br><br><img src="https://habrastorage.org/webt/jd/a6/7s/jda67s-pgp1kw-03dnttxc-zdcq.png"><br>  <i>Figura 21-33.</i>  <i>Modo de registro de controle s√≠ncrono.</i> <br><br><h4>  Registro de controle do modo de pulso </h4><br>  O modo de pulso √© semelhante ao modo s√≠ncrono, pois nele o bit de controle √© amostrado novamente na frequ√™ncia SC;  o pulso come√ßa no primeiro ciclo do rel√≥gio SC e segue o ciclo de grava√ß√£o do barramento.  A sa√≠da do bit de controle √© definida durante um ciclo completo do rel√≥gio SC.  No final deste ciclo de clock, o bit de controle √© redefinido automaticamente. <br><br>  Com este modo de opera√ß√£o, o programa pode escrever 1 no bit de registro de controle para gerar um pulso.  Ap√≥s o bit ser atribu√≠do ao valor 1, o programa o ler√° como 1 at√© o final do pulso, ap√≥s o qual ser√° lido como 0. Depois disso, o programa poder√° escrever outro 1 para iniciar um novo pulso.  Assim, n√£o ser√° poss√≠vel dar um pulso com mais frequ√™ncia do que em cada segundo passo do sinal SC. <br><br><h4>  Redefinir registro de gerenciamento </h4><br>  O registro de controle possui dois modos de reset controlados pelo bit de configura√ß√£o EXT RES, conforme mostrado na Figura 21-34.  Quando EXT RES √© 0 (padr√£o), no modo s√≠ncrono ou de pulso, a entrada de redefini√ß√£o rastreada redefine a sa√≠da sincronizada, mas n√£o o pr√≥prio bit de controle.  Quando EXT RES √© 1, a entrada de redefini√ß√£o rastre√°vel redefine o bit de controle e a sa√≠da sincronizada. <br><br><img src="https://habrastorage.org/webt/lo/ho/dl/lohodlp2-dbsqoqzpwurp8hx2di.png"><br>  <i>Figura 21-34.</i>  <i>Redefina o registro de gerenciamento.</i> <br><br><h2>  21.3.3.3 Modo de entrada / sa√≠da paralela </h2><br>  Nesse modo, o controle e o rastreamento de status s√£o conectados aos sinais do Datapath de entrada e sa√≠da paralela.  Para ativar esse modo, voc√™ precisa armar os bits de configura√ß√£o do SC OUT para selecionar a sa√≠da paralela do Datapath.  A comunica√ß√£o com entrada paralela est√° sempre dispon√≠vel, no entanto, essas conex√µes de rastreamento s√£o compartilhadas com as entradas de registro de status, entradas de controle de contador e sa√≠das de interrup√ß√£o. <br><br><img src="https://habrastorage.org/webt/9c/se/c2/9csec2u290m0hm1qaecqxpyybhe.png"><br>  <i>Figura 21-35.</i>  <i>Modo de E / S paralela.</i> <br><br><h2>  21.3.3.4 Modo contador </h2><br>  Conforme mostrado na Figura 21-36, quando a unidade opera no modo contador, um contador decrescente de 7 bits est√° dispon√≠vel para uso tanto nas opera√ß√µes dentro do UDB quanto para as necessidades do programa.  Os recursos do medidor incluem: <br><br><ul><li>  Registro de per√≠odo de 7 bits, (leitura / grava√ß√£o). </li><li>  Registro de conta de 7 bits, (leitura / grava√ß√£o).  O acesso √© poss√≠vel apenas quando o contador est√° parado. </li><li>  Recarrega automaticamente o per√≠odo no registro da conta quando atinge zero. </li><li>  O bit de controle acess√≠vel por software no registro de controle auxiliar CNT START, usado para iniciar e parar o contador.  (Sobrep√µe o sinal de hardware ENABLE e deve ser instalado para que o sinal de hardware opcional ENABLE funcione). </li><li>  Bits selecion√°veis ‚Äã‚Äãdos canais de rastreamento do controle din√¢mico opcional do contador para as fun√ß√µes de in√≠cio e carregamento: <br>  - PT, sinal rastreado para iniciar ou parar a contagem. <br>  - LD, um sinal de carga rastre√°vel que causa uma recarga de per√≠odo.  Quando esse sinal √© engatilhado, ele se sobrep√µe ao sinal final pendente.  √â sens√≠vel ao n√≠vel e, enquanto o sinal est√° armado, o per√≠odo continua a carregar. </li><li>  Um contador de 7 bits pode ser enviado para rastrear recursos como sc_out [6: 0]. </li><li>  O sinal de termina√ß√£o pode inserir recursos de rastreamento como sc_out [7]. </li><li>  No modo "padr√£o", o modo de encaixe √© usado para o sinal de contagem.  No modo alternativo, alterna para o modo combinado. </li><li>  No modo padr√£o, o sinal EN de hardware opcional, se usado, deve ser definido para ativar o sinal de hardware LD.  No modo alternativo, os sinais de hardware LD e EN s√£o independentes. </li></ul><br><img src="https://habrastorage.org/webt/no/ov/up/noovupgcemdnnl1v6ak4tyl1rnq.png"><br>  <i>Figura 21-36.</i>  <i>Modo contador</i> <br><blockquote>  <i><b>Nota do tradutor:</b></i> <br>  Em torno deste lugar, percebi que n√£o entendia completamente nada do documento.  Em nenhum lugar s√£o descritos os modos "padr√£o" e "alternativo".  Depois de uma longa pesquisa, consegui encontrar alguns, mas um exemplo. <br>  Arquivo: C: \ Arquivos de programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ psoc \ content \ CyComponentLibrary \ CyComponentLibrary.cylib \ bScanComp_v1_10 \ bScanComp_v1_10.v <br>  C√≥digo explicativo: <br><br><img src="https://habrastorage.org/webt/ba/rf/13/barf13t7suartgjw8b0frvtsccs.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto:</b> <div class="spoiler_text"><pre><code class="plaintext hljs">cy_psoc3_count7 #(.cy_period(Period),.cy_route_ld(0),.cy_route_en(1), .cy_alt_mode(1)) ChannelCounter( /* input */ .clock(clk_int), /* input */ .reset(1'b0), /* input */ .load(1'b0), /* input */ .enable(enable_int), /* output [06:00] */ .count(count), /* output */ .tc(tc_o) );</code> </pre> <br></div></div><br>  A pr√≥pria declara√ß√£o do componente cy_psoc3_count7 que encontrei apenas para a linguagem VHDL, parece que para o Verilog ele est√° embutido nas ferramentas de desenvolvimento.  Agora voc√™ sabe aproximadamente onde procurar os bits de ajuste em discuss√£o. <br><br>  Aqui consideramos os bits misteriosos, chamados SC OUT CTL ou SC_OUT_CTL, mas seus valores n√£o est√£o documentados.  Eu n√£o os encontrei em lugar nenhum.  Fica claro no texto que eles alternam o componente STATUS_CONTROL entre os modos.  Mas no arquivo VHDL mencionado anteriormente, C: \ Arquivos de programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ lcpsoc3 \ cpsoc3.vhd <br><br><div class="spoiler">  <b class="spoiler_title">vemos separadamente o contador j√° conhecido por n√≥s</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_count7 generic(cy_period : std_logic_vector (6 downto 0) := "1111111"; cy_init_value : std_logic_vector (6 downto 0) := "0000000"; cy_route_ld : boolean := false; cy_route_en : boolean := false; cy_alt_mode : boolean := false); port (clock : in std_logic; reset : in std_logic; load : in std_logic; enable : in std_logic; count : out std_logic_vector (6 downto 0); tc : out std_logic); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">separadamente - status e gerenciamento</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> attribute atomic_rtl of cy_psoc3_status : component is rtl_generic; attribute cpu_access of cy_psoc3_status : component is true; component cy_psoc3_statusi generic(cy_force_order : boolean := false; cy_md_select : std_logic_vector (6 downto 0) := "0000000"; cy_int_mask : std_logic_vector (6 downto 0) := "0000000"); port (reset : in std_logic := '0'; clock : in std_logic := '0'; status : in std_logic_vector (6 downto 0); interrupt : out std_logic); end component; attribute atomic_rtl of cy_psoc3_statusi : component is rtl_generic; attribute cpu_access of cy_psoc3_statusi : component is true; component cy_psoc3_control generic(cy_init_value : std_logic_vector (7 downto 0) := "00000000"; cy_force_order : boolean := false; cy_ctrl_mode_1 : std_logic_vector (7 downto 0) := "00000000"; cy_ctrl_mode_0 : std_logic_vector (7 downto 0) := "00000000"; cy_ext_reset : boolean := false); port (reset : in std_logic := '0'; clock : in std_logic := '0'; control : out std_logic_vector (7 downto 0)); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">separadamente - sincronizador</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_sync port (clock : in std_logic := '0'; sc_in : in std_logic; sc_out : out std_logic); end component;</code> </pre><br></div></div><br>  Repito que o Verilog n√£o possui uma vers√£o dessas declara√ß√µes (existem apenas modelos comportamentais no diret√≥rio C: \ Arquivos de Programas (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim, ent√£o acho que a configura√ß√£o dos bits Os modos n√£o s√£o acess√≠veis a programadores simples Ao ler esta se√ß√£o, lembre-se desse fato: algo √© fornecido apenas como refer√™ncia, n√£o est√° sujeito a n√≥s, programadores. </blockquote>  Para ativar o modo contador, a sa√≠da do contador deve ser selecionada nos bits SC_OUT_CTI [1: 0].  Nesse modo, a opera√ß√£o normal do registro de controle n√£o est√° dispon√≠vel.  Ao mesmo tempo, o registro de status pode ser usado para opera√ß√µes de leitura, mas voc√™ n√£o deve us√°-lo para gerar uma interrup√ß√£o, pois o registro de mapeamento de m√°scara tamb√©m √© usado como um registro de per√≠odo de contagem.  O registro do per√≠odo n√£o √© destru√≠do e mant√©m seu estado ap√≥s acordar.  Para um per√≠odo de N medidas, o valor N-1 deve ser carregado no registro de per√≠odo.  O valor N = 1 (o per√≠odo √© zero), pois o valor do divisor de frequ√™ncia n√£o √© suportado e levar√° a uma unidade constante na sa√≠da do TC (contagem de terminais, TC).  A disponibilidade do modo SYNC depende se o controle din√¢mico (LD / EN) √© usado ou n√£o.  Se n√£o for utilizado, n√£o afeta o modo SYNC.  Se usado, o modo SYNC n√£o est√° dispon√≠vel. <br><br><h2>  21.3.3.5 Modo de sincroniza√ß√£o </h2><br>  Conforme mostrado na Figura 21-37, o registro de status pode operar como um rel√≥gio duplo de 4 bits sincronizado com o valor atual SC_CLK se o bit SYNC MD estiver definido.  Este modo pode ser usado para implementar a sincroniza√ß√£o local de sinais ass√≠ncronos (por exemplo, entradas GPIO).  Nesse caso, os sinais sincronizados s√£o selecionados em SC_IN [3: 0], as sa√≠das s√£o roteadas para os contatos SC_IO_OUT [3: 0] e o SYNC MD alterna automaticamente os contatos SC_IO para o modo de sa√≠da.  Nesse modo, a opera√ß√£o normal do registro de status n√£o est√° dispon√≠vel e o modo de bit de status fixo √© desativado √† for√ßa, independentemente das configura√ß√µes de controle do modo.  Este modo n√£o afeta o registro de controle.  O contador ainda pode ser usado, mas com limita√ß√µes.  Neste modo de opera√ß√£o, as entradas din√¢micas (LD / EN) n√£o podem ser usadas. <br><br><img src="https://habrastorage.org/webt/ol/cw/6z/olcw6ztxrs5xqzb-9l0i6uyyqa8.png"><br>  <i>Figura 21-37.</i>  <i>Modo s√≠ncrono.</i> <br><br><h2>  21.3.3.6 Status e controle de rel√≥gio </h2><br>  Os registros de controle e status requerem uma sele√ß√£o de rel√≥gio em qualquer um dos seguintes modos de opera√ß√£o: <br><br><ul><li>  registro de status com qualquer bit no modo pegajoso, com limpeza ap√≥s a leitura, </li><li>  registro de controle no modo contador, </li><li>  modo s√≠ncrono. </li></ul><br>  O tempo √© atribu√≠do no m√≥dulo rel√≥gio e redefini√ß√£o.  Veja 21.3.4.  Rel√≥gio e redefinir o m√≥dulo de controle. <br><br><h2>  21.3.3.7 Registro de controle auxiliar </h2><br>  O registro de controle auxiliar para leitura e grava√ß√£o √© um registro especial que controla equipamentos UDB fixos.  Esse registro permite que a CPU ou o DMA controle dinamicamente interrup√ß√µes, FIFOs e opera√ß√µes de contador.  Os bits dos registradores e suas descri√ß√µes s√£o apresentados abaixo: <br><br><div class="scrollable-table"><table><tbody><tr><th colspan="8">  <b>Registro de controle auxiliar</b> </th></tr><tr><td>  <b>7</b> </td><td>  <b>6</b> </td><td>  <b>5</b> </td><td>  <b>4</b> </td><td>  <b>3</b> </td><td>  <b>2</b> </td><td>  <b>1</b> </td><td>  <b>0 0</b> </td></tr><tr><td></td><td></td><td>  CNT <br>  INICIAR </td><td>  INT PT </td><td>  FIFO1 <br>  LVL </td><td>  FIFO0 <br>  LVL </td><td>  FIFO1 <br>  CLR </td><td>  FIFO0 <br>  CLR </td></tr></tbody></table></div><br><h4>  Clear FIFO0 e FIFO1 (FIFO0 Clear, FIFO1 Clear) </h4><br>  Os bits FIFO0 CLR e FIFO1 CLR s√£o usados ‚Äã‚Äãpara redefinir o status dos FIFOs correspondentes.  Quando 1 √© gravado nesses bits, o estado do FIFO correspondente √© redefinido.  Para continuar a opera√ß√£o FIFO, √© necess√°rio escrever 0. Esses bits permanecem armados.O FIFOs funciona como buffers simples de byte √∫nico sem status. <br><br><h4>  N√≠vel FIFO0 e FIFO1 (n√≠vel FIFO0, n√≠vel FIFO1) </h4><br>  Os bits FIFO0 LVL e FIFO1 LVL definem o n√≠vel no qual um FIFO de 4 bytes eleva o status do barramento (quando o barramento l√™ ou grava no FIFO).  O valor do status do barramento FIFO depende da dire√ß√£o configurada, conforme mostrado na tabela abaixo. <br><br>  Tabela 21-21.  Bits de controle de n√≠vel FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  <b>FIFOx</b> <b><br></b>  <b>LVL</b> </th><th>  <b>Modo de entrada</b> <b><br></b>  <b>(O barramento grava no FIFO)</b> </th><th>  <b>Modo de sa√≠da</b> <b><br></b>  <b>(O barramento l√™ do FIFO)</b> </th></tr><tr><td>  0 0 </td><td>  <b>N√£o est√° cheio.</b> <br>  Voc√™ pode escrever pelo menos 1 byte. <br></td><td>  <b>N√£o est√° vazio.</b> <br>  Pelo menos 1 byte est√° dispon√≠vel para leitura. </td></tr><tr><td>  1 </td><td>  <b>Devastado por pelo menos metade.</b> <br>  Voc√™ pode escrever pelo menos 2 bytes. </td><td>  <b>Pelo menos meio cheio.</b> <br>  Pelo menos 2 bytes est√£o dispon√≠veis para leitura. </td></tr></tbody></table></div><br><h4>  Ativar interrup√ß√£o </h4><br>  Quando a l√≥gica de gera√ß√£o do registro de status √© ativada, o bit INT EN permite a passagem do sinal de interrup√ß√£o gerado. <br><br><h4>  Iniciar contador / conta?  (In√≠cio da contagem) </h4><br>  O bit CNT START pode ser usado para iniciar e parar o contador (dispon√≠vel apenas se os bits SC_OUT_CTL [1: 0] estiverem configurados para o modo de sa√≠da do contador). <br><br><h2>  21.3.3.8 Resumo dos registros de gerenciamento e status </h2><br>  A tabela abaixo resume as fun√ß√µes dos registros de controle e status.  Observe que os registros de m√°scara e controle s√£o combinados com contadores e registros de per√≠odo, e o valor desses registros n√£o depende do modo de opera√ß√£o. <br><br>  Tabela 21-22.  Um breve resumo da opera√ß√£o dos registros de gerenciamento e status <br><div class="scrollable-table"><table><tbody><tr><th>  Mode </th><th>  Gerenciamento / Contador <br>  (Controle / contagem) </th><th>  Status / Sincroniza√ß√£o <br>  (Status / SINCRONIZA√á√ÉO) </th><th>  Sobreposi√ß√£o / per√≠odo da m√°scara <br>  (M√°scara / Per√≠odo) </th></tr><tr><td>  Controlar </td><td>  Control Out </td><td rowspan="2">  Status In ou SYNC </td><td>  M√°scara de status de sobreposi√ß√£o </td></tr><tr><td>  Contador </td><td>  Counter Out </td><td>  Per√≠odo de contagem a (Per√≠odo de contagem) </td></tr><tr><td>  Status </td><td rowspan="2">  Control Out ou Count Out </td><td>  Status em </td><td>  M√°scara de status de sobreposi√ß√£o </td></tr><tr><td>  Sincroniza√ß√£o (SYNC) </td><td>  Sincroniza√ß√£o (SYNC) </td><td>  N√£o dispon√≠vel <sup>b</sup> (NA) </td></tr></tbody></table></div><br>  a.  - observe que, no modo contador, o registro de sobreposi√ß√£o de m√°scara funciona como um registro de per√≠odo e n√£o pode funcionar como um registro de m√°scara sobre.  Conseq√ºentemente, a sa√≠da de interrup√ß√£o n√£o est√° dispon√≠vel quando o modo contador est√° ativado. <br><br>  b.  - observe que no modo de sincroniza√ß√£o o registro de status n√£o est√° dispon√≠vel e, portanto, √© imposs√≠vel usar o registro de sobreposi√ß√£o de m√°scara.  No entanto, ele pode ser usado como um registro de per√≠odo para o modo contador. <br><br>  Para continuar ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443380/">https://habr.com/ru/post/pt443380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443368/index.html">Estamos preparando uma pesquisa de texto completo no Postgres. Parte 2</a></li>
<li><a href="../pt443370/index.html">Conectando o Google reCAPTCHA ao Vue e validando a resposta no servidor</a></li>
<li><a href="../pt443372/index.html">Back-end no CodeFest. Tripas encomendadas?</a></li>
<li><a href="../pt443376/index.html">Conseguiu encontrar dezenas de armazenamentos corporativos da Box.com que divulgam dados da Apple, Herbalife etc.</a></li>
<li><a href="../pt443378/index.html">Estamos escrevendo um cliente http de alto desempenho usando fasthttp como exemplo. Alexander Valyalkin (VertaMedia)</a></li>
<li><a href="../pt443382/index.html">Fintech Digest: Mir Pay para Android, suspendendo a proibi√ß√£o de retirar dinheiro de carteiras an√¥nimas, as startups de IA n√£o s√£o exatamente AI</a></li>
<li><a href="../pt443384/index.html">Slurm e MegaSlerm em Moscou no final de maio</a></li>
<li><a href="../pt443386/index.html">Como obter o log de seguran√ßa com usu√°rio n√£o administrativo</a></li>
<li><a href="../pt443388/index.html">Controle de ilumina√ß√£o multin√≠vel baseado no KTS NPL</a></li>
<li><a href="../pt443392/index.html">Hist√≥rico de salvamento de jogos: de senhas em papel a nuvens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>