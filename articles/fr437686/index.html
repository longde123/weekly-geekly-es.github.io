<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏻 👩🏽‍🚒 😫 Learning Go: écrire un messager p2p avec un cryptage de bout en bout 👨🏻‍⚖️ 🍡 🚈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Encore un autre P2P Messenger 


 La lecture des revues et de la documentation linguistique ne suffit pas pour apprendre à y écrire des applications p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning Go: écrire un messager p2p avec un cryptage de bout en bout</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437686/"><h1 id="yet-another-p2p-messenger">  Encore un autre P2P Messenger </h1><br><p>  La lecture des revues et de la documentation linguistique ne suffit pas pour apprendre à y écrire des applications plus ou moins utiles. </p><br><p>  Assurez-vous de consolider, vous devez créer quelque chose d'intéressant afin que les développements puissent être utilisés dans d'autres tâches. </p><br><p><img src="https://habrastorage.org/webt/kt/bm/3r/ktbm3rsivunfcdcvcyqvnm14f5u.png" alt="Exemple d'interface utilisateur de chat ReactJs"></p><br><p>  Cet article est destiné aux débutants intéressés par la langue go et les réseaux peer-to-peer. <br>  Et pour les professionnels qui peuvent proposer des idées raisonnables ou critiquer de manière constructive. </p><a name="habracut"></a><br><p>  Je programme depuis un certain temps avec différents degrés d'immersion en java, php, js, python. <br>  Et chaque langage de programmation est bon dans son domaine. </p><br><p>  Le domaine principal de Go est la création de services distribués, de microservices. <br>  Le plus souvent, un microservice est un petit programme qui exécute ses fonctionnalités hautement spécialisées. </p><br><p> Mais les microservices devraient toujours pouvoir communiquer entre eux, donc l'outil de création de microservices devrait permettre une mise en réseau facile et indolore. <br>  Pour tester cela, nous allons écrire une application organisant un réseau décentralisé de pairs (Peer-To-Peer), le plus simple est un messager p2p (au fait, existe-t-il un synonyme russe pour ce mot?). </p><br><p>  Dans le code, j'invente activement des vélos et monte sur le râteau pour sentir le golang, obtenir des critiques constructives et des suggestions rationnelles. </p><br><h2 id="chto-delaem">  On fait quoi </h2><br><p>  Peer (peer) - une instance unique du messager. </p><br><p>  Notre messager devrait pouvoir: </p><br><ul><li>  Trouver des fêtes à proximité </li><li>  Établir une connexion avec d'autres pairs </li><li>  Crypter l'échange de données avec des pairs </li><li>  Recevoir des messages de l'utilisateur </li><li>  Afficher les messages à l'utilisateur </li></ul><br><p>  Pour rendre la tâche un peu plus intéressante, faisons-la passer par un seul port réseau. </p><br><p><img src="https://habrastorage.org/webt/5b/zo/8g/5bzo8g4eqogveeure4lzgngo5ma.png" alt="Le schéma conditionnel du messager"></p><br><p>  Si vous tirez ce port sur HTTP, nous obtenons une application React qui tire le même port en établissant une connexion de socket Web. </p><br><p>  Si vous tirez le port via HTTP et non depuis la machine locale, nous affichons la bannière. </p><br><p>  Si un autre homologue est connecté à ce port, une connexion permanente est établie avec un chiffrement de bout en bout. </p><br><h2 id="opredelyaem-tip-vhodyaschego-soedineniya">  Déterminer le type de connexion entrante </h2><br><p>  Tout d'abord, ouvrez le port d'écoute et nous attendrons de nouvelles connexions. </p><br><pre><code class="go hljs">net.ListenTCP(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, tcpAddr)</code> </pre> <br><p>  Sur la nouvelle connexion, lisez les 4 premiers octets. </p><br><p>  Nous prenons la liste des verbes HTTP et comparons nos 4 octets avec elle. </p><br><p>  Maintenant, nous déterminons si une connexion est établie à partir de la machine locale, et sinon, nous répondons avec une bannière et raccrochons. </p><br><pre> <code class="go hljs"> buf, err := readWriter.Peek(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItIsHttp(buf) { handleHttp(readWriter, conn, p) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { peer := proto.NewPeer(conn) p.HandleProto(readWriter, peer) } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"127"</span></span>) &amp;&amp; !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"[::"</span></span>) { response.Body = ioutil.NopCloser(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger. see https://github.com/easmith/p2p-messenger"</span></span>)) }</code> </pre> <br><p>  Si la connexion est locale, nous répondons avec le fichier correspondant à la demande. </p><br><p>  J'ai alors décidé d'écrire le traitement moi-même, même si je pouvais utiliser le gestionnaire disponible dans la bibliothèque standard. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//   func processRequest(request *http.Request, response *http.Response) {/*    */} //     fileServer := http.FileServer(http.Dir("./front/build/")) fileServer.ServeHTTP(NewMyWriter(conn), request)</span></span></code> </pre> <br><p>  Si le chemin <code>/ws</code> demandé, alors nous essayons d'établir une connexion websocket. </p><br><p>  Depuis que j'ai assemblé le vélo dans le traitement des demandes de fichiers, je vais faire le traitement de la connexion ws en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque gorilla / websocket</a> . </p><br><p>  Pour ce faire, créez <code>MyWriter</code> et implémentez-y des méthodes correspondant aux interfaces <code>http.ResponseWriter</code> et <code>http.Hijacker</code> . </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// w - MyWriter func handleWs(w http.ResponseWriter, r *http.Request, p *proto.Proto) { c, err := upgrader.Upgrade(w, r, w.Header()) /*          */ }</span></span></code> </pre> <br><h2 id="obnaruzhenie-pirov">  Détection de pairs </h2><br><p>  Pour rechercher des homologues dans un réseau local, nous utiliserons la multidiffusion UDP. </p><br><p>  Nous enverrons des paquets contenant des informations sur nous-mêmes à l'adresse IP de multidiffusion. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto)</span></span></span></span> { conn, err := net.DialUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := conn.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"meow:%v:%v"</span></span>, hex.EncodeToString(p.PubKey), p.Port))) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br><p>  Et écoutez séparément de Multicast IP pour tous les paquets UDP. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto, handler </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, peerAddress </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> conn, err := net.ListenMulticastUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> _, src, err := conn.ReadFromUDP(buffer) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">// connectToPeer handler(p, peerAddress) }</span></span></code> </pre> <br><p>  Ainsi nous nous déclarons et apprenons l'apparition d'autres fêtes. </p><br><p>  Il serait possible d'organiser cela au niveau IP, et même dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle du package IPv4,</a> seul le paquet de données de multidiffusion est donné comme exemple de code. </p><br><h2 id="protokol-vzaimodeystviya-pirov">  Protocole d'interaction entre pairs </h2><br><p>  Nous emballerons toutes les communications entre pairs dans une enveloppe (enveloppe). </p><br><p>  Sur toute enveloppe, il y a toujours un expéditeur et un destinataire, à cela nous ajouterons une commande (qu'il emporte avec lui), un identifiant (jusqu'à présent, c'est un nombre aléatoire, mais peut être fait comme un hachage de contenu), la longueur du contenu et le contenu de l'enveloppe elle-même - un message ou des paramètres de commande. </p><br><p><img src="https://habrastorage.org/webt/3b/yx/yc/3byxycyif222uk2jslbya9qb1bs.png" alt="Octets d'enveloppe"></p><br><p>  La commande, (ou le type de contenu) est placée avec succès au tout début de l'enveloppe et nous définissons une liste de commandes de 4 octets qui ne se croisent pas avec les noms des verbes HTTP. </p><br><p>  L'enveloppe entière pendant la transmission est sérialisée en un tableau d'octets. </p><br><h3 id="rukopozhatie">  Poignée de main </h3><br><p>  Lorsque la connexion est établie, le festin tend immédiatement la main pour une poignée de main, donnant son nom, sa clé publique et sa clé publique éphémère pour générer une clé de session partagée. </p><br><p>  En réponse, l'homologue reçoit un ensemble similaire de données, enregistre l'homologue trouvé dans sa liste et calcule (CalcSharedSecret) la clé de session commune. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handShake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, conn net.Conn)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> peer := proto.NewPeer(conn) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> p.SendName(peer) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> envelope, err := proto.ReadEnvelope(bufio.NewReader(conn)) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3 id="obmen-pirami">  Échange de fête </h3><br><p>  Après une poignée de main, les pairs échangent leurs listes de pairs =) </p><br><p>  Pour ce faire, une enveloppe contenant la commande LIST est envoyée et une liste JSON de pairs est placée dans son contenu. <br>  En réponse, nous obtenons une enveloppe similaire. </p><br><p>  On en retrouve dans les listes de nouveaux et avec chacun d'eux on essaie de se connecter, se serrer la main, échanger des fêtes etc. </p><br><h3 id="obmen-polzovatelskimi-soobscheniyami">  Messagerie utilisateur </h3><br><p>  Les messages personnalisés sont de la plus grande valeur pour nous, nous allons donc crypter et signer chaque connexion. </p><br><h4 id="o-shifrovanii">  À propos du chiffrement </h4><br><p>  Dans les bibliothèques golang standard (google) du paquet crypto, de nombreux algorithmes différents sont implémentés (il n'y a pas de normes GOST). </p><br><p>  Le plus pratique pour les signatures, je pense, est la courbe Ed25519.  Nous utiliserons la bibliothèque ed25519 pour signer des messages. </p><br><p>  Au tout début, j'ai pensé à utiliser une paire de clés obtenue à partir de ed25519 non seulement pour signer, mais aussi pour générer une clé de session. </p><br><p>  Cependant, les clés de signature ne sont pas applicables pour le calcul de la clé partagée - vous devez toujours les conjurer: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateKeyExchangePair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publicKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, privateKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pub, priv, err := ed25519.GenerateKey(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(publicKey[:], pub[:]) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(privateKey[:], priv[:]) curve25519.ScalarBaseMult(&amp;publicKey, &amp;privateKey) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Par conséquent, il a été décidé de générer des clés éphémères, et d'une manière générale, c'est la bonne approche qui ne laisse pas aux attaquants la possibilité de récupérer une clé commune. </p><br><p>  Pour les amateurs de mathématiques, voici les liens wiki: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Protocole <em>Diffie</em> - Hellman_ sur les courbes elliptiques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signature numérique EdDSA</a> </p><br><p>  La génération d'une clé partagée est assez standard: d'abord, pour une nouvelle connexion, nous générons des clés éphémères, nous envoyons une enveloppe avec une clé publique au socket. </p><br><p>  Le côté opposé fait de même, mais dans un ordre différent: il reçoit une enveloppe avec une clé publique, génère sa propre paire et envoie la clé publique au socket. </p><br><p>  Désormais, chaque participant dispose des clés éphémères publiques et privées de quelqu'un d'autre. </p><br><p>  En les multipliant, nous obtenons la même clé pour les deux, que nous utiliserons pour crypter les messages. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//CalcSharedSecret Calculate shared secret func CalcSharedSecret(publicKey []byte, privateKey []byte) (secret [32]byte) { var pubKey [32]byte var privKey [32]byte copy(pubKey[:], publicKey[:]) copy(privKey[:], privateKey[:]) curve25519.ScalarMult(&amp;secret, &amp;privKey, &amp;pubKey) return }</span></span></code> </pre> <br><p>  Nous crypterons les messages par l'algorithme AES établi depuis longtemps en mode de couplage de blocs (CBC). </p><br><p>  Toutes ces implémentations sont faciles à trouver dans la documentation de golang. </p><br><p>  Le seul raffinement consiste à remplir automatiquement le message avec zéro octet pour la multiplicité de sa longueur à la longueur du bloc de chiffrement (16 octets). </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Encrypt the message func Encrypt(content []byte, key []byte) []byte { padding := len(content) % aes.BlockSize if padding != 0 { repeat := bytes.Repeat([]byte("\x00"), aes.BlockSize-(padding)) content = append(content, repeat...) } /* ... */ } //Decrypt encrypted message func Decrypt(encrypted []byte, key []byte) []byte { /* ... */ encrypted = bytes.Trim(encrypted, string([]byte("\x00"))) return encrypted }</span></span></code> </pre> <br><p>  En 2013, il a implémenté AES (avec un mode similaire à CBC) pour crypter les messages dans Telegram dans le cadre d'un concours de Pavel Durov. </p><br><p>  À cette époque, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protocole Diffie-Hellman</a> le plus courant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">était</a> utilisé dans les télégrammes pour générer une clé éphémère. </p><br><p>  Et afin d'exclure la charge des fausses connexions, avant chaque échange de clés, les clients ont résolu le problème de factorisation. </p><br><h2 id="gui">  GUI </h2><br><p>  Nous devons afficher une liste de pairs et une liste de messages avec eux, et également répondre aux nouveaux messages en augmentant le compteur à côté du nom du pair. </p><br><p>  Ici sans problèmes - ReactJS + websocket. </p><br><p>  Les messages de socket Web sont essentiellement des enveloppes uniques, mais ils ne contiennent pas de texte chiffré. </p><br><p>  Tous sont des "héritiers" de type <code>WsCmd</code> et sont sérialisés en JSON lors du transfert. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Serializable interface to detect that can to serialised to json type Serializable interface { ToJson() []byte } func toJson(v interface{}) []byte { json, err := json.Marshal(v) /*  err */ return json } /* ... */ //WsCmd WebSocket command type WsCmd struct { Cmd string `json:"cmd"` } //WsMessage WebSocket command: new Message type WsMessage struct { WsCmd From string `json:"from"` To string `json:"to"` Content string `json:"content"` } //ToJson convert to JSON bytes func (v WsMessage) ToJson() []byte { return toJson(v) } /* ... */</span></span></code> </pre> <br><p>  Donc, une requête HTTP arrive à la racine ("/"), maintenant pour afficher le front, regardez dans le répertoire "front / build" et donnez index.html </p><br><p>  Eh bien l'interface est constituée, maintenant le choix pour les utilisateurs est: l'exécuter dans un navigateur ou dans une fenêtre séparée - WebView. </p><br><p>  Pour la dernière option utilisée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zserge / webview</a> </p><br><pre> <code class="go hljs"> e := webview.Open(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger"</span></span>, fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:%v"</span></span>, initParams.Port), <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  Pour créer une application avec celle-ci, vous devez installer un autre système </p><br><pre> <code class="bash hljs"> sudo apt install libwebkit2gtk-4.0-dev</code> </pre> <br><p>  Au cours de la réflexion sur l'interface graphique, j'ai trouvé de nombreuses bibliothèques pour GTK, QT, et l'interface de la console aurait l'air très geek - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/jroimartin/gocui</a> - à mon avis, une idée très intéressante. </p><br><h2 id="zapusk-messendzhera">  Lancement de Messenger </h2><br><h3 id="ustanovka-golang">  Installation de Golang </h3><br><p>  Bien sûr, vous devez d'abord installer go. <br>  Pour ce faire, je recommande fortement d'utiliser l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang.org/doc/install</a> . </p><br><p>  Instructions simplifiées pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bash script</a> </p><br><h3 id="zagruzka-prilozheniya-v-gopath">  Téléchargez une application dans GOPATH </h3><br><p>  Il est tellement arrangé que toutes les bibliothèques et même vos projets doivent être dans le soi-disant GOPATH. </p><br><p>  Par défaut, c'est $ HOME / go.  Go vous permet d'extraire la source du référentiel public avec une simple commande: </p><br><pre> <code class="bash hljs"> go get github.com/easmith/p2p-messenger</code> </pre> <br><p>  Maintenant, dans votre <code>$HOME/go/src/github.com/easmith/p2p-messenger</code> source de la branche principale apparaîtra </p><br><h3 id="ustanovka-npm-i-sborka-fronta">  Installation et montage avant du NPM </h3><br><p>  Comme je l'ai écrit ci-dessus, notre interface graphique est une application Web avec un front sur ReactJs, donc le front doit encore être assemblé. </p><br><p>  Nodejs + npm - ici comme d'habitude. </p><br><p>  Juste au cas où, voici les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions pour Ubuntu</a> </p><br><p>  Maintenant, nous commençons l'assemblage avant en standard </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> front npm update npm run build</code> </pre> <br><p>  L'avant est prêt! </p><br><h3 id="zapusk">  Lancement </h3><br><p>  Revenons à la racine et lançons la fête de notre messager. </p><br><p>  Au démarrage, nous pouvons spécifier le nom de notre homologue, le port, le fichier avec les adresses des autres homologues et un indicateur indiquant s'il faut lancer WebView. </p><br><p>  Par défaut, <code>$USER@$HOSTNAME</code> est utilisé comme nom d' <code>$USER@$HOSTNAME</code> et port 35035. </p><br><p>  Donc, nous commençons et discutons avec des amis sur le réseau local. </p><br><pre> <code class="bash hljs"> go run app.go -name Snowden</code> </pre> <br><h2 id="otzyv-o-programmirovanii-na-golang">  Commentaires sur la programmation de Golang </h2><br><ul><li>  La chose la plus importante que je voudrais noter: <strong>à l'aller, il s'avère immédiatement mettre en œuvre ce que je voulais</strong> . <br>  Presque tout ce dont vous avez besoin se trouve dans la bibliothèque standard. </li><li>  Cependant, il y avait une difficulté lorsque j'ai commencé le projet dans un répertoire autre que GOPATH. <br>  J'ai utilisé GoLand pour écrire du code.  Et au début, il était gênant de formater automatiquement le code avec des bibliothèques d'importation automatique. </li><li>  Il y a <strong>beaucoup de générateurs de code</strong> dans l' <strong>IDE</strong> , ce qui nous a permis de nous concentrer sur le développement plutôt que sur le jeu de code. </li><li>  Vous vous habituez rapidement à la gestion fréquente des erreurs, mais un visage se produit lorsque vous réalisez que pour aller, une situation normale est lorsque l'essence de l'erreur est analysée en fonction de sa représentation sous forme de chaîne. <br><pre> <code class="go hljs">err != io.EOF</code> </pre> </li><li>  Les choses vont un peu mieux avec la bibliothèque os.  De telles constructions aident à comprendre l'essence du problème. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> </li><li>  Hors de la boîte, go nous apprend à documenter correctement le code et à écrire des tests. <br>  Et il y en a mais.  Nous avons décrit l'interface avec la méthode <code>ToJson()</code> . <br>  Ainsi, le générateur de documentation n'hérite pas de la description de cette méthode pour les méthodes qui l'implémentent, donc pour supprimer les avertissements inutiles, vous devez copier la documentation dans chaque méthode implémentée (proto / mtypes.go). </li><li>  Récemment, je me suis habitué à la puissance de log4j en java, donc il n'y a pas assez de bon enregistreur en route. <br>  Il vaut probablement la peine d'étudier l'immensité du github avec une belle journalisation avec des appender et des formateurs. </li><li>  Travail inhabituel avec des tableaux. <br>  Par exemple, la concaténation se produit via la fonction <code>append</code> et la conversion d'un tableau de longueur arbitraire en un tableau de longueur fixe par <code>copy</code> . </li><li>  <code>switch-case</code> fonctionne comme <code>if-elseif-else</code> - mais c'est une approche intéressante, mais encore une fois face à la main: <br>  si nous voulons le comportement de <code>switch-case</code> habituel, nous devons mettre en <code>fallthrough</code> chaque cas. <br>  Vous pouvez également utiliser <code>goto</code> , mais ne le faisons pas, s'il vous plaît! </li><li>  Il n'y a pas d'opérateur ternaire et souvent ce n'est pas pratique. </li></ul><br><h2 id="chto-dalshe">  Et ensuite? </h2><br><p>  Ainsi, le messager Peer-To-Peer le plus simple est implémenté. </p><br><p>  Les cônes sont bondés, vous pouvez en outre améliorer les fonctionnalités de l'utilisateur: envoi de fichiers, d'images, d'audio, d'émoticônes, etc., etc. </p><br><p>  Et vous ne pouvez pas inventer votre protocole et utiliser les tampons de protocole Google, <br>  Connectez la chaîne de blocs et protégez-vous contre le spam à l'aide des contrats intelligents Ethereum. </p><br><p>  Sur les contrats intelligents, organisez des discussions de groupe, des canaux, un système de noms, des avatars et des profils utilisateur. </p><br><p>  Il est également impératif d'exécuter des homologues de départ, de mettre en œuvre un contournement NAT et d'envoyer des messages d'homologue à homologue. </p><br><p>  En conséquence, vous obtenez un bon télégramme / téléphone de remplacement, il vous suffit d'y transférer tous vos amis =) </p><br><h2 id="poleznosti">  Utilité </h2><br><div class="spoiler">  <b class="spoiler_title">Quelques liens</b> <div class="spoiler_text"><p>  Au cours des travaux sur le messager, j'ai trouvé des pages intéressantes pour un développeur débutant. <br>  Je les partage avec vous: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang.org/doc/</a> - documentation en langue, tout est simple, clair et avec des exemples.  La même documentation peut être exécutée localement avec la commande </p><br><pre> <code class="bash hljs">godoc -HTTP=:6060</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gobyexample.com</a> - une collection d'exemples simples </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang-book.ru</a> - un bon livre en russe </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/dariubs/GoBooks</a> est une collection de livres sur Go. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">awesome-go.com</a> - Une liste de bibliothèques, de frameworks et d'applications intéressantes à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">emporter</a> .  La catégorisation est plus ou moins, mais la description de beaucoup d'entre eux est très rare, ce qui n'aide pas la recherche par Ctrl + F </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437686/">https://habr.com/ru/post/fr437686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437674/index.html">Méthodes de reconnaissance d'objets 3D pour les véhicules sans pilote. Rapport Yandex</a></li>
<li><a href="../fr437676/index.html">Les universités et les accélérateurs d'entreprise comme levier pour lancer une start-up B2B aux États-Unis</a></li>
<li><a href="../fr437680/index.html">Ma collection de bricolage sur Youtube</a></li>
<li><a href="../fr437682/index.html">Écriture d'un autre outil de création de modèles Kubernetes</a></li>
<li><a href="../fr437684/index.html">Algorithme suprême - Compendium biaisé</a></li>
<li><a href="../fr437688/index.html">OpenSceneGraph: Techniques de programmation de base</a></li>
<li><a href="../fr437694/index.html">Analyse de l'utilitaire Files.walkFileTree ();</a></li>
<li><a href="../fr437696/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 283 (du 21 au 27 janvier)</a></li>
<li><a href="../fr437698/index.html">Service de traduction de brevets de l'OMPI Translate - Mes expériences</a></li>
<li><a href="../fr437702/index.html">Analyse des entrevues d'emploi Google: requêtes synonymes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>