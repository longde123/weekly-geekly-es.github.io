<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîê ü•¶ üè´ Arduin y LED, o c√≥mo actualizar el dise√±ador infantil ‚úäüèæ üë®‚ÄçüöÄ üí£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mi hijo "enganch√≥" firmemente al constructor magn√©tico Magformers . Una vez que examin√≥ una serie de Fixiks donde aparec√≠a el mismo constructor, el ni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin y LED, o c√≥mo actualizar el dise√±ador infantil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Mi hijo "enganch√≥" firmemente al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constructor magn√©tico Magformers</a> .  Una vez que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">examin√≥</a> una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie de Fixiks donde aparec√≠a el mismo constructor, el</a> ni√±o pregunt√≥: "Pap√°, ¬øpor qu√© los detalles tienen detalles que brillan, pero nosotros no?". <br><br>  Result√≥ que realmente hay un "conjunto de LED de ne√≥n Magformers", donde adem√°s de los bloques de construcci√≥n habituales, tambi√©n hay un elemento con un LED.  Como en este momento ya hab√≠amos reunido una caja completa de imanes de todas las formas y tama√±os posibles (en cuanto a m√≠, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formadores chinos</a> no son inferiores al original en absoluto), de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alguna manera</a> no quer√≠a comprar otro juego solo por el hecho de una bombilla.  Adem√°s, este conjunto cuesta significativamente m√°s que uno similar sin retroiluminaci√≥n. <br><br>  Habiendo estimado que solo hay un par de d√≥lares en los componentes, la mayor√≠a de los cuales ya ten√≠a, decid√≠ recoger mi morgulka.  S√≠, y con efectos que el original no tuvo. <br><br>  Debajo del gato encontrar√° la opci√≥n de una luz intermitente en el ATTiny85 y el panel LED en los LED WS8212.  Hablar√© sobre los circuitos, c√≥mo alimente todo esto desde la bater√≠a, as√≠ como los problemas obvios que acumul√© en el camino.  Tambi√©n hablar√© en detalle sobre el componente de software del proyecto. <br><a name="habracut"></a><br><h2>  Primeros pasos </h2><br>  Me pareci√≥ que el brillo de un LED normal (incluso RGB) es aburrido y banal.  Pero sentir algo como WS8212 parec√≠a interesante.  En ebee, se ofrecieron tanto LED individuales como matrices de hasta 16x16 de tama√±o.  Habiendo comprado varios m√≥dulos diferentes, me decid√≠ por una matriz 4x4.  Hay muchos LED en √©l para disfrutar de varios efectos visuales, mientras que el m√≥dulo es comparable en tama√±o a la ventana del bloque cuadrado del dise√±ador. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Para controlar la matriz de LED, solo un pin del microcontrolador es suficiente, por lo que incluso el arduino nano parece un busto (adem√°s, no cabe en la carcasa).  Pero el clon digispark en el controlador ATTiny85 result√≥ ser perfecto: no tiene mucha memoria y pines, pero es m√°s que suficiente para el parpadeo del LED.  El m√≥dulo se integra perfectamente con Arduino IDE y tiene un cargador de arranque USB incorporado, por lo que programar este m√≥dulo es muy simple y c√≥modo.  Hace mucho que quer√≠a probarlo. <br><br>  Comenz√≥ con el esquema m√°s simple. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  De esta forma, fue posible depurar r√°pidamente todos los algoritmos de brillo / parpadeo (sobre ellos a continuaci√≥n).  Pero un juguete con cable no es el caso: debe pensar en la energ√≠a de la bater√≠a.  Adem√°s, para no quebrar con las pilas de los dedos (que, adem√°s, no caben en el sobre), se decidi√≥ utilizar litio.  Y dado que hay una bater√≠a de litio, debe pensar en c√≥mo cargarla.  En los contenedores, acabamos de encontrar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">controlador de carga "popular" en el chip TP4056 que</a> se compr√≥ en la ocasi√≥n. <br><br>  Pero no funcion√≥ de inmediato.  El circuito del m√≥dulo Digispark ATTiny85 no est√° muy dise√±ado para esto: hay alimentaci√≥n USB, pero luego la alimentaci√≥n se suministra directamente al microcontrolador (a trav√©s del bus +5) o desde la entrada VIN, pero luego la alimentaci√≥n pasa por el estabilizador lineal 7805. Opci√≥n cuando el m√≥dulo de carga de litio insertado en el espacio entre el conector USB y el microcontrolador no se proporciona.  Tuve que modificar un poco el circuito y eliminar los detalles adicionales. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Entonces, ahora se suministra alimentaci√≥n USB al pin VIN y luego se dirige a la entrada del cargador.  La salida del cargador (de hecho, la bater√≠a est√° conectada directamente) vuelve a la placa a trav√©s del pie de 5V.  Y aunque, de hecho, habr√° de 3 a 4.2V (voltaje de la bater√≠a), esto es bastante normal: el rango de voltaje de funcionamiento del microcontrolador es 1.8-5.5V.  E incluso el m√≥dulo LED funciona normalmente desde 2.7V, aunque por debajo de 3.2V el LED azul es un poco escaso y los colores "flotan" un poco en amarillo. <br><br>  Para ahorrar energ√≠a, el LED D2 siempre encendido tambi√©n desapareci√≥.  El esquema general ahora se ve as√≠ <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Ser√≠a posible alimentar el circuito a trav√©s del conector USB en el cargador, pero luego se perder√≠a la capacidad de cargar firmware a trav√©s del conector USB en la placa del controlador.  Ser√≠a posible dejar dos conectores USB para diversos fines: uno para cargar, el otro para firmware, pero esto es de alguna manera incorrecto. <br><br>  Compr√© una bater√≠a de tama√±o 6x25x35 en eBay, pero result√≥ ser defectuosa o la apagu√© con un cortocircuito o una corriente de carga grande (de manera predeterminada, la corriente de carga est√° configurada en 1A y necesita soldar una resistencia para reducir la corriente).  En cualquier caso, cuando se conect√≥ la carga, incluso a 10 mA, el voltaje de la bater√≠a cay√≥ a 1V.  En el momento de la prueba, cambi√© a una bater√≠a LiPo medio muerta desde un peque√±o quadrocopter.  Un poco m√°s tarde ped√≠ la bater√≠a a otro vendedor y result√≥ ser buena. <br><br>  En principio, ser√≠a posible detenerse en esto, soldar los cables de conexi√≥n y empujar suavemente todo dentro de alg√∫n tipo de carcasa, pero decid√≠ medir el consumo del circuito.  Y luego llor√©.  Bueno, en condiciones de funcionamiento (cuando las bombillas brillan por completo), esta cosa consume hasta 130 mA, por lo que, en reposo, el consumo es de m√°s de 25 mA.  Es decir  ¬°Esta luz intermitente consume mi bater√≠a de 600 mAh en menos de un d√≠a! <br><br>  Result√≥ que unos 10 mA consumen LED.  Incluso si no se encienden, un microcontrolador todav√≠a funciona en cada uno de ellos y espera un comando.  Es decir  Debe crear un circuito de apagado para los LED. <br><br>  Los restantes 15 mA son consumidos por el microcontrolador.  S√≠, puede acostarse y, seg√∫n la hoja de datos, el consumo se medir√° mediante microamperios, pero de hecho no fue posible obtener menos de 1 mA.  Apagu√© el ADC y traduje los pines en la entrada.  Parece que en alg√∫n lugar del circuito hay alg√∫n tipo de fuga, pero mi modesto conocimiento de la electr√≥nica no es suficiente para encontrarlo y comprenderlo. <br><br><h2>  Complicamos el esquema </h2><br>  Entonces record√© que compr√© un chip PT1502 para una prueba.  Este chip es un controlador de carga de bater√≠a de litio completo con una fuente de alimentaci√≥n con varias entradas de control.  La √∫nica dificultad es que el microcircuito viene en un paquete QFN20 de 4x4 mm y requiere algunas correas.  Soldar esto en casa es dif√≠cil, pero posible.  La tarifa es dif√≠cil para un LUT regular y debe solicitarse a los chinos.  Pero no tenemos miedo a las dificultades, ¬øverdad? <br><br>  En varios cuadros, el esquema se puede describir de la siguiente manera. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  En el estado apagado, no se suministra energ√≠a al controlador ni a los LED.  El dispositivo tiene un bot√≥n de 'Encendido' que enciende la luz intermitente (tambi√©n cambia de modo).  El LED brilla, digamos, un minuto, y si no hay actividad del usuario (nadie presiona un bot√≥n), el dispositivo se apaga.  Es decir  No solo se va a dormir, sino que se apaga mediante la se√±al Power Hold.  Y apaga todo a la vez, tanto el microcontrolador como los LED.  La funcionalidad de encendido y apagado se implementa dentro del chip PT1502 <br><br>  Todo lo que queda es dibujar un diagrama de circuito y hacer una placa de circuito.  La circuiter√≠a est√°, en su mayor parte, unida a la hoja de datos PT1502, as√≠ como al m√≥dulo Digispark ATTiny85.  El microcircuito del controlador de potencia PT1502 se divide funcionalmente en varias partes, por lo tanto, se divide en bloques en el circuito. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Esto, de hecho, es un controlador de carga de bater√≠a de litio con su propio arn√©s.  El LED1 indica el estado de carga - encendido, luego la carga est√° encendida.  La resistencia R6 establece la corriente de carga a 470 mA.  Como tengo una bater√≠a de 600 mAh, en principio, puede aumentar la corriente y poner una resistencia en 780-800 ohmios hasta 600 mA.  Sin embargo, no estoy seguro acerca de la calidad especial de mi bater√≠a: es mejor cargarla m√°s lentamente, pero durar√° m√°s. <br><br>  Considere un plan de energ√≠a <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  El bot√≥n SW1 inicia todo el sistema: el chip PT1502 se activa solo y luego inicia todas las fuentes de alimentaci√≥n (de las cuales tiene 3).  Cuando se instala la alimentaci√≥n, el microcircuito iniciar√° el microcontrolador liberando la se√±al RESET.  Para facilitar la depuraci√≥n, tambi√©n agregu√© un bot√≥n Restablecer por separado. <br><br>  La se√±al HOLD se usa para apagar todo el sistema.  Cuando se inicia el microcontrolador, debe configurar la unidad en esta l√≠nea.  Cuando llega el momento de redondear, el microcontrolador establece cero en la l√≠nea HOLD y el chip de alimentaci√≥n PT1502 detendr√° todas las fuentes de alimentaci√≥n. <br><br>  Ser√≠a posible seguir la carga de la bater√≠a baja usando la salida BAT_LOW, pero en este art√≠culo lo califiqu√©: no necesita guardar ning√∫n dato y nada explotar√° si no nota una bater√≠a agotada a tiempo.  Muere, as√≠ muere.  Pero por si acaso, la junta proporcion√≥ contacto para este negocio. <br><br>  Volvamos al bot√≥n SW1 por un segundo.  Decid√≠ no hacer 2 botones separados para encender y controlar.  Por lo tanto, el mismo bot√≥n tambi√©n est√° conectado al ATTiny85 y durante la operaci√≥n cambia los modos de parpadeo.  Los valores del divisor R7-R8 se seleccionan para no quemar el puerto del microcontrolador PB2.  Para todos los rangos de voltaje de la bater√≠a (3.3 - 4.2V), el voltaje se suministrar√° al pie del controlador dentro de los l√≠mites especificados de la hoja de datos (0.7 * VCC - VCC + 0.5V) <br><br>  Considera una fuente de energ√≠a <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Este es un convertidor DC-DC pulsado.  El voltaje de salida se establece mediante las resistencias R10-R11 y, de acuerdo con la f√≥rmula de la hoja de datos, se establece en 3.3V.  Todo lo dem√°s es un simple flejado. <br><br>  Para bien, una fuente de alimentaci√≥n tan enga√±osa no es realmente necesaria: ser√≠a posible alimentar el microcontrolador en general directamente desde la bater√≠a.  Es solo que esta fuente ya est√° implementada en el chip PT1502 y puede encenderse / apagarse cuando la necesitemos, ¬øpor qu√© no usarla? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  El chip tambi√©n tiene 2 estabilizadores lineales, pero no los usar√©.  Desafortunadamente, result√≥ que todav√≠a es necesario suministrar el voltaje de entrada a esta fuente, de lo contrario, el microcircuito piensa que la energ√≠a a√∫n no es lo suficientemente estable y no inicia el microcontrolador (este conocimiento me fue dado por una semana de soldar el tablero de prueba de un lado a otro; no pod√≠a entender por qu√© no funciona ) <br><br>  Pasemos a la parte l√≥gica. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  El cable USB se traslapa de la placa Digispark sin cambios.  Esto es necesario para coordinar el voltaje USB (que funciona con 3.3V) y las se√±ales del microcontrolador (que en el original est√° alimentado por 5V).  Como en mi caso el microcontrolador tambi√©n funciona con 3.3V, el circuito podr√≠a simplificarse, pero por si acaso, me divorci√© del circuito original en el tablero. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  No hay nada interesante en la uni√≥n del microcontrolador. <br><br>  El toque final es el conector <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  De hecho, obtuve una placa de depuraci√≥n para m√≠ en ATTiny85 con soporte USB y un controlador de energ√≠a con una bater√≠a de litio.  Por lo tanto, no me limit√© a simplemente enviar la l√≠nea al LED.  En cambio, traje todas las l√≠neas del microcontrolador al peine; al mismo tiempo, es conveniente conectarse al programador. <br><br>  Y deje que casi todas las l√≠neas est√©n r√≠gidamente vinculadas a una determinada funcionalidad (PB1 - L√≠nea de espera, PB2 - bot√≥n de encendido, PB3 / PB4 - USB, PB5 - Restablecer) en el futuro ser√° posible eludir algunos l√≠mites.  Por ejemplo, no suelde el cable USB y libere las l√≠neas PB3 / PB4.  O, por ejemplo, rechazar un reinicio y liberar PB5.  Mientras tanto, solo PB0 permanece libre, y conecta nuestro LED a √©l. <br><br>  Pasamos al tablero.  Dadas las limitaciones en el tama√±o de la placa en 40x40 mm, la cantidad de componentes y la carcasa QFN20 del chip PT1502, ni siquiera consider√© la fabricaci√≥n de la placa en casa.  Por lo tanto, inmediatamente comenc√© a criar el tablero de dos capas m√°s compacto.  Eso es lo que tengo <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Para facilitar su uso, en el reverso firm√© todas las funciones de salida posibles (se me ocurri√≥ la idea de la placa Digispark) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Orden√©</a> el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablero</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JLCPCB</a> .  Para ser honesto, no estoy muy satisfecho con la calidad: si suelda el chip muchas veces, la m√°scara cerca de los contactos peque√±os del PT1502 est√° un poco nublada.  Bueno, peque√±as inscripciones flotaban un poco.  Sin embargo, si todo se suelda la primera vez, entonces las normas. <br><br>  Para soldar QFN20 necesita un soldador, todo lo dem√°s se puede soldar con un cierto soldador con cierta habilidad.  As√≠ es como se ve la placa soldada <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Vivienda </h2><br>  Es hora de pasar al casco.  Lo imprim√≠ en una impresora 3D.  Dise√±o sin adornos: caja y bot√≥n.  Se proporcionan ganchos especiales en la caja para instalar la luci√©rnaga en el m√≥dulo cuadrado est√°ndar del dise√±ador. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  La placa principal y la bater√≠a viven en el estuche. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  El panel LED est√° montado en la cubierta, que a su vez se atornilla a la caja principal con tornillos. <br><br>  Al principio pens√© en atornillar el panel LED a la cubierta con tornillos, pero al final simplemente lo pegu√© en una cinta de doble cara.  Result√≥ as√≠ <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  De esta forma, el dispositivo ya se puede usar, pero todav√≠a se ve feo: no hay suficiente difusor. <br><br>  Trat√© de hacer la primera versi√≥n del difusor utilizando la tecnolog√≠a de contracci√≥n de botellas de PET con un secador de construcci√≥n (se asom√≥ a los modelos de aviones). <br><br>  Entonces, primero necesitas un espacio en blanco.  Lo hice con yeso, que vert√≠ en un formulario que imprim√≠ en una impresora 3D.  En la primera versi√≥n, el formulario era de una sola pieza y nunca pude sacar el disco fundido.  Por lo tanto, tuve que hacer una forma de dos piezas. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  La idea del m√©todo es la siguiente.  Pones una botella de yogurt para beb√©s en un espacio en blanco y la sientas con un secador de cabello.  Estos son solo reportajes de 20 recipientes diferentes de debajo de leche diferente. Nunca logr√© poner esto bien, sin pliegues ni burbujas.  Aparentemente necesita cercar alg√∫n tipo de instalaci√≥n de vac√≠o y colocar una l√°mina de pl√°stico.  En general, result√≥ ser demasiado dif√≠cil para tal oficio. <br><br>  Despu√©s de refunfu√±ar entre los topos, encontr√© un par de metros de sonda de pl√°stico transparente PET Verbatim.  Decid√≠ probar el difusor solo para imprimir.  Y aunque en la entrada de la impresora, el pl√°stico parece cristalino, la parte real es aburrida.  Esto probablemente se deba a la estructura interna, ya que  Las capas no llenan el volumen por completo, sino que se superponen con huecos y huecos.  Adem√°s, si intenta procesar la pieza con papel de lija para obtener una superficie m√°s lisa, obtenemos a√∫n m√°s esteras.  Sin embargo, esto es exactamente lo que necesitaba. <br><br>  Era demasiado vago para molestarme con el soporte para el difusor, as√≠ que lo agregu√© al pegamento caliente.  Entonces mi dise√±o ahora es condicionalmente plegable.  Podr√≠a confundirme con la invenci√≥n de alg√∫n tipo de pestillos, pero ya me he quedado sin sonda de pl√°stico transparente.  As√≠ que deja que se derrita. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Para las luces intermitentes LED, no necesita sumergirse particularmente en la periferia del microcontrolador: solo un par de funciones para trabajar con GPIO son suficientes.  Pero dado que el m√≥dulo est√° acoplado a la plataforma Arduino, ¬øpor qu√© no aprovechar esto? <br><br>  Primero, algunas definiciones y constantes <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Esto determina el n√∫mero de p√≠xeles en mi matriz, los n√∫meros de pin y el brillo m√°ximo de los LED (durante la depuraci√≥n, fue conveniente establecerlo en 50 para que no me ciegue los ojos) <br><br>  Los LED en mi matriz est√°n dispuestos de una manera bastante obvia: un zigzag.  Por lo tanto, para diferentes efectos, tuve que renumerar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Para controlar los LED, no reinvent√© la rueda y tom√© una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca lista para trabajar con los LED WS8211</a> .  La interfaz de la biblioteca est√° ligeramente encalada.  Algunas funciones auxiliares (por ejemplo, convertir HSV a RGB) tambi√©n se atascaron all√≠. <br><br>  Primero, la placa y la biblioteca WS8211 deben inicializarse. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  En primer lugar, debe configurar la se√±al POWER HOLD en la unidad: esta ser√° una se√±al para el chip PT1502 de que el microcontrolador se ha enrollado y funciona correctamente.  El microcircuito, a su vez, suministrar√° electricidad regularmente al microcontrolador y a los LED siempre que la se√±al de RETENCI√ìN est√© establecida en la unidad. <br><br>  A continuaci√≥n, se configuran las patas para controlar el LED en la salida y los botones en la entrada.  Despu√©s de eso, puede inicializar la biblioteca WS8211. <br><br>  Dado que este es un dispositivo bastante aut√≥nomo, es imposible permitir que el microcontrolador se pegue en un estado incomprensible y consuma toda la bater√≠a.  Para hacer esto, inicio el temporizador de vigilancia durante 2 segundos.  El temporizador se reiniciar√° en el bucle principal del programa. <br><br>  Ahora necesita definir un par de funciones auxiliares.  La biblioteca WS8211 almacena un b√∫fer con los valores de color de cada LED.  Trabajar con el b√∫fer directamente no es muy conveniente, porque escrib√≠ una funci√≥n simple para escribir valores RGB en un LED espec√≠fico <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  Pero en la mayor√≠a de los casos, en el modelo de color RGB, contar colores no es muy conveniente, o incluso imposible.  Por ejemplo, al dibujar cualquier tipo de arco iris, es m√°s conveniente trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el modelo de color HSV</a> .  El color de cada p√≠xel se establece por el valor del tono de color y el brillo.  La saturaci√≥n se omite por simplicidad (se usa el m√°ximo).  Los valores de matiz se reducen a un rango de 0-255 (en lugar del est√°ndar 0-359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  La funci√≥n se toma de la biblioteca Ai_WS8211 y se archiva ligeramente.  En la versi√≥n original de esta funci√≥n de la biblioteca hab√≠a un par de errores debido a que el color en los arco√≠ris se mostraba con sacudidas. <br><br>  Pasemos a la implementaci√≥n de varios efectos.  Cada funci√≥n se llama desde el bucle principal para dibujar un "marco".  Dado que cada efecto opera con diferentes par√°metros entre llamadas, se almacenan en variables est√°ticas. <br><br>  Este es el efecto m√°s simple: todos los LED est√°n llenos de un color, que cambia suavemente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  El siguiente efecto es m√°s interesante: muestra un arco iris a lo largo del contorno de la matriz y los colores del arco iris cambian gradualmente en un c√≠rculo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Y este efecto llena toda la matriz con un color aleatorio, que primero se ilumina suavemente y luego tambi√©n se apaga suavemente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  El siguiente grupo de efectos dibuja diferentes balizas intermitentes.  Entonces, por ejemplo, a un ni√±o le gusta construir una excavadora con imanes y una luz intermitente naranja ser√° muy √∫til all√≠. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  T√©cnicamente, el efecto se ve como un punto brillante que se mueve a lo largo de la matriz.  Pero para que se vea hermoso, los LED vecinos se desvanecen gradualmente a medida que se aleja del punto principal.  Por lo tanto, necesitaba una funci√≥n que calcule este mismo brillo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos es una cierta posici√≥n condicional del punto luminoso de brillo, asignada a un rango de loopback de 0-255.  ledPos es la posici√≥n del LED (que se muestra en el mismo rango) cuyo brillo necesita calcular.  Si la diferencia de posici√≥n es mayor que delta, entonces el LED no se enciende, y cuanto m√°s cerca de la posici√≥n, m√°s brillante se ilumina. <br><br>  O, por ejemplo, una luz intermitente roja y azul de la polic√≠a <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Como estamos hablando de autom√≥viles, entonces el sem√°foro aqu√≠ no es un problema para implementar. <br><br>  Estas son funciones que incluyen varias se√±ales de tr√°fico en varias posiciones. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Es hora de revivirlo.  El sem√°foro opera de acuerdo con un programa especial definido en una especie de bytecode.  La placa describe el modo y el tiempo durante el cual este modo debe estar activado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  En realidad, la funci√≥n que lo procesa todo <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Al alcanzar el intervalo de tiempo especificado, se activa el siguiente modo de sem√°foro y la cuenta regresiva comienza nuevamente. <br><br>  El √∫ltimo efecto sobre el cual fue suficiente mi imaginaci√≥n son los asteriscos.  5 LED aleatorios se iluminan con un brillo aleatorio y luego se apagan suavemente.  Si una estrella se apaga, se encender√° otra en un lugar aleatorio. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  En alg√∫n lugar aqu√≠ apareci√≥ un bicho malvado.  A veces las estrellas se iluminan bruscamente, o viceversa, se apagan abruptamente.  Pero para ser honesto, era demasiado vago como para entenderlo, parece bastante normal. <br><br>  Es hora de pensar en ahorrar bater√≠a.  Ya he dado los valores de consumo de todo esto.  Si no piensa en apagar la alimentaci√≥n, los LED consumir√°n la bater√≠a en un par de horas.  Esta funci√≥n es responsable de apagar la alimentaci√≥n despu√©s de 90 segundos de inactividad.  Inicialmente, fueron 60 segundos, pero con un juego real esto no fue suficiente, y 2 minutos fueron de alguna manera largos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  En realidad, el apagado ocurre de la siguiente manera. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Si el usuario presiona los botones, el temporizador se reinicia.  Una vez transcurrido el tiempo establecido, la funci√≥n establece la se√±al HOLD en cero, que es un comando PT1502 para apagar la alimentaci√≥n.  Watchdog, por cierto, tambi√©n debe detenerse, de lo contrario, despu√©s de 2 segundos, activar√° el sistema y volver√° a encender. <br><br>  Finalmente, el ciclo principal que lo inicia todo <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Al presionar el bot√≥n se cambian los modos y se restablece el temporizador de apagado autom√°tico.  Dependiendo del modo actual, se inicia una de las funciones de efectos de la lista Modos.  En cada ciclo, el perro guardi√°n tambi√©n se reinicia. <br><br>  Si un ni√±o, por ejemplo, jugaba con un autom√≥vil policial y despu√©s de 1,5 minutos se apagaba la luz de emergencia, lo m√°s probable es que despu√©s de un segundo turno el hijo quiera seguir jugando el autom√≥vil policial.  Para hacer esto, el modo seleccionado se guarda en EEPROM (el n√∫mero de celda 10 se selecciona del bulldozer). <br><br>  Aqu√≠ hay un video que muestra c√≥mo funciona todo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Cargador de arranque </h2><br>  Casi todo est√° listo.  Pero hay una cosa m√°s que debe archivarse: un gestor de arranque.  El hecho es que el gestor de arranque est√°ndar no nos conviene. <br><br>  En primer lugar, cuando enciende la alimentaci√≥n, espera hasta 6 segundos; tal vez el firmware comenzar√° a fluir.  Solo despu√©s de que este control se transfiere al firmware principal.  Esto es conveniente en la etapa de desarrollo, pero ser√° molesto en el dispositivo terminado. <br><br>  Y en segundo lugar, el gestor de arranque est√°ndar no sabe nada sobre el chip PT1502, lo que ser√≠a bueno dar una se√±al de RETENCI√ìN.  Sin esta se√±al, el microcircuito piensa que el microcontrolador no se inici√≥ o, por el contrario, quiere apagarse.  Y si es as√≠, luego de unos pocos milisegundos, el PT1502 cortar√° la alimentaci√≥n de todo el circuito. <br><br>  El beneficio de solucionar ambos problemas no es dif√≠cil.  El digispark ATTiny85 utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el gestor de arranque de micron√∫cleos</a> .  Este gestor de arranque es lo suficientemente f√°cil de archivar para nuestras necesidades.  Solo es necesario corregir las definiciones correspondientes en el archivo de configuraci√≥n. <br><br>  En primer lugar, copi√© la configuraci√≥n est√°ndar de firmware \ configuraci√≥n \ t85_default en mi propio directorio y ya hice todos los cambios en √©l.  Por lo tanto, en caso de que sea f√°cil volver al cargador de arranque original. <br><br>  En el archivo bootloaderconfig.h, hay una opci√≥n de c√≥mo ingresar al gestor de arranque.  De lo que se ofrece de f√°brica, nada nos conviene, pero la opci√≥n m√°s cercana es ENTRY_JUMPER.  En esta opci√≥n, se accede al gestor de arranque solo si aparece un cierto nivel en un pin espec√≠fico (el puente est√° cerrado en el tablero). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  No tenemos un puente, pero hay un bot√≥n en el pie de PB2.  Deje que el gestor de arranque entre si el bot√≥n se mantiene presionado durante 5-7 segundos cuando se enciende la alimentaci√≥n.  Pero si se presiona y suelta, la transici√≥n al firmware principal se produce de inmediato. <br><br>  Necesitamos definir 3 funciones: inicializaci√≥n, desinicializaci√≥n y, de hecho, verificar si es hora de ingresar al gestor de arranque.  En el original, todos son simples e implementados con macros.  Solo los primeros 2 ser√°n simples <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () configura el pin del bot√≥n (JUMPER_PIN) en la entrada y apaga el suspensor.  Ya tenemos un pull-up en el tablero y en el suelo, y cuando presionas un bot√≥n en el pin, por el contrario, habr√° uno.  Al mismo tiempo, puede configurar inmediatamente la se√±al HOLD para que salga y configurar la unidad para que ... <br><br>  Para obtener una explicaci√≥n de la aritm√©tica de bits, por ejemplo, vaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , y se puede obtener una comprensi√≥n de los registros de configuraci√≥n GPIO en los controladores AVR, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> . <br><br>  La funci√≥n bootLoaderExit () est√° vac√≠a porque  la configuraci√≥n expuesta es bastante adecuada para la transici√≥n posterior al firmware principal <br><br>  La funci√≥n bootLoaderStartCondition (), que es responsable de ingresar el gestor de arranque en el formato macro, no se ha adaptado y, por lo tanto, se ha convertido en una funci√≥n completa <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  La funci√≥n dentro de unos segundos (de hecho, aproximadamente 6-7) verifica el estado del bot√≥n.  Si el bot√≥n se solt√≥ antes, entonces no necesitamos ingresar al gestor de arranque.  Paciente y persistente est√°n permitidos en el gestor de arranque. <br><br>  Al final result√≥ que, el archivo bootloaderconfig.h est√° involucrado en la compilaci√≥n de archivos ensambladores y el c√≥digo en este archivo causa errores.  Tuve que poner la funci√≥n en el bloque #ifndef __ASSEMBLER__ <br><br>  Otro par√°metro que modifiqu√© le dice al gestor de arranque qu√© hacer si no est√° conectado a USB: salga despu√©s de un segundo.  El hecho es que durante el robo, el hijo a menudo presion√≥ el bot√≥n y accidentalmente entr√≥ en el gestor de arranque.  No s√© qu√© milagroso, pero si el gestor de arranque no vio la conexi√≥n USB, podr√≠a sobrescribir accidentalmente algunas p√°ginas de memoria.  Por lo tanto, si no hay conexi√≥n, simplemente saldremos al programa principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Compilamos ... y recibimos un error de que el c√≥digo no cabe en el espacio del cargador de arranque asignado a √©l.  Dado que la memoria flash en el controlador es muy peque√±a, el gestor de arranque se exprime al m√°ximo para dejar m√°s espacio para el programa principal.  Pero esto se soluciona f√°cilmente en el archivo Makefile.inc siguiendo las instrucciones <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Luego, reduje la direcci√≥n de inicio del cargador de arranque a una p√°gina (64 bytes), aumentando as√≠ el espacio del cargador de arranque. <br><br>  De lo contrario, compilar y cargar el gestor de arranque utilizando el programador USBAsp no fue un problema. <br><br><h2>  Conclusi√≥n </h2><br>  Fue una forma muy interesante de un prototipo en una placa de prueba a un dispositivo terminado.  Parece un intermitente ordinario de una lecci√≥n de arduino, pero de hecho, en el proceso de trabajo, tuve que resolver un mont√≥n de problemas interesantes: aqu√≠ est√°n la lucha con el consumo, la elecci√≥n de la base del elemento y el dise√±o del caso, y recordar el firmware con el gestor de arranque.  Espero sinceramente que mi experiencia sea √∫til para alguien. <br><br>  ¬øPudo haber sido m√°s f√°cil?  Por supuesto que puedes.  Creo que todo se podr√≠a hacer con un transistor.  Desafortunadamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> le√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> despu√©s de soldar la placa.  Ver√≠a el art√≠culo antes, har√≠a todo en el mismo TP4056 popular, es m√°s f√°cil soldarlo.  De todos modos, el convertidor DC-DC, que est√° dentro del PT1502 en este dispositivo, para bien, no es necesario.  Sin embargo, un estudio pr√°ctico del microcircuito PT1502 me es √∫til para mi otro proyecto, as√≠ como la capacidad de soldar microcircuitos en el paquete QFN20. <br><br>  Finalmente, aqu√≠ est√°n los enlaces a mi proyecto: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo de firmware</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Circuito y placa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo de carcasa y difusor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelos STL listos para imprimir</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435198/">https://habr.com/ru/post/es435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435184/index.html">La inteligencia artificial aprendi√≥ a encontrar la enfermedad de Alzheimer en el cerebro 6 a√±os antes del diagn√≥stico</a></li>
<li><a href="../es435186/index.html">Rolls-Royce desarrolla el avi√≥n el√©ctrico m√°s r√°pido del mundo</a></li>
<li><a href="../es435190/index.html">Google ha logrado retirarse de los impuestos de $ 22.7 mil millones a trav√©s de Irlanda y Bermudas</a></li>
<li><a href="../es435194/index.html">Simplifique la redacci√≥n del curr√≠culum de un desarrollador</a></li>
<li><a href="../es435196/index.html">Los investigadores pasan ReCAPTCHA utilizando los servicios de Google</a></li>
<li><a href="../es435202/index.html">Escribimos nuestro lenguaje de programaci√≥n, parte 1: escribimos un lenguaje VM</a></li>
<li><a href="../es435204/index.html">Recepci√≥n para desarrolladores para superar la dilaci√≥n</a></li>
<li><a href="../es435206/index.html">Europa aprueba la directiva de derechos de autor: por qu√© las plataformas de transmisi√≥n se oponen</a></li>
<li><a href="../es435208/index.html">Internet de las cosas ... que lloran por una buena UI / UX</a></li>
<li><a href="../es435210/index.html">El trabajo de Xamarin con el SDK C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>