<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♣️ ☝🏽 🎉 .NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 1 🎄 👰🏻 👏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menerbitkan artikel asli tentang Habr, yang terjemahannya diposting di blog Codingsight . 
 Bagian kedua tersedia di sini. 

 Kebutuhan untuk mel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/">  <i>Saya menerbitkan artikel asli tentang Habr, yang terjemahannya diposting di blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codingsight</a> .</i> <br>  <i>Bagian kedua tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a></i> <br><br>  Kebutuhan untuk melakukan sesuatu secara serempak, tanpa menunggu hasilnya di sini dan sekarang, atau untuk berbagi banyak pekerjaan antara beberapa unit yang melakukan itu, bahkan sebelum munculnya komputer.  Dengan penampilan mereka, kebutuhan seperti itu menjadi sangat nyata.  Sekarang, pada tahun 2019, mengetik artikel ini di laptop dengan prosesor Intel Core 8-core, di mana tidak seratus proses bekerja pada saat yang sama, tetapi lebih banyak utas.  Di sebelahnya terdapat ponsel yang sedikit usang, dibeli beberapa tahun yang lalu, dengan prosesor 8-core.  Sumber daya tematik penuh dengan artikel dan video di mana penulisnya mengagumi smartphone andalannya tahun ini di mana mereka menempatkan prosesor 16-inti.  Kurang dari $ 20 / jam, MS Azure menyediakan mesin virtual dengan 128 prosesor inti dan 2 TB TB.  Sayangnya, tidak mungkin memaksimalkan dan mengekang kekuatan ini tanpa bisa mengendalikan interaksi arus. <br><a name="habracut"></a><br><h3>  Terminologi </h3><br>  <b>Proses</b> - Objek OS, ruang alamat terisolasi, berisi utas. <br>  <b>Thread (Utas)</b> - objek OS, unit eksekusi terkecil, bagian dari suatu proses, utas berbagi memori dan sumber daya lainnya di antara mereka sendiri dalam proses. <br>  <b>Multitasking</b> adalah fitur OS, kemampuan untuk menjalankan banyak proses pada saat yang bersamaan <br>  <b>Multicore</b> - properti prosesor, kemampuan untuk menggunakan banyak core untuk pemrosesan data <br>  <b>Multiprocessing</b> - properti komputer, kemampuan untuk bekerja secara bersamaan dengan beberapa prosesor secara fisik <br>  <b>Multithreading</b> adalah properti dari suatu proses, kemampuan untuk mendistribusikan pemrosesan data antara banyak utas. <br>  <b>Paralelisme</b> - melakukan beberapa tindakan secara fisik pada waktu yang sama per unit waktu <br>  <b>Asynchrony</b> - pelaksanaan operasi tanpa menunggu akhir dari pemrosesan ini, hasil dari eksekusi dapat diproses nanti. <br><br><h3>  Metafora </h3><br>  Tidak semua definisi baik dan beberapa memerlukan penjelasan tambahan, jadi saya akan menambahkan metafora untuk memasak sarapan ke terminologi yang diperkenalkan secara formal.  Memasak sarapan dalam metafora ini adalah suatu proses. <br><br>  Memasak sarapan di pagi hari saya ( <b>CPU</b> ) datang ke dapur ( <b>Komputer</b> ).  Saya punya 2 tangan ( <b>Cores</b> ).  Dapur memiliki sejumlah perangkat ( <b>IO</b> ): oven, ketel, pemanggang roti, lemari es.  Saya menyalakan gas, meletakkan wajan di atasnya dan menuangkan minyak di sana, tanpa menunggu sampai memanas ( <b>asynchronous, Non-Blocking-IO-Wait</b> ), saya mengambil telur dari lemari es dan memecahnya menjadi piring, dan kemudian memukulnya dengan satu tangan ( <b>Thread # 1)</b> ), dan yang kedua ( <b>Thread # 2</b> ) Saya memegang piring (Sumber Daya Bersama).  Sekarang saya masih akan menyalakan ketel, tetapi tidak ada cukup tangan ( <b>Thread Starvation</b> ) Selama waktu ini, penggorengan dipanaskan (Memproses hasilnya) di mana saya menuangkan apa yang saya kocok.  Saya meraih ketel dan menyalakannya dan secara bodoh melihat bagaimana air di dalamnya mendidih ( <b>Memblokir-IO-Tunggu</b> ), meskipun saya bisa mencuci piring selama waktu ini, di mana saya mengalahkan telur dadar. <br><br>  Saya memasak telur dadar hanya dengan 2 tangan, dan saya tidak punya lebih, tetapi pada saat yang sama, 3 operasi terjadi pada saat mengocok telur dadar: mengocok telur dadar, memegang piring, memanaskan wajan. CPU adalah bagian tercepat dari komputer, IO adalah yang lebih sering dari komputer memperlambat segalanya, sehingga seringkali solusi yang efektif adalah mengambil sesuatu CPU saat menerima data dari IO. <br><br>  Melanjutkan metafora: <br><br><ul><li>  Jika dalam proses menyiapkan telur dadar, saya juga akan mencoba berganti pakaian, ini akan menjadi contoh multitasking.  Nuansa penting: komputer dengan ini jauh lebih baik daripada orang. </li><li>  Dapur dengan beberapa koki, misalnya di restoran, adalah komputer multi-core. </li><li>  Banyak restoran food court di pusat perbelanjaan - pusat data </li></ul><br><h3>  .NET Tools </h3><br>  Dalam bekerja dengan utas, seperti dalam banyak hal lainnya, .NET bagus.  Dengan setiap versi baru, ia menyajikan semakin banyak alat baru untuk bekerja dengannya, lapisan abstraksi baru di atas utas OS.  Dalam bekerja dengan konstruksi abstraksi, pengembang kerangka menggunakan pendekatan yang meninggalkan kemungkinan ketika menggunakan abstraksi tingkat tinggi, itu akan turun satu atau beberapa level di bawah ini.  Paling sering ini tidak perlu, apalagi, ini membuka kemungkinan senapan ditembak di kaki, tetapi kadang-kadang, dalam kasus yang jarang terjadi, ini mungkin satu-satunya cara untuk memecahkan masalah yang tidak menyelesaikan pada tingkat abstraksi saat ini. <br><br>  Dengan alat, maksud saya kedua antarmuka program (API) yang disediakan oleh kerangka kerja dan paket pihak ketiga, dan solusi perangkat lunak keseluruhan yang menyederhanakan pencarian untuk masalah yang terkait dengan kode multi-threaded. <br><br><h4>  Aliran mulai </h4><br>  Kelas Thread, kelas paling dasar dalam .NET untuk bekerja dengan utas.  Konstruktor menerima satu dari dua delegasi: <br><br><ul><li>  ThreadStart - Tanpa Parameter </li><li>  ParametrizedThreadStart - dengan satu parameter tipe objek. </li></ul><br>  Delegasi akan dieksekusi di utas yang baru dibuat setelah memanggil metode Mulai, jika delegasi tipe ParametrizedThreadStart diteruskan ke konstruktor, maka objek harus diteruskan ke metode Mulai.  Mekanisme ini diperlukan untuk mentransfer informasi lokal apa pun ke aliran.  Perlu dicatat bahwa membuat utas merupakan operasi yang mahal, dan utas itu sendiri adalah benda berat, setidaknya karena memori 1MB dialokasikan ke tumpukan, dan memerlukan interaksi dengan OS API. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  Kelas ThreadPool mewakili konsep kumpulan.  Di .NET, kumpulan thread adalah karya seni dan pengembang dari Microsoft telah berupaya keras agar dapat berfungsi secara optimal dalam berbagai skenario. <br><br>  <b>Konsep umum:</b> <br><br>  <i>Sejak awal, aplikasi di latar belakang membuat beberapa utas sebagai cadangan dan memberikan kesempatan untuk menggunakannya.</i>  <i>Jika utas sering digunakan dan dalam jumlah besar, kumpulan dikembangkan untuk memenuhi kebutuhan kode panggilan.</i>  <i>Ketika tidak ada arus bebas di kumpulan pada waktu yang tepat, ia akan menunggu salah satu arus untuk kembali atau membuat yang baru.</i>  <i>Oleh karena itu, rangkaian utas sangat bagus untuk beberapa tindakan pendek dan kurang cocok untuk operasi yang beroperasi sebagai layanan di seluruh aplikasi.</i> <i><br><br></i>  <i>Untuk menggunakan utas dari kumpulan, ada metode QueueUserWorkItem yang menerima delegasi tipe WaitCallback, yang merupakan tanda tangan yang sama dengan ParametrizedThreadStart, dan parameter yang diteruskan untuk melakukan fungsi yang sama.</i> <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  Metode thread pool yang kurang dikenal, RegisterWaitForSingleObject, digunakan untuk mengatur operasi IO yang tidak menghalangi.  Delegasi yang diteruskan ke metode ini akan dipanggil ketika WaitHandle yang diteruskan ke metode ini "Dirilis". <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br>  .NET memiliki pengatur waktu aliran dan berbeda dari pengatur waktu WinForms / WPF karena penangannya akan dipanggil dalam aliran yang diambil dari kumpulan. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br>  Ada juga cara yang agak eksotis untuk mengirim delegasi ke utas dari kolam - metode BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br>  Saya juga ingin membahas fungsi yang memanggil banyak metode di atas - CreateThread dari Kernel32.dll Win32 API.  Ada cara, berkat mekanisme metode eksternal, untuk memanggil fungsi ini.  Saya melihat tantangan semacam itu hanya sekali dalam contoh mengerikan kode warisan, dan motivasi penulis untuk melakukan hal itu masih merupakan misteri bagi saya. <br><br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><h4>  Lihat dan debug utas </h4><br>  Utas yang Anda buat secara pribadi oleh semua komponen pihak ketiga dan .NET pool dapat dilihat di jendela Utas Visual Studio.  Jendela ini akan menampilkan informasi tentang aliran hanya ketika aplikasi sedang dalam debugging dan dalam mode istirahat (mode istirahat).  Di sini Anda dapat dengan mudah melihat nama dan prioritas tumpukan setiap utas, beralih debug ke utas tertentu.  Properti Priority dari kelas Thread memungkinkan Anda untuk mengatur prioritas utas, yang OC dan CLR akan anggap sebagai rekomendasi ketika membagi waktu CPU antara utas. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><h4>  Pustaka paralel tugas </h4><br>  Pustaka Paralel Tugas (TPL) muncul di .NET 4.0.  Sekarang ini adalah standar dan alat utama untuk bekerja dengan asinkron.  Kode apa pun yang menggunakan pendekatan yang lebih lama dianggap sebagai warisan.  Unit dasar TPL adalah kelas Tugas dari System.Threading.Tasks namespace.  Tugas adalah abstraksi atas utas.  Dengan versi baru C #, kami mendapatkan cara yang elegan untuk bekerja dengan operator Task - async / wait.  Konsep-konsep ini memungkinkan untuk menulis kode asinkron seolah-olah sederhana dan sinkron, ini memungkinkan bahkan bagi orang-orang dengan sedikit pemahaman tentang dapur utas internal untuk menulis aplikasi yang menggunakannya, aplikasi yang tidak membeku selama operasi yang lama.  Menggunakan async / menunggu adalah topik untuk satu atau bahkan beberapa artikel, tetapi saya akan mencoba untuk mendapatkan inti dari beberapa kalimat: <br><br><ul><li>  async adalah pengubah metode yang mengembalikan Task atau batal </li><li>  dan menunggu adalah pernyataan menunggu tanpa pemblokiran Tugas. </li></ul><br>  Sekali lagi: operator yang menunggu, dalam kasus umum (ada pengecualian), akan melepaskan utas eksekusi saat ini lebih lanjut, dan ketika Tugas selesai pelaksanaannya, dan utas (sebenarnya lebih tepat untuk mengatakan konteksnya, tetapi lebih pada itu nanti) akan bebas untuk melanjutkan metode lebih lanjut.  Di dalam .NET, mekanisme ini diimplementasikan dengan cara yang sama seperti imbal hasil, ketika metode tertulis berubah menjadi seluruh kelas, yang merupakan mesin negara dan dapat dieksekusi dalam potongan terpisah tergantung pada negara-negara ini.  Siapa pun yang tertarik dapat menulis kode sederhana apa pun menggunakan asyn / menunggu, kompilasi dan lihat perakitan menggunakan JetBrains dotPeek dengan Compiler Generated Code diaktifkan. <br><br>  Pertimbangkan opsi untuk meluncurkan dan menggunakan Tugas.  Menggunakan contoh kode di bawah ini, kami membuat tugas baru yang tidak berguna ( <i>Thread.Sleep (10000)</i> ), tetapi dalam kehidupan nyata itu harus semacam pekerjaan rumit yang melibatkan CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br>  Tugas dibuat dengan sejumlah opsi: <br><br><ul><li>  LongRunning adalah isyarat bahwa tugas tidak akan diselesaikan dengan cepat, yang berarti mungkin ada baiknya mempertimbangkan untuk tidak mengambil utas dari kumpulan, tetapi untuk membuat yang terpisah untuk Tugas ini agar tidak membahayakan yang lain. </li><li>  AttachedToParent - Tugas dapat diatur dalam hierarki.  Jika opsi ini digunakan, maka Tugas mungkin dalam keadaan ketika telah selesai sendiri dan sedang menunggu anak-anak untuk menyelesaikan. </li><li>  PreferFairness - berarti lebih baik untuk mengeksekusi tugas yang dikirim sebelumnya untuk dieksekusi sebelum yang dikirim nanti.  Tapi ini hanya rekomendasi dan hasilnya tidak dijamin. </li></ul><br>  Parameter kedua untuk metode yang lulus CancellToken.  Untuk memproses pembatalan operasi dengan benar setelah peluncurannya, kode yang dieksekusi harus diisi dengan pemeriksaan status dari Cancertoken.  Jika tidak ada pemeriksaan, maka metode Batal yang dipanggil pada objek PembatalanTokenSource akan dapat menghentikan pelaksanaan Tugas hanya sebelum dimulai. <br><br>  Parameter terakhir melewati objek scheduler dari tipe TaskScheduler.  Kelas ini dan turunannya dirancang untuk mengontrol strategi untuk mendistribusikan Task'ov oleh utas, secara default, Tugas akan dieksekusi pada utas acak dari kumpulan. <br><br>  Operator yang menunggu diterapkan ke Tugas yang dibuat, yang berarti kode yang ditulis setelah itu, jika ada, akan dieksekusi dalam konteks yang sama (seringkali ini berarti bahwa ia berada di utas yang sama) seperti kode sebelum menunggu. <br><br>  Metode ini ditandai sebagai batal async, yang berarti Anda dapat menggunakan operator yang menunggu di dalamnya, tetapi kode panggilan tidak dapat menunggu untuk dieksekusi.  Jika fitur ini diperlukan, maka metode tersebut harus mengembalikan Task.  Metode yang ditandai batal async cukup umum: sebagai aturan, ini adalah event handler atau metode lain yang bekerja berdasarkan prinsip api dan lupa.  Jika Anda tidak hanya perlu memberikan kesempatan untuk menunggu hingga penyelesaian, tetapi juga mengembalikan hasilnya, maka Anda harus menggunakan Tugas. <br><br>  Pada Tugas yang dikembalikan oleh metode StartNew, seperti yang lain, Anda dapat memanggil metode ConfigureAwait dengan parameter palsu, kemudian eksekusi setelah menunggu tidak akan melanjutkan pada konteks yang ditangkap, tetapi pada yang sewenang-wenang.  Ini harus selalu dilakukan ketika konteks eksekusi tidak penting untuk kode setelah menunggu.  Ini juga merupakan rekomendasi dari MS ketika menulis kode yang akan dikemas dalam bentuk pustaka. <br><br>  Mari kita memikirkan sedikit lebih banyak tentang bagaimana Anda bisa menunggu sampai Tugas selesai.  Di bawah ini adalah contoh kode, dengan komentar, ketika menunggu dilakukan dengan baik dan saat buruk. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  Pada contoh pertama, kita menunggu Tugas untuk menyelesaikan dan tanpa memblokir utas panggilan, kita akan kembali untuk memproses hasil hanya ketika sudah ada di sana, sampai utas panggilan dibiarkan sendiri. <br><br>  Pada opsi kedua, kami memblokir utas panggilan sampai hasil metode dihitung.  Ini buruk bukan hanya karena kami mengambil utas, sumber daya program yang sangat berharga, dengan kemalasan yang sederhana, tetapi juga karena jika kode metode yang kami panggil telah menunggu, dan konteks sinkronisasi melibatkan kembali ke utas panggilan setelah menunggu, maka kita akan menemui jalan buntu : utas panggilan menunggu sampai hasil dari metode asinkron dihitung, metode asinkron mencoba dengan sia-sia untuk melanjutkan eksekusi di utas panggilan. <br><br>  Kelemahan lain dari pendekatan ini adalah penanganan kesalahan yang rumit.  Faktanya adalah bahwa kesalahan dalam kode asinkron ketika menggunakan async / menunggu sangat mudah untuk ditangani - mereka berperilaku seolah-olah kode itu sinkron.  Sementara, jika kita menerapkan <s>pengusiran setan,</s> ekspektasi sinkron ke Tugas, pengecualian asli berubah menjadi AggregateException, yaitu  Untuk menangani pengecualian, Anda harus memeriksa tipe InnerException dan menulis rantai if di dalam satu blok tangkap atau menggunakan tangkap ketika membangun alih-alih rantai blok tangkap yang lebih akrab di C #. <br><br>  Contoh ketiga dan terakhir juga ditandai buruk karena alasan yang sama dan mengandung semua masalah yang sama. <br><br>  WhenAny dan WhenAll metode sangat mudah dalam menunggu sekelompok Task'ov, mereka membungkus sekelompok Task'ov dalam satu, yang akan bekerja pada operasi pertama Task'a dari grup, atau ketika semua orang menyelesaikan eksekusi mereka. <br><br><h4>  Aliran berhenti </h4><br>  Karena berbagai alasan, mungkin perlu untuk menghentikan aliran setelah dimulai.  Ada beberapa cara untuk melakukan ini.  Kelas Thread memiliki dua metode dengan nama yang sesuai - <b>Abort</b> dan <b>Interrupt</b> .  Yang pertama tidak direkomendasikan untuk digunakan, karena  setelah dipanggil kapan saja secara acak, selama pemrosesan instruksi apa pun, <b>ThreadAbortedException</b> akan dilempar.  Anda tidak akan mengharapkan pengecualian seperti itu crash ketika menambahkan variabel integer, kan?  Dan ketika menggunakan metode ini, ini adalah situasi yang sangat nyata.  Jika Anda ingin mencegah CLR dari melemparkan pengecualian seperti itu di bagian kode tertentu, Anda bisa membungkusnya dengan panggilan ke <b>Thread.BeginCriticalRegion</b> , <b>Thread.EndCriticalRegion</b> .  Kode apa pun yang ditulis di blok akhirnya dibungkus dengan panggilan seperti itu.  Untuk alasan ini, dalam isi kode kerangka kerja, Anda dapat menemukan blok dengan percobaan kosong, tetapi akhirnya tidak kosong.  Microsoft tidak merekomendasikan menggunakan metode ini bahwa mereka tidak memasukkannya dalam .net core. <br><br>  Metode Interrupt bekerja lebih mudah ditebak.  Itu dapat mengganggu utas dengan pengecualian <b>ThreadInterruptedException</b> hanya ketika utas berada dalam status siaga.  Dalam keadaan ini, masuk ke penangguhan saat menunggu WaitHandle, mengunci, atau setelah memanggil Thread. Tidur. <br><br>  Kedua opsi yang dijelaskan di atas buruk karena tidak dapat diprediksi.  Solusinya adalah dengan menggunakan struktur <b>CancellingToken</b> dan kelas <b>CancellingTokenSource</b> .  Intinya adalah: turunan dari kelas PembatalanTokenSource dibuat dan hanya orang yang memilikinya dapat menghentikan operasi dengan memanggil metode <b>Batal</b> .  Hanya PembatalanToken yang diteruskan ke operasi itu sendiri.  Pemilik PembatalanToken tidak dapat membatalkan operasi itu sendiri, tetapi hanya dapat memeriksa apakah operasi telah dibatalkan.  Untuk melakukan ini, ada properti Boolean <b>IsCancellationRequested</b> dan metode <b>ThrowIfCancelRequested</b> .  Yang terakhir akan menaikkan <b>TaskCancelledException</b> jika metode Batal dipanggil pada instance <b>CancellTokenSource</b> yang dibatalkan.  Dan inilah metode yang saya rekomendasikan untuk digunakan.  Ini lebih baik daripada opsi sebelumnya dengan mendapatkan kontrol penuh pada titik-titik mana operasi pengecualian dapat terputus. <br><br>  Opsi paling kejam untuk menghentikan utas adalah memanggil fungsi Win32 API TerminateThread.  Perilaku CLR setelah memanggil fungsi ini bisa tidak dapat diprediksi.  Pada MSDN, berikut ini ditulis tentang fungsi ini: <i>"TerminateThread adalah fungsi berbahaya yang hanya boleh digunakan dalam kasus yang paling ekstrim.</i>  <i>“</i> <br><br><h4>  Konversi legacy-API ke Berbasis Tugas menggunakan metode FromAsync </h4><br>  Jika Anda cukup beruntung untuk mengerjakan proyek yang dimulai setelah tugas diperkenalkan dan tidak lagi membuat ngeri bagi sebagian besar pengembang, maka Anda tidak akan harus berurusan dengan banyak API lama, baik pihak ketiga maupun tim Anda disiksa di masa lalu.  Untungnya, tim pengembangan .NET Framework merawat kami, meskipun mungkin tujuannya adalah untuk menjaga diri kami sendiri.  Meskipun demikian, .NET memiliki sejumlah alat untuk tanpa kesulitan mengubah kode yang ditulis dalam pendekatan pemrograman asinkron lama ke yang baru.  Salah satunya adalah metode FromAsync dari TaskFactory.  Menggunakan contoh kode di bawah ini, saya membungkus metode asinkron lama dari kelas WebRequest di Tugas menggunakan metode ini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Ini hanya sebuah contoh, dan Anda tidak mungkin melakukan ini dengan tipe bawaan, tetapi proyek lama apa pun hanya dipenuhi dengan metode BeginDoSomething yang mengembalikan metode IAsyncResult dan EndDoSomething yang menerimanya.</i> <br><br><h4>  Konversi legacy-API ke Berbasis Tugas menggunakan kelas TaskCompletionSource </h4><br>  Alat penting lainnya untuk dipertimbangkan adalah kelas <b>TaskCompletionSource</b> .  Dalam hal fungsi, tujuan dan prinsip operasi, entah bagaimana dapat mengingatkan metode RegisterWaitForSingleObject dari kelas ThreadPool tentang yang saya tulis di atas.  Menggunakan kelas ini, Anda dapat dengan mudah dan nyaman membungkus API asinkron yang lama di Tugas. <br><br>  <i>Anda akan mengatakan bahwa saya sudah berbicara tentang metode FromAsync dari kelas TaskFactory yang dimaksudkan untuk tujuan ini.</i>  <i>Di sini kita harus mengingat seluruh sejarah pengembangan model asinkron di .net yang telah ditawarkan Microsoft selama 15 tahun terakhir: sebelum Pola Asinkron Berbasis Tugas (TAP) ada Pola Pemrograman Asinkron (APP), yang tentang <b>Begin</b> DoMetode metoda yang mengembalikan <b>IAsyncResult</b> dan <b>End</b> Do. Metode yang menerimanya dan metode FromAsync baik-baik saja untuk warisan tahun-tahun ini, tetapi seiring waktu, itu digantikan oleh Event Based Asynchronous Pattern ( <b>EAP</b> ), yang mengasumsikan bahwa suatu peristiwa akan dipicu ketika operasi asinkron selesai.</i> <br><br>  TaskCompletionSource hanya bagus untuk menyelesaikan tugas dan legacy-API yang dibangun di sekitar model acara.  Inti dari karyanya adalah sebagai berikut: objek dari kelas ini memiliki properti publik dari jenis Tugas yang keadaannya dapat dikontrol melalui metode SetResult, SetException, dll dari kelas TaskCompletionSource.  Di tempat-tempat di mana operator menunggu diterapkan ke Tugas ini, itu akan dieksekusi atau jatuh dengan pengecualian, tergantung pada metode yang diterapkan pada TaskCompletionSource.  Jika semuanya masih tidak jelas, maka mari kita lihat contoh kode ini, di mana beberapa API EAP lama dibungkus dalam Tugas menggunakan TaskCompletionSource: ketika acara dipecat, Tugas akan ditransfer ke status Selesai, dan metode yang diterapkan operator menunggu untuk Tugas ini akan melanjutkan eksekusi mendapatkan objek <b>hasil</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><h4>  Tips &amp; Trik TaskCompletionSource </h4><br>  Membungkus API yang lebih lama tidak semuanya dapat Anda lakukan dengan TaskCompletionSource.  Menggunakan kelas ini membuka kemungkinan menarik untuk merancang berbagai API pada tugas yang tidak menempati utas.  Dan aliran, seperti yang kita ingat, adalah sumber daya yang mahal dan jumlahnya terbatas (terutama oleh RAM).  Batasan ini mudah dicapai dengan mengembangkan, misalnya, aplikasi web yang dimuat dengan logika bisnis yang kompleks.  Pertimbangkan kemungkinan yang saya bicarakan tentang penerapan trik seperti Polling Panjang. <br><br>  <i>Secara singkat, inti dari triknya adalah ini: Anda perlu menerima informasi dari API tentang beberapa peristiwa yang terjadi di sisinya, sementara API karena alasan tertentu tidak dapat melaporkan acara tersebut, tetapi hanya dapat mengembalikan negara.</i>  <i>Contohnya adalah semua API yang dibangun di atas HTTP sebelum waktu WebSocket atau ketika tidak mungkin karena alasan tertentu untuk menggunakan teknologi ini.</i>  <i>Klien dapat menanyakan server HTTP.</i>  <i>Server HTTP tidak dapat dengan sendirinya memprovokasi komunikasi dengan klien.</i>  <i>Solusi sederhana adalah menginterogasi server dengan timer, tetapi ini menciptakan beban tambahan pada server dan penundaan tambahan rata-rata TimerInterval / 2. Untuk menghindari hal ini, sebuah trik yang disebut Long Polling ditemukan, yang melibatkan menunda respons dari server sampai Timeout berakhir atau suatu peristiwa akan terjadi.</i>  <i>Jika suatu peristiwa telah terjadi, maka itu diproses, jika tidak, permintaan dikirim lagi.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Tetapi solusi seperti itu akan muncul dengan sendirinya begitu jumlah klien yang menunggu acara bertambah, karena  Setiap klien seperti itu, untuk mengantisipasi acara, mengambil seluruh aliran.  Ya, dan kami mendapat penundaan tambahan 1 ms untuk pengoperasian acara, paling sering itu tidak signifikan, tetapi mengapa membuat perangkat lunak lebih buruk daripada yang seharusnya?  Jika Anda menghapus Thread.Sleep (1), maka sia-sia kami akan memuat satu inti prosesor pada idle 100%, berputar dalam siklus yang tidak berguna.  Menggunakan TaskCompletionSource, Anda dapat dengan mudah mengulang kode ini dan menyelesaikan semua masalah yang diidentifikasi di atas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Kode ini tidak siap produksi, tetapi hanya demo.</i>  <i>Untuk menggunakannya dalam kasus nyata, Anda juga harus setidaknya menangani situasi ketika pesan tiba pada saat tidak ada yang mengharapkannya: dalam kasus ini, metode AsseptMessageAsync harus mengembalikan Tugas yang sudah selesai.</i>  <i>Jika kasus ini adalah yang paling sering terjadi, maka Anda dapat berpikir tentang menggunakan ValueTask.</i> <br><br>  Ketika kami menerima permintaan untuk pesan, kami membuat dan menempatkan TaskCompletionSource dalam kamus, dan kemudian kami menunggu apa yang terjadi terlebih dahulu: interval waktu yang ditentukan berakhir atau pesan diterima. <br><br><h4>  ValueTask: mengapa dan bagaimana </h4><br>  Async / menunggu operator, seperti operator pengembalian hasil, menghasilkan mesin negara dari metode, yang menciptakan objek baru, yang hampir selalu tidak penting, tetapi dalam kasus yang jarang terjadi dapat membuat masalah.  Kasing ini mungkin metode yang disebut sangat sering, berbicara tentang puluhan dan ratusan ribu panggilan per detik.  Jika metode seperti itu ditulis sehingga dalam banyak kasus mengembalikan hasil melewati semua metode menunggu, maka .NET menyediakan alat untuk mengoptimalkan ini - struktur ValueTask.  Untuk membuatnya jelas, pertimbangkan contoh penggunaannya: ada cache yang sering kita kunjungi.  Ada beberapa nilai di dalamnya dan kemudian kita mengembalikannya, jika tidak, maka kita pergi ke IO lambat di belakangnya.  Saya ingin melakukan yang terakhir secara asinkron, yang berarti seluruh metode asinkron.  Jadi, cara yang jelas untuk menulis sebuah metode adalah sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena keinginan untuk mengoptimalkan sedikit, dan sedikit ketakutan tentang apa yang akan dihasilkan Roslyn dengan mengkompilasi kode ini, kita dapat menulis ulang contoh ini sebagai berikut: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memang, solusi optimal dalam hal ini adalah untuk mengoptimalkan hot-path, yaitu, mendapatkan nilai dari kamus tanpa alokasi tambahan dan memuat pada GC, sedangkan dalam kasus-kasus langka ketika kita masih perlu pergi ke IO, semuanya akan tetap ditambah / minus yang lama: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat lebih dekat fragmen kode ini: jika ada nilai dalam cache, kita membuat struktur, jika tidak, tugas sebenarnya akan dibungkus dengan signifikan. </font><font style="vertical-align: inherit;">Kode panggilan tidak peduli ke arah mana kode ini dijalankan: ValueTask, dalam hal sintaksis C #, akan berperilaku seperti Tugas biasa dalam kasus ini.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penjadwal Tugas: Mengelola Strategi Peluncuran Tugas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API berikutnya yang ingin saya pertimbangkan adalah kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan turunannya. </font><font style="vertical-align: inherit;">Saya sudah menyebutkan di atas bahwa di TPL ada kemampuan untuk mengendalikan strategi untuk mendistribusikan Task'ov dengan utas. </font><font style="vertical-align: inherit;">Strategi tersebut didefinisikan dalam turunan dari kelas TaskScheduler. </font><font style="vertical-align: inherit;">Hampir semua strategi yang Anda butuhkan akan ditemukan di perpustakaan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dikembangkan oleh microsoft, tetapi bukan bagian dari .NET, tetapi dikirimkan sebagai paket Nuget. </font><font style="vertical-align: inherit;">Mari kita pertimbangkan secara singkat beberapa di antaranya:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Melakukan Tugas pada utas saat ini</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - membatasi jumlah tugas yang dieksekusi secara bersamaan ke parameter N, yang diterima di konstruktor</font></font></li><li> <b>OrderedTaskScheduler</b> —   LimitedConcurrencyLevelTaskScheduler(1),     . </li><li> <b>WorkStealingTaskScheduler</b> —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        . ..      WorkStealingTaskScheduler'    ,   ThreadPool     . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memungkinkan Anda untuk melakukan tugas sesuai dengan aturan antrian dengan prioritas</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - membuat utas terpisah untuk setiap Tugas yang berjalan di atasnya. </font><font style="vertical-align: inherit;">Ini bisa berguna untuk tugas-tugas yang berjalan lama tak terduga.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terperinci yang bagus </font><font style="vertical-align: inherit;">tentang Penjadwal Tugas di blog microsoft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk debugging nyaman segala sesuatu yang berkaitan dengan Tugas di Visual Studio ada jendela Tugas. </font><font style="vertical-align: inherit;">Di jendela ini, Anda dapat melihat status tugas saat ini dan pergi ke baris kode yang sedang dijalankan.</font></font><br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PLinq dan kelas Paralel </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain Tugas dan semua yang dikatakan bersama mereka di .NET, ada dua alat yang lebih menarik: PLinq (Linq2 Paralel) dan kelas Paralel. Yang pertama menjanjikan eksekusi paralel dari semua operasi Linq pada banyak utas. Jumlah utas dapat dikonfigurasi dengan metode ekstensi WithDegreeOfParallelism. Sayangnya, paling sering PLinq dalam mode run secara default tidak akan memiliki cukup informasi tentang bagian dalam sumber data Anda untuk memberikan peningkatan kecepatan yang signifikan, di sisi lain, harga percobaan sangat rendah: Anda hanya perlu memanggil metode AsParallel di depan rantai metode Linq dan melakukan tes kinerja. Selain itu, dimungkinkan untuk mentransfer ke informasi tambahan PLinq tentang sifat sumber data Anda menggunakan mekanisme Partisi. Anda dapat membaca lebih lanjut di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas statis paralel menyediakan metode untuk mengulangi koleksi Foreach secara paralel, mengeksekusi loop For, dan mengeksekusi beberapa delegasi secara paralel ke Invoke. Eksekusi utas saat ini akan dihentikan hingga akhir perhitungan. Jumlah utas dapat dikonfigurasi dengan meneruskan ParallelOptions sebagai argumen terakhir. Dengan menggunakan opsi, Anda juga dapat menentukan TaskScheduler dan CancellingToken.</font></font><br><br><h4>  Kesimpulan </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya mulai menulis artikel ini berdasarkan bahan-bahan laporan saya dan informasi yang saya kumpulkan selama pekerjaan setelahnya, saya tidak berharap akan menghasilkan begitu banyak. </font><font style="vertical-align: inherit;">Sekarang, ketika editor teks di mana saya mengetik artikel ini dengan mencela mengatakan bahwa halaman ke-15 telah hilang, saya akan meringkas hasil antara. </font><font style="vertical-align: inherit;">Trik, API, alat visual, dan jebakan lain akan dibahas dalam artikel mendatang. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda perlu mengetahui alat untuk bekerja dengan utas, asinkron, dan paralelisme untuk menggunakan sumber daya PC modern. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .NET memiliki banyak alat berbeda untuk tujuan ini. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak semuanya muncul sekaligus, karena peninggalan sering ditemukan, namun ada cara untuk mengonversi API lama tanpa banyak usaha. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bekerja dengan utas di .NET diwakili oleh kelas utas dan Utas </font></font></li><li>  Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken' </li><li>  —  ,   .   ,     .      TaskCompletionSource </li><li>      .NET        Task'. </li><li>  c# async/await     </li><li>   Task'       TaskScheduler'  </li><li>  ValueTask      hot-paths  memory-traffic </li><li>  Tasks  Threads Visual Studio           </li><li> PLinq  ,            ,        partitioning </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ... </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452094/">https://habr.com/ru/post/id452094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452082/index.html">Pembaruan Fleksibel Aplikasi dalam Aplikasi: Mempercepat Proses Pembaruan Aplikasi di Android</a></li>
<li><a href="../id452086/index.html">Apa yang ada di pixel saya untuk Anda: membuat nanopixels menggunakan metasurfaces plasmon</a></li>
<li><a href="../id452088/index.html">Pengenalan jalan melalui segmentasi semantik</a></li>
<li><a href="../id452090/index.html">Membuat generator puzzle prosedural</a></li>
<li><a href="../id452092/index.html">Pembaruan Dalam Aplikasi: Mempercepat Pembaruan Aplikasi Android</a></li>
<li><a href="../id452098/index.html">Log Habr pengembang front-end: refactor dan reflex</a></li>
<li><a href="../id452102/index.html">Permainan foto untuk mereka yang menyukai drone: secara singkat tentang AirSelfie 2</a></li>
<li><a href="../id452106/index.html">Kami mengundang pembicara ke pertemuan DIY musim panas pada 16 Juni 2019</a></li>
<li><a href="../id452108/index.html">Docker: saran tidak berbahaya</a></li>
<li><a href="../id452110/index.html">Mengotomatiskan penggantian disk dengan Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>