<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 💂🏼 👉🏾 Le livre de jeu intérieur. Fonctionnalités réseau dans le nouveau moteur Ansible 2.9 🐳 🔓 📯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La prochaine version de Red Hat Ansible Engine 2.9 vous attend avec des améliorations impressionnantes, dont certaines sont décrites dans cet article....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre de jeu intérieur. Fonctionnalités réseau dans le nouveau moteur Ansible 2.9</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/471896/"><p><img src="https://habrastorage.org/webt/db/2m/xd/db2mxdllzxasqtz4syfggtayzw4.jpeg"></p><br><p>  La prochaine version de Red Hat Ansible Engine 2.9 vous attend avec des améliorations impressionnantes, dont certaines sont décrites dans cet article.  Comme d'habitude, nous avons ouvertement développé les améliorations du réseau Ansible, avec le soutien de la communauté.  Rejoignez - Jetez un œil au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau des tâches sur GitHub</a> et étudiez le plan de développement pour la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sortie de Red Hat Ansible Engine 2.9</a> sur la page wiki d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ansible Network</a> . </p><br><p>  Comme nous l'avons récemment annoncé, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Red Hat Ansible Automation Platform</a> inclut désormais Ansible Tower, Ansible Engine et tout le contenu du réseau Ansible.  Désormais, la plupart des plateformes réseau les plus populaires sont implémentées via des modules Ansible.  Par exemple: </p><br><ul><li>  Arista eos </li><li>  Cisco IOS </li><li>  Cisco IOS XR </li><li>  Cisco NX-OS </li><li>  Juniper Junos </li><li>  Vyos </li></ul><br><p>  Une liste complète des plates-formes entièrement prises en charge par Red Hat via Ansible Automation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disponible ici</a> . </p><a name="habracut"></a><br><h2 id="chemu-my-nauchilis">  Qu'avons-nous appris </h2><br><p> Au cours des quatre dernières années, nous avons beaucoup appris sur le développement d'une plateforme d'automatisation de réseau.  Nous avons également appris comment les utilisateurs finaux jouent des artefacts de plate-forme dans les livres de jeu et les rôles Ansible.  Et voici ce que nous avons découvert: </p><br><ul><li>  Les organisations automatisent les appareils non seulement un, mais de nombreux fournisseurs. </li><li>  L'automatisation n'est pas seulement un phénomène technique, mais aussi culturel. </li><li>  L'automatisation à grande échelle des réseaux est plus compliquée qu'il n'y paraît, en raison des principes architecturaux fondamentaux de la conception d'automatisation. </li></ul><br><p>  Lorsque nous avons discuté de nos plans de développement à long terme il y a plus d'un an, nos entreprises clientes ont demandé ce qui suit: </p><br><ul><li>  La collecte des faits doit être mieux standardisée et alignée avec le flux de travail d'automatisation pour n'importe quel appareil. </li><li>  La mise à jour des configurations sur l'appareil doit également être standardisée et harmonisée afin que les modules Ansible traitent la seconde moitié du cycle après avoir collecté les faits. </li><li>  Nous avons besoin de méthodes rigoureuses et prises en charge pour convertir la configuration des appareils en données structurées.  Sur cette base, la source de vérité peut être déplacée d'un périphérique réseau. </li></ul><br><h2 id="uluchsheniya-faktov">  Améliorations des faits </h2><br><p>  La collecte de faits à partir de périphériques réseau à l'aide d'Ansible est souvent aléatoire.  Les plates-formes réseau sont équipées à des degrés divers de la capacité de collecter des faits, mais elles n'ont presque pas - ou même pas du tout - de fonctions pour analyser et standardiser la présentation des données dans des paires clé-valeur.  Lisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post de</a> Ken Celenza sur la difficulté et la douleur d'analyser et de normaliser les données factuelles. </p><br><p>  Vous avez peut-être remarqué comment nous avons travaillé sur le rôle Ansible Network Engine.  Naturellement, 24 000 téléchargements plus tard, le rôle Network Engine est rapidement devenu l'un des rôles les plus populaires d'Ansible dans Ansible Galaxy pour les scénarios d'automatisation de réseau.  Avant de migrer une grande partie de cela vers Ansible 2.8 pour préparer ce dont Ansible 2.9 avait besoin, ce rôle Ansible fournissait le premier ensemble d'outils pour aider à l'analyse des commandes, à la gestion des commandes et à la collecte de données pour les périphériques réseau. </p><br><p>  Si vous êtes doué pour utiliser Network Engine, il s'agit d'un moyen très efficace de collecter, d'analyser et de normaliser les données de fait à utiliser avec Ansible.  L'inconvénient de ce rôle est que vous devez créer tout un tas d'analyseurs pour chaque plate-forme et pour toutes les activités du réseau.  Pour comprendre à quel point il est difficile de créer, d'expédier et de maintenir des analyseurs, regardez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1200+ analyseurs</a> des gars de Cisco. </p><br><p>  En un mot, pour l'automatisation à grande échelle, il est très important de recevoir les faits des appareils et de les normaliser en paires clé-valeur, mais cela est difficile à réaliser lorsque vous avez de nombreux fournisseurs et plates-formes réseau. </p><br><p>  Chaque module de faits de réseau dans Ansible 2.9 peut désormais analyser la configuration d'un périphérique réseau et renvoyer des données structurées - sans bibliothèques supplémentaires, rôles Ansible ou analyseurs personnalisés. </p><br><p>  À partir d'Ansible 2.9, à chaque version du module réseau mis à jour, le module fact est amélioré pour fournir des informations sur cette section de configuration.  Autrement dit, le développement des faits et des modules se déroule désormais au même rythme, et ils auront toujours une structure de données commune. </p><br><p> La configuration des ressources sur un périphérique réseau peut être extraite et convertie en données structurées de deux manières.  Dans les deux cas, vous pouvez compiler et convertir une liste spécifique de ressources à l'aide du nouveau <code>gather_network_resources</code> .  Les noms de ressources correspondent aux noms de modules, ce qui est très pratique. </p><br><h3 id="vo-vremya-sbora-faktov">  Au moment de la collecte des faits: </h3><br><p>  À l'aide du <code>gather_facts</code> vous pouvez extraire la configuration actuelle de l'appareil au début du playbook, puis l'utiliser dans tout le playbook.  Spécifiez les ressources individuelles à récupérer à partir du périphérique. </p><br><pre> <code class="plaintext hljs">- hosts: arista module_defaults: eos_facts: gather_subset: min gather_network_resources: - interfaces gather_facts: True</code> </pre> <br><p>  Vous remarquerez peut-être quelque chose de nouveau dans ces exemples, à savoir <code>gather_facts: true</code> désormais disponible pour la recherche de faits native pour les périphériques réseau. </p><br><h3 id="ispolzovanie-modulya-setevyh-faktov-napryamuyu">  Utilisation directe du module de faits sur le réseau: </h3><br><pre> <code class="plaintext hljs">- name: collect interface configuration facts eos_facts: gather_subset: min gather_network_resources: - interfaces</code> </pre> <br><h3 id="pleybuk-vozvraschaet-sleduyuschie-fakty-ob-interfeyse">  Le playbook renvoie les faits suivants sur l'interface: </h3><br><pre> <code class="plaintext hljs">ansible_facts: ansible_network_resources: interfaces: - enabled: true name: Ethernet1 mtu: '1476' - enabled: true name: Loopback0 - enabled: true name: Loopback1 - enabled: true mtu: '1476' name: Tunnel0 - enabled: true name: Ethernet1 - enabled: true name: Tunnel1 - enabled: true name: Ethernet1</code> </pre> <br><p>  Remarquez comment Ansible récupère la configuration native de l'appareil Arista et la convertit en données structurées à utiliser comme paires clé-valeur standard pour les tâches et opérations suivantes. </p><br><p>  Les faits d'interface peuvent être ajoutés aux variables stockées Ansible et utilisés immédiatement ou ultérieurement comme entrée dans le <code>eos_interfaces</code> ressources <code>eos_interfaces</code> sans traitement ni conversion supplémentaires. </p><br><h3 id="moduli-resursov">  Modules de ressources </h3><br><p>  Nous avons donc extrait les faits, normalisé les données, les avons entrées dans un schéma interne normalisé de la structure des données et obtenu une source de vérité toute prête.  Hourra!  Bien sûr, c'est génial, mais nous devons toujours reconvertir les paires clé-valeur en une configuration spécifique attendue par une plate-forme de périphérique spécifique.  Nous avons maintenant besoin de modules pour des plates-formes spécifiques pour satisfaire ces nouvelles exigences de collecte de faits et de normalisation. </p><br><p>  Qu'est-ce qu'un module de ressources?  Les sections de configuration de l'appareil peuvent être considérées comme les ressources fournies par cet appareil.  Les modules de ressources réseau sont intentionnellement limités à une seule ressource, et ils peuvent être empilés comme des briques pour configurer des services réseau complexes.  En conséquence, les exigences et les spécifications du module de ressources sont naturellement simplifiées, car le module de ressources peut lire <em>et</em> configurer un service réseau spécifique sur un périphérique réseau. </p><br><p>  Pour expliquer ce que fait le module de ressources, regardons un exemple de playbook qui montre une opération idempoent utilisant de nouveaux faits à partir d'une ressource réseau et le module <code>eos_l3_interface</code> . </p><br><pre> <code class="plaintext hljs">- name: example of facts being pushed right back to device. hosts: arista gather_facts: false tasks: - name: grab arista eos facts eos_facts: gather_subset: min gather_network_resources: l3_interfaces - name: ensure that the IP address information is accurate eos_l3_interfaces: config: "{{ ansible_network_resources['l3_interfaces'] }}" register: result - name: ensure config did not change assert: that: not result.changed</code> </pre> <br><p>  Comme vous pouvez le voir, les données collectées de l'appareil sont transférées directement vers le module de ressources correspondant sans conversion.  Au démarrage, le playbook récupère les valeurs de l'appareil et les compare avec celles attendues.  Dans cet exemple, les valeurs obtenues correspondent aux valeurs attendues (c'est-à-dire que les écarts de configuration sont vérifiés) et un message s'affiche si la configuration a changé. </p><br><p>  Un moyen idéal pour détecter les écarts de configuration consiste à stocker les faits dans des variables stockées Ansible et à les utiliser périodiquement avec le module de ressources en mode vérification.  Il s'agit d'une méthode simple pour voir si quelqu'un a modifié les valeurs manuellement.  Dans la plupart des cas, les organisations autorisent les modifications et la configuration manuelles, bien que de nombreuses opérations soient effectuées via Ansible Automation. </p><br><h2 id="chem-novye-moduli-resursa-otlichayutsya-ot-predyduschih">  En quoi les nouveaux modules de ressources sont-ils différents des précédents? </h2><br><p>  Pour un ingénieur en automatisation de réseau, il existe 3 différences principales entre les modules de ressources dans Ansible 2.9 des versions précédentes. </p><br><p>  1) Pour une ressource réseau spécifique (qui peut également être considérée comme une section de configuration), les modules et les faits se développeront dans tous les systèmes d'exploitation réseau pris en charge en même temps.  Nous pensons que si Ansible prend en charge la configuration des ressources sur une seule plate-forme réseau, nous devons la prendre en charge partout.  Cela simplifie l'utilisation des modules de ressources, car un ingénieur en automatisation réseau peut désormais configurer une ressource (par exemple, LLDP) dans tous les systèmes d'exploitation réseau avec des modules natifs et pris en charge. </p><br><p>  2) Les modules de ressources incluent désormais une valeur d'état. </p><br><ul><li>  <code>merged</code> : la configuration est fusionnée avec la configuration fournie (par défaut); </li><li>  <code>replaced</code> : la configuration des ressources sera remplacée par la configuration fournie; </li><li>  <code>overridden</code> : la configuration des ressources sera remplacée par la configuration fournie;  les instances de ressources en excès seront supprimées; </li><li>  <code>deleted</code> : la configuration des ressources sera supprimée / restaurée par défaut. </li></ul><br><p><img src="https://habrastorage.org/webt/yg/0m/_c/yg0m_c1thcp9wm30_de2tqjs810.jpeg"></p><br><p>  3) Les modules de ressources incluent désormais des valeurs de retour stables.  Lorsque le module de ressources réseau a apporté (ou suggéré) les modifications nécessaires au périphérique réseau, il renvoie les mêmes paires clé-valeur au playbook. </p><br><ul><li>  <code>before</code> : configuration sur l'appareil sous forme de données structurées avant la tâche; </li><li>  <code>after</code> : si l'appareil a changé (ou peut changer si le mode de vérification est utilisé), la configuration résultante sera retournée sous forme de données structurées; </li><li>  <code>commands</code> : toutes les commandes de configuration s'exécutant sur l'appareil pour l'amener à l'état souhaité. </li></ul><br><p><img src="https://habrastorage.org/webt/si/jq/r2/sijqr2ujxrhob-6mvsg2wjcmhrw.jpeg"></p><br><p><img src="https://habrastorage.org/webt/tn/1s/cq/tn1scqim6qomensla3ksk3bn8s4.jpeg"></p><br><h2 id="chto-vse-eto-znachit-pochemu-eto-vazhno">  Qu'est-ce que tout cela signifie?  Pourquoi est-ce important? </h2><br><p>  Cet article décrit de nombreux concepts complexes, mais nous espérons qu'à la fin vous comprendrez mieux que les entreprises clientes demandent des faits, une normalisation des données et une configuration de boucle pour la plate-forme d'automatisation.  Mais pourquoi ont-ils besoin de ces améliorations?  De nombreuses organisations sont désormais engagées dans la transformation numérique pour rendre leurs environnements informatiques plus flexibles et compétitifs.  Pour le meilleur ou pour le pire, de nombreux ingénieurs réseau deviennent des développeurs de réseaux, soit par leur propre intérêt, soit à la demande des gestionnaires. </p><br><p>  Les organisations comprennent que l'automatisation de modèles de réseau individuels ne résout pas le problème de fragmentation et n'augmente l'efficacité que dans une certaine limite.  La plate-forme d'automatisation Red Hat Ansible fournit des modèles de données de ressources rigoureux et normatifs pour gérer par programme les données sous-jacentes sur un périphérique réseau.  Autrement dit, les utilisateurs abandonnent progressivement les méthodes de configuration individuelles au profit de méthodes plus modernes en mettant l'accent sur les technologies (par exemple, les adresses IP, les VLAN, LLDP, etc.), et non sur une implémentation de fournisseur spécifique. </p><br><p>  Est-ce à dire que les jours de configuration et de modules de commande fiables et éprouvés sont comptés?  Pas question.  Les modules de ressources réseau attendus ne seront pas applicables dans tous les cas et pas pour chaque fournisseur, de sorte que les ingénieurs réseau auront toujours besoin de modules de commande et de configuration pour certaines implémentations.  Le but des modules de ressources est de simplifier les grands modèles Jinja et de normaliser les configurations de périphériques non structurées dans un format JSON structuré.  Avec les modules de ressources, il sera plus facile pour les réseaux existants de transformer leur configuration en paires clé-valeur structurées qui seront une source de vérité facile à lire.  Si vous utilisez des paires clé-valeur structurées, vous pouvez passer des configurations en cours d'exécution sur chaque périphérique à l'utilisation de données structurées indépendantes et mettre les réseaux au premier plan avec l'approche «infrastructure en tant que code». </p><br><h2 id="kakie-moduli-resursov-poyavyatsya-v-ansible-engine-29">  Quels modules de ressources apparaîtront dans Ansible Engine 2.9? </h2><br><p>  Avant de dire en détail ce qui se passera dans Ansible 2.9, rappelons comment nous avons divisé la totalité du travail. </p><br><p>  Nous avons identifié 7 catégories et chacune a attribué des ressources réseau spécifiques: </p><br><p><img src="https://habrastorage.org/webt/qs/io/au/qsioaupl7rqnsvfnmiyzygd9zqs.png"></p><br><p>  Remarque: des ressources audacieuses ont été planifiées et mises en œuvre dans Ansible 2.9. <br>  Sur la base des commentaires des clients d'entreprise et de la communauté, il était logique de traiter d'abord les modules liés aux protocoles de topologie réseau, à la virtualisation et aux interfaces. <br>  Les modules de ressources suivants sont développés par l'équipe Ansible Network et correspondent aux plateformes prises en charge par Red Hat: </p><br><p><img src="https://habrastorage.org/webt/um/n8/lr/umn8lrzquzbuxlxbb10vaebxavw.png"></p><br><p>  Les modules suivants sont développés par la communauté Ansible: </p><br><ul><li>  <code>exos_lldp_global</code> - de Extreme Networks. </li><li>  <code>nxos_bfd_interfaces</code> - de Cisco </li><li>  <code>nxos_telemetry</code> - de Cisco </li></ul><br><p>  Comme vous pouvez le voir, le concept de modules de ressources s'intègre dans notre stratégie d'orientation de plateforme.  Autrement dit, nous incluons les capacités et fonctions nécessaires dans Ansible lui-même, afin de prendre en charge la normalisation dans le développement des modules réseau, ainsi que de simplifier le travail des utilisateurs au niveau du rôle et du playbook Ansible.  Pour étendre le développement des modules de ressources, l'équipe Ansible a publié l'outil Module Builder. </p><br><h2 id="plany-na-ansible-210-i-dalshe">  Plans pour Ansible 2.10 partir </h2><br><p>  Après la sortie d'Ansible 2.9, nous traiterons l'ensemble suivant de modules de ressources pour Ansible 2.10, qui peuvent être utilisés pour configurer davantage la topologie et la stratégie réseau, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACL, OSPF et BGP</a> .  Le plan de développement peut encore être ajusté, donc si vous avez des commentaires, signalez-le à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la communauté Ansible Network</a> . </p><br><h2 id="resursy-i-nachalo-raboty">  Ressources et mise en route </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Communiqué de presse de la plate-forme Ansible Automation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog de la plate-forme d'automatisation Ansible</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'avenir de la livraison de contenu chez Ansible</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réflexions sur la modification de la structure du projet Ansible</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471896/">https://habr.com/ru/post/fr471896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471882/index.html">Une liste ouverte d'événements PHP, de conférenciers et d'organisateurs sur GitHub</a></li>
<li><a href="../fr471884/index.html">10 utilitaires ApexSQL gratuits pour gérer les bases de données Microsoft SQL Server</a></li>
<li><a href="../fr471886/index.html">VMmanager 6: présentation de la box et comparaison avec la génération précédente</a></li>
<li><a href="../fr471890/index.html">Inférence variationnelle - qu'est-ce que c'est et que mange-t-elle?</a></li>
<li><a href="../fr471892/index.html">6 histoires pratiques de nos jours de semaine SRE</a></li>
<li><a href="../fr471904/index.html">Planificateur de ressources chez HPE InfoSight</a></li>
<li><a href="../fr471906/index.html">Les dangers des optimisations incorrectes</a></li>
<li><a href="../fr471908/index.html">La beauté inattendue des nombres premiers</a></li>
<li><a href="../fr471912/index.html">Apprendre l'anglais: 7 façons pratiques d'élargir votre vocabulaire</a></li>
<li><a href="../fr471914/index.html">Fonctionnement du système graphique Sega Mega Drive: processeur d'affichage vidéo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>