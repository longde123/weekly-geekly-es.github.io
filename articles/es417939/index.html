<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÅÔ∏è ‚óºÔ∏è üë®üèº‚Äç‚öñÔ∏è Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Partes 4 y 5 üçà üêª üç°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tengo una rama pbrt, que utilizo para probar nuevas ideas, implementar ideas interesantes de art√≠culos cient√≠ficos y, en general, para estudiar todo l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Partes 4 y 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="imagen"></div><br>  Tengo una rama pbrt, que utilizo para probar nuevas ideas, implementar ideas interesantes de art√≠culos cient√≠ficos y, en general, para estudiar todo lo que generalmente da como resultado una nueva edici√≥n del libro de <em>representaci√≥n basada en</em> la <em>f√≠sica</em> .  A diferencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pbrt-v3</a> , que nos esforzamos por mantener lo m√°s cerca posible del sistema descrito en el libro, en este hilo podemos cambiar cualquier cosa.  Hoy veremos c√≥mo los cambios m√°s radicales en el sistema reducir√°n significativamente el uso de la memoria en la escena con la isla de la caricatura de Disney <em>"Moana"</em> . <br><br>  Nota sobre la metodolog√≠a: en las tres publicaciones anteriores, todas las estad√≠sticas se midieron para la versi√≥n WIP (Work In Progress) de la escena con la que trabaj√© antes de su lanzamiento.  En este art√≠culo, pasaremos a la versi√≥n final, que es un poco m√°s complicada. <br><br>  Al renderizar la √∫ltima escena de la isla desde <em>Moana</em> , se usaron 81 GB de RAM para almacenar la descripci√≥n de la escena para pbrt-v3.  Actualmente, pbrt-next usa 41 GB, aproximadamente la mitad.  Para obtener este resultado, fue suficiente para hacer peque√±os cambios que se extendieron a varios cientos de l√≠neas de c√≥digo. <br><a name="habracut"></a><br><h2>  Primitivas reducidas </h2><br>  Recordemos que en pbrt <code>Primitive</code> es una combinaci√≥n de geometr√≠a, su material, la funci√≥n de radiaci√≥n (si es una fuente de luz) y registra sobre el ambiente dentro y fuera de la superficie.  En pbrt-v3, <code>GeometricPrimitive</code> almacena lo siguiente: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Como se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">indic√≥ anteriormente</a> , la mayor parte del tiempo <code>areaLight</code> es <code>nullptr</code> , y <code>MediumInterface</code> contiene un par de <code>nullptr</code> .  Entonces, en pbrt-next agregu√© una opci√≥n <code>Primitive</code> llamada <code>SimplePrimitive</code> , que solo almacena punteros a la geometr√≠a y al material.  Siempre que sea posible, se usa <code>GeometricPrimitive</code> posible en lugar de <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  Para las instancias de objetos no animados, ahora tenemos <code>TransformedPrimitive</code> , que solo almacena un puntero a la primitiva y la transformaci√≥n, lo que nos ahorra unos 500 bytes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espacio desperdiciado</a> que la instancia de <code>AnimatedTransform</code> agreg√≥ al renderizador <code>TransformedPrimitive</code> pbrt-v3. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Existe <code>AnimatedPrimitive</code> en caso de que necesite una conversi√≥n animada a pbrt-next). <br><br>  Despu√©s de todos estos cambios, las estad√≠sticas informan que solo se usan 7.8 GB en <code>Primitive</code> , en lugar de 28.9 GB en pbrt-v3.  Aunque es genial que hayamos ahorrado 21 GB, no es tanto como la disminuci√≥n que podr√≠amos esperar de estimaciones anteriores;  Volveremos a esta discrepancia al final de esta parte. <br><br><h2>  Geometr√≠a reducida </h2><br>  Adem√°s, pbrt-next redujo significativamente la cantidad de memoria ocupada por la geometr√≠a: el espacio utilizado para los tri√°ngulos de malla disminuy√≥ de 19.4 GB a 9.9 GB, y el espacio de almacenamiento para curvas de 1.4 a 1.1 GB.  Un poco m√°s de la mitad de estos ahorros provino de la simplificaci√≥n de la clase <code>Shape</code> b√°sica. <br><br>  En pbrt-v3, <code>Shape</code> trae consigo varios miembros que se transfieren a todas las implementaciones de <code>Shape</code> ; estos son varios aspectos a los que es conveniente acceder en las implementaciones de <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Para comprender por qu√© estas variables miembro causan problemas, ser√° √∫til comprender c√≥mo se representan las mallas triangulares en pbrt.  Primero, est√° la clase <code>TriangleMesh</code> , que almacena los v√©rtices y los b√∫feres de √≠ndice para toda la malla: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Cada tri√°ngulo en la malla est√° representado por la clase <code>Triangle</code> , que hereda de <code>Shape</code> .  La idea es mantener el <code>Triangle</code> m√°s peque√±o posible: solo almacenan un puntero a la malla de la que forman parte, y un puntero al desplazamiento en el b√∫fer de √≠ndice en el que comienzan los √≠ndices de sus v√©rtices: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Cuando las implementaciones de <code>Triangle</code> necesitan encontrar las posiciones de sus v√©rtices, realiza la indexaci√≥n correspondiente para obtenerlas de <code>TriangleMesh</code> . <br><br>  El problema con <code>Shape</code> pbrt-v3 es que los valores almacenados en √©l son los mismos para todos los tri√°ngulos de la malla, por lo que es mejor guardarlos de cada malla completa en <code>TriangleMesh</code> , y luego dar a <code>Triangle</code> acceso a una sola copia de los valores comunes. <br><br>  Este problema se solucion√≥ en pbrt-next: la clase <code>Shape</code> b√°sica en pbrt-next no contiene dichos miembros y, por lo tanto, cada <code>Triangle</code> tiene 24 bytes menos.  La <code>Curve</code> geometr√≠a utiliza una estrategia similar y tambi√©n se beneficia de una forma m√°s compacta. <br><br><h2>  Tampones de tri√°ngulo compartido </h2><br>  A pesar del hecho de que la escena de la isla de <em>Moana hace</em> un uso extensivo de la creaci√≥n de instancias de objetos para repetir la geometr√≠a expl√≠citamente, ten√≠a curiosidad por la frecuencia con la que se utilizan la reutilizaci√≥n de los b√∫feres de √≠ndice, los b√∫feres de coordenadas de textura, etc. para varias mallas triangulares. <br><br>  Escrib√≠ una peque√±a clase que procesa estos b√∫feres al recibirlos y los almacena en el cach√©, y modifiqu√© <code>TriangleMesh</code> para que verifique el cach√© y use la versi√≥n ya guardada de cualquier b√∫fer redundante que necesite.  La ganancia fue muy buena: logr√© deshacerme de 4.7 GB de exceso de volumen, que es mucho m√°s de lo que esperaba. <br><br><h2>  Bloqueo con std :: shared_ptr </h2><br>  Despu√©s de todos estos cambios, las estad√≠sticas informan sobre 36 GB de memoria asignada conocida y, al comienzo de la representaci√≥n, la <code>top</code> indica el uso de 53 GB.  Asuntos <br><br>  Ten√≠a miedo de otra serie de corridas lentas de <code>massif</code> para descubrir qu√© memoria asignada falta en las estad√≠sticas, pero luego apareci√≥ una carta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arseny Kapulkin</a> en mi bandeja de entrada.  Arseny me explic√≥ que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mis estimaciones anteriores</a> del uso de la memoria <code>GeometricPrimitive</code> estaban muy equivocadas.  Tuve que resolverlo durante mucho tiempo, pero luego me di cuenta;  Muchas gracias a Arseny por se√±alar el error y explicaciones detalladas. <br><br>  Antes de escribir a Arseny, imagin√© la implementaci√≥n de <code>std::shared_ptr</code> siguiente manera: en estas l√≠neas hay un descriptor com√∫n que almacena el recuento de referencias y un puntero al propio objeto colocado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Luego suger√≠ que la instancia <code>shared_ptr</code> solo lo se√±ala y lo usa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  En resumen, supuse que <code>sizeof(shared_ptr&lt;&gt;)</code> es el mismo que el tama√±o del puntero y que se desperdician 16 bytes de espacio adicional en cada puntero compartido. <br><br>  Pero esto no es as√≠. <br><br>  En la implementaci√≥n de mi sistema, el descriptor com√∫n tiene un tama√±o de 32 bytes y un tama√±o de 16 bytes <code>sizeof(shared_ptr&lt;&gt;)</code> .  Por lo tanto, <code>GeometricPrimitive</code> , que consiste principalmente en <code>std::shared_ptr</code> , es aproximadamente el doble de mis estimaciones.  Si se pregunta por qu√© sucedi√≥ esto, estas dos publicaciones de Stack Overflow explican las razones con gran detalle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> . <br><br>  En casi todos los casos de uso de <code>std::shared_ptr</code> en pbrt-next, no es necesario que compartan punteros.  Mientras hac√≠a un pirateo loco, reemplac√© todo lo que pude con <code>std::unique_ptr</code> , que en realidad tiene el mismo tama√±o que un puntero normal.  Por ejemplo, as√≠ es <code>SimplePrimitive</code> ve <code>SimplePrimitive</code> ahora: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  La recompensa result√≥ ser mayor de lo que esperaba: el uso de memoria al comienzo de la representaci√≥n disminuy√≥ de 53 GB a 41 GB, un ahorro de 12 GB, completamente inesperado hace unos d√≠as, y el volumen total es casi la mitad del utilizado por pbrt-v3.  Genial <br><br>  En la siguiente parte, finalmente completaremos esta serie de art√≠culos: examine la velocidad de representaci√≥n en pbrt-next y discuta ideas para otras formas de reducir la cantidad de memoria necesaria para esta escena. <br><br><h2>  Parte 5 </h2><br>  Para resumir esta serie de art√≠culos, comenzaremos explorando la velocidad de representaci√≥n de la escena de la isla de la caricatura de Disney <em>"Moana"</em> en pbrt-next, la rama pbrt que uso para probar nuevas ideas.  Haremos cambios m√°s radicales de lo que es posible en pbrt-v3, que deber√≠a adherirse al sistema descrito en nuestro libro.  Concluimos con una discusi√≥n de √°reas para mejoras adicionales, desde la m√°s simple hasta la m√°s extrema. <br><br><h2>  Tiempo de renderizado </h2><br>  Pbrt-next realiz√≥ muchos cambios en los algoritmos de transferencia de luz, incluidos cambios en el muestreo BSDF y mejoras en los algoritmos de ruleta rusa.  Como resultado, traza m√°s rayos que pbrt-v3 para renderizar esta escena, por lo que no es posible comparar directamente el tiempo de ejecuci√≥n de estos dos renderizadores.  La velocidad generalmente es cercana, con una excepci√≥n importante: cuando se representa una escena de isla desde <em>Moana</em> , como se muestra a continuaci√≥n, pbrt-v3 gasta el 14.5% del tiempo de ejecuci√≥n buscando texturas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ptex</a> .  Esto sol√≠a parecer bastante normal para m√≠, pero pbrt-next solo gasta el 2.2% del tiempo de ejecuci√≥n.  Todo esto es terriblemente interesante. <br><br>  Despu√©s de estudiar las estad√≠sticas, obtenemos <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Como vemos en pbrt-v3, la textura de ptex se lee del disco en promedio cada 34 b√∫squedas de textura.  En pbrt-next, se lee solo despu√©s de cada 244 b√∫squedas, es decir, la E / S de disco ha disminuido aproximadamente 7 veces.  Suger√≠ que esto sucede porque pbrt-next calcula las diferencias de rayos para los rayos indirectos, y esto conduce al acceso a niveles m√°s altos de texturas MIP, lo que a su vez crea una serie m√°s integrada de accesos al cach√© de texturas ptex, reduce el n√∫mero de errores de cach√© y, por lo tanto, el n√∫mero de operaciones de E / S <sup>2</sup> .  Una breve comprobaci√≥n confirm√≥ mi suposici√≥n: cuando se apag√≥ la diferencia del haz, la velocidad de ptex empeor√≥. <br><br>  El aumento en la velocidad de ptex no solo ha afectado el costo de la computaci√≥n y las E / S.  En un sistema de 32 CPU, pbrt-v3 solo aceler√≥ 14.9 veces despu√©s de analizar la descripci√≥n de la escena.  pbrt generalmente muestra una escala paralela lineal, por lo que me decepcion√≥ bastante.  Debido al n√∫mero mucho menor de conflictos durante los bloqueos en ptex, la versi√≥n pbrt-next fue 29.2 veces m√°s r√°pida en un sistema con 32 CPU y 94.9 veces m√°s r√°pida en un sistema con 96 CPU: volvemos a los indicadores que nos convienen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Ra√≠ces de la escena de la isla Moana representada por pbrt con una resoluci√≥n de 2048x858 a 256 muestras por p√≠xel.</i>  <i>El tiempo total de representaci√≥n en una instancia de Google Compute Engine con 96 CPU virtuales con una frecuencia de 2 GHz en pbrt-next es de 41 min 22 s.</i>  <i>La aceleraci√≥n debido al mulithreading durante el renderizado fue 94.9 veces.</i>  <i>(No entiendo muy bien qu√© est√° sucediendo con el mapeo de relieve).</i> <br><br><h2>  Trabajar para el futuro </h2><br>  Disminuir la cantidad de memoria utilizada en escenas tan complejas es una experiencia emocionante: guardar unos pocos gigabytes con un peque√±o cambio es mucho m√°s agradable que decenas de megabytes guardados en una escena m√°s simple.  Tengo una buena lista de lo que espero aprender en el futuro, si el tiempo lo permite.  Aqu√≠ hay un resumen r√°pido. <br><br><h3>  Disminuci√≥n adicional de la memoria intermedia del tri√°ngulo </h3><br>  Incluso con el uso repetido de buffers que almacenan los mismos valores para varias mallas triangulares, todav√≠a se usa mucha memoria debajo de los buffers triangulares.  Aqu√≠ hay un desglose del uso de memoria para varios tipos de buffers triangulares en la escena: <br><br><table><thead><tr><th>  Tipo </th><th>  El recuerdo </th></tr></thead><tbody><tr><td>  L√≠neas de pedido </td><td>  2,5 GB </td></tr><tr><td>  Normal </td><td>  2,5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  √çndices </td><td>  252 MB </td></tr></tbody></table><br>  Entiendo que no se puede hacer nada con las posiciones de v√©rtice transmitidas, pero para otros datos hay ahorros.  Hay muchos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de representaciones de vectores normales en una forma de memoria eficiente</a> que proporciona varias compensaciones entre el tama√±o de la memoria / n√∫mero de c√°lculos.  El uso de una de las representaciones de 24 o 32 bits reducir√° el espacio ocupado por las normales a 663 MB y 864 MB, lo que nos ahorrar√° m√°s de 1.5 GB de RAM. <br><br>  En esta escena, la cantidad de memoria utilizada para almacenar coordenadas de textura y b√∫feres de √≠ndice es sorprendentemente peque√±a.  Supongo que esto sucedi√≥ debido a la presencia de muchas plantas generadas por procedimientos en la escena y al hecho de que todas las variaciones del mismo tipo de planta tienen la misma topolog√≠a (y, por lo tanto, el b√∫fer de √≠ndice) con la parametrizaci√≥n (y, por lo tanto, las coordenadas UV).  A su vez, reutilizar buffers coincidentes es bastante eficiente. <br><br>  Para otras escenas, el muestreo de coordenadas UV de texturas de 16 bits o el uso de valores flotantes de media precisi√≥n, dependiendo de su rango de valores, puede ser bastante adecuado.  Parece que en esta escena, todos los valores de coordenadas de textura son cero o uno, lo que significa que pueden representarse por un <em>bit</em> , es decir, es posible reducir la memoria ocupada 32 veces.  Este estado de cosas probablemente surgi√≥ debido al uso del formato ptex para texturizar, lo que elimina la necesidad de atlas UV.  Dada la peque√±a cantidad actualmente ocupada por las coordenadas de textura, la implementaci√≥n de esta optimizaci√≥n no es particularmente necesaria. <br><br>  pbrt siempre usa enteros de 32 bits para los b√∫feres de √≠ndice.  Para mallas peque√±as de menos de 256 v√©rtices, solo son suficientes 8 bits por √≠ndice, y para mallas de menos de 65,536 v√©rtices, se pueden usar 16 bits.  Cambiar pbrt para adaptarlo a este formato no ser√° muy dif√≠cil.  Si quisi√©ramos optimizar al m√°ximo, podr√≠amos seleccionar exactamente tantos bits como sea necesario para representar el rango requerido en los √≠ndices, mientras que el precio ser√≠a aumentar la complejidad de encontrar sus valores.  A pesar de que ahora solo se usa un cuarto de gigabyte de memoria para los √≠ndices de v√©rtice, esta tarea no parece muy interesante en comparaci√≥n con otras. <br><br><h3>  Uso pico de memoria de compilaci√≥n BVH </h3><br>  Anteriormente, no discutimos otro detalle del uso de la memoria: inmediatamente antes del renderizado, se produce un pico a corto plazo de 10 GB de memoria adicionalmente utilizada.  Esto sucede cuando se construye el BVH (grande) de toda la escena.  El c√≥digo para construir el BVH del renderizador pbrt est√° escrito para ejecutarse en dos fases: primero, crea un BVH con la <a href="">representaci√≥n tradicional</a> : dos punteros secundarios a cada nodo.  Despu√©s de construir el √°rbol, se convierte en <a href="">un esquema de memoria eficiente</a> en el que el primer hijo del nodo se encuentra directamente detr√°s de √©l en la memoria, y el desplazamiento al segundo hijo se almacena como un entero. <br><br>  Tal separaci√≥n era necesaria desde el punto de vista de la ense√±anza de los estudiantes: era mucho m√°s f√°cil comprender los algoritmos para construir BVH sin el caos asociado con la necesidad de convertir el √°rbol en una forma compacta durante el proceso de construcci√≥n.  Sin embargo, el resultado es este pico en el uso de memoria;  Teniendo en cuenta su influencia en la escena, la eliminaci√≥n de este problema parece atractiva. <br><br><h3>  Convertir punteros a enteros </h3><br>  En varias estructuras de datos, hay muchos punteros de 64 bits que se pueden representar como enteros de 32 bits.  Por ejemplo, cada <code>SimplePrimitive</code> contiene un puntero a un <code>Material</code> .  La mayor√≠a de las instancias de <code>Material</code> son comunes a muchos primitivos en la escena y nunca hay m√°s de unos pocos miles;  por lo tanto, podemos almacenar un √∫nico vector <code>vector</code> global <code>vector</code> todos los materiales: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  y simplemente almacene compensaciones de enteros de 32 bits para este vector en <code>SimplePrimitive</code> , lo que nos ahorra 4 bytes.  El mismo truco se puede usar con un puntero a <code>TriangleMesh</code> en cada <code>Triangle</code> , as√≠ como en muchos otros lugares. <br><br>  Despu√©s de tal cambio, habr√° una ligera redundancia en el acceso a los signos en s√≠ mismos, y el sistema ser√° un poco menos comprensible para los estudiantes que intenten comprender su trabajo;  Adem√°s, este es probablemente el caso cuando, en el contexto de pbrt, es mejor mantener la implementaci√≥n un poco m√°s comprensible, aunque a costa de una optimizaci√≥n incompleta del uso de la memoria. <br><br><h3>  Alojamiento basado en arenas (√°reas) </h3><br>  Para cada <code>Triangle</code> individual y primitivo, se realiza una llamada separada a <code>new</code> (en realidad, <code>make_unique</code> , pero esto es lo mismo).  Dichas asignaciones de memoria conducen al uso de contabilidad de recursos adicionales, que ocupan unos cinco gigabytes de memoria, no contabilizados en las estad√≠sticas.  Dado que la vida √∫til de todas estas ubicaciones es la misma, hasta que se complete el renderizado, podemos deshacernos de esta contabilidad adicional seleccion√°ndolas del <a href="">campo</a> de la <a href="">memoria</a> . <br><br><h3>  Vtable caqui </h3><br>  Mi √∫ltima idea es terrible, y me disculpo por ello, pero ella me intrig√≥. <br><br>  Cada tri√°ngulo en la escena tiene una carga adicional de al menos dos punteros vtable: uno para <code>Triangle</code> y otro para <code>SimplePrimitive</code> .  Esto es de 16 bytes.  La escena de la isla de <em>Moana</em> tiene un total de 146 162 124 tri√°ngulos √∫nicos, que agrega casi 2.2 GB de punteros vtable redundantes. <br><br>  ¬øQu√© pasar√≠a si no tuvi√©ramos una clase base abstracta para <code>Shape</code> y cada implementaci√≥n de geometr√≠a no heredara de nada?  Esto nos ahorrar√≠a espacio en punteros vtable, pero, por supuesto, al pasar un puntero a una geometr√≠a, no sabr√≠amos qu√© tipo de geometr√≠a es, es decir, ser√≠a in√∫til. <br><br>  Resulta que en las CPU modernas x86 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, solo</a> se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilizan 48 bits de punteros de 64 bits</a> .  Por lo tanto, hay 16 bits adicionales que podemos pedir prestados para almacenar informaci√≥n ... por ejemplo, como la geometr√≠a a la que apuntamos.  A su vez, agregando un poco de trabajo, podemos regresar a la posibilidad de crear un an√°logo de llamadas a funciones virtuales. <br><br>  As√≠ es como suceder√°: primero definimos una estructura <code>ShapeMethods</code> que contiene punteros a funciones, como <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Cada implementaci√≥n de geometr√≠a implementar√° una funci√≥n de restricci√≥n, una funci√≥n de intersecci√≥n, y as√≠ sucesivamente, recibiendo un an√°logo del puntero <code>this</code> como primer argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Tendr√≠amos una tabla global de estructuras <code>ShapeMethods</code> en la que el <em>en√©simo</em> elemento ser√≠a para un tipo de geometr√≠a con √≠ndice <em>n</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Al crear geometr√≠a, codificamos su tipo en algunos de los bits no utilizados del puntero de retorno.  Luego, teniendo en cuenta el puntero a la geometr√≠a cuya llamada espec√≠fica queremos realizar, extraer√≠amos este √≠ndice de tipo del puntero y lo <code>shapeMethods</code> como √≠ndice en <code>shapeMethods</code> para encontrar el puntero de funci√≥n correspondiente.  Esencialmente, implementar√≠amos vtable manualmente, procesando el despacho nosotros mismos.  Si hici√©ramos esto tanto para la geometr√≠a como para las primitivas, ahorrar√≠amos 16 bytes por <code>Triangle</code> , pero al mismo tiempo lo hicimos de una manera bastante dif√≠cil. <br><br>  Supongo que tal truco para implementar la administraci√≥n de funciones virtuales no es nuevo, pero no pude encontrar enlaces a √©l en Internet.  Aqu√≠ est√° la p√°gina de Wikipedia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">punteros etiquetados</a> , pero analiza cosas como el conteo de enlaces.  Si conoce un enlace mejor, env√≠eme una carta. <br><br>  Al compartir este truco inc√≥modo, puedo terminar la serie de publicaciones.  Nuevamente, muchas gracias a Disney por publicar esta escena.  Fue incre√≠blemente divertido trabajar con √©l;  los engranajes en mi cabeza siguen girando. <br><br><h2>  Notas </h2><br><ol><li>  Al final, pbrt-next traza m√°s rayos en esta escena que pbrt-v3, lo que probablemente explica el aumento en el n√∫mero de operaciones de b√∫squeda. </li><li>  Las diferencias de rayos para los rayos indirectos en pbrt-next se calculan utilizando el mismo <a href="">truco</a> utilizado en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensi√≥n de cach√© de textura</a> para pbrt-v3. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417939/">https://habr.com/ru/post/es417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417929/index.html">Extracto del libro "Un d√≠a en la vida del cerebro. Neurobiolog√≠a de la conciencia desde el amanecer hasta el anochecer "</a></li>
<li><a href="../es417931/index.html">T√©cnicas de retenci√≥n de jugadores: ejemplos de juegos de diferentes g√©neros</a></li>
<li><a href="../es417933/index.html">Semana de la seguridad 27: iPhone falso y precio de seguridad</a></li>
<li><a href="../es417935/index.html">Notas sobre inteligencia artificial, aprendizaje autom√°tico, aprendizaje profundo y Big Data</a></li>
<li><a href="../es417937/index.html">¬øEst√°n las personas "de hierro" haciendo software?</a></li>
<li><a href="../es417941/index.html">¬øD√≥nde desaparece el agua en la tetera?</a></li>
<li><a href="../es417943/index.html">Sin servidor y React 2: juego de manos y sin fraude</a></li>
<li><a href="../es417945/index.html">¬øQu√© herramientas tiene la sonda solar Parker?</a></li>
<li><a href="../es417947/index.html">Visualizaci√≥n de datos para su proyecto web.</a></li>
<li><a href="../es417949/index.html">¬øC√≥mo escrib√≠ la biblioteca est√°ndar de C ++ 11 o por qu√© boost es tan aterrador? Cap√≠tulo 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>