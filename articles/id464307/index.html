<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 🐳 🛴 Pengujian integrasi layanan microser di Scala 🌪️ ⚕️ ♏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengujian unit memang bagus, tetapi tidak cukup. Seringkali Anda ingin memastikan bahwa aplikasi yang berjalan juga berfungsi. Tes integrasi datang un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian integrasi layanan microser di Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Pengujian unit memang bagus, tetapi tidak cukup.  Seringkali Anda ingin memastikan bahwa aplikasi yang berjalan juga berfungsi.  Tes integrasi datang untuk menyelamatkan.  Ini semakin banyak digunakan untuk menguji layanan, dan Docker memungkinkan Anda untuk mengelola lingkungan pengujian Anda dengan mudah.  Tetapi, seperti biasa, segala sesuatunya tidak sesederhana itu ketika ada lebih banyak layanan dan ketergantungan microser. <br><br>  Yuri Badalyants di RIT ++ memberi tahu bagaimana di 2GIS mereka menguji banyak layanan dan kebun binatang teknologi secara keseluruhan.  Di bawah potongan, versi laporan ini ditambahkan dan diperbarui di bawah pengawasan yang cermat dari pembicara: opsi apa yang telah Anda coba, apa yang Anda lakukan, masalah apa yang tidak harus Anda selesaikan sekarang.  Ini akan tentang Docker, Testcontainers, dan juga tentang Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LMnet</a> ) memulai karirnya pada tahun 2011 sebagai pengembang web, bekerja dengan PHP, JavaScript dan Java.  Sekarang dia menulis di Scala di 2GIS. <br><br><h2>  Kasino </h2><br>  2GIS telah menyediakan peta kota dan direktori perusahaan yang nyaman selama 20 tahun, dan baru-baru ini kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi baru</a> dengan peta Rusia tanpa batas.  Saya akan memberi tahu Anda tentang pengalaman yang didapat saat saya bekerja di tim Kasino.  Tim ini terlibat dalam tiga bidang utama: <br><br><ul><li>  Iklan - pengiklan mana yang akan ditampilkan, yang disembunyikan, yang dinaikkan dan cara menurunkan peringkat. </li></ul><br><ul><li>  BigData terkait dengan periklanan dan personalisasi, serta pembuatan analisis dan metrik. </li><li>  Crawler adalah program yang mencari organisasi di Internet untuk secara otomatis menambahkannya ke database. </li></ul><br>  Ketiga area ini adalah tugas utama, yang, pada gilirannya, memiliki sejumlah besar subtugas.  Saat ini, ada lebih dari 25 microservices yang ditulis dalam Scala.  Ini hanya kode kami, tetapi kami juga menggunakan sistem pihak ketiga, seperti PostgreSQL, Cassandra dan Kafka.  Kami menyimpan data di Hadoop dan memprosesnya di Spark.  Selain itu, kami menggunakan metode pembelajaran mesin yang disediakan oleh tim Ilmu Data. <br><br>  Akibatnya, kami memiliki sejumlah besar layanan dan layanan mikro, sejumlah besar dependensi, dan, tentu saja, semua ini perlu diuji dalam beberapa cara. <br><br>  Tentu saja, kami menulis unit test.  Namun, bahkan jika semua tes berwarna hijau, ini tidak berarti semuanya bekerja.  Sesuatu mungkin salah selama fase integrasi komponen atau layanan Microsoft.  Oleh karena itu, kami menulis tes integrasi. <br><br><h2>  Tes integrasi </h2><br>  Setiap layanan mikro yang dikembangkan oleh tim Kasino menyelesaikan masalah bisnisnya dan terletak di repositori terpisah di GitLab.  Artikel ini akan fokus pada pengujian integrasi dalam satu repositori (microservice) dengan dependensi yang dikunci, yang merupakan tanggung jawab pengembang sendiri.  Tim QA sedang menguji interaksi layanan mikro, dan saya tidak akan menyentuh topik ini. <br><br>  Ketika saya pertama kali bergabung dengan tim, pada akhir 2016, ada sekitar skema tes integrasi berikut: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  Pengembang mendorong kode-nya di GIT, setelah itu kode microservice masuk ke TeamCity.  TeamCity mulai membuat kode dan menjalankan tes. </li><li>  TeamCity mengambil file konfigurasi (config) dari Chef (sistem manajemen konfigurasi yang mirip dengan Ansible, hanya ditulis dalam Ruby).  Chef juga berfungsi untuk mengotomatiskan penyebaran.  Ketika saya memiliki 100 mesin, saya tidak ingin pergi ke masing-masing dan menginstal apa yang saya butuhkan di SSH, dan Chef memungkinkan saya untuk mengotomatisasi ini. </li><li>  TeamCity mengumpulkan file jar (karena kami menulis di Scala, artefak yang kami terbitkan adalah jar), maka program memuatnya ke lingkungan CI.  Aplikasi kami ditempatkan di sana, ada juga beberapa dependensi.  Dalam diagram, salah satu dependensi digambarkan sebagai basis data.  Mungkin ada banyak ketergantungan seperti itu, dan terima kasih kepada Chef, aplikasi kita tahu tentang mereka dan mulai berinteraksi dengan mereka. </li><li>  Selanjutnya, TeamCity meluncurkan <strong>SBT</strong> (ini adalah sistem build kami, tempat kompilasi dan tes dijalankan) dan menjalankan tes sendiri.  Mereka relatif mirip dengan tes unit, tetapi mereka bekerja terutama pada prinsip ini: pergi melalui http ke alamat tertentu, periksa beberapa metode dan lihat apa yang dikembalikan;  atau melakukan persiapan, dan kemudian melihat apakah yang dibutuhkan telah kembali. </li></ol><br>  <strong>Apa yang bisa dikatakan tentang skema seperti itu?</strong>  Yang terpenting, ini berhasil.  Ketika semuanya sudah diatur, menjalankan tes mudah, karena terlihat seperti tes unit.  Namun plus berakhir di sana. <br><br>  Dan kontra mulai.  <strong>Lingkungan CI selalu hidup</strong> , dan ini merupakan pemborosan sumber daya tambahan.  Karena Chef adalah konfigurasi statis, Anda harus selalu memiliki beberapa jenis mesin di mana semua dependensi akan dikonfigurasikan, di mana aplikasi akan digunakan secara independen.  Mesin seperti itu akan menghabiskan sumber daya tambahan, karena pengujian dijalankan dari waktu ke waktu, dan mesin harus siap setiap saat.  Selain itu, lingkungan CI disertakan dengan semua dependensi. <br><br>  <strong>Tidak mungkin menjalankan tes pada dua cabang secara bersamaan</strong> .  Ini mengikuti dari paragraf sebelumnya: karena kita memiliki satu lingkungan, kita tidak bisa menjalankannya secara paralel. <br><br>  <strong>Tes, start, stop, dan restart tidak mungkin dilakukan</strong> .  Saya akan menjelaskan mengapa ini perlu: semua aplikasi kita mematuhi logika yang disebut <strong>anggun shutdown</strong> , yaitu, ketika kita mendapatkan SIGTERM, kita tidak menghentikan proses di tengah, tetapi mencegat sinyal ini dan memahami bahwa kita perlu mematikan program.  Pada titik ini, logika tertentu dihidupkan, misalnya, permintaan HTTP yang sedang "dalam penerbangan" diproses, atau jika kami bekerja dengan Kafka, kami melakukan semua kesalahan - dengan kata lain, kami melakukan tindakan tertentu sehingga kami dapat menyelesaikan pekerjaan dengan aman, dan lalu, ketika semuanya dilakukan, matikan. <br><br>  Logika ini tidak selalu sederhana, dan Anda dapat mengujinya dengan skema seperti itu hanya secara manual, karena dari tes kami tidak mengontrol siklus hidup aplikasi.  Ternyata TeamCity entah bagaimana telah menyebarkan sesuatu melalui Chef, sementara pengujiannya berada pada tahap yang berbeda dan tidak tahu bagaimana aplikasi tersebut digunakan. <br><br>  Minus berikutnya adalah sangat <strong>sulit untuk mengkonfigurasi semua ini secara lokal</strong> .  Artinya, ada banyak dependensi, mereka memiliki konfigurasi sendiri, mereka perlu dinaikkan pada mesin lokal.  Aplikasi itu sendiri juga memiliki file konfigurasi sendiri, di mana ada banyak nilai.  Tes itu sendiri memiliki konfigurasi yang perlu dicocokkan dengan konfigurasi aplikasi, dan mungkin juga ada lebih dari satu nilai konfigurasi.  Tampaknya semua ini tidak terdengar menakutkan, seperti "pergi dan perbaiki konfigurasi di tiga tempat", tetapi dalam kenyataannya mungkin diperlukan berjam-jam bagi karyawan baru untuk melakukan ini. <br><br><h3>  GitLab CI + Docker </h3><br>  Seiring waktu, skema ini telah berubah menjadi yang lain: <strong>GitLab CI</strong> dan <strong>Docker</strong> .  Ini tidak terjadi karena skema sebelumnya tidak ideal, tetapi karena perusahaan sedikit mengubah arah dalam hal administrasi organisasi. <br><br>  Sebelumnya, masing-masing tim, dan kami memiliki banyak dari mereka, seperti yang kami inginkan atau bagaimana kami bisa, dan mengerahkan pekerjaannya.  Misalnya, kami memiliki TeamCity, Chef, dan tim lain yang bisa menggunakan Jenkins atau Ansible. <br><br>  Sekarang kami bergerak menuju cloud lokal dan Kubernetes, dan ada tim terpisah yang mengelola semua ini, baik GitLab CI dan Kubernetes.  Tim lain hanya menggunakan ini sebagai layanan.  Ini jauh lebih nyaman karena Anda tidak perlu mengelola semua ini secara manual. <br><br>  Menggunakan Kubernetes, kami menerapkan skema berikut: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  Alih-alih TeamCity, Gitlab CI sekarang digunakan. </li><li>  GitLab CI membuat gambar buruh pelabuhan dan menyebarkannya ke Kubernetes.  Konfigurasi sekarang disimpan langsung di repositori, dan tidak secara terpisah di Chef, jadi untuk penyebaran Anda tidak perlu bekerja dengan layanan konfigurasi pihak ketiga. </li><li>  Ketergantungan meningkat di muka, juga di Kubernetes. </li><li>  Kemudian GitLab CI meluncurkan SBT dan menguji dalam langkah terpisah. </li></ol><br>  Semuanya sangat mirip dengan skema sebelumnya dan pada dasarnya tidak berbeda dari itu, yaitu, bahkan pro dan kontra akan persis sama, tetapi Docker muncul. <br><br>  Dengan buruh pelabuhan, Anda dapat melakukan lebih banyak hal menyenangkan yang berbeda dan salah satunya adalah pembuatan docker. <br><br><h3>  Susunan docker </h3><br>  Ini adalah semacam "overlay" pada Docker, yang memungkinkan Anda untuk menjalankan beberapa gambar docker sebagai satu kesatuan. <br><br>  Contoh yang bagus di mana komposisi buruh pelabuhan sangat membantu adalah Kafka.  Dia membutuhkan ZooKeeper untuk berlari.  Jika Anda mengangkat Kafka dan ZooKeeper tanpa membuat docker, maka Anda perlu menaikkan ZooKeeper secara terpisah di docker, secara terpisah - Kafka, dan menjaga agar kedua wadah buruh pelabuhan ini konsisten.  Ini sangat tidak nyaman, dan menulis buruh pelabuhan memungkinkan Anda untuk mendeskripsikan kedua wadah dalam satu file buruh pelabuhan-menulis.yml dan menggunakan perintah <code>docker-compose run Kafka</code> sederhana <code>docker-compose run Kafka</code> meningkatkan Kafka dan ZooKeeper. <br><br>  Anda dapat membuat tes integrasi pada komposisi buruh pelabuhan.  Mari kita lihat bagaimana tampilannya. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Sekali lagi, dorong semuanya di GitLab. </li><li>  GitLab CI meluncurkan docker-compose. </li><li>  Dalam menulis docker, aplikasi naik, semua dependensi dan SBT naik, dan SBT mendorong tes untuk aplikasi ini - semuanya terjadi di dalam penulisan docker. </li></ol><br>  Berkat skema ini, tidak perlu lagi menjaga lingkungan dan dependensi yang terpisah, karena semuanya berjalan langsung ke runner GitLab CI, di mana buruh pelabuhan dan pembuat komposisi harus berada.  Selama awal, dia akan memompa gambar yang diperlukan dan menjalankannya. <br><br>  Selain itu, Anda dapat menguji cabang yang berbeda secara bersamaan, karena semuanya terjadi pada pelari. <br><br>  Sekarang <strong>lebih mudah untuk mengkonfigurasi</strong> lingkungan <strong>secara lokal</strong> , tetapi Anda masih perlu mengoordinasikan beberapa tempat.  Intinya adalah bahwa sekarang, ketika kita melakukan konfigurasi lokal, kita tidak perlu meletakkan semuanya pada mesin lokal, semuanya ditulis dalam file docker-compose.yml.  Jadi, Anda harus mengonfigurasi di dua tempat yang berbeda - ini adalah docker-compose.yml dan konfigurasi pengujian kami. <br><br>  Sedangkan untuk minusnya, <strong>masih tidak mungkin untuk menguji mulai, berhenti dan mulai ulang</strong> , karena dari SBT, dari tes, kami tidak mengontrol siklus hidup aplikasi.  Itu dijalankan oleh buruh pelabuhan-menulis, itu menjalankan SBT dan tes dijalankan di dalam SBT.  Dengan demikian, tidak ada manajemen siklus hidup aplikasi yang lengkap.  Ada juga kesulitan dengan peluncuran, yang ingin saya bicarakan lebih banyak. <br><br><h4>  docker-compose 2 </h4><br>  Pada zaman docker-compose 2, docker-compose.yml file tersebut terlihat seperti ini: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Layanan terdaftar di sini, yaitu, apa yang akan kami tingkatkan sebagai bagian dari komposisi buruh pelabuhan ini.  Dalam hal ini, saya baru saja mengambil contoh dari dokumentasi docker-compose.  Ada tiga layanan: web, redis, dan db (database). <br><br>  Web adalah aplikasi kita, dan redis dan db adalah semacam dependensi. <br><br>  Ada item di blok web yang disebut <code>depends_on</code> .  Ini menunjukkan bahwa aplikasi web tergantung pada beberapa wadah lain, dan dijelaskan di bawah ini: dari database dan redis. <br><br>  Juga, ada klausa <code>condition</code> .  Untuk redis, ini adalah <code>service_started</code> , yang berarti bahwa sampai redis dimulai, kontainer tidak akan mencoba untuk memulai aplikasi web. <br><br>  Sedangkan untuk database, kondisinya adalah <code>service_healthy</code> , dan pemeriksaan kesehatan dijelaskan di bawah ini.  Artinya, kita tidak hanya perlu meluncurkan wadah buruh pelabuhan, tetapi juga untuk melakukan pemeriksaan kesehatan tertentu.  Ini bisa berupa logika khusus. <br><br>  Sebagai contoh, kami menggunakan PostgreSQL, yang menggunakan ekstensi PostGIS, dan perlu beberapa saat untuk menginisialisasi.  Ketika kami meluncurkan wadah buruh pelabuhan, kami tidak dapat segera bekerja dengan ekstensi postgis - kami harus menunggu ekstensi untuk menginisialisasi.  Karenanya, kami hanya <code>SELECT PostGIS_Version();</code> kueri <code>SELECT PostGIS_Version();</code> ke <code>SELECT PostGIS_Version();</code>  .  Sampai ekstensi diinisialisasi, permintaan akan melempar kesalahan, dan ketika ekstensi diinisialisasi, itu akan mulai mengembalikan versi.  Ini sangat mudah dan logis - <strong>pertama kita akan meningkatkan semua dependensi, dan kemudian aplikasi</strong> . <br><br><h4>  docker-compose 3 </h4><br>  Ketika docker-compose 3 keluar, kami mulai menggunakannya. <br><br>  Tetapi dalam dokumentasi untuk itu, item muncul pada perubahan logika depend_on.  Pengembang buruh pelabuhan memutuskan bahwa deskripsi grafik ketergantungan sudah cukup.  Ini berarti bahwa ketika Anda memulai <code>docker-compose run web</code> , baik aplikasi itu sendiri dan db di mana itu tergantung akan mulai secara bersamaan. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  Paragraf berikutnya dalam dokumentasi mengatakan bahwa depend_on tidak lagi merupakan kondisi. <br><br>  Jadi, jika Anda masih ingin mendapatkan fungsionalitas yang digunakan dalam versi kedua, Anda harus mengambil semuanya ke tangan Anda sendiri. <br><br>  Halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengontrol startup order</a> menawarkan beberapa solusi.  Opsi pertama adalah menggunakan <strong>wait-for-it.sh</strong> . <br><br>  Sekarang docker-compose.yml terlihat sedikit berbeda: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> hanyalah sebuah array, tidak ada ketentuan. <br><br>  Dalam dependensi kami, kami mendefinisikan kembali perintah, yaitu, dalam penulisan buruh pelabuhan Anda dapat melampirkan perintah yang dimulai dengan wadah buruh pelabuhan. <br><br>  Di sana kita harus menulis wait-for-it.sh, dan yang lainnya.  Alih-alih tiga poin dalam contoh di atas, kita harus menulis apa yang perlu kita tunggu, serta perintah asli yang meluncurkan wadah buruh pelabuhan. <br><br>  Untuk melakukan ini, Anda perlu menemukan file buruh pelabuhan, salin perintah untuk redis dari sana dan tempel, hal yang sama berlaku untuk database.  Sebuah minus yang sangat besar adalah bahwa <strong>abstraksi rusak</strong> - saya tidak ingin tahu perintah mana yang meluncurkan wadah buruh pelabuhan.  Perintah-perintah ini bisa nontrivial, cukup rumit, tetapi saya tidak ingin repot, saya hanya ingin memasukkan <code>docker run</code> dan hanya itu. <br><br>  Saya pribadi tidak terlalu menyukai solusi ini, tetapi kami memiliki beberapa layanan yang berfungsi seperti ini. <br><br><h4>  Script di atas komposisi buruh pelabuhan </h4><br>  Kemudian saya memutuskan bahwa saatnya telah tiba untuk " <strong>membangun</strong> sepeda", dan saya memiliki <strong>buruh pelabuhan-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Biarkan saya memberi Anda contoh semi-realistis: ada postgres di docker-compose.yml, ada aplikasi my_service, yang tergantung pada postgres, dan SBT, di mana tes dijalankan dan yang tergantung pada layanan saya. <br><br>  Saya menjalankan program tidak melalui <code>docker run</code> , tetapi melalui script docker-compose-run.sh. <br><br>  Pertama, ia memulai ketergantungan yang paling dalam terlebih dahulu, dalam kasus saya ini adalah postgres.  Script memulai dependensi dalam mode "daemon", artinya, ia tidak memblokir terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  Lalu saya menunggu kondisi dipenuhi oleh fungsi wait_until.  Ini hampir sama dengan wait-for-it.sh, hanya untuk berbicara, dalam gaya imperatif.  Ketika PostGIS mulai, terminal diblokir, yaitu, program juga menunggu, dan jika tidak menunggu, kesalahan dilemparkan dan tes berhenti bekerja. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Ketika PostGIS diinisialisasi, lanjutkan ke langkah berikutnya dan lakukan hal yang sama dengan layanan.  Baginya, tesnya sedikit lebih sederhana: port 80 harus diikat. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  Langkah terakhir adalah menjalankan SBT melalui perintah run, di mana tes dijalankan. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Dengan demikian, semuanya dinaikkan dalam urutan yang benar, tetapi secara manual. <br><br>  Pada akhirnya, fungsi <code>down</code> disebut, yang menerima hasil dari perintah sebelumnya.  Jika "0", maka tes telah lulus, dan kami matikan saja docker-compose;  jika tidak, pertama-tama kita "meludahkan" log untuk mencari tahu apa yang salah, dan baru kemudian mematikan komposisi buruh pelabuhan. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Skema seperti itu berfungsi, tetapi tidak skalanya dengan baik.  Setiap layanan harus menggambarkan docker-compose-run.sh dengan logikanya sendiri.  Plus, konfigurasi peluncuran meluas antara docker-compose-run.sh dan docker-compose.yml.  Nah, secara umum, sepertinya kita tidak menggunakan docker-compose, tetapi berjuang dengan kekurangannya. <br><br><h4>  Menjalankan buruh pelabuhan dari kode </h4><br>  Ketika skema sebelumnya dibuat, saya berpikir: jika saya sudah memiliki semuanya di buruh pelabuhan, lalu mengapa tidak menjalankannya dari kode.  Saya mulai mencari solusi dan menemukan beberapa opsi. <br><br>  Opsi pertama adalah cukup <strong>menggunakan klien buruh pelabuhan</strong> .  Ada dua klien buruh pelabuhan utama di dunia JVM: <strong>buruh pelabuhan-java</strong> dan <strong>klien buruh pelabuhan</strong> . <br><br>  Klien buruh pelabuhan memungkinkan Anda untuk menjalankan perintah buruh pelabuhan langsung dari kode menggunakan API.  Artinya, alih-alih merangkai string untuk membangun perintah seperti <code>`docker run ...`</code> , Anda cukup membentuk perintah seperti itu dalam kode dan menjalankannya.  Itu jauh lebih nyaman. <br><br>  Metode ini bekerja dengan baik, dan, tentu saja, mereka dapat melakukan segalanya, namun, ini adalah level yang sangat rendah.  Saya harus membuat analog docker-compose saya sendiri, yang merupakan tugas yang sangat besar. <br><br>  Opsi berikutnya adalah <strong>pustaka docker-it-scala</strong> , yang membungkus kedua klien ini dan memungkinkan Anda untuk memilih backend yang akan digunakan.  Dia dapat menjalankan wadah yang Anda butuhkan. <br><br>  Tetapi kekurangan dari perpustakaan ini adalah bahwa ia tidak memiliki API yang sangat fleksibel dan tidak ada kontrol siklus hidup. <br><br>  Saya juga tidak menyukai opsi ini, saya terus mencari dan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Testcontainers</a> .  Saya ingin memberi tahu Anda lebih banyak tentang ini. <br><br><h2>  Wadah uji </h2><br>  Ini adalah semacam perpustakaan java untuk meluncurkan dan menguji kontainer buruh pelabuhan.  Ada fasad Scala, testcontainers-scala.  Di luar kotak, ada sejumlah layanan populer, misalnya, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Anda dapat menjalankan wadah lain.  Perpustakaan memiliki API yang cukup sederhana dan fleksibel, yang akan saya bahas lebih detail. <br><br><h3>  Wadah yang telah ditentukan </h3><br>  Jadi, bagaimana cara bekerja dengan wadah standar, yang ada di perpustakaan: sebenarnya, semuanya cukup sederhana, karena wadah direpresentasikan sebagai objek: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  Dalam hal ini, kita membuat <code>PostgreSQLContainer</code> , kita dapat memulainya dan mulai bekerja dengannya.  Selanjutnya, kita mendapatkan <code>jbdcUrl</code> , yang dengannya Anda dapat terhubung ke PostgreSQL.  Setelah itu kita <code>mappedPort</code> . <br><br>  Ini berarti PostgreSQL menonjol dari port docker 5432, dan Testcontainers melihat port ini dan secara otomatis menetapkan ke beberapa port acak.  Yaitu, dari tes yang kita lihat, misalnya, 32422. Tugas terjadi secara otomatis. <br><br><h3>  Wadah kustom </h3><br>  Tampilan berikut, yang disebut wadah kustom, juga cukup sederhana: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Ada <code>GenericContainer</code> tempat Anda perlu mewarisi dan menimpa sejumlah bidang.  Pastikan hanya mengatur <code>imageName</code> - ini adalah nama wadah yang ingin kita buat. <br><br>  Anda dapat mengatur <code>exposedPorts</code> : port yang akan ditampung wadah.  Di env, Anda dapat mengatur variabel lingkungan, Anda juga dapat mengatur <code>command</code> untuk dijalankan. <br><br>  <code>classpathResourceMapping</code> memungkinkan Anda untuk membuang sumber daya dari classpath ke dalam wadah buruh pelabuhan.  Ini sangat mudah, misalnya, jika konfigurasi aplikasi langsung pada sumber daya pengujian.  Anda cukup memetakan di dalam, dan aplikasi di dalam buruh pelabuhan mendapat akses ke konfigurasi ini. <br><br>  <code>waitStrategy</code> adalah hal yang sangat nyaman yang hilang di docker-compose 3, sebenarnya itu adalah HealthCheck.  Ada beberapa <code>waitStrategy</code> telah ditentukan, misalnya, Anda dapat menunggu sampai terjadi pengikatan port, atau metode http spesifik akan mengembalikan 200. Tetapi Anda dapat menulis HealthCheck Anda. <br><br>  Karena Anda menulis HealthCheck hanya dalam kode Anda, Anda dapat menggunakan, pertama, bahasa normal, bukan bash, dan, kedua, setiap perpustakaan yang tersedia dari kode Anda: jika Anda ingin membuat HealthCheck kustom di Cassandra - ambil driver dan tulis Periksa Kesehatan. <br><br><h3>  Menjalankan tes </h3><br>  Dan sekarang sedikit tentang cara menjalankan tes: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Saya akan berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ScalaTest</a> , standar de facto untuk pengujian di dunia Scala. <br><br>  Sebagai contoh, kami ingin menulis tes untuk Postgres.  Buat tes <code>PostgresqlSpec</code> dan mewarisinya dari <code>ForAllTestContainer</code> .  Ini adalah sifat yang disediakan oleh perpustakaan.  Ini akan memulai wadah yang diperlukan sebelum semua tes dan menghentikannya setelah semua tes.  Atau Anda dapat menggunakan <code>ForeachTestContainer</code> , lalu wadah mulai sebelum setiap tes dan berhenti setelah masing-masing. <br><br>  Maka Anda perlu mendefinisikan kembali wadah.  Ini dapat dilakukan dengan mengganti properti <code>container</code> .  Dalam kasus saya, saya menggunakan <code>PostgreSQLContainer</code> . <br><br>  Lalu kami menulis tes.  Dalam contoh ini, saya membuat koneksi, mengambil jdbcUrl, nama pengguna, kata sandi, menulis tes khusus, mengirim permintaan. <br><br>  Biasanya, tes integrasi memerlukan beberapa wadah.  Saya bisa membuatnya menggunakan <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Yaitu, saya membuat wadah, menambahkannya ke <code>MultipleContainers</code> , dan menggunakannya sebagai <code>container</code> . <br><br>  Skema untuk menjalankan tes dengan Testcontainers adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Dorong kode di GitLa. </li><li>  Pelari GitLab CI meluncurkan SBT. </li><li>  SBT menjalankan tes.  Di dalam pengujian, aplikasi dan dependensi kami diluncurkan. </li></ol><br>  Keuntungan dari skema ini: <br><br><ul><li>  Tidak perlu menjaga lingkungan dan dependensi yang terpisah, semuanya terjadi pada pelari. </li><li>  Anda dapat menguji berbagai cabang secara bersamaan. </li><li>  Anda dapat menguji mulai, berhenti, dan mulai ulang, karena kami dapat mengontrol siklus hidup aplikasi (semuanya dimulai tepat dalam kode uji). </li><li>  Ada HealthChecks fleksibel yang sangat kurang. </li><li>  Tidak ada file * .sh di repositori, Anda dapat mengonfigurasi tes dalam aplikasi ses fleksibel yang Anda inginkan. </li><li>  Berkat Pemetaan classpathResource, Anda dapat menggunakan konfigurasi yang sama dengan tes dan aplikasi. </li><li>  Anda dapat mengonfigurasi tes dari kode. </li><li>  Semua ini berjalan dengan sama mudahnya baik di CI dan lokal, karena ini hanya tes yang terlihat dan dijalankan sebagai unit test, hanya semuanya berjalan dalam wadah buruh pelabuhan. </li></ul><br>  Ternyata semuanya mencurigakan mulus dan baik, tetapi ini hanya pada pandangan pertama, pada kenyataannya, kami mengalami sejumlah masalah. <br><br><h3>  Wadah tergantung </h3><br>  Masalah pertama yang kami temui adalah <strong>wadah yang tergantung</strong> .  Katakanlah ada semacam tes: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Ini menjalankan postgres dan AppContainer.  AppContainer dari postgres dilewatkan jdbcUrl, nama pengguna dan kata sandi untuk koneksi.  Selanjutnya, MultipleContainers dibuat dan tes itu sendiri dijelaskan. <br><br>  Saya menjalankan program dan melihat kesalahan: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  Intinya adalah bahwa port yang ditugaskan tidak dapat diambil sampai wadah dimulai.  Mengapa ini terjadi? <br><br>  Faktanya adalah bahwa <code>ForAllTestContainer</code> atau <code>ForEachTestContainer</code> memulai kontainer segera sebelum tes, dan tidak pada saat saya membuat instance kontainer.  Ternyata saat saya membuat AppContainer, saya belum mengaktifkan <code>PostgreSQLContainer</code> , yang artinya saya tidak bisa mendapatkan port yang ditugaskan darinya, dan diperlukan untuk membentuk <code>jdbcUrl</code> . <br><br>  Masalahnya adalah bahwa esensi wadah itu bisa berubah: ia memiliki beberapa keadaan.  Misalnya, dapat dimatikan dan dihidupkan. <br><br>  Bagaimana cara mengatasi masalah ini?  Metode pertama yang saya sebut "malas." <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  Gagasan utamanya adalah membuat wadah menggunakan <strong>val malas</strong> .  Maka mereka tidak akan segera diinisialisasi dalam konstruktor uji, tetapi akan menunggu panggilan pertama.  Kami akan menginisialisasi dalam metode <code>beforeAll</code> dan <code>afterAll</code> , yang disediakan oleh BeforeAndAfterAll dari ScalaTest.  Di <code>beforeAll</code> wadah mulai, dan di <code>afterAll</code> , mereka mati.  Karena wadah dinyatakan malas, pada saat metode mulai dipanggil sebelum Semua, mereka akan dibuat, diinisialisasi, dan dimulai. <br><br>  Namun, kesalahan masih terjadi bahwa saya tidak dapat bergabung dengan localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Tampaknya kami menggunakan jdbcUrl, mengapa localhost muncul?  Mari kita lihat bagaimana jdbcUrl bekerja: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Itu hanya penggabungan string.  Semuanya jelas dengan konstanta, mereka tidak dapat rusak.  <code>getMappedPort</code> juga berfungsi, karena kami telah memperbaikinya.  <code>databaseName</code> adalah konstanta hard-coded.  Tetapi dengan <code>getContainerIpAddress</code> lebih menarik.  Berdasarkan namanya, kita dapat berasumsi bahwa itu harus mengembalikan alamat IP wadah.  Tetapi jika Anda menjalankan kode ini, ternyata selalu mengembalikan localhost.  Ternyata, metode ini tidak dimaksudkan untuk interaksi antar wadah: <code>getContainerIpAddress</code> <strong>menyediakan interaksi dari tes di dalam wadah</strong> . <br><br>  Rekomendasi pengembang Testcontainers: <strong>buat jaringan khusus untuk komunikasi antar wadah</strong> .  Susunan Docker berfungsi seperti ini: ia membuat jaringan dan menyelesaikan semuanya sendiri. <br><br>  Jadi, Anda perlu membuat jaringan. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Sekarang kita harus mengkonfigurasi jdbcUrl secara manual.  Kita juga perlu mengaktifkan kontainer kita di jaringan, dan mengatur alias untuk PostgreSQLContainer sehingga dapat diakses di dalam jaringan dengan beberapa nama domain.  Pada akhirnya, Anda harus ingat untuk "membunuh" jaringan. <br><br>  Akhirnya, program semacam itu akan berhasil. <br><br>  Dalam versi terbaru dari testcontainers-scala, inisialisasi wadah malas didukung di luar kotak: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Anda bisa menggunakan <code>ForAllTestContainer</code> dan <code>MultipleContainers</code> lagi.  Di <code>beforeAll</code> tidak perlu lagi <code>beforeAll</code> urutan mulai secara manual.  Sekarang <code>MultipleContainers</code> dapat bekerja dengan val malas dan menjalankannya dalam urutan yang benar, dan tidak melakukan inisialisasi yang ketat segera setelah pembuatan.  Pada saat yang sama, manipulasi dengan jaringan khusus dan jdbcUrl juga perlu dilakukan secara manual. <br><br><h3>  Mengejek </h3><br>  Namun, masih ada masalah.  Misalnya moki.  Terkadang sangat tidak nyaman untuk membuat semacam ketergantungan dalam wadah buruh pelabuhan.  Kami menggunakan Spark JobServer, yang menciptakan pekerjaan Spark dan mengontrol siklus hidup mereka di Spark.  Kami menggunakan dua metode: "buat" dan "berikan status". <br><br>  Untuk menjalankan Spark JobServer di dalam docker.  Perlu untuk meningkatkan Spark, dan sampai saat ini, tidak memiliki wadah buruh pelabuhan sama sekali dan itu perlu untuk merakit sendiri.  Selain itu, Spark JobServer menggunakan PostgreSQL untuk menyimpan status.  Akibatnya, Anda harus melakukan banyak pekerjaan sulit ketika Anda benar-benar hanya membutuhkan dua metode dengan API sederhana. <br><br>  Tetapi Anda dapat mengintip ke dalam implementasi JobServer Spark dan membuat mock yang berperilaku dengan cara yang sama, tetapi tidak memerlukan dependensi dari Spark JobServer yang asli. <br><br>  Sepertinya ini (dalam contoh, kodesemu yang disederhanakan): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    «»    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    «» docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       —    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Ringkasan </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers —   ,    . API   ,      . <br><br>     Java-,        .      —     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>—       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>—   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>—         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube —     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>—     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag —   , —       ,        .    ,    latest   . <br><br> <strong><em>— ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>—  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , —   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingin lebih detail tentang layanan microser sendiri dan tidak hanya pada Scala - program </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">memiliki jawaban untuk berbagai pertanyaan. </font><font style="vertical-align: inherit;">Lebih tertarik pada arsitektur dan interkoneksi berbagai bagiannya - datang ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada 7-8 November. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya sangat lezat, dan tidak jelas apa yang harus dipilih, kemudian berlangganan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buletin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di mana kita berbicara tentang laporan dan mengumpulkan bahan-bahan yang berguna tentang topik tersebut.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464307/">https://habr.com/ru/post/id464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464293/index.html">Apakah kait diganti dalam React Redux?</a></li>
<li><a href="../id464295/index.html">Contoh menggunakan beberapa fitur JavaScript baru</a></li>
<li><a href="../id464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../id464303/index.html">Data deret waktu dalam DBMS relasional. Ekstensi TimescaleDB dan PipelineDB untuk PostgreSQL</a></li>
<li><a href="../id464305/index.html">Kecil ya. Membuka kotak microvirtual Firecracker</a></li>
<li><a href="../id464309/index.html">Tombol panggilan DIY. Raspberry Pi, MajorDoMo, Freeswitch dan Linphonec</a></li>
<li><a href="../id464315/index.html">Film di mana ada tanah. Penelitian Yandex dan sejarah singkat pencarian berdasarkan makna</a></li>
<li><a href="../id464317/index.html">Proyek Konbanwa</a></li>
<li><a href="../id464325/index.html">Bagaimana Scrumban Menyatukan yang Terbaik dari Metodologi Kanban dan Scrum</a></li>
<li><a href="../id464327/index.html">Perbandingan penggunaan memori GUI toolkit berbeda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>