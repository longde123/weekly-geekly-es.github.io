<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏾 ⏯️ 👩🏿‍🏭 JavaScript-Entwurfsmuster ◾️ ♌️ 👨🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir veröffentlichen, sagt, dass beim Starten eines Projekts nicht sofort mit dem Schreiben von Code begonn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Entwurfsmuster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/427293/">  Der Autor des Materials, dessen Übersetzung wir veröffentlichen, sagt, dass beim Starten eines Projekts nicht sofort mit dem Schreiben von Code begonnen wird.  Zunächst bestimmen sie den Zweck und die Grenzen des Projekts und identifizieren dann die Möglichkeiten, die es haben sollte.  Danach schreiben sie entweder sofort den Code oder wählen, wenn es sich um ein recht komplexes Projekt handelt, geeignete Entwurfsmuster aus, die seine Grundlage bilden.  In diesem Material geht es um JavaScript-Entwurfsmuster.  Es ist in erster Linie für Anfänger-Entwickler konzipiert. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/zv/zk/by/zvzkbyrzatcp3w-qda0bfcopljq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist ein Designmuster?</font> </h2><br>  Im Bereich der Softwareentwicklung ist ein Entwurfsmuster ein wiederholbarer Architekturentwurf, der eine Lösung für ein Entwurfsproblem in einem häufig auftretenden Kontext darstellt.  Entwurfsmuster sind eine Zusammenfassung der Erfahrungen professioneller Softwareentwickler.  Ein Entwurfsmuster kann als eine Art Muster betrachtet werden, nach dem Programme geschrieben werden. <br><br><h2>  <font color="#3AC1EF">Warum werden Designmuster benötigt?</font> </h2><br>  Viele Programmierer halten Entwurfsmuster entweder für Zeitverschwendung oder wissen einfach nicht, wie sie richtig angewendet werden sollen.  Die Verwendung eines geeigneten Musters kann jedoch dazu beitragen, besseren und verständlicheren Code zu schreiben, der aufgrund seiner Verständlichkeit leichter zu warten ist. <br><br>  Das Wichtigste dabei ist vielleicht, dass die Verwendung von Mustern Softwareentwicklern so etwas wie ein Wörterbuch bekannter Begriffe bietet, die beispielsweise beim Parsen des Codes eines anderen sehr nützlich sind.  Muster zeigen den Zweck bestimmter Fragmente des Programms für diejenigen, die versuchen, mit dem Gerät eines Projekts umzugehen. <br><br>  Wenn Sie beispielsweise das Muster „Decorator“ verwenden, wird der neue Programmierer, der zum Projekt gekommen ist, sofort darüber informiert, welche Aufgaben ein bestimmter Code löst und warum er benötigt wird.  Dank dessen kann ein solcher Programmierer mehr Zeit für die praktischen Aufgaben aufwenden, die das Programm löst, als zu versuchen, seine interne Struktur zu verstehen. <br><br>  Nachdem wir herausgefunden haben, was Entwurfsmuster sind und wofür sie gedacht sind, werden wir uns den Mustern selbst zuwenden und ihre Implementierung mit JavaScript beschreiben. <br><br><h2>  <font color="#3AC1EF">Muster "Modul"</font> </h2><br>  Ein Modul ist ein unabhängiger Code, der geändert werden kann, ohne dass dies Auswirkungen auf anderen Projektcode hat.  Module ermöglichen es außerdem, ein Phänomen wie die Verschmutzung von Sichtbarkeitsbereichen zu vermeiden, da sie separate Sichtbarkeitsbereiche für die darin deklarierten Variablen erstellen.  Für ein Projekt geschriebene Module können in anderen Projekten wiederverwendet werden, wenn ihre Mechanismen universell sind und nicht an die Besonderheiten eines bestimmten Projekts gebunden sind. <br><br>  Module sind ein wesentlicher Bestandteil jeder modernen JavaScript-Anwendung.  Sie helfen dabei, die Code-Sauberkeit aufrechtzuerhalten, Code in aussagekräftige Fragmente zu unterteilen und ihn zu organisieren.  JavaScript bietet viele Möglichkeiten zum Erstellen von Modulen. Eine davon ist das Modul „Modul“. <br><br>  Im Gegensatz zu anderen Programmiersprachen verfügt JavaScript nicht über Zugriffsmodifikatoren.  Das heißt, Variablen können nicht als privat oder öffentlich deklariert werden.  Infolgedessen wird das "Modul" -Muster auch verwendet, um das Konzept der Kapselung zu emulieren. <br><br>  Dieses Muster verwendet IIFE (sofort aufgerufene funktionale Ausdrücke, Abschlüsse und Funktionsumfang, um dieses Konzept nachzuahmen.  Zum Beispiel: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateVariable = <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(privateVariable);  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    <span class="hljs-attr"><span class="hljs-attr">publicMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{      privateMethod();    }  } })(); myModule.publicMethod();</code> </pre> <br>  Da wir IIFE haben, wird der Code sofort ausgeführt und das vom Ausdruck zurückgegebene Objekt wird der Konstanten <code>myModule</code> .  Aufgrund der Tatsache, dass ein Abschluss vorliegt, hat das zurückgegebene Objekt Zugriff auf Funktionen und Variablen, die in IIFE deklariert sind, auch nachdem IIFE seine Arbeit abgeschlossen hat. <br><br>  Infolgedessen sind die in IIFE deklarierten Variablen und Funktionen vor den Mechanismen verborgen, die außerhalb ihrer Sichtbarkeit liegen.  Sie erweisen sich als private Einheiten der <code>myModule</code> Konstante. <br><br>  Nachdem dieser Code ausgeführt wurde, <code>myModule</code> aus: <br><br><pre> <code class="hljs matlab">const myModule = { publicMethod: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; }};</span></span></code> </pre> <br>  Das heißt, unter Bezugnahme auf diese Konstante können Sie die öffentliche Methode des <code>publicMethod()</code> , die wiederum die private Methode <code>privateMethod()</code> .  Zum Beispiel: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.publicMethod();</code> </pre> <br><h2>  <font color="#3AC1EF">Modulmuster öffnen</font> </h2><br>  Das Revealing Module-Muster ist eine leicht verbesserte Version des von Christian Heilmann vorgeschlagenen Modulmusters.  Das Problem mit dem "Modul" -Muster ist, dass wir öffentliche Funktionen erstellen müssen, um auf private Funktionen und Variablen zugreifen zu können. <br><br>  In diesem Muster weisen wir den Eigenschaften des zurückgegebenen Objekts, das wir veröffentlichen möchten, private Funktionen zu.  Aus diesem Grund wird dieses Muster als "Offenes Modul" bezeichnet.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myRevealingModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateVar = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publicVar  = <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Name: '</span></span>+ privateVar); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publicSetName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{   privateVar = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publicGetName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   privateFunction(); } <span class="hljs-comment"><span class="hljs-comment">/**    ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">setName</span></span>: publicSetName,   <span class="hljs-attr"><span class="hljs-attr">greeting</span></span>: publicVar,   <span class="hljs-attr"><span class="hljs-attr">getName</span></span>: publicGetName }; })(); myRevealingModule.setName(<span class="hljs-string"><span class="hljs-string">'Mark'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  Name: Mark myRevealingModule.getName();</span></span></code> </pre> <br>  Die Verwendung dieses Musters vereinfacht das Verständnis, welche Funktionen und Variablen des Moduls öffentlich verfügbar sind, was zur Verbesserung der Lesbarkeit des Codes beiträgt. <br><br>  Nach dem Ausführen von <code>myRevealingModule</code> sieht myRevealingModule <code>myRevealingModule</code> aus: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myRevealingModule = { setName: publicSetName, greeting: publicVar, getName: publicGetName };</code> </pre> <br>  Wir können beispielsweise die Methode <code>myRevealingModule.setName('Mark')</code> aufrufen, die auf die interne Funktion <code>publicSetName</code> .  Die Methode <code>myRevealingModule.getName()</code> verweist auf die interne Funktion <code>publicGetName</code> .  Zum Beispiel: <br><br><pre> <code class="hljs cs">myRevealingModule.setName(<span class="hljs-string"><span class="hljs-string">'Mark'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  Name: Mark myRevealingModule.getName();</span></span></code> </pre> <br>  Berücksichtigen Sie die Vorteile des Musters "Open Module" gegenüber dem Muster "Module": <br><br><ul><li>  Mit dem "offenen Modul" können Sie öffentliche versteckte Entitäten des Moduls erstellen (und diese gegebenenfalls wieder ausblenden), indem Sie für jede einzelne Entität nur eine Zeile im Objekt ändern, die nach IIFE zurückgegeben wird. </li><li>  Das zurückgegebene Objekt enthält keine Funktionsdefinition.  Alles rechts von seinen Eigenschaftsnamen ist in IIFE definiert.  Dies hilft, den Code sauber und leicht lesbar zu halten. </li></ul><br><h2>  <font color="#3AC1EF">Module in ES6</font> </h2><br>  Vor der Veröffentlichung des ES6-Standards verfügte JavaScript nicht über ein Standardtool für die Arbeit mit Modulen. Daher mussten Entwickler Bibliotheken von Drittanbietern oder das Muster „Modul“ verwenden, um die entsprechenden Mechanismen zu implementieren.  Mit dem Aufkommen von ES6 erschien jedoch ein Standardmodulsystem in JavaScript. <br><br>  ES6-Module werden in Dateien gespeichert.  Eine Datei kann nur ein Modul enthalten.  Alles innerhalb des Moduls ist standardmäßig privat.  Funktionen, Variablen und Klassen können mit dem Schlüsselwort <code>export</code> .  Code innerhalb des Moduls wird immer im strengen Modus ausgeführt. <br><br><h3>  <font color="#3AC1EF">▍ Modul exportieren</font> </h3><br>  Es gibt zwei Möglichkeiten, eine in einem Modul deklarierte Funktion oder Variable zu exportieren: <br><br><ul><li>  Der Export erfolgt durch Hinzufügen des Schlüsselworts <code>export</code> bevor eine Funktion oder Variable deklariert wird.  Zum Beispiel: <br><br><pre> <code class="hljs lua">// utils.js export const greeting = <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Sum:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 + num2; } export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Subtract:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 - num2; } //  -   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Private Function'</span></span>); }</code> </pre> </li><li>  Der Export erfolgt durch Hinzufügen des Schlüsselworts <code>export</code> am Ende des Codes, in dem die Namen der zu exportierenden Funktionen und Variablen aufgeführt sind.  Zum Beispiel: <br><br><pre> <code class="hljs lua">// utils.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Multiply:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 * num2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Divide:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 / num2; } //    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Private Function'</span></span>); } export {multiply, divide};</code> </pre> </li></ul><br><h3>  <font color="#3AC1EF">▍Importmodul</font> </h3><br>  So wie es zwei Möglichkeiten zum Exportieren gibt, gibt es zwei Möglichkeiten zum Importieren von Modulen.  Dies erfolgt mit dem Schlüsselwort <code>import</code> : <br><br><ul><li>  Importieren Sie mehrere ausgewählte Elemente.  Zum Beispiel: <br><br><pre> <code class="hljs pgsql">// main.js //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { sum, multiply } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./utils.js'</span></span>; console.log(sum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)); console.log(multiply(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>));</code> </pre> </li><li>  Importieren Sie alles, was das Modul exportiert.  Zum Beispiel: <br><br><pre> <code class="hljs pgsql">// main.js //  ,    <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> utils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./utils.js'</span></span>; console.log(utils.sum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)); console.log(utils.multiply(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>));</code> </pre> </li></ul><br><h3>  <font color="#3AC1EF">▍ Aliase für exportierte und importierte Entitäten</font> </h3><br>  Wenn die Namen von Funktionen oder Variablen, die in den Code exportiert werden, eine Kollision verursachen können, können sie während des Exports oder während des Imports geändert werden. <br><br>  Um Objekte während des Exports umzubenennen, haben Sie folgende Möglichkeiten: <br><br><pre> <code class="hljs lua">// utils.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Sum:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 + num2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num1, num2)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Multiply:'</span></span>, num1, num2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 * num2; } export {sum as add, multiply};</code> </pre> <br>  Um Objekte während des Imports umzubenennen, wird die folgende Konstruktion verwendet: <br><br><pre> <code class="hljs pgsql">// main.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>, multiply <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mult } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./utils.js'</span></span>; console.log(<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)); console.log(mult(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>));</code> </pre> <br><h2>  <font color="#3AC1EF">Singleton-Muster</font> </h2><br>  Das Muster "Singleton" oder "Singleton" ist ein Objekt, das nur in einer einzigen Kopie existieren kann.  Im Rahmen der Anwendung dieses Musters wird eine neue Instanz einer Klasse erstellt, wenn sie noch nicht erstellt wurde.  Wenn die Klasseninstanz bereits vorhanden ist, wird beim Versuch, auf den Konstruktor zuzugreifen, ein Verweis auf das entsprechende Objekt zurückgegeben.  Nachfolgende Aufrufe des Konstruktors geben immer dasselbe Objekt zurück. <br><br>  Tatsächlich gab es in JavaScript immer das, was wir als "Singleton" -Muster bezeichnen, aber sie nennen es nicht "Singleton", sondern "Objektliteral".  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">job</span></span>: <span class="hljs-string"><span class="hljs-string">'Teacher'</span></span>, <span class="hljs-attr"><span class="hljs-attr">greet</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); } };</code> </pre> <br>  Da jedes Objekt in JavaScript seinen eigenen Speicherbereich belegt und ihn nicht mit anderen Objekten teilt, erhalten wir bei jedem Zugriff auf die <code>user</code> einen Link zu demselben Objekt. <br><br>  Das Singleton-Muster kann mithilfe der Konstruktorfunktion implementiert werden.  Es sieht so aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, age</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(instance) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">'Mark'</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  true console.log(user1 === user2);</span></span></code> </pre> <br>  Wenn die Konstruktorfunktion aufgerufen wird, prüft sie zunächst, ob das <code>instance</code> vorhanden ist.  Wenn die entsprechende Variable nicht initialisiert wird, wird <code>this</code> die <code>instance</code> .  Wenn die Variable bereits einen Verweis auf ein Objekt hat, gibt der Konstruktor einfach eine <code>instance</code> , dh einen Verweis auf ein vorhandenes Objekt. <br><br>  Das Singleton-Muster kann mithilfe des Modulmusters implementiert werden.  Zum Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> singleton = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, age</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">getInstance</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, age</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!instance) {       instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(name, age);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance;   } } })(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user1 = singleton.getInstance(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user2 = singleton.getInstance(<span class="hljs-string"><span class="hljs-string">'Mark'</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>); <span class="hljs-comment"><span class="hljs-comment">// prints true console.log(user1 === user2);</span></span></code> </pre> <br>  Hier erstellen wir eine neue <code>user</code> indem wir die Methode <code>singleton.getInstance()</code> aufrufen.  Wenn eine Instanz des Objekts bereits vorhanden ist, gibt diese Methode diese einfach zurück.  Wenn es noch kein solches Objekt gibt, erstellt die Methode eine neue Instanz davon, indem sie die <code>User</code> Konstruktorfunktion aufruft. <br><br><h2>  <font color="#3AC1EF">Fabrikmuster</font> </h2><br>  Das Factory-Muster verwendet sogenannte Factory-Methoden, um Objekte zu erstellen.  Sie müssen keine Klassen oder Konstruktorfunktionen angeben, die zum Erstellen von Objekten verwendet werden. <br><br>  Dieses Muster wird verwendet, um Objekte in Fällen zu erstellen, in denen es nicht erforderlich ist, die Logik ihrer Erstellung öffentlich zu machen.  Das Factory-Muster kann verwendet werden, wenn Sie abhängig von bestimmten Bedingungen unterschiedliche Objekte erstellen müssen.  Zum Beispiel: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(options) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doors = options.doors || <span class="hljs-number"><span class="hljs-number">4</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = options.state || <span class="hljs-string"><span class="hljs-string">'brand new'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.color = options.color || <span class="hljs-string"><span class="hljs-string">'white'</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Truck</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(options) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doors = options.doors || <span class="hljs-number"><span class="hljs-number">4</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = options.state || <span class="hljs-string"><span class="hljs-string">'used'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.color = options.color || <span class="hljs-string"><span class="hljs-string">'black'</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleFactory</span></span></span><span class="hljs-class"> </span></span>{ createVehicle(options) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(options.vehicleType === <span class="hljs-string"><span class="hljs-string">'car'</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Car(options);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(options.vehicleType === <span class="hljs-string"><span class="hljs-string">'truck'</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Truck(options);     } } }</code> </pre> <br>  Hier werden die <code>Car</code> und <code>Truck</code> Klassen angelegt, die die Verwendung bestimmter Standardwerte vorsehen.  Sie werden verwendet, um <code>car</code> und <code>truck</code> Objekte zu erstellen.  <code>VehicleFactory</code> wird auch die <code>VehicleFactory</code> Klasse deklariert, mit der neue Objekte basierend auf der Analyse der <code>vehicleType</code> Eigenschaft erstellt werden, die mit <code>options</code> an die entsprechende Methode des Objekts übergeben wird, das im Objekt zurückgegeben wird.  So arbeiten Sie mit all dem: <br><br><pre> <code class="hljs perl">const factory = new VehicleFactory(); const car = factory.createVehicle({ vehicleType: <span class="hljs-string"><span class="hljs-string">'car'</span></span>, doors: <span class="hljs-number"><span class="hljs-number">4</span></span>, color: <span class="hljs-string"><span class="hljs-string">'silver'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">state</span></span>: <span class="hljs-string"><span class="hljs-string">'Brand New'</span></span> }); const truck= factory.createVehicle({ vehicleType: <span class="hljs-string"><span class="hljs-string">'truck'</span></span>, doors: <span class="hljs-number"><span class="hljs-number">2</span></span>, color: <span class="hljs-string"><span class="hljs-string">'white'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">state</span></span>: <span class="hljs-string"><span class="hljs-string">'used'</span></span> }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Car {doors: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">state</span></span>: <span class="hljs-string"><span class="hljs-string">"Brand New"</span></span>, color: <span class="hljs-string"><span class="hljs-string">"silver"</span></span>} console.log(car); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Truck {doors: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">state</span></span>: <span class="hljs-string"><span class="hljs-string">"used"</span></span>, color: <span class="hljs-string"><span class="hljs-string">"white"</span></span>} console.log(truck);</code> </pre> <br>  Hier wird das <code>factory</code> Objekt der <code>VehicleFactory</code> Klasse <code>VehicleFactory</code> .  Danach können Sie Objekte der Klassen " <code>Car</code> oder " <code>Truck</code> erstellen, indem Sie die Methode <code>factory.createVehicle()</code> aufrufen und das <code>vehicleType</code> wobei die Eigenschaft " <code>vehicleType</code> auf " <code>car</code> oder " <code>truck</code> . <br><br><h2>  <font color="#3AC1EF">Dekorateur Muster</font> </h2><br>  Das Decorator-Muster wird verwendet, um die Funktionalität von Objekten zu erweitern, ohne vorhandene Klassen oder Konstruktorfunktionen zu ändern.  Dieses Muster kann verwendet werden, um Objekten bestimmte Funktionen hinzuzufügen, ohne den Code zu ändern, der für deren Erstellung verantwortlich ist. <br><br>  Hier ist ein einfaches Beispiel für die Verwendung dieses Musters: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span></span> { this.name = name; //    this.color = <span class="hljs-string"><span class="hljs-string">'White'</span></span>; } //   ,    const tesla= new Car(<span class="hljs-string"><span class="hljs-string">'Tesla Model 3'</span></span>); //   -    tesla.setColor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color)</span></span></span></span> { this.color = color; } tesla.setPrice = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(price)</span></span></span></span> { this.price = price; } tesla.setColor(<span class="hljs-string"><span class="hljs-string">'black'</span></span>); tesla.setPrice(<span class="hljs-number"><span class="hljs-number">49000</span></span>); //  black console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(tesla.color);</code> </pre> <br>  Betrachten wir nun ein praktisches Beispiel für die Anwendung dieses Musters.  Angenommen, die Kosten für Autos hängen von ihren Merkmalen und den zusätzlichen Funktionen ab, die ihnen zur Verfügung stehen.  Ohne die Verwendung des Decorator-Musters müssten wir zur Beschreibung dieser Autos verschiedene Klassen für verschiedene Kombinationen dieser zusätzlichen Funktionen erstellen, von denen jede eine Methode zum Ermitteln der Kosten eines Autos hätte.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class">() </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarWithAC</span></span></span><span class="hljs-class">() </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarWithAutoTransmission</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarWithPowerLocks</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarWithACandPowerLocks</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Dank des fraglichen Musters können Sie ein Auto der Basisklasse erstellen, das beispielsweise ein Auto in der Grundkonfiguration beschreibt, dessen Kosten durch einen festen Betrag ausgedrückt werden.  Danach kann das auf Basis dieser Klasse erstellte Standardobjekt mit Decorator-Funktionen erweitert werden.  Das von dieser Funktion verarbeitete Standardauto erhält neue Möglichkeiten, die sich zusätzlich auf den Preis auswirken.  Dieses Schema kann beispielsweise wie folgt implementiert werden: <br><br><pre> <code class="hljs lua">class Car { constructor() { //   this.cost = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20000</span></span>; } } } // - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">carWithAC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car)</span></span></span></span> { car.hasAC = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; const prevCost = car.cost(); car.cost = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prevCost + <span class="hljs-number"><span class="hljs-number">500</span></span>; } } // - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">carWithAutoTransmission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car)</span></span></span></span> { car.hasAutoTransmission = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  const prevCost = car.cost(); car.cost = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prevCost + <span class="hljs-number"><span class="hljs-number">2000</span></span>; } } // - <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">carWithPowerLocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car)</span></span></span></span> { car.hasPowerLocks = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; const prevCost = car.cost(); car.cost = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prevCost + <span class="hljs-number"><span class="hljs-number">500</span></span>; } }</code> </pre> <br>  Hier erstellen wir zuerst die Basisklasse <code>Car</code> , mit der Objekte erstellt werden, die Autos als Standard darstellen.  Anschließend erstellen wir mehrere Dekorationsfunktionen, mit denen wir die Objekte der Basisklasse <code>Car</code> um zusätzliche Eigenschaften erweitern können.  Diese Funktionen nehmen die entsprechenden Objekte als Parameter.  Danach fügen wir dem Objekt eine neue Eigenschaft hinzu, die angibt, mit welcher neuen Funktion das Auto ausgestattet wird, und definieren die <code>cost</code> des Objekts neu, die nun die neuen Kosten des Autos zurückgibt.  Um das Auto mit Standardkonfiguration mit etwas Neuem auszustatten, können wir daher das folgende Design verwenden: <br><br><pre> <code class="hljs pgsql">const car = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Car(); console.log(car.<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>()); carWithAC(car); carWithAutoTransmission(car); carWithPowerLocks(car);</code> </pre> <br>  Danach können Sie die Kosten des Autos in einer verbesserten Konfiguration herausfinden: <br><br><pre> <code class="hljs pgsql">//       console.log(car.<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>());</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir verschiedene in JavaScript verwendete Entwurfsmuster untersucht. Tatsächlich gibt es jedoch noch viele Muster, mit denen eine Vielzahl von Problemen gelöst werden können. <br><br>  Während die Kenntnis der verschiedenen Entwurfsmuster für den Programmierer wichtig ist, ist ihre angemessene Verwendung ebenso wichtig.  Wenn der Programmierer die Muster und den Umfang ihrer Anwendung kennt und die vor ihm liegende Aufgabe analysiert, kann er verstehen, welche Art von Muster zur Lösung beitragen kann. <br><br>  <b>Liebe Leser!</b>  Welche Designmuster verwenden Sie am häufigsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427293/">https://habr.com/ru/post/de427293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427281/index.html">Entwicklung von Schnittstellenklassen in C ++</a></li>
<li><a href="../de427283/index.html">Wie hoch die Verfügbarkeit bei Kubernetes ist gewährleistet</a></li>
<li><a href="../de427285/index.html">Schule über die Grundlagen digitaler Schaltkreise: Nowosibirsk - Ok, Krasnojarsk - machen Sie sich bereit</a></li>
<li><a href="../de427289/index.html">Geologische 3D-Modellierung, Protokollierung und Technologie von Aramco Innovations</a></li>
<li><a href="../de427291/index.html">Minimieren Sie den Datenverkehr in ASP.NET Web Forms, anklickbare Div- und regelmäßige Serverabfragen</a></li>
<li><a href="../de427295/index.html">JavaScript-Currying-Funktionen</a></li>
<li><a href="../de427297/index.html">Apache Ignite + Apache Spark-Datenrahmen: zusammen mehr Spaß</a></li>
<li><a href="../de427299/index.html">Lassen Sie uns noch etwas sammeln? Konstruktor 3 in 1 "Mondflotte"</a></li>
<li><a href="../de427301/index.html">GitHub stürzt Datenbank ab</a></li>
<li><a href="../de427303/index.html">Windows verlangsamen Teil 2: Prozesse erstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>