<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏾 🚊 ♿️ 《塞尔达传说》中的屏幕过渡使用了NES未记录的功能 👎🏿 ㊙️ 💴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为了在“塞尔达传说”的第一部分中垂直滚动效果，使用了NES图形“硬件”操作，这很可能不是控制台开发人员提供的。 


 我无权访问NES控制台的图片处理单元（PPU-图形芯片）的官方文档，因此我对“未定义行为”的陈述更有可能是猜测。 我从NesDev Wiki获取了图形硬件的规范 。 通过写入具有存...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>《塞尔达传说》中的屏幕过渡使用了NES未记录的功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/"> 为了在“塞尔达传说”的第一部分中垂直滚动效果，使用了NES图形“硬件”操作，这很可能不是控制台开发人员提供的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br> 我无权访问NES控制台的图片处理单元（PPU-图形芯片）的官方文档，因此我对“未定义行为”的陈述更有可能是猜测。 我从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NesDev Wiki</a>获取了图形硬件的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范</a> 。 通过写入具有存储器映射的寄存器来控制PPU。 如果以设计人员设想的方式使用这些寄存器，那么将无法实现这种效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br> 垂直滚动屏幕时，整个屏幕应立即滚动。 先前的GIF显示了部分垂直滚动的示例。 屏幕的一部分保持静止（界面元素），另一部分（游戏区域）垂直滚动。  PPU的“标准”工作无法实现部分垂直滚动。 <br><br> 相反，完全定义了部分<em>水平</em>滚动并且是可能的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br> 在绘制帧时写入单独的PPU寄存器可能会导致图形失真。 塞尔达传说（Legend of Zelda）故意造成一种工件，该工件表现为部分垂直滚动。 在本文中，我将讨论NES图形硬件，并说明垂直滚动技巧的工作原理。 <br><a name="habracut"></a><br><h2> 图形类型 </h2><br>  NES控制台具有两种类型的图形： <br><br><ul><li> 子画面是可以放置在屏幕上任意位置且彼此独立移动的图块。 </li><li> 背景-可以平滑滚动为单个图像的瓷砖网格。 </li></ul><br> 为了演示两者之间的区别，我将展示一个由精灵和背景组成的场景： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br> 这是只显示精灵的同一场景： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br> 这是一个只有背景可见的场景： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2> 卷动 </h2><br> 图像处理器（NES图片处理器）支持滚动背景图像。 在图形存储器中，背景图被存储为一个二维的图块网格，覆盖了两倍于屏幕宽度和高度的区域。 <br><br> 在该网格中的屏幕上，屏幕上会显示一个“窗口”，大小与屏幕大小相同，并且可以精确控制该窗口的位置。 通过沿网格逐渐移动可见窗口，可以创建平滑的滚动效果。 <br><br> 输出的NES视频信号的大小为256x240像素。 存储器内部的图块网格表示为512x480像素区域，并分为四个屏幕大小的矩形，称为“名称表”。 游戏可以通过在名称表的网格中选择像素坐标来指示可见窗口的位置，从而配置图片处理单元（PPU）。 <br><br> 选择坐标（0，0）时，名称的整个左上表将显示在屏幕上： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br> 转到（125，181），我们将从每个名称表中看到一些内容： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br> 可见窗口最小化到内存中图块网格的背面。 移至（342，290），我们将可见屏幕的左上角放在名称的右下方表中，由于折叠，每个名称表的部分都将可见： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3> 内存不足！ </h3><br> 每个名称表的大小为1 KB，但是NES仅向这些表分配2 KB的视频内存，因此一次只能在内存中容纳两个名称表。 <br><br> 它怎么会有四个名称表？ <br><br><h4> 镜像名称表 </h4><br> 视频存储器以这样的方式连接到PPU：当PPU渲染四个表观名称表之一的图块时，实际上是两个真实表之一被选择，并且从那里进行读取。 从本质上讲，这意味着四个可见名称表实际上由两对相同的表组成。 <br><br> 此图显示了所有四个表的内容的快照。 左上方和右上方与两个下方相同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br> 为什么然后不保留两个名称表呢？ <br><br> 幸运的是，可以在运行时配置视在表和真实表之间的确切绑定。 如果游戏要执行水平滚动，则它会调整图形设备，以使左上和右上表不同，并且可以滚动它们而不会出现明显的重复。 在此配置中，左上表和左下表将引用相同的实名表； 同样适用于两个右表。 此配置称为垂直镜像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br> 还有另一种可能的配置-“水平镜像”，游戏将其用于垂直滚动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br> 通常，游戏不会沿对角线滚动，因为由于名称表的镜像，游戏会在屏幕边缘周围产生伪像。 <br><br><h3> 弹药筒 </h3><br> 每个游戏卡带都有用于配置表镜像的硬件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br> 有些游戏根本不需要切换镜像，因此水平或垂直镜像都硬编码在盒中。 其他游戏会在这两种模式之间动态切换，因此可以通过编程方式配置其弹药筒中的镜像。 塞尔达传说属于第二类。 最后，某些真正复杂的游戏的盒带具有额外的视频内存，也就是说，它们根本不需要镜像：它们可以同时垂直和水平滚动，而没有可见的复制伪像。 <br><br><h3> 真实的例子 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>屏幕上显示的垂直滚动的示例。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>这显示了具有水平镜像的名称表的记录。</i>  <i>当前可见的窗口突出显示。</i> <br><br> 请记住，最垂直的滚动并非罕见-异常的是带有<em>分屏的</em>垂直滚动。 <br><br><h2> 分屏 </h2><br> 由NES生成的视频信号的每一帧都是从上到下渲染的，一次渲染一行像素。 在每一行中，从左到右一次绘制一个像素。 在渲染帧的一半时，游戏可以重新配置PPU，这会影响尚未渲染的像素的显示。 框架中间最常见的变化之一是更新水平滚动位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br> 在房间之间水平滚动时，《塞尔达传说》始终从滚动位置（0，0）开始，并在屏幕顶​​部呈现界面元素。 在屏幕上绘制界面像素的最后一行后，水平滚动改变的值会随着每帧的增加而增加，因此相机会平稳移动。 <br><br> 名称表显示的动画显示了滚动之前游戏如何从水平镜像切换到垂直镜像，以及在过渡完成后如何再次切换到水平镜像。 另外，在继续滚动的同时，将更新左上（和左下）名称表，并在其中记录玩家进入的房间的副本。 滚动完成后，游戏停止拆分屏幕，并且再次完全从左上方的表格进行渲染。 <br><br><h3> 渲染测量 </h3><br> 为了将屏幕拆分到所需位置，游戏需要以某种方式找出绘制当前帧的哪一部分。 像素字符串以已知的频率渲染，因此可以通过计算自帧开始以来经过的处理器周期数来确定渲染的像素字符串的数量。 <br><br> 还有另一种更准确的技术，称为“精灵零击中”。 <br><br>  NES一次最多可以渲染64个精灵。 视频存储器中的第一个精灵称为“零精灵”（零精灵）。 在每帧中，只要将零子画面的不透明像素叠加到不透明的背景像素上，就会发生“子画面零命中”事件。 它通过内存映射将一个PPU寄存器中的一个位置1，可以由处理器检查。 <br><br> 要使用Sprite Zero Hit（Sprite零命中）来拆分屏幕，游戏会将零Sprite放置在拆分边界附近的垂直位置，并且在渲染过程中，它们会不断检查是否发生了Sprite Zero Hit事件。 如果是这样，则游戏将从水平滚动切换为实现分离。 <br><br> 带有和不带有背景的房间之间的水平过渡如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br> 在过渡开始时出现并在结束时消失的棕色圆圈是零子图形。 我们将仔细研究有无背景的界面： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br> 零精灵是与游戏界面中常规炸弹精灵完全匹配的漂白炸弹精灵。 零子画面被配置为显示在背景下，但是由于界面的黑色像素被认为是透明的，因此如果零子画面炸弹没有被战略性地隐藏在界面的炸弹后面，则该零子弹将是可见的。 <br><br> 请注意，“精灵零点击”发生在界面底行之前几行像素。 它发生在炸弹保险丝的顶部像素，距离界面底部16个像素。 当“精灵零命中”发生时，游戏开始计算处理器周期，并在完成所需的周期数后设置水平滚动。 <br><br><h2> 光束消隐 </h2><br> 大多数情况下，控制台PPU在屏幕上绘制像素。 帧之间的停机时间很短，在此期间不执行渲染。 这种现象称为消隐（垂直消隐或vblank）。 某些类型的PPU配置更改只能在vblank期间进行。 <br><br><h2> 滚动寄存器 </h2><br> 游戏通过写入称为<code>PPUSCROLL</code>的PPU寄存器来更改滚动位置，该寄存器映射到内存地址<code>0x2005</code> 。  <code>PPUSCROLL</code>的第一个写操作定义了滚动位置的X分量，第二个操作设置了Y分量，类似地，进一步执行交替记录。 <br><br> 下图显示了在该回放（慢动作）过程中屏幕的16帧中<code>PPUSCROLL</code>中所有非零的写入操作以及游戏的情节。 滚动位置分量Y每两帧增加一次。 在此示例中， <code>PPUSCROLL</code>中的所有写操作都是在vblank期间执行的，这会导致整个背景随之滚动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3> 滚动画面分割 </h3><br> 在<code>PPUSCROLL</code>期间对<code>PPUSCROLL</code>写操作在vblank之后立即绘制的帧的开头生效。 如果滚动位置在帧渲染期间发生更改（即在vblank期间未发生变化），则此更改在图形到达下一行像素时生效。 通过在PPU在滚动之前绘制最后一行像素的同时写入<code>PPUSCROLL</code>来实现部分水平滚动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br> 当更新框架中间的滚动位置时，仅应用滚动位置的X位置。 即，滚动位置分量Y被丢弃。 因此，如果游戏要分割屏幕并更改框架滚动部分的位置，则只能水平滚动。 <br><br> 而且： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br> 信不信由你， <code>PPUSCROLL</code>寄存器的值在此转换期间未更改。 <br><br> 您可以在界面下看到一个高1像素的图形工件。 这是我的模拟器的一个错误，这是由于处理器时钟周期与逐像素渲染缺乏同步所导致的。 <br><br><h3> 干预其他名册 </h3><br> 映射到内存地址<code>0x2006</code>的第二个寄存器称为<code>PPUADDR</code> ，用于设置当前视频内存地址。 例如，当游戏想要更改名称表中的图块之一时，它首先将<code>PPUADDR</code>的视频内存地址写入<code>PPUADDR</code> ，然后将<code>PPUDATA</code>的新值写入<code>PPUDATA</code>这是映射到地址<code>0x2007</code>的第三个寄存器。 <br><br>  <code>PPUADDR</code>期间（即渲染帧时）写入<code>PPUADDR</code>可能会导致图形失真。 这是因为在从视频存储器获取图块以对其进行绘制的过程中，受<code>PPUADDR</code>写入影响的PPU链也直接受到PPU设备的控制。 由于渲染到屏幕的过程是从该行的顶部到底部，以及从左到右执行的，因此PPU本质上为<code>PPUADDR</code>分配<code>PPUADDR</code>绘制的当前<code>PPUADDR</code>的地址值。 当渲染从一个图块移动到另一个图块时， <code>PPUADDR</code>将增加当前值。 <br><br> 因此，在帧的中间写入<code>PPUADDR</code>可以更改PPU在当前帧的持续时间内从内存中接收到的图块。 <br><br> 让我们在垂直跳转期间<code>PPUADDR</code>对<code>PPUADDR</code>写操作。 由于名称表也在过渡期间更新，因此对<code>PPUADDR</code>的<em>所有</em>写操作的输出将过于庞大。 在水平过渡的情况下，在渲染一行像素63时设置了滚动，因此，我们将仅在此行中考虑在<code>PPUADDR</code>写入操作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br> 图案清晰可见。 每两帧，记录在像素行63中的地址减少32（0x20）。 但是，这如何导致实际滚动位置的更新？ <br><br><h3>  <i>实际</i>滚动寄存器 </h3><br>  PPU内部有一个15位寄存器，未映射到CPU。 它既用作访问视频内存的当前地址，又用作后台滚动配置。 <br><br> 当将此值用作地址时，将忽略第14位，而将第0-13位视为视频存储器中的地址。 <br><br> 使用此值作为滚动配置时，其不同部分具有不同的含义： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>选择一个名称表</strong>是一个介于0到3之间的值，该值确定用来绘制图形的当前名称表。 <br><br>  <strong>X中的</strong> <strong>粗略滚动和Y中的粗略滚动</strong>确定所选名称表中图块的坐标。 这是当前要绘制的图块。 <br><br>  <strong>沿Y的精确滚动</strong>包含一个0到7的值，该值确定当前图块内部像素线的当前垂直偏移量。 瓦片是边长为8像素的正方形。 <br><br> 该寄存器中没有在<strong>X上的精确滚动</strong> 。 有一个单独的寄存器，仅包含当前像素的水平偏移，但是对于解释《塞尔达传说》中如何执行垂直滚动并不重要。 <br><br> 游戏写入<code>PPUADDR</code>时，此寄存器会发生什么情况？ 这是上面演示中的前三个写操作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br> 通过将地址中的条目分为滚动组件，您可以清楚地了解此处发生的情况。 每两帧， <strong>Y中</strong>的“ <strong>粗略滚动”</strong>的值减小，从而导致垂直滚动一格或8像素。 <br><br> 在整个帧中，初始滚动偏移为0.0，此后在该地址上在像素线63上进行记录。 这意味着从包含界面背景的所选名称表的顶部开始绘制前63行像素。 但是，从该地址开始垂直滚动会进一步渲染第64行像素。 由于垂直滚动每两帧减少一次，因此可以感觉到部分屏幕的垂直滚动。 <br><br><h3> 向下滚动以向上滚动 </h3><br>  《塞尔达传说》无法完全对玩家隐藏这一招。 它会在屏幕的垂直过渡上创建可见的伪像，如果您仔细观察的话会很明显。 在房间之间移动时，滚动动画的第一帧将向下滚动。 这是慢动作的动画。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br> 在名称表中，您可以看到实际发生的情况。 尽管在玩家看来，可见区域将平滑向上滚动，但滚动过渡是通过将可见区域从名称的左上表移动到包含房间背景副本的左下表开始的。 这是必需的，因为屏幕顶部的界面也是名称表的一部分，并且如果可见区域从其原始位置向上滚动，它将通过界面。 <br><br> 垂直滚动是通过写入帧中间的<code>PPUADDR</code>寄存器实现的。 要写入的第一个值是<code>0x2800</code> 。 两帧后， <code>0x23A0</code>记录<code>0x23A0</code> ，然后该值开始每第二帧减少32。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br> 将值<code>0x2800</code>写入<code>0x2800</code>寄存器<code>0x2800</code> <code>PPUADDR</code> <strong>表</strong> <code>PPUADDR</code>为2，这将呈现左下方的名称表。 由于两个滚动值均为0，因此它将从此名称表的左上图块开始。 但是， <strong>Y中的“精确滚动”</strong>为2，因此距左下角名称表的顶部有两个像素的垂直偏移。 这就是为什么在过渡的第一帧中，我们在屏幕底部看到一个2像素高的黑条。 过渡动画的初始滚动值向下移动2个像素，以使过渡无缝。 <br><br> 两帧后，将<code>PPUADDR</code>写入<code>0x23A0</code> 。 这将我们带回到名称的左上表，并从第29行图块（即底部）进行渲染。  <strong>在Y中精确滚动</strong>仍包含2。 <br><br> 为什么必须<strong>将“精确滚动”设置</strong>为2？ 为什么游戏不只写<code>0x0800</code>和<code>0x03A0</code>以免遭受两个像素的偏移？ <br><br> 四个名称表从<code>0x2000</code>到<code>0x2FFF</code>占据了PPU地址空间中4 KB的区域。 该表中的每个图块都占用一个视频字节的内存（实际上，它们只是另一个表中的索引），并且图块和名称表在视频内存中的顺序是这样的： <strong>选择名称表，</strong> <strong>按Y</strong>进行<strong>粗略滚动</strong>和<strong>按X</strong>进行<strong>粗略滚动</strong>构成了图块内部的偏移量具有名称表的存储区。 也就是说，取内部PPU寄存器的低12位并将它们加到<code>0x2000</code> ，您可以在视频存储器中找到<code>0x2000</code>地址。 这不是巧合！ 这正是应该处理该寄存器的方式：既作为地址寄存器又作为滚动寄存器。 <br><br> 但是有一个缺陷。 <br><br> 当作为地址寄存器处理时，位12和13被认为是地址的一部分。 在渲染期间，PPU会不断用当前渲染图块的地址覆盖寄存器。 由于图块位于名称表中，并且这些表位于从<code>0x2000</code>到<code>0x2FFF</code>的存储区中，因此PPU将从此间隔中的值分配给寄存器。 <br><br> 当游戏在帧的中间写入<code>PPUADDR</code>时，如果它没有在名称表中写下平铺地址，则PPU将尝试<em>从</em>视频内存中的<em>其他位置</em>读取。 他碰巧要计数的任何字节都将被视为图块，这很可能导致不良结果。 因此，记录在<code>PPUADDR</code>帧中间的所有值<code>PPUADDR</code>必须在<code>0x2000</code>到<code>0x2FFF</code>范围内。 考虑此间隔中的每个数字并考虑其滚动成分， <strong>Y中</strong>的“ <strong>精确”滚动</strong>值应始终等于2。 <br><br> 此限制意味着我们无法在帧中间更改<strong>Y</strong>方向上的<strong>精确滚动</strong> ，即使用此技巧实现屏幕分离的垂直滚动时，我们仅限于一次滚动8个像素，并且始终与图块边框之间有两个像素的垂直偏移量。  《塞尔达传说》在水平滚动时每帧移动4个像素，在垂直滚动时每帧移动8像素，现在我们知道为什么。 <br><br> 在各个房间之间向下滚动时，该伪像也很明显，但是在这种情况下，它出现在动画的结尾。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2> 补充阅读 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NesDev Wiki</a>是学习NES硬件的宝贵资源。 特别是，本文的主题是有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">滚动PPU的</a>页面 <br> 和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PPU寄存器</a> 。 </li><li> 我尚未完成的NES模拟器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>可用。 </li></ul><br><h2> 注意事项 </h2><br> 在我发现PPU的内部寄存器之前，我的仿真器展示了在《塞尔达传说》屏幕垂直过渡期间擦除的效果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  Link的sprite确实应在屏幕上向下移动，但背景并未滚动。 删除是由于游戏逐渐更新名称表，使其包含新游戏室的图形，但并未更新滚动条以使更新不显示在屏幕上。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460383/">https://habr.com/ru/post/zh-CN460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460367/index.html">混沌工程：故意破坏的艺术。 第一部分</a></li>
<li><a href="../zh-CN460373/index.html">深入了解Turbo页面：网页快速下载技术的体系结构</a></li>
<li><a href="../zh-CN460375/index.html">图书“面向企业和营销的机器学习”</a></li>
<li><a href="../zh-CN460377/index.html">使用Liquibase在Spring Boot应用程序中管理数据库结构。 第一部分</a></li>
<li><a href="../zh-CN460381/index.html">什么是自信，为什么需要自信</a></li>
<li><a href="../zh-CN460387/index.html">SELinux入门指南</a></li>
<li><a href="../zh-CN460393/index.html">背景：Fedora Silverblue的期望</a></li>
<li><a href="../zh-CN460395/index.html">分析功能：在Plesk中处理数据的过程</a></li>
<li><a href="../zh-CN460397/index.html">WebComponents快速入门</a></li>
<li><a href="../zh-CN460399/index.html">Vue.js上的SVG加载指示器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>