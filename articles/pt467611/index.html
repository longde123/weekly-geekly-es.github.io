<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏿 👸🏽 🚎 Algoritmos de detecção de contorno de imagem 👩🏻‍🏭 🧑🏻 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo apresenta os quatro algoritmos de detecção de loop mais comuns. 

 Os dois primeiros, ou seja, o algoritmo para rastrear quadrados e rastrear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de detecção de contorno de imagem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  O artigo apresenta os quatro algoritmos de detecção de loop mais comuns. <br><br>  Os dois primeiros, ou seja, o algoritmo para rastrear quadrados e rastrear os arredores de Moore, são fáceis de implementar e, portanto, são frequentemente usados ​​para determinar o contorno de um determinado padrão.  Infelizmente, ambos os algoritmos têm várias fraquezas, o que torna <b>impossível</b> detectar o contorno de uma grande classe de padrões devido ao seu tipo especial de adjacência. <br><br>  Esses algoritmos ignoram todos os <b><i>"buracos"</i></b> no padrão.  Por exemplo, se tivermos um padrão semelhante ao mostrado na <b><i>Figura 1</i></b> , o circuito detectado pelos algoritmos será semelhante ao mostrado na <b><i>Figura 2</i></b> (o contorno é indicado por pixels azuis).  Em algumas áreas de aplicação, isso é bastante aceitável, mas em outras, por exemplo, no reconhecimento de caracteres, é necessária a detecção das partes internas de um padrão para encontrar todos os espaços que distinguem um caractere específico.  (A <b><i>Figura 3</i></b> mostra o contorno “completo” do padrão.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="imagem"></div><br><br>  Portanto, para obter um contorno completo, primeiro é necessário usar o algoritmo de <b><i>“busca de furo”</i></b> que determina os furos em um determinado padrão e, em seguida, aplicar o algoritmo de detecção de contorno a cada furo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="imagem"></div><a name="habracut"></a><br><h2>  O que é conectividade? </h2><br>  Em imagens digitais com valores binários, um pixel pode ter um dos seguintes valores: 1 - quando faz parte do padrão, ou 0 - quando faz parte do plano de fundo, ou seja,  sem gradação de cinza.  (Vamos supor que pixels com o valor 1 sejam pretos e com o valor 0 sejam brancos). <br><br>  Para identificar <b><i>objetos</i></b> em um padrão digital, precisamos encontrar grupos de pixels pretos que estão "conectados" entre si.  Em outras palavras, os <b><i>objetos</i></b> em um determinado padrão digital são os <b><i>componentes conectados</i></b> desse padrão. <br><br>  No caso geral, um <b><i>componente conectado</i></b> é um conjunto de pixels pretos <b>P</b> , de modo que, para cada par de pixels <b>pi</b> e <b><sub>pj</sub></b> em <b>P,</b> haja uma sequência de pixels <b><i>pi, ..., <sub>pj, de</sub></i></b> modo que: <br><br>  a) todos os pixels na sequência estão no conjunto <b>P</b> , ou seja,  são pretos e <br><br>  b) a cada 2 pixels <b><i>na sequência</i></b> um <b><i>ao lado do outro</i></b> são "vizinhos". <br><br>  Uma questão importante surge: <b><i>quando podemos dizer que 2 pixels são “vizinhos”?</i></b>  Como usamos pixels quadrados, a resposta à pergunta anterior não é trivial pelo seguinte motivo: no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico quadrado, os</a> pixels têm uma aresta ou um vértice comum ou nada em comum.  Cada pixel tem 8 pixels em comum;  esses pixels compõem o "bairro Moore" desse pixel.  Devemos considerar os pixels "vizinhos" tendo apenas um vértice comum?  Ou para ser considerado "vizinho", dois pixels devem ter uma borda comum? <br><br>  Portanto, existem dois tipos de conectividade, a saber: conexão 4 e conexão 8. <br><br><h4>  4 conexões </h4><br>  Quando podemos dizer que um determinado conjunto de pixels pretos está <b><i>conectado 4?</i></b>  Primeiro, você precisa definir o conceito de <b><i>4 vizinhos</i></b> (também chamado de <b><i>vizinho direto</i></b> ): <br><br>  <b>Definição de 4 vizinhos</b> : Um pixel <b>Q</b> é um <b><i>4 vizinho de um</i></b> determinado pixel <b>P</b> se <b>Q</b> e <b>P</b> tiverem uma aresta comum.  Os 4 vizinhos do pixel <b>P</b> (designados como <b>P2, P4, P6</b> e <b>P8</b> ) são mostrados na <b><i>Figura 2</i></b> abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Definição de um componente conectado a 4</b> : o conjunto de pixels pretos <b>P</b> é um <b><i>componente conectado</i></b> a <b><i>4</i></b> se, para cada par de pixels <b>p <sub>i</sub></b> e <b>p <sub>j</sub></b> em <b>P,</b> houver uma sequência de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que: <br><br>  a) todos os pixels na sequência estão no conjunto <b>P</b> , ou seja,  são pretos e <br><br>  b) a cada dois pixels <b><i>adjacentes na sequência</i></b> são <b><i>4 vizinhos</i></b> <br><br><h4>  Exemplos de 4 padrões conectados </h4><br>  Os diagramas abaixo mostram exemplos de 4 padrões conectados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8 conexões </h4><br>  Quando posso dizer que um determinado conjunto de pixels pretos está <b><i>8 conectado</i></b> ?  Primeiro, precisamos definir o conceito de <b><i>8 vizinhos</i></b> (também chamado de <b><i>vizinho indireto</i></b> ): <br><br>  <b>Definição de 8 vizinhos</b> : Um pixel <b>Q</b> é um <b><i>8 vizinhos</i></b> (ou apenas um <b><i>vizinho</i></b> ) de um determinado pixel <b>P</b> se <b>Q</b> e <b>P</b> tiverem uma aresta ou vértice comum.  Os 8 vizinhos de um determinado pixel <b>P</b> formam o bairro Moore desse pixel. <br><br>  <b>Definição de um componente conectado a 8</b> : o conjunto de pixels pretos <b>P</b> é um <b><i>componente conectado a 8</i></b> (ou apenas um <b><i>componente conectado</i></b> ) se, para cada par de pixels <b>p <sub>i</sub></b> e <b>p <sub>j</sub></b> em <b>P,</b> houver uma sequência de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que : <br><br>  a) todos os pixels na sequência estão no conjunto <b>P</b> , ou seja,  são pretos e <br><br>  b) a cada dois pixels <b><i>adjacentes nessa sequência</i></b> são <b><i>8 vizinhos</i></b> <br><br>  <b>Nota</b> : todos os padrões de 4 conexões são 8, ou seja,  Os padrões com 4 conexões são um subconjunto dos muitos padrões com 8 conexões.  Por outro lado, um padrão conectado a 8 pode não estar conectado a 4. <br><br><h4>  Exemplo de padrão com 8 links </h4><br>  O diagrama abaixo mostra um padrão que está 8 conectado, mas não 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Um exemplo de um padrão não conectado a 8: </h4><br>  O diagrama abaixo mostra um exemplo de um padrão que não está conectado 8, ou seja,  composto por mais de um componente conectado (o diagrama mostra três componentes conectados): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algoritmo de traço quadrado </h2><br><h4>  Idéia </h4><br>  A idéia por trás do algoritmo de rastreamento quadrado é muito simples;  isso pode ser atribuído ao fato de o algoritmo ter sido uma das primeiras tentativas de detectar o contorno de um padrão binário. <br><br>  Para entender como funciona, você precisa de um pouco de imaginação ... <br><br>  Suponha que tenhamos um padrão digital, por exemplo, um grupo de pixels pretos em um fundo de pixels brancos, ou seja,  na grade;  encontre o pixel preto e declare-o como nosso pixel " <b>inicial</b> ".  (Encontrar o pixel " <b>inicial</b> " pode ser implementado de várias maneiras; começaremos do canto inferior esquerdo da grade, digitalizaremos cada coluna de pixels de baixo para cima, da coluna da esquerda para a direita, até encontrarmos um pixel preto. Nós o declararemos " <b>inicial</b> " ".) <br><br>  Agora imagine que você é uma joaninha no pixel <b>inicial</b> , como mostra a <b><i>Figura 1</i></b> abaixo.  Para obter o esboço de um padrão, faça o seguinte: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Os pixels pretos que você circulou serão o contorno do padrão. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Um aspecto importante do algoritmo de traço quadrado é o "senso de direção".  As curvas à esquerda e à direita são realizadas em relação à localização atual, que depende de como você chegou ao pixel atual.  Portanto, para fazer os movimentos certos, você precisa acompanhar sua direção. <br><br><h4>  Algoritmo </h4><br>  A seguir, é apresentada uma descrição formal do algoritmo de rastreamento quadrado: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico</a> quadrado, <b>T</b> , contendo o componente <b>P</b> conectado <b>de</b> células pretas. <br><br>  Saída: linha <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> de pixels da borda, ou seja,  contorno. <br><br>  Iniciar <br><br><ul><li>  Defina <b>B</b> como um conjunto vazio. </li><li>  Digitalize as células <b>T</b> de baixo para cima e da esquerda para a direita até encontrar um pixel preto <b>s</b> de <b>P.</b> </li><li>  Inserir <b>s</b> em <b>B.</b> </li><li>  Torne o pixel atual <b>p o</b> pixel inicial <b>s</b> . </li><li>  Vire à esquerda, ou seja,  vá para o pixel vizinho à esquerda de <b>p</b> . </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li><li>  Enquanto <b>p</b> não <b>for</b> igual a <b>s</b> , execute <br><br>  Se o pixel atual <b>p</b> for preto <br><ul><li>  insira <b>p</b> em <b>B</b> e vire à esquerda (vá para o pixel vizinho à esquerda de <b>p</b> ). </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li></ul><br>  caso contrário <br><ul><li>  vire à direita (vá para o próximo pixel à direita de <b>p</b> ). </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li></ul><br>  Fim do ciclo de "tchau" </li></ul><br>  O fim <br><br>  <b>Nota: os</b> conceitos de "esquerda" e "direita" devem ser considerados não com relação à página ou ao leitor, mas com relação à direção de entrada no pixel "atual" durante a digitalização. <br><br><h4>  Demonstração </h4><br>  A seguir, é apresentada uma demonstração animada de como o algoritmo de rastreamento quadrado detecta o contorno de um padrão.  Não esqueça que a joaninha se move em pixels;  observe como sua direção muda ao virar à esquerda e à direita.  As curvas à esquerda e à direita são realizadas em relação à direção atual em um pixel, ou seja,  orientação joaninha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Análise </h4><br>  Acontece que os recursos do algoritmo de rastreamento quadrado são muito limitados.  Ele é incapaz de detectar os contornos de uma grande família de padrões que frequentemente surgem em aplicações do mundo real. <br><br>  Isso se deve principalmente ao fato de as rotações esquerda e direita não levarem em consideração os pixels localizados “ao longo <br>  diagonais "do pixel atual. <br><br>  Vamos examinar os diferentes padrões com conectividade diferente e ver por que o algoritmo de rastreamento quadrado falha.  Além disso, estudaremos maneiras de melhorar os recursos do algoritmo e fazê-lo funcionar mesmo com padrões que possuem um tipo especial de conectividade. <br><br><h4>  Critério de parada </h4><br>  Uma das fraquezas do algoritmo é a escolha do critério de parada.  Em outras palavras, quando um algoritmo para de executar? <br><br>  Na descrição original do algoritmo de rastreamento quadrado, a condição de conclusão é atingir o pixel <b>inicial</b> pela segunda vez.  Acontece que, se o algoritmo depende de tal critério, não será capaz de detectar os contornos de uma grande família de padrões. <br><br>  A seguir, uma demonstração animada explicando como o algoritmo não consegue detectar o contorno exato do padrão devido à seleção de um critério de parada incorreto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Como você pode ver, melhorar o critério de parada pode ser um bom começo para melhorar o desempenho geral do algoritmo.  Existem duas alternativas eficazes para um critério de desligamento existente: <br><br>  a) Pare apenas visitando o pixel <b>inicial</b> <b><i>n</i></b> vezes, em que n é pelo menos 2, OU <br><br>  b) Pare depois de pressionar o pixel <b>inicial</b> pela segunda vez, exatamente como o atingimos inicialmente. <br><br>  Este critério foi proposto por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jacob Eliosoff</a> , então o chamaremos de <b><i>critério para interromper Jacob</i></b> . <br><br>  A alteração do critério de parada no caso geral melhora a eficácia do algoritmo de rastreio quadrado, mas não supera outros pontos fracos que possui no caso de padrões com tipos especiais de conectividade. <br><br>  O algoritmo de rastreamento quadrado não consegue detectar o contorno de uma família de padrões com uma conectividade 8 que NÃO possui uma conectividade 4. <br><br>  A seguir, é apresentada uma demonstração animada de como o algoritmo de rastreamento quadrado (com o critério de parada de Jacob) falha ao detectar o contorno correto de um padrão com conectividade 8 sem conectividade 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Esse algoritmo é completamente inútil? </h2><br>  Se você ler a análise acima, provavelmente acha que o algoritmo de rastreamento quadrado falha ao detectar os contornos da maioria dos padrões.  Mas acontece.  que existe uma família especial de padrões em que o caminho é totalmente detectado pelo algoritmo de rastreamento quadrado. <br><br>  Seja <b>P</b> o conjunto de pixels pretos com conectividade 4 na grade.  Deixe os pixels brancos da grade, ou seja,  os pixels de fundo <b>W</b> também têm uma conectividade de 4. Acontece que nessas condições do padrão e de seu fundo, pode-se provar que o algoritmo de traço quadrado (com o critério de parada de Jacob) sempre lidará com êxito com a determinação do contorno. <br><br>  Abaixo está a prova de que, no caso em que o padrão e os pixels de fundo estão conectados, o algoritmo de traço quadrado determinará corretamente o contorno ao usar o critério de parada de Jacob. <br><br>  Prova <br>  <b>Dado</b> : o padrão <b>P é</b> tal que todos os pixels do padrão (ou seja, preto) e os pixels de fundo (ou seja, branco) W têm uma conectividade de 4. <br><br>  <b>Primeira observação</b> <br><br>  Como o conjunto de pixels brancos W tem uma conectividade 4, isso significa que não pode haver " <b><i>buracos</i></b> " no padrão (em termos informais, " <b><i>buracos</i></b> " queremos dizer grupos de pixels brancos completamente cercados por pixels pretos do padrão). <br><br>  A presença de qualquer " <b><i>buraco</i></b> " no padrão levará à separação do grupo de pixels brancos dos pixels brancos restantes;  no entanto, muitos pixels brancos perdem a conectividade 4. <br><br>  <i>A Figura 2</i> e a <b><i>Figura 3</i></b> abaixo mostram dois tipos de " <b><i>orifícios</i></b> " que podem ocorrer em um padrão com conectividade 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Segunda observação</b> <br><br>  Quaisquer dois pixels pretos de um padrão DEVEM ter um lado comum. <br><br>  Suponha que dois pixels pretos tenham apenas um vértice comum.  Então, para satisfazer a propriedade da conexão 4 do padrão, deve haver um caminho conectando esses dois pixels para que cada dois pixels adjacentes nesse caminho tenham uma conectividade 4. Mas isso nos dará um padrão semelhante à <b><i>Figura 3</i></b> .  Em outras palavras, isso resultará na separação de pixels brancos.  <b><i>A Figura 4</i></b> abaixo mostra um padrão típico que satisfaz a suposição de que os pixels no padrão e no plano de fundo estão conectados em 4, ou seja,  não tem " <b><i>buracos</i></b> " e a cada dois pixels pretos tem um lado comum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  É útil representar esses padrões da seguinte maneira: <br><br>  Primeiro, consideramos os pixels de limite, ou seja,  contorno do padrão.  Então, se considerarmos que cada pixel de limite possui 4 arestas de comprimento unitário, veremos que algumas dessas arestas são comuns aos pixels brancos vizinhos.  Vamos chamar essas arestas de arestas de <b><i>fronteira</i></b> . <br><br>  Essas arestas de limite podem ser consideradas como arestas de um polígono.  Na <b><i>foto</i></b> <b><i><br></i></b>  <b><i>5</i></b> abaixo, essa ideia é demonstrada pelo exemplo de um polígono correspondente ao padrão da <b><i>Figura 4</i></b> acima: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Se considerarmos todas as “configurações” possíveis de pixels de contorno que podem ocorrer em tais padrões, veremos que existem dois casos simples, mostrados na <b><i>Figura 6</i></b> e na <b><i>Figura 7</i></b> abaixo. <br><br>  Os pixels de limite podem ser múltiplos desses casos ou de outros arranjos, ou seja,  as voltas e reviravoltas desses dois casos.  As nervuras de limite estão marcadas em azul como <b>E1, E2, E3</b> e <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Terceira observação</b> <br><br>  No caso dos dois casos acima, não importa qual seja o pixel inicial que escolhemos, e em qualquer direção em que ele <b>caia</b> , o algoritmo de rastreamento quadrado nunca <b>"voltará" (retrocesso)</b> , nunca <b>"passará" pela</b> <i>borda</i> <b>do</b> <i>limite</i> duas vezes ( somente se não rastrear a borda uma segunda vez) e nunca errar a <b><i>borda da borda</i></b> .  Confira! <br><br>  Dois conceitos precisam ser esclarecidos aqui: <br><br>  a) o algoritmo <b>“volta”</b> quando, antes de rastrear toda a borda, volta a visitar um pixel já visitado, e <br><br>  b) para cada <b><i>nervura limite,</i></b> há duas maneiras de <b>"passar por ela"</b> , a saber, "interna" e "externa" (onde "interna" refere-se ao movimento para dentro do polígono correspondente e "externa" - para fora do polígono). <br><br>  Além disso, quando o algoritmo passa "para dentro" através de uma das bordas do limite, ele passa "para fora" pela próxima borda do limite, ou seja,  o algoritmo de rastreamento quadrado não deve ser capaz de passar por duas arestas consecutivas da mesma maneira. <br><br>  <b>Última observação</b> <br><br>  Cada padrão possui um <b>número par de</b> <b>arestas</b> <b>de</b> <b>limite</b> . <br><br>  Se você observar o polígono da <b><i>Figura 5</i></b> , poderá ver que: <br><br>  se queremos começar do vértice <b>S</b> marcado no diagrama e seguir as arestas do limite até chegarmos a <b>S</b> novamente, notamos que no processo cruzamos um número par de arestas do limite.  Podemos considerar cada aresta de fronteira como um "passo" em uma direção separada.  Então, para cada "passo" à direita, deve haver um "passo" correspondente à esquerda, se quisermos retornar à posição inicial.  O mesmo se aplica aos "degraus" verticais.  Portanto, as "etapas" devem ter pares correspondentes, e isso explica por que cada um desses padrões terá um número par de arestas de limite. <br><br>  Portanto, quando o algoritmo para rastrear quadrados entra pela <b>borda do limite inicial</b> (do pixel inicial) uma segunda vez, ele o faz na <b>mesma</b> direção da primeira vez. <br><br>  A razão para isso é que, como existem duas maneiras de atravessar a borda do limite, e o algoritmo se move alternadamente para dentro e para fora, e há um número par de bordas do limite, o algoritmo passará pela borda do limite inicial pela segunda vez da mesma maneira que em primeiro. <br><br><h4>  Conclusão </h4><br>  No caso de um padrão e fundo de 4 conexões, o algoritmo de rastreamento quadrado detectará toda a borda, ou seja,  contorno, padrão e deixará de funcionar após um único traço, ou seja,  Ele não o rastreará novamente, porque quando atingir a <b>borda do limite inicial</b> pela segunda vez, entrará na mesma maneira que na primeira vez.  Consequentemente, o algoritmo de rastreio quadrado com o critério de parada de Jacob determinará corretamente o contador de qualquer padrão, desde que o padrão e o plano de fundo estejam conectados 4. <br><br><h2>  Rastreando os arredores de Moore </h2><br><h4>  Idéia </h4><br>  A idéia por trás do rastreamento Moore-Neighbour é simples;  mas antes de explicá-lo, precisamos explicar um conceito importante: <b><i>o bairro Moore de um</i></b> pixel. <br><br><h4>  O bairro de Moore </h4><br>  A vizinhança de Moore de um pixel <b>P</b> é um conjunto de 8 pixels com um vértice ou aresta comum com esse pixel.  Esses pixels, nomeadamente <b>P1, P2, P3, P4, P5, P6, P7 e P8</b> , são mostrados na <b><i>Figura 1</i></b> . <br><br>  O bairro de Moore (também chamado de <b><i>8 vizinhos</i></b> ou <b><i>vizinhos</i></b> <b><i>indiretos</i></b> ) é um conceito importante frequentemente referido na literatura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Agora, estamos prontos para nos familiarizar com a ideia subjacente aos vestígios dos arredores de Moore. <br><br>  Que haja um padrão digital, ou seja,  um grupo de pixels pretos, em um fundo de pixels brancos, ou seja,  na grade;  encontre o pixel preto e declare-o <b>o</b> pixel " <b>inicial</b> ".  (Existem várias maneiras de encontrar o pixel " <b>inicial</b> ", mas, como antes, começaremos do canto inferior esquerdo e digitalizaremos todas as colunas de pixels em ordem, até encontrarmos o primeiro pixel preto, que declararemos " <b>inicial</b> ".) <br><br>  Agora, novamente, imagine que você é uma joaninha no pixel <b>inicial</b> , como mostra a <b><i>Figura 2</i></b> abaixo.  Sem perda de generalização, detectaremos o contorno movendo-se no padrão no sentido horário.  (Não importa em que direção escolhemos, o principal é usá-lo constantemente no algoritmo). <br><br>  A idéia geral é a seguinte: toda vez que entramos no pixel preto <b>P</b> , voltamos, isto é, ao pixel branco em que estávamos antes.  Em seguida <b>,</b> contornamos o pixel <b>P</b> no sentido horário, visitando todos os pixels nas proximidades de Moore, até chegarmos ao pixel preto.  O algoritmo termina quando o pixel inicial atinge o pixel inicial uma segunda vez. <br><br>  Os pixels pretos que o algoritmo visitou serão o contorno do padrão. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algoritmo </h4><br>  A seguir, é apresentada uma descrição formal do algoritmo de rastreamento de vizinhança de Moore: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico</a> quadrado <b>T</b> contendo um componente <b>P</b> conectado de células pretas. <br><br>  Saída: linha <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) de</b> pixels <b>de</b> limite, ou seja,  contorno. <br><br>  Denote por <b>M (a)</b> a vizinhança de Moore do pixel <b>a</b> . <br><br>  Seja <b>p</b> o pixel atual da borda. <br><br>  Seja <b>c</b> o pixel atual em consideração, ou seja,  <b>c</b> está em <b>M (p)</b> . <br><br>  Iniciar <br><br><ul><li>  Defina <b>B</b> como um conjunto vazio. </li><li>  De baixo para cima e da esquerda para a direita, digitalize as células <b>T</b> até encontrarmos um pixel preto <b>s</b> de <b>P.</b> </li><li>  Inserir <b>s</b> em <b>B.</b> </li><li>  Definimos o ponto <b>s</b> como o ponto limite atual <b>p</b> , ou seja,  <b>p = s</b> </li><li>  Vamos voltar, ou seja,  vamos para o pixel do qual viemos <b>s</b> . </li><li>  Seja <b>c o</b> próximo pixel no sentido horário em <b>M (p)</b> . </li><li>  Enquanto <b>c</b> não <b>for</b> igual a <b>s</b> , execute <br><br><ul><li>  se <b>c</b> é preto <br><ul><li>  Inserir <b>c</b> em <b>B</b> </li><li>  estabelecemos <b>p = c</b> </li><li>  voltar (mover o pixel atual <b>c</b> para o pixel a partir do qual chegamos a <b>p</b> ) </li></ul><br>  caso contrário <br><ul><li>  mova o pixel atual <b>c</b> para o próximo pixel no sentido horário em <b>M (p)</b> </li></ul><br>  Fim do ciclo de adeus </li></ul></li></ul><br>  O fim <br><br><h4>  Demonstração </h4><br>  A seguir, uma demonstração animada de como o rastreamento de vizinhança de Moore realiza a detecção de contornos de padrão.  (Decidimos traçar o contorno no sentido horário.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Análise </h4><br>  A principal fraqueza em rastrear os arredores de Moore reside na escolha de critérios de parada. <br><br>  Na descrição original do algoritmo para rastrear os arredores de Moore, o critério de parada é atingir o pixel <b>inicial</b> pela segunda vez.  Semelhante ao algoritmo de rastreamento quadrado, verifica-se que o rastreamento dos arredores de Moore usando esse critério não pode detectar os contornos de uma grande família de padrões. <br><br>  A seguir, uma demonstração animada explicando por que o algoritmo não consegue encontrar o contorno exato do padrão devido à seleção de um critério de parada incorreto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Como você pode ver, melhorar o critério de parada pode ser um bom começo para melhorar o desempenho geral do rastreamento.  Existem duas alternativas efetivas para o critério de desligamento, semelhante ao critério de desligamento de Jacob. <br><br>  O uso do critério Jacob melhora significativamente a eficácia do rastreamento dos arredores de Moore, tornando-o o melhor algoritmo para determinar o contorno de qualquer padrão, independentemente de sua conectividade. <br><br>  A razão para isso é principalmente porque o algoritmo verifica toda a vizinhança de Moore do pixel de limite para procurar o próximo pixel de limite.  Ao contrário do algoritmo de traço quadrado, que gira apenas para a esquerda e para a direita e perde os pixels "na diagonal", o traçado da vizinhança de Moore sempre será capaz de detectar o limite externo de qualquer componente conectado.  A razão é a seguinte: para qualquer padrão de <b><i>8 conexões</i></b> (ou simplesmente <b><i>conectado</i></b> ), o <b>próximo</b> pixel de borda fica dentro do bairro Moore do atual pixel de borda.  Como o rastreamento de vizinhança de Moore verifica cada um dos pixels na vizinhança de Moore do pixel de limite atual, ele deve detectar o próximo pixel de limite. <br><br>  Quando o rastreio da vizinhança de Mura atinge o pixel inicial uma segunda vez da mesma maneira que ela fez na primeira vez, isso significa que um <b>contorno externo</b> <b>completo</b> <b>do</b> padrão foi detectado e, se o algoritmo não for parado, ele detectará novamente o mesmo contorno. <br><br><h2>  Varredura radial </h2><br>  O algoritmo de varredura radial é um algoritmo de detecção de contorno discutido em alguns livros.  Apesar do nome complexo, a ideia subjacente é muito simples.  De fato, verifica-se que o algoritmo de varredura radial <b>é idêntico ao</b> traço do entorno de Moore.  Alguém pode perguntar: "Por que o mencionamos?" <br><br>  O rastreamento dos arredores de Moore procura nas proximidades de Moore o pixel de limite atual em uma determinada direção (escolhemos a direção no sentido horário) até encontrar um pixel preto.  Ela então declara esse pixel como o limite atual e continua. <br><br>  O algoritmo de varredura radial faz o mesmo.  Por outro lado, fornece uma maneira interessante de encontrar o próximo pixel preto na vizinhança de Moore de um determinado pixel de limite. <br><br>  O método é baseado na seguinte ideia: <br><br>  toda vez que encontrarmos um novo pixel de limite, torne-o o pixel atual <b>P</b> e desenhe <b>um segmento de linha imaginário</b> conectando <b>P</b> ao pixel de limite <b>anterior</b> .  Em seguida, <b>giramos o</b> segmento em relação a <b>P</b> no sentido horário até encontrar um pixel preto na vizinhança de Moore do pixel <b>P.</b>  A rotação da linha é idêntica à verificação de cada pixel nas proximidades de Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos uma demonstração animada de como o algoritmo de varredura radial funciona e como ele parece rastrear os arredores de Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E quando o algoritmo de varredura radial para? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos explicar o comportamento do algoritmo usando os seguintes critérios de parada ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Critério de parada 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deixe o algoritmo de varredura radial completo quando visitar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pela segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo está uma demonstração animada, da qual fica claro por que o critério de quebra será alterado corretamente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também vale a pena mencionar que, ao usar esse critério de parada nos dois algoritmos, a eficácia do algoritmo de varredura radial é idêntica à localização dos arredores de Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No algoritmo de rastreamento quadrado e no rastreamento de vizinhança de Moore, descobrimos que o uso do critério de parada de Jacob melhora significativamente o desempenho de ambos os algoritmos. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O critério de parada de Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exige que o algoritmo pare de executar quando visita o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pela segunda vez na mesma direção da primeira vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, não podemos usar o critério de parada de Jacob no algoritmo de varredura radial. O motivo é que o algoritmo de varredura radial não define o conceito</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A "direção" na qual ele atinge o pixel de limite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em outras palavras, não está clara a “direção” na qual o algoritmo caiu no pixel de limite (e sua definição é não trivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, precisamos propor outro critério de parada, que não depende da direção de atingir um pixel específico, o que pode melhorar a eficácia do algoritmo de varredura radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Critério de parada 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que cada vez que o algoritmo detecte um novo pixel de limite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ele seja inserido em uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">série de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> limite: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; e declarado como o pixel da borda atual. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consideraremos o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Isso significa que conhecemos o pixel da borda anterior </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 de</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada pixel da borda atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Quanto ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , assumiremos que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é um pixel imaginário que não é equivalente a nenhum dos pixels na grade que enfrenta o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na linha de pixels de limite). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadas as premissas acima, podemos determinar o critério de parada da seguinte forma: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo termina a execução quando: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) a corrente de pixel limite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> já </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anteriormente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se reuniu como um pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (onde </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) na série de pixels de contorno, e </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em outras palavras, o algoritmo conclui a execução quando visita o pixel limite P no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vezes se o pixel de limite antes de P (na linha de pixels de limite) pela segunda vez for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel que era antes de P quando P foi visitado pela </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a condição do critério de parada for atendida e o algoritmo não for desligado, o algoritmo de varredura radial continuará a detectar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite pela segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O desempenho do algoritmo de varredura radial com esse critério de parada é semelhante ao desempenho de rastrear a vizinhança de Moore com o critério de parada de Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo de Theo Pavlidis </font></font></h2><br><h4>  Idéia </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este algoritmo é um dos mais recentes algoritmos de detecção de loop propostos por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ele o citou em seu livro de 1982, </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmos para processamento de gráficos e imagens</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (capítulo 7, seção 5). Não é tão simples como o algoritmo para rastrear quadrados ou rastrear os arredores de Moore, mas não é tão complicado (isso é característico da maioria dos algoritmos de detecção de contorno). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não explicaremos esse algoritmo da mesma maneira que foi feito em seu livro. Nossa abordagem é mais fácil de entender e fornece uma idéia da ideia geral subjacente ao algoritmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem perda de generalização, decidimos dar a volta no loop no sentido horário para corresponder à ordem de todos os outros algoritmos apresentados no artigo. Por outro lado, Pavlidis escolheu a direção no sentido anti-horário. Isso não afetará o desempenho do algoritmo. A única diferença é a direção relativa dos movimentos que faremos quando contornarmos o contorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, vamos à ideia ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que temos um padrão digital, ou seja, um grupo de pixels pretos em um fundo de pixels brancos, ou seja, na grade; encontre o pixel preto e declare-o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel " </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> ". Você pode procurar o </font><font style="vertical-align: inherit;">pixel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " de várias maneiras, por exemplo, conforme descrito acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels para usar esse método é opcional. Em vez disso, escolheremos um </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que satisfaça as seguintes restrições impostas pelo algoritmo Pavlidis para a seleção de um pixel inicial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma limitação importante da direção na qual inserimos o pixel inicial</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Na verdade, você pode escolher QUALQUER pixel de borda preta como o pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sob esta condição: se você estiver inicialmente nele, o pixel vizinho esquerdo NÃO é preto. Em outras palavras, você precisa inserir o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em uma direção em que o pixel vizinho esquerdo seja branco (a "esquerda" aqui é obtida em relação à direção em que inserimos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora imagine que você é uma joaninha em pé</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> , como mostra a </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo. Durante a execução do algoritmo, estaremos interessados ​​em apenas três pixels à sua frente, ou seja, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrados na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Designaremos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à sua frente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o pixel à esquerda de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o pixel à direita de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no algoritmo de traço quadrado, a coisa mais importante no algoritmo Pavlidis é o "senso de direção". As curvas à esquerda e à direita são relativas à posição atual, que depende de como você inseriu o pixel atual. Portanto, para fazer os movimentos certos, é importante acompanhar sua orientação atual. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas não importa como você esteja localizado, os pixels P1, P2 e P3 são determinados conforme descrito acima.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com essas informações, estamos prontos para explicar o algoritmo ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada vez que você está no pixel de limite atual (que é o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> ), fazemos o seguinte: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verifique o pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o pixel de limite atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e dê um passo à frente e, em seguida, dê um passo à esquerda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para estar em P1 (a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordem dos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> movimentos é muito importante). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a seguir ilustra este processo. </font><font style="vertical-align: inherit;">O caminho para chegar ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é mostrado em azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E somente se P1 for branco, procederemos à verificação de P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declarar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel de limite atual e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avançar um passo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para estar em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este caso é mostrado na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo. </font><font style="vertical-align: inherit;">O caminho que você precisa seguir no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é mostrado em azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente se P1 e P2 forem brancos, verifique P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel atual da borda e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mova um passo para a direita e depois um passo para a esquerda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como mostra a Figura 4 abaixo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso é tudo!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Três regras simples para três casos simples. Como você pode ver, é importante acompanhar sua direção ao fazer curvas, porque todos os movimentos são feitos em relação à orientação atual. Mas parece que esquecemos alguma coisa? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se todos os três pixels estiverem brancos à nossa frente?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, giramos (em pé no atual limite do pixel) 90 graus no sentido horário para ver um novo conjunto de três pixels à nossa frente. Em seguida, fazemos a mesma verificação para esses novos pixels. Você ainda pode ter uma pergunta: e se todos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esses</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> três pixels forem brancos ?! Então, novamente, giramos 90 graus no sentido horário, permanecendo no mesmo pixel. Antes de verificar a vizinhança inteira do pixel de Moore, você pode girar três vezes (cada vez 90 graus no sentido horário).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se girarmos três vezes sem encontrar pixels pretos, isso significa que estamos em um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel isolado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , não conectado a nenhum outro pixel preto. </font><font style="vertical-align: inherit;">É por isso que o algoritmo permite que você gire três vezes e, em seguida, conclui sua execução. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro aspecto: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando o algoritmo completa a execução? </font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo termina em dois casos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) como mencionado acima. </font><font style="vertical-align: inherit;">o algoritmo permite que você gire três vezes (90 graus no sentido horário cada vez), depois de concluir a execução e declarar o pixel isolado OU </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) quando o pixel de limite atual é o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o algoritmo conclui a execução “declarando” que detectou o contorno do padrão.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, é apresentada uma descrição formal do algoritmo Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosaico</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quadrado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contendo um componente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conectado </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> células pretas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saída: linha </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> limite, ou seja, </font><font style="vertical-align: inherit;">contorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definições:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denuncie por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel do limite atual, ou seja, </font><font style="vertical-align: inherit;">o pixel em que estamos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 da</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seguinte maneira: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(veja também a Figura 1 acima)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o pixel à sua frente, adjacente àquele em que você está, ou seja, </font><font style="vertical-align: inherit;">com pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> —  ,   <b>P2</b> . </li><li> <b>P3</b> —  ,   <b>P2</b> . </li><li>  <b>«»</b>            . </li></ul><br>  Iniciar <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encerrar o programa e declarar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p um</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isolado</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> caso contrário </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire 90 graus no sentido horário, de pé no pixel atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até agora </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (finalize o loop de repetição)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O fim </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstração </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, é apresentada uma demonstração animada de como o algoritmo Pavlidis detecta o contorno de um determinado padrão. </font><font style="vertical-align: inherit;">Não esqueça que andamos em pixels; </font><font style="vertical-align: inherit;">observe como a orientação muda ao virar para a esquerda ou direita. </font><font style="vertical-align: inherit;">Para explicar o algoritmo com o máximo de detalhes possível, incluímos todos os casos possíveis.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Análise </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você acha que o algoritmo Pavlidis é ideal para detectar contornos de padrões, deve mudar de idéia ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse algoritmo é realmente um pouco mais complicado do que, por exemplo, rastrear os arredores de Moore, nos quais não há casos especiais que exijam processamento separado, mas não será capaz de determinar os contornos de um grande número. uma família de padrões que possui um certo tipo de conectividade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo funciona muito bem em padrões de 4 conexões. Seu problema ocorre ao rastrear alguns padrões conectados a 8 que não estão conectados a 4. A seguir, é apresentada uma demonstração animada de como o algoritmo Pavlidis falha ao detectar o contorno correto de um padrão de 8 conexões (e não de 4) - ele pula a maior parte da borda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras simples de modificar um algoritmo para melhorar significativamente seu desempenho. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Substitua o critério de parada</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em vez de concluir o algoritmo ao visitar o pixel inicial pela segunda vez, você pode finalizá-lo quando visitar o pixel inicial pela terceira ou quarta vez. Isso melhorará o desempenho geral do algoritmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OU </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Chegue à origem do problema, ou seja, antes de selecionar o pixel</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicial.Há uma limitação importante em relação à direção na qual a entrada no pixel inicial é realizada. Essencialmente, você precisa inserir o pixel inicial para que, quando você fique sobre ele, o pixel à sua esquerda seja branco. A razão para introduzir essa restrição é esta: como sempre olhamos para os três pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nossa </font><b><font style="vertical-align: inherit;">frente</font></b><font style="vertical-align: inherit;"> em</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma determinada ordem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em alguns padrões, pularemos o pixel de limite diretamente à esquerda do pixel inicial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corremos o risco de perder não apenas o pixel vizinho esquerdo do pixel inicial, mas também o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel diretamente abaixo dele</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (como demonstrado na análise). Além disso, em alguns padrões, um pixel correspondente ao pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo </font><font style="vertical-align: inherit;">será ignorado </font><font style="vertical-align: inherit;">. Portanto, assumimos que o pixel inicial precisa ser atingido em uma direção em que os pixels correspondentes aos pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrados na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo sejam brancos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, padrões como o mostrado na demonstração serão detectados corretamente e a eficácia do algoritmo Pavlidis melhorará significativamente. </font><font style="vertical-align: inherit;">Por outro lado, encontrar um pixel inicial que atenda a esses requisitos pode ser desafiador e, em muitos casos, será impossível encontrá-lo. </font><font style="vertical-align: inherit;">Nesse caso, você deve usar uma maneira alternativa de melhorar o algoritmo Pavlidis, ou seja, a conclusão do algoritmo depois de visitar o ponto de partida pela terceira vez.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467611/">https://habr.com/ru/post/pt467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467597/index.html">Personalizando as diretrizes de produtos de big data com o Vowpal Wabbit</a></li>
<li><a href="../pt467599/index.html">Renderização de gráficos 3D com OpenGL</a></li>
<li><a href="../pt467605/index.html">Tudo que você precisa é de URL</a></li>
<li><a href="../pt467607/index.html">Confissão do ódio dos estivadores</a></li>
<li><a href="../pt467609/index.html">Criando um aplicativo móvel no React Native</a></li>
<li><a href="../pt467615/index.html">Como criar wrapper Python e não enlouquecer</a></li>
<li><a href="../pt467617/index.html">Kaspresso: a estrutura de autoteste que você estava esperando</a></li>
<li><a href="../pt467619/index.html">Os jarros Aquafor são um bom exemplo de como os filtros para tratamento de água não podem ser projetados</a></li>
<li><a href="../pt467621/index.html">Encontro Elasticsearch Moscow em Ozon</a></li>
<li><a href="../pt467623/index.html">Reagir nativo: criando um campo de entrada animado usando a API animada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>