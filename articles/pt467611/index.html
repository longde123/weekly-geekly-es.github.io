<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèø üë∏üèΩ üöé Algoritmos de detec√ß√£o de contorno de imagem üë©üèª‚Äçüè≠ üßëüèª üóΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo apresenta os quatro algoritmos de detec√ß√£o de loop mais comuns. 

 Os dois primeiros, ou seja, o algoritmo para rastrear quadrados e rastrear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de detec√ß√£o de contorno de imagem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  O artigo apresenta os quatro algoritmos de detec√ß√£o de loop mais comuns. <br><br>  Os dois primeiros, ou seja, o algoritmo para rastrear quadrados e rastrear os arredores de Moore, s√£o f√°ceis de implementar e, portanto, s√£o frequentemente usados ‚Äã‚Äãpara determinar o contorno de um determinado padr√£o.  Infelizmente, ambos os algoritmos t√™m v√°rias fraquezas, o que torna <b>imposs√≠vel</b> detectar o contorno de uma grande classe de padr√µes devido ao seu tipo especial de adjac√™ncia. <br><br>  Esses algoritmos ignoram todos os <b><i>"buracos"</i></b> no padr√£o.  Por exemplo, se tivermos um padr√£o semelhante ao mostrado na <b><i>Figura 1</i></b> , o circuito detectado pelos algoritmos ser√° semelhante ao mostrado na <b><i>Figura 2</i></b> (o contorno √© indicado por pixels azuis).  Em algumas √°reas de aplica√ß√£o, isso √© bastante aceit√°vel, mas em outras, por exemplo, no reconhecimento de caracteres, √© necess√°ria a detec√ß√£o das partes internas de um padr√£o para encontrar todos os espa√ßos que distinguem um caractere espec√≠fico.  (A <b><i>Figura 3</i></b> mostra o contorno ‚Äúcompleto‚Äù do padr√£o.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="imagem"></div><br><br>  Portanto, para obter um contorno completo, primeiro √© necess√°rio usar o algoritmo de <b><i>‚Äúbusca de furo‚Äù</i></b> que determina os furos em um determinado padr√£o e, em seguida, aplicar o algoritmo de detec√ß√£o de contorno a cada furo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="imagem"></div><a name="habracut"></a><br><h2>  O que √© conectividade? </h2><br>  Em imagens digitais com valores bin√°rios, um pixel pode ter um dos seguintes valores: 1 - quando faz parte do padr√£o, ou 0 - quando faz parte do plano de fundo, ou seja,  sem grada√ß√£o de cinza.  (Vamos supor que pixels com o valor 1 sejam pretos e com o valor 0 sejam brancos). <br><br>  Para identificar <b><i>objetos</i></b> em um padr√£o digital, precisamos encontrar grupos de pixels pretos que est√£o "conectados" entre si.  Em outras palavras, os <b><i>objetos</i></b> em um determinado padr√£o digital s√£o os <b><i>componentes conectados</i></b> desse padr√£o. <br><br>  No caso geral, um <b><i>componente conectado</i></b> √© um conjunto de pixels pretos <b>P</b> , de modo que, para cada par de pixels <b>pi</b> e <b><sub>pj</sub></b> em <b>P,</b> haja uma sequ√™ncia de pixels <b><i>pi, ..., <sub>pj, de</sub></i></b> modo que: <br><br>  a) todos os pixels na sequ√™ncia est√£o no conjunto <b>P</b> , ou seja,  s√£o pretos e <br><br>  b) a cada 2 pixels <b><i>na sequ√™ncia</i></b> um <b><i>ao lado do outro</i></b> s√£o "vizinhos". <br><br>  Uma quest√£o importante surge: <b><i>quando podemos dizer que 2 pixels s√£o ‚Äúvizinhos‚Äù?</i></b>  Como usamos pixels quadrados, a resposta √† pergunta anterior n√£o √© trivial pelo seguinte motivo: no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico quadrado, os</a> pixels t√™m uma aresta ou um v√©rtice comum ou nada em comum.  Cada pixel tem 8 pixels em comum;  esses pixels comp√µem o "bairro Moore" desse pixel.  Devemos considerar os pixels "vizinhos" tendo apenas um v√©rtice comum?  Ou para ser considerado "vizinho", dois pixels devem ter uma borda comum? <br><br>  Portanto, existem dois tipos de conectividade, a saber: conex√£o 4 e conex√£o 8. <br><br><h4>  4 conex√µes </h4><br>  Quando podemos dizer que um determinado conjunto de pixels pretos est√° <b><i>conectado 4?</i></b>  Primeiro, voc√™ precisa definir o conceito de <b><i>4 vizinhos</i></b> (tamb√©m chamado de <b><i>vizinho direto</i></b> ): <br><br>  <b>Defini√ß√£o de 4 vizinhos</b> : Um pixel <b>Q</b> √© um <b><i>4 vizinho de um</i></b> determinado pixel <b>P</b> se <b>Q</b> e <b>P</b> tiverem uma aresta comum.  Os 4 vizinhos do pixel <b>P</b> (designados como <b>P2, P4, P6</b> e <b>P8</b> ) s√£o mostrados na <b><i>Figura 2</i></b> abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Defini√ß√£o de um componente conectado a 4</b> : o conjunto de pixels pretos <b>P</b> √© um <b><i>componente conectado</i></b> a <b><i>4</i></b> se, para cada par de pixels <b>p <sub>i</sub></b> e <b>p <sub>j</sub></b> em <b>P,</b> houver uma sequ√™ncia de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que: <br><br>  a) todos os pixels na sequ√™ncia est√£o no conjunto <b>P</b> , ou seja,  s√£o pretos e <br><br>  b) a cada dois pixels <b><i>adjacentes na sequ√™ncia</i></b> s√£o <b><i>4 vizinhos</i></b> <br><br><h4>  Exemplos de 4 padr√µes conectados </h4><br>  Os diagramas abaixo mostram exemplos de 4 padr√µes conectados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8 conex√µes </h4><br>  Quando posso dizer que um determinado conjunto de pixels pretos est√° <b><i>8 conectado</i></b> ?  Primeiro, precisamos definir o conceito de <b><i>8 vizinhos</i></b> (tamb√©m chamado de <b><i>vizinho indireto</i></b> ): <br><br>  <b>Defini√ß√£o de 8 vizinhos</b> : Um pixel <b>Q</b> √© um <b><i>8 vizinhos</i></b> (ou apenas um <b><i>vizinho</i></b> ) de um determinado pixel <b>P</b> se <b>Q</b> e <b>P</b> tiverem uma aresta ou v√©rtice comum.  Os 8 vizinhos de um determinado pixel <b>P</b> formam o bairro Moore desse pixel. <br><br>  <b>Defini√ß√£o de um componente conectado a 8</b> : o conjunto de pixels pretos <b>P</b> √© um <b><i>componente conectado a 8</i></b> (ou apenas um <b><i>componente conectado</i></b> ) se, para cada par de pixels <b>p <sub>i</sub></b> e <b>p <sub>j</sub></b> em <b>P,</b> houver uma sequ√™ncia de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que : <br><br>  a) todos os pixels na sequ√™ncia est√£o no conjunto <b>P</b> , ou seja,  s√£o pretos e <br><br>  b) a cada dois pixels <b><i>adjacentes nessa sequ√™ncia</i></b> s√£o <b><i>8 vizinhos</i></b> <br><br>  <b>Nota</b> : todos os padr√µes de 4 conex√µes s√£o 8, ou seja,  Os padr√µes com 4 conex√µes s√£o um subconjunto dos muitos padr√µes com 8 conex√µes.  Por outro lado, um padr√£o conectado a 8 pode n√£o estar conectado a 4. <br><br><h4>  Exemplo de padr√£o com 8 links </h4><br>  O diagrama abaixo mostra um padr√£o que est√° 8 conectado, mas n√£o 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Um exemplo de um padr√£o n√£o conectado a 8: </h4><br>  O diagrama abaixo mostra um exemplo de um padr√£o que n√£o est√° conectado 8, ou seja,  composto por mais de um componente conectado (o diagrama mostra tr√™s componentes conectados): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algoritmo de tra√ßo quadrado </h2><br><h4>  Id√©ia </h4><br>  A id√©ia por tr√°s do algoritmo de rastreamento quadrado √© muito simples;  isso pode ser atribu√≠do ao fato de o algoritmo ter sido uma das primeiras tentativas de detectar o contorno de um padr√£o bin√°rio. <br><br>  Para entender como funciona, voc√™ precisa de um pouco de imagina√ß√£o ... <br><br>  Suponha que tenhamos um padr√£o digital, por exemplo, um grupo de pixels pretos em um fundo de pixels brancos, ou seja,  na grade;  encontre o pixel preto e declare-o como nosso pixel " <b>inicial</b> ".  (Encontrar o pixel " <b>inicial</b> " pode ser implementado de v√°rias maneiras; come√ßaremos do canto inferior esquerdo da grade, digitalizaremos cada coluna de pixels de baixo para cima, da coluna da esquerda para a direita, at√© encontrarmos um pixel preto. N√≥s o declararemos " <b>inicial</b> " ".) <br><br>  Agora imagine que voc√™ √© uma joaninha no pixel <b>inicial</b> , como mostra a <b><i>Figura 1</i></b> abaixo.  Para obter o esbo√ßo de um padr√£o, fa√ßa o seguinte: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Os pixels pretos que voc√™ circulou ser√£o o contorno do padr√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Um aspecto importante do algoritmo de tra√ßo quadrado √© o "senso de dire√ß√£o".  As curvas √† esquerda e √† direita s√£o realizadas em rela√ß√£o √† localiza√ß√£o atual, que depende de como voc√™ chegou ao pixel atual.  Portanto, para fazer os movimentos certos, voc√™ precisa acompanhar sua dire√ß√£o. <br><br><h4>  Algoritmo </h4><br>  A seguir, √© apresentada uma descri√ß√£o formal do algoritmo de rastreamento quadrado: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico</a> quadrado, <b>T</b> , contendo o componente <b>P</b> conectado <b>de</b> c√©lulas pretas. <br><br>  Sa√≠da: linha <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> de pixels da borda, ou seja,  contorno. <br><br>  Iniciar <br><br><ul><li>  Defina <b>B</b> como um conjunto vazio. </li><li>  Digitalize as c√©lulas <b>T</b> de baixo para cima e da esquerda para a direita at√© encontrar um pixel preto <b>s</b> de <b>P.</b> </li><li>  Inserir <b>s</b> em <b>B.</b> </li><li>  Torne o pixel atual <b>p o</b> pixel inicial <b>s</b> . </li><li>  Vire √† esquerda, ou seja,  v√° para o pixel vizinho √† esquerda de <b>p</b> . </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li><li>  Enquanto <b>p</b> n√£o <b>for</b> igual a <b>s</b> , execute <br><br>  Se o pixel atual <b>p</b> for preto <br><ul><li>  insira <b>p</b> em <b>B</b> e vire √† esquerda (v√° para o pixel vizinho √† esquerda de <b>p</b> ). </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li></ul><br>  caso contr√°rio <br><ul><li>  vire √† direita (v√° para o pr√≥ximo pixel √† direita de <b>p</b> ). </li><li>  Atualizar <b>p</b> , ou seja,  torna-se o pixel atual. </li></ul><br>  Fim do ciclo de "tchau" </li></ul><br>  O fim <br><br>  <b>Nota: os</b> conceitos de "esquerda" e "direita" devem ser considerados n√£o com rela√ß√£o √† p√°gina ou ao leitor, mas com rela√ß√£o √† dire√ß√£o de entrada no pixel "atual" durante a digitaliza√ß√£o. <br><br><h4>  Demonstra√ß√£o </h4><br>  A seguir, √© apresentada uma demonstra√ß√£o animada de como o algoritmo de rastreamento quadrado detecta o contorno de um padr√£o.  N√£o esque√ßa que a joaninha se move em pixels;  observe como sua dire√ß√£o muda ao virar √† esquerda e √† direita.  As curvas √† esquerda e √† direita s√£o realizadas em rela√ß√£o √† dire√ß√£o atual em um pixel, ou seja,  orienta√ß√£o joaninha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  An√°lise </h4><br>  Acontece que os recursos do algoritmo de rastreamento quadrado s√£o muito limitados.  Ele √© incapaz de detectar os contornos de uma grande fam√≠lia de padr√µes que frequentemente surgem em aplica√ß√µes do mundo real. <br><br>  Isso se deve principalmente ao fato de as rota√ß√µes esquerda e direita n√£o levarem em considera√ß√£o os pixels localizados ‚Äúao longo <br>  diagonais "do pixel atual. <br><br>  Vamos examinar os diferentes padr√µes com conectividade diferente e ver por que o algoritmo de rastreamento quadrado falha.  Al√©m disso, estudaremos maneiras de melhorar os recursos do algoritmo e faz√™-lo funcionar mesmo com padr√µes que possuem um tipo especial de conectividade. <br><br><h4>  Crit√©rio de parada </h4><br>  Uma das fraquezas do algoritmo √© a escolha do crit√©rio de parada.  Em outras palavras, quando um algoritmo para de executar? <br><br>  Na descri√ß√£o original do algoritmo de rastreamento quadrado, a condi√ß√£o de conclus√£o √© atingir o pixel <b>inicial</b> pela segunda vez.  Acontece que, se o algoritmo depende de tal crit√©rio, n√£o ser√° capaz de detectar os contornos de uma grande fam√≠lia de padr√µes. <br><br>  A seguir, uma demonstra√ß√£o animada explicando como o algoritmo n√£o consegue detectar o contorno exato do padr√£o devido √† sele√ß√£o de um crit√©rio de parada incorreto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Como voc√™ pode ver, melhorar o crit√©rio de parada pode ser um bom come√ßo para melhorar o desempenho geral do algoritmo.  Existem duas alternativas eficazes para um crit√©rio de desligamento existente: <br><br>  a) Pare apenas visitando o pixel <b>inicial</b> <b><i>n</i></b> vezes, em que n √© pelo menos 2, OU <br><br>  b) Pare depois de pressionar o pixel <b>inicial</b> pela segunda vez, exatamente como o atingimos inicialmente. <br><br>  Este crit√©rio foi proposto por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jacob Eliosoff</a> , ent√£o o chamaremos de <b><i>crit√©rio para interromper Jacob</i></b> . <br><br>  A altera√ß√£o do crit√©rio de parada no caso geral melhora a efic√°cia do algoritmo de rastreio quadrado, mas n√£o supera outros pontos fracos que possui no caso de padr√µes com tipos especiais de conectividade. <br><br>  O algoritmo de rastreamento quadrado n√£o consegue detectar o contorno de uma fam√≠lia de padr√µes com uma conectividade 8 que N√ÉO possui uma conectividade 4. <br><br>  A seguir, √© apresentada uma demonstra√ß√£o animada de como o algoritmo de rastreamento quadrado (com o crit√©rio de parada de Jacob) falha ao detectar o contorno correto de um padr√£o com conectividade 8 sem conectividade 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Esse algoritmo √© completamente in√∫til? </h2><br>  Se voc√™ ler a an√°lise acima, provavelmente acha que o algoritmo de rastreamento quadrado falha ao detectar os contornos da maioria dos padr√µes.  Mas acontece.  que existe uma fam√≠lia especial de padr√µes em que o caminho √© totalmente detectado pelo algoritmo de rastreamento quadrado. <br><br>  Seja <b>P</b> o conjunto de pixels pretos com conectividade 4 na grade.  Deixe os pixels brancos da grade, ou seja,  os pixels de fundo <b>W</b> tamb√©m t√™m uma conectividade de 4. Acontece que nessas condi√ß√µes do padr√£o e de seu fundo, pode-se provar que o algoritmo de tra√ßo quadrado (com o crit√©rio de parada de Jacob) sempre lidar√° com √™xito com a determina√ß√£o do contorno. <br><br>  Abaixo est√° a prova de que, no caso em que o padr√£o e os pixels de fundo est√£o conectados, o algoritmo de tra√ßo quadrado determinar√° corretamente o contorno ao usar o crit√©rio de parada de Jacob. <br><br>  Prova <br>  <b>Dado</b> : o padr√£o <b>P √©</b> tal que todos os pixels do padr√£o (ou seja, preto) e os pixels de fundo (ou seja, branco) W t√™m uma conectividade de 4. <br><br>  <b>Primeira observa√ß√£o</b> <br><br>  Como o conjunto de pixels brancos W tem uma conectividade 4, isso significa que n√£o pode haver " <b><i>buracos</i></b> " no padr√£o (em termos informais, " <b><i>buracos</i></b> " queremos dizer grupos de pixels brancos completamente cercados por pixels pretos do padr√£o). <br><br>  A presen√ßa de qualquer " <b><i>buraco</i></b> " no padr√£o levar√° √† separa√ß√£o do grupo de pixels brancos dos pixels brancos restantes;  no entanto, muitos pixels brancos perdem a conectividade 4. <br><br>  <i>A Figura 2</i> e a <b><i>Figura 3</i></b> abaixo mostram dois tipos de " <b><i>orif√≠cios</i></b> " que podem ocorrer em um padr√£o com conectividade 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Segunda observa√ß√£o</b> <br><br>  Quaisquer dois pixels pretos de um padr√£o DEVEM ter um lado comum. <br><br>  Suponha que dois pixels pretos tenham apenas um v√©rtice comum.  Ent√£o, para satisfazer a propriedade da conex√£o 4 do padr√£o, deve haver um caminho conectando esses dois pixels para que cada dois pixels adjacentes nesse caminho tenham uma conectividade 4. Mas isso nos dar√° um padr√£o semelhante √† <b><i>Figura 3</i></b> .  Em outras palavras, isso resultar√° na separa√ß√£o de pixels brancos.  <b><i>A Figura 4</i></b> abaixo mostra um padr√£o t√≠pico que satisfaz a suposi√ß√£o de que os pixels no padr√£o e no plano de fundo est√£o conectados em 4, ou seja,  n√£o tem " <b><i>buracos</i></b> " e a cada dois pixels pretos tem um lado comum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  √â √∫til representar esses padr√µes da seguinte maneira: <br><br>  Primeiro, consideramos os pixels de limite, ou seja,  contorno do padr√£o.  Ent√£o, se considerarmos que cada pixel de limite possui 4 arestas de comprimento unit√°rio, veremos que algumas dessas arestas s√£o comuns aos pixels brancos vizinhos.  Vamos chamar essas arestas de arestas de <b><i>fronteira</i></b> . <br><br>  Essas arestas de limite podem ser consideradas como arestas de um pol√≠gono.  Na <b><i>foto</i></b> <b><i><br></i></b>  <b><i>5</i></b> abaixo, essa ideia √© demonstrada pelo exemplo de um pol√≠gono correspondente ao padr√£o da <b><i>Figura 4</i></b> acima: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Se considerarmos todas as ‚Äúconfigura√ß√µes‚Äù poss√≠veis de pixels de contorno que podem ocorrer em tais padr√µes, veremos que existem dois casos simples, mostrados na <b><i>Figura 6</i></b> e na <b><i>Figura 7</i></b> abaixo. <br><br>  Os pixels de limite podem ser m√∫ltiplos desses casos ou de outros arranjos, ou seja,  as voltas e reviravoltas desses dois casos.  As nervuras de limite est√£o marcadas em azul como <b>E1, E2, E3</b> e <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Terceira observa√ß√£o</b> <br><br>  No caso dos dois casos acima, n√£o importa qual seja o pixel inicial que escolhemos, e em qualquer dire√ß√£o em que ele <b>caia</b> , o algoritmo de rastreamento quadrado nunca <b>"voltar√°" (retrocesso)</b> , nunca <b>"passar√°" pela</b> <i>borda</i> <b>do</b> <i>limite</i> duas vezes ( somente se n√£o rastrear a borda uma segunda vez) e nunca errar a <b><i>borda da borda</i></b> .  Confira! <br><br>  Dois conceitos precisam ser esclarecidos aqui: <br><br>  a) o algoritmo <b>‚Äúvolta‚Äù</b> quando, antes de rastrear toda a borda, volta a visitar um pixel j√° visitado, e <br><br>  b) para cada <b><i>nervura limite,</i></b> h√° duas maneiras de <b>"passar por ela"</b> , a saber, "interna" e "externa" (onde "interna" refere-se ao movimento para dentro do pol√≠gono correspondente e "externa" - para fora do pol√≠gono). <br><br>  Al√©m disso, quando o algoritmo passa "para dentro" atrav√©s de uma das bordas do limite, ele passa "para fora" pela pr√≥xima borda do limite, ou seja,  o algoritmo de rastreamento quadrado n√£o deve ser capaz de passar por duas arestas consecutivas da mesma maneira. <br><br>  <b>√öltima observa√ß√£o</b> <br><br>  Cada padr√£o possui um <b>n√∫mero par de</b> <b>arestas</b> <b>de</b> <b>limite</b> . <br><br>  Se voc√™ observar o pol√≠gono da <b><i>Figura 5</i></b> , poder√° ver que: <br><br>  se queremos come√ßar do v√©rtice <b>S</b> marcado no diagrama e seguir as arestas do limite at√© chegarmos a <b>S</b> novamente, notamos que no processo cruzamos um n√∫mero par de arestas do limite.  Podemos considerar cada aresta de fronteira como um "passo" em uma dire√ß√£o separada.  Ent√£o, para cada "passo" √† direita, deve haver um "passo" correspondente √† esquerda, se quisermos retornar √† posi√ß√£o inicial.  O mesmo se aplica aos "degraus" verticais.  Portanto, as "etapas" devem ter pares correspondentes, e isso explica por que cada um desses padr√µes ter√° um n√∫mero par de arestas de limite. <br><br>  Portanto, quando o algoritmo para rastrear quadrados entra pela <b>borda do limite inicial</b> (do pixel inicial) uma segunda vez, ele o faz na <b>mesma</b> dire√ß√£o da primeira vez. <br><br>  A raz√£o para isso √© que, como existem duas maneiras de atravessar a borda do limite, e o algoritmo se move alternadamente para dentro e para fora, e h√° um n√∫mero par de bordas do limite, o algoritmo passar√° pela borda do limite inicial pela segunda vez da mesma maneira que em primeiro. <br><br><h4>  Conclus√£o </h4><br>  No caso de um padr√£o e fundo de 4 conex√µes, o algoritmo de rastreamento quadrado detectar√° toda a borda, ou seja,  contorno, padr√£o e deixar√° de funcionar ap√≥s um √∫nico tra√ßo, ou seja,  Ele n√£o o rastrear√° novamente, porque quando atingir a <b>borda do limite inicial</b> pela segunda vez, entrar√° na mesma maneira que na primeira vez.  Consequentemente, o algoritmo de rastreio quadrado com o crit√©rio de parada de Jacob determinar√° corretamente o contador de qualquer padr√£o, desde que o padr√£o e o plano de fundo estejam conectados 4. <br><br><h2>  Rastreando os arredores de Moore </h2><br><h4>  Id√©ia </h4><br>  A id√©ia por tr√°s do rastreamento Moore-Neighbour √© simples;  mas antes de explic√°-lo, precisamos explicar um conceito importante: <b><i>o bairro Moore de um</i></b> pixel. <br><br><h4>  O bairro de Moore </h4><br>  A vizinhan√ßa de Moore de um pixel <b>P</b> √© um conjunto de 8 pixels com um v√©rtice ou aresta comum com esse pixel.  Esses pixels, nomeadamente <b>P1, P2, P3, P4, P5, P6, P7 e P8</b> , s√£o mostrados na <b><i>Figura 1</i></b> . <br><br>  O bairro de Moore (tamb√©m chamado de <b><i>8 vizinhos</i></b> ou <b><i>vizinhos</i></b> <b><i>indiretos</i></b> ) √© um conceito importante frequentemente referido na literatura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Agora, estamos prontos para nos familiarizar com a ideia subjacente aos vest√≠gios dos arredores de Moore. <br><br>  Que haja um padr√£o digital, ou seja,  um grupo de pixels pretos, em um fundo de pixels brancos, ou seja,  na grade;  encontre o pixel preto e declare-o <b>o</b> pixel " <b>inicial</b> ".  (Existem v√°rias maneiras de encontrar o pixel " <b>inicial</b> ", mas, como antes, come√ßaremos do canto inferior esquerdo e digitalizaremos todas as colunas de pixels em ordem, at√© encontrarmos o primeiro pixel preto, que declararemos " <b>inicial</b> ".) <br><br>  Agora, novamente, imagine que voc√™ √© uma joaninha no pixel <b>inicial</b> , como mostra a <b><i>Figura 2</i></b> abaixo.  Sem perda de generaliza√ß√£o, detectaremos o contorno movendo-se no padr√£o no sentido hor√°rio.  (N√£o importa em que dire√ß√£o escolhemos, o principal √© us√°-lo constantemente no algoritmo). <br><br>  A id√©ia geral √© a seguinte: toda vez que entramos no pixel preto <b>P</b> , voltamos, isto √©, ao pixel branco em que est√°vamos antes.  Em seguida <b>,</b> contornamos o pixel <b>P</b> no sentido hor√°rio, visitando todos os pixels nas proximidades de Moore, at√© chegarmos ao pixel preto.  O algoritmo termina quando o pixel inicial atinge o pixel inicial uma segunda vez. <br><br>  Os pixels pretos que o algoritmo visitou ser√£o o contorno do padr√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algoritmo </h4><br>  A seguir, √© apresentada uma descri√ß√£o formal do algoritmo de rastreamento de vizinhan√ßa de Moore: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico</a> quadrado <b>T</b> contendo um componente <b>P</b> conectado de c√©lulas pretas. <br><br>  Sa√≠da: linha <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) de</b> pixels <b>de</b> limite, ou seja,  contorno. <br><br>  Denote por <b>M (a)</b> a vizinhan√ßa de Moore do pixel <b>a</b> . <br><br>  Seja <b>p</b> o pixel atual da borda. <br><br>  Seja <b>c</b> o pixel atual em considera√ß√£o, ou seja,  <b>c</b> est√° em <b>M (p)</b> . <br><br>  Iniciar <br><br><ul><li>  Defina <b>B</b> como um conjunto vazio. </li><li>  De baixo para cima e da esquerda para a direita, digitalize as c√©lulas <b>T</b> at√© encontrarmos um pixel preto <b>s</b> de <b>P.</b> </li><li>  Inserir <b>s</b> em <b>B.</b> </li><li>  Definimos o ponto <b>s</b> como o ponto limite atual <b>p</b> , ou seja,  <b>p = s</b> </li><li>  Vamos voltar, ou seja,  vamos para o pixel do qual viemos <b>s</b> . </li><li>  Seja <b>c o</b> pr√≥ximo pixel no sentido hor√°rio em <b>M (p)</b> . </li><li>  Enquanto <b>c</b> n√£o <b>for</b> igual a <b>s</b> , execute <br><br><ul><li>  se <b>c</b> √© preto <br><ul><li>  Inserir <b>c</b> em <b>B</b> </li><li>  estabelecemos <b>p = c</b> </li><li>  voltar (mover o pixel atual <b>c</b> para o pixel a partir do qual chegamos a <b>p</b> ) </li></ul><br>  caso contr√°rio <br><ul><li>  mova o pixel atual <b>c</b> para o pr√≥ximo pixel no sentido hor√°rio em <b>M (p)</b> </li></ul><br>  Fim do ciclo de adeus </li></ul></li></ul><br>  O fim <br><br><h4>  Demonstra√ß√£o </h4><br>  A seguir, uma demonstra√ß√£o animada de como o rastreamento de vizinhan√ßa de Moore realiza a detec√ß√£o de contornos de padr√£o.  (Decidimos tra√ßar o contorno no sentido hor√°rio.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  An√°lise </h4><br>  A principal fraqueza em rastrear os arredores de Moore reside na escolha de crit√©rios de parada. <br><br>  Na descri√ß√£o original do algoritmo para rastrear os arredores de Moore, o crit√©rio de parada √© atingir o pixel <b>inicial</b> pela segunda vez.  Semelhante ao algoritmo de rastreamento quadrado, verifica-se que o rastreamento dos arredores de Moore usando esse crit√©rio n√£o pode detectar os contornos de uma grande fam√≠lia de padr√µes. <br><br>  A seguir, uma demonstra√ß√£o animada explicando por que o algoritmo n√£o consegue encontrar o contorno exato do padr√£o devido √† sele√ß√£o de um crit√©rio de parada incorreto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Como voc√™ pode ver, melhorar o crit√©rio de parada pode ser um bom come√ßo para melhorar o desempenho geral do rastreamento.  Existem duas alternativas efetivas para o crit√©rio de desligamento, semelhante ao crit√©rio de desligamento de Jacob. <br><br>  O uso do crit√©rio Jacob melhora significativamente a efic√°cia do rastreamento dos arredores de Moore, tornando-o o melhor algoritmo para determinar o contorno de qualquer padr√£o, independentemente de sua conectividade. <br><br>  A raz√£o para isso √© principalmente porque o algoritmo verifica toda a vizinhan√ßa de Moore do pixel de limite para procurar o pr√≥ximo pixel de limite.  Ao contr√°rio do algoritmo de tra√ßo quadrado, que gira apenas para a esquerda e para a direita e perde os pixels "na diagonal", o tra√ßado da vizinhan√ßa de Moore sempre ser√° capaz de detectar o limite externo de qualquer componente conectado.  A raz√£o √© a seguinte: para qualquer padr√£o de <b><i>8 conex√µes</i></b> (ou simplesmente <b><i>conectado</i></b> ), o <b>pr√≥ximo</b> pixel de borda fica dentro do bairro Moore do atual pixel de borda.  Como o rastreamento de vizinhan√ßa de Moore verifica cada um dos pixels na vizinhan√ßa de Moore do pixel de limite atual, ele deve detectar o pr√≥ximo pixel de limite. <br><br>  Quando o rastreio da vizinhan√ßa de Mura atinge o pixel inicial uma segunda vez da mesma maneira que ela fez na primeira vez, isso significa que um <b>contorno externo</b> <b>completo</b> <b>do</b> padr√£o foi detectado e, se o algoritmo n√£o for parado, ele detectar√° novamente o mesmo contorno. <br><br><h2>  Varredura radial </h2><br>  O algoritmo de varredura radial √© um algoritmo de detec√ß√£o de contorno discutido em alguns livros.  Apesar do nome complexo, a ideia subjacente √© muito simples.  De fato, verifica-se que o algoritmo de varredura radial <b>√© id√™ntico ao</b> tra√ßo do entorno de Moore.  Algu√©m pode perguntar: "Por que o mencionamos?" <br><br>  O rastreamento dos arredores de Moore procura nas proximidades de Moore o pixel de limite atual em uma determinada dire√ß√£o (escolhemos a dire√ß√£o no sentido hor√°rio) at√© encontrar um pixel preto.  Ela ent√£o declara esse pixel como o limite atual e continua. <br><br>  O algoritmo de varredura radial faz o mesmo.  Por outro lado, fornece uma maneira interessante de encontrar o pr√≥ximo pixel preto na vizinhan√ßa de Moore de um determinado pixel de limite. <br><br>  O m√©todo √© baseado na seguinte ideia: <br><br>  toda vez que encontrarmos um novo pixel de limite, torne-o o pixel atual <b>P</b> e desenhe <b>um segmento de linha imagin√°rio</b> conectando <b>P</b> ao pixel de limite <b>anterior</b> .  Em seguida, <b>giramos o</b> segmento em rela√ß√£o a <b>P</b> no sentido hor√°rio at√© encontrar um pixel preto na vizinhan√ßa de Moore do pixel <b>P.</b>  A rota√ß√£o da linha √© id√™ntica √† verifica√ß√£o de cada pixel nas proximidades de Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos uma demonstra√ß√£o animada de como o algoritmo de varredura radial funciona e como ele parece rastrear os arredores de Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E quando o algoritmo de varredura radial para? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos explicar o comportamento do algoritmo usando os seguintes crit√©rios de parada ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crit√©rio de parada 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deixe o algoritmo de varredura radial completo quando visitar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pela segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo est√° uma demonstra√ß√£o animada, da qual fica claro por que o crit√©rio de quebra ser√° alterado corretamente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m vale a pena mencionar que, ao usar esse crit√©rio de parada nos dois algoritmos, a efic√°cia do algoritmo de varredura radial √© id√™ntica √† localiza√ß√£o dos arredores de Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No algoritmo de rastreamento quadrado e no rastreamento de vizinhan√ßa de Moore, descobrimos que o uso do crit√©rio de parada de Jacob melhora significativamente o desempenho de ambos os algoritmos. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O crit√©rio de parada de Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exige que o algoritmo pare de executar quando visita o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pela segunda vez na mesma dire√ß√£o da primeira vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, n√£o podemos usar o crit√©rio de parada de Jacob no algoritmo de varredura radial. O motivo √© que o algoritmo de varredura radial n√£o define o conceito</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A "dire√ß√£o" na qual ele atinge o pixel de limite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em outras palavras, n√£o est√° clara a ‚Äúdire√ß√£o‚Äù na qual o algoritmo caiu no pixel de limite (e sua defini√ß√£o √© n√£o trivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, precisamos propor outro crit√©rio de parada, que n√£o depende da dire√ß√£o de atingir um pixel espec√≠fico, o que pode melhorar a efic√°cia do algoritmo de varredura radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crit√©rio de parada 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que cada vez que o algoritmo detecte um novo pixel de limite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ele seja inserido em uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©rie de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> limite: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; e declarado como o pixel da borda atual. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consideraremos o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Isso significa que conhecemos o pixel da borda anterior </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 de</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada pixel da borda atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Quanto ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , assumiremos que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© um pixel imagin√°rio que n√£o √© equivalente a nenhum dos pixels na grade que enfrenta o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na linha de pixels de limite). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadas as premissas acima, podemos determinar o crit√©rio de parada da seguinte forma: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo termina a execu√ß√£o quando: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) a corrente de pixel limite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anteriormente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se reuniu como um pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (onde </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) na s√©rie de pixels de contorno, e </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em outras palavras, o algoritmo conclui a execu√ß√£o quando visita o pixel limite P no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vezes se o pixel de limite antes de P (na linha de pixels de limite) pela segunda vez for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel que era antes de P quando P foi visitado pela </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a condi√ß√£o do crit√©rio de parada for atendida e o algoritmo n√£o for desligado, o algoritmo de varredura radial continuar√° a detectar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite pela segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O desempenho do algoritmo de varredura radial com esse crit√©rio de parada √© semelhante ao desempenho de rastrear a vizinhan√ßa de Moore com o crit√©rio de parada de Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo de Theo Pavlidis </font></font></h2><br><h4>  Id√©ia </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este algoritmo √© um dos mais recentes algoritmos de detec√ß√£o de loop propostos por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ele o citou em seu livro de 1982, </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmos para processamento de gr√°ficos e imagens</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cap√≠tulo 7, se√ß√£o 5). N√£o √© t√£o simples como o algoritmo para rastrear quadrados ou rastrear os arredores de Moore, mas n√£o √© t√£o complicado (isso √© caracter√≠stico da maioria dos algoritmos de detec√ß√£o de contorno). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o explicaremos esse algoritmo da mesma maneira que foi feito em seu livro. Nossa abordagem √© mais f√°cil de entender e fornece uma id√©ia da ideia geral subjacente ao algoritmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem perda de generaliza√ß√£o, decidimos dar a volta no loop no sentido hor√°rio para corresponder √† ordem de todos os outros algoritmos apresentados no artigo. Por outro lado, Pavlidis escolheu a dire√ß√£o no sentido anti-hor√°rio. Isso n√£o afetar√° o desempenho do algoritmo. A √∫nica diferen√ßa √© a dire√ß√£o relativa dos movimentos que faremos quando contornarmos o contorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, vamos √† ideia ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que temos um padr√£o digital, ou seja, um grupo de pixels pretos em um fundo de pixels brancos, ou seja, na grade; encontre o pixel preto e declare-o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel " </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> ". Voc√™ pode procurar o </font><font style="vertical-align: inherit;">pixel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " de v√°rias maneiras, por exemplo, conforme descrito acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels para usar esse m√©todo √© opcional. Em vez disso, escolheremos um </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que satisfa√ßa as seguintes restri√ß√µes impostas pelo algoritmo Pavlidis para a sele√ß√£o de um pixel inicial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma limita√ß√£o importante da dire√ß√£o na qual inserimos o pixel inicial</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Na verdade, voc√™ pode escolher QUALQUER pixel de borda preta como o pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sob esta condi√ß√£o: se voc√™ estiver inicialmente nele, o pixel vizinho esquerdo N√ÉO √© preto. Em outras palavras, voc√™ precisa inserir o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em uma dire√ß√£o em que o pixel vizinho esquerdo seja branco (a "esquerda" aqui √© obtida em rela√ß√£o √† dire√ß√£o em que inserimos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora imagine que voc√™ √© uma joaninha em p√©</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> , como mostra a </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo. Durante a execu√ß√£o do algoritmo, estaremos interessados ‚Äã‚Äãem apenas tr√™s pixels √† sua frente, ou seja, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrados na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Designaremos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† sua frente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o pixel √† esquerda de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o pixel √† direita de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no algoritmo de tra√ßo quadrado, a coisa mais importante no algoritmo Pavlidis √© o "senso de dire√ß√£o". As curvas √† esquerda e √† direita s√£o relativas √† posi√ß√£o atual, que depende de como voc√™ inseriu o pixel atual. Portanto, para fazer os movimentos certos, √© importante acompanhar sua orienta√ß√£o atual. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas n√£o importa como voc√™ esteja localizado, os pixels P1, P2 e P3 s√£o determinados conforme descrito acima.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com essas informa√ß√µes, estamos prontos para explicar o algoritmo ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada vez que voc√™ est√° no pixel de limite atual (que √© o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> ), fazemos o seguinte: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verifique o pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o pixel de limite atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e d√™ um passo √† frente e, em seguida, d√™ um passo √† esquerda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para estar em P1 (a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordem dos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> movimentos √© muito importante). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a seguir ilustra este processo. </font><font style="vertical-align: inherit;">O caminho para chegar ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© mostrado em azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E somente se P1 for branco, procederemos √† verifica√ß√£o de P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declarar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel de limite atual e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avan√ßar um passo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para estar em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este caso √© mostrado na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo. </font><font style="vertical-align: inherit;">O caminho que voc√™ precisa seguir no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© mostrado em azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente se P1 e P2 forem brancos, verifique P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preto, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel atual da borda e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mova um passo para a direita e depois um passo para a esquerda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como mostra a Figura 4 abaixo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© tudo!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tr√™s regras simples para tr√™s casos simples. Como voc√™ pode ver, √© importante acompanhar sua dire√ß√£o ao fazer curvas, porque todos os movimentos s√£o feitos em rela√ß√£o √† orienta√ß√£o atual. Mas parece que esquecemos alguma coisa? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se todos os tr√™s pixels estiverem brancos √† nossa frente?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, giramos (em p√© no atual limite do pixel) 90 graus no sentido hor√°rio para ver um novo conjunto de tr√™s pixels √† nossa frente. Em seguida, fazemos a mesma verifica√ß√£o para esses novos pixels. Voc√™ ainda pode ter uma pergunta: e se todos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esses</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tr√™s pixels forem brancos ?! Ent√£o, novamente, giramos 90 graus no sentido hor√°rio, permanecendo no mesmo pixel. Antes de verificar a vizinhan√ßa inteira do pixel de Moore, voc√™ pode girar tr√™s vezes (cada vez 90 graus no sentido hor√°rio).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se girarmos tr√™s vezes sem encontrar pixels pretos, isso significa que estamos em um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel isolado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , n√£o conectado a nenhum outro pixel preto. </font><font style="vertical-align: inherit;">√â por isso que o algoritmo permite que voc√™ gire tr√™s vezes e, em seguida, conclui sua execu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro aspecto: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando o algoritmo completa a execu√ß√£o? </font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo termina em dois casos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) como mencionado acima. </font><font style="vertical-align: inherit;">o algoritmo permite que voc√™ gire tr√™s vezes (90 graus no sentido hor√°rio cada vez), depois de concluir a execu√ß√£o e declarar o pixel isolado OU </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) quando o pixel de limite atual √© o </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o algoritmo conclui a execu√ß√£o ‚Äúdeclarando‚Äù que detectou o contorno do padr√£o.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, √© apresentada uma descri√ß√£o formal do algoritmo Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosaico</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quadrado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contendo um componente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conectado </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> c√©lulas pretas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sa√≠da: linha </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> limite, ou seja, </font><font style="vertical-align: inherit;">contorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defini√ß√µes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denuncie por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel do limite atual, ou seja, </font><font style="vertical-align: inherit;">o pixel em que estamos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 da</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seguinte maneira: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(veja tamb√©m a Figura 1 acima)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o pixel √† sua frente, adjacente √†quele em que voc√™ est√°, ou seja, </font><font style="vertical-align: inherit;">com pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> ‚Äî  ,   <b>P2</b> . </li><li> <b>P3</b> ‚Äî  ,   <b>P2</b> . </li><li>  <b>¬´¬ª</b>            . </li></ul><br>  Iniciar <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encerrar o programa e declarar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p um</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isolado</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> caso contr√°rio </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire 90 graus no sentido hor√°rio, de p√© no pixel atual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (finalize o loop de repeti√ß√£o)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O fim </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstra√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, √© apresentada uma demonstra√ß√£o animada de como o algoritmo Pavlidis detecta o contorno de um determinado padr√£o. </font><font style="vertical-align: inherit;">N√£o esque√ßa que andamos em pixels; </font><font style="vertical-align: inherit;">observe como a orienta√ß√£o muda ao virar para a esquerda ou direita. </font><font style="vertical-align: inherit;">Para explicar o algoritmo com o m√°ximo de detalhes poss√≠vel, inclu√≠mos todos os casos poss√≠veis.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  An√°lise </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ acha que o algoritmo Pavlidis √© ideal para detectar contornos de padr√µes, deve mudar de id√©ia ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse algoritmo √© realmente um pouco mais complicado do que, por exemplo, rastrear os arredores de Moore, nos quais n√£o h√° casos especiais que exijam processamento separado, mas n√£o ser√° capaz de determinar os contornos de um grande n√∫mero. uma fam√≠lia de padr√µes que possui um certo tipo de conectividade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo funciona muito bem em padr√µes de 4 conex√µes. Seu problema ocorre ao rastrear alguns padr√µes conectados a 8 que n√£o est√£o conectados a 4. A seguir, √© apresentada uma demonstra√ß√£o animada de como o algoritmo Pavlidis falha ao detectar o contorno correto de um padr√£o de 8 conex√µes (e n√£o de 4) - ele pula a maior parte da borda.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras simples de modificar um algoritmo para melhorar significativamente seu desempenho. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Substitua o crit√©rio de parada</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em vez de concluir o algoritmo ao visitar o pixel inicial pela segunda vez, voc√™ pode finaliz√°-lo quando visitar o pixel inicial pela terceira ou quarta vez. Isso melhorar√° o desempenho geral do algoritmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OU </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Chegue √† origem do problema, ou seja, antes de selecionar o pixel</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicial.H√° uma limita√ß√£o importante em rela√ß√£o √† dire√ß√£o na qual a entrada no pixel inicial √© realizada. Essencialmente, voc√™ precisa inserir o pixel inicial para que, quando voc√™ fique sobre ele, o pixel √† sua esquerda seja branco. A raz√£o para introduzir essa restri√ß√£o √© esta: como sempre olhamos para os tr√™s pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√†</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nossa </font><b><font style="vertical-align: inherit;">frente</font></b><font style="vertical-align: inherit;"> em</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma determinada ordem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em alguns padr√µes, pularemos o pixel de limite diretamente √† esquerda do pixel inicial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corremos o risco de perder n√£o apenas o pixel vizinho esquerdo do pixel inicial, mas tamb√©m o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel diretamente abaixo dele</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (como demonstrado na an√°lise). Al√©m disso, em alguns padr√µes, um pixel correspondente ao pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo </font><font style="vertical-align: inherit;">ser√° ignorado </font><font style="vertical-align: inherit;">. Portanto, assumimos que o pixel inicial precisa ser atingido em uma dire√ß√£o em que os pixels correspondentes aos pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrados na </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abaixo sejam brancos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, padr√µes como o mostrado na demonstra√ß√£o ser√£o detectados corretamente e a efic√°cia do algoritmo Pavlidis melhorar√° significativamente. </font><font style="vertical-align: inherit;">Por outro lado, encontrar um pixel inicial que atenda a esses requisitos pode ser desafiador e, em muitos casos, ser√° imposs√≠vel encontr√°-lo. </font><font style="vertical-align: inherit;">Nesse caso, voc√™ deve usar uma maneira alternativa de melhorar o algoritmo Pavlidis, ou seja, a conclus√£o do algoritmo depois de visitar o ponto de partida pela terceira vez.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467611/">https://habr.com/ru/post/pt467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467597/index.html">Personalizando as diretrizes de produtos de big data com o Vowpal Wabbit</a></li>
<li><a href="../pt467599/index.html">Renderiza√ß√£o de gr√°ficos 3D com OpenGL</a></li>
<li><a href="../pt467605/index.html">Tudo que voc√™ precisa √© de URL</a></li>
<li><a href="../pt467607/index.html">Confiss√£o do √≥dio dos estivadores</a></li>
<li><a href="../pt467609/index.html">Criando um aplicativo m√≥vel no React Native</a></li>
<li><a href="../pt467615/index.html">Como criar wrapper Python e n√£o enlouquecer</a></li>
<li><a href="../pt467617/index.html">Kaspresso: a estrutura de autoteste que voc√™ estava esperando</a></li>
<li><a href="../pt467619/index.html">Os jarros Aquafor s√£o um bom exemplo de como os filtros para tratamento de √°gua n√£o podem ser projetados</a></li>
<li><a href="../pt467621/index.html">Encontro Elasticsearch Moscow em Ozon</a></li>
<li><a href="../pt467623/index.html">Reagir nativo: criando um campo de entrada animado usando a API animada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>