<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèø ü§∂üèª ü§òüèª Vuex meistern - Von Null zu Held üî≠ ü§∂üèª üí≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚ÄûMastering Vuex - Zero to Hero‚Äú von Sanath Kumar. 


 Die offizielle Dokumentation von ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vuex meistern - Von Null zu Held</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421551/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûMastering Vuex - Zero to Hero‚Äú</a> von Sanath Kumar. </p><br><p>  Die offizielle Dokumentation von Vuex definiert es als Statusverwaltungsmuster + Bibliothek f√ºr Vue.js.-Anwendungen  <i>Aber was hei√üt das?</i>  <i>Was ist ein staatliches Managementmuster?</i> </p><br><p>  Stellen Sie sich vor, Sie arbeiten an einer gro√üen Webanwendung mit Hunderten von Routen und Komponenten.  W√§re es nicht einfacher, wenn wir alle Daten, die wir jemals in einer Anwendung ben√∂tigen w√ºrden, in einem zentralen Speicher speichern k√∂nnten? </p><br><img src="https://habrastorage.org/webt/dm/rc/t5/dmrct5ro7paby7tugthhzagynxw.jpeg"><a name="habracut"></a><br><p> Jede Komponente oder Route in unserer Anwendung fordert Daten aus dem Vuex-Status an und √ºbertr√§gt die ge√§nderten Daten zur√ºck in den Status. </p><br><p>  Im Wesentlichen kann der Zustand von Vuex als die einzige Quelle der Wahrheit f√ºr die gesamte Anwendung angesehen werden. </p><br><p>  Daten werden im Status als JSON-Objekt gespeichert.  Zum Beispiel: </p><br><pre><code class="plaintext hljs">state: { name: "John Doe", age: "28" }</code> </pre> <br><p>  Aber wie k√∂nnen unsere Komponenten und Routen auf Daten zugreifen, die in unserem Bundesstaat gespeichert sind?  Dazu m√ºssen wir in unserem Vuex-Repository <b>Getter</b> definieren, die Daten aus dem Repository an unsere Komponenten zur√ºckgeben.  Mal sehen, wie ein einfacher <b>Getter</b> aussieht, der den Namen aus unserem Repository erh√§lt: </p><br><pre> <code class="plaintext hljs">getters: { NAME: state =&gt; { return state.name; }, }</code> </pre> <br><p>  Beachten Sie, dass der Getter-Name in Gro√übuchstaben geschrieben ist.  Dies ist nur eine Empfehlung f√ºr den Codestil.  Es ist nicht notwendig, ihm zu folgen, wenn Sie es nicht m√∂gen. </p><br><p>  Nachdem wir einen Getter f√ºr den Namen definiert haben, ist es unglaublich einfach, den Wert des Namens in unserer Komponente zu ermitteln.  Mit dem folgenden Code k√∂nnen Sie dies tun. </p><br><pre> <code class="plaintext hljs">let name = this.$store.getters.NAME;</code> </pre> <br><p>  Wir haben herausgefunden, wie Daten aus dem Speicher abgerufen werden k√∂nnen.  Nun wollen wir sehen, wie wir <b>die</b> Daten im Repository <b>festlegen</b> k√∂nnen.  Wir werden Setter definieren, richtig?  Au√üerdem werden Vuex-Setter etwas anders benannt.  Wir definieren eine <b>Mutation</b> , um Daten auf unseren Vuex-Status zu setzen. </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, payload) =&gt; { state.name = payload; }, }</code> </pre> <br><p>  Was ist Nutzlast noch?  <b>Nutzlast</b> sind die Daten, die von der Komponente, die die Mutation durchf√ºhrt, zu unserer Mutation √ºbertragen werden.  Wie k√∂nnen wir das machen?  Sehr einfach: </p><br><pre> <code class="plaintext hljs">this.$store.commit('SET_NAME', your_name);</code> </pre> <br><p>  Dieser Code √§ndert den Status der Anwendung und <i>legt</i> jeden Wert fest, der <i>Ihrem</i> Namen f√ºr die Eigenschaft name in unserem Repository zugewiesen wurde. </p><br><p>  MUTATIONEN SYNCHRON </p><br><p>  Stellen Sie sich vor, wir haben eine Liste von Namen in einer Datenbank auf einem Remote-Server gespeichert.  Der Server stellt uns einen Endpunkt zur Verf√ºgung, der ein Array von Namen zur√ºckgibt, die in unserer Vue.js verwendet werden k√∂nnen.  Nat√ºrlich k√∂nnen wir <b>Axios verwenden</b> , um den Endpunkt abzufragen und die Daten abzurufen. </p><br><pre> <code class="plaintext hljs">let {data} = await Axios.get('https://myapiendpoint.com/api/names');</code> </pre> <br><p>  Danach k√∂nnen wir das zur√ºckgegebene Array mithilfe einer Mutation an unseren Store-Vuex-Status √ºbergeben.  Einfach, oder?  Aber nicht wirklich.  Mutationen sind synchron und wir k√∂nnen keine asynchronen Operationen wie API-Aufrufe innerhalb einer Mutation ausf√ºhren. </p><br><p>  Was sollen wir dann tun?  <b>Aktionen</b> erstellen. </p><br><p>  Aktionen sind wie Mutationen, aber anstatt den Zustand direkt zu √§ndern, machen sie eine Mutation.  Klingt verwirrend?  Schauen wir uns die Ank√ºndigung der Aktion an. </p><br><pre> <code class="plaintext hljs">actions: { SET_NAME: (context, payload) { context.commit('SET_NAME', payload); }, }</code> </pre> <br><p>  Wir haben eine Aktion namens SET_NAME definiert, die Kontext und <i>Nutzdaten</i> als Parameter verwendet.  Die Aktion schreibt die zuvor erstellte Mutation SET_NAME mit den an sie √ºbergebenen Daten, <b>dh Ihrem_Namen</b> , <b>fest</b> . </p><br><p>  Anstatt die Mutation direkt aufzurufen, l√∂sen unsere Komponenten jetzt die Aktion SET_NAME mit einem neuen Namen als Daten wie folgt aus: </p><br><pre> <code class="plaintext hljs">this.$store.dispatch('SET_NAME', your_name);</code> </pre> <br><p>  Dann initiiert die Aktion die Mutation mit den an sie √ºbergebenen Daten, d. H. <i>Ihrem_Namen</i> . </p><br><br><h2>  Aber warum? </h2><br><p>  Sie fragen sich vielleicht, warum eine Aktionsdeklaration erforderlich ist, wenn wir einfach Mutationen mit einem neuen Wert direkt von unseren Komponenten aus initiieren k√∂nnen.  Wie oben erw√§hnt, sind Mutationen synchron, aber keine Aktionen. </p><br><p>  Im obigen Beispiel wird der Fall ber√ºcksichtigt, wenn Sie den Wert des Namens aktualisieren m√ºssen, jedoch nicht nur in seinem Status, sondern auch in der Datenbank, die auf dem Remoteserver ausgef√ºhrt wird.  Ich bin sicher, dass Sie Vuex in 99% der F√§lle so in einem realen Projekt einsetzen m√∂chten.  Schauen Sie sich das folgende Code-Snippet an: </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, name) =&gt; { state.name = name; }, }, actions: { SET_NAME: async (context, name) =&gt; { let {data} = await Axios.post('http://myapiendpoint.com/api/name', {name: name}); if (data.status == 200) { context.commit('SET_NAME', name); } }, }</code> </pre> <br><p>  Der Code selbst ist selbsterkl√§rend.  Wir verwenden Axios, um den Namen an den Endpunkt zu senden.  Wenn die POST-Anforderung erfolgreich war und der Feldnamenwert auf dem Server erfolgreich ge√§ndert wurde, initiieren wir die SET_NAME-Mutation, um den Namenswert in unserem Status zu aktualisieren. </p><br><p>  √úBERNEHMEN SIE NIEMALS MUTATIONEN DIREKT.  VERWENDEN SIE F√úR DIESE IMMER AKTIONEN. </p><br><br><h2>  Konfigurieren des Vuex-Speichers in Vue.JS </h2><br><p>  Lassen Sie uns tiefer eintauchen und herausfinden, wie wir Vuex in einer realen Anwendung implementieren k√∂nnen. </p><br><h3>  Schritt 1. Installieren Sie Vuex </h3><br><pre> <code class="plaintext hljs">npm install --save vuex</code> </pre> <br><h3>  Schritt 2. Erstellen eines Vuex-Repositorys </h3><br><ol><li>  Erstellen Sie das <b>Gesch√§ftsverzeichnis</b> im Stammverzeichnis unserer Anwendung. </li><li>  Erstellen Sie die Datei <b>index.js</b> in diesem Verzeichnis und erstellen Sie mit dem <b>folgenden</b> Code ein neues Repository. </li></ol><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, });</code> </pre> <br><h3>  Schritt 3. Hinzuf√ºgen von Vuex-Speicher zur Vue.JS-Anwendung </h3><br><p>  1. Importieren Sie das <b>Repository</b> in die Datei main.js: </p><br><pre> <code class="plaintext hljs">import {store} from './store';</code> </pre> <br><p>  2. F√ºgen Sie der Vue-Instanz <b>Speicher hinzu</b> , wie unten gezeigt: </p><br><pre> <code class="plaintext hljs">new Vue({ el: '#app', store, router, render: h =&gt; h(App), });</code> </pre> <br><p>  Jetzt k√∂nnen wir unserem Vuex-Repository Statusvariablen, Getter, Mutationen und Aktionen hinzuf√ºgen. </p><br><br><h2>  Beispiel </h2><br><p>  Schauen Sie sich das Vuex-Repository einer einfachen Aufgabenlistenanwendung an.  "Nicht nur eine andere To-Do-Liste !!!".  Huh?  Keine Sorge.  Am Ende dieses Artikels erfahren Sie, wie Sie die volle Leistung von Vuex nutzen k√∂nnen. </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; Vue.use(Vuex); export const store = new Vuex.Store({ state: { todos: null, }, getters: { TODOS: state =&gt; { return state.todos; }, }, mutations: { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }, actions: { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }, });</code> </pre> <br><br><h2>  F√ºgen Sie der Aufgabenliste ein neues Element hinzu </h2><br><p>  Initiieren Sie in Ihrer Komponente die Aktion SAVE_TODO, indem Sie ihr ein neues Aufgabenelement √ºbergeben, wie im folgenden Codeausschnitt gezeigt. </p><br><pre> <code class="plaintext hljs">let item = 'Get groceries'; this.$store.dispatch('SAVE_TODO', item);</code> </pre> <br><p>  Die Aktion <b>SAVE_TODO sendet</b> eine POST-Anforderung an den Endpunkt und initiiert dann die <b>ADD_TODO-Mutation</b> , die der <b>Statusvariablen</b> <b>todos</b> ein <b>Aufgabenelement</b> hinzuf√ºgt. </p><br><br><h2>  Aufgaben erledigen </h2><br><p>  Initiieren Sie im <b>Mounted ()</b> -Block Ihrer Komponente die zweite <b>GET_TODO-</b> Aktion, die alle <b>Aufgaben</b> vom Endpunkt empf√§ngt und in der Statusvariablen <i>todos</i> speichert, wodurch die SET_TODO-Mutation initiiert wird: </p><br><pre> <code class="plaintext hljs">mounted() { this.$store.dispatch('GET_TODO'); }</code> </pre> <br><br><h2>  Zugriff auf Aufgaben innerhalb einer Komponente </h2><br><p>  Erstellen Sie eine berechnete Eigenschaft, um auf das <i>todos-</i> Element innerhalb einer Komponente zuzugreifen: </p><br><pre> <code class="plaintext hljs">computed: { todoList() { return this.$store.getters.TODOS; }, }</code> </pre> <br><p>  Innerhalb der Komponente k√∂nnen Sie auf die berechnete Eigenschaft zugreifen: </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in todoList"&gt;&lt;/div&gt;</code> </pre> <br><br><h2>  Verwenden der mapGetters-Methode </h2><br><p>  Mit der von <b>Vuex</b> bereitgestellten <b>mapGetters-</b> Methode k√∂nnen Sie noch einfacher auf <b>Aufgaben</b> innerhalb einer Komponente zugreifen. </p><br><pre> <code class="plaintext hljs">import {mapGetters} from 'vuex'; computed : { ...mapGetters(['TODOS']), //    }</code> </pre> <br><p>  M√∂glicherweise haben Sie bereits vermutet, dass der Code in der Vorlage ge√§ndert werden sollte, wie im folgenden Snippet gezeigt. </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in TODOS"&gt;&lt;/div&gt;</code> </pre> <br><p>  Beachten Sie, wie wir den ES6-Verteilungsoperator [...] in unseren berechneten Eigenschaften verwendet haben. </p><br><p>  VUEX STORAGE IST NICHT NUR DIE QUELLE DES AKTUELLEN STAATS IHRER ANWENDUNG.  Es ist auch der einzige Punkt, der diesen Zustand √§ndern sollte. </p><br><p>  Dies bedarf einer kleinen Erkl√§rung.  Wir haben bereits gelernt, wie Sie Aktionen zum <b>Empfangen</b> und <b>Installieren von</b> Aufgaben in unserem Repository erstellen.  Was ist, wenn wir ein Element aktualisieren und markieren m√ºssen?  Wo f√ºhren wir den Code daf√ºr aus? </p><br><p>  Im Internet finden Sie unterschiedliche Meinungen zu diesem Thema.  Der Dokumentation fehlen auch diesbez√ºglich klare Leitlinien. </p><br><p>  Ich w√ºrde empfehlen, alle API-Aufrufe in Aktionen in Ihrem Vuex-Repository zu speichern.  Daher erfolgt jede Status√§nderung nur innerhalb des Repositorys, wodurch das Debuggen erleichtert und das Verst√§ndnis des Codes vereinfacht wird und das Bearbeiten des Codes erleichtert wird. </p><br><br><h2>  Code Organisation </h2><br><p>  Das Speichern aller Statusvariablen, Getter, Aktionen und Mutationen in einer Datei macht es schnell umst√§ndlich, sobald Sie mit gro√üen Anwendungen arbeiten.  Lassen Sie uns sehen, wie Sie die Speicherung in mehreren Dateien als Module organisieren k√∂nnen. </p><br><p>  Erstellen Sie ein neues Verzeichnis in Ihrem Repository und nennen Sie es <i>Module</i> .  F√ºgen Sie die Datei <i>todos.js</i> dem erstellten Verzeichnis hinzu, das den folgenden Code enth√§lt: </p><br><pre> <code class="plaintext hljs">const state = {}; const getters = {}; const mutations = {}; const actions = {}; export default { state, getters, mutations, actions, };</code> </pre> <br><p>  Jetzt k√∂nnen wir die Statusvariablen, Getter, Mutationen und Aktionen aus der Datei <b>index.js</b> in die Datei <b>todos.js verschieben</b> .  Denken Sie daran, <b>Axios</b> zu importieren.  Wir m√ºssen Vuex lediglich mitteilen, dass wir das Speichermodul erstellt haben und wo es zu finden ist.  Die aktualisierte Datei <i>index.js</i> sollte <i>ungef√§hr</i> so aussehen: </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; import todos from './modules/todos'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, modules: { todos, }, });</code> </pre> <br><p>  Die Datei <b>todos.js</b> sieht folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs">import Axios from 'axios'; state = { todos: null, }; getters = { TODOS: state =&gt; { return state.todos; }, }; mutations = { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }; actions = { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }; export default { state, getters, mutations, actions, };</code> </pre> <br><br><h2>  Zusammenfassung </h2><br><ol><li>  Der Anwendungsstatus wird als ein gro√ües JSON-Objekt gespeichert. </li><li>  <b>Getter</b> werden verwendet, um auf im Speicher gespeicherte Werte zuzugreifen. </li><li>  <b>Mutationen</b> aktualisieren Ihren Zustand.  Es ist zu beachten, dass Mutationen synchron sind. </li><li>  Alle asynchronen Operationen m√ºssen innerhalb von <b>Aktionen ausgef√ºhrt werden</b> .  Aktionen √§ndern den Zustand und l√∂sen Mutationen aus. </li><li>  Machen Sie es sich zur Regel, <b>Mutationen</b> ausschlie√ülich durch <b>Aktion auszul√∂sen</b> . </li><li>  <b>Module</b> k√∂nnen verwendet werden, um Ihren Speicher in mehreren kleinen Dateien zu organisieren. </li></ol><br><p>  Vuex macht die Arbeit mit Vue viel einfacher und macht mehr Spa√ü.  Wenn Sie ein Anf√§nger sind, kann es Situationen geben, in denen es f√ºr Sie schwierig ist, zu entscheiden, ob Sie Vuex in bestimmten Bereichen Ihrer Anwendung verwenden m√∂chten.  Folge deinem Instinkt.  Sie werden ziemlich schnell hohe Geschwindigkeit erreichen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421551/">https://habr.com/ru/post/de421551/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421537/index.html">Funktionen h√∂herer Ordnung in JS: Young Fighter Course</a></li>
<li><a href="../de421543/index.html">Klonen Sie eine kontaktlose Karte mit einer mobilen Anwendung</a></li>
<li><a href="../de421545/index.html">Testbericht zum PocketBook 616 - dem preisg√ºnstigsten Taschenbuch f√ºr 2018 mit Hintergrundbeleuchtung</a></li>
<li><a href="../de421547/index.html">Akzeptanz unabh√§ngiger Rechenzentren</a></li>
<li><a href="../de421549/index.html">Wir schreiben technische Dokumentation: eine Anleitung f√ºr den Laien</a></li>
<li><a href="../de421553/index.html">Wir teilen technologische Inhalte: Wir haben alle unsere Materialien auf einer Website gesammelt</a></li>
<li><a href="../de421555/index.html">WideNES-Projekt - Gehen Sie √ºber die Grenzen des NES-Bildschirms hinaus</a></li>
<li><a href="../de421557/index.html">Offene Lektion "Asynchrone Programmierung in Java"</a></li>
<li><a href="../de421559/index.html">Komponenten-UI-Architektur in iOS-Anwendungen</a></li>
<li><a href="../de421561/index.html">12 Fragen zu Rollern, die sich nicht sch√§men zu stellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>