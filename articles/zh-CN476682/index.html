<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻 😕 💎 如何在Phaser中编写一个Sapper并运行HTML5开发人员测试任务 🥠 👩🏼 ☔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="下午好，亲爱的同事们！ 

 我的名字叫亚历山大（Alexander），我是HTML5游戏的开发商。 

 在我发送简历的公司之一中，我被要求完成测试任务。 我同意，并在1天后根据TOR HTML5开发了该游戏。 



 因为我正在接受游戏编程方面的培训，并且为了更有效地使用我的代码，所以我决定在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在Phaser中编写一个Sapper并运行HTML5开发人员测试任务</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/">下午好，亲爱的同事们！ <br><br> 我的名字叫亚历山大（Alexander），我是HTML5游戏的开发商。 <br><br> 在我发送简历的公司之一中，我被要求完成测试任务。 我同意，并在1天后根据TOR HTML5开发了该游戏。 <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br> 因为我正在接受游戏编程方面的培训，并且为了更有效地使用我的代码，所以我决定在完成的项目上写一篇培训文章会很有用。 由于完成的测试得到了积极的评估并导致了面试的邀请，因此我的决定可能有权存在，并且可能会在将来对某人有所帮助。 <br><br> 本文将介绍足以成功完成开发人员HTML5职位的平均测试任务的工作量。 想要熟悉Phaser框架的任何人也可能会感兴趣。 并且，如果您已经在使用Phaser并用JS编写-请参阅如何在TypeScript中开发项目。 <br><br> 因此，在cat下有很多TypeScript代码！ <br><a name="habracut"></a><br><h2> 引言 </h2><br> 我们对此问题作简要说明。 <br><br><ol><li> 我们将开发一个简单的HTML5游戏-一个经典的工具。 </li><li> 作为主要工具，我们将使用相位器3，打字稿和webpack。 </li><li> 该游戏将为桌面设计，并在浏览器中运行。 </li></ol><br> 我们提供了最终项目的链接。 <br><br><div class="spoiler">  <b class="spoiler_title">链接到演示和源</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可播放的演示</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub源代码</a> <br></div></div><br> 如果突然有人忘记了游戏规则，请回想一下这位工兵的技巧。 但是由于这种情况不太可能发生，因此将规则放置在破坏者的下方：) <br><br><div class="spoiler">  <b class="spoiler_title">拍手规则</b> <div class="spoiler_text"> 比赛场地由布置在桌子中的单元格组成。 默认情况下，当游戏开始时，所有单元格都关闭。 炸弹放置在某些牢房中。 <br><br> 在封闭的单元格上单击鼠标左键时，它将打开。 如果一个开孔中有炸弹，则游戏以失败告终。 <br><br> 如果该单元格中没有炸弹，则会在其中显示一个数字，表明相对于当前打开的位置，相邻单元格中的炸弹数量。 如果附近没有炸弹，则牢房看起来是空的。 <br><br> 右键单击封闭的单元格可以在其上设置一个标志。 玩家的任务是安排所有可用的标记，以便标记所有已开采的单元格。 放置所有标志后，玩家在一个打开的单元格上按下鼠标左键以检查他是否获胜。 <br></div></div><br> 接下来，我们直接进入手册本身。 所有材料都分为小步骤，每个步骤都描述了在短时间内完成特定任务的过程。 因此，逐步执行小目标，最终我们将创建一个完整的游戏。 如果决定快速转到特定步骤，请使用目录。 <br><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.准备</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1项目模板</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2构建配置</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.3安装模块</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.4资产准备</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.创建场景</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1入口点</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2起始场景</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.3起始场景的文字</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.4过渡到游戏级别</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.5级场景</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.6在入口处设置场景</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.游戏对象</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.1游戏板</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.2细胞模型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3单元格视图</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.4在视图类中创建精灵</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.5精灵定位</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.6创建FieldView的实例</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.7显示板字段。</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.8制造炸弹</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.9设定值</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.处理输入事件</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1跟踪鼠标单击事件</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">左键点击处理</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4右键处理</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.5 GameSceneView对象</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.动画</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.1木板填充动画</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.2单元翻转动画</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1.准备</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1项目模板</font> </h3><br> 下载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">默认的相位器项目模板</a> 。 这是框架作者推荐的模板，它为我们提供了以下目录结构： <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2"> 启动游戏的HTML页面 </td></tr><tr><td rowspan="2">  webpack / </td><td>  base.js </td><td> 为测试环境构建配置 </td></tr><tr><td>  prod.js </td><td> 为生产构建配置 </td></tr><tr><td rowspan="2">  src / </td><td> 资产/ </td><td> 游戏资产（精灵，声音，字体） </td></tr><tr><td>  index.js </td><td> 入口点 </td></tr></tbody></table></div>对于我们的项目，我们不需要当前的<code>index.js</code>文件，因此将其删除。 然后创建目录<code>/src/scripts/</code> ，并将空的<code>index.ts</code>文件放入其中。 我们将所有脚本添加到此文件夹中。 <br> 还需要记住的是，在构建用于生产的项目时，将在根目录中创建一个<code>dist</code>目录，该目录将放置发行版本。 <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2构建配置</font> </h3><br> 我们将使用webpack进行组装。 由于我们的模板最初是为使用JavaScript而准备的，并且我们使用TypeScript编写，因此我们需要对收集器的配置进行一些小的更改。 <br><br> 在<code>webpack/base.js</code>添加<code>entry</code>键（用于指示构建我们的项目时的进入点），以及用于描述构建TS脚本规则的<code>ts-loader</code>配置： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br> 我们还需要在项目根目录中创建tsconfig.json文件。 对我来说，它具有以下内容： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3安装模块</font> </h3><br> 从package.json安装所有依赖项，并向其中添加typescript和ts-loader模块： <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br> 现在该项目已准备好开始开发。 我们可以使用2条命令，这些命令已经在<code>package.json</code>文件的<code>scripts</code>属性中定义。 <br><br><ol><li> 建立一个调试项目并通过本地服务器在浏览器中打开 <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li> 运行要出售的版本，并将发行版本放在dist /文件夹中 <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4资产准备</font> </h3><br> 该游戏的所有资产均已从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenGameArt</a> （版本61x61）进行了诚实下载，并拥有名为<i>Feel free to use</i>的最友好的许可证，随附的页面会仔细地告诉我们）。 顺便说一句，本文中提供的代码具有相同的许可证！  ;） <br><br> 我从下载的集合中删除了时钟图像，并重命名了其余文件，以便获得易于使用的帧名称。 名称和相应文件的列表显示在下面的屏幕上。 <br><br> 根据生成的精灵，我们将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TexturePacker</a>程序中创建一个<code>Phaser JSONArray</code>格式地图集（免费版本已经足够了，我还没有得到工作），并将生成的<code>spritesheet.png</code>和<code>spritesheet.json</code>文件放在<code>src/assets/</code> project目录中。 <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2.创建场景</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1入口点</font> </h3><br> 我们通过创建webpack配置中描述的入口点开始开发。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br> 由于我们拥有的游戏是为台式机设计的，并且将填满整个屏幕，因此我们将<code>width</code>和<code>height</code>字段大胆地使用浏览器的整个<code>width</code>和<code>height</code> 。 <br>  <code>scene</code>字段当前为空数组，我们将对其进行修复！ <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2起始场景</font> </h3><br> 在<code>src/scripts/scenes/StartScene.ts</code>创建第一个场景的类： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br> 为了有效继承<code>Phaser.Scene</code>我们将场景名称作为参数传递给父类的构造函数。 <br><br> 该场景将结合资源预加载和开始屏幕的功能，邀请用户加入游戏。 <br><br> 通常，在我的项目中，玩家按顺序依次经历两个场景，然后进入开始场景： <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br> 但是在这种情况下，游戏是如此简单，并且资产太少，因此没有理由将预载放到一个单独的场景中，甚至没有更多的理由来做初始的单独的<code>Boot</code> loader。 <br><br> 我们将以<code>preload</code>方法加载所有资产。 为了将来能够使用创建的图集，我们需要执行两个步骤： <br><br><ol><li> 使用<code>require</code>获取<code>png</code>和<code>json</code>地图集文件： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li> 将它们<code>preload</code>到开始场景的<code>preload</code>方法中： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3起始场景的文字</font> </h3><br> 在开始的场景中，还有两件事要做： <br><br><ol><li> 告诉玩家如何开始游戏 </li><li> 在玩家的主动下开始游戏 </li></ol><br> 为了满足第一点，我们首先在场景文件的开头创建两个枚举，以描述文本及其样式： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br> 然后在<code>create</code>方法中将两个文本都创建为对象。 让我提醒您，只有在将所有资源加载到<code>preload</code>方法中之后，才会调用<code>Phaser</code>中场景的<code>create</code>方法，这非常适合我们。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br> 在另一个更大的项目中，我们可以将文本和样式添加到json语言环境文件中或单独的配置中，但是鉴于我们现在只有2行，我认为这一步骤是多余的，在这种情况下，我建议不要使我们的生活变得复杂，将自己限制在场景文件开头的列表中。 <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4过渡到游戏级别</font> </h3><br> 在继续进行之前，我们在此场景中要做的最后一件事是跟踪鼠标单击事件，以将玩家启动到游戏中： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">2.5级场景</font> </h3><br> 通过传递给<code>this.scene.start</code>方法的<code>"Game"</code>参数判断<code>this.scene.start</code>您已经猜到是时候创建第二个场景了，该场景将处理主要的游戏逻辑。 创建<code>src/scripts/scenes/GameScene.ts</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br> 在此场景中，我们不需要<code>preload</code>方法，因为 我们已经在上一个场景中加载了所有必要的资源。 <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6在入口处设置场景</font> </h3><br> 现在已经创建了两个场景，将它们添加到我们的入口点 <br>  <code>src/scripts/index.ts</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3.游戏对象</font> </h2><br> 因此， <code>GameScene</code>类将实现游戏级逻辑。 我们对精工游戏水平有何期待？ 在视觉上，我们希望看到一个封闭的运动场。 我们知道该字段是一个表，这意味着它具有给定数量的行和列，其中一些炸弹放置在舒适的位置。 因此，我们有足够的信息来创建描述比赛场地的单独实体。 <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1游戏板</font> </h3><br> 创建<code>src/scripts/models/Board.ts</code>在其中放置<code>Board</code>类： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br> 让我们让该类成为Phaser.Events.EventEmitter的后继者，以便访问将来用于注册和调用事件的接口。 <br><br>  <code>Field</code>类的对象数组将存储在<code>_fields</code>私有属性中。 我们稍后将实现此模型。 <br><br> 我们设置了专用数字属性<code>_rows</code>和<code>_cols</code>以指示<code>_cols</code>的行数和列数。 创建用于读取<code>_rows</code>和<code>_cols</code>公共<code>_cols</code> 。 <br><br>  <code>_bombs</code>字段告诉我们该<code>_bombs</code>需要生成的炸弹数量。 在<code>_scene</code>参数中<code>_scene</code>我们将引用传递给<code>GameScene</code>游戏场景的对象，在其中我们将创建<code>Board</code>类的实例。 <br><br> 值得注意的是，我们仅将场景对象转移到模型中，以便进一步传输到视图，而在此处仅将其用于显示视图。 事实是，移相器直接使用场景对象渲染子画面，因此在创建子画面预制件时，我们有义务提供到当前场景的链接，我们将在以后进行开发。 对于我们自己，我们将接受以下协议：将链接转移到场景仅用于进一步用作显示引擎，并同意我们不会在模型和视图中直接调用场景的自定义方法。 <br><br> 一旦我们确定了棋盘创建界面，我建议在关卡场景中对其进行初始化，以最终确定<code>GameScene</code>类： <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br> 我们在场景文件的开头将board参数带到常量，并在创建此类的实例时将其传递给<code>Board</code>构造函数。 <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2细胞模型</font> </h3><br> 该板包含要在屏幕上显示的单元格。 每个单元格必须放置在由行和列确定的相应位置。 <br><br> 单元也被选择为单独的实体。 创建<code>src/scripts/models/Field.ts</code>在其中放置描述单元格的类： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br> 每个单元格应具有其所在的行和列指标。 我们设置参数<code>_board</code>和<code>_scene</code>以设置指向板对象和场景的链接。 我们实现了用于读取<code>_row</code> ， <code>_col</code>和<code>_board</code>吸气剂。 <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3单元格视图</font> </h3><br> 创建了抽象单元格，现在我们要对其进行可视化。 要在屏幕上显示单元格，需要创建其视图。 创建<code>src/scripts/views/FieldView.ts</code>并将视图类放入其中： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br> 请注意，我们使此类成为<code>Phaser.GameObjects.Sprite</code>的后代。 用移相器来说，该类已成为Sprite预制件。 也就是说，我得到了精灵游戏对象的功能，我们将使用自己的方法进一步扩展该功能。 <br><br> 让我们看一下此类的构造函数。 在这里，首先，我们必须使用以下参数集调用父类的构造函数： <br><br><ul><li> 链接到场景对象（正如我在3.1节中所警告的：相位器要求我们链接到当前场景以渲染精灵） </li><li> 画布上的<code>x</code>和<code>y</code>坐标 </li><li> 地图集可用的字符串键，我们在开始场景的<code>preload</code>方法中加载了该键 </li><li> 您要选择以显示精灵的此地图集中的框架字符串键 </li></ul><br> 在private <code>_model</code>属性中设置对模型的引用（即<code>Field</code>类的实例）。 <br><br> 我们还谨慎地启动了2个当前为空的<code>_init</code>和<code>_create</code> ，我们将在稍后实现。 <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4在视图类中创建精灵</font> </h3><br> 因此，创建了视图，但是她仍然不知道如何绘制精灵。 要将精灵和我们需要的框架放在画布上，您将需要修改我们自己的private <code>_create</code>方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5精灵定位</font> </h3><br> 此刻，所有创建的精灵将放置在画布的坐标（0，0）中。 我们还需要将每个单元格放在板上的相应位置。 即，对应于此单元格的行和列的位置。 为此，我们需要编写代码来计算<code>FieldView</code>类的每个实例的坐标。 <br><br> 将<code>_position</code>属性添加到类中，该属性负责游戏场地上单元格的最终坐标： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br> 由于我们要相对于屏幕的中心对齐板并相应地对齐其中的单元格，因此我们还需要<code>_offset</code>属性，指示此特定单元格相对于屏幕的左边缘和上边缘的偏移量。 使用私有获取器添加它： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br> 因此，我们： <br><br><ol><li> 在<code>this._scene.cameras.main.width</code>获得了总屏幕宽度。 </li><li> 我们通过将单元格的数量乘以一个单元格的宽度来获得木板的总宽度： <code>this._board.cols * this.width</code> 。 </li><li> 从屏幕的宽度上减去木板的宽度，我们在屏幕上得到了一个位置，而不是被木板占据。 </li><li> 将结果数字除以2，我们可以在电路板的左侧和右侧获得缩进值。 </li><li> 通过将每个单元格移动此缩进值，我们可以保证整个电路板沿<code>x</code>轴对齐。 </li></ol><br> 我们执行绝对相似的动作以获得垂直位移。 <br><br> 仍然需要在<code>_init</code>方法中添加必要的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br> 这里的属性<code>this.x</code> ， <code>this.y</code> ， <code>this.width</code>和<code>this.height</code>是父类<code>Phaser.GameObjects.Sprite</code>的继承属性。 更改<code>this.x</code>和<code>this.y</code>的属性将导致精灵在画布上的正确定位。 <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6创建FieldView的实例</font> </h3><br> 在<code>Field</code>类中创建一个视图： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7显示板字段。</font> </h3><br> 让我们回到<code>Board</code>类，它实际上是<code>Field</code>对象的集合，并将创建单元格。 <br><br> 我们将把木板创建代码取出到一个单独的<code>_create</code>方法中，并从构造函数中调用此方法。 知道在<code>_create</code>方法中，我们不仅将创建单元格，还将提取用于在单独的<code>_createFields</code>方法中创建单元格的代码。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br> 正是在这种方法中，我们将在嵌套循环中创建所需数量的单元格： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br> 这是第一次使用该命令运行程序集进行调试 <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br> 确保在屏幕中央，我们希望看到8行中的64个单元格。 <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8制造炸弹</font> </h3><br> 之前，我报道了在<code>Board</code>类的<code>_create</code>方法中，我们将不仅创建字段。 还有什么 还将创建炸弹，并将创建的单元格设置为相邻炸弹的数量。 让我们从炸弹本身开始。 <br><br> 我们需要将N枚炸弹放在板上随机的单元格中。 我们用近似算法描述炸弹的创建过程： <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br> 在循环的每次迭代中，我们将从<code>this._fields</code>属性中获得一个随机单元，直到创建的炸弹数量与<code>this._bombs</code>字段中指示的<code>this._bombs</code> 。 如果接收到的单元是空的，那么我们将在其中安装炸弹并更新生成炸弹所需的计数器。 <br><br> 要生成随机数，我们使用静态方法<code>Phaser.Math.Between</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br> 不要忘记在<code>Board.ts</code>文件中写对<code>this._createBombs();</code>的<code>Board.ts</code> <code>this._createBombs();</code> 在<code>_create</code>方法的末尾 <br><br> 正如您已经注意到的，为了使此代码正确运行，您需要通过向其添加<code>empty</code> getter和<code>setBomb</code>方法来改进<code>Field</code>类。 <br><br> 将一个<code>_value</code>私有字段添加到Field <code>_value</code> ，这将控制单元格的内容。 我们接受以下协议。 <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td> 单元格为空，并且其中没有地雷或值 </td></tr><tr><td>  <code>_value</code> === -1 </td><td> 牢房里有一个地雷 </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td> 单元中的是当前单元旁边的地雷数量 </td></tr></tbody></table></div><br> 遵循这些规则，我们将在<code>Field</code>类中开发使用<code>_value</code>属性的方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9设定值</font> </h3><br> 炸弹已经排列好了，现在我们拥有所有数据，以便在需要它的所有单元格中设置数值。 <br><br> 让我提醒您，根据工兵的规则，该牢房的数量必须与位于该牢房旁边的炸弹数量相对应。 根据此规则，我们编写相应的伪代码。 <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br> 在<code>Board</code>类中，创建一个新方法并将指定的伪代码转换为真实代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br> 让我们看看我们使用的哪些接口没有实现。 您需要添加<code>getClosestFields</code>方法来获取相邻的单元格。 <br><br> 如何识别相邻小区？ <br><br> 例如，考虑板子上任何不在边缘的单元，即不在极行和极列中的单元。 这样的像元具有最大数量的邻居：顶数为1，底数为1，左数为3，右数为3（包括对角线上的像元）。 <br><br> 因此，在每个相邻的单元格中，指示符<code>_row</code>和<code>_col</code>不超过1。这意味着我们可以预先指定当前字段的参数<code>_row</code>和<code>_col</code>之间的差异。 在文件的开头添加一个常量到类描述中： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br> 现在我们可以添加缺少的方法，在其中循环遍历此数组： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br> 不要忘记在每次迭代中检查<code>field</code>变量，因为板上的并非所有单元都有8个邻居。 例如，左上方的单元格在其左侧将没有邻居，依此类推。 <br><br> 仍然需要实现<code>getField</code>方法并将所有必需的调用添加到<code>Board</code>类中的<code>_create</code>方法 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080">4.   </font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080">4.1     </font> </h3><br>        ,         ,             .            . <br><br>       .   <code>FieldView</code>      <code>_create</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br>  phaser           <code>Phaser.GameObjects</code> .        ( <code>pointerdown</code> )   ,     <code>FieldView</code> ,   <code>Phaser.GameObjects.Sprite</code> . <br><br>     ,    ,     ,         .      <code>setInteractive</code>     ,       . <br><br> ,      ,    <code>Board</code>   ,      <code>Field</code> ,     <code>_createFields</code>        : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br>   ,          <code>_onFieldClick</code> ,    .          <code>Board</code> .  ,                ,         <code>GameScene</code> . ,      ,   <code>Board</code>   .   : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br>       ,   ,    ,     .     ,           . ,      ,  ,     ,   ,   ,   <code>Field</code> . <br><br>         <code>GameScene</code>      <code>_create</code> ,     : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080">4.2.     </font> </h3><br>       .     .       .  ,     ,   ,   : <br><br><ol><li>         </li><li>      —   </li><li>       ,  ,       ,               ,        </li><li>       ,         ,     </li></ol><br>             : <br><br><pre> <code class="plaintext hljs">                         </code> </pre><br>      ,   .   <code>_onFieldClickLeft</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br>  ,  ,   <code>Field</code>  <code>Board</code> ,     ,     . <br><br>  3      <code>States</code> ,   <code>_state</code>        : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br> ,     ,     ,     <code>open</code> ,    : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br>       ,   .      <code>_setState</code> ,         .         ,     . <br><br>    <code>_exploded</code>       Field,   : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br>    <code>Board</code>      <code>openClosestFields</code> .           ,           . <br>   : <br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br>                : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br>   <code>completed</code>   <code>Board</code>       .        ?           . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br>     <code>_fields</code>   <code>completed</code> ,      .     (      ,     <code>completed</code>    <code>Field</code> )    <code>_bombs</code> (     ),   <code>true</code> ,  ,   . <br>          ,       .       <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br>    <code>completed</code>    <code>Field</code> .        ?    ,   .           : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br>         <code>_onGameOver</code> ,           .                 <code>status</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080">4.3  </font> </h3><br>             . <br><br>    <code>Field</code>    <code>_setState</code> ,    <code>change</code>    .      <code>FieldView</code>    : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br>      <code>_onStateChange</code>    .     ,     ,  ,    <code>_render</code> . <br><br>            .        ,     <code>setFrame</code>  ,      . <br><br>           <code>_frameName</code> ,    .     ,     . <br><div class="scrollable-table"><table><tbody><tr><td>  </td><td> 条件 </td></tr><tr><td> <code>closed</code> </td> <td>   <br></td></tr><tr><td> <code>flag</code> </td> <td>    <br></td></tr><tr><td> <code>empty</code> </td> <td>  ,       <br></td></tr><tr><td> <code>exploded</code> <br> </td><td>  ,    <br></td></tr><tr><td> <code>mined</code> <br> </td><td>  , ,    <br></td></tr><tr><td> <code>1...9</code> <br> </td><td>       1  9,        <br></td></tr></tbody></table></div><br>           ,      .      : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br>        ,     — ,   .            (    ): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br>                 .  ,     <code>true</code> , ,   <code>key</code>           . <br><br>      ,           <code>_value</code> ,        <code>States</code>   . <br><br>            ,          . <br><br><a name="section-4-4"></a><h3> <font color="#008080">4.4   </font> </h3><br>         ,     .           .     . <br><br><ol><li>      ,       </li><li>   ,           </li><li>  /                 </li></ol><br>          : <br><br><pre> <code class="plaintext hljs">                              </code> </pre><br>          ,      : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br>       <code>_flags</code> ,          ,           .        ,        ,    .    <code>Board</code>  <code>countMarked</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br>     —     <code>Field</code> ,           <code>open</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br> ,  <code>_setState</code>   <code>change</code> ,     ,  ,          . <br><br>       ,           .  ,   ,    : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080">4.5  GameSceneView</font> </h3><br>   UI       <code>GameSceneView</code>     <code>src/scripts/views/GameSceneView.ts</code> . <br><br>         <code>FieldView</code>           <code>GameObjects</code> . <br>           : <br><br><ul><li>     </li><li>   </li><li>      (/) </li></ul><br>    UI      <code>GameSceneView</code> . <br>  . <br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br>     . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br>           50px          .  ,  <code>setOrigin</code>  pivot point    (0, 1).  ,        . <br><br>   . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br>               <code>setOrigin</code>   0.5   x.  ,      ,           . <br><br>   ,        . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br>           <code>setOrigin</code> ,          .         ,      .           . <br><br>    <code>render</code>      UI        <code>_create</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br>         UI,   . <br>        GameScene     _render  ,     : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080">5. </font> </h2><br>      ,     ,     ?!  ,      phaser,           .             . <br><br>    2 :          .     . <br><br><a name="section-5-1"></a><h3> <font color="#008080">5.1   </font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br>  ,             .                         . <br><br>   <code>FiledView</code>     <code>_create</code>  <code>_animateShow</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br> B     .  ,     ,   2 : <br><br><ol><li>       ,        </li><li>          </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br>         (0, 0),      ,       ,           .       . <br><br>       <code>_moveTo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br>        <code>tweens</code> .    <code>add</code>      : <br><br><ul><li>  <code>targets</code>         ,      .      <code>this</code>   ,      . </li><li>         . </li><li>  <code>duration</code>    ,    — 600. </li><li>  <code>ease</code>  <code>easeParams</code>  easing . </li><li>   delay     ,             .    ,     .           . </li><li> ,   <code>onComplete</code>   ,       . </li></ul><br>     ,         ,        <code>resolve</code> ,    . <br><br><a name="section-5-2"></a><h3> <font color="#008080">5.2   </font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br>  ,          .     ? <br><br>            <code>_render</code>  .        ,  ,    .  ,    ,        . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br>          <code>scale</code> .           <code>x</code>  ,     ,     .  ,      <code>x</code>      ,       .      <code>_animateFlip</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br>     <code>_moveTo</code>  <code>_scaleTo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br>          ,                   .          . <br><br>             ,    !  :) <br><br>     ,        ! <br><br><h2> 结论 </h2><br> ,    ,    ,                .             ,      phaser      .            ! <br><br>         .          ,         .      . ,       ,      ,  , tilemap, spine  . <br>     ,        ,  ,         ,  ,      ?   ,                    ,     .   . <br><br>    !       ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476682/">https://habr.com/ru/post/zh-CN476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476670/index.html">几何核C3D上的CAD概述-2</a></li>
<li><a href="../zh-CN476674/index.html">ReportPortal快速部署以熟悉</a></li>
<li><a href="../zh-CN476676/index.html">48个JavaScript开源资源（2019）</a></li>
<li><a href="../zh-CN476678/index.html">使用Apple Combine进行远程异步获取的API</a></li>
<li><a href="../zh-CN476680/index.html">Rodov的连续生产计划系统是1961年的苏联精益生产计划/ MRP。 起飞，日落和新生</a></li>
<li><a href="../zh-CN476686/index.html">基于Raspberry CM3 +的物联网网关的开发</a></li>
<li><a href="../zh-CN476688/index.html">OTUS的新课程。 “ IOS开发人员。 高级课程V 2.0»</a></li>
<li><a href="../zh-CN476692/index.html">内容营销原则</a></li>
<li><a href="../zh-CN476694/index.html">关于与Farida Roslovets以及Electro-neeek RPA主管一起进行的业务机器人化</a></li>
<li><a href="../zh-CN476696/index.html">如何创建和部署全栈阵营的应用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>