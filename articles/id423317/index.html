<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚀 ✊🏾 🦖 Kenapa pria Scala? 👍🏾 🛬 🤶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo kolega. 

 Belum lama ini, kami mencetak buku oleh Odersky, Spoon dan Wenners tentang Scala 2.12. Toh, untuk Scala 3 masih jauh. 


 Penulis arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kenapa pria Scala?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/423317/">  Halo kolega. <br><br>  Belum lama ini, kami mencetak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku oleh</a> Odersky, Spoon dan Wenners tentang Scala 2.12.  Toh, untuk Scala 3 masih jauh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/1a/9-/pn1a9-_ak4yws-g7xkgd9kbw6ka.jpeg"></div><br>  Penulis artikel hari ini adalah Adam Worski, salah satu pendiri SoftwareMill dan pengembang Scala yang berpengalaman.  Dia mendapat ringkasan menarik tentang kekuatan bahasa Scala modern, yang kami bawa ke perhatian Anda. <br><a name="habracut"></a><br><br>  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuliah paripurna oleh</a> Martin Odersky tentang ScalaDays, di mana ia menguraikan rencana untuk Scala 3 dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuliah paripurna oleh</a> John de Goes di konferensi Scalapeño tentang masa depan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scala</a> , diskusi yang hidup berlanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas Scala</a> .  Terlepas dari diskusi presentasi pleno ini, banyak diskusi dilakukan di twitter, di komunitas Slack, serta di reddit (lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ). <br><br><img src="https://habrastorage.org/webt/ue/ty/mb/uetymbny6mtyogrfrcj_vzgdc7a.png"><br><br>  <i>Itu pertanyaannya!</i> <br><br>  Semua ini sangat menarik dan informatif bagi para spesialis yang sudah bekerja di ekosistem Scala.  Namun, sebagian besar kontroversi terkait dengan berbagai kelemahan Scala sebagai bahasa yang dapat dipahami secara intuitif atau aktual.  Momen-momen ini dapat menakuti orang-orang "dari luar", membuat mereka bertanya: "Mengapa saya harus menggunakan Scala?", "Bagaimana jika ini jalan buntu?", "Akankah Scala 3 mengulangi kesuksesan Python 3?"  dll.  Seperti dalam kebanyakan diskusi, titik terlemah dan paling emosional menarik perhatian, dan perdebatan ini tidak terkecuali. <br><br>  Jadi mari <b>kita mundur</b> : mengapa Anda bahkan membutuhkan Scala?  Apa alasan teknis dan bisnis untuk bekerja dengan bahasa ini? <br><br>  <b>Area Subjek Proyek</b> <br><br>  Untuk mulai dengan, bahasa Scala sangat baik untuk bidang subjek tertentu (tetapi tidak untuk semua orang!).  Aset terpenting Scala adalah <b>fleksibilitasnya dalam mendefinisikan abstraksi</b> .  Yang Anda inginkan - sejumlah "batu bata" sederhana untuk ini;  terkadang mendefinisikan abstraksi tidak lebih sulit daripada menggunakan kelas, metode, dan ekspresi lambda.  Terkadang Anda harus menggunakan parameter implisit atau metode ekstensi;  dalam kasus yang jarang terjadi, tetap hanya menggunakan perintah makro.  Namun, <b>ada opsi</b> . <br><br>  Dengan demikian, Scala sangat cocok untuk Anda jika Anda perlu <b>menavigasi area subjek yang kompleks</b> .  Sebagai contoh, kita dapat berbicara tentang pemrograman terdistribusi atau kompetitif.  Concurrency sangat sulit, dan Scala memiliki sejumlah perpustakaan yang menyederhanakan tugas ini dengan membangun abstraksi.  Ada dua pendekatan utama untuk ini: aktor, diimplementasikan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka</a> , dan dalam semangat FP, disajikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monix</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kucing-efek</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scalaz</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZIO</a> (jika Anda ingin membaca lebih lanjut tentang membandingkan alat-alat ini - saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel</a> tentang topik ini) ) <br><br>  Namun, tentu saja, kita dapat berbicara tentang bidang studi lain.  Kemampuan Scala juga memungkinkan kami membawa pemodelan aplikasi bisnis yang khas ke tingkat selanjutnya.  Tetapi dalam kasus ini kita berbicara tentang kompleksitas urutan yang berbeda.  Dalam hal sistem terdistribusi, kita dihadapkan dengan kompleksitas teknis.  Ketika memprogram logika bisnis dalam aplikasi, kita sudah bicara tentang kerumitan area subjek.  Misalnya, buku Debasish Ghosh " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemodelan domain fungsional dan reaktif</a> " menjelaskan cara menggabungkan DDD dengan pemrograman fungsional dan reaktif. <br><br>  <b>Kesulitan bahasa</b> <br><br>  Catatan: ketika berbicara tentang Scala, semua orang suka menekankan luasnya kemungkinan bahasa ini, menekankan bahwa justru karena keserbagunaan seperti itu, bahasa ini sangat kompleks.  Ini tidak sepenuhnya benar. <br><br>  Seperti disebutkan di atas, Scala memiliki sejumlah konstruksi dasar dari mana abstraksi dapat dibangun.  Namun, semuanya dapat <b>digabungkan</b> satu sama lain, karena bahasa tersebut memperoleh fleksibilitas tersebut.  Sebagian besar proyek inovatif yang Anda temui datang ke kombinasi satu atau lain dari jenis pesanan yang lebih tinggi, parameter implisit dan subtipe. <br><br>  Jadi, dengan sejumlah fitur dasar yang relatif kecil (ukuran tata bahasa Scala lebih sederhana daripada Kotlin, Java, atau Swift!) - yang, pada gilirannya, memfasilitasi pembelajaran - pilihan kombinasi jauh lebih banyak. <br><br>  Apakah pilihannya terlalu luas?  Saya kira tidak.  Programmer, sebagai profesional yang kompeten dan bertanggung jawab, lebih dari mampu memilih opsi terbaik untuk memecahkan masalah tertentu.  Untuk informasi lebih lanjut, lihat artikel “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simple Scala Stack</a> ”. <br><br>  <b>Java hanya lebih baik</b> <br><br>  Ada banyak pembicaraan sekarang bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin telah</a> menggantikan Scala sebagai "seperti Jawa, hanya lebih baik."  Tetapi saya percaya bahwa <b>Scala, dan bukan Kotlin</b> , yang masih layak mendapatkan gelar seperti itu.  Ada dua alasan utama untuk ini: <br><br>  Pertama, <b>kekekalan dalam Scala adalah yang terpenting</b> .  Ini karena sifat Scala: menulis kode di atasnya adalah nyaman terutama dengan bantuan data yang tidak dapat diubah.  Data tersebut termasuk, khususnya: <code>val</code> (sebagai unit kelas pertama), kelas <code>case</code> , fungsi tingkat tinggi, dll.  Tetapi intinya adalah bagaimana perpustakaan bahasa Scala standar dirancang dan ditulis;  semua struktur data yang digunakan secara default tidak dapat diubah.  Berkat kekekalan, sejumlah hal disederhanakan, terutama di dunia kita yang memiliki kompetisi tinggi, di mana bahasa-bahasa itu menang, di mana ketidakmampuan lebih disukai. <br><br>  Kedua, Scala mendukung <b>konstruktor tipe, tipe urutan lebih tinggi, dan tipe kelas</b> (dinyatakan secara implisit), yang sangat menyederhanakan pekerjaan dengan jenis pembungkus / wadah, misalnya, <code>Promise</code> , <code>Future</code> atau <code>Task</code> .  Pembungkus seperti itu berlaku ketika pemrograman dalam gaya asinkron atau reaktif, dan keberadaan konstruksi bahasa yang menyederhanakan kerja, katakanlah, dengan basis kode di mana <code>Future</code> digunakan secara aktif adalah argumen lain yang mendukung Scala. <br><br>  Apa tipe kelasnya?  Peran mereka kira-kira sama dengan pola desain di Jawa, namun, mereka lebih fleksibel dan mudah digunakan segera setelah Anda memahami maknanya dengan tegas.  Ada beberapa panduan bagus tentang ini, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> . <br><br>  Bagaimana dengan konstruktor tipe?  Ini adalah jenis seperti <code>Future</code> atau <code>Option</code> , berfungsi sebagai "wadah" atau "pembungkus" untuk jenis lainnya.  Jadi, Anda dapat memiliki <code>Option[String]</code> atau <code>Future[Int]</code> .  Jenis pesanan yang lebih tinggi memungkinkan Anda untuk menulis kode yang abstrak setiap bungkus.  Lihat misalnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> <br><br>  Tiba-tiba Anda bertanya-tanya, mengapa bahkan menggunakan <code>Future</code> / <code>Task</code> ?  Intinya bukan hanya sebagian besar perhitungan "reaktif" berkinerja tinggi dengan penundaan minimal dilakukan menggunakan I / O asinkron, yang hanya diminta oleh desain semacam itu.  Alasan lain diberikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang reddit</a> dan dalam artikel saya “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa repot-repot dengan pembungkus?</a>  " <br><br>  Bekerja di lingkungan yang sebagian besar tidak berubah, serta kemampuan untuk menangani konstruksi seperti <code>Future</code> , <code>Promise</code> atau <code>Task</code> (dan abstraksikan!) Secara radikal mengubah kode Anda.  Sekilas, ini mungkin tidak jelas: jika Anda memiliki pengalaman Java atau Ruby di belakang Anda, maka Anda tidak akan dapat segera mewujudkan aspek-aspek Scala ini.  Tetapi, bahkan dari sudut pandang pendidikan, sangat berguna untuk memahami bagaimana pendekatan "fungsional" bekerja dan, yang lebih penting, mengapa itu bisa berubah menjadi <b>alternatif yang sangat berharga</b> . <br><br>  Secara alami, baik Scala dan Kotlin memiliki sejumlah keunggulan umum di atas Jawa, misalnya: <br><br><ul><li>  Sintaks yang lebih kompak </li><li>  Kode stereotip kurang </li><li>  Sistem tipe yang lebih kaya </li><li>  Kurangnya ballast bahasa </li></ul><br><br>  Pada saat yang sama, kedua bahasa menyediakan akses ke ekosistem perpustakaan dan kerangka kerja JVM. <br>  Semakin kaya sistem tipe (dalam Scala lebih kaya daripada di Kotlin, dan di Kotlin lebih kaya daripada di Jawa), semakin banyak pekerjaan verifikasi yang dilakukan oleh kompiler, dan bukan oleh orang.  Untuk inilah komputer diciptakan: untuk melakukan tugas berulang yang membosankan dan rutin.  Memeriksa penerapan tipe jelas hanya salah satu dari tugas-tugas ini. <br><br>  Pada saat yang sama, sistem tipe kaya berguna tidak hanya ketika <b>menulis kode</b> , tetapi juga, pada tingkat yang jauh lebih besar, ketika <b>membaca kode</b> .  Ketika mudah bagi Anda untuk menavigasi basis kode, memahami apa yang dilakukannya, dan, apalagi, itu tidak menakutkan (atau tidak begitu menakutkan) untuk melakukan <b>refactoring</b> , ini mengkarakterisasi bahasa dengan sangat positif baik dari sudut pandang teknis maupun sudut pandang yang diterapkan. <br><br>  <b>FP vs OOP</b> <br><br>  Pertanyaan lain yang sering diajukan dalam diskusi tersebut adalah apakah bahasa Scala harus terus mematuhi sintesis OOP dan FP, atau haruskah itu berkembang di sepanjang jalur yang murni fungsional.  Saya adalah <b>pendukung sintesis</b> , terutama karena FP dan OOP, menurut pendapat saya, bukan pendekatan alternatif, tetapi saling melengkapi. <br><br>  FP <b>pemrograman menggunakan fungsi</b> , meskipun tidak ada, tetapi transparan referensial (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk reddit</a> di utas sebelumnya, di mana transparansi referensial dijelaskan dengan sempurna).  Dalam OOP, komunikasi dengan objek diatur menggunakan "pesan" atau, dalam terminologi kami, panggilan ke metode virtual.  Tidak ada satu alasan pun mengapa kedua pendekatan ini tidak dapat hidup berdampingan, dan Scala telah menunjukkan ini! <br><br>  Dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tweet tentang keutamaan Scala,</a> John de Goes menyebutkan beberapa fitur OOP yang berguna untuk pendekatan fungsional murni, khususnya, <b>modul kelas satu</b> (diperoleh dengan membuat objek), <b>sintaksis titik</b> (metode memanggil dalam objek), dan <b>instance</b> <b>kelas</b> / jenis sebagai konstruksi kelas satu .  Semua ini adalah elemen kombinasi sukses dari dua paradigma.  Mungkin ada lagi yang hanya sekitar sudut? <br><br>  Proyek "sintesis" belum selesai, pasti ada bidang untuk diskusi di sini.  Salah satu aspek yang tidak lengkap adalah sintaks yang diusulkan untuk metode ekstensi, yang seharusnya menggantikan konversi implisit yang jauh lebih membingungkan.  Lain adalah mengoptimalkan sintaks dari kelas tipe;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saran yang</a> dibuat beberapa waktu lalu jelas kasar dan tidak mencakup beberapa penggunaan monad yang paling umum di Scala.  Beberapa saran lebih baik, yang lain membutuhkan perbaikan, tetapi bagus bahwa mereka diterima dan diskusi sedang berlangsung;  terima kasih kepada mereka, bahasanya hidup dan, pada akhirnya, solusi terbaik adalah tetap di dalamnya. <br><br>  <b>Scala 3</b> <br><br>  Scala 3 akan dirilis dalam dua tahun.  Sejumlah kemungkinan menarik akan muncul di dalamnya, khususnya, jenis buram, parameter sifat, pendekatan metaprogramming baru, jenis gabungan &amp; &amp; persimpangan, jenis fungsi implisit - ini hanya beberapa contoh.  Tentu saja, ada kekhawatiran (yang beralasan) tentang migrasi. <br><br>  Sudah diketahui bahwa alat khusus akan diperkenalkan untuk <b>migrasi kode otomatis</b> dari Scala 2 ke Scala 3 menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scalafix</a> .  Karena Scala adalah bahasa yang diketik secara statis, tugas seperti itu dapat diselesaikan dalam skala besar dan jauh lebih sederhana daripada, misalnya, dalam Python.  Tapi, tentu saja, tidak ada keajaiban di sini: bahkan jika alat ini memberikan 99% cakupan kode yang benar, 1% dari kasus yang paling bermasalah masih akan tetap ada.  Karena Anda tidak dapat mengandalkan sihir, migrasi fragmen-fragmen ini perlu dilakukan secara manual. <br><br>  Ini adalah biaya untuk bekerja dengan bahasa yang berkembang aktif: Anda mendapatkan peluang terbaru, tetapi beberapa dari mereka sebenarnya tidak begitu baik dan perlu ditingkatkan.  Meski begitu, perubahan yang diusulkan tidak revolusioner.  Bahasa Scala 3 sangat mirip dengan Scala 2, tidak ada perubahan paradigma besar yang diharapkan. <br><br>  Sangat menggembirakan bahwa tim Scala serius tentang migrasi.  Sementara migrasi sebelumnya antara versi Scala yang lebih lama (mis. Dari 2.8 menjadi 2.9) cukup memberatkan, migrasi baru-baru ini berjalan jauh lebih baik.  Ada tiga pihak utama yang terlibat: EPFL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ScalaCenter</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lightbend</a> semuanya (sering bersama-sama) bekerja untuk memfasilitasi migrasi.  Misalnya, ada alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MIMA yang</a> kompatibel biner, dan banyak perpustakaan baru terus-menerus dibuat di komunitas untuk memastikan pekerjaan yang nyaman dengan versi Scala baru. <br><br>  Akhirnya, alat TASTY yang belum selesai (yang, karenanya, belum dapat dievaluasi) harus memastikan penggunaan file biner dari Scala 2 ke Scala 3. <br><br>  <b>Jadi mengapa menggunakan Scala?</b> <br><br>  Jadi, apa alasan untuk berhenti di Scala, jika Anda menganggap bahasa ini dari sudut pandang bisnis?  Semua keuntungan teknis di atas bermanfaat langsung untuk bisnis.  Ketika Anda memiliki bahasa di mana Anda dapat menulis kode kompleks dengan bug lebih sedikit, maka Anda diberikan penundaan minimal dalam hal dan pengguna puas.  Jika Anda mulai menulis aplikasi kompetitif yang praktis dan tidak tergelincir untuk Scala, yang disediakan alat khusus di Scala, ini akan menjadi manfaat serius bagi perusahaan Anda. <br><br>  Selain itu, jangan lupa tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spark</a> , platform terdepan untuk <b>analisis data terdistribusi</b> .  Scala digunakan tidak hanya untuk mengimplementasikan Spark seperti itu, tetapi juga untuk menentukan perhitungan sendiri.  Berikut ini adalah abstraksi berorientasi ilmu data lainnya yang menyembunyikan model komputasi yang kompleks. <br><br>  <b>Ringkasan</b> <br><br>  Tentu saja, ada masalah di Scala, tetapi di mana mereka tidak?  Alasan untuk optimisme adalah bahwa banyak orang yang menggunakan Scala setiap hari aktif bekerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan alat</a> , perpustakaan, dan bahasa itu sendiri.  Saya dapat berasumsi bahwa mereka terus bekerja dengan Scala justru karena, dengan semua kekurangan yang tersedia, tidak ada satu bahasa yang sangat cocok untuk bidang subjek mereka. <br><br>  Scala memungkinkan Anda untuk mengembangkan gaya pemrograman Anda sendiri, tidak peduli apa bahasa Anda dulu: Java, Ruby, atau coba saja diri Anda dalam pemrograman.  Tidak ada pendekatan unik untuk memenangkan Scala;  baik pendekatan Akka yang lebih <i>penting</i> , atau pendekatan yang lebih <i>fungsional</i> dari Kucing dan Scalaz. <br><br>  Di sinilah masalahnya dapat dilihat: ada sebagian kecil di komunitas Scala yang mematuhi pendekatan OOP / AF "reaktif", "sintetis", dan AF murni.  Namun, sebenarnya ini adalah keuntungan yang sangat besar.  Karena keragaman tersebut, diskusi diadakan, banyak pendapat yang berbeda diungkapkan dari sudut pandang yang berbeda.  Pada hal ini, pada gilirannya, Anda dapat dengan sempurna belajar bagaimana menyelesaikan masalah yang tidak standar dan memperkaya alat Anda sendiri. <br><br>  Apa pun jalur yang Anda pilih di Scala, Anda akan didukung oleh komunitas kolega yang mengesankan yang terlibat dalam pengembangan perpustakaan dan kerangka kerja;  orang-orang ini selalu siap membantu dan mendiskusikan ide-ide yang muncul. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423317/">https://habr.com/ru/post/id423317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423307/index.html">GitHub Tarik Permintaan dalam Kode Visual Studio</a></li>
<li><a href="../id423309/index.html">Transaksi DBMS</a></li>
<li><a href="../id423311/index.html">Naviaddress Kemitraan dan ACTUM</a></li>
<li><a href="../id423313/index.html">Sentuh I2C. Buat penganalisis logika sederhana</a></li>
<li><a href="../id423315/index.html">Teori Tautan Universal</a></li>
<li><a href="../id423319/index.html">Integrasi kode Vivaldi. Pengembang kami memberi tahu</a></li>
<li><a href="../id423321/index.html">Melindungi repositori GitHub dari komitmen jahat</a></li>
<li><a href="../id423323/index.html">"Kamu harus malas untuk menjadi penguji yang baik."</a></li>
<li><a href="../id423329/index.html">Mempersiapkan wawancara dengan perusahaan Lima Besar</a></li>
<li><a href="../id423335/index.html">Bagaimana cara mengalahkan klik di Y. Direct dan AdWords untuk 600 ribu rubel sebulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>