<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ“ ğŸ‘©ğŸ¾â€ğŸš€ ğŸ—œï¸ Bagaimana saya mencoba membuat analisa statis GLSL (dan apa yang salah) ğŸ‘µ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ¦ˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu ketika saya sedang mempersiapkan Ludum Dare dan membuat game sederhana di mana saya menggunakan pixel shaders (yang lain tidak dibawa ke mesin P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya mencoba membuat analisa statis GLSL (dan apa yang salah)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428027/"><p> Suatu ketika saya sedang mempersiapkan Ludum Dare dan membuat game sederhana di mana saya menggunakan pixel shaders (yang lain tidak dibawa ke mesin Phaser). </p><br><div class="spoiler">  <b class="spoiler_title">Apa itu shader?</b> <div class="spoiler_text"><p>  Shader adalah program mirip GLSL C yang berjalan pada kartu grafis.  Ada dua jenis shader, dalam artikel ini kita berbicara tentang pixel shaders (mereka juga "fragmen", fragmen shaders), yang secara kasar dapat direpresentasikan dalam bentuk ini: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  Yaitu  shader dijalankan untuk setiap piksel dari gambar keluaran, menentukan atau menyempurnakan warnanya. <br>  Anda dapat membaca artikel pengantar tentang artikel lain di hub - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/333002/</a> </p></div></div><br><p>  Setelah pengujian, saya melemparkan tautan ke seorang teman, dan menerima tangkapan layar darinya dengan pertanyaan "apakah ini normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  Tidak, itu tidak normal.  Setelah memperhatikan kode shader dengan cermat, saya menemukan kesalahan perhitungan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Karena  Karena R1 konstan kurang dari M, dalam beberapa kasus hasil dalam argumen pertama pow adalah angka kurang dari nol.  Akar kuadrat dari angka negatif adalah hal yang misterius, setidaknya untuk standar GLSL.  Kartu video saya tidak bingung, dan entah bagaimana ia keluar dari posisi ini (tampaknya, setelah kembali dari pow 0), tetapi ternyata lebih terbaca oleh seorang teman. </p><br><p>  Dan kemudian saya berpikir: bisakah saya menghindari masalah seperti itu di masa depan?  Tidak ada yang aman dari kesalahan, terutama yang tidak direproduksi secara lokal.  Anda tidak dapat menulis unit test untuk GLSL.  Pada saat yang sama, transformasi di dalam shader cukup sederhana - perkalian, pembagian, sinus, cosinus ... Apakah benar-benar mustahil untuk melacak nilai-nilai setiap variabel dan memastikan bahwa dalam keadaan apa pun ia melampaui batas-batas nilai yang diizinkan? </p><br><p>  Jadi saya memutuskan untuk mencoba melakukan analisis statis untuk GLSL.  Apa yang terjadi - Anda dapat membacanya di bawah potongan. </p><br><p>  Saya akan segera memperingatkan Anda: Saya tidak bisa mendapatkan produk jadi, hanya prototipe pendidikan. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  Analisis pendahuluan </h2><br><p>  Setelah mempelajari sedikit artikel yang ada tentang topik ini (dan menemukan bahwa topik tersebut disebut Analisis Rentang Nilai), saya senang bahwa saya memiliki GLSL, dan bukan bahasa lain.  Nilailah sendiri: </p><br><ul><li>  no "dynamics" - referensi ke fungsi, antarmuka, tipe yang disimpulkan secara otomatis, dll. </li><li>  tidak ada penanganan memori langsung </li><li>  tidak ada modul, yang menghubungkan, mengikat akhir - seluruh kode sumber shader tersedia <br>  rentang umumnya dikenal untuk nilai input </li><li>  beberapa tipe data, dan yang berputar di sekitar float.  int / bool jarang digunakan, dan tidak begitu penting untuk mengikutinya </li><li>  seandainya loop jarang digunakan (karena masalah kinerja).  loop, jika digunakan, sering kali merupakan penghitung sederhana untuk melalui array atau mengulangi efek tertentu beberapa kali.  Tidak ada yang akan menulis kengerian seperti itu di GLSL (saya harap). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j â€“ <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Secara umum, mengingat keterbatasan GLSL, tugas tampaknya dapat dipecahkan.  Algoritma utamanya adalah sebagai berikut: </p><br><ol><li>  parsing kode shader dan buat urutan perintah yang mengubah nilai variabel apa pun </li><li>  mengetahui rentang awal untuk variabel, melalui urutan, memperbarui rentang ketika mereka berubah </li><li>  jika rentang melanggar batas apa pun yang diberikan (misalnya, angka negatif mungkin muncul, atau sesuatu yang lebih besar dari 1 akan sampai pada "warna keluaran" gl_FragColor dalam komponen merah), Anda perlu menampilkan peringatan </li></ol><br><h2 id="ispolzuemye-tehnologii">  Teknologi yang digunakan </h2><br><p>  Di sini saya punya pilihan yang panjang dan menyakitkan.  Di satu sisi, ruang lingkup utama saya adalah memeriksa shader WebGL, jadi mengapa tidak javascript untuk menjalankan semua yang ada di browser selama pengembangan.  Di sisi lain, saya telah berencana untuk turun dari Phaser untuk waktu yang lama dan mencoba mesin lain seperti Unity atau LibGDX.  Akan ada shader, tetapi javascript akan hilang. </p><br><p>  Dan di pihak ketiga, tugas itu dilakukan terutama untuk hiburan.  Dan hiburan terbaik di dunia adalah kebun binatang.  Oleh karena itu: </p><br><ol><li>  Penguraian kode GLSL dilakukan dalam javascript.  Hanya saja saya cukup cepat menemukan perpustakaan untuk mem-parsing GLSL di AST di atasnya, dan tes UI tampaknya lebih akrab dengan yang berbasis web.  AST berubah menjadi urutan perintah, yang dikirim ke ... </li><li>  ... bagian kedua, yang ditulis dalam C ++ dan dikompilasi ke dalam WebAssembly.  Saya memutuskan dengan cara ini: jika saya tiba-tiba ingin mempercepat penganalisis ini ke mesin lain, dengan perpustakaan C ++ ini harus dilakukan paling sederhana. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Beberapa kata tentang toolkit</b> <div class="spoiler_text"><ul><li>  Saya mengambil Visual Studio Code sebagai IDE utama dan umumnya senang dengan itu.  Saya perlu sedikit kebahagiaan - yang utama adalah bahwa Ctrl + Click harus berfungsi dan dilengkapi otomatis saat mengetik.  Kedua fungsi bekerja dengan baik di C ++ dan JS.  Yah, kemampuan untuk tidak mengganti IDE yang berbeda di antara mereka sendiri juga bagus. </li><li>  untuk mengkompilasi C ++, WebAssembly menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cheerp</a> (dibayar, tetapi gratis untuk proyek sumber terbuka).  Saya tidak menemui masalah dengan penggunaannya, kecuali bahwa itu dioptimalkan kode agak aneh, tapi di sini saya tidak yakin siapa yang salah itu - gumpalan itu sendiri atau dentang compiler yang digunakan olehnya. </li><li>  untuk unit test di C ++ mengambil gtest lama yang bagus </li><li>  untuk membangun js dalam bundel mengambil beberapa microbundle.  Dia memenuhi persyaratan saya "Saya ingin paket 1 npm dan beberapa flag command line", tetapi pada saat yang sama tidak tanpa masalah, sayangnya.  Katakanlah menonton macet pada kesalahan apa pun saat mem-parsing javascript masuk dengan pesan <code>[Object object]</code> , yang tidak banyak membantu. </li></ul></div></div><br><p>  Segalanya, sekarang Anda bisa pergi. </p><br><h2 id="korotko-o-modeli">  Secara singkat tentang model </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  Penganalisis menyimpan dalam memori daftar variabel yang ditemukan di shader, dan untuk masing-masing menyimpan rentang nilai saat ini yang mungkin (seperti <code>[0,1]</code> atau <code>[1,âˆ)</code> ). </p><br><p>  Penganalisa menerima alur kerja seperti ini: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Di sini kita memanggil fungsi sin, variabel dengan id = 3 dan 4 diumpankan ke dalamnya, dan hasilnya ditulis ke variabel 1 dan 2. Panggilan ini sesuai dengan GLSL-th: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Perhatikan argumen kosong (ditandai sebagai "-").  Di GLSL, hampir semua fungsi bawaan kelebihan beban untuk set tipe input yang berbeda, mis.  ada <code>sin(float)</code> , <code>sin(vec2)</code> , <code>sin(vec3)</code> , <code>sin(vec4)</code> .  Untuk kenyamanan, saya membawa semua versi kelebihan beban ke satu bentuk - dalam hal ini <code>sin(vec4)</code> . </p><br><p>  Analyzer mengeluarkan daftar perubahan untuk setiap variabel, seperti </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Yang berarti "variabel 2 pada baris 10 di cabang 1 memiliki kisaran dari -1 hingga 1 inklusif" (kita akan berbicara tentang cabang sedikit kemudian).  Sekarang Anda dapat dengan indah menyoroti rentang nilai dalam kode sumber. </p><br><h2 id="horoshee-nachalo">  Awal yang bagus </h2><br><p>  Ketika pohon AST sudah mulai berubah menjadi daftar perintah, sekarang saatnya untuk mengimplementasikan fungsi dan metode standar.  Ada cukup banyak dari mereka (dan mereka juga memiliki banyak kelebihan, seperti yang saya tulis di atas), tetapi secara umum mereka memiliki transformasi rentang yang dapat diprediksi.  Katakanlah, untuk contoh seperti itu, semuanya ternyata cukup jelas: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-âˆ,âˆ) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  Saluran merah dari warna output berada dalam kisaran yang dapat diterima, tidak ada kesalahan. </p><br><p>  Jika Anda membahas lebih banyak fungsi bawaan, maka untuk setengah shader, analisis seperti itu sudah cukup.  Tetapi bagaimana dengan babak kedua - dengan kondisi, putaran, dan fungsi? </p><br><h2 id="vetvleniya">  Cabang </h2><br><p>  Ambil contoh shader semacam itu. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Variabel <code>a</code> diambil dari tekstur, dan oleh karena itu nilai variabel ini terletak dari 0 hingga 1. Tetapi nilai apa yang dapat diambil <code>k</code> ? </p><br><p>  Anda dapat pergi dengan cara sederhana dan "satukan cabang-cabang" - hitung kisaran dalam setiap kasus dan berikan totalnya.  Untuk cabang if, kita mendapatkan <code>k = [0,2]</code> , dan untuk cabang lain, <code>k = [0,1]</code> .  Jika Anda menggabungkan, ternyata <code>[0,2]</code> , dan Anda harus memberikan kesalahan, karena  nilai yang lebih besar dari 1 termasuk dalam warna keluaran <code>gl_FragColor</code> . </p><br><p>  Namun, ini adalah alarm palsu yang jelas, dan untuk analisa statis tidak ada yang lebih buruk daripada alarm palsu - jika tidak dimatikan setelah teriakan pertama "serigala", maka setelah kesepuluh pasti. </p><br><p>  Jadi, kita perlu memproses kedua cabang secara terpisah, dan di kedua cabang kita perlu memperjelas kisaran variabel <code>a</code> (walaupun secara resmi belum diubah).  Begini tampilannya: </p><br><p>  Cabang 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Cabang 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Dengan demikian, ketika penganalisa menemukan suatu kondisi tertentu yang berperilaku berbeda tergantung pada kisaran, itu menciptakan cabang (brunch) untuk masing-masing kasus.  Dalam setiap kasus, ia memperbaiki kisaran variabel sumber dan bergerak lebih jauh ke bawah daftar perintah. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  Perlu diperjelas bahwa cabang-cabang dalam kasus ini tidak terkait dengan konstruksi if-else.  Cabang dibuat ketika rentang variabel dibagi menjadi sub-rentang, dan penyebabnya mungkin merupakan pernyataan kondisional opsional.  Misalnya, fungsi langkah juga membuat cabang.  Shader GLSL berikutnya melakukan hal yang sama dengan yang sebelumnya, tetapi tidak menggunakan percabangan (yang, omong-omong, lebih baik dalam hal kinerja). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  Fungsi langkah harus mengembalikan 0 jika a &lt;0,5 dan 1 sebaliknya.  Oleh karena itu, cabang juga akan dibuat di sini - mirip dengan contoh sebelumnya. </p><br><h2 id="utochnenie-drugih-peremennyh">  Penyempurnaan variabel lainnya </h2><br><p>  Pertimbangkan contoh sebelumnya yang sedikit dimodifikasi: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Berikut nuansanya sebagai berikut: percabangan terjadi sehubungan dengan variabel <code>b</code> , dan perhitungan terjadi dengan variabel <code>a</code> .  Artinya, di dalam setiap cabang akan ada nilai yang benar dari rentang <code>b</code> , tetapi sama sekali tidak perlu, dan nilai asli dari kisaran <code>a</code> , sepenuhnya salah. </p><br><p>  Namun, penganalisa melihat bahwa rentang <code>b</code> diperoleh dengan menghitung dari <code>a</code> .  Jika Anda mengingat informasi ini, maka saat bercabang, penganalisis dapat melalui semua variabel sumber dan menyempurnakan jangkauannya dengan melakukan perhitungan terbalik. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Fungsi dan Putaran </h2><br><p>  GLSL tidak memiliki metode virtual, pointer fungsi, atau bahkan panggilan rekursif, sehingga setiap panggilan fungsi unik.  Oleh karena itu, paling mudah untuk memasukkan tubuh fungsi di tempat panggilan (inline, dengan kata lain).  Ini akan sepenuhnya konsisten dengan urutan perintah. </p><br><p>  Ini lebih rumit dengan siklus, karena  secara formal, GLSL sepenuhnya mendukung C-like for loop.  Namun, paling sering, loop digunakan dalam bentuk paling sederhana, seperti ini: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  Siklus seperti itu mudah untuk "disebarkan", yaitu  masukkan badan loop 12 kali satu demi satu.  Akibatnya, setelah berpikir, saya memutuskan sejauh ini hanya mendukung opsi seperti itu. </p><br><p>  Keuntungan dari pendekatan ini adalah bahwa perintah dapat dikeluarkan dalam aliran ke penganalisis tanpa harus menghafal setiap fragmen (seperti badan fungsi atau loop) untuk digunakan kembali lebih lanjut. </p><br><h2 id="vsplyvshie-problemy">  Muncul masalah </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Masalah # 1: kesulitan atau ketidakmampuan untuk mengklarifikasi </h3><br><p>  Di atas, kami memeriksa kasus-kasus ketika, ketika memperbaiki nilai-nilai satu variabel, kami menarik kesimpulan tentang nilai-nilai variabel lain.  Dan masalah ini diselesaikan ketika operasi seperti penambahan / pengurangan terlibat.  Tapi, katakanlah, apa yang harus dilakukan dengan trigonometri?  Misalnya, kondisi seperti itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  Bagaimana cara menghitung rentang <code>a</code> dalam jika?  Ternyata rangkaian rentang tak berujung dengan langkah pi, yang kemudian akan sangat tidak nyaman untuk digunakan. </p><br><p>  Dan mungkin ada situasi seperti itu: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Klarifikasi rentang <code>a</code> dan <code>b</code> dalam kasus umum tidak realistis.  Dan, oleh karena itu, positif palsu mungkin terjadi. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Masalah # 2: Ranges Bergantung </h3><br><p>  Pertimbangkan contoh ini: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  Untuk memulainya, analisa mempertimbangkan kisaran variabel <code>val2</code> - dan diharapkan menjadi <code>[0,1] - 1 == [-1, 0]</code> </p><br><p>  Namun, kemudian, dengan mempertimbangkan <code>value - val2</code> , penganalisa tidak memperhitungkan bahwa <code>val2</code> diperoleh dari <code>value</code> , dan bekerja dengan rentang seolah - olah mereka saling independen.  Mendapat <code>[0,1] - [-1,0] = [0,2]</code> , dan melaporkan kesalahan.  Meskipun dalam kenyataannya ia seharusnya mendapat konstanta 1. </p><br><p>  Kemungkinan solusi: untuk menyimpan untuk setiap variabel tidak hanya sejarah rentang, tetapi juga seluruh "pohon keluarga" - yang variabel bergantung, operasi mana, dan sebagainya.  Hal lain adalah bahwa untuk "membuka" silsilah ini tidak akan mudah. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Masalah # 3: Kisaran tergantung secara implisit </h3><br><p>  Berikut ini sebuah contoh: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Di sini, penganalisa akan mengasumsikan bahwa kisaran <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  Yang salah, karena  <code>sin(a) + cos(a)</code> untuk setiap kebohongan dalam kisaran <code>[-âˆš2, âˆš2]</code> . </p><br><p>  Hasil perhitungan <code>sin(a)</code> secara formal tidak tergantung pada hasil perhitungan <code>cos(a)</code> .  Namun, mereka bergantung pada kisaran <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Ringkasan dan Kesimpulan </h2><br><p>  Ternyata, membuat analisis rentang nilai bahkan untuk bahasa yang sederhana dan sangat khusus seperti GLSL bukanlah tugas yang mudah.  Cakupan fitur bahasa masih dapat diperkuat: mendukung array, matriks, dan semua operasi built-in adalah tugas teknis murni yang hanya membutuhkan waktu.  Tetapi bagaimana mengatasi situasi dengan ketergantungan antar variabel - pertanyaannya masih belum jelas bagi saya.  Tanpa menyelesaikan masalah-masalah ini, false positive tidak dapat dihindari, kebisingan yang akhirnya dapat melebihi manfaat analisis statis. </p><br><p>  Mengingat apa yang saya temui, saya tidak terlalu terkejut dengan tidak adanya beberapa alat yang terkenal untuk analisis rentang nilai dalam bahasa lain - jelas ada lebih banyak masalah di dalamnya daripada di GLSL yang relatif sederhana.  Pada saat yang sama, Anda dapat menulis setidaknya unit test dalam bahasa lain, tetapi di sini Anda tidak dapat melakukannya. </p><br><p>  Solusi alternatif dapat dikompilasi dari bahasa lain ke dalam GLSL - di sini baru-baru ini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang kompilasi dari kotlin</a> .  Kemudian Anda dapat menulis tes unit untuk kode sumber dan mencakup semua kondisi batas.  Atau buat "penganalisis dinamis" yang akan menjalankan data yang sama dengan yang pergi ke shader melalui kode kotlin asli dan memperingatkan tentang kemungkinan masalah. </p><br><p>  Jadi pada titik ini saya berhenti.  Perpustakaan, sayangnya, tidak berfungsi, tetapi mungkin prototipe ini berguna bagi seseorang. </p><br><p>  Repositori di github, untuk ditinjau: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Untuk mencoba: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonus: fitur webassembly dengan berbagai flag compiler </h2><br><p>  Awalnya, saya melakukan analisa tanpa menggunakan stdlib - cara kuno, dengan array dan pointer.  Pada saat itu saya sangat khawatir tentang ukuran file output wasm, saya ingin itu kecil.  Tetapi mulai dari beberapa titik saya mulai merasa tidak nyaman dan karena itu memutuskan untuk mentransfer semuanya ke stdlib - pointer cerdas, koleksi normal, itu saja. </p><br><p>  Oleh karena itu, saya mendapat kesempatan untuk membandingkan hasil perakitan dua versi perpustakaan - dengan dan tanpa stdlib.  Nah, lihat juga seberapa baik / buruknya ciak (dan dentang yang digunakan olehnya) mengoptimalkan kode. </p><br><p>  Oleh karena itu, saya mengkompilasi kedua versi dengan set flag optimasi yang berbeda ( <code>-O1</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> dan <code>-Oz</code> ), dan untuk beberapa versi ini saya mengukur kecepatan analisis 3.000 operasi dengan 1.000 cabang.  Saya setuju, bukan contoh terbesar, tetapi IMHO cukup untuk analisis komparatif. </p><br><p>  Apa yang terjadi sesuai dengan ukuran file wasm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  Anehnya, opsi ukuran dengan optimasi "nol" lebih baik daripada hampir semua yang lain.  Saya akan berasumsi bahwa dalam <code>O3</code> garis agresif segala sesuatu di dunia, yang mengembang biner.  Versi yang diharapkan tanpa stdlib lebih ringkas, tetapi tidak terlalu banyak <del>  menanggung penghinaan seperti itu </del>  untuk menghilangkan kesenangan bekerja dengan koleksi yang nyaman. </p><br><p>  Dengan kecepatan eksekusi: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Sekarang saya bisa melihat bahwa <code>-O3</code> tidak sia-sia memakan rotinya, jika dibandingkan dengan <code>-O0</code> .  Pada saat yang sama, perbedaan antara versi dengan dan tanpa stdlib praktis tidak ada (saya melakukan 10 pengukuran, saya pikir dengan jumlah yang lebih besar perbedaannya akan hilang sama sekali). </p><br><p>  Perlu dicatat 2 poin: </p><br><ul><li>  Grafik menunjukkan nilai rata-rata dari 10 kali berturut-turut analisis, tetapi dalam semua tes analisis pertama berlangsung 2 kali lebih lama daripada yang lain (mis., Katakanlah, 120 ms, dan yang berikutnya sudah sekitar 60 ms).  Mungkin ada beberapa inisialisasi WebAssembly. </li><li>  Dengan flag <code>-O3</code> , saya mengambil beberapa bug yang sangat aneh yang tidak saya tangkap untuk flag lainnya.  Misalnya, fungsi min dan maks tiba-tiba mulai bekerja dengan cara yang sama - seperti min. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Terima kasih atas perhatiannya. <br>  Biarkan nilai-nilai variabel Anda tidak pernah melampaui batas. <br>  Dan ini dia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428027/">https://habr.com/ru/post/id428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428011/index.html">Lagu-lagu ruang zombie</a></li>
<li><a href="../id428019/index.html">Mainkan Mortal Kombat dengan TensorFlow.js</a></li>
<li><a href="../id428021/index.html">Stempel terhadap jaringan saraf. Atau pilih dan jalankan jaringan saraf untuk mengenali objek pada Raspberry Zero</a></li>
<li><a href="../id428023/index.html">Dasar-dasar keselamatan listrik dalam desain perangkat elektronik</a></li>
<li><a href="../id428025/index.html">Menghubungkan file swap (SWAP) di MAC OS X saat menggunakan SSD eksternal sebagai suatu sistem</a></li>
<li><a href="../id428029/index.html">Acara digital di Moskow dari 29 Oktober hingga 4 November</a></li>
<li><a href="../id428031/index.html">3CX integrasi dengan 1C: Manajemen Perdagangan - metode menggabungkan konfigurasi</a></li>
<li><a href="../id428033/index.html">Di AS, perangkat cerdas peretasan yang disahkan dan komputer terpasang untuk tujuan perbaikan dan peningkatan</a></li>
<li><a href="../id428035/index.html">Red Hat akan diserap oleh IBM</a></li>
<li><a href="../id428039/index.html">Pemerintah tidak berencana untuk mengadvokasi netralitas jaringan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>