<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏼 📜 🥀 Model manajemen program otomatis 💬 🚙 ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Pendahuluan 
 Dalam [1], jawaban diberikan untuk pertanyaan tentang apa yang dianggap pemrograman otomatis (AP), tetapi model mesin keadaan terbata...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Model manajemen program otomatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1. Pendahuluan </h3><br>  Dalam [1], jawaban diberikan untuk pertanyaan tentang apa yang dianggap pemrograman otomatis (AP), tetapi model mesin keadaan terbatas (SC) tidak dijelaskan secara rinci sebagai model kontrol program otomatis.  Jelas bahwa otomat abstrak murni tidak cocok untuk peran ini, karena  dibatasi oleh jumlah saluran.  Tetapi model struktural otomat, serta teori automata struktural yang sesuai dengannya, belum memungkinkan untuk memberikan jawaban tentang pilihan model otomat. <br><br>  Masalahnya dimulai dengan fakta bahwa di antara banyak karya pada teori finite automata (TCA) ada beberapa yang memberikan definisi model struktural otomat terbatas (SCA).  Benar, orang dapat memahami bahwa otomat struktural adalah diagram [struktural] automata elementer (elemen fungsional) yang mengimplementasikan model otomat abstrak [2].  Ingatlah bahwa, sesuai dengan teori, semuanya dimulai dengan membuat model perangkat dalam bentuk otomat abstrak, dan kemudian tugasnya adalah mensintesis sirkuit digital yang mengimplementasikannya [3]. <br><br>  Pemrograman sekilas tampak sedikit seperti sintesis sirkuit digital.  Tapi baru pada awalnya.  Pertama, di sana dan di sana semuanya dimulai dengan suatu algoritma.  Kedua, masalah struktural pengorganisasian dan implementasi sirkuit digital dan pemrograman memiliki banyak kesamaan, terutama dalam konteks pemrograman paralel.  Tetapi kita akan membahas topik paralelisme secara terpisah.  Sementara itu, tugas kita adalah memilih dan / atau memodifikasi model mesin negara yang terbatas, yang dapat dimengerti, nyaman, dan menyenangkan bagi para programmer yang dimanjakan oleh berbagai perangkat lunak. <br><br>  Benar, pertanyaannya langsung logis - mengapa ada satu "toolkit otomatis" yang agak tidak biasa?  Kami akan mencoba menjawab pertanyaan ini dengan mendefinisikan model kendali otomatis [bersarang], dengan mempertimbangkan juga kelebihannya dibandingkan dengan model pemrograman yang biasa. <br><a name="habracut"></a><br><h3>  2. Definisi model kontrol program otomatis </h3><br>  Dalam proses evolusi, praktik pemrograman telah membentuk persyaratan tertentu untuk model manajemen program.  Harus diakui bahwa model mesin negara terbatas klasik hanya sedikit bersesuaian dengan mereka.  Dan jika tugasnya adalah menggunakan automata dalam pemrograman, maka itu perlu diadaptasi.  Sangat diinginkan untuk melakukan ini dalam kerangka teori automata.  Klaim utama terhadap AP yang ada dikurangi menjadi fakta bahwa kondisi ini dilanggar. <br><br>  <i>Definisi 1.</i> Kita menyebut <i>bentuk normal disjunctive normal finite automata (DNKA)</i> finite automata yang terdefinisi penuh yang transisinya dilabeli oleh konjungsi elementer variabel logis. <br><br>  Model DNA didasarkan pada model formal <i>automata yang</i> sepenuhnya (sepenuhnya) didefinisikan <i>dengan keadaan abstrak</i> [4] dan <i>automata logis</i> [5]. <br><br>  <i>Definisi 2.</i> Kami menyebut <i>bentuk disjungtif a finite automaton (DFA) sebagai</i> automaton dalam bentuk DFA yang hanya berisi <i>transisi yang dihasilkan</i> . <br><br>  Transisi yang ditandai dengan sinyal keluaran dan transisi dengan tanda di tempat sinyal keluaran yang mengubah keadaan saat ini dari automaton diklasifikasikan sebagai transisi yang efektif.  Transisi yang tidak termasuk dalam deskripsi otomat disjungtif merupakan <i>tambahan dari DKA (DDA)</i> ke otomat DFA yang didefinisikan sepenuhnya.  Penambahan semacam itu adalah otomat yang terdiri dari keadaan terisolasi dengan transisi dalam bentuk loop dan dengan tanda hubung di tempat sinyal keluaran. <br><br><h3>  3. Model memori untuk model perhitungan AP </h3><br>  Kehadiran banyak input dan output DFA menetapkan paralelisme operator perangkat lunak / fungsi yang terkait dengannya.  Untuk implementasinya yang benar, diperlukan model memori tipe CREW (concurrent read Exclusive - write) [6].  Dalam kerangka kerjanya, pembacaan nilai data saat ini diperbolehkan pada bagian dari set semua fungsi (predikat dan tindakan), dan hanya satu dari mereka yang diizinkan untuk mengubah <i>data umum</i> untuk tindakan paralel yang dapat dieksekusi. <br><br>  Model kontrol otomatis, berbeda dengan model komputasi multi-threaded, jelas membatasi eksekusi operator / fungsi program otomatis hingga batas siklus waktu diskrit.  Dalam situasi seperti itu, setiap perubahan pada memori dengan tindakan yang dilakukan pada siklus jam saat ini dapat ditulis ke <i>"memori bayangan"</i> , sehingga setelah selesai dan sebelum dimulainya siklus jam diskrit berikutnya, itu menjadi nilai-nilai baru. <br><br>  Interaksi operator program otomat dengan memori akan disebut <i>model memori bayangan</i> .  Model ini merupakan bagian penting dari model umum pemrograman otomatis.  Ini memastikan kebenaran operasi paralel dari operator AP dan menyederhanakan pemrograman proses paralel. <br><br>  Dalam kerangka model memori, mekanisme yang kompleks dan tidak terlalu andal untuk sinkronisasi multi-threaded dari proses sebenarnya tidak diperlukan (untuk lebih jelasnya lihat [7]).  Tetapi jika perlu, karena kesetaraan automata dan <i>grafik-skema algoritma (GAW)</i> [8], model pemrograman otomatis tidak membatasi aplikasi mereka. <br><br><h3>  4. Model automata yang bersarang dan inersia </h3><br>  Tugas menciptakan model elemen logika penundaan, dipilih lebih lanjut sebagai contoh, di satu sisi, menunjukkan masalah model klasik otomat, dan, di sisi lain, mencerminkan kualitas model DFA yang menyelesaikan masalah algoritmik dengan cara yang lebih visual dan nyaman.  Model diperkenalkan automata bersarang menghasilkan subkelas model otomat, selanjutnya disebut sebagai <i>automata inersia</i> , dan subkelas yang sesuai dari <i>algoritma inersia</i> . <br><br>  Jadi, biarlah tugas menciptakan model diskrit dari elemen logika tunda yang mengimplementasikan transmisi sinyal input biner.  Selain itu, waktu penundaan t01 dan t10, masing-masing, ke unit dan keadaan nol dalam kasus umum tidak bersamaan. <br><br>  Model paling sederhana dari <i>keterlambatan tunggal</i> dalam bentuk otomat Mealy ditunjukkan pada Gambar.  1 (lihat, untuk perbandingan, model keterlambatan dalam [2]).  Penundaannya ditentukan oleh satu siklus clock diskrit tunggal.  Model penundaan <i>transportasi yang</i> lebih kompleks (untuk rincian lebih lanjut tentang jenis keterlambatan lihat [9]) dalam bentuk otomat Miley dan model Miley-Moore gabungan disajikan, masing-masing, pada Gambar.  2a dan ara.  2b. <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="gambar"><br>  Fig.  1. Model unit delay dalam bentuk otomat Miles <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="gambar"><br>  Fig.  2. Model keterlambatan transportasi Miles (a) dan Miles-Moore (b) <br><br>  Sinyal input x3 (kita ingat bahwa dalam program otomatis ini sesuai dengan predikat [1]) mengambil nilai sebenarnya jika nilai penghitung jam sama dengan nilai variabel t sama dengan penundaan t01 atau t10.  Nilai variabel t ditugaskan untuk sinyal y3 dan y4 (dalam program, fungsi aksi dengan nama yang sama dengan sinyal output).  Sinyal y1, y2 mengatur nilai variabel yang mewakili output model.  Sinyal y5 menambah penghitung jam, yang diatur ulang oleh sinyal y6. <br><br>  <i>Catatan 2. Keadaan internal model pada Gambar.</i>  <i>1, akan lebih mudah untuk diasosiasikan dengan status keluaran suatu elemen.</i>  <i>Ini memungkinkan kita untuk mengecualikan tidak hanya operator y1 dan y2, tetapi juga variabel output itu sendiri.</i> <i><br></i> <br>  Implementasi penanaman automata mirip dengan memanggil subrutin membentuk teknologi pemrograman otomat modular.  Pada saat yang sama, di tingkat perangkat lunak, berbeda dengan upaya serupa di tingkat perangkat keras (lihat [10] untuk perbandingan), ini jauh lebih sederhana.  Untuk melakukan ini, Anda harus memasukkan panggilan program dari nested automaton, dan kemudian kernel dari implementasi automata, seperti prosesor normal, mengatur pengembalian kontrol ke level saat ini untuk bersarang. <br><br>  <i>Definisi 3. Automata bersarang</i> akan disebut automata dengan keadaan akhir, transisi yang memulai prosedur kembali ke tingkat (peringkat) bersarang sebelumnya. <br><br>  Implementasi yang benar dari bersarang automata memberlakukan batasan pada prosedur untuk pembuatannya.  Pertama, automaton bersarang hanya bisa berada di bawahnya.  Selain itu, otomat tingkat atas, tidak termasuk peringkat nol, juga bisa menjadi otomat bersarang.  Kedua, pada setiap transisi <b>hanya satu</b> automaton bersarang dapat dibuat.  Mekanisme nested automata juga menciptakan dasar untuk penerapan algoritma rekursif berdasarkan kontrol otomatis. <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="gambar"><br>  Fig.  3. Model keterlambatan dalam bentuk automata bersarang <br><br>  Gambar. 3 menunjukkan model penundaan, di mana Gambar. 3a mewakili model tingkat atas, dan Gambar. 3b dan Gambar.  3c - varian automata bersarang untuk transportasi dan penundaan <i>inersia</i> (untuk detail lebih lanjut tentang jenis penundaan lihat [8]).  Pada saat yang sama, ini adalah contoh dari dua jenis automata bersarang - <i>biasa</i> dan <i>inersia</i> .  Jenis otomat bersarang ditentukan oleh nama status akhirnya: keadaan dengan nama "00" menentukan jalan keluar yang biasa dari otomat bertingkat, dan keadaan dengan nama "XX" tidak mengubah keadaan saat ini dari otomat tingkat atas. <br><br>  Penjelasan penting untuk memahami algoritma penundaan inersia.  Untuk itu (lihat Gbr. 3c), nilai predikat x1 tergantung pada transisi tempat automaton tertanam dibuat.  Dengan kata lain, predikat dalam status "0" mengontrol pelestarian "nol" pada input, dan pada kondisi "1", sebaliknya, "unit".  Jika nilai pada input adalah nol pada nilai nol dari output, maka Anda harus mengembalikan nilai sebenarnya.  Lebih lanjut, jika stabilitas input dilanggar (nilai x1 salah) dan waktu tunda belum kedaluwarsa (nilai x3 salah), maka jalan keluar dari mesin tertanam direalisasikan melalui keadaan inersia (lihat Gambar 3c). <br><br>  <i>Definisi 4.</i> Automata, termasuk panggilan automata bersarang yang memiliki keadaan inersia akhir, akan disebut <i>automata inersia</i> . <br><br>  Dalam model pada Gambar. 3a, tindakan z1 (simbol z dipilih untuk nama-nama tindakan yang mencakup panggilan ke robot bersarang) membuat robot bersarang jika nilai penundaan ditentukan.  Sebagai bagian dari tindakan ini, jenis penundaan yang ditentukan ditentukan, sesuai dengan yang dibuat oleh salah satu automata bersarang, ditunjukkan pada Gambar.3b atau Gambar.  3c. <br><br>  Pada tingkat atas hierarki, pandangan otomat pada Gambar. 3a benar-benar bertepatan dalam struktur dengan model pada Gambar. 1, berbeda hanya dengan adanya tindakan pada transisi.  Penundaan dengan nata automata memiliki bentuk yang lebih sederhana dibandingkan dengan model tingkat tunggal pada Gambar. 2.  Otomat bersarang juga dapat dianggap sebagai semacam "otomat perpustakaan" yang dapat dipanggil dari otomat lain. <br><br><h3>  3. Pemrograman otomat objek </h3><br>  Model kontrol otomatis, selain bentuk grafik, juga memiliki bentuk tabel sederhana - tabel transisi (TP), yang dapat secara efektif ditafsirkan dalam C ++.  Dalam kerangka kerjanya, program otomat terpisah (atau bagian darinya) dan, dengan demikian, definisinya dalam bentuk rangkaian program S dapat diwakili oleh kelas.  Dalam hal ini, model memori akan sesuai dengan properti kelas, rangkaian operasi akan sesuai dengan metode kelas, dan kontrol otomatis dalam bentuk TP akan menggambarkan perilaku kelas.  Pengenalan kontrol ke dalam kelas memungkinkan kita untuk berbicara tentang objek aktif, juga sering disebut agen, dll. <br><br>  Banyak objek dengan perilaku dalam bentuk kontrol otomat memformalkan konsep <i>program paralel otomat objek</i> .  Dalam hal ini, model dari setiap program paralel dapat diwakili oleh diagram program di mana kontrol C akan disajikan dalam bentuk jaringan otomat, di mana komponen automata menggambarkan perilaku objek aktif, memori M diwakili oleh kombinasi sifat-sifat objek, dan banyak operator A diwakili oleh kombinasi metode objek program. <br><br>  Dalam lingkungan VKPA, peran bahasa pemrograman otomatis ditugaskan ke bahasa C ++.  Dalam "C ++ otomatis", objek diberkahi dengan aktivitas / perilaku dan memiliki cara untuk menggambarkan dan menerapkan paralelisme, baik pada tingkat metode objek individu maupun pada tingkat menggambarkan operasi paralel banyak objek. <br><br>  Implementasi objek AP yang ada agak rumit.  Dalam VKPa, implementasi objeknya didasarkan pada interpretasi automata dan kontrol khusus program.  Tidak seperti implementasi langsung automata, yang digunakan, misalnya, dalam teknologi SWITH, ini menghilangkan prosedur untuk mengubah model otomat menjadi model diagram alur.  Algoritma interpretasi yang digunakan dalam VKPa mirip dengan metode menafsirkan tabel keputusan oleh E. Hamby [12]. <br><br>  Kecuali ditentukan lain, kami selanjutnya akan mengaitkan konsep program otomat dengan konsep <i>objek otomat (AO)</i> dalam arti OOP, tetapi dengan mempertimbangkan konsep program paralel objek otomat yang diperkenalkan di atas.  Karena itu, operator dan memori AP akan ditentukan melalui metode dan properti objek yang aktif.  Objek automata dibedakan dari objek biasa dengan keberadaan perilaku yang ditentukan oleh model mesin negara. <br><br><h3>  4. Kesimpulan </h3><br>  Membuat model automata bersarang adalah langkah menuju perubahan kualitatif dalam teknologi pemrograman.  Model inersia otomat yang dideskripsikan mirip dengan konsep status historis dalam UML.  Embedding automata yang biasa memiliki analog dalam pemrograman, "embedding inersia" tidak memilikinya, karena  Dalam suatu program, Anda tidak dapat kembali ke perintah sebelum panggilan subrutin.  Dan ini adalah elemen perbedaan kualitatif antara pemrograman otomatis dan pemrograman biasa. <br><br>  Anda tentu saja dapat memperkenalkan memori bayangan ke dalam pemrograman biasa dan menunjukkan paralelisme fungsi.  Tetapi dalam kerangka model otomat, semua ini memiliki bentuk organik, baik dalam hal deskripsi maupun dalam hal kinerja.  Semuanya ditentukan oleh paralelisme alami model.  Model diagram blok tidak memiliki kemampuan seperti itu. <br><br>  Objek aktif juga memperluas kemampuan pemrograman.  Tetapi "pembungkus objek", untuk bagiannya, secara kualitatif mempengaruhi pemrograman otomatis, menyederhanakan prosedur untuk memohon dan mengimplementasikan automata bersarang.  Jadi, penggunaan properti kelas [lokal] memungkinkan Anda untuk mengimplementasikan tidak hanya penyematan, tetapi juga algoritma rekursif. <br><br><div class="spoiler">  <b class="spoiler_title">Referensi</b> <div class="spoiler_text">  1. Mesin Turing, sebagai model program otomatis.  [Sumber daya elektronik], mode akses: <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratis.  Yaz.  Rusia  (tanggal perawatan 07.01.2020). <br>  2. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Pengantar teori automata - M.: Ilmu.  Ch.  ed.  Fisika-Matematika.  lit., 1985.-- 320 hal. <br>  3. GLUSHKOV V.M.  Sintesis mesin digital.  M.: Fizmatgiz, 1962. <br>  4. ZAKREVSKY A.D.  Sintesis logis dari skema kaskade.  - M.: Ilmu.  Ch.  ed.  Fisika-mat.  lit., 1981. - 416 hal. <br>  5. KUZNETSOV O.P.  Grafik automata logis dan transformasinya // Otomasi dan Telemekanik.  - 1975. - No. 9.– S. 149-158. <br>  6. Kormen T., Leiserson Ch., Rivest R. Algoritma: konstruksi dan analisis - M .: MCCMO, 2001. - 960 p. <br>  7. BUCH G., RAMBO J., JACOBSON I. UML.  Panduan pengguna.  Edisi kedua.  Akademi TI: Moskow, 2007 .-- 493 hal. <br>  8. BARANOV S.I.  Sintesis firmware  - L.: Energi, 1979.- 232s. <br>  9. ARMSTRONG J.R.  Pemodelan sistem digital dalam bahasa VHDL: Terjemahan. Dari Bahasa Inggris / M .: Mir, 1992. - 175 hal. <br>  10. HAMBARTSUMYAN A.A., ZAPOLSKYH E.N.  Tentang satu pendekatan untuk dekomposisi automata sementara.  Saya, Avtomat.  dan Telemech., 1981, Edisi 2, 135-144 <br>  11. SHALYTO A. A. Paradigma pemrograman otomatis.  Buletin Ilmiah dan Teknis Universitas Teknologi Informasi, Mekanika, dan Optik St. Petersburg.  Vol.  53. Pemrograman otomatis.  2008, hal.  3-23. <br>  12. HAMBI E. Tabel keputusan pemrograman.  M.: Mir, 1976 .-- 86 hal. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484588/">https://habr.com/ru/post/id484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484578/index.html">Tujuan Tingkat Layanan - Pengalaman Google (Terjemahan Bab Buku Google SRE)</a></li>
<li><a href="../id484580/index.html">Apa yang perlu Anda ketahui tentang simulator untuk memori</a></li>
<li><a href="../id484582/index.html">ASP.NET MVC - Kerangka Entitas, MySQL dan menggunakan Dependency Resolver untuk memilih repositori</a></li>
<li><a href="../id484584/index.html">Mengapa kita memerlukan manajer dalam proyek TI dan apa yang akan terjadi ketika tidak</a></li>
<li><a href="../id484586/index.html">Bekerja dengan IPv6 di PHP</a></li>
<li><a href="../id484590/index.html">Sehingga anak laki-laki tidak malu untuk menunjukkan</a></li>
<li><a href="../id484592/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 398 (13-19 Januari 2020)</a></li>
<li><a href="../id484596/index.html">Toko Online Sisi Klien Blazor: Bagian 1 - Oidc otorisasi (oauth2) + Server Identitas4</a></li>
<li><a href="../id484600/index.html">Microsoft Menyalakan Konferensi Teknis Tur Praha</a></li>
<li><a href="../id484602/index.html">Buku “Pengembangan aplikasi seluler di C # untuk iOS dan Android”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>