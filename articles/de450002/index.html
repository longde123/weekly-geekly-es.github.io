<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèª üåπ #‚É£ Suchen von Fehlern in LLVM 8 mit PVS-Studio üë∞üèø üôåüèª ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist zwei Jahre her, seit wir den Code des LLVM-Projekts das letzte Mal mit PVS-Studio √ºberpr√ºft haben. Lassen Sie uns also sehen, ob PVS-Studio imm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen von Fehlern in LLVM 8 mit PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450002/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio und LLVM 8.0.0"></div><br>  Es ist zwei Jahre her, seit wir den Code des LLVM-Projekts das letzte Mal mit PVS-Studio √ºberpr√ºft haben. Lassen Sie uns also sehen, ob PVS-Studio immer noch f√ºhrend unter den Tools zur Erkennung von Fehlern und Sicherheitsl√ºcken ist.  Dazu scannen wir die Version LLVM 8.0.0 nach neuen Fehlern. <br><a name="habracut"></a><br><h2>  Der Artikel, der geschrieben werden muss </h2><br>  Ehrlich gesagt hatte ich keine Lust, diesen Artikel zu schreiben.  Es macht nicht viel Spa√ü, √ºber das Projekt zu sprechen, das wir bereits mehrmals √ºberpr√ºft haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ).  Ich w√ºrde stattdessen etwas Neues bevorzugen, aber ich hatte keine Wahl. <br><br>  Jedes Mal, wenn eine neue Version von LLVM ver√∂ffentlicht oder der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Static Analyzer</a> aktualisiert wird, erhalten wir E-Mails in dieser Richtung: <br><br>  <i>Hey, die neue Version von Clang Static Analyzer hat eine neue Diagnose bekommen!</i>  <i>PVS-Studio scheint weniger relevant zu werden.</i>  <i>Clang kann mehr Fehler als zuvor erkennen und holt jetzt PVS-Studio ein.</i>  <i>Was hast du gesagt</i> <br><br>  Darauf w√ºrde ich gerne antworten: <br><br>  <b>Wir haben auch nicht faulenzen!</b>  Wir haben die F√§higkeiten von PVS-Studio erheblich verbessert, also keine Sorge - wir sind immer noch die Besten. <br><br>  Aber das ist leider eine schlechte Antwort.  Es bietet keine Beweise, und das ist der Grund, warum ich diesen Artikel schreibe.  Also habe ich LLVM noch einmal √ºberpr√ºft und Tonnen von Fehlern aller Art gefunden.  Diejenigen, die mir am besten gefallen haben, werden weiter besprochen.  Clang Static Analyzer kann diese Fehler nicht erkennen (oder macht den Prozess sehr m√ºhsam) - und wir k√∂nnen.  √úbrigens habe ich nur einen Abend gebraucht, um all diese Fehler aufzuschreiben. <br><br>  Die Fertigstellung des Artikels dauerte jedoch mehrere Wochen.  Ich konnte mich einfach nicht dazu bringen, das gesammelte Material in Text zu schreiben :). <br><br>  Wenn Sie sich fragen, welche Techniken PVS-Studio verwendet, um Fehler und Schwachstellen zu erkennen, lesen Sie diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> . <br><br><h2>  Neue und bestehende Diagnose </h2><br>  Wie ich bereits sagte, wurde die letzte der vielen LLVM-√úberpr√ºfungen vor zwei Jahren durchgef√ºhrt, und die damals gefundenen Fehler wurden von den Autoren behoben.  Dieser Artikel zeigt einen neuen Teil der Fehler.  Wie kommt es, dass es √ºberhaupt neue Fehler gibt?  Es gibt drei Gr√ºnde: <br><br><ol><li>  Das LLVM-Projekt entwickelt sich weiter.  Die Autoren √§ndern vorhandenen Code und f√ºgen neuen Code hinzu.  Sowohl modifizierte als auch neue Teile haben nat√ºrlich neue Fehler.  Diese Tatsache ist ein starkes Argument daf√ºr, regelm√§√üig statische Analysen durchzuf√ºhren und nicht ab und zu.  Das Format unserer Artikel ist perfekt, um die Funktionen von PVS-Studio zu demonstrieren, hat jedoch nichts damit zu tun, die Codequalit√§t zu verbessern oder die Fehlerbehebung kosteng√ºnstiger zu gestalten.  Verwenden Sie regelm√§√üig statische Analysen! </li><li>  Wir modifizieren und verbessern vorhandene Diagnosen, sodass der Analysator Fehler erkennen kann, die er zuvor nicht erkennen konnte. </li><li>  PVS-Studio wurde um eine neue Diagnose erweitert, die es vor zwei Jahren noch nicht gab.  Ich habe solche Warnungen in einem separaten Abschnitt zusammengefasst, damit der Fortschritt von PVS-Studio deutlicher sichtbar wird. </li></ol><br><h2>  Durch vorhandene Diagnose festgestellte M√§ngel </h2><br>  <b>Snippet Nr.</b>  <b>1: Kopieren-Einf√ºgen</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> [CWE-570] Es gibt identische Unterausdr√ºcke 'Name.startswith ("avx512.mask.permvar.")' Links und rechts von '||'  Betreiber.  AutoUpgrade.cpp 73 <br><br>  Das Auftreten der "avx512.mask.permvar".  Teilzeichenfolge wird zweimal √ºberpr√ºft.  Die zweite Bedingung war offensichtlich, etwas anderes zu √ºberpr√ºfen, aber der Programmierer verga√ü, die kopierte Zeile zu √§ndern. <br><br>  <b>Snippet Nr.</b>  <b>2: Tippfehler</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: V501 Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'CXNameRange_WantQualifier'.  Betreiber.  CIndex.cpp 7245 <br><br>  Die benannte Konstante <i>CXNameRange_WantQualifier</i> wird aufgrund eines Tippfehlers zweimal verwendet. <br><br>  <b>Snippet Nr.</b>  <b>3: Verwirrung √ºber den Vorrang des Bedieners</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V502</a> [CWE-783] M√∂glicherweise funktioniert der Operator '?:' Anders als erwartet.  Der Operator '?:' Hat eine niedrigere Priorit√§t als der Operator '=='.  PPCTargetTransformInfo.cpp 404 <br><br>  Ich finde diesen Bug sehr s√º√ü.  Ja, ich wei√ü, dass ich einen seltsamen Geschmack habe :). <br><br>  Gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Priorit√§t</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operators</a> wird der urspr√ºngliche Ausdruck wie folgt ausgewertet: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Aus praktischer Sicht ist diese Bedingung jedoch nicht sinnvoll, da sie reduziert werden kann auf: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  Dies ist offensichtlich ein Fehler.  Es muss die <i>Indexvariable gewesen sein</i> , die der Programmierer auf 0/1 pr√ºfen wollte.  Um den Code zu korrigieren, sollte der tern√§re Operator in Klammern gesetzt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  Der tern√§re Operator ist tats√§chlich sehr knifflig und kann zu logischen Fehlern f√ºhren.  Gehen Sie vorsichtig damit um und z√∂gern Sie nicht, zus√§tzliche Klammern zu setzen.  Dieses Thema wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> im Abschnitt "Vorsicht vor dem Operator?: Operator und in Klammern setzen" ausf√ºhrlicher behandelt. <br><br>  <b>Schnipsel Nr.</b>  <b>4, 5: Nullzeiger</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V522</a> [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'LHS' statt.  TGParser.cpp 2152 <br><br>  Wenn der <i>LHS-</i> Zeiger zuf√§llig null ist, wird erwartet, dass das Programm eine Warnung generiert.  Stattdessen wird dieser Nullzeiger dereferenziert: <i>LHS-&gt; getAsString ()</i> . <br><br>  Es ist eine typische Situation f√ºr Fehlerbehandler, Fehler zu enthalten, da Entwickler sie nicht richtig testen.  Statische Analysatoren √ºberpr√ºfen den gesamten erreichbaren Code, unabh√§ngig davon, wie oft er tats√§chlich ausgef√ºhrt wird.  Dies ist ein gutes Beispiel daf√ºr, wie die statische Analyse andere Codetest- und Schutzmittel erg√§nzt. <br><br>  Ein √§hnlicher fehlerhafter Handler f√ºr den <i>RHS-</i> Zeiger befindet sich etwas weiter entfernt: V522 [CWE-476] Eine Dereferenzierung des Nullzeigers 'RHS' kann stattfinden.  TGParser.cpp 2186 <br><br>  <b>Snippet Nr.</b>  <b>6: Verwenden eines Zeigers nach einer Bewegung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V522 [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'ProgClone' statt.  Miscompilation.cpp 601 <br><br>  Der Smart Pointer <i>ProgClone gibt</i> zuerst den Objektbesitz frei: <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  Tats√§chlich ist <i>ProgClone</i> zu einem Nullzeiger geworden. Technisch gesehen wird ein Nullzeiger also etwas weiter dereferenziert: <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  Das wird aber nicht passieren!  Beachten Sie, dass die Schleife √ºberhaupt nicht ausgef√ºhrt wird. <br><br>  Der <i>MiscompiledFunctions-</i> Container wird zuerst gel√∂scht: <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  Und dann wird seine Gr√∂√üe in der Schleifenbedingung verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  Offensichtlich startet die Schleife einfach nicht.  Ich denke, es ist auch ein Fehler, und der Code sollte irgendwie anders aussehen. <br><br>  Ich denke, was wir hier sehen, ist diese ber√ºchtigte Fehlerparit√§t, bei der ein Fehler als Verkleidung f√ºr einen anderen fungiert :). <br><br>  <b>Snippet Nr.</b>  <b>7: Verwenden eines Zeigers nach einer Bewegung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V522 [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'Test' statt.  Miscompilation.cpp 709 <br><br>  Dieser ist dem vorherigen Fall √§hnlich.  Der Inhalt des Objekts wird zuerst verschoben und dann so verwendet, als w√§re nichts passiert.  Dieser Fehler tritt immer h√§ufiger auf, nachdem C ++ eine Verschiebungssemantik hinzugef√ºgt wurde.  Das gef√§llt mir an dieser Sprache!  Sie erhalten neue M√∂glichkeiten, sich in den Fu√ü zu schie√üen, was bedeutet, dass PVS-Studio immer Arbeit zu erledigen hat :). <br><br>  <b>Snippet Nr.</b>  <b>8: Nullzeiger</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: V522 [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'Typ' statt.  PrettyFunctionDumper.cpp 233 <br><br>  Genau wie Fehlerbehandler erhalten Testfunktionen, die Debug-Daten drucken, normalerweise auch keine ausreichende Testabdeckung, und dies ist ein Beispiel daf√ºr.  Anstatt dem Benutzer bei der L√∂sung seiner Probleme zu helfen, wartet die Funktion darauf, dass er sie behebt. <br><br>  Fester Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>Snippet Nr.</b>  <b>9: Nullzeiger</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V522 [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'Ty' statt.  SearchableTableEmitter.cpp 614 <br><br>  Ich glaube nicht, dass Sie dazu Kommentare ben√∂tigen. <br><br>  <b>Snippet Nr.</b>  <b>10: Tippfehler</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Die Variable 'Identifier-&gt; Type' wird sich selbst zugewiesen.  FormatTokenLexer.cpp 249 <br><br>  Das Zuweisen einer Variablen zu sich selbst ist eine bedeutungslose Operation.  Der Programmierer muss Folgendes beabsichtigt haben: <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>Snippet Nr.</b>  <b>11: Verd√§chtige Pause</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V622</a> [CWE-478] √úberpr√ºfen Sie die Anweisung 'switch'.  M√∂glicherweise fehlt der erste 'case'-Operator.  SystemZAsmParser.cpp 652 <br><br>  Am Anfang steht eine sehr verd√§chtige <i>Unterbrechungserkl√§rung</i> .  Sollte es hier nicht noch etwas geben? <br><br>  <b>Snippet Nr.</b>  <b>12: √úberpr√ºfen eines Zeigers nach der Dereferenzierung</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> [CWE-476] Der Zeiger 'Callee' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 172, 174. AMDGPUInline.cpp 172 <br><br>  Der <i>Callee-</i> Zeiger wird zuerst dereferenziert, wenn die Funktion <i>getTTI</i> aufgerufen wird. <br><br>  Und dann stellt sich heraus, dass der Zeiger auf <i>nullptr</i> √ºberpr√ºft werden <i>sollte</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  Zu sp√§t ... <br><br>  <b>Schnipsel Nr.</b>  <b>13 - Nein ....: √úberpr√ºfen eines Zeigers nach der Dereferenzierung</b> <br><br>  Das vorherige Beispiel ist nicht eindeutig.  Das gleiche Problem findet sich in diesem Snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V595 [CWE-476] Der Zeiger 'CalleeFn' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1079, 1081. SimplifyLibCalls.cpp 1079 <br><br>  Und dieser: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V595 [CWE-476] Der Zeiger 'ND' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 532, 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  Und hier: <br><br><ul><li>  V595 [CWE-476] Der 'U'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 404, 407. DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476] Der 'ND'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2149, 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  Dann habe ich das Interesse an der Verfolgung von V595-Warnungen verloren, sodass ich Ihnen nicht sagen kann, ob es neben den oben gezeigten noch andere Fehler dieses Typs gibt.  Ich wette, es gibt. <br><br>  <b>Schnipsel Nr.</b>  <b>17, 18: Verd√§chtige Verschiebung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V629</a> [CWE-190] √úberpr√ºfen Sie den Ausdruck '~ (Gr√∂√üe - 1) &lt;&lt; 1'.  Bitverschiebung des 32-Bit-Werts mit anschlie√üender Erweiterung auf den 64-Bit-Typ.  AArch64AddressingModes.h 260 <br><br>  Dieser Code mag tats√§chlich korrekt sein, sieht aber seltsam aus und muss √ºberpr√ºft werden. <br><br>  Angenommen, die Variable <i>Size</i> hat den Wert 16.  Dann wird erwartet, dass die <i>NImms-</i> Variable den folgenden Wert erh√§lt: <br><br>  1111111111111111111111111111111111111111111111111111111111111100000000 <br><br>  Aber in Wirklichkeit wird es den Wert bekommen: <br><br>  000000000000000000000000000000000000111111111111111111111111111111000000 <br><br>  Dies geschieht, weil alle Berechnungen f√ºr den 32-Bit-Typ ohne Vorzeichen durchgef√ºhrt werden und erst dann implizit auf <i>uint64_t hochgestuft wird</i> , wobei die h√∂chstwertigen Bits auf Null gesetzt werden. <br><br>  Das Problem kann wie folgt behoben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Ein weiterer Fehler dieses Typs: V629 [CWE-190] √úberpr√ºfen Sie den Ausdruck 'Immr &lt;&lt; 6'.  Bitverschiebung des 32-Bit-Werts mit anschlie√üender Erweiterung auf den 64-Bit-Typ.  AArch64AddressingModes.h 269 <br><br>  <b>Snippet Nr.</b>  <b>19: Fehlt</b> <b><i>sonst noch ein</i></b> <b>Keyword</b> <b>?</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V646</a> [CWE-670] √úberpr√ºfen Sie die Logik der Anwendung.  M√∂glicherweise fehlt das Schl√ºsselwort "else".  AMDGPUAsmParser.cpp 5655 <br><br>  Dieser ist kein Fehler.  Da der <i>then-</i> Block der ersten <i>if-</i> Anweisung mit <i>continue</i> endet, spielt es keine Rolle, ob er das Schl√ºsselwort <i>else enth√§lt</i> oder nicht.  Das Verhalten ist in jedem Fall das gleiche.  Das fehlende <i>Sonst</i> macht den Code jedoch weniger lesbar und daher potenziell gef√§hrlich.  Wenn die <i>Fortsetzung</i> eines Tages verschwindet, √§ndert sich das Verhalten drastisch.  Ich empfehle dringend, etwas <i>anderes</i> hinzuzuf√ºgen. <br><br>  <b>Snippet Nr.</b>  <b>20: Vier identische Tippfehler</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldungen: <br><br><ul><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + Name.str ()'.  Symbol.cpp 32 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC-Klasse)" + Name.str ()'.  Symbol.cpp 35 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC-Klasse EH)" + Name.str ()'.  Symbol.cpp 38 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC IVar)" + Name.str ()'.  Symbol.cpp 41 </li></ul><br>  Der Programmierer hat versehentlich den Operator + anstelle von + = verwendet und am Ende vier bedeutungslose Konstrukte erhalten. <br><br>  <b>Snippet Nr.</b>  <b>21: Undefiniertes Verhalten</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  Versuchen Sie zuerst, den Fehler selbst zu erkennen.  Ich habe das Bild hinzugef√ºgt, damit Sie nicht sofort auf die Antwort schauen: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="???"></div><br><br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V708</a> [CWE-758] Es wird eine gef√§hrliche Konstruktion verwendet: 'FeaturesMap [Op] = FeaturesMap.size ()', wobei 'FeaturesMap' der Klasse 'map' entspricht.  Dies kann zu undefiniertem Verhalten f√ºhren.  RISCVCompressInstEmitter.cpp 490 <br><br>  Die fehlerhafte Leitung ist diese: <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  Wenn das <i>Op-</i> Element nicht gefunden wurde, erstellt das Programm ein neues Element in der Karte und weist ihm die Gesamtzahl der Elemente in dieser Karte zu.  Sie wissen nur nicht, ob die <i>Gr√∂√üenfunktion</i> vor oder nach dem Hinzuf√ºgen des neuen Elements aufgerufen wird. <br><br>  <b>Schnipsel Nr.</b>  <b>22 - Nein.</b>  <b>24: doppelte Zuordnungen</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V519</a> [CWE-563] Der Variablen 'NType' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 1663, 1664. MachOObjectFile.cpp 1664 <br><br>  Ich denke nicht, dass es ein wahrer Fehler ist - eher eine doppelte Zuordnung.  Aber es ist immer noch ein Defekt. <br><br>  Zwei weitere F√§lle: <br><br><ul><li>  V519 [CWE-563] Der Variablen 'B.NDesc' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Pr√ºflinien: 1488, 1489. llvm-nm.cpp 1489 </li><li>  V519 [CWE-563] Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 59, 61. coff2yaml.cpp 61 </li></ul><br>  <b>Schnipsel Nr.</b>  <b>25 - Nein.</b>  <b>27: Mehr doppelte Zuordnungen</b> <br><br>  Diese befassen sich mit leicht unterschiedlichen Versionen doppelter Zuweisungen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: V519 [CWE-563] Der Variablen 'Alignment' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 1158, 1160. LoadStoreVectorizer.cpp 1160 <br><br>  Dies ist ein sehr seltsamer Ausschnitt, der wahrscheinlich einen logischen Fehler enth√§lt.  Der <i>Ausrichtungsvariablen</i> wird zuerst der Wert basierend auf der Bedingung zugewiesen, und dann wird der Wert erneut zugewiesen, jedoch ohne vorherige √úberpr√ºfung. <br><br>  √Ñhnliche M√§ngel: <br><br><ul><li>  V519 [CWE-563] Der Variablen 'Effekte' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 152, 165. WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563] Der Variablen 'ExpectNoDerefChunk' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 4970, 4973. SemaType.cpp 4973 </li></ul><br>  <b>Snippet Nr.</b>  <b>28: Immer wahrer Zustand</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> [CWE-571] Der Ausdruck 'nextByte! = 0x90' ist immer wahr.  X86DisassemblerDecoder.cpp 379 <br><br>  Die Pr√ºfung macht keinen Sinn.  Die <i>nextByte-</i> Variable ist niemals gleich <i>0x90</i> : Sie folgt nur logisch aus der vorherigen Pr√ºfung.  Dies muss ein logischer Fehler sein. <br><br>  <b>Schnipsel Nr.</b>  <b>29 - Nein ....: Immer wahre / falsche Bedingungen</b> <br><br>  Es gibt viele Warnungen, dass eine ganze Bedingung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> ) oder ein Teil einer Bedingung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> ) immer wahr oder falsch ist.  Anstelle von echten Fehlern handelt es sich h√§ufig nur um schlechten Code, die Auswirkungen der Makroerweiterung usw.  Trotzdem sollten alle derartigen Warnungen √ºberpr√ºft werden, da einige von ihnen auf echte Logikfehler hinweisen k√∂nnen.  Das folgende Snippet sieht beispielsweise nicht richtig aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> [CWE-570] Ein Teil des bedingten Ausdrucks ist immer falsch: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  Die <i>0xE-</i> Konstante ist die Dezimalzahl 14. Die Pr√ºfung <i>RegNo == 0xe</i> ist nicht sinnvoll, da die Funktion zur√ºckgegeben wird, wenn <i>RegNo&gt; 13</i> ist. <br><br>  Ich habe viele andere V547- und V560-Warnungen gesehen, aber wie bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> war ich nicht begeistert, sie zu √ºberpr√ºfen, da ich bereits genug Material f√ºr einen Artikel hatte :).  Also keine Zahlen f√ºr die Gesamtzahl der Fehler dieses Typs in LLVM. <br><br>  Hier ist ein Beispiel, um zu veranschaulichen, warum das √úberpr√ºfen dieser Warnungen langweilig ist.  Der Analysator ist v√∂llig korrekt, wenn eine Warnung zum folgenden Code ausgegeben wird.  Aber es ist immer noch kein Fehler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: V547 [CWE-570] Der Ausdruck '! HasError' ist immer falsch.  UnwrappedLineParser.cpp 1635 <br><br>  <b>Snippet Nr.</b>  <b>30: Verd√§chtige R√ºckkehr</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V612</a> [CWE-670] Eine bedingungslose 'R√ºckgabe' innerhalb einer Schleife.  R600OptimizeVectorRegisters.cpp 63 <br><br>  Es ist entweder ein Fehler oder eine bestimmte Codierungstechnik, die anderen Programmierern eine Idee vermitteln soll.  F√ºr mich sagt es nichts aus, au√üer dass es ein sehr verd√§chtiger Code ist.  Bitte schreibe keinen solchen Code :). <br><br>  F√ºhlen Sie sich m√ºde?  OK, es ist Zeit, Tee oder Kaffee zu kochen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="Kaffee"></div><br><br><h2>  Durch neue Diagnose festgestellte M√§ngel </h2><br>  Ich denke, 30 Beispiele reichen f√ºr die bestehende Diagnose.  Lassen Sie uns nun sehen, ob wir mit der neuen Diagnose, die nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> √úberpr√ºfung hinzugef√ºgt wurde, etwas Interessantes finden k√∂nnen.  In den letzten zwei Jahren wurde das C ++ - Analysatormodul um 66 neue Diagnosen erweitert. <br><br>  <b>Snippet Nr.</b>  <b>31: Nicht erreichbarer Code</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V779</a> [CWE-561] Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  ExecutionUtils.cpp 146 <br><br>  Wie Sie sehen k√∂nnen, enden beide Zweige der <i>if-</i> Anweisung mit einer <i>return-</i> Anweisung, was bedeutet, dass der <i>CtorDtorsByPriority-</i> Container niemals gel√∂scht wird. <br><br>  <b>Snippet Nr.</b>  <b>32: Nicht erreichbarer Code</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V779 [CWE-561] Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  LLParser.cpp 835 <br><br>  Dieser ist interessant.  Schauen Sie sich zuerst diesen Teil an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  An diesem Code scheint nichts Seltsames zu sein.  Die <i>break-</i> Anweisung ist nicht erforderlich und kann sicher entfernt werden.  Aber so einfach ist das nicht. <br><br>  Die Warnung wird durch folgende Zeilen ausgel√∂st: <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  In der Tat ist dieser Code nicht erreichbar.  Alle Fallbezeichnungen der <i>switch-</i> Anweisung enden mit einer <i>R√ºckgabe</i> , und die bedeutungslose Einzelpause sieht nicht mehr so ‚Äã‚Äãharmlos aus!  Was w√§re, wenn einer der Zweige eher mit einer <i>Pause</i> als mit einer <i>R√ºckkehr</i> enden sollte? <br><br>  <b>Snippet Nr.</b>  <b>33: Versehentliches L√∂schen der h√∂chstwertigen Bits</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V784</a> Die Gr√∂√üe der Bitmaske ist kleiner als die Gr√∂√üe des ersten Operanden.  Dies f√ºhrt zum Verlust h√∂herer Bits.  RuntimeDyld.cpp 815 <br><br>  Beachten Sie, dass die Funktion <i>getStubAlignment</i> einen <i>vorzeichenlosen</i> Wert zur√ºckgibt.  Mal sehen, wie der Ausdruck ausgewertet wird, vorausgesetzt, die Funktion gibt den Wert 8 zur√ºck: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  Beachten Sie jetzt, dass der Typ der <i>DataSize-</i> Variablen 64-Bit ohne Vorzeichen ist.  Es stellt sich also heraus, dass das Ausf√ºhren der Operation DataSize &amp; 0xFFFFFFF8 dazu f√ºhrt, dass alle 32 h√∂chstwertigen Bits des Werts gel√∂scht werden.  Ich glaube nicht, dass der Programmierer das wollte.  Vielleicht meinten sie es DataSize &amp; 0xFFFFFFFFFFFFFFFFF8u. <br><br>  Um den Fehler zu beheben, sollte der Code folgenderma√üen umgeschrieben werden: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Oder so: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>Snippet Nr.</b>  <b>34: Schlechte explizite Typkonvertierung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> [CWE-190] M√∂glicher √úberlauf.  Ziehen Sie in Betracht, Operanden des Operators 'NumElts * Scale' in den Typ 'size_t' umzuwandeln, nicht in das Ergebnis.  X86ISelLowering.h 1577 <br><br>  Die explizite Typkonvertierung wird verwendet, um einen √úberlauf beim Multiplizieren von Variablen vom Typ <i>int</i> zu vermeiden.  In diesem Fall funktioniert dies jedoch nicht, da die Multiplikation zuerst erfolgt und erst dann das 32-Bit-Ergebnis auf den Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>size_t hochgestuft wird</i></a> . <br><br>  <b>Snippet Nr.</b>  <b>35: Schlechtes Kopieren und Einf√ºgen</b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V778</a> [CWE-682] Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler und die Variable 'Op1' sollte anstelle von 'Op0' verwendet werden.  InstCombineCompares.cpp 5507 <br><br>  Diese neue coole Diagnose erkennt Situationen, in denen ein Codefragment mithilfe von Copy-Paste geschrieben wird, wobei alle Namen bis auf einen ge√§ndert werden. <br><br>  Beachten Sie, dass alle <i>Op0s</i> au√üer einem im zweiten Block in <i>Op1</i> ge√§ndert wurden.  Der Code sollte wahrscheinlich so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br>  <b>Snippet Nr.</b>  <b>36: Variablen verwechselt</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1001</a> [CWE-563] Die Variable 'Mode' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  SIModeRegister.cpp 48 <br><br>  Es ist sehr gef√§hrlich, f√ºr Funktionsargumente dieselben Namen zu haben wie f√ºr Klassenmitglieder, da Sie das Risiko haben, sie zu verwechseln.  Was Sie hier sehen, ist ein Beispiel daf√ºr.  Der folgende Ausdruck ist bedeutungslos: <br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br>  Das Argument wird ge√§ndert, aber danach nie mehr verwendet.  Dieses Snippet sollte wahrscheinlich so aussehen: <br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br>  <b>Snippet Nr.</b>  <b>37: Variablen verwechselt</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: V1001 [CWE-563] Die Variable 'Gr√∂√üe' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  Object.cpp 424 <br><br>  Dieser √§hnelt dem vorherigen Beispiel.  Richtige Version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br>  <b>Schnipsel Nr.</b>  <b>38 - Nein.</b>  <b>47: Fehlende Zeigerpr√ºfung</b> <br><br>  Wir haben uns einige Beispiele f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595-</a> Warnung etwas fr√ºher angesehen.  Was es erkennt, ist eine Situation, in der ein Zeiger zuerst dereferenziert und erst dann √ºberpr√ºft wird.  Die neue Diagnose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1004</a> ist das Gegenteil davon und erkennt auch Unmengen von Fehlern.  Es wird nach bereits getesteten Zeigern gesucht, die bei Bedarf nicht erneut getestet werden.  Hier sind einige Fehler dieses Typs im LLVM-Code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V1004 [CWE-476] Der 'Ptr'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 729, 738. TargetTransformInfoImpl.h 738 <br><br>  <i>Ptr</i> kann <i>nullptr sein</i> , was durch die Pr√ºfung angezeigt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br>  Derselbe Zeiger wird jedoch ohne eine solche Pr√ºfung etwas weiter dereferenziert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br>  Ein weiterer √§hnlicher Fall. <br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V1004 [CWE-476] Der 'FD'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 3228, 3231. CGDebugInfo.cpp 3231 <br><br>  Beachten Sie den <i>FD-</i> Zeiger.  Dieser Fehler ist unkompliziert, daher keine Kommentare zu diesem. <br><br>  Noch eine hier: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio-Diagnosemeldung: V1004 [CWE-476] Der Zeiger 'PtrTy' wurde unsicher verwendet, nachdem er gegen nullptr √ºberpr√ºft wurde.  √úberpr√ºfen Sie die Zeilen: 960, 965. InterleavedLoadCombinePass.cpp 965 <br><br>  Wie vermeidet man solche Fehler?  Seien Sie sehr vorsichtig, wenn Sie Ihren Code √ºberpr√ºfen, und √ºberpr√ºfen Sie ihn regelm√§√üig mit PVS-Studio. <br><br>  Ich denke nicht, dass wir andere Beispiele dieses Typs untersuchen sollten, daher hier nur eine Liste der Warnungen: <br><ul><li>  V1004 [CWE-476] Der Zeiger 'Expr' wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1049, 1078. DebugInfoMetadata.cpp 1078 </li><li>  V1004 [CWE-476] Der 'PI'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 733, 753. LegacyPassManager.cpp 753 </li><li>  V1004 [CWE-476] Der Zeiger 'StatepointCall' wurde unsicher verwendet, nachdem er gegen nullptr √ºberpr√ºft wurde.  √úberpr√ºfen Sie die Zeilen: 4371, 4379. Verifier.cpp 4379 </li><li>  V1004 [CWE-476] Der 'RV'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2263, 2268. TGParser.cpp 2268 </li><li>  V1004 [CWE-476] Der 'CalleeFn'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1081, 1096. SimplifyLibCalls.cpp 1096 </li><li>  V1004 [CWE-476] Der 'TC'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1819, 1824. Driver.cpp 1824 </li></ul><br>  <b>Schnipsel Nr.</b>  <b>48 - Nein.</b>  <b>60: Nicht kritisch, aber immer noch ein Defekt (m√∂glicher Speicherverlust)</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br>  PVS-Studio-Diagnosemeldung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1023</a> [CWE-460] Ein Zeiger ohne Eigent√ºmer wird durch die Methode 'emplace_back' zum Container 'Strategies' hinzugef√ºgt.  Im Ausnahmefall tritt ein Speicherverlust auf.  llvm-isel-fuzzer.cpp 58 <br><br>  Sie k√∂nnen nicht einfach <i>xxx.push_back (neues X)</i> schreiben, um ein Element an einen Container vom Typ <i>std :: vector &lt;std :: unique_ptr &lt;X&gt;&gt;</i> anzuh√§ngen, da keine implizite Umwandlung von <i>X *</i> in <i>std :: unique_ptr &lt;erfolgt X&gt;</i> . <br><br>  Die beliebte L√∂sung besteht darin, <i>xxx.emplace_back (neues X)</i> zu schreiben, da es kompilierbar ist: Die Methode <i>emplace_back erstellt</i> das Element direkt aus den Argumenten und kann daher explizite Konstruktoren verwenden. <br><br>  Diese L√∂sung ist jedoch nicht sicher.  Wenn der Vektor voll ist, wird der Speicher neu zugewiesen.  Dieser Vorgang kann fehlschlagen und eine <i>std :: bad_alloc-</i> Ausnahme <i>ausl√∂sen</i> .  In diesem Fall geht der Zeiger verloren und das Programm kann das erstellte Objekt nicht l√∂schen. <br><br>  Eine sicherere L√∂sung besteht darin, ein <i>unique_ptr</i> zu erstellen, das den Zeiger <i>beibeh√§lt</i> , bis der Vektor versucht, den Speicher neu zuzuweisen: <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br>  Mit dem C ++ 14-Standard k√∂nnen Sie 'std :: make_unique' verwenden: <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br>  Diese Art von Defekt hat keine Auswirkung auf LLVM.  Die Kompilierung wird einfach beendet, wenn die Speicherzuordnung fehlschl√§gt.  Dies kann jedoch bei Anwendungen mit langer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betriebszeit</a> sehr kritisch sein, die nicht einfach beendet werden k√∂nnen, wenn ein Speicherzuordnungsfehler auftritt. <br><br>  Obwohl dieser Code f√ºr LLVM nicht gef√§hrlich ist, dachte ich, ich sollte Ihnen dennoch etwas √ºber dieses Fehlermuster und die Tatsache erz√§hlen, dass PVS-Studio es jetzt erkennen kann. <br><br>  Andere √§hnliche F√§lle: <br><br><ul><li>  V1023 [CWE-460] Ein Zeiger ohne Eigent√ºmer wird dem Container 'Passes' durch die Methode 'emplace_back' hinzugef√ºgt.  Im Ausnahmefall tritt ein Speicherverlust auf.  PassManager.h 546 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schrieb 60 Warnungen auf und h√∂rte damit auf. </font><font style="vertical-align: inherit;">Hat PVS-Studio andere Fehler in LLVM gefunden? </font><font style="vertical-align: inherit;">Ja, das hat es getan. </font><font style="vertical-align: inherit;">Aber als ich die Beispiele aufschrieb, brach die Nacht herein und ich beschloss, aufzuh√∂ren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Ihnen hat das Lesen dieses Artikels gefallen und es hat Sie ermutigt, den PVS-Studio-Analysator selbst auszuprobieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besuchen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Seite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Analysator herunterzuladen und einen Testschl√ºssel zu erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie vor allem regelm√§√üig statische Analysen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einmalige √úberpr√ºfungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie sie zur Popularisierung der statischen Analyse und zur F√∂rderung von PVS-Studio durchgef√ºhrt werden, sind nicht das normale Szenario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Gl√ºck bei der Verbesserung der Qualit√§t und Zuverl√§ssigkeit Ihres Codes!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450002/">https://habr.com/ru/post/de450002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449990/index.html">Wie kann man Latex, Formeln und Habr finden?</a></li>
<li><a href="../de449992/index.html">NodeMCU Simple Driver Model (SDM) Schaufenster: Dynamische Benutzeroberfl√§che</a></li>
<li><a href="../de449996/index.html">Den FFT-Algorithmus verstehen</a></li>
<li><a href="../de449998/index.html">FAQ: Was ein reisender Geek √ºber Impfungen wissen muss, bevor er reist</a></li>
<li><a href="../de450000/index.html">(Von rechts nach links (Durch den Spiegel</a></li>
<li><a href="../de450004/index.html">Schneller C / C ++ - Cache, Thread-Sicherheit</a></li>
<li><a href="../de450006/index.html">K√ºhlung des K√ºhler-Rechenzentrums: Welches K√ºhlmittel soll gew√§hlt werden?</a></li>
<li><a href="../de450008/index.html">Suchen Sie mit dem PVS-Studio-Analyseger√§t nach Fehlern in LLVM 8</a></li>
<li><a href="../de450010/index.html">Speicherung, Sicherung und Katalogisierung von Fotos</a></li>
<li><a href="../de450016/index.html">Erstellung eines formalen Verifizierungssystems von Grund auf neu. Teil 1: Virtuelle Zeichenmaschine in PHP und Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>