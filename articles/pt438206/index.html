<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¥ ü¶é üë®üèº‚Äçüé® 26 recomenda√ß√µes para usar o tipo var em Java ‚ñ™Ô∏è üïß ü§öüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A Infer√™ncia de Tipo de Vari√°vel Local Java (LVTI) ou, brevemente, o tipo de var (o identificador de var n√£o √© uma palavra-chave, mas um nome de tipo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>26 recomenda√ß√µes para usar o tipo var em Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438206/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/mq/zq/0cmqzquxmzrie0s3ryftj5dqvga.png"></div><br><p>  <strong>A Infer√™ncia de Tipo de Vari√°vel Local Java (LVTI)</strong> ou, brevemente, o tipo de <strong>var</strong> (o identificador de <strong>var</strong> n√£o √© uma palavra-chave, mas um nome de tipo reservado) foi adicionada ao Java 10 usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP 286: Infer√™ncia de Tipo de Vari√°vel Local</a> .  Sendo uma fun√ß√£o de compilador 100%, n√£o afeta o bytecode, o tempo de execu√ß√£o ou o desempenho.  Basicamente, o compilador verifica o lado direito do operador de atribui√ß√£o e, com base nele, determina o tipo espec√≠fico da vari√°vel e a substitui por <strong>var</strong> . </p><br><p> Al√©m disso, √© √∫til para reduzir a verbosidade do c√≥digo padr√£o e tamb√©m acelera o pr√≥prio processo de programa√ß√£o.  Por exemplo, √© muito conveniente escrever <strong><code>var evenAndOdd =...</code></strong> vez de <strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong> </p><br><p>  A apar√™ncia de <strong>var</strong> n√£o significa que seja sempre e conveniente us√°-lo em qualquer lugar; √†s vezes ser√° mais pr√°tico fazer com ferramentas padr√£o. </p><br><p>  Neste artigo, examinaremos 26 situa√ß√µes, com exemplos de quando voc√™ pode usar <strong>var</strong> e quando n√£o vale a pena. </p><a name="habracut"></a><br><h2 id="punkt-1-staraytes-davat-osmyslennye-imena-lokalnym-peremennym">  Ponto 1: tente atribuir nomes significativos √†s vari√°veis ‚Äã‚Äãlocais </h2><br><p>  Normalmente, nos concentramos em fornecer os nomes corretos para os campos das classes, mas n√£o prestamos a mesma aten√ß√£o aos nomes das vari√°veis ‚Äã‚Äãlocais.  Quando nossos m√©todos s√£o perfeitamente implementados, cont√™m pouco c√≥digo e t√™m bons nomes, muitas vezes n√£o prestamos aten√ß√£o √†s vari√°veis ‚Äã‚Äãlocais, nem reduzimos completamente seus nomes. </p><br><p>  Quando usamos <strong>var em</strong> vez de escrever tipos expl√≠citos, o compilador os detecta automaticamente e substitui <strong>var</strong> .  Mas, por outro lado, como resultado disso, fica mais dif√≠cil para as pessoas lerem e entenderem o c√≥digo, pois o uso de <strong>var</strong> pode complicar sua legibilidade e compreens√£o.  Na maioria dos casos, isso ocorre porque tendemos a considerar o tipo de uma vari√°vel como informa√ß√£o prim√°ria e o nome como secund√°rio.  Embora deva ser exatamente o oposto. </p><br><h3 id="primer-1">  Exemplo 1: </h3><br><p>  Muitos provavelmente concordam que no exemplo abaixo, os nomes das vari√°veis ‚Äã‚Äãlocais s√£o muito curtos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// HAVING public boolean callDocumentationTask() { DocumentationTool dtl = ToolProvider.getSystemDocumentationTool(); DocumentationTask dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Ao usar nomes abreviados, junto com <strong>var</strong> , o c√≥digo fica ainda menos claro: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public boolean callDocumentationTask() { var dtl = ToolProvider.getSystemDocumentationTool(); var dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p>  Op√ß√£o mais preferida: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public boolean callDocumentationTask() { var documentationTool = ToolProvider.getSystemDocumentationTool(); var documentationTask = documentationTool.getTask(...); return documentationTask.call(); }</span></span></code> </pre> <br><h3 id="primer-2">  Exemplo 2: </h3><br><p>  Evite nomear vari√°veis ‚Äã‚Äãcomo esta: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public List&lt;Product&gt; fetchProducts(long userId) { var u = userRepository.findById(userId); var p = u.getCart(); return p; }</span></span></code> </pre> <br><p>  Use nomes mais significativos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public List&lt;Product&gt; fetchProducts(long userId) { var user = userRepository.findById(userId); var productList = user.getCart(); return productList; }</span></span></code> </pre> <br><h3 id="primer-3">  Exemplo 3: </h3><br><p>  Em um esfor√ßo para atribuir nomes mais compreens√≠veis √†s vari√°veis ‚Äã‚Äãlocais, n√£o v√° ao extremo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteArrayOutputStream = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Em vez disso, voc√™ pode usar uma op√ß√£o mais curta, mas n√£o menos compreens√≠vel: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var outputStream = new ByteArrayOutputStream(); // or var outputStreamOfFoo = new ByteArrayOutputStream();</span></span></code> </pre> <br><p>  Voc√™ sabia que o Java tem uma classe interna chamada: <br>  <strong>InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState</strong> </p><br><p>  Bem, nomear vari√°veis ‚Äã‚Äãcom esse tipo pode ser complicado :) </p><br><h2 id="punkt-2-ispolzuyte-literaly-chtoby-pomoch-var-tochno-opredelit-tip-primitiva-int-long-float-double">  Ponto 2: use literais para ajudar var a identificar o tipo de primitivo (int, long, float, double) </h2><br><p>  Sem o uso de literais para tipos primitivos, podemos achar que os tipos esperado e impl√≠cito podem diferir.  Isso √© causado pela convers√£o impl√≠cita de tipo usada pelas vari√°veis <strong>var</strong> . </p><br><p>  Por exemplo, os dois fragmentos de c√≥digo a seguir se comportam conforme o esperado.  Aqui declaramos explicitamente os tipos <strong>booleano</strong> e <strong>char</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type boolean char a = 'a'; // this is of type char</span></span></code> </pre> <br><p>  Agora usamos <strong>var</strong> , em vez de declarar explicitamente os tipos: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is inferred as boolean var a = 'a'; // this is inferred as char</span></span></code> </pre> <br><p>  At√© agora tudo bem.  Agora fa√ßa o mesmo para os tipos <strong>int</strong> , <strong>long</strong> , <strong>float</strong> e <strong>double</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intNumber = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type int long longNumber = 20; // this is of type long float floatNumber = 20; // this is of type float, 20.0 double doubleNumber = 20; // this is of type double, 20.0</span></span></code> </pre> <br><p>  Embora o snippet de c√≥digo acima seja simples e direto, agora vamos usar <strong>var em</strong> vez de especificar explicitamente os tipos. </p><br><p>  Evite: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var intNumber = 20; // this is inferred as int var longNumber = 20; // this is inferred as int var floatNumber = 20; // this is inferred as int var doubleNumber = 20; // this is inferred as int</span></span></code> </pre> <br><p>  Todas as quatro vari√°veis ‚Äã‚Äãser√£o exibidas como <strong>int</strong> .  Para corrigir esse comportamento, precisamos usar literais Java: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var intNumber = 20; // this is inferred as int var longNumber = 20L; // this is inferred as long var floatNumber = 20F; // this is inferred as float, 20.0 var doubleNumber = 20D; // this is inferred as double, 20.0</span></span></code> </pre> <br><p>  Mas o que acontece se declararmos um n√∫mero decimal? </p><br><p>  Evite isso se voc√™ espera obter uma vari√°vel do tipo <strong>float</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID, IF THIS IS A FLOAT var floatNumber = 20.5; // this is inferred as double</span></span></code> </pre> <br><p>  Para evitar surpresa, use o literal apropriado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER, IF THIS IS A FLOAT var floatNumber = 20.5F; // this is inferred as float</span></span></code> </pre> <br><h2 id="punkt-3-v-nekotoryh-sluchayah-var-i-neyavnye-privedeniya-tipov-mogut-uprostit-podderzhku-koda">  Ponto 3: em alguns casos, convers√µes de tipo var e impl√≠citas podem simplificar o suporte ao c√≥digo </h2><br><p>  Por exemplo, vamos supor que nosso c√≥digo esteja entre dois m√©todos.  Um m√©todo obt√©m um carrinho de compras com produtos diferentes e calcula o melhor pre√ßo.  Para fazer isso, ele compara v√°rios pre√ßos no mercado e retorna o pre√ßo total na forma de um tipo <strong>flutuante</strong> .  Outro m√©todo simplesmente deduz esse pre√ßo do cart√£o. </p><br><p>  Primeiro, vejamos um m√©todo que calcula o melhor pre√ßo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre> <br><p>  Em segundo lugar, vamos dar uma olhada no m√©todo que funciona com o mapa: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Agora, colocamos nosso c√≥digo entre esses dois m√©todos de servi√ßo externos como cliente.  Nossos usu√°rios podem escolher as mercadorias a serem compradas e calculamos o melhor pre√ßo para elas e, em seguida, baixamos os fundos do cart√£o: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public void purchaseCart(long customerId) { ... float price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><p>  Ap√≥s algum tempo, a empresa propriet√°ria da API decide abandonar a representa√ß√£o material dos pre√ßos em favor do decimal (em vez de <strong>float</strong> , <strong>int</strong> agora √© usado).  Ent√£o, eles modificaram o c√≥digo da API da seguinte maneira: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> realprice = ...; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) realprice; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  O fato √© que nosso c√≥digo usa uma declara√ß√£o expl√≠cita de uma vari√°vel <strong>float</strong> como pre√ßo.  Em sua forma atual, receberemos um erro no momento da compila√ß√£o.  Mas se tiv√©ssemos previsto tal situa√ß√£o e usado <strong>var em</strong> vez de <strong>float</strong> , nosso c√≥digo continuaria funcionando sem problemas, gra√ßas √† convers√£o impl√≠cita de tipo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public void purchaseCart(long customerId) { ... var price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><h2 id="punkt-4-kogda-literaly-ne-yavlyayutsya-podhodyaschim-resheniem-to-ispolzuyte-yavnoe-privedenie-tipov-ili-otkazhites-ot-var">  Ponto 4: quando literais n√£o s√£o uma solu√ß√£o adequada, use convers√£o expl√≠cita ou descartar var </h2><br><p>  Alguns tipos primitivos em Java n√£o possuem literais especiais, por exemplo, <strong>bytes</strong> e tipos <strong>curtos</strong> .  Nesse caso, usando a designa√ß√£o expl√≠cita de tipo, podemos criar vari√°veis ‚Äã‚Äãsem problemas. </p><br><p>  Use isso em vez de <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS INSTEAD OF USING VAR byte byteNumber = 45; // this is of type byte short shortNumber = 4533; // this is of type short</span></span></code> </pre> <br><p>  Mas por que nessa situa√ß√£o dar prefer√™ncia √† nota√ß√£o de tipo expl√≠cita em vez de apenas usar <strong>var</strong> ?  Bem, vamos escrever esse c√≥digo usando <strong>var</strong> .  Observe que nos dois casos, o compilador assumir√° que voc√™ precisa de vari√°veis ‚Äã‚Äãdo tipo <strong>int</strong> . </p><br><p>  Evite este erro: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteNumber = 45; // this is inferred as int var shortNumber = 4533; // this is inferred as int</span></span></code> </pre> <br><p>  N√£o h√° literais aqui que viriam em nosso aux√≠lio, portanto somos for√ßados a usar a convers√£o expl√≠cita de tipo descendente.  Pessoalmente, evitarei essas situa√ß√µes, porque n√£o vejo vantagens aqui. </p><br><p>  Use esta entrada apenas se voc√™ realmente quiser usar <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS ONLY IF YOU WANT TO USE VAR var byteNumber = (byte) 45; // this is inferred as byte var shortNumber = (short) 4533; // this is inferred as short</span></span></code> </pre> <br><h2 id="punkt-5-izbegayte-ispolzovaniya-var-esli-nazvaniya-peremennyh-ne-soderzhat-dostatochnoy-informacii-o-tipe-dlya-ponimaniya-koda">  Ponto 5: evite usar var se os nomes de vari√°veis ‚Äã‚Äãn√£o contiverem informa√ß√µes de tipo suficientes para entender o c√≥digo </h2><br><p>  A vantagem de usar <strong>var</strong> √© escrever um c√≥digo mais conciso.  Por exemplo, no caso de usar construtores, podemos evitar a necessidade de repetir o nome da classe e, portanto, eliminar a redund√¢ncia de c√≥digo. </p><br><p>  Evite o seguinte: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID MemoryCacheImageInputStream inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Use em vez disso: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p>  Para a constru√ß√£o abaixo, <strong>var</strong> tamb√©m ser√° uma boa maneira de simplificar o c√≥digo sem perder informa√ß√µes. </p><br><p>  Evite: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fm = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Use o seguinte c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var compiler = ToolProvider.getSystemJavaCompiler(); var fileManager = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p>  Ent√£o, por que estamos mais √† vontade trabalhando com <strong>var</strong> nos exemplos apresentados?  Porque toda a informa√ß√£o necess√°ria est√° contida nos nomes das vari√°veis.  Mas se <strong>var</strong> , em combina√ß√£o com um nome de vari√°vel, reduz a clareza do c√≥digo, √© melhor recusar us√°-lo. </p><br><p>  Evite: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public File fetchCartContent() { return new File(...); } // As a human, is hard to infer the "cart" type without // inspecting the fetchCartContent() method var cart = fetchCartContent();</span></span></code> </pre> <br><p>  Use: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public File fetchCartContent() { return new File(...); } File cart = fetchCartContent();</span></span></code> </pre> <br><p>  Considere, por exemplo, o uso da classe <strong><code>java.nio.channels.Selector</code></strong> .  Esta classe possui um m√©todo est√°tico <strong><code>open()</code></strong> que retorna um novo Seletor e o abre.  Mas aqui voc√™ pode pensar facilmente que o m√©todo <strong><code>Selector.open()</code></strong> pode retornar um tipo <strong>booleano</strong> , dependendo do sucesso de abrir um seletor existente ou at√© mesmo retornar <strong>nulo</strong> .  Usar <strong>var</strong> aqui levar√° √† perda de informa√ß√µes e confus√£o no c√≥digo. </p><br><h2 id="punkt-6-tip-var-garantiruet-bezopasnost-vo-vremya-kompilyacii">  Ponto 6: o tipo var garante seguran√ßa em tempo de compila√ß√£o </h2><br><p>  Isso significa que n√£o podemos compilar um aplicativo que tente executar atribui√ß√µes incorretas.  Por exemplo, o c√≥digo abaixo n√£o compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var items = 10; items = "10 items"; // incompatible types: String cannot be converted to int</span></span></code> </pre> <br><p>  Mas este compila: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-number"><span class="hljs-number">10</span></span>; items = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br><p>  E esse c√≥digo compila com sucesso: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-string"><span class="hljs-string">"10"</span></span>; items = <span class="hljs-string"><span class="hljs-string">"10 items"</span></span>;</code> </pre> <br><p>  Depois que o compilador definiu o valor da vari√°vel <strong>var</strong> , n√£o podemos atribuir nada al√©m desse tipo. </p><br><h2 id="punkt-7-var-ne-mozhet-ispolzovatsya-dlya-sozdaniya-ekzemplyara-konkretnogo-tipa-i-naznacheniya-ego-peremennoy-tipa-interfeysa">  Ponto 7: var n√£o pode ser usado para instanciar um tipo espec√≠fico e atribu√≠-lo a uma vari√°vel do tipo de interface </h2><br><p>  Em Java, usamos a abordagem "programa√ß√£o com interfaces".  Por exemplo, criamos uma inst√¢ncia da classe ArrayList, associando-a a uma abstra√ß√£o (interface): </p><br><pre> <code class="java hljs">List&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  E evitamos coisas como vincular um objeto a uma vari√°vel do mesmo tipo: </p><br><pre> <code class="java hljs">ArrayList&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p>  Essa √© a pr√°tica mais comum e desej√°vel, pois podemos substituir facilmente a implementa√ß√£o da interface por qualquer outra.  Para isso, √© necess√°rio apenas declarar uma vari√°vel do tipo de interface. </p><br><p>  N√£o seremos capazes de seguir esse conceito usando vari√°veis ‚Äã‚Äãvar, pois  um tipo espec√≠fico √© sempre exibido para eles.  Por exemplo, no seguinte fragmento de c√≥digo, o compilador determinar√° o tipo da vari√°vel como <strong><code>ArrayList&lt;String&gt;</code></strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Existem v√°rios argumentos de defesa que explicam esse comportamento: </p><br><ul><li><p>  <strong>var √©</strong> usado para vari√°veis ‚Äã‚Äãlocais, onde, na maioria dos casos, a programa√ß√£o usando interfaces √© usada menos do que nos casos com par√¢metros de m√©todo retornados por valores ou campos </p><br></li><li><p>  O escopo das vari√°veis ‚Äã‚Äãlocais deve ser pequeno, portanto, resolver problemas causados ‚Äã‚Äãpela mudan√ßa para outra implementa√ß√£o n√£o deve ser muito dif√≠cil. </p><br></li><li><p>  <strong>var</strong> trata o c√≥digo √† direita como o inicializador usado para determinar o tipo real.  Se, em algum momento, o inicializador for alterado, o tipo que est√° sendo definido tamb√©m poder√° ser alterado, causando problemas no c√≥digo que depende dessa vari√°vel. </p><br></li></ul><br><h2 id="punkt-8-veroyatnost-vyvoda-neozhidaemogo-tipa">  Par√°grafo 8: probabilidade de conclus√£o de um tipo inesperado </h2><br><p>  O uso de var em combina√ß√£o com um <strong>operador de diamante</strong> (&lt;&gt;) na aus√™ncia de informa√ß√µes para identificar o tipo pode levar a resultados inesperados. </p><br><p>  Antes do Java 7, a infer√™ncia expl√≠cita de tipo era usada para cole√ß√µes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicitly specifying generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;String&gt;();</span></span></code> </pre> <br><p>  A partir do Java 7, o <strong>operador diamante</strong> foi introduzido.  Nesse caso, o compilador derivar√° independentemente o tipo necess√°rio: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferring generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;&gt;();</span></span></code> </pre> <br><p>  Que tipo ser√° exibido no c√≥digo abaixo? </p><br><p>  Voc√™ deve evitar essas constru√ß√µes: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var productList = new ArrayList&lt;&gt;(); // is inferred as ArrayList&lt;Object&gt;</span></span></code> </pre> <br><p>  O tipo ser√° definido como <strong><code>ArrayList&lt;Object&gt;</code></strong> .  Isso ocorre porque as informa√ß√µes necess√°rias para determinar corretamente o tipo n√£o s√£o fornecidas.  Isso leva ao fato de que o tipo mais pr√≥ximo ser√° selecionado, o que pode ser compat√≠vel com o contexto do que est√° acontecendo.  Nesse caso, <strong><code>Object</code></strong> . </p><br><p>  Assim, <strong>var</strong> s√≥ pode ser usado se fornecermos as informa√ß√µes necess√°rias para determinar o tipo esperado.  O tipo pode ser especificado diretamente ou passado como argumento. </p><br><p>  Especifique diretamente o tipo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var productList = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p>  Passe argumentos do tipo necess√°rio: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(productStack); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><pre> <code class="java hljs">Product p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); Product p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfProduct = List.of(p1, p2); <span class="hljs-comment"><span class="hljs-comment">// inferred as List&lt;Product&gt; // DON'T DO THIS var listofProduct = List.of(); // inferred as List&lt;Object&gt; listofProduct.add(p1); listofProduct.add(p2);</span></span></code> </pre> <br><h2 id="punkt-9-prisvoenie-massiva-k-var-peremennoy-ne-trebuet-skobok--">  Item 9: atribuir uma matriz a uma vari√°vel var n√£o requer colchetes [] </h2><br><p>  Todos n√≥s sabemos como declarar matrizes em Java: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// or, less preferred int numbers[] = new int[5];</span></span></code> </pre> <br><p>  Que tal usar <strong>var</strong> ao trabalhar com matrizes?  Nesse caso, n√£o h√° necessidade de usar colchetes no lado esquerdo. </p><br><p>  Evite o seguinte (isso nem compila): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var[] numbers = new int[5]; // or var numbers[] = new int[5];</span></span></code> </pre> <br><p>  Use: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var numbers = new int[5]; // inferred as array of int numbers[0] = 2; // work numbers[0] = 2.2; // doesn't work numbers[0] = "2"; // doesn't work</span></span></code> </pre> <br><p>  O c√≥digo abaixo usando <strong>var</strong> tamb√©m falha na compila√ß√£o.  Isso ocorre porque o compilador n√£o pode determinar o tipo do lado direito: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type work as expected int[] numbers = {1, 2, 3}; // IT DOESN'T COMPILE var numbers = {1, 2, 3}; var numbers[] = {1, 2, 3}; var[] numbers = {1, 2, 3};</span></span></code> </pre> <br><h2 id="punkt-10-var-nelzya-ispolzovat-pri-obyavlenii-neskolkih-peremennyh-v-odnoy-stroke">  Item 10: var n√£o pode ser usado ao declarar v√°rias vari√°veis ‚Äã‚Äãna mesma linha </h2><br><p>  Se voc√™ deseja declarar vari√°veis ‚Äã‚Äãdo mesmo tipo de uma s√≥ vez, precisa saber que <strong>var</strong> n√£o <strong>√©</strong> adequado para isso.  O c√≥digo a seguir n√£o compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: 'var' is not allowed in a compound declaration var hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Use em vez disso: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p>  Ou √©: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var hello = "hello"; var bye = "bye"; var welcome = "welcome";</span></span></code> </pre> <br><h2 id="punkt-11-lokalnye-peremennye-dolzhny-stremitsya-k-minimizacii-svoey-oblasti-vidimosti-tip-var-usilivaet-eto-utverzhdenie">  Ponto 11: vari√°veis ‚Äã‚Äãlocais devem se esfor√ßar para minimizar seu escopo.  O tipo var refor√ßa essa afirma√ß√£o. </h2><br><p>  Mantenha um pequeno escopo para vari√°veis ‚Äã‚Äãlocais - tenho certeza de que voc√™ ouviu essa declara√ß√£o antes de <strong>var</strong> . </p><br><p>  A legibilidade e as corre√ß√µes r√°pidas de bugs s√£o argumentos a favor dessa abordagem.  Por exemplo, vamos definir uma pilha da seguinte maneira: </p><br><p>  Evite isso: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // George, Tyllen, Martin, Kelly stack.forEach(...); ...</span></span></code> </pre> <br><p>  Observe que estamos chamando o m√©todo <strong><code>forEach()</code></strong> , herdado de <strong><code>java.util.Vector</code></strong> .  Este m√©todo percorrer√° a pilha como qualquer outro vetor e √© disso que precisamos.  Mas agora decidimos usar <strong><code>ArrayDeque</code></strong> vez de <strong><code>Stack</code></strong> .  Quando fazemos isso, o m√©todo <strong><code>forEach()</code></strong> receber√° uma implementa√ß√£o de ArrayDeque que percorrer√° a pilha como uma pilha padr√£o (LIFO) </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new ArrayDeque&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // Kelly, Martin, Tyllen, George stack.forEach(...); ...</span></span></code> </pre> <br><p>  N√£o √© isso que queremos.  √â muito dif√≠cil rastrear o erro aqui, porque o c√≥digo que cont√©m a parte <strong><code>forEach()</code></strong> n√£o est√° localizado pr√≥ximo ao c√≥digo no qual as altera√ß√µes foram feitas.  Para aumentar a velocidade de busca e corre√ß√£o de erros, √© muito melhor escrever c√≥digo usando a vari√°vel de <strong><code>stack</code></strong> , o mais pr√≥ximo poss√≠vel da declara√ß√£o dessa vari√°vel. </p><br><p>  √â melhor fazer o seguinte: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // George, Tyllen, Martin, Kelly stack.forEach(...); ... // 50 lines of code that doesn't use stack</span></span></code> </pre> <br><p>  Agora, quando o desenvolvedor alternar de <strong><code>Stack</code></strong> para <strong><code>ArrayQueue</code></strong> , ele poder√° perceber rapidamente o erro e corrigi-lo. </p><br><h2 id="punkt-12-tip-var-uproschaet-ispolzovanie-razlichnyh-tipov-v-ternarnyh-operatorah">  Cl√°usula 12: o tipo var simplifica o uso de v√°rios tipos em operadores tern√°rios </h2><br><p>  Podemos usar diferentes tipos de operandos no lado direito do operador tern√°rio. </p><br><p>  Ao especificar explicitamente tipos, o c√≥digo a seguir n√£o √© compilado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE List code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // or Set code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10);</span></span></code> </pre> <br><p>  No entanto, podemos fazer isso: </p><br><pre> <code class="java hljs">Collection code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); Object code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  O c√≥digo abaixo tamb√©m n√£o compila: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE int code = intOrString ? 12112 : "12112"; String code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  Mas voc√™ pode usar tipos mais gerais: </p><br><pre> <code class="java hljs">Serializable code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>; Object code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>;</code> </pre> <br><p>  Em todos esses casos, √© melhor preferir <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // inferred as Collection&lt;Integer&gt; var code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // inferred as Serializable var code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p>  A partir desses exemplos, n√£o se segue que o tipo <strong>var</strong> define os tipos de objeto em tempo de execu√ß√£o.  Isto n√£o √© assim! </p><br><p>  E, √© claro, o tipo <strong>var</strong> funcionar√° corretamente com os mesmos tipos de ambos os operandos: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferred as float var code = oneOrTwoDigits ? 1211.2f : 1211.25f;</span></span></code> </pre> <br><h2 id="punkt-13-tip-var-mozhet-byt-ispolzovan-vnutri-ciklov">  Ponto 13: o tipo var pode ser usado dentro de loops </h2><br><p>  Podemos facilmente substituir a declara√ß√£o expl√≠cita de types in <strong>for</strong> loops pelo tipo <strong>var</strong> . </p><br><p>  Alterando um tipo <strong>int</strong> expl√≠cito para <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type for (int i = 0; i &lt; 5; i++) { ... } // using var for (var i = 0; i &lt; 5; i++) { // i is inferred of type int ... }</span></span></code> </pre> <br><p>  Alterando o tipo expl√≠cito de <strong><code>Order</code></strong> para <strong>var</strong> : </p><br><pre> <code class="java hljs">List&lt;Order&gt; orderList = ...; <span class="hljs-comment"><span class="hljs-comment">// explicit type for (Order order : orderList) { ... } // using var for (var order : orderList) { // order type is inferred as Order ... }</span></span></code> </pre> <br><h2 id="punkt-14-var-otlichno-rabotaet-s-potokami-stream-v-java-8">  Ponto 14: var funciona bem com fluxos em Java 8 </h2><br><p>  √â muito simples usar var do Java 10 com fluxos que apareceram no Java 8. </p><br><p>  Voc√™ pode simplesmente substituir a declara√ß√£o expl√≠cita do tipo <strong>Stream</strong> por <strong>var</strong> : </p><br><h3 id="primer-1-1">  Exemplo 1: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 5); numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println); // using var var numbers = Stream.of(1, 2, 3, 4, 5); // inferred as Stream&lt;Integer&gt; numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println);</span></span></code> </pre> <br><h3 id="primer-2-1">  Exemplo 2: </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit types Stream&lt;String&gt; paths = Files.lines(Path.of("...")); List&lt;File&gt; files = paths.map(p -&gt; new File(p)).collect(toList()); // using var var paths = Files.lines(Path.of("...")); // inferred as Stream&lt;String&gt; var files = paths.map(p -&gt; new File(p)).collect(toList()); // inferred as List&lt;File&gt;</span></span></code> </pre><br><h2 id="punkt-15-var-mozhno-ispolzovat-pri-obyavlenii-lokalnyh-peremennyh-prednaznachennyh-dlya-razbieniya-bolshih-cepochek-vyrazheniy-na-chasti">  Cl√°usula 15: var pode ser usada ao declarar vari√°veis ‚Äã‚Äãlocais destinadas a quebrar grandes cadeias de express√µes em partes </h2><br><p>  Express√µes com muitos aninhamentos parecem impressionantes e geralmente parecem algum tipo de c√≥digo inteligente e importante.  No caso em que √© necess√°rio facilitar a legibilidade do c√≥digo, √© recomend√°vel dividir uma express√£o grande usando vari√°veis ‚Äã‚Äãlocais.  Mas, √†s vezes, escrever muitas vari√°veis ‚Äã‚Äãlocais parece um trabalho muito exaustivo que eu gostaria de evitar. </p><br><p>  Um exemplo de uma express√£o grande: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// AVOID int result = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)) .values() .stream() .max(Comparator.comparing(List::size)) .orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  Melhor dividir o c√≥digo em seus componentes: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); Optional&lt;List&lt;Integer&gt;&gt; evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); int sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p>  A segunda vers√£o do c√≥digo parece mais leg√≠vel e mais simples, mas a primeira vers√£o tamb√©m tem o direito de existir.  √â absolutamente normal que nossa mente se adapte ao entendimento de express√µes t√£o grandes e as prefira a vari√°veis ‚Äã‚Äãlocais.  No entanto, o uso do tipo <strong>var</strong> pode ajudar a dividir grandes estruturas, reduzindo o esfor√ßo para declarar vari√°veis ‚Äã‚Äãlocais: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER var evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); var evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); var sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><h2 id="punkt-16-var-ne-mozhet-byt-ispolzovan-kak-tip-vozvraschaemogo-znacheniya-ili-kak-tip-argumenta-metoda">  Cl√°usula 16: var n√£o pode ser usada como um tipo de retorno ou como um tipo de argumento de m√©todo </h2><br><p>  Os dois trechos de c√≥digo mostrados abaixo n√£o ser√£o compilados. </p><br><p>  Usando <strong>var</strong> como o tipo de retorno: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public var countItems(Order order, long timestamp) { ... }</span></span></code> </pre> <br><p>  Usando <strong>var</strong> como um tipo de argumento de m√©todo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public int countItems(var order, var timestamp) { ... }</span></span></code> </pre> <br><h2 id="punkt-17-lokalnye-peremennye-tipa-var-mogut-byt-peredany-kak-parametry-metoda-ili-mogut-prinimat-vozvraschaemoe-metodom-znachenie">  Cl√°usula 17: vari√°veis ‚Äã‚Äãlocais do tipo var podem ser passadas como par√¢metros do m√©todo ou podem assumir o valor retornado pelo m√©todo </h2><br><p>  Os seguintes fragmentos de c√≥digo ser√£o compilados e funcionar√£o corretamente: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// an Order instance var timestamp = ...; // a long representing a timestamp var itemsNr = countItems(order, timestamp); // inferred as int type ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;A, B&gt; <span class="hljs-function"><span class="hljs-function">B </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A container, B tocontain)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// Order instance var product = ...; // Product instance var resultProduct = contains(order, product); // inferred as Product type</span></span></code> </pre> <br><h2 id="punkt-18-peremennye-var-mogut-byt-ispolzovany-s-anonimnymi-klassami">  18:  var       </h2><br><p>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; Product product = ...; // a Product instance int weight = weighter.getWeight(product);</span></span></code> </pre> <br><p>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; var product = ...; // a Product instance var weight = weighter.getWeight(product);</span></span></code> </pre> <br><h2 id="punkt-19-peremennye-tipa-var-mogut-ispolzovatsya-v-kachestve-effectively-final-peremennyh">  19:   var     effectively final  </h2><br><p> , : </p><br><blockquote> <em>‚Ä¶   Java SE 8,           ,   final  effectively final.   ,        ,  effectively final</em> . </blockquote><p>  ,   <strong>var</strong>   effectively final.      . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID int ratio = 5; // this is effectively final Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var ratio = 5; // this is effectively final var weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><h2 id="punkt-20-var-peremennye-mogut-byt-final-peremennymi">  20: var-   final- </h2><br><p>   <strong>var</strong>     ( ,     effectively final).     ,  <strong>final</strong> . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID // IT DOESN'T COMPILE public void discount(int price) { final int limit = 2000; final int discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // IT DOESN'T COMPILE public void discount(int price) { final var limit = 2000; final var discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><h2 id="punkt-21-lyambda-vyrazheniyam-i-ssylkam-na-metody-nuzhny-yavnye-tipy">  21:          </h2><br><p>  <strong>var</strong>   ,     .          ,   <strong>var</strong> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // lambda expression needs an explicit target-type var f = x -&gt; x + 1; // method reference needs an explicit target-type var exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Supplier&lt;IllegalArgumentException&gt; exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   Java 11   <strong>var</strong> -    .      Java 11: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 11 (var x, var y) -&gt; x + y // or (@Nonnull var x, @Nonnull var y) -&gt; x + y</span></span></code> </pre> <br><h2 id="punkt-22-inicializirovat-var-nullem-zaprescheno">  22:  var null'  </h2><br><p>   <strong>var</strong> -  . </p><br><p>     (  <strong>null</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message = null; // result in an error of type: variable initializer is 'null'</span></span></code> </pre> <br><p>      ( ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message; // result in: cannot use 'var' on variable without initializer ... message = "hello";</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String message = null; // or String message; ... message = "hello";</span></span></code> </pre> <br><h2 id="punkt-23-tip-var-nelzya-ispolzovat-v-polyah-klassa">  23:  var      </h2><br><p>    <strong>var</strong>   ,      . </p><br><p>      : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public class Product { private var price; // error: 'var' is not allowed here private var name; // error: 'var' is not allowed here ... }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public class Product { private int price; private String name; ... }</span></span></code> </pre> <br><h2 id="punkt-24-var-nelzya-ispolzovat-v-bloke-catch">  24: var     catch </h2><br><p>   ,    try-with-resources </p><br><h3 id="blok-catch">  catch </h3><br><p>    ,    ,   . </p><br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE try { TimeUnit.NANOSECONDS.sleep(5000); } catch (var ex) { ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER try { TimeUnit.NANOSECONDS.sleep(5000); } catch (InterruptedException ex) { ... }</span></span></code> </pre> <br><h3 id="try-with-resources"> Try-with-resources </h3><br><p> , <strong>var</strong>     <strong>try-with-resources</strong> . </p><br><p> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type try (PrintWriter writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><p>     <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var try (var writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><h2 id="punkt-25-tip-var-mozhno-ispolzovat-s-dzhenerikami">  25:  var     </h2><br><p> ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>   ,  <strong>var</strong>    ,       <strong>T</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>     ,      <strong>var</strong> : </p><br><pre> <code class="java hljs">codepublic &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)); numbers.add((T) Double.valueOf(<span class="hljs-number"><span class="hljs-number">3.9</span></span>)); numbers.add(t); numbers.add(<span class="hljs-string"><span class="hljs-string">"5"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><p>     <strong>List&lt;T&gt;</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// DON'T DO THIS, DON'T FORGET THE, T var numbers = new ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(3)); numbers.add((T) Double.valueOf(3.9)); numbers.add(t); numbers.add("5"); // error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><h2 id="punkt-26-budte-vnimatelny-s-tipom-var-pri-ispolzovanii-wildcards--kovariantov-i-kontrvariantov">  26:     var   Wildcards (?),    </h2><br><h3 id="ispolzovanie--wildcards"> ? Wildcards </h3><br><p>    <strong>var</strong>  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;?&gt; clazz = Integer.class; // use var var clazz = Integer.class;</span></span></code> </pre> <br><p>    <strong>Foo&lt;?&gt;</strong>  <strong>var</strong>  ,      ,    <strong>var</strong>    . </p><br><p>     ,   , , ,    .       ,     <strong>ArrayList</strong>  ,     <strong>Collection&lt;?&gt;</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Collection&lt;?&gt; stuff = new ArrayList&lt;&gt;(); stuff.add("hello"); // compile time error stuff.add("world"); // compile time error // use var, this will remove the error, but I don't think that this is // what you had in mind when you wrote the above code var stuff = new ArrayList&lt;&gt;(); strings.add("hello"); // no error strings.add("world"); // no error</span></span></code> </pre> <br><h3 id="ispolzovanie-kovariantov-foo--extends-t-i-kontrvariantov-foo--super-t">   (Foo &lt;? extends T&gt;)   (Foo &lt;? super T&gt;) </h3><br><p>  ,    : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;? extends Number&gt; intNumber = Integer.class; Class&lt;? super FilterReader&gt; fileReader = Reader.class;</span></span></code> </pre> <br><p>            ,    ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: Class&lt;Reader&gt; cannot be converted to Class&lt;? extends Number&gt; Class&lt;? extends Number&gt; intNumber = Reader.class; // error: Class&lt;Integer&gt; cannot be converted to Class&lt;? super FilterReader&gt; Class&lt;? super FilterReader&gt; fileReader = Integer.class;</span></span></code> </pre> <br><p>    <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var var intNumber = Integer.class; var fileReader = Reader.class;</span></span></code> </pre> <br><p>       ,     .        ‚Äì     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this will compile just fine var intNumber = Reader.class; var fileReader = Integer.class;</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>       ¬´ <strong>var</strong> ¬ª,    Java 10.    ,           .   ,      <strong>var</strong>    ,     . </p><br><p>  <strong>var</strong>      Java! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438206/">https://habr.com/ru/post/pt438206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438182/index.html">O estudo constatou os benef√≠cios da pirataria moderada para produtores e distribuidores de conte√∫do</a></li>
<li><a href="../pt438196/index.html">Se o projeto for "Teatro", use atores ...</a></li>
<li><a href="../pt438198/index.html">Vamos aprofundar a hist√≥ria: onde crescem as pernas dos quadroc√≥pteros</a></li>
<li><a href="../pt438202/index.html">JavaScript: campos de classe p√∫blica e privada</a></li>
<li><a href="../pt438204/index.html">Dispositivo compilador r√°pido. Parte 1</a></li>
<li><a href="../pt438210/index.html">Civiliza√ß√£o de Springs, 2/5</a></li>
<li><a href="../pt438212/index.html">Prova de conceito: como verificar se a implementa√ß√£o do ML vale a pena</a></li>
<li><a href="../pt438214/index.html">Startups de tecnologia dos EUA enfrentar√£o novos controles governamentais em 2019</a></li>
<li><a href="../pt438218/index.html">OpenSceneGraph: Manipula√ß√£o de Eventos</a></li>
<li><a href="../pt438224/index.html">Bairro do governo. Piloto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>