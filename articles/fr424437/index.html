<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚞 🤥 🎸 Orme. Confortable et maladroit. Json.Encoder et Json.Decoder 🏚️ 🤾🏽 🥀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons de parler de l' orme 0,18 . 


 Orme. Confortable et maladroit 
 Orme. Confortable et maladroit. La composition 
 Orme. Confortable et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Orme. Confortable et maladroit. Json.Encoder et Json.Decoder</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424437/"><p>  Nous continuons de parler de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">orme 0,18</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Orme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Confortable et maladroit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Orme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Confortable et maladroit.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La composition</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Orme.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Confortable et maladroit.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Http, Task</a> </p><br><p>  Cet article couvrira les problèmes des encodeurs / décodeurs. </p><br><p>  Les décodeurs / encodeurs sont utilisés pour: </p><br><ol><li>  conversion des réponses de ressources tierces (Http, WebSocket, etc.); </li><li>  interactions via les ports.  Je vais vous en dire plus sur les ports et le code natif dans les articles suivants. </li></ol><a name="habracut"></a><br><p>  Comme décrit précédemment, Elm nous oblige à transformer les données externes en types d'applications internes.  Le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Json.Decode</a> est responsable de ce processus.  Le processus inverse est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Json.Encode</a> . </p><br><p>  Le type qui définit les règles de décodage est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Json.Decode.Decoder a</a> .  Ce type est paramétré par le type d'utilisateur et détermine comment obtenir le type d'utilisateur a à partir de l'objet JSON. </p><br><p>  Pour l'encodeur, seul le type de résultat est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">défini</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Json.Encode.Value</a> . </p><br><p>  Prenons des exemples pour le type UserData. </p><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Décodeur pour recevoir des données de l'utilisateur: </p><br><pre> <code class="hljs pgsql">decodeUserData : <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.Decoder UserData decodeUserData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map3 UserData (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “id” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.int) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “<span class="hljs-type"><span class="hljs-type">name</span></span>” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “email” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) encodeUserData : UserData -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> encodeUserData userData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ ( “id”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.int userData.id) , ( “<span class="hljs-type"><span class="hljs-type">name</span></span>”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.name) , ( “email”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.email) ]</code> </pre> <br><p>  La fonction Json.Decode.map3 accepte un constructeur de type UserData.  Ensuite, trois décodeurs du type sont transmis conformément à l'ordre de leur déclaration dans le type d'utilisateur UserData. </p><br><p>  La fonction decodeUserData peut être utilisée conjointement avec les fonctions Json.Decode.decodeString ou Json.Decode.decodeValue.  <a href="">Un exemple d'utilisation</a> des articles précédents. </p><br><p>  La fonction encodeUserData produit un encodage de type personnalisé du type Json.Encode.Value, qui peut être envoyé.  En termes simples, Json.Encode.Value correspond à un objet JSON. </p><br><p>  Des options simples sont décrites dans la documentation, elles peuvent être étudiées sans trop de difficultés.  Regardons les cas de vie qui nécessitent un tour de passe-passe. </p><br><h2 id="dekodery-union-tipov-ili-diskriminatory-tipov">  Décodeurs de type union ou discriminateurs de type </h2><br><p>  Supposons que nous ayons un catalogue de marchandises.  Et chaque produit peut avoir un nombre arbitraire d'attributs, dont chacun a un type de l'un des nombreux: </p><br><ol><li>  entier </li><li>  chaîne </li><li>  énumérés.  Suppose le choix de l'une des valeurs valides. </li></ol><br><p>  Un objet JSON est valide comme suit: </p><br><pre> <code class="hljs powershell">{ “id”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “name”: “Product name”, “price”: <span class="hljs-number"><span class="hljs-number">1000</span></span>, “attributes”: [ { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-type"><span class="hljs-type">Length</span></span>”, “<span class="hljs-type"><span class="hljs-type">unit</span></span>”: “<span class="hljs-type"><span class="hljs-type">meters</span></span>”, “<span class="hljs-type"><span class="hljs-type">value</span></span>”: <span class="hljs-number"><span class="hljs-number">100</span></span> }, { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-type"><span class="hljs-type">Color</span></span>”, “<span class="hljs-type"><span class="hljs-type">unit</span></span>”: “”, “<span class="hljs-type"><span class="hljs-type">value</span></span>”: { “<span class="hljs-type"><span class="hljs-type">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">label</span></span>”: “<span class="hljs-type"><span class="hljs-type">red</span></span>” } },<span class="hljs-type"><span class="hljs-type">...</span></span> ] }</code> </pre> <br><p>  Les autres types possibles ne seront pas pris en compte; leur utilisation est similaire.  Un type de produit personnalisé aurait alors la description suivante: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Product = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , price: <span class="hljs-type"><span class="hljs-type">Int</span></span> , attributes: Attributes } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Attributes = List <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , unit: String , <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: AttributeValue } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AttributeValue = IntValue <span class="hljs-type"><span class="hljs-type">Int</span></span> | StringValue String | EnumValue Enum <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Enum = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , label: String }</code> </pre> <br><p>  Nous discuterons légèrement des types décrits.  Il existe un produit (Produit), qui contient une liste d'attributs / caractéristiques (Attributs).  Chaque attribut (attribut) contient un identifiant, un nom, une dimension et une valeur.  La valeur d'attribut est décrite comme type d'union, un élément pour chaque type de valeur caractéristique.  Le type Enum décrit une valeur d'un ensemble acceptable et contient: l'identifiant et la valeur lisible par l'homme. </p><br><p>  Description du décodeur, omettez le préfixe Json.Decode pour plus de brièveté: </p><br><pre> <code class="hljs cpp">decodeProduct : Decoder Product decodeProduct = map4 Product (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “price” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “attributes” decodeAttributes) decodeAttributes : Decoder Attributes decodeAttributes = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> decodeAttribute decodeAttribute : Decoder Attribute decodeAttribute = map4 Attribute (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “unit” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “value” decodeAttributeValue) decodeAttributeValue : Decoder AttributeValue decodeAttributeValue = oneOf [ <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> IntValue <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> StringValue <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> EnumValue decodeEnumValue ] decodeEnumValue : Decoder Enum decodeEnumValue = map2 Enum (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “label” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)</code> </pre> <br><p>  L'astuce est contenue dans la fonction decodeAttributeValue.  L'utilisation de la fonction Json.Decode.oneOf parcourt tous les décodeurs valides pour la valeur d'attribut.  En cas de décompression réussie par l'un des décodeurs, la valeur est étiquetée avec l'étiquette correspondante du type AttributeValue. </p><br><p>  L'encodage du type de produit peut être effectué à l'aide de la fonction Json.Encode.object, dans laquelle les attributs de type encodés seront transmis.  Il convient de prêter attention au codage de type AttributeValue.  Conformément à l'objet JSON décrit précédemment, l'encodeur peut être décrit comme le préfixe Json.Encode omis par souci de concision: </p><br><pre> <code class="hljs cs">encodeAttributeValue : AttributeValue -&gt; Value encodeAttributeValue attributeValue = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> attributeValue of IntValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> StringValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> EnumValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ (“id”, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.id) , (“id”, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.label) ]</code> </pre> <br><p>  Comme vous pouvez le voir, nous comparons les options de type et utilisons les encodeurs correspondants. </p><br><p>  Modifiez la description des attributs et définissez-les à l'aide d'un discriminateur de type.  L'objet attribut JSON, dans ce cas, ressemblerait à ceci: </p><br><pre> <code class="hljs pgsql">{ “id”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>”, “<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>”: “<span class="hljs-type"><span class="hljs-type">int</span></span>”, “value_int”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “value_string”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_id”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_label”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br><p>  Dans ce cas, le discriminateur de type est stocké dans le champ type et détermine dans quel champ la valeur est stockée.  Une telle structure de description n'est probablement pas la plus pratique, mais elle est souvent trouvée.  Cela ne vaut probablement pas la peine de changer la description du type de cet objet JSON, il est préférable de conserver les types sous une forme pratique pour un usage interne.  Dans ce cas, la description du décodeur peut être la suivante: </p><br><pre> <code class="hljs vhdl">decodeAttribute2 : Decoder <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> decodeAttribute2 = field <span class="hljs-string"><span class="hljs-string">"type"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; andThen decodeAttributeValueType |&gt; andThen (\attributeValue -&gt; map4 <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> (field <span class="hljs-string"><span class="hljs-string">"id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field <span class="hljs-string"><span class="hljs-string">"unit"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (succeed attributeValue) ) decodeAttributeValueType : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Decoder AttributeValue decodeAttributeValueType valueType = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> valueType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_int"</span></span> int |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> IntValue <span class="hljs-string"><span class="hljs-string">"string"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_string"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> StringValue <span class="hljs-string"><span class="hljs-string">"enum"</span></span> -&gt; map2 Enum (field <span class="hljs-string"><span class="hljs-string">"value_enum_id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"value_enum_label"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> EnumValue _ -&gt; Json.Decode.fail <span class="hljs-string"><span class="hljs-string">"Unknown attribute type"</span></span></code> </pre> <br><p>  Dans la fonction decodeAttribute2, nous décodons d'abord le discriminateur, en cas de succès, nous décodons la valeur d'attribut.  Ensuite, nous décodons les champs restants du type Attribut et spécifions la valeur précédemment obtenue comme valeur du champ de valeur. </p><br><p>  <a href="">Le code source du décodeur</a> . </p><br><h2 id="chastichnoe-obnovlenie-tipa">  Mise à jour de type partielle </h2><br><p>  Dans certains cas, l'API ne renvoie pas l'intégralité de l'objet, mais seulement une partie de celui-ci.  Par exemple, lors de l'enregistrement pour visualiser ou modifier le statut d'un objet.  Dans ce cas, il est plus pratique de recevoir immédiatement l'objet mis à jour dans le message et de masquer toutes les manipulations derrière le décodeur. </p><br><p>  Par exemple, nous prenons le même produit, mais y ajoutons le champ d'état et traiterons la demande de fermeture du produit. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Attributes</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } decodeUpdateStatus : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Decoder</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> decodeUpdateStatus product = field “status” int |&gt; andThen (\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">succeed</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">product</span></span></span><span class="hljs-class"> | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class">} )</span></span></code> </pre> <br><p>  Ou vous pouvez utiliser la fonction Json.Decode.map. </p><br><pre> <code class="hljs erlang-repl">decodeUpdateStatus : Product -&gt; Decoder Product decodeUpdateStatus product = field “status” int |&gt; map (\newStatus -&gt; { product | status = newStatus} )</code> </pre> <br><h2 id="data-i-vremya">  Date et heure </h2><br><p>  Nous utiliserons la fonction Date.fromString, qui est implémentée à l'aide du constructeur de type Date. </p><br><pre> <code class="hljs pgsql">decodeDateFromString : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromString = string |&gt; andThen (\stringDate -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromString stringDate <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Ok <span class="hljs-type"><span class="hljs-type">date</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.succeed <span class="hljs-type"><span class="hljs-type">date</span></span> Err reason -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.fail reason )</code> </pre> <br><p>  Si l'horodatage est utilisé comme une représentation date / heure, le décodeur en général peut être décrit comme: </p><br><pre> <code class="hljs pgsql">decodeDateFromTimestamp : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromTimestamp = oneOf [ <span class="hljs-type"><span class="hljs-type">int</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map toFloat , <span class="hljs-type"><span class="hljs-type">float</span></span> ] |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromTime</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424437/">https://habr.com/ru/post/fr424437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424427/index.html">Les robots Roskomnadzor et Telegram via un proxy</a></li>
<li><a href="../fr424429/index.html">Science, Art et Son: 4 projets impressionnants</a></li>
<li><a href="../fr424431/index.html">Valve dévoile le classement des contrôleurs de jeux Steam</a></li>
<li><a href="../fr424433/index.html">Pourquoi les pirates Mikrotik et comment j'ai caché 100 000. RouterOS d'un botnet</a></li>
<li><a href="../fr424435/index.html">Zoo de forage pétrolier: mettre les choses en ordre</a></li>
<li><a href="../fr424441/index.html">Nouveautés du premier CTP de SQL Server 2019</a></li>
<li><a href="../fr424443/index.html">Vivaldi 2.0 en notre faveur</a></li>
<li><a href="../fr424445/index.html">La traduction par Neil Ford des microservices en tant qu'architecture évolutive</a></li>
<li><a href="../fr424447/index.html">Lisp parfumé avec Pascal ou le langage de programmation 8501st</a></li>
<li><a href="../fr424453/index.html">Apprenez OpenGL. Leçon 6.2 - Rendu basé sur la physique. Sources de lumière analytiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>