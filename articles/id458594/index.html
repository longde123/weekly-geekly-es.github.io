<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➡️ ♠️ ⏮️ Jangan lupa untuk meningkatkan kemungkinan respons terhadap klien menggunakan permintaan berulang dalam penyeimbangan L7 🧛🏾 👷🏻 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menggunakan nginx untuk menyeimbangkan lalu lintas HTTP di tingkat L7, dimungkinkan untuk mengirim permintaan klien ke server aplikasi berikutnya jika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jangan lupa untuk meningkatkan kemungkinan respons terhadap klien menggunakan permintaan berulang dalam penyeimbangan L7</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458594/">  Menggunakan nginx untuk menyeimbangkan lalu lintas HTTP di tingkat L7, dimungkinkan untuk mengirim permintaan klien ke server aplikasi berikutnya jika target tidak mengembalikan respons positif.  Sebuah uji mekanisme verifikasi pasif kondisi kesehatan server aplikasi menunjukkan ambiguitas dokumentasi dan spesifisitas algoritma untuk mengecualikan server dari kumpulan server produksi. <br><a name="habracut"></a><br><h2>  Ringkasan menyeimbangkan lalu lintas HTTP </h2><br>  Ada berbagai cara untuk menyeimbangkan lalu lintas HTTP.  Pada level model OSI, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada teknologi penyeimbang</a> di level jaringan, transportasi dan aplikasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kombinasi dapat digunakan</a> tergantung pada ukuran aplikasi. <br><br>  Teknologi penyeimbangan lalu lintas memberikan efek positif dalam aplikasi dan pemeliharaannya.  Ini beberapa di antaranya.  Penskalaan horisontal aplikasi, di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beban didistribusikan di antara beberapa node</a> .  Rencana dekomisioning server aplikasi dengan menghapus aliran permintaan klien darinya.  Implementasi strategi pengujian A / B untuk fungsionalitas aplikasi yang berubah.  Meningkatkan toleransi kesalahan aplikasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirimkan permintaan ke server aplikasi yang berfungsi dengan baik</a> . <br><br>  Fungsi terakhir diimplementasikan dalam dua mode.  Dalam mode pasif, penyeimbang dalam lalu lintas klien mengevaluasi respons server aplikasi target dan mengeluarkannya dari kumpulan server produksi dalam kondisi tertentu.  Dalam mode aktif, penyeimbang secara berkala mengirim permintaan ke server aplikasi di URI yang ditentukan secara spesifik, dan untuk tanda-tanda respons tertentu memutuskan untuk mengeluarkannya dari kumpulan server produksi.  Selanjutnya, penyeimbang, dalam kondisi tertentu, mengembalikan server aplikasi ke kumpulan server produksi. <br><br><h2>  Verifikasi pasif dari server aplikasi dan pengecualiannya dari kumpulan server produksi </h2><br>  Mari kita lihat lebih dekat pada pemeriksaan server aplikasi pasif dalam edisi freeware nginx / 1.17.0.  Server aplikasi dipilih pada gilirannya oleh algoritma Round Robin, bobotnya sama. <br><br>  Diagram tiga langkah menunjukkan bagian waktu dimulai dengan mengirim permintaan klien ke server aplikasi No. 2.  Indikator yang cerah mencirikan permintaan / tanggapan antara klien dan penyeimbang.  Indikator gelap - permintaan / tanggapan antara nginx dan server aplikasi. <br><br><img src="https://habrastorage.org/webt/vg/dl/yl/vgdlylmjdofsxs-iktkfimfaqr8.gif"><br><br>  Langkah ketiga diagram menunjukkan bagaimana penyeimbang mengalihkan permintaan klien ke server aplikasi berikutnya, jika server target memberikan respons kesalahan atau tidak menjawab sama sekali. <br><br>  Daftar kesalahan HTTP dan TCP di mana server menggunakan server berikut ini ditentukan dalam direktif <i>proxy_next_upstream</i> . <br><br>  Secara default, nginx hanya mengalihkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan dengan metode HTTP idempoten</a> ke server aplikasi berikutnya. <br><br>  Apa yang didapat klien?  Di satu sisi, kemampuan untuk mengarahkan permintaan ke server aplikasi berikutnya meningkatkan kemungkinan memberikan respons yang memuaskan kepada klien ketika server target gagal.  Di sisi lain, jelas bahwa panggilan berurutan pertama ke server target, dan kemudian ke berikutnya meningkatkan waktu respons total kepada klien. <br><br>  Pada akhirnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nginx.org/ru/docs/http/ngx_">respons server aplikasi dikembalikan ke</a> klien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nginx.org/ru/docs/http/ngx_">, tempat</a> <i>proxy_next_upstream_tries</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nginx.org/ru/docs/http/ngx_">upaya yang diijinkan</a> <i>berakhir</i> . <br><br>  Saat menggunakan fungsi pengalihan ke server yang berfungsi berikutnya, Anda perlu juga menyelaraskan batas waktu pada server penyeimbang dan aplikasi.  Batas atas waktu untuk permintaan "perjalanan" antara server aplikasi dan penyeimbang adalah batas waktu klien, atau waktu tunggu yang ditentukan oleh bisnis.  Saat menghitung batas waktu, juga perlu memperhitungkan margin untuk peristiwa jaringan (keterlambatan / kerugian selama pengiriman paket).  Jika klien setiap kali mengakhiri sesi dengan timeout sementara penyeimbang mendapatkan jawaban yang dijamin, niat baik untuk membuat aplikasi yang dapat diandalkan akan sia-sia. <br><br><img src="https://habrastorage.org/webt/th/wt/da/thwtdayvqkzx3tr6dvlbmou1a3q.jpeg"><br><br>  Pemeriksaan kesehatan pasif dari server aplikasi dikendalikan oleh arahan, misalnya, dengan opsi berikut untuk nilainya: <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> backend { <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> app01:<span class="hljs-number"><span class="hljs-number">80</span></span> weight=<span class="hljs-number"><span class="hljs-number">1</span></span> max_fails=<span class="hljs-number"><span class="hljs-number">5</span></span> fail_timeout=<span class="hljs-number"><span class="hljs-number">100s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> app02:<span class="hljs-number"><span class="hljs-number">80</span></span> weight=<span class="hljs-number"><span class="hljs-number">1</span></span> max_fails=<span class="hljs-number"><span class="hljs-number">5</span></span> fail_timeout=<span class="hljs-number"><span class="hljs-number">100s</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; <span class="hljs-attribute"><span class="hljs-attribute">proxy_next_upstream</span></span> timeout http_500; <span class="hljs-attribute"><span class="hljs-attribute">proxy_next_upstream_tries</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; ... } ... }</code> </pre> <br>  Pada 2 Juli <i>2019</i> , dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nginx.org/ru/docs/http/ngx_">menetapkan</a> bahwa parameter <i>max_fails</i> menetapkan jumlah upaya yang gagal untuk bekerja dengan server yang harus terjadi dalam waktu yang ditentukan oleh parameter <i>fail_timeout</i> . <br><br>  Parameter <i>fail_timeout</i> menetapkan waktu di mana jumlah upaya gagal yang ditentukan untuk bekerja dengan server harus terjadi agar server dianggap tidak tersedia;  dan waktu selama server dianggap tidak tersedia. <br><br>  Dalam contoh yang diberikan, bagian dari file konfigurasi, penyeimbang dikonfigurasi untuk menangkap 5 panggilan gagal dalam 100 detik. <br><br><h2>  Mengembalikan server aplikasi ke kumpulan server produksi </h2><br>  Sebagai berikut dari dokumentasi, penyeimbang setelah <i>fail_timeout</i> tidak dapat menganggap server tidak beroperasi.  Namun, sayangnya, dokumentasi tidak secara eksplisit menetapkan bagaimana kinerja server dievaluasi. <br><br>  Tanpa eksperimen, seseorang hanya dapat mengasumsikan bahwa mekanisme untuk memeriksa keadaan mirip dengan yang dijelaskan sebelumnya. <br><br><h2>  Harapan dan Realita </h2><br>  Dalam konfigurasi yang disajikan, perilaku berikut diharapkan dari penyeimbang: <br><br><ol><li>  Sampai penyeimbang mengecualikan server aplikasi No. 2 dari kumpulan server produksi, permintaan klien akan dikirim ke sana. </li><li>  Permintaan yang dikembalikan dengan kesalahan 500 dari server aplikasi No. 2 akan diteruskan ke server aplikasi berikutnya, dan klien akan menerima respons positif. </li><li>  Segera setelah penyeimbang menerima 5 tanggapan dengan kode 500 dalam 100 detik, ia akan mengecualikan server aplikasi No. 2 dari kumpulan server produksi.  Semua permintaan setelah jendela 100 detik akan segera dikirim ke server aplikasi yang tersisa tanpa waktu tambahan. </li><li>  Setelah 100 detik, entah bagaimana, penyeimbang harus mengevaluasi kinerja server aplikasi dan mengembalikannya ke kumpulan server produksi. </li></ol><br>  Setelah melakukan tes dalam bentuk barang, menurut majalah penyeimbang, ditetapkan bahwa pernyataan No. 3 tidak berfungsi.  Penyeimbang mengecualikan server idle segera setelah kondisi pada parameter <i>max_fails terpenuhi</i> .  Dengan demikian, server yang gagal dikecualikan dari layanan tanpa menunggu berlalu 100 detik.  Parameter <i>fail_timeout hanya</i> memainkan peran batas atas waktu akumulasi kesalahan. <br><br>  Sebagai bagian dari pernyataan No. 4, ternyata nginx memeriksa fungsionalitas aplikasi yang sebelumnya dikecualikan dari pemeliharaan server hanya dengan satu permintaan.  Dan jika server masih merespons dengan kesalahan, maka pemeriksaan berikutnya akan <i>gagal</i> setelah <i>fail_timeout</i> . <br><br><h2>  Apa yang hilang </h2><br><ol><li>  Algoritme yang diimplementasikan dalam nginx / 1.17.0 mungkin bukan cara yang paling adil untuk memeriksa kinerja server sebelum mengembalikannya ke kumpulan server produksi.  Paling tidak, sesuai dengan dokumentasi saat ini, tidak 1 permintaan diharapkan, tetapi jumlah yang ditentukan dalam <i>max_fails</i> . </li><li>  Algoritma pemeriksaan keadaan tidak memperhitungkan kecepatan permintaan.  Semakin besar, semakin kuat spektrum dengan upaya yang gagal bergeser ke kiri, dan server aplikasi keluar dari kumpulan server yang bekerja terlalu cepat.  Saya kira ini dapat mempengaruhi aplikasi yang memungkinkan mereka untuk menghasilkan kesalahan "kekurangan waktu".  Misalnya, saat mengumpulkan sampah. </li></ol><br><img src="https://habrastorage.org/webt/dg/5k/t2/dg5kt2myincbznycsx2owz_rh6w.jpeg"><br><br>  Saya ingin bertanya kepada Anda apakah ada manfaat praktis dari algoritma pemeriksaan kesehatan server, yang mengukur kecepatan upaya yang gagal? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458594/">https://habr.com/ru/post/id458594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458574/index.html">Bagaimana tumbuh dari pengembang menjadi pemimpin tim dan hidup dengannya lebih jauh</a></li>
<li><a href="../id458576/index.html">Manajemen teks dan pelokalan dalam aplikasi web</a></li>
<li><a href="../id458582/index.html">Insinyur Amazon telah menciptakan perangkat pemblokiran AI yang menjaga kucing keluar dari jalan</a></li>
<li><a href="../id458584/index.html">11 Juli, Group-IB Webinar “Analisis Malware untuk Pemula: Pendekatan Dasar”</a></li>
<li><a href="../id458592/index.html">Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC</a></li>
<li><a href="../id458596/index.html">Petty little joy # 6: OpenAI Gym - mainkan game dan kendalikan robot</a></li>
<li><a href="../id458598/index.html">Pengakuan sumber cahaya pada peta lingkungan</a></li>
<li><a href="../id458602/index.html">Bagaimana kami menembus Great Chinese Firewall (Bagian 1)</a></li>
<li><a href="../id458604/index.html">Mengapa dua produsen elektronik terbesar bergabung dalam proyek GPU baru</a></li>
<li><a href="../id458606/index.html">Jalankan OpenVPN di Docker dalam 2 detik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>