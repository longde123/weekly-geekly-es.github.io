<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏻 ❤️ 🏂🏿 MetricKit. Leistungsanalyse von iOS-Anwendungen 🤟🏽 🕴🏾 👶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neues Spielzeug 
 Wir machen uns weiterhin mit neuem Material von Apple vertraut, das auf der WWDC vorgestellt wurde. Betrachten Sie diesmal MetricKit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MetricKit. Leistungsanalyse von iOS-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468347/"><img src="https://habrastorage.org/getpro/habr/post_images/362/bcb/a7d/362bcba7db30e427252ec3bf33b87042.jpg" alt="Bild"><br><br><h3>  Neues Spielzeug </h3><br>  Wir machen uns weiterhin mit neuem Material von Apple vertraut, das auf der WWDC vorgestellt wurde.  Betrachten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> diesmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MetricKit</a> , ein völlig neues Framework, das als Tool zur Überwachung der Anwendungsleistung dient. <br><a name="habracut"></a><br>  Jeder weiß, dass das Messen der Anwendungsleistung während der Entwicklung einfach ist.  Xcode zeigt die Menge des verwendeten Arbeitsspeichers und die Prozessorlast an. Sie können mithilfe von Instrumenten eine Verbindung zu einem zu testenden Simulator oder Gerät herstellen und sogar Ihre eigenen Tools schreiben (weitere Informationen finden Sie in unseren Artikeln zu benutzerdefinierten Toolpaketen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ).  Wenn Sie nur die Bedeutung der Leistungsoptimierung verstehen, können Sie nicht fast alles messen, was die Anwendung tut.  Wenn wir über den AppStore sprechen, wird es jedoch komplizierter, wenn die entwickelte Anwendung für echte Benutzer gedacht ist.  Unabhängig davon, wie sorgfältig Sie Ihre Anwendung testen, gibt es unter realen Bedingungen immer eine Reihe von Überraschungen, die sich auf die Leistung und das Benutzererlebnis auswirken.  Natürlich gibt es viele Tools zum Sammeln verschiedener Parameter, aber die meisten davon sind durch das <b>iOS SDK</b> sowie die Auswirkungen der tatsächlichen Überwachung auf das Anwendungsverhalten begrenzt. <br><br>  In diesem Jahr hat Apple beschlossen, diese Lücke zu schließen, und Entwicklern ein Tool zur Verfügung gestellt, mit dem sie Anwendungsleistungsmetriken in einer realen Umgebung erfassen und analysieren können.  Sie kündigten <b>MetricKit</b> (ein Framework, das Zugriff auf die vom Betriebssystem <b>bereitgestellten</b> Optionen bietet) einer separaten Registerkarte im Xcode 11-Organizer an, auf der Sie Anwendungseinstellungen finden.  Wir werden in MetricKit pausieren, da die Anzeige von Parametern in Xcode nur mit Anwendungen funktioniert, die bereits im AppStore veröffentlicht wurden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78a/64c/612/78a64c6124242358e3ceb0ab5b63fe88.png" alt="Bild"><br><br><h3>  MXMetricManager </h3><br>  Die Architektur des Frameworks ist recht einfach und unkompliziert.  Der zentrale Teil wird von der <b>MXMetricManager-</b> Klasse belegt, einer Einzelelementstruktur, die dem Entwickler eine große <b>Anzahl</b> von Framework-APIs zur Verfügung stellt. <br><br>  Im Allgemeinen besteht der Workflow aus drei Hauptschritten: <br><br><ol><li>  Sie initialisieren MXMetricMnager und weisen ihm einen Beobachter zu. </li><li>  Wenn Sie möchten, können Sie mithilfe der Signpost-API Ihre eigenen Metriken in Ihrer Anwendung implementieren </li><li>  Und schließlich beschäftigen wir uns jetzt mit den empfangenen Daten in der didReceivePayloads-Methode, d. H.  Senden Sie sie zur weiteren Analyse an Ihr Backend. </li></ol><br>  Parameter werden als Array von Instanzen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MXMetricPayload geliefert</a> .  Die Nutzdaten kapseln Metadatensätze und Zeitstempel.  Metric Payload ist ein einfacher Wrapper für die Unterklasse von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MXMetric</a> .  Für jeden Parametertyp ist er separat. <br><br>  Die Arten von Metriken sind von Apple ziemlich gut dokumentiert. Lassen Sie uns also nicht zu lange darauf eingehen.  Sie sollten jedoch aufhören, eine interessante Sache zu bemerken: MXMetric bietet eine offene API für die Serialisierung in NSDictionary oder JSON, was meiner Meinung nach etwas ungewöhnlich ist. <br><br><h3>  Interne Komponenten von MetricKit. </h3><br>  Draußen sieht MetricKit ziemlich einfach aus.  Aber es ist immer interessant zu sehen, wie alles von innen nach außen funktioniert.  Das Eintauchen in etwas Tieferes ist immer eine Intrige, wenn Sie vor einer bestimmten Aufgabe stehen.  Daher habe ich beschlossen, Parameter mit MetricKit-Tags zu übergeben und sie dann dazu zu bringen, mir jederzeit aktualisierte Metriken zur Verfügung zu stellen.  Natürlich können Sie in Xcode " <i>Debug -&gt; MetricKit Payloads simulieren" verwenden</i> , aber mit id können Sie Ihre eigenen Daten nicht anzeigen.  Das ist zwar kein sehr nützliches Team, aber es gibt dir die Richtung in deiner Forschung vor und es sieht sehr lustig aus;) <br><br>  Um die Aufgabe zu starten, benötigen wir natürlich MetricKit selbst.  Sie könnten denken, dass das Abrufen einer Binärdatei für das Framework einfach ist, da Xcode sie in der Liste der Frameworks anzeigt, sobald Sie sie über das Dialogfeld "Binärdatei mit Bibliotheken verknüpfen" hinzufügen.  Dies ist ein sehr optimistischer Gedanke.  Denn wenn Sie <b>MetricKit.framework</b> öffnen, wird die Datei <b>MetricKit.tbd angezeigt</b> .  Seine Größe beträgt nur <b>4kb</b> .  Offensichtlich ist dies nicht das, wonach wir suchen. <br><br>  Also, was ist hier wirklich los? <br><br>  <b>TBD</b> steht für "textbasierter Dylib-Stub" und ist eine YAML-Datei mit einer Dylib-Beschreibung, die Zeichen exportiert, und einem Pfad zur Dylib-Binärdatei.  Durch das Verknüpfen mit TBD-Dateien wird die Größe der Binärdatei verringert.  Später zur Laufzeit wird die echte Dylib-Binärdatei unter dem in der TBD-Datei angegebenen Pfad vom Betriebssystem heruntergeladen.  So sieht die Datei aus, wenn Sie sie in Xcode öffnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/047/3d2/e9e/0473d2e9e853e1c65632c2a1b2500b39.png" alt="Bild"><br><br>  Wenn Sie den Pfad aus der TBD-Datei verwenden, können Sie die MetricKit-Binärdatei problemlos für weitere Untersuchungen abrufen. Es gibt jedoch eine noch einfachere Methode. <br><br>  Unsere Anwendungsbinärdatei enthält den Pfad zu jeder dynamisch verknüpften Bibliothek im Abschnitt Mach-O-Header.  Diese Informationen können mit dem Tool unter Verwendung des Flags -l leicht abgerufen werden. <br><br>  Hier ist die Ausgabe für das von mir erstellte Testprojekt: <br><br><pre><code class="swift hljs">→ otool -l ./<span class="hljs-type"><span class="hljs-type">Metrics</span></span> | grep -i metrickit name /<span class="hljs-type"><span class="hljs-type">System</span></span>/<span class="hljs-type"><span class="hljs-type">Library</span></span>/<span class="hljs-type"><span class="hljs-type">Frameworks</span></span>/<span class="hljs-type"><span class="hljs-type">MetricKit</span></span>.framework/<span class="hljs-type"><span class="hljs-type">MetricKit</span></span> (offset <span class="hljs-number"><span class="hljs-number">24</span></span>)</code> </pre> <br>  Sie können den gleichen Pfad sehen, den wir zuvor in der tbd-Datei gesehen haben.  Mit einer binären Framework-Datei können Sie sich die internen Elemente ansehen.  Dafür benutze ich normalerweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hopper Disassemble</a> .  Es ist ein einfach zu bedienendes, aber sehr leistungsfähiges Tool zum sorgfältigen Studium von Binärdateien. <br><br>  Sobald die MetricKit-Binärdatei geöffnet wird, wechseln Sie zur Registerkarte "Proc."  und erweitern Sie die Liste 'Tags'.  Hier sehen Sie alle exportierten Zeichen.  Wenn Sie eine davon auswählen (z. B. MXMetricManager), werden alle Methoden angezeigt. Nachdem Sie eine Methode ausgewählt haben, wird deren Inhalt auf der rechten Seite angezeigt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/f17/71a/ac1f1771a4b061364d898d3c28f4564c.png" alt="Bild"><br><br>  Beim Anzeigen der MXMetricManager-Methodenliste [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://gist.github.com/deszip/88a258ae21d33dc75d7cbac9569c6ec1</a> ] fällt die Methode _checkAndDeliverMetricReports sehr leicht auf.  Dies scheint das zu sein, was aufgerufen werden muss, damit MetricKit den Abonnenten Updates liefert. <br><br>  Leider führte ein Versuch, ihn anzurufen, nicht zu einem Anruf beim Teilnehmer, was wahrscheinlich bedeutet, dass diese Parameter nicht zugestellt werden.  In Anbetracht der Implementierung der Methode stellen wir einige interessante Dinge fest: Sie listet den Inhalt des Verzeichnisses / Library / Caches / MetricKit / Reports auf. <br><br>  Anschließend versucht er, die MXMetricPayload-Instanz für jedes Element auf der Festplatte zu entpacken.  Und schließlich iteriert es über registrierte Abonnenten und ruft die didReceive-Methode mit einer Liste von Daten auf. <br><br>  Das Problem ist wahrscheinlich, dass sich keine Daten in <i>/ Library / Caches / MetricKit / Reports befinden</i> , aber wir wissen, dass wir einige archivierte Instanzen von MXMetricPayload benötigen.  Erstellen wir sie also und legen sie auf der Festplatte ab, bevor <i>wir</i> ' <i>_checkAndDeliverMetricReports</i> ' aufrufen.  Auch hier ist geplant, eine Instanz von MXMetricPayload zu erstellen, dann einen beliebigen Typ von MXMetric zu erstellen und hinzuzufügen und die Dateninstanz dann auf der Festplatte zu archivieren.  <i>Rufen Sie schließlich</i> die Methode ' <i>_checkAndDeliverMetricReports</i> ' auf. Dies sollte dazu führen, dass Sie unseren Abonnenten mit stub als Argument aufrufen. <br><br>  Wenn Sie sich die Apple-Dokumente zu Nutzdaten und Metriken ansehen, werden Sie möglicherweise feststellen, dass sie keine öffentlichen Initialisierer haben und die meisten Eigenschaften schreibgeschützt sind.  Wie ist es also möglich, eine Klasse zu instanziieren? <br><br>  <b>Kehren Sie</b> erneut zu Hopper zurück, um eine Liste der <b>MXMetricPayload-</b> Methoden <b>anzuzeigen</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d6/e2a/12c/3d6e2a12c6d296f9f88f811068b4762d.png" alt="Bild"><br><br>  Hier sehen Sie die Initialisierer und Methoden zum Zuweisen von Parametern.  Das Aufrufen privater Methoden ist mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NSInvocation-</a> Klasse und der 'performSelector'-Methode aufgrund der Dynamik von Objective-C einfach. <br><br>  Als Beispiel erstellen wir Metriken für die CPU und fügen sie der Nutzlast hinzu.  Über diesen Link finden Sie das vollständige Codefragment: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://gist.github.com/deszip/a0cf877b07cc2877129e0aaef2fed1e4</a> ]. <br><br>  Und schließlich archivieren wir alles, was wir erstellt haben, und schreiben die Daten in das <i>Verzeichnis / Library / Caches / MetricKit / Reports</i> . <br><br>  Jetzt ist es Zeit, die Methode ' <i>_checkAndDeliverMetricReports</i> ' <i>aufzurufen</i> , die schließlich zu einem Anruf beim Abonnenten führen sollte.  Dieses Mal übergeben wir die Daten mit gestoppelter Nutzlast als Argument als Argument. <br><br><h3>  Woher kommen die Metriken? </h3><br>  Das <b>Abrufen von</b> Berichten ist über <b>MetricKit</b> recht einfach zu implementieren, aber Sie <b>möchten</b> wahrscheinlich erfahren, wie Berichte im Verzeichnis <i>app / Library</i> <b>angezeigt werden</b> .  So. <br><br>  Beim Durchsuchen der MetricKit-Binärdatei fiel mir diese Methode auf: '_createXPCConnection'.  Durch die Überprüfung der Implementierung wird die Situation verdeutlicht: Es wird eine NSXPCConnection for Service mit dem Namen <i>com.apple.metrickit.xpc</i> und zwei Schnittstellen <b>MXXPCServer</b> und <b>MXXPCClient</b> für die Client- und Serverseite erstellt.  Wenn Sie sich die Protokollbeschreibung ansehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/6ac/fe4/0ae6acfe4f83220d86aa7e61b9690cf5.png" alt="Bild"><br><br><h3>  Fazit </h3><br>  <b>MetricKit</b> ist ein einzigartiges und unverzichtbares Werkzeug, um die Leistung Ihrer Anwendung unter realen Produktionsbedingungen zu <b>gewährleisten</b> . <br><br>  Leider ist es derzeit nicht möglich, einen Blick auf die 'Metric'-Benutzeroberfläche in Xcode zu werfen, außer auf das, was während einer Demo in einer WWDC-Sitzung gezeigt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b9/2ec/8af/8b92ec8aff5e8566f00506333e0e4206.png" alt="Bild"><br><br>  Es kann ein unschätzbares Werkzeug sein, um die Benutzererfahrung auf die nächste Stufe zu heben, indem Leistungsprobleme in Ihrem Code beseitigt werden. <br><br>  Ein Nachteil, den ich jetzt in diesem Tool sehe, ist das Fehlen von Details für jeden Typ: Nur die Trennung ist die Version der Anwendung, und Sie können keine Metriken für eine bestimmte Gruppe von Geräten / Betriebssystemversionen / Regionen usw. sehen. <br><br>  Natürlich besteht immer die Möglichkeit, Daten zur weiteren Verarbeitung zusammen mit wichtigen Informationen, die Sie benötigen, an sich selbst zu senden.  Sie können es an Aufgaben in Ihrem Bug-Tracker und mehr anhängen.  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppSpector arbeitet</a> unser Team daran, die Funktionalität von Leistungsüberwachungstools mithilfe von Daten aus <b>MetricKit zu erweitern</b> . <br><br>  Bleiben Sie auf dem Laufenden! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468347/">https://habr.com/ru/post/de468347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468337/index.html">Arbeiten mit cron für Android und Hinzufügen eines Shell-Skripts zum automatischen Ausführen, wenn das Gerät gestartet wird</a></li>
<li><a href="../de468339/index.html">Einführung in das Dark Theme für Visual Studio App Center</a></li>
<li><a href="../de468341/index.html">Azure Cloud Shell auf dem Windows-Terminal</a></li>
<li><a href="../de468343/index.html">Jeff Bezos: "Zum Wohl der Erde in den Weltraum gehen"</a></li>
<li><a href="../de468345/index.html">GitHub startet seine Tentakel im CI / CD- und Artefaktmanagement</a></li>
<li><a href="../de468351/index.html">Marktmikrostruktur und negative Selektion</a></li>
<li><a href="../de468363/index.html">Mein Magnum Opus aus der Welt des Mobile Gaming</a></li>
<li><a href="../de468367/index.html">Amazon kündigt Plan zur globalen Erwärmung an</a></li>
<li><a href="../de468369/index.html">Wie ich „WildMAN“ erstellt habe - eine Parodie auf viele 8-Bit-Spiele und sie kürzlich auf Android portiert habe</a></li>
<li><a href="../de468371/index.html">Spieldesign zum Leben erwecken. Nahtloser Download oder vollständiges Eintauchen in God of War 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>