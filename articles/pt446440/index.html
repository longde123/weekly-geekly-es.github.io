<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤩 👂🏽 ✍🏽 O livro Reage Rápido. Aplicações Web em React, JSX, Redux e GraphQL » ◾️ 👰 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! A edição original foi lançada no outono de 2017, mas ainda é considerado o melhor livro para explorar o React. O autor está constant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro Reage Rápido. Aplicações Web em React, JSX, Redux e GraphQL »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/446440/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/za/bm/rw/zabmrwn_latmfqhxzpog6svpeoe.jpeg" align="left" alt="imagem"></a>  Oi, habrozhiteli!  A edição original foi lançada no outono de 2017, mas ainda é considerado o melhor livro para explorar o React.  O autor está constantemente atualizando e modificando o código do livro no repositório do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> . <br><br>  Em um post, sugerimos que você se familiarize com a passagem "Estados e seu papel na natureza interativa do React" <br><br>  Se você tivesse que ler apenas um capítulo deste livro, deveria escolher este!  Sem estados, os componentes do React permanecem apenas em padrões estáticos avançados.  Espero que você compartilhe meu entusiasmo, porque a compreensão dos conceitos deste capítulo permitirá que você construa aplicativos muito mais interessantes. <br><br><a name="habracut"></a><br>  Imagine que você está construindo um campo de entrada com preenchimento automático (Fig. 4.1).  Ao inserir dados, o campo deve emitir uma solicitação ao servidor para obter informações sobre as opções adequadas para exibir a saída em uma página da web.  Você trabalhou com propriedades até agora e sabe que alterar propriedades permite obter visualizações diferentes.  No entanto, as propriedades não podem ser alteradas no contexto do componente atual, porque são transmitidas quando o componente é criado. <br><br><img src="https://habrastorage.org/webt/hv/b_/s0/hvb_s0fbckd7lprixqyfldxeyao.png" align="left" alt="imagem">  Em outras palavras, as propriedades são imutáveis ​​no componente atual, o que significa que você não pode alterar as propriedades desse componente, a menos que recrie o componente e transfira novos valores do pai (Fig. 4.2).  Mas as informações recebidas do servidor precisam ser armazenadas em algum lugar e, em seguida, uma nova lista de opções deve ser exibida na exibição.  Como atualizar a exibição se as propriedades não podem ser alteradas? <br><br>  Uma solução possível é renderizar um elemento com novas propriedades sempre que você receber uma nova resposta do servidor.  Mas então você deve colocar a lógica fora do componente - e o componente deixa de ser auto-suficiente.  Obviamente, se os valores das propriedades não puderem ser alterados e o preenchimento automático for auto-suficiente, é impossível usar propriedades.  Em seguida, surge a pergunta: como atualizar visualizações em resposta a eventos sem recriar o componente (createElement () ou JSX &lt;NAME /&gt;)?  É esse problema que os estados resolvem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rh/2n/rm/rh2nrmgxmoggbssmhcytpnqlwmk.png" alt="imagem"></div><br>  Depois que a resposta do servidor estiver pronta, o código de retorno de chamada mudará o estado do componente de acordo.  Você terá que escrever esse código você mesmo.  No entanto, após a atualização do estado, o React atualizará automaticamente a visualização para você (apenas nos locais em que deve ser atualizado, ou seja, onde os dados do estado são usados). <br><br>  Com o estado dos componentes do React, é possível criar aplicativos React interativos e significativos.  Estado é um conceito fundamental que permite criar componentes do React que podem armazenar dados e atualizar automaticamente as visualizações de acordo com as alterações nos dados. <br><br><h3>  Qual é o estado do componente React? </h3><br>  O estado React é um armazenamento de dados de componente mutável - blocos orientados a função independentes da interface e lógica do usuário.  "Variabilidade" significa que os valores dos estados podem mudar.  Usando o estado na vista (render ()) e alterando os valores posteriormente, você pode influenciar a aparência da vista. <br><br>  Metáfora: se você imaginar um componente como uma função, para a entrada de quais propriedades e estado são transferidos, o resultado da função será uma descrição da interface do usuário (apresentação).  Propriedades e estados expandem as visualizações, mas são usadas para diferentes propósitos (consulte a seção 4.3). <br><br>  Ao trabalhar com estados, você os acessa pelo nome.  O nome é um atributo (ou seja, uma chave de objeto ou uma propriedade de objeto - não uma propriedade de componente) deste objeto state.state, por exemplo this.state.autocompleMatches ou this.state.inputFieldValue. <br><br>  Os dados de estado geralmente são usados ​​para exibir informações dinâmicas em uma exibição para estender a renderização de exibições.  Retornando a um exemplo anterior de um campo de preenchimento automático: o estado muda em resposta a uma solicitação XHR para o servidor, que, por sua vez, é iniciado inserindo dados no campo.  React garante que as visualizações sejam atualizadas quando o estado usado nas visualizações for alterado.  De fato, quando um estado muda, apenas as partes correspondentes das representações mudam (para elementos individuais e até mesmo os valores de atributo de um elemento individual). <br><br>  Tudo o resto no DOM permanece inalterado.  Isso é possível graças ao modelo DOM virtual (consulte a seção 1.1.1), que o React usa para determinar o delta (totalidade das alterações) durante o processo de reconciliação.  Esse fato permite escrever código em um estilo declarativo.  React faz toda a rotina para você.  Os principais estágios da alteração da apresentação são discutidos no Capítulo 5. <br><br>  Os desenvolvedores de reação usam estados para gerar novas interfaces de usuário.  As propriedades do componente (this.props), variáveis ​​comuns (inputValue) e atributos de classe (this.inputValue) não são adequadas para isso, porque a alteração de seus valores (no contexto do componente atual) não inicia uma alteração na exibição.  Por exemplo, o seguinte snippet é antipadrão, o que mostra que alterar o valor em qualquer lugar, exceto no estado, não fará com que a exibição seja atualizada: <br><br><pre><code class="plaintext hljs">// :   ! let inputValue = 'Texas' class Autocomplete extends React.Component { updateValues() ← {      ( ) this.props.inputValue = 'California' inputValue = 'California' this.inputValue = 'California' } render() { return ( &lt;div&gt; {this.props.inputValue} {inputValue} {this.inputValue} &lt;/div&gt; ) } }</code> </pre> <br>  Agora vamos ver como trabalhar com os estados dos componentes do React. <br><br><h3>  Trabalhar com estados </h3><br>  Para trabalhar com estados, você deve poder acessar valores, atualizá-los e definir valores iniciais.  Vamos começar consultando os estados nos componentes React. <br><br><h3>  Acesso aos estados </h3><br>  O objeto de estado é um atributo do componente e você deve acessá-lo através deste link, por exemplo, this.state.name.  Como você se lembra, as variáveis ​​podem ser acessadas e exibidas no código JSX entre chaves ({}).  Da mesma forma, em render (), você pode renderizar this.state (como qualquer outra variável ou atributo de classe de um componente não padrão), por exemplo {this.state.inputFieldValue}.  Essa sintaxe é semelhante à sintaxe para acessar propriedades em this.props.name. <br><br><img src="https://habrastorage.org/webt/ei/wy/cj/eiwycjaglq1319bi377c13zyat8.png" align="left" alt="imagem">  Usamos o que você aprendeu para implementar o relógio na fig.  4.3  Nosso objetivo é criar uma classe de componente autônoma que qualquer pessoa possa importar e usar em seu aplicativo sem muito aborrecimento.  O relógio deve exibir a hora atual. <br><br>  O projeto tem a seguinte estrutura: <br><br><pre> <code class="plaintext hljs">/clock index.html /jsx script.jsx clock.jsx /js script.js clock.js react.js react-dom.js</code> </pre> <br>  Eu uso a CLI Babel com sinalizadores de rastreamento (-w) e diretório (-d) para compilar todos os arquivos de origem JSX de clock / jsx para a pasta clock / js de destino e recompilar quando alterações são detectadas.  Além disso, salvei o comando como um script npm no arquivo package.json da pasta pai ch04 para executar o comando npm run build-clock a partir de ch04: <br><br><pre> <code class="plaintext hljs">"scripts": { "build-clock": "./node_modules/.bin/babel clock/jsx -d clock/js -w" },</code> </pre> <br>  Obviamente, o tempo não pára (gostemos ou não).  Por esse motivo, você precisa atualizar constantemente a exibição e, para isso, pode usar o estado.  Nomeie-o como currentTime e tente renderizar o estado, como mostra a Listagem 4.1. <br><br>  Listagem 4.1.  Renderização de estado JSX <br><br><pre> <code class="plaintext hljs">class Clock extends React.Component { render() { return &lt;div&gt;{this.state.currentTime}&lt;/div&gt; } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById('content') )</code> </pre> <br>  Você receberá uma mensagem de erro: TypeError não capturado: Não é possível ler a propriedade 'currentTime' de null.  Normalmente, as mensagens de erro do JavaScript têm os mesmos benefícios que um copo de água fria para uma pessoa que está se afogando.  É bom que, pelo menos nesse caso, o JavaScript exiba uma mensagem significativa. <br><br>  A mensagem indica que o valor de currentTime é indefinido.  Diferentemente das propriedades, os estados não são definidos no pai.  Chamar setState em render () também falha, porque criará um loop (setState -&gt; render -&gt; setState ...) - e o React reportará um erro. <br><br><h3>  Atribuição do estado inicial </h3><br>  Você já viu que antes de usar os dados do estado em render (), você deve inicializar o estado.  Para definir o estado inicial, use this.state no construtor com a sintaxe da classe ES6 React.Component.  Lembre-se de chamar super () com propriedades;  caso contrário, a lógica no pai (React.Component) não funcionará: <br><br><pre> <code class="plaintext hljs">class MyFancyComponent extends React.Component { constructor(props) { super(props) this.state = {...} } render() { ... } }</code> </pre> <br>  Ao atribuir o estado inicial, você também pode adicionar outra lógica - por exemplo, defina o valor de currentTime usando a nova Data ().  Você também pode usar toLocaleString () para obter o formato de data / hora correto para o local atual do usuário, conforme mostrado abaixo (ch04 / relógio). <br><br>  Listagem 4.2.  Construtor do componente Clock <br><br><pre> <code class="plaintext hljs">class Clock extends React.Component { constructor(props) { super(props) this.state = {currentTime: (new Date()).toLocaleString()} } ... }</code> </pre> <br>  O valor this.state deve ser um objeto.  Não entraremos em detalhes do constructor () do ES6;  consulte o Apêndice D e o Resumo do ES6 em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/azat-co/cheatsheets/tree/master/es6</a> .  A linha inferior é que, como em outras linguagens OOP, um construtor (ou seja, construtor ()) é chamado quando uma instância da classe é criada.  O nome do método construtor deve ser exatamente isso;  considere esta uma das regras do ES6.  Além disso, ao criar o método constructor (), a chamada super () quase sempre deve ser incluída nele, sem a qual o construtor do pai não seria executado.  Por outro lado, se você não definir o método constructor (), a chamada para super () será assumida por padrão. <br><br>  O nome currentTime é opcional;  você deve usar o mesmo nome posteriormente ao ler e atualizar esse estado. <br><br>  O objeto de estado pode conter objetos ou matrizes aninhados.  O exemplo a seguir adiciona uma matriz de descrições de livros ao estado: <br><br><pre> <code class="plaintext hljs">class Content extends React.Component { constructor(props) { super(props) this.state = { githubName: 'azat-co', books: [ 'pro express.js', 'practical node.js', 'rapid prototyping with js' ] } } render() { ... } }</code> </pre> <br>  O método constructor () é chamado apenas uma vez, ao criar um elemento React com base na classe.  Portanto, você pode definir o estado diretamente usando this.state apenas uma vez - no método constructor ().  Não configure ou atualize o estado diretamente com this.state = ... em outro lugar, pois isso pode levar a conseqüências imprevistas. <br><br>  Então você obtém apenas o valor inicial, que rapidamente se tornará obsoleto - em apenas 1 segundo.  Quem precisa de um relógio que não mostre a hora atual?  Felizmente, existe um mecanismo para atualizar o estado atual. <br><br><h3>  Atualização de status </h3><br>  O estado é alterado pelo método da classe this.setState (data, callback).  Quando esse método é chamado, o React combina os dados com os estados atuais e chama render (), após o qual chama retorno de chamada. <br><br>  Definir um retorno de chamada em setState () é importante porque o método funciona de forma assíncrona.  Se o aplicativo depender do novo estado, você poderá usar esse retorno de chamada para garantir que o novo estado esteja disponível. <br><br>  Se você simplesmente presumir que o estado foi atualizado sem aguardar a conclusão de setState (), ou seja, trabalhar de forma síncrona ao executar uma operação assíncrona, poderá ocorrer um erro: o programa depende da atualização dos valores do estado, mas o estado permanece antigo. <br>  Até agora, geramos tempo do estado.  Você já sabe como definir o estado inicial, mas deve ser atualizado a cada segundo, certo?  Para fazer isso, use a função de timer do navegador setInterval () (http://mng.bz/P2d6), que atualizará o estado a cada n milissegundos.  O método setInterval () é implementado em quase todos os navegadores modernos como global, o que significa que pode ser usado sem bibliotecas ou prefixos adicionais.  Um exemplo: <br><br><pre> <code class="plaintext hljs">setInterval(()=&gt;{ console.log('Updating time...') this.setState({ currentTime: (new Date()).toLocaleString() }) }, 1000)</code> </pre> <br>  Para iniciar a contagem regressiva, você precisa chamar setInterval () apenas uma vez.  Criamos o método launchClock () exclusivamente para esse fim;  launchClock () será chamado no construtor.  A versão final do componente é mostrada na Listagem 4.3 (ch04 / clock / jsx / clock.jsx). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wk/uz/ez/wkuzezejgvya-npm71161pn-_aa.png" alt="imagem"></div><br>  O método setState () pode ser chamado em qualquer lugar, não apenas no método launchClock () (que é chamado no construtor), como no exemplo.  Normalmente, o método setState () é chamado de um manipulador de eventos ou como um retorno de chamada quando os dados são recebidos ou atualizados. <br><br><blockquote>  DICA Uma tentativa de alterar o estado no código com um comando no formato this.state.name = 'novo nome' não levará a nada.  Não levará à renderização e atualização do modelo DOM real, do que você gostaria.  Na maioria dos casos, uma alteração direta de estado sem setState () é antipadrão e deve ser evitada. </blockquote><br>  É importante observar que o método setState () atualiza apenas os estados que foram passados ​​para ele (parcialmente ou mesclados, mas sem uma substituição completa).  Ele não substitui o objeto de estado inteiro toda vez.  Portanto, se apenas um dos três estados for alterado, os outros dois permanecerão inalterados.  No exemplo a seguir, userEmail e userId não serão alterados: <br><br><pre> <code class="plaintext hljs">constructor(props) { super(props) this.state = { userName: 'Azat Mardan', userEmail: 'hi@azat.co', userId: 3967 } } updateValues() { this.setState({userName: 'Azat'}) }</code> </pre> <br>  Se você pretende atualizar todos os três estados, precisará fazer isso explicitamente passando os novos valores desses estados para setState ().  (Também no código antigo, que agora não funciona mais, o método this.replaceState () às vezes é encontrado; é oficialmente descontinuado1. Como você pode imaginar pelo nome, substituiu todo o objeto de estado por todos os seus atributos. <br><br>  Lembre-se de que chamar setState () inicia a execução de render ().  Na maioria dos casos, funciona.  Em alguns casos especiais em que o código depende de dados externos, você pode iniciar uma nova renderização chamando this.forceUpdate ().  No entanto, essas decisões são indesejáveis, porque depender de dados externos (em vez de estado) torna os componentes menos confiáveis ​​e dependentes de fatores externos (ligação restrita). <br><br>  Como mencionado anteriormente, o objeto state pode ser acessado na entrada this.state.  No JSX, os valores de saída são colocados entre chaves ({}), portanto, para declarar uma propriedade state em uma visualização (ou seja, no comando de retorno do método render), use a notação {this.state.NAME}. <br><br>  A magia de reação ocorre quando você usa dados de estado em uma exibição (por exemplo, na saída, em um comando if / else, como um valor de atributo ou valor de propriedade de um filho) e depois passa novos valores para setState ().  Bah!  O React atualiza toda a marcação HTML necessária para você.  Você pode verificar isso no console do DevTools, onde os ciclos "Atualizando ..." e "Renderizando ..." devem ser exibidos.  E o melhor é que isso afetará apenas os elementos DOM mínimos absolutos necessários. <br><br>  »Mais informações sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Cupom de desconto de 20% para vendedores ambulantes - <b>reagir</b> <br><br>  Após o pagamento da versão em papel do livro, uma versão eletrônica do livro é enviada por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446440/">https://habr.com/ru/post/pt446440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446430/index.html">Arrefecimento de uma nanopartícula levitante por meio de um ressonador óptico</a></li>
<li><a href="../pt446432/index.html">Um seminário sobre gerenciamento de documentos técnicos foi realizado na Crimeia</a></li>
<li><a href="../pt446434/index.html">Escala do Zimbra Collaboration Suite</a></li>
<li><a href="../pt446436/index.html">Como gerar hipóteses sobre as necessidades de potenciais consumidores do seu futuro produto</a></li>
<li><a href="../pt446438/index.html">Nossa experiência de criação de API de gateway</a></li>
<li><a href="../pt446444/index.html">Do Skype ao WebRTC: Como organizamos a comunicação por vídeo na Web</a></li>
<li><a href="../pt446446/index.html">Noções básicas do mecanismo JavaScript: formulários gerais e cache embutido. Parte 1</a></li>
<li><a href="../pt446448/index.html">5 regras básicas para a realização de entrevistas com problemas para identificar as necessidades do consumidor</a></li>
<li><a href="../pt446452/index.html">Missão lunar “Bereshit” - em 4 de abril de 2019, a transição para a órbita lunar está concluída, 7 dias de voo, 6 manobras e 1 pouso</a></li>
<li><a href="../pt446454/index.html">Desenvolvimento de servidor Web Golang - do fácil ao complexo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>