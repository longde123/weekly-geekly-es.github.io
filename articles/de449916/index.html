<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁷󠁬󠁳󠁿 🅰️ 🌕 5 Möglichkeiten, PHP-Code unter Hochlastbedingungen bereitzustellen 👨🏿‍🍳 💙 👩🏻‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Highroad in der Schule unterrichtet würde, hätte das Lehrbuch zu diesem Thema eine solche Aufgabe. „Das soziale Netzwerk N verfügt über 2.000 Ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Möglichkeiten, PHP-Code unter Hochlastbedingungen bereitzustellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449916/">  Wenn Highroad in der Schule unterrichtet würde, hätte das Lehrbuch zu diesem Thema eine solche Aufgabe.  „Das soziale Netzwerk N verfügt über 2.000 Server, auf denen 150.000 Dateien mit jeweils 900 MB PHP-Code und ein Staging-Cluster für 50 Computer gespeichert sind.  Der Code wird zweimal täglich auf den Servern bereitgestellt, im Staging-Cluster wird der Code alle paar Minuten aktualisiert, und es gibt zusätzliche „Hotfixes“ - kleine Dateigruppen, die nicht auf allen oder auf dem ausgewählten Teil der Server angeordnet sind, ohne auf die vollständige Berechnung zu warten.  Frage: Werden solche Bedingungen als Hochlast betrachtet und wie werden sie bereitgestellt?  Schreiben Sie mindestens 5 Bereitstellungsoptionen. “  Wir können nur vom Hyload-Problembuch träumen, aber jetzt wissen wir bereits, dass <strong>Yuri Nasretdinov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">youROCK</a> ) dieses Problem definitiv lösen und die „Fünf“ bekommen würde. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qMu4YHJV1Z8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yuri hielt nicht bei einer einfachen Lösung an, sondern erstellte zusätzlich einen Bericht, in dem er das Konzept des „Code Deployment“ -Konzepts enthüllte, über klassische und alternative Lösungen für umfangreiche PHP-Bereitstellungen sprach, deren Leistung analysierte und das MDK-Bereitstellungssystem vorstellte. <br><a name="habracut"></a><br><h2>  Das Konzept des "Bereitstellen von Code" </h2><br>  Auf Englisch bedeutet der Begriff „Einsatz“, die Truppen in Alarmbereitschaft zu versetzen, und auf Russisch sagen wir manchmal „Füllen Sie den Code in den Kampf“, was dasselbe bedeutet.  Sie nehmen den Code in der bereits kompilierten Form oder im Original, wenn es sich um PHP handelt, laden ihn auf die Server hoch, die den Benutzerverkehr bedienen, und wechseln dann auf magische Weise die Last von einer Version des Codes zu einer anderen.  All dies ist im Konzept der „Code-Bereitstellung“ enthalten. <br><br>  Der Bereitstellungsprozess besteht normalerweise aus mehreren Phasen. <br><br><ul><li>  <strong>Abrufen des Codes aus dem Repository</strong> auf eine beliebige Weise: Klonen, Abrufen, Auschecken. </li><li> <strong>Montage - bauen</strong> .  Bei PHP-Code fehlt möglicherweise die Erstellungsphase.  In unserem Fall handelt es sich in der Regel um die automatische Generierung von Übersetzungsdateien, das Hochladen statischer Dateien auf CDN und einige andere Vorgänge. </li><li>  <strong>Lieferung an Endserver</strong> - Bereitstellung. </li></ul><br>  Nachdem alles zusammengestellt ist, beginnt die Phase der sofortigen Bereitstellung - der <strong>Code</strong> wird <strong>auf Produktionsserver übertragen</strong> .  Über diese Phase wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo</a> diskutiert. <br><br><h2>  Altes Bereitstellungssystem in Badoo </h2><br>  Wenn Sie eine Datei mit einem Dateisystem-Image haben, wie können Sie diese dann bereitstellen?  Unter Linux müssen Sie <strong>ein Zwischenschleifengerät</strong> erstellen, eine Datei anhängen und danach kann dieses Blockgerät bereits gemountet werden. <br><br>  Ein Loop-Gerät ist eine Krücke, die Linux benötigt, um ein Dateisystem-Image bereitzustellen.  Es gibt Betriebssysteme, in denen diese Krücke nicht benötigt wird. <br><br><img src="https://habrastorage.org/webt/gd/ch/h6/gdchh68qpl5ikkpddsvxzwcwvlm.png"><br><br>  Wie verwendet der Bereitstellungsprozess Dateien, die wir der Einfachheit halber auch als "Schleifen" bezeichnen?  Es gibt ein Verzeichnis, in dem sich der Quellcode und der automatisch generierte Inhalt befinden.  Wir machen ein leeres Bild des Dateisystems - jetzt ist es EXT2, und früher haben wir ReiserFS verwendet.  Wir mounten ein leeres Image des Dateisystems in einem temporären Verzeichnis und kopieren dort den gesamten Inhalt.  Wenn wir nichts brauchen, um in Produktion zu gehen, kopieren wir nicht alles.  Hängen Sie danach das Gerät aus und rufen Sie das Image des Dateisystems ab, in dem sich die erforderlichen Dateien befinden.  Als nächstes <strong>archivieren</strong> wir <strong>das Image und laden es auf alle Server</strong> hoch. Dort entpacken und mounten wir es. <br><br><h2>  Andere bestehende Lösungen </h2><br>  Zunächst möchten wir uns bei <strong>Richard Stallman</strong> bedanken - ohne seine Lizenz hätten die meisten von uns verwendeten Dienstprogramme nicht existiert. <br><br><img src="https://habrastorage.org/webt/8h/oa/yh/8hoayhyyicam7izl-q7egj8bitq.png"><br><br>  Herkömmlicherweise habe ich die Methoden zum Bereitstellen von PHP-Code in vier Kategorien unterteilt. <br><br><ul><li>  <strong>Basierend auf dem Versionskontrollsystem</strong> : svn up, git pull, hg up. </li><li>  <strong>Basierend auf dem Dienstprogramm rsync</strong> - in ein neues Verzeichnis oder "oben". </li><li>  <strong>Stellen Sie eine Datei</strong> bereit - egal was passiert: phar, hhbc, loop. </li><li>  Die spezielle Methode, die <strong>Rasmus Lerdorf</strong> vorgeschlagen hat, ist <strong>rsync, 2 Verzeichnisse und realpath_root</strong> . </li></ul><br>  Jede Methode hat sowohl Vor- als auch Nachteile, weshalb wir sie aufgegeben haben.  Betrachten Sie diese 4 Methoden genauer. <br><br><h3>  Bereitstellung basierend auf dem Versionskontrollsystem von svn up </h3><br>  Ich habe SVN nicht zufällig gewählt - nach meinen Beobachtungen besteht der Einsatz in dieser Form genau im Fall von SVN.  Das System ist recht <strong>leicht</strong> und ermöglicht <strong>eine schnelle und einfache</strong> Bereitstellung. Führen Sie einfach svn up aus, und schon sind Sie fertig. <br><br>  Diese Methode hat jedoch ein großes Minus: Wenn Sie svn up ausführen und beim Aktualisieren des Quellcodes neue Anforderungen aus dem Repository eingehen, wird der Status des Dateisystems angezeigt, das im Repository nicht vorhanden war.  Sie haben einen Teil der Dateien neu und einen Teil der alten - dies ist eine <strong>nicht atomare Bereitstellungsmethode,</strong> die nicht für hohe Auslastung geeignet ist, sondern nur für kleine Projekte.  Trotzdem kenne ich Projekte, die immer noch auf diese Weise bereitgestellt werden, und bis jetzt funktioniert alles für sie. <br><br><h3>  Bereitstellung basierend auf dem Dienstprogramm rsync </h3><br>  Hierfür gibt es zwei Möglichkeiten: Hochladen von Dateien mit dem Dienstprogramm direkt auf den Server und Hochladen von "oben" - Update. <br><br><h4>  rsync in ein neues Verzeichnis </h4><br>  Da Sie zuerst den gesamten Code vollständig in ein Verzeichnis gießen, das noch nicht auf dem Server vorhanden ist, und erst dann den Datenverkehr wechseln, ist diese Methode <strong>atomar</strong> - niemand sieht einen Zwischenzustand.  In unserem Fall führt das Erstellen von 150.000 Dateien und das Löschen des alten Verzeichnisses mit 150.000 Dateien zu einer <strong>großen Belastung des Festplattensubsystems</strong> .  Wir verwenden Festplatten sehr aktiv, und der Server fühlt sich nach einer solchen Operation für eine Minute nicht gut an.  Da wir 2000 Server haben, müssen 900 MB 2000 Mal ausgefüllt werden. <br><br>  Dieses Schema kann verbessert werden, wenn Sie zuerst eine bestimmte Anzahl von Zwischenservern hochladen, z. B. 50, und diese dann dem Rest hinzufügen.  Dies löst mögliche Probleme mit dem Netzwerk, aber das Problem des Erstellens und Löschens einer großen Anzahl von Dateien verschwindet nirgendwo. <br><br><img src="https://habrastorage.org/webt/wj/c9/pt/wjc9ptyfin79_dn6jmnornudzt8.png"><br><br><h4>  rsync oben </h4><br>  Wenn Sie rsync verwendet haben, wissen Sie, dass dieses Dienstprogramm nicht nur ganze Verzeichnisse füllen, sondern auch vorhandene aktualisieren kann.  Nur Änderungen zu senden ist ein Plus, aber da wir die Änderungen in dasselbe Verzeichnis hochladen, in dem wir den Kampfcode bereitstellen, wird es auch eine Art Zwischenzustand geben - dies ist ein Minus. <br><br>  Das Einreichen von Änderungen funktioniert folgendermaßen.  Rsync erstellt Listen von Dateien auf der Serverseite, von der aus die Bereitstellung ausgeführt wird, und auf der Empfangsseite.  Danach zählt es stat aus allen Dateien und sendet die gesamte Liste an die empfangende Seite.  Auf dem Server, von dem aus die Bereitstellung ausgeführt wird, wird der Unterschied zwischen diesen Werten berücksichtigt und festgelegt, welche Dateien gesendet werden sollen. <br><br>  Unter unseren Bedingungen benötigt dieser Prozess etwa <strong>3 MB Datenverkehr und 1 Sekunde Prozessorzeit</strong> .  Es scheint, dass dies nicht viel ist, aber wir haben 2.000 Server, und alles hat mindestens eine Minute Prozessorzeit.  Dies ist keine so schnelle Methode, aber definitiv besser, als das Ganze über rsync zu senden.  Es bleibt irgendwie das Problem der Atomizität zu lösen und wird fast perfekt sein. <br><br><h3>  Stellen Sie eine Datei bereit </h3><br>  Unabhängig davon, welche einzelne Datei Sie hochladen, ist die Verwendung von BitTorrent oder des UFTP-Dienstprogramms relativ einfach.  Eine Datei ist einfacher zu entpacken, kann unter Unix atomar ersetzt werden und es ist einfach, die Integrität der auf dem Buildserver generierten und an die Zielcomputer gelieferten Datei zu überprüfen, indem die MD5- oder SHA-1-Beträge aus der Datei berechnet werden (im Fall von rsync wissen Sie nicht, was sich auf den Zielservern befindet ) <br><br>  Bei Festplatten ist die sequentielle Aufzeichnung ein großes Plus - eine 900-MB-Datei wird in etwa 10 Sekunden auf eine nicht belegte Festplatte geschrieben.  Trotzdem müssen Sie dieselben 900 MB aufzeichnen und über das Netzwerk übertragen. <br><br><h4>  Lyrischer Exkurs über UFTP </h4><br>  Dieses Open Source-Dienstprogramm wurde ursprünglich erstellt, um Dateien über ein Netzwerk mit langen Verzögerungen zu übertragen, z. B. über ein satellitengestütztes Netzwerk.  UFTP erwies sich jedoch als geeignet zum Hochladen von Dateien auf eine große Anzahl von Computern, da es mit dem auf Multicast basierenden UDP-Protokoll funktioniert.  Eine Multicast-Adresse wird erstellt, alle Computer, die die Datei empfangen möchten, abonnieren sie, und die Switches ermöglichen die Zustellung von Kopien von Paketen an jeden Computer.  Wir verlagern also die Last der Datenübertragung an das Netzwerk.  Wenn Ihr Netzwerk damit umgehen kann, funktioniert diese Methode viel besser als BitTorrent. <br><br>  Sie können dieses Open Source-Dienstprogramm in Ihrem Cluster ausprobieren.  Trotz der Tatsache, dass es über UDP funktioniert, verfügt es über einen NACK-Mechanismus - eine negative Bestätigung, die die Weiterleitung von Paketen erzwingt, die bei der Zustellung verloren gehen.  <strong>Dies ist eine zuverlässige Methode zur Bereitstellung</strong> . <br><br><h4>  Optionen für die Bereitstellung einzelner Dateien </h4><br>  <strong>tar.gz</strong> <br><br>  Eine Option, die die Nachteile beider Ansätze kombiniert.  Sie müssen nicht nur nacheinander 900 MB auf die Festplatte schreiben, sondern danach die gleichen 900 MB durch zufälliges Lesen und Schreiben erneut schreiben und 150.000 Dateien erstellen.  Diese Methode hat eine noch schlechtere Leistung als rsync. <br><br>  <strong>phar</strong> <br><br>  PHP unterstützt Archive im Phar-Format (PHP-Archiv), weiß, wie man deren Inhalte angibt und Dateien einschließt.  Aber nicht alle Projekte lassen sich einfach in einem Phar zusammenfassen - Sie müssen den Code anpassen.  Nur weil der Code aus diesem Archiv nicht funktioniert.  Außerdem können Sie nicht eine Datei im Archiv ändern ( <em>Yuri aus der Zukunft: Theoretisch können Sie das immer noch</em> ). Sie müssen das gesamte Archiv neu laden.  Trotz der Tatsache, dass Phar-Archive mit OPCache arbeiten, muss der Cache bei der Bereitstellung verworfen werden, da sonst in OPCache Müll aus der alten Phar-Datei vorhanden ist. <br><br>  <strong>hhbc</strong> <br><br>  Diese Methode stammt ursprünglich aus HHVM - HipHop Virtual Machine und wird von Facebook verwendet.  Dies ist so etwas wie ein Phar-Archiv, enthält jedoch nicht die Quellcodes, sondern den kompilierten Bytecode der virtuellen HHVM-Maschine - dem PHP-Interpreter von Facebook.  Es ist verboten, Änderungen an dieser Datei vorzunehmen: In diesem Modus können keine neuen Klassen, Funktionen und anderen dynamischen Funktionen erstellt werden.  Aufgrund dieser Einschränkungen kann die virtuelle Maschine zusätzliche Optimierungen verwenden.  Laut Facebook kann dies die Geschwindigkeit der Codeausführung um bis zu 30% erhöhen.  Dies ist wahrscheinlich eine gute Option für sie.  Es ist auch unmöglich, hier eine Datei zu ändern ( <em>Yuri aus der Zukunft: Eigentlich ist es möglich, weil es eine SQLite-Basis ist</em> ).  Wenn Sie eine Zeile ändern möchten, müssen Sie das gesamte Archiv erneut wiederholen. <br><br>  Für diese Methode ist es <strong>verboten, eval und dynamic include zu verwenden.</strong>  Das ist so, aber nicht ganz.  Eval kann verwendet werden, aber wenn es keine neuen Klassen oder Funktionen erstellt und include nicht aus Verzeichnissen erstellt werden kann, die sich außerhalb dieses Archivs befinden. <br><br>  <strong>Schleife</strong> <br><br>  Dies ist unsere alte Version und hat zwei große Vorteile.  Erstens sieht es aus wie ein reguläres Verzeichnis <strong>.</strong>  Sie mounten die Schleife, und für den Code spielt es keine Rolle - sie funktioniert mit Dateien sowohl in der Entwicklungsumgebung als auch in der Produktionsumgebung.  Die zweite Schleife kann im Lese- und Schreibmodus bereitgestellt werden und eine Datei ändern, wenn Sie für die Produktion noch dringend etwas ändern müssen. <br><br>  Aber Schleife hat Nachteile.  Erstens funktioniert es komisch mit Docker.  Ich werde etwas später darüber sprechen. <br><br>  Zweitens, wenn Sie Symlink in der letzten Schleife als document_root verwenden, haben Sie Probleme mit OPCache.  Es ist nicht sehr gut, Symlink im Pfad zu haben, und es beginnt zu verwirren, welche Versionen der Dateien verwendet werden sollen.  Daher muss OPCache bei der Bereitstellung zurückgesetzt werden. <br><br>  Ein weiteres Problem besteht darin, dass <strong>Superuser-Berechtigungen erforderlich sind</strong> , um Dateisysteme bereitzustellen.  Und Sie dürfen nicht vergessen, sie beim Start / Neustart des Computers zu mounten, da sonst anstelle von Code ein leeres Verzeichnis vorhanden ist. <br><br><h4>  Probleme mit Docker </h4><br>  Wenn Sie einen Docker-Container erstellen und einen Ordner darin ablegen, in dem „Schleifen“ oder andere Blockgeräte bereitgestellt sind, treten zwei Probleme gleichzeitig auf: Die neuen Bereitstellungspunkte fallen nicht in den Docker-Container und die zum Zeitpunkt der Erstellung vorhandenen „Schleifen“ Ein Docker-Container <strong>kann nicht ausgehängt werden,</strong> da er von einem Docker-Container belegt ist. <br><br>  Dies ist natürlich im Allgemeinen nicht mit der Bereitstellung kompatibel, da die Anzahl der Schleifengeräte begrenzt ist und unklar ist, wie der neue Code in den Container fallen soll. <br><br>  Wir haben versucht, seltsame Dinge zu tun, zum Beispiel einen lokalen <strong>NFS-Server zu eröffnen</strong> oder ein Verzeichnis mit SSHFS bereitzustellen, aber aus verschiedenen Gründen hat sich dies nicht in uns festgesetzt.  Infolgedessen haben wir in cron rsync aus der letzten "Schleife" im aktuellen Verzeichnis registriert und den Befehl einmal pro Minute ausgeführt: <br><pre><code class="php hljs">rsync /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/loop/&lt;N&gt;/ /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/</code> </pre> <br>  Hier ist <code>/var/www/</code> das Verzeichnis, das in den Container <code>/var/www/</code> wird.  Auf Computern mit Docker-Containern müssen wir jedoch nicht oft PHP-Skripte ausführen, sodass rsync nicht atomar war, was für uns geeignet war.  Trotzdem ist diese Methode natürlich sehr schlecht.  Ich möchte ein Bereitstellungssystem erstellen, das gut mit Docker funktioniert. <br><br><h3>  rsync, 2 Verzeichnisse und realpath_root </h3><br>  Diese Methode wurde von Rasmus Lerdorf, dem Autor von PHP, vorgeschlagen und er weiß, wie man sie einsetzt. <br><br>  Wie kann man eine atomare Bereitstellung durchführen und auf welche Weise habe ich darüber gesprochen?  Nehmen Sie symlink und registrieren Sie es als document_root.  Zu jedem Zeitpunkt zeigt symlink auf eines der beiden Verzeichnisse, und Sie machen rsync in ein benachbartes Verzeichnis, dh in das Verzeichnis, auf das der Code nicht verweist. <br><br><img src="https://habrastorage.org/webt/x7/qh/49/x7qh49aslgwu3loufk6wixt8fcg.png"><br><br>  Das Problem tritt jedoch auf: Der PHP-Code weiß nicht, in welchem ​​der Verzeichnisse er gestartet wurde.  Daher müssen Sie beispielsweise eine Variable verwenden, die Sie am Anfang der Konfiguration schreiben. Sie legt fest, aus welchem ​​Verzeichnis der Code ausgeführt wurde und aus welchen neuen Dateien aufgenommen werden soll.  Auf einer Folie heißt es <code>ROOT_DIR</code> . <br><br>  Verwenden Sie diese Konstante, wenn Sie auf alle Dateien im Code zugreifen, den Sie in der Produktion verwenden.  Sie erhalten also die Eigenschaft atomicity: Anforderungen, die vor dem Wechseln von symlink eingehen, enthalten weiterhin Dateien aus dem alten Verzeichnis, in dem Sie nichts geändert haben, und neue Anforderungen, die nach dem Wechseln von symlink eingegangen sind, funktionieren ab dem neuen Verzeichnis und werden bearbeitet neuer Code. <br><br><img src="https://habrastorage.org/webt/ny/o3/hh/nyo3hhqqs2iwthucxiquyf-org4.png"><br><br>  Dies muss jedoch im Code geschrieben werden.  Nicht alle Projekte sind dafür bereit. <br><br><h3>  Rasmus-Stil </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rasmus schlägt vor,</a> den Code nicht manuell zu ändern und Konstanten zu erstellen, um Apache leicht zu ändern oder Nginx zu verwenden. <br><br><img src="https://habrastorage.org/webt/8f/c3/xy/8fc3xyhs8rgmrtp45qeguvtzufi.png"><br><br>  Geben Sie für document_root den Symlink zur neuesten Version an.  Wenn Sie nginx haben, können Sie <code>root $realpath_root</code> registrieren. Für Apache benötigen Sie ein separates Modul mit den Einstellungen, die auf der Folie <code>root $realpath_root</code> .  Dies funktioniert folgendermaßen: Wenn eine Anforderung eingeht, berücksichtigt nginx oder Apache von Zeit zu Zeit realpath () aus dem Pfad, speichert sie vor Symlinks und übergibt diesen Pfad als document_root.  In diesem Fall verweist document_root immer auf ein reguläres Verzeichnis ohne Symlinks, und Ihr PHP-Code muss möglicherweise nicht darüber nachdenken, aus welchem ​​Verzeichnis er aufgerufen wird. <br><br>  Diese Methode hat interessante Vorteile - echte Pfade kommen zu OPCache PHP, sie enthalten keinen Symlink.  Selbst die allererste Datei, zu der die Anforderung kam, ist bereits voll, und es gibt keine Probleme mit OPCache.  Da document_root verwendet wird, funktioniert dies mit jedem PHP-Projekt.  Sie müssen nichts anpassen. <br><br>  Es ist kein erneutes Laden von fpm erforderlich. Während der Bereitstellung muss OPCache nicht zurückgesetzt werden, weshalb der Prozessorserver sehr ausgelastet ist, da alle Dateien erneut analysiert werden müssen.  In meinem Experiment erhöhte das Zurücksetzen von OPCache um etwa eine halbe Minute den Prozessorverbrauch um den Faktor 2–3.  Es wäre schön, es wiederzuverwenden, und diese Methode ermöglicht es Ihnen, es zu tun. <br><br>  Nun die Nachteile.  Da Sie OPCache nicht wiederverwenden und über zwei Verzeichnisse verfügen, müssen Sie für jedes Verzeichnis eine Kopie der Datei im Speicher speichern. Unter OPCache ist zweimal mehr Speicher erforderlich. <br><br>  Es gibt eine weitere Einschränkung, die seltsam erscheinen kann: <strong>Sie können nicht mehr als einmal pro max_execution_time bereitstellen</strong> .  Andernfalls tritt das gleiche Problem auf, da während rsync in eines der Verzeichnisse wechselt, Anforderungen von diesem weiterhin verarbeitet werden können. <br><br>  Wenn Sie Apache aus irgendeinem Grund verwenden, benötigen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieter-Modul</a> , das Rasmus ebenfalls geschrieben hat. <br><br>  Rasmus sagt, das System ist gut und ich empfehle es Ihnen auch.  Für 99% der Projekte ist es sowohl für neue als auch für bestehende Projekte geeignet.  Aber natürlich sind wir nicht so und haben beschlossen, unsere eigene Entscheidung zu schreiben. <br><br><h2>  Neues System - MDK </h2><br>  Grundsätzlich unterscheiden sich unsere Anforderungen nicht von den Anforderungen für die meisten Webprojekte.  Wir wollen nur eine <strong>schnelle Bereitstellung</strong> für Staging und Produktion, <strong>geringen Ressourcenverbrauch</strong> , Wiederverwendung von OPCache und schnelles Rollback. <br><br>  Es gibt jedoch zwei weitere Anforderungen, die sich von den anderen unterscheiden können.  Zuallererst ist es die Fähigkeit, <strong>Patches atomar anzuwenden</strong> .  Wir bezeichnen Patches als Änderungen in einer oder mehreren Dateien, die etwas über die Produktion regeln.  Wir wollen es schnell machen.  Im Prinzip bewältigt das von Rasmus angebotene System die Patch-Aufgabe. <br><br>  Wir haben auch <strong>CLI-Skripte</strong> <strong>, die mehrere Stunden lang ausgeführt werden</strong> können und die weiterhin mit einer konsistenten Version des Codes funktionieren sollten.  In diesem Fall passen die oben genannten Lösungen leider entweder nicht zu uns oder wir müssen viele Verzeichnisse haben. <br><br>  Mögliche Lösungen: <br><br><ul><li>  Schleife xN (-staging, -docker, -opcache); </li><li>  rsync xN (-Produktion, -opcache xN); </li><li>  SVN xN (-Produktion, -opcache xN). </li></ul><br>  Hier ist N die Anzahl der Berechnungen, die in wenigen Stunden durchgeführt werden.  Wir können Dutzende davon haben, was bedeutet, dass sehr viel Platz für zusätzliche Kopien des Codes aufgewendet werden muss. <br><br>  Deshalb haben wir uns ein neues System <strong>ausgedacht</strong> und es <strong>MDK genannt.</strong>  Es steht für <strong>Multiversion Deployment Kit</strong> , ein <strong>Bereitstellungstool</strong> für mehrere Versionen.  Wir haben es basierend auf den folgenden Annahmen gemacht. <br><br>  <strong>Wir haben die Baumspeicherarchitektur von Git übernommen.</strong>  Wir benötigen eine konsistente Version des Codes, in dem das Skript funktioniert, dh wir benötigen Snapshots.  Snapshots werden von LVM unterstützt, dort jedoch von experimentellen Dateisystemen wie Btrfs und Git ineffizient implementiert.  Wir haben die Implementierung von Snapshots von Git übernommen. <br><br>  <strong>Alle Dateien wurden von file.php in file.php umbenannt. &lt;Version&gt;.</strong>  Da alle vorhandenen Dateien einfach auf der Festplatte gespeichert sind, müssen wir der Version ein Suffix hinzufügen, wenn wir mehrere Versionen derselben Datei speichern möchten. <br><br>  <strong>Ich liebe Go, also habe ich aus Geschwindigkeitsgründen ein System auf Go geschrieben.</strong> <br><br><h3>  Funktionsweise des Multiversion Deployment Kit </h3><br>  Wir haben die Idee von Schnappschüssen von Git übernommen.  Ich habe es ein wenig vereinfacht und Ihnen gesagt, wie es in MDK implementiert ist. <br><br>  Es gibt zwei Arten von Dateien in MDK.  Das erste sind <strong>Karten.</strong>  Die folgenden Bilder sind grün markiert und entsprechen den Verzeichnissen im Repository.  Der zweite Typ sind <strong>direkt die Dateien,</strong> die sich wie gewohnt an derselben Stelle befinden, jedoch mit einem Suffix in Form einer Dateiversion.  Dateien und Karten werden basierend auf ihrem Inhalt versioniert, in unserem Fall einfach MD5. <br><br><img src="https://habrastorage.org/webt/-n/wz/1s/-nwz1str78y7hua15pfwxrrl14o.png"><br><br>  Angenommen, wir haben eine Hierarchie von Dateien, in der die <strong>Stammzuordnung auf bestimmte Versionen von Dateien aus anderen Zuordnungen verweist</strong> , und diese wiederum auf andere Dateien und <strong>Zuordnungen verweisen und bestimmte Versionen</strong> korrigieren.  Wir wollen eine Art Datei ändern. <br><br><img src="https://habrastorage.org/webt/7d/up/_b/7dup_biyh7msgtsp7kejinaulwc.png"><br><br>  Vielleicht haben Sie bereits ein ähnliches Bild gesehen: Wir ändern die Datei auf der zweiten Verschachtelungsebene, und in der entsprechenden Map - Map * wird die Version der Drei * -Datei aktualisiert, ihr Inhalt wird geändert, die Version wird geändert - und die Version ändert sich auch in der Root-Map.  Wenn wir etwas ändern, erhalten wir immer eine neue Root-Map, aber alle Dateien, die wir nicht geändert haben, werden wiederverwendet. <br><br>  Links bleiben zu denselben Dateien wie sie waren.  Dies ist die Hauptidee, Snapshots auf irgendeine Weise zu erstellen. Beispielsweise wird <strong>ZFS</strong> in <strong>ZFS</strong> ungefähr auf die gleiche Weise implementiert. <br><br><h3>  Wie MDK auf einer Festplatte liegt </h3><br><img src="https://habrastorage.org/webt/2r/vb/k4/2rvbk4ucmbe8upitkgczvy1dbns.png"><br><br>  Wir haben auf der Festplatte: <strong>Symlink zur neuesten Root-Map</strong> - den Code, der aus dem Web bereitgestellt wird, mehrere Versionen von Root-Maps, mehrere Dateien, möglicherweise mit unterschiedlichen Versionen, und in den Unterverzeichnissen gibt es Maps für die entsprechenden Verzeichnisse. <br><br>  Ich sehe die Frage voraus: " <em>Und wie verarbeitet dies die Webanforderung? Zu welchen Dateien kommt der Benutzercode?</em> " <br><br>  Ja, ich habe Sie getäuscht - es gibt auch Dateien ohne Versionen, denn wenn Sie eine Anfrage für index.php erhalten und diese nicht im Verzeichnis haben, funktioniert die Site nicht. <br><br><img src="https://habrastorage.org/webt/-e/fl/9k/-efl9kqt3-go-tvg0qpu0lnvauo.png"><br><br>  Alle PHP-Dateien haben Dateien, die wir <strong>Stubs</strong> nennen, da sie zwei Zeilen enthalten: erfordern aus der Datei, in der die Funktion deklariert ist, die mit diesen Karten arbeitet, und erfordern aus der gewünschten Version der Datei. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"mdk.inc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> mdk_resolve_path(<span class="hljs-string"><span class="hljs-string">"a.php"</span></span>);</code> </pre><br>  Dies geschieht auf diese Weise und ist nicht mit der neuesten Version <strong>verknüpft.</strong> Wenn Sie <strong>b.php</strong> ohne Version aus der <strong>a.php-</strong> Datei ausschließen, <strong>merkt sich</strong> das <strong>System</strong> , da require_once geschrieben ist, von welcher Root-Karte es gestartet wurde, und verwendet es Holen Sie sich eine konsistente Version von Dateien. <br><br>  Für den Rest der Dateien haben wir nur einen Symlink zur neuesten Version. <br><br><h3>  Bereitstellen mit MDK </h3><br>  Das Modell ist Git Push sehr ähnlich. <br><br><ul><li>  Senden Sie den Inhalt der Root-Map. </li><li>  Auf der Empfangsseite schauen wir uns an, welche Dateien fehlen.  Da die Version der Datei vom Inhalt bestimmt wird, müssen wir sie nicht ein zweites Mal herunterladen ( <em>Yuri aus der Zukunft: außer für den Fall, dass ein verkürzter MD5 kollidiert, der noch einmal in der Produktion aufgetreten ist</em> ). </li><li>  Fordern Sie die fehlende Datei an. </li><li>  Wir gehen zum zweiten Punkt und weiter im Kreis. </li></ul><br><h4>  Beispiel </h4><br>  Angenommen, auf dem Server befindet sich eine Datei mit dem Namen "one".  Senden Sie eine Root-Map. <br><br><img src="https://habrastorage.org/webt/_h/sz/h_/_hszh_rruyekpqegz6-blz5xkeq.png"><br><br>  In der Stammzuordnung zeigen gestrichelte Pfeile Links zu Dateien an, die wir nicht haben.  Wir kennen ihre Namen und Versionen, weil sie auf der Karte sind.  Wir fordern sie vom Server an.  Der Server sendet und es stellt sich heraus, dass eine der Dateien auch eine Karte ist. <br><br><img src="https://habrastorage.org/webt/zp/--/ec/zp--ecfpdqqkgjq4zciljreqkk0.png"><br><br>  Wir schauen - wir haben überhaupt keine einzige Datei.  Wieder fordern wir fehlende Dateien an.  Der Server sendet sie.  Es sind keine Karten mehr vorhanden - der Bereitstellungsprozess ist abgeschlossen. <br><br><img src="https://habrastorage.org/webt/mp/jk/tc/mpjktcmgb80dpamvqjkwp_ya1lg.png"><br><br>  Sie können leicht erraten, was passieren wird, wenn die Dateien 150.000 sind, aber eine hat sich geändert.  Wir werden in der Root-Map sehen, dass eine Map fehlt. Lassen Sie uns die Verschachtelungsebene durchgehen und eine Datei erhalten.  In Bezug auf die Rechenkomplexität unterscheidet sich der Prozess fast nicht vom direkten Kopieren von Dateien, gleichzeitig bleiben jedoch die Konsistenz und die Snapshots des Codes erhalten. <br><br>  MDK hat keine Nachteile :) Es ermöglicht Ihnen, <strong>kleine Änderungen schnell und atomar bereitzustellen</strong> , und <strong>Skripte funktionieren tagelang</strong> , da wir alle Dateien, die bereitgestellt wurden, innerhalb einer Woche belassen können.  Sie werden ausreichend Platz einnehmen.  Sie können OPCache auch wiederverwenden, und die CPU frisst fast nichts. <br><br>  <strong>Die Überwachung ist recht schwierig, aber möglich</strong> .  Alle Dateien sind nach Inhalten versioniert, und Sie können cron schreiben, das alle Dateien durchläuft und den Namen und den Inhalt überprüft.  Sie können auch überprüfen, ob die Root-Map auf alle Dateien verweist und keine fehlerhaften Links enthält.  Darüber hinaus wird während der Bereitstellung die Integrität überprüft. <br><br>  Sie können <strong>die Änderungen problemlos rückgängig machen</strong> , da alle alten Karten vorhanden sind.  Wir können die Karte einfach werfen, alles wird sofort da sein. <br><br>  Für mich bedeutet die Tatsache, dass <strong>MDK in Go geschrieben ist</strong> , dass es schnell funktioniert. <br><br>  Ich habe dich wieder getäuscht, es gibt immer noch Nachteile.  Damit das Projekt mit dem System funktioniert, ist <strong>eine wesentliche Änderung des Codes erforderlich, die</strong> jedoch einfacher ist, als es auf den ersten Blick erscheinen mag.  <strong>Das System ist sehr komplex</strong> . Ich würde die Implementierung nicht empfehlen, wenn Sie keine Anforderungen wie Badoo haben.  Außerdem endet der Ort früher oder später, sodass der <strong>Garbage Collector erforderlich ist</strong> . <br><br>  Wir haben spezielle Dienstprogramme zum Bearbeiten von Dateien geschrieben - echte, keine Stubs, zum Beispiel mdk-vim.  Sie geben die Datei an, sie findet die gewünschte Version und bearbeitet sie. <br><br><h3>  MDK in Zahlen </h3><br>  Wir haben 50 Server im Staging, auf denen wir für 3-5 s bereitstellen <strong>.</strong>  Im Vergleich zu allem außer rsync ist es sehr schnell.  In der <strong>Produktion stellen</strong> wir ca. <strong>2 Minuten</strong> kleine Patches bereit - <strong>5-10 s</strong> . <br><br>  Wenn Sie aus irgendeinem Grund den gesamten Ordner mit dem Code auf allen Servern verloren haben (was niemals passieren sollte :)), <strong>dauert</strong> der <strong>Vorgang des vollständigen Hochladens etwa 40 Minuten</strong> .  Es ist uns einmal passiert, wenn auch nachts mit einem Minimum an Verkehr.  Daher wurde niemand verletzt.  Die zweite Datei befand sich 5 Minuten lang auf zwei Servern, daher ist dies nicht erwähnenswert. <br><br>  Das System ist nicht in Open Source, aber wenn Sie interessiert sind, schreiben Sie in die Kommentare - es kann angelegt sein ( <em>Yuri aus der Zukunft: Das System ist zum Zeitpunkt dieses Schreibens noch nicht in Open Source</em> ). <br><br><h2>  Fazit </h2><br>  <strong>Hör auf Rasmus, er lügt nicht</strong> .  Meiner Meinung nach ist die rsync-Methode zusammen mit realpath_root die beste, obwohl Schleifen auch recht gut funktionieren. <br><br>  <strong>Denken Sie mit Ihrem Kopf</strong> : Sehen Sie sich genau an, was Ihr Projekt benötigt, und versuchen Sie nicht, ein Raumschiff zu schaffen, in dem es genügend „Mais“ gibt.  Wenn Sie jedoch immer noch ähnliche Anforderungen haben, ist ein MDK-ähnliches System genau das Richtige für Sie. <br><br><blockquote>  Wir haben uns entschlossen, zu diesem Thema zurückzukehren, das in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> diskutiert wurde und möglicherweise nicht die gebührende Aufmerksamkeit erhielt, da es nur einer von vielen Bausteinen war, um eine hohe Leistung zu erzielen.  Aber jetzt haben wir eine separate professionelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia-</a> Konferenz, die sich ausschließlich mit PHP befasst.  Und hier kommen wir wirklich voll zur Geltung.  Wir werden gründlich über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standards</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools</a> sprechen - viel darüber, einschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring</a> . <br><br>  Abonnieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> mit Aktualisierungen des Konferenzprogramms und bis zum 17. Mai. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449916/">https://habr.com/ru/post/de449916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449902/index.html">Kabelfernsehnetze für die Kleinsten. Teil 2: Zusammensetzung und Wellenform</a></li>
<li><a href="../de449904/index.html">Erstellen einer Proxy-DLL für die Überprüfung von Hijack-DLL-Vorgängen</a></li>
<li><a href="../de449906/index.html">Selbstdokumentierender REST-Server (Node.JS, TypeScript, Koa, Joi, Swagger)</a></li>
<li><a href="../de449908/index.html">DDR3 oder DDR4? Warum haben wir Dell R420 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s für 99 US-Dollar in den Niederlanden angeboten?</a></li>
<li><a href="../de449910/index.html">GitLab Shell Runner. Wettbewerbsfähiger Start von Testdiensten mit Docker Compose</a></li>
<li><a href="../de449918/index.html">Infrarot-Thermometer mit Sensor MLX90614</a></li>
<li><a href="../de449920/index.html">10 nicht standardmäßige Möglichkeiten, um SEO beim Ändern des CMS zu verletzen (+1 Bonus)</a></li>
<li><a href="../de449922/index.html">Probefahrt nanoCAD SPDS Metalwork 1.2. Teil 3</a></li>
<li><a href="../de449926/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 362 (22. - 28. April 2019)</a></li>
<li><a href="../de449928/index.html">Nicht nur die Verarbeitung: Wie wir aus Kafka Streams eine verteilte Datenbank erstellt haben und was daraus wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>