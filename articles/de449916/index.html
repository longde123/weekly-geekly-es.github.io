<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø üÖ∞Ô∏è üåï 5 M√∂glichkeiten, PHP-Code unter Hochlastbedingungen bereitzustellen üë®üèø‚Äçüç≥ üíô üë©üèª‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Highroad in der Schule unterrichtet w√ºrde, h√§tte das Lehrbuch zu diesem Thema eine solche Aufgabe. ‚ÄûDas soziale Netzwerk N verf√ºgt √ºber 2.000 Ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 M√∂glichkeiten, PHP-Code unter Hochlastbedingungen bereitzustellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449916/">  Wenn Highroad in der Schule unterrichtet w√ºrde, h√§tte das Lehrbuch zu diesem Thema eine solche Aufgabe.  ‚ÄûDas soziale Netzwerk N verf√ºgt √ºber 2.000 Server, auf denen 150.000 Dateien mit jeweils 900 MB PHP-Code und ein Staging-Cluster f√ºr 50 Computer gespeichert sind.  Der Code wird zweimal t√§glich auf den Servern bereitgestellt, im Staging-Cluster wird der Code alle paar Minuten aktualisiert, und es gibt zus√§tzliche ‚ÄûHotfixes‚Äú - kleine Dateigruppen, die nicht auf allen oder auf dem ausgew√§hlten Teil der Server angeordnet sind, ohne auf die vollst√§ndige Berechnung zu warten.  Frage: Werden solche Bedingungen als Hochlast betrachtet und wie werden sie bereitgestellt?  Schreiben Sie mindestens 5 Bereitstellungsoptionen. ‚Äú  Wir k√∂nnen nur vom Hyload-Problembuch tr√§umen, aber jetzt wissen wir bereits, dass <strong>Yuri Nasretdinov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">youROCK</a> ) dieses Problem definitiv l√∂sen und die ‚ÄûF√ºnf‚Äú bekommen w√ºrde. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qMu4YHJV1Z8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yuri hielt nicht bei einer einfachen L√∂sung an, sondern erstellte zus√§tzlich einen Bericht, in dem er das Konzept des ‚ÄûCode Deployment‚Äú -Konzepts enth√ºllte, √ºber klassische und alternative L√∂sungen f√ºr umfangreiche PHP-Bereitstellungen sprach, deren Leistung analysierte und das MDK-Bereitstellungssystem vorstellte. <br><a name="habracut"></a><br><h2>  Das Konzept des "Bereitstellen von Code" </h2><br>  Auf Englisch bedeutet der Begriff ‚ÄûEinsatz‚Äú, die Truppen in Alarmbereitschaft zu versetzen, und auf Russisch sagen wir manchmal ‚ÄûF√ºllen Sie den Code in den Kampf‚Äú, was dasselbe bedeutet.  Sie nehmen den Code in der bereits kompilierten Form oder im Original, wenn es sich um PHP handelt, laden ihn auf die Server hoch, die den Benutzerverkehr bedienen, und wechseln dann auf magische Weise die Last von einer Version des Codes zu einer anderen.  All dies ist im Konzept der ‚ÄûCode-Bereitstellung‚Äú enthalten. <br><br>  Der Bereitstellungsprozess besteht normalerweise aus mehreren Phasen. <br><br><ul><li>  <strong>Abrufen des Codes aus dem Repository</strong> auf eine beliebige Weise: Klonen, Abrufen, Auschecken. </li><li> <strong>Montage - bauen</strong> .  Bei PHP-Code fehlt m√∂glicherweise die Erstellungsphase.  In unserem Fall handelt es sich in der Regel um die automatische Generierung von √úbersetzungsdateien, das Hochladen statischer Dateien auf CDN und einige andere Vorg√§nge. </li><li>  <strong>Lieferung an Endserver</strong> - Bereitstellung. </li></ul><br>  Nachdem alles zusammengestellt ist, beginnt die Phase der sofortigen Bereitstellung - der <strong>Code</strong> wird <strong>auf Produktionsserver √ºbertragen</strong> .  √úber diese Phase wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo</a> diskutiert. <br><br><h2>  Altes Bereitstellungssystem in Badoo </h2><br>  Wenn Sie eine Datei mit einem Dateisystem-Image haben, wie k√∂nnen Sie diese dann bereitstellen?  Unter Linux m√ºssen Sie <strong>ein Zwischenschleifenger√§t</strong> erstellen, eine Datei anh√§ngen und danach kann dieses Blockger√§t bereits gemountet werden. <br><br>  Ein Loop-Ger√§t ist eine Kr√ºcke, die Linux ben√∂tigt, um ein Dateisystem-Image bereitzustellen.  Es gibt Betriebssysteme, in denen diese Kr√ºcke nicht ben√∂tigt wird. <br><br><img src="https://habrastorage.org/webt/gd/ch/h6/gdchh68qpl5ikkpddsvxzwcwvlm.png"><br><br>  Wie verwendet der Bereitstellungsprozess Dateien, die wir der Einfachheit halber auch als "Schleifen" bezeichnen?  Es gibt ein Verzeichnis, in dem sich der Quellcode und der automatisch generierte Inhalt befinden.  Wir machen ein leeres Bild des Dateisystems - jetzt ist es EXT2, und fr√ºher haben wir ReiserFS verwendet.  Wir mounten ein leeres Image des Dateisystems in einem tempor√§ren Verzeichnis und kopieren dort den gesamten Inhalt.  Wenn wir nichts brauchen, um in Produktion zu gehen, kopieren wir nicht alles.  H√§ngen Sie danach das Ger√§t aus und rufen Sie das Image des Dateisystems ab, in dem sich die erforderlichen Dateien befinden.  Als n√§chstes <strong>archivieren</strong> wir <strong>das Image und laden es auf alle Server</strong> hoch. Dort entpacken und mounten wir es. <br><br><h2>  Andere bestehende L√∂sungen </h2><br>  Zun√§chst m√∂chten wir uns bei <strong>Richard Stallman</strong> bedanken - ohne seine Lizenz h√§tten die meisten von uns verwendeten Dienstprogramme nicht existiert. <br><br><img src="https://habrastorage.org/webt/8h/oa/yh/8hoayhyyicam7izl-q7egj8bitq.png"><br><br>  Herk√∂mmlicherweise habe ich die Methoden zum Bereitstellen von PHP-Code in vier Kategorien unterteilt. <br><br><ul><li>  <strong>Basierend auf dem Versionskontrollsystem</strong> : svn up, git pull, hg up. </li><li>  <strong>Basierend auf dem Dienstprogramm rsync</strong> - in ein neues Verzeichnis oder "oben". </li><li>  <strong>Stellen Sie eine Datei</strong> bereit - egal was passiert: phar, hhbc, loop. </li><li>  Die spezielle Methode, die <strong>Rasmus Lerdorf</strong> vorgeschlagen hat, ist <strong>rsync, 2 Verzeichnisse und realpath_root</strong> . </li></ul><br>  Jede Methode hat sowohl Vor- als auch Nachteile, weshalb wir sie aufgegeben haben.  Betrachten Sie diese 4 Methoden genauer. <br><br><h3>  Bereitstellung basierend auf dem Versionskontrollsystem von svn up </h3><br>  Ich habe SVN nicht zuf√§llig gew√§hlt - nach meinen Beobachtungen besteht der Einsatz in dieser Form genau im Fall von SVN.  Das System ist recht <strong>leicht</strong> und erm√∂glicht <strong>eine schnelle und einfache</strong> Bereitstellung. F√ºhren Sie einfach svn up aus, und schon sind Sie fertig. <br><br>  Diese Methode hat jedoch ein gro√ües Minus: Wenn Sie svn up ausf√ºhren und beim Aktualisieren des Quellcodes neue Anforderungen aus dem Repository eingehen, wird der Status des Dateisystems angezeigt, das im Repository nicht vorhanden war.  Sie haben einen Teil der Dateien neu und einen Teil der alten - dies ist eine <strong>nicht atomare Bereitstellungsmethode,</strong> die nicht f√ºr hohe Auslastung geeignet ist, sondern nur f√ºr kleine Projekte.  Trotzdem kenne ich Projekte, die immer noch auf diese Weise bereitgestellt werden, und bis jetzt funktioniert alles f√ºr sie. <br><br><h3>  Bereitstellung basierend auf dem Dienstprogramm rsync </h3><br>  Hierf√ºr gibt es zwei M√∂glichkeiten: Hochladen von Dateien mit dem Dienstprogramm direkt auf den Server und Hochladen von "oben" - Update. <br><br><h4>  rsync in ein neues Verzeichnis </h4><br>  Da Sie zuerst den gesamten Code vollst√§ndig in ein Verzeichnis gie√üen, das noch nicht auf dem Server vorhanden ist, und erst dann den Datenverkehr wechseln, ist diese Methode <strong>atomar</strong> - niemand sieht einen Zwischenzustand.  In unserem Fall f√ºhrt das Erstellen von 150.000 Dateien und das L√∂schen des alten Verzeichnisses mit 150.000 Dateien zu einer <strong>gro√üen Belastung des Festplattensubsystems</strong> .  Wir verwenden Festplatten sehr aktiv, und der Server f√ºhlt sich nach einer solchen Operation f√ºr eine Minute nicht gut an.  Da wir 2000 Server haben, m√ºssen 900 MB 2000 Mal ausgef√ºllt werden. <br><br>  Dieses Schema kann verbessert werden, wenn Sie zuerst eine bestimmte Anzahl von Zwischenservern hochladen, z. B. 50, und diese dann dem Rest hinzuf√ºgen.  Dies l√∂st m√∂gliche Probleme mit dem Netzwerk, aber das Problem des Erstellens und L√∂schens einer gro√üen Anzahl von Dateien verschwindet nirgendwo. <br><br><img src="https://habrastorage.org/webt/wj/c9/pt/wjc9ptyfin79_dn6jmnornudzt8.png"><br><br><h4>  rsync oben </h4><br>  Wenn Sie rsync verwendet haben, wissen Sie, dass dieses Dienstprogramm nicht nur ganze Verzeichnisse f√ºllen, sondern auch vorhandene aktualisieren kann.  Nur √Ñnderungen zu senden ist ein Plus, aber da wir die √Ñnderungen in dasselbe Verzeichnis hochladen, in dem wir den Kampfcode bereitstellen, wird es auch eine Art Zwischenzustand geben - dies ist ein Minus. <br><br>  Das Einreichen von √Ñnderungen funktioniert folgenderma√üen.  Rsync erstellt Listen von Dateien auf der Serverseite, von der aus die Bereitstellung ausgef√ºhrt wird, und auf der Empfangsseite.  Danach z√§hlt es stat aus allen Dateien und sendet die gesamte Liste an die empfangende Seite.  Auf dem Server, von dem aus die Bereitstellung ausgef√ºhrt wird, wird der Unterschied zwischen diesen Werten ber√ºcksichtigt und festgelegt, welche Dateien gesendet werden sollen. <br><br>  Unter unseren Bedingungen ben√∂tigt dieser Prozess etwa <strong>3 MB Datenverkehr und 1 Sekunde Prozessorzeit</strong> .  Es scheint, dass dies nicht viel ist, aber wir haben 2.000 Server, und alles hat mindestens eine Minute Prozessorzeit.  Dies ist keine so schnelle Methode, aber definitiv besser, als das Ganze √ºber rsync zu senden.  Es bleibt irgendwie das Problem der Atomizit√§t zu l√∂sen und wird fast perfekt sein. <br><br><h3>  Stellen Sie eine Datei bereit </h3><br>  Unabh√§ngig davon, welche einzelne Datei Sie hochladen, ist die Verwendung von BitTorrent oder des UFTP-Dienstprogramms relativ einfach.  Eine Datei ist einfacher zu entpacken, kann unter Unix atomar ersetzt werden und es ist einfach, die Integrit√§t der auf dem Buildserver generierten und an die Zielcomputer gelieferten Datei zu √ºberpr√ºfen, indem die MD5- oder SHA-1-Betr√§ge aus der Datei berechnet werden (im Fall von rsync wissen Sie nicht, was sich auf den Zielservern befindet ) <br><br>  Bei Festplatten ist die sequentielle Aufzeichnung ein gro√ües Plus - eine 900-MB-Datei wird in etwa 10 Sekunden auf eine nicht belegte Festplatte geschrieben.  Trotzdem m√ºssen Sie dieselben 900 MB aufzeichnen und √ºber das Netzwerk √ºbertragen. <br><br><h4>  Lyrischer Exkurs √ºber UFTP </h4><br>  Dieses Open Source-Dienstprogramm wurde urspr√ºnglich erstellt, um Dateien √ºber ein Netzwerk mit langen Verz√∂gerungen zu √ºbertragen, z. B. √ºber ein satellitengest√ºtztes Netzwerk.  UFTP erwies sich jedoch als geeignet zum Hochladen von Dateien auf eine gro√üe Anzahl von Computern, da es mit dem auf Multicast basierenden UDP-Protokoll funktioniert.  Eine Multicast-Adresse wird erstellt, alle Computer, die die Datei empfangen m√∂chten, abonnieren sie, und die Switches erm√∂glichen die Zustellung von Kopien von Paketen an jeden Computer.  Wir verlagern also die Last der Daten√ºbertragung an das Netzwerk.  Wenn Ihr Netzwerk damit umgehen kann, funktioniert diese Methode viel besser als BitTorrent. <br><br>  Sie k√∂nnen dieses Open Source-Dienstprogramm in Ihrem Cluster ausprobieren.  Trotz der Tatsache, dass es √ºber UDP funktioniert, verf√ºgt es √ºber einen NACK-Mechanismus - eine negative Best√§tigung, die die Weiterleitung von Paketen erzwingt, die bei der Zustellung verloren gehen.  <strong>Dies ist eine zuverl√§ssige Methode zur Bereitstellung</strong> . <br><br><h4>  Optionen f√ºr die Bereitstellung einzelner Dateien </h4><br>  <strong>tar.gz</strong> <br><br>  Eine Option, die die Nachteile beider Ans√§tze kombiniert.  Sie m√ºssen nicht nur nacheinander 900 MB auf die Festplatte schreiben, sondern danach die gleichen 900 MB durch zuf√§lliges Lesen und Schreiben erneut schreiben und 150.000 Dateien erstellen.  Diese Methode hat eine noch schlechtere Leistung als rsync. <br><br>  <strong>phar</strong> <br><br>  PHP unterst√ºtzt Archive im Phar-Format (PHP-Archiv), wei√ü, wie man deren Inhalte angibt und Dateien einschlie√üt.  Aber nicht alle Projekte lassen sich einfach in einem Phar zusammenfassen - Sie m√ºssen den Code anpassen.  Nur weil der Code aus diesem Archiv nicht funktioniert.  Au√üerdem k√∂nnen Sie nicht eine Datei im Archiv √§ndern ( <em>Yuri aus der Zukunft: Theoretisch k√∂nnen Sie das immer noch</em> ). Sie m√ºssen das gesamte Archiv neu laden.  Trotz der Tatsache, dass Phar-Archive mit OPCache arbeiten, muss der Cache bei der Bereitstellung verworfen werden, da sonst in OPCache M√ºll aus der alten Phar-Datei vorhanden ist. <br><br>  <strong>hhbc</strong> <br><br>  Diese Methode stammt urspr√ºnglich aus HHVM - HipHop Virtual Machine und wird von Facebook verwendet.  Dies ist so etwas wie ein Phar-Archiv, enth√§lt jedoch nicht die Quellcodes, sondern den kompilierten Bytecode der virtuellen HHVM-Maschine - dem PHP-Interpreter von Facebook.  Es ist verboten, √Ñnderungen an dieser Datei vorzunehmen: In diesem Modus k√∂nnen keine neuen Klassen, Funktionen und anderen dynamischen Funktionen erstellt werden.  Aufgrund dieser Einschr√§nkungen kann die virtuelle Maschine zus√§tzliche Optimierungen verwenden.  Laut Facebook kann dies die Geschwindigkeit der Codeausf√ºhrung um bis zu 30% erh√∂hen.  Dies ist wahrscheinlich eine gute Option f√ºr sie.  Es ist auch unm√∂glich, hier eine Datei zu √§ndern ( <em>Yuri aus der Zukunft: Eigentlich ist es m√∂glich, weil es eine SQLite-Basis ist</em> ).  Wenn Sie eine Zeile √§ndern m√∂chten, m√ºssen Sie das gesamte Archiv erneut wiederholen. <br><br>  F√ºr diese Methode ist es <strong>verboten, eval und dynamic include zu verwenden.</strong>  Das ist so, aber nicht ganz.  Eval kann verwendet werden, aber wenn es keine neuen Klassen oder Funktionen erstellt und include nicht aus Verzeichnissen erstellt werden kann, die sich au√üerhalb dieses Archivs befinden. <br><br>  <strong>Schleife</strong> <br><br>  Dies ist unsere alte Version und hat zwei gro√üe Vorteile.  Erstens sieht es aus wie ein regul√§res Verzeichnis <strong>.</strong>  Sie mounten die Schleife, und f√ºr den Code spielt es keine Rolle - sie funktioniert mit Dateien sowohl in der Entwicklungsumgebung als auch in der Produktionsumgebung.  Die zweite Schleife kann im Lese- und Schreibmodus bereitgestellt werden und eine Datei √§ndern, wenn Sie f√ºr die Produktion noch dringend etwas √§ndern m√ºssen. <br><br>  Aber Schleife hat Nachteile.  Erstens funktioniert es komisch mit Docker.  Ich werde etwas sp√§ter dar√ºber sprechen. <br><br>  Zweitens, wenn Sie Symlink in der letzten Schleife als document_root verwenden, haben Sie Probleme mit OPCache.  Es ist nicht sehr gut, Symlink im Pfad zu haben, und es beginnt zu verwirren, welche Versionen der Dateien verwendet werden sollen.  Daher muss OPCache bei der Bereitstellung zur√ºckgesetzt werden. <br><br>  Ein weiteres Problem besteht darin, dass <strong>Superuser-Berechtigungen erforderlich sind</strong> , um Dateisysteme bereitzustellen.  Und Sie d√ºrfen nicht vergessen, sie beim Start / Neustart des Computers zu mounten, da sonst anstelle von Code ein leeres Verzeichnis vorhanden ist. <br><br><h4>  Probleme mit Docker </h4><br>  Wenn Sie einen Docker-Container erstellen und einen Ordner darin ablegen, in dem ‚ÄûSchleifen‚Äú oder andere Blockger√§te bereitgestellt sind, treten zwei Probleme gleichzeitig auf: Die neuen Bereitstellungspunkte fallen nicht in den Docker-Container und die zum Zeitpunkt der Erstellung vorhandenen ‚ÄûSchleifen‚Äú Ein Docker-Container <strong>kann nicht ausgeh√§ngt werden,</strong> da er von einem Docker-Container belegt ist. <br><br>  Dies ist nat√ºrlich im Allgemeinen nicht mit der Bereitstellung kompatibel, da die Anzahl der Schleifenger√§te begrenzt ist und unklar ist, wie der neue Code in den Container fallen soll. <br><br>  Wir haben versucht, seltsame Dinge zu tun, zum Beispiel einen lokalen <strong>NFS-Server zu er√∂ffnen</strong> oder ein Verzeichnis mit SSHFS bereitzustellen, aber aus verschiedenen Gr√ºnden hat sich dies nicht in uns festgesetzt.  Infolgedessen haben wir in cron rsync aus der letzten "Schleife" im aktuellen Verzeichnis registriert und den Befehl einmal pro Minute ausgef√ºhrt: <br><pre><code class="php hljs">rsync /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/loop/&lt;N&gt;/ /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/</code> </pre> <br>  Hier ist <code>/var/www/</code> das Verzeichnis, das in den Container <code>/var/www/</code> wird.  Auf Computern mit Docker-Containern m√ºssen wir jedoch nicht oft PHP-Skripte ausf√ºhren, sodass rsync nicht atomar war, was f√ºr uns geeignet war.  Trotzdem ist diese Methode nat√ºrlich sehr schlecht.  Ich m√∂chte ein Bereitstellungssystem erstellen, das gut mit Docker funktioniert. <br><br><h3>  rsync, 2 Verzeichnisse und realpath_root </h3><br>  Diese Methode wurde von Rasmus Lerdorf, dem Autor von PHP, vorgeschlagen und er wei√ü, wie man sie einsetzt. <br><br>  Wie kann man eine atomare Bereitstellung durchf√ºhren und auf welche Weise habe ich dar√ºber gesprochen?  Nehmen Sie symlink und registrieren Sie es als document_root.  Zu jedem Zeitpunkt zeigt symlink auf eines der beiden Verzeichnisse, und Sie machen rsync in ein benachbartes Verzeichnis, dh in das Verzeichnis, auf das der Code nicht verweist. <br><br><img src="https://habrastorage.org/webt/x7/qh/49/x7qh49aslgwu3loufk6wixt8fcg.png"><br><br>  Das Problem tritt jedoch auf: Der PHP-Code wei√ü nicht, in welchem ‚Äã‚Äãder Verzeichnisse er gestartet wurde.  Daher m√ºssen Sie beispielsweise eine Variable verwenden, die Sie am Anfang der Konfiguration schreiben. Sie legt fest, aus welchem ‚Äã‚ÄãVerzeichnis der Code ausgef√ºhrt wurde und aus welchen neuen Dateien aufgenommen werden soll.  Auf einer Folie hei√üt es <code>ROOT_DIR</code> . <br><br>  Verwenden Sie diese Konstante, wenn Sie auf alle Dateien im Code zugreifen, den Sie in der Produktion verwenden.  Sie erhalten also die Eigenschaft atomicity: Anforderungen, die vor dem Wechseln von symlink eingehen, enthalten weiterhin Dateien aus dem alten Verzeichnis, in dem Sie nichts ge√§ndert haben, und neue Anforderungen, die nach dem Wechseln von symlink eingegangen sind, funktionieren ab dem neuen Verzeichnis und werden bearbeitet neuer Code. <br><br><img src="https://habrastorage.org/webt/ny/o3/hh/nyo3hhqqs2iwthucxiquyf-org4.png"><br><br>  Dies muss jedoch im Code geschrieben werden.  Nicht alle Projekte sind daf√ºr bereit. <br><br><h3>  Rasmus-Stil </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rasmus schl√§gt vor,</a> den Code nicht manuell zu √§ndern und Konstanten zu erstellen, um Apache leicht zu √§ndern oder Nginx zu verwenden. <br><br><img src="https://habrastorage.org/webt/8f/c3/xy/8fc3xyhs8rgmrtp45qeguvtzufi.png"><br><br>  Geben Sie f√ºr document_root den Symlink zur neuesten Version an.  Wenn Sie nginx haben, k√∂nnen Sie <code>root $realpath_root</code> registrieren. F√ºr Apache ben√∂tigen Sie ein separates Modul mit den Einstellungen, die auf der Folie <code>root $realpath_root</code> .  Dies funktioniert folgenderma√üen: Wenn eine Anforderung eingeht, ber√ºcksichtigt nginx oder Apache von Zeit zu Zeit realpath () aus dem Pfad, speichert sie vor Symlinks und √ºbergibt diesen Pfad als document_root.  In diesem Fall verweist document_root immer auf ein regul√§res Verzeichnis ohne Symlinks, und Ihr PHP-Code muss m√∂glicherweise nicht dar√ºber nachdenken, aus welchem ‚Äã‚ÄãVerzeichnis er aufgerufen wird. <br><br>  Diese Methode hat interessante Vorteile - echte Pfade kommen zu OPCache PHP, sie enthalten keinen Symlink.  Selbst die allererste Datei, zu der die Anforderung kam, ist bereits voll, und es gibt keine Probleme mit OPCache.  Da document_root verwendet wird, funktioniert dies mit jedem PHP-Projekt.  Sie m√ºssen nichts anpassen. <br><br>  Es ist kein erneutes Laden von fpm erforderlich. W√§hrend der Bereitstellung muss OPCache nicht zur√ºckgesetzt werden, weshalb der Prozessorserver sehr ausgelastet ist, da alle Dateien erneut analysiert werden m√ºssen.  In meinem Experiment erh√∂hte das Zur√ºcksetzen von OPCache um etwa eine halbe Minute den Prozessorverbrauch um den Faktor 2‚Äì3.  Es w√§re sch√∂n, es wiederzuverwenden, und diese Methode erm√∂glicht es Ihnen, es zu tun. <br><br>  Nun die Nachteile.  Da Sie OPCache nicht wiederverwenden und √ºber zwei Verzeichnisse verf√ºgen, m√ºssen Sie f√ºr jedes Verzeichnis eine Kopie der Datei im Speicher speichern. Unter OPCache ist zweimal mehr Speicher erforderlich. <br><br>  Es gibt eine weitere Einschr√§nkung, die seltsam erscheinen kann: <strong>Sie k√∂nnen nicht mehr als einmal pro max_execution_time bereitstellen</strong> .  Andernfalls tritt das gleiche Problem auf, da w√§hrend rsync in eines der Verzeichnisse wechselt, Anforderungen von diesem weiterhin verarbeitet werden k√∂nnen. <br><br>  Wenn Sie Apache aus irgendeinem Grund verwenden, ben√∂tigen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieter-Modul</a> , das Rasmus ebenfalls geschrieben hat. <br><br>  Rasmus sagt, das System ist gut und ich empfehle es Ihnen auch.  F√ºr 99% der Projekte ist es sowohl f√ºr neue als auch f√ºr bestehende Projekte geeignet.  Aber nat√ºrlich sind wir nicht so und haben beschlossen, unsere eigene Entscheidung zu schreiben. <br><br><h2>  Neues System - MDK </h2><br>  Grunds√§tzlich unterscheiden sich unsere Anforderungen nicht von den Anforderungen f√ºr die meisten Webprojekte.  Wir wollen nur eine <strong>schnelle Bereitstellung</strong> f√ºr Staging und Produktion, <strong>geringen Ressourcenverbrauch</strong> , Wiederverwendung von OPCache und schnelles Rollback. <br><br>  Es gibt jedoch zwei weitere Anforderungen, die sich von den anderen unterscheiden k√∂nnen.  Zuallererst ist es die F√§higkeit, <strong>Patches atomar anzuwenden</strong> .  Wir bezeichnen Patches als √Ñnderungen in einer oder mehreren Dateien, die etwas √ºber die Produktion regeln.  Wir wollen es schnell machen.  Im Prinzip bew√§ltigt das von Rasmus angebotene System die Patch-Aufgabe. <br><br>  Wir haben auch <strong>CLI-Skripte</strong> <strong>, die mehrere Stunden lang ausgef√ºhrt werden</strong> k√∂nnen und die weiterhin mit einer konsistenten Version des Codes funktionieren sollten.  In diesem Fall passen die oben genannten L√∂sungen leider entweder nicht zu uns oder wir m√ºssen viele Verzeichnisse haben. <br><br>  M√∂gliche L√∂sungen: <br><br><ul><li>  Schleife xN (-staging, -docker, -opcache); </li><li>  rsync xN (-Produktion, -opcache xN); </li><li>  SVN xN (-Produktion, -opcache xN). </li></ul><br>  Hier ist N die Anzahl der Berechnungen, die in wenigen Stunden durchgef√ºhrt werden.  Wir k√∂nnen Dutzende davon haben, was bedeutet, dass sehr viel Platz f√ºr zus√§tzliche Kopien des Codes aufgewendet werden muss. <br><br>  Deshalb haben wir uns ein neues System <strong>ausgedacht</strong> und es <strong>MDK genannt.</strong>  Es steht f√ºr <strong>Multiversion Deployment Kit</strong> , ein <strong>Bereitstellungstool</strong> f√ºr mehrere Versionen.  Wir haben es basierend auf den folgenden Annahmen gemacht. <br><br>  <strong>Wir haben die Baumspeicherarchitektur von Git √ºbernommen.</strong>  Wir ben√∂tigen eine konsistente Version des Codes, in dem das Skript funktioniert, dh wir ben√∂tigen Snapshots.  Snapshots werden von LVM unterst√ºtzt, dort jedoch von experimentellen Dateisystemen wie Btrfs und Git ineffizient implementiert.  Wir haben die Implementierung von Snapshots von Git √ºbernommen. <br><br>  <strong>Alle Dateien wurden von file.php in file.php umbenannt. &lt;Version&gt;.</strong>  Da alle vorhandenen Dateien einfach auf der Festplatte gespeichert sind, m√ºssen wir der Version ein Suffix hinzuf√ºgen, wenn wir mehrere Versionen derselben Datei speichern m√∂chten. <br><br>  <strong>Ich liebe Go, also habe ich aus Geschwindigkeitsgr√ºnden ein System auf Go geschrieben.</strong> <br><br><h3>  Funktionsweise des Multiversion Deployment Kit </h3><br>  Wir haben die Idee von Schnappsch√ºssen von Git √ºbernommen.  Ich habe es ein wenig vereinfacht und Ihnen gesagt, wie es in MDK implementiert ist. <br><br>  Es gibt zwei Arten von Dateien in MDK.  Das erste sind <strong>Karten.</strong>  Die folgenden Bilder sind gr√ºn markiert und entsprechen den Verzeichnissen im Repository.  Der zweite Typ sind <strong>direkt die Dateien,</strong> die sich wie gewohnt an derselben Stelle befinden, jedoch mit einem Suffix in Form einer Dateiversion.  Dateien und Karten werden basierend auf ihrem Inhalt versioniert, in unserem Fall einfach MD5. <br><br><img src="https://habrastorage.org/webt/-n/wz/1s/-nwz1str78y7hua15pfwxrrl14o.png"><br><br>  Angenommen, wir haben eine Hierarchie von Dateien, in der die <strong>Stammzuordnung auf bestimmte Versionen von Dateien aus anderen Zuordnungen verweist</strong> , und diese wiederum auf andere Dateien und <strong>Zuordnungen verweisen und bestimmte Versionen</strong> korrigieren.  Wir wollen eine Art Datei √§ndern. <br><br><img src="https://habrastorage.org/webt/7d/up/_b/7dup_biyh7msgtsp7kejinaulwc.png"><br><br>  Vielleicht haben Sie bereits ein √§hnliches Bild gesehen: Wir √§ndern die Datei auf der zweiten Verschachtelungsebene, und in der entsprechenden Map - Map * wird die Version der Drei * -Datei aktualisiert, ihr Inhalt wird ge√§ndert, die Version wird ge√§ndert - und die Version √§ndert sich auch in der Root-Map.  Wenn wir etwas √§ndern, erhalten wir immer eine neue Root-Map, aber alle Dateien, die wir nicht ge√§ndert haben, werden wiederverwendet. <br><br>  Links bleiben zu denselben Dateien wie sie waren.  Dies ist die Hauptidee, Snapshots auf irgendeine Weise zu erstellen. Beispielsweise wird <strong>ZFS</strong> in <strong>ZFS</strong> ungef√§hr auf die gleiche Weise implementiert. <br><br><h3>  Wie MDK auf einer Festplatte liegt </h3><br><img src="https://habrastorage.org/webt/2r/vb/k4/2rvbk4ucmbe8upitkgczvy1dbns.png"><br><br>  Wir haben auf der Festplatte: <strong>Symlink zur neuesten Root-Map</strong> - den Code, der aus dem Web bereitgestellt wird, mehrere Versionen von Root-Maps, mehrere Dateien, m√∂glicherweise mit unterschiedlichen Versionen, und in den Unterverzeichnissen gibt es Maps f√ºr die entsprechenden Verzeichnisse. <br><br>  Ich sehe die Frage voraus: " <em>Und wie verarbeitet dies die Webanforderung? Zu welchen Dateien kommt der Benutzercode?</em> " <br><br>  Ja, ich habe Sie get√§uscht - es gibt auch Dateien ohne Versionen, denn wenn Sie eine Anfrage f√ºr index.php erhalten und diese nicht im Verzeichnis haben, funktioniert die Site nicht. <br><br><img src="https://habrastorage.org/webt/-e/fl/9k/-efl9kqt3-go-tvg0qpu0lnvauo.png"><br><br>  Alle PHP-Dateien haben Dateien, die wir <strong>Stubs</strong> nennen, da sie zwei Zeilen enthalten: erfordern aus der Datei, in der die Funktion deklariert ist, die mit diesen Karten arbeitet, und erfordern aus der gew√ºnschten Version der Datei. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"mdk.inc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> mdk_resolve_path(<span class="hljs-string"><span class="hljs-string">"a.php"</span></span>);</code> </pre><br>  Dies geschieht auf diese Weise und ist nicht mit der neuesten Version <strong>verkn√ºpft.</strong> Wenn Sie <strong>b.php</strong> ohne Version aus der <strong>a.php-</strong> Datei ausschlie√üen, <strong>merkt sich</strong> das <strong>System</strong> , da require_once geschrieben ist, von welcher Root-Karte es gestartet wurde, und verwendet es Holen Sie sich eine konsistente Version von Dateien. <br><br>  F√ºr den Rest der Dateien haben wir nur einen Symlink zur neuesten Version. <br><br><h3>  Bereitstellen mit MDK </h3><br>  Das Modell ist Git Push sehr √§hnlich. <br><br><ul><li>  Senden Sie den Inhalt der Root-Map. </li><li>  Auf der Empfangsseite schauen wir uns an, welche Dateien fehlen.  Da die Version der Datei vom Inhalt bestimmt wird, m√ºssen wir sie nicht ein zweites Mal herunterladen ( <em>Yuri aus der Zukunft: au√üer f√ºr den Fall, dass ein verk√ºrzter MD5 kollidiert, der noch einmal in der Produktion aufgetreten ist</em> ). </li><li>  Fordern Sie die fehlende Datei an. </li><li>  Wir gehen zum zweiten Punkt und weiter im Kreis. </li></ul><br><h4>  Beispiel </h4><br>  Angenommen, auf dem Server befindet sich eine Datei mit dem Namen "one".  Senden Sie eine Root-Map. <br><br><img src="https://habrastorage.org/webt/_h/sz/h_/_hszh_rruyekpqegz6-blz5xkeq.png"><br><br>  In der Stammzuordnung zeigen gestrichelte Pfeile Links zu Dateien an, die wir nicht haben.  Wir kennen ihre Namen und Versionen, weil sie auf der Karte sind.  Wir fordern sie vom Server an.  Der Server sendet und es stellt sich heraus, dass eine der Dateien auch eine Karte ist. <br><br><img src="https://habrastorage.org/webt/zp/--/ec/zp--ecfpdqqkgjq4zciljreqkk0.png"><br><br>  Wir schauen - wir haben √ºberhaupt keine einzige Datei.  Wieder fordern wir fehlende Dateien an.  Der Server sendet sie.  Es sind keine Karten mehr vorhanden - der Bereitstellungsprozess ist abgeschlossen. <br><br><img src="https://habrastorage.org/webt/mp/jk/tc/mpjktcmgb80dpamvqjkwp_ya1lg.png"><br><br>  Sie k√∂nnen leicht erraten, was passieren wird, wenn die Dateien 150.000 sind, aber eine hat sich ge√§ndert.  Wir werden in der Root-Map sehen, dass eine Map fehlt. Lassen Sie uns die Verschachtelungsebene durchgehen und eine Datei erhalten.  In Bezug auf die Rechenkomplexit√§t unterscheidet sich der Prozess fast nicht vom direkten Kopieren von Dateien, gleichzeitig bleiben jedoch die Konsistenz und die Snapshots des Codes erhalten. <br><br>  MDK hat keine Nachteile :) Es erm√∂glicht Ihnen, <strong>kleine √Ñnderungen schnell und atomar bereitzustellen</strong> , und <strong>Skripte funktionieren tagelang</strong> , da wir alle Dateien, die bereitgestellt wurden, innerhalb einer Woche belassen k√∂nnen.  Sie werden ausreichend Platz einnehmen.  Sie k√∂nnen OPCache auch wiederverwenden, und die CPU frisst fast nichts. <br><br>  <strong>Die √úberwachung ist recht schwierig, aber m√∂glich</strong> .  Alle Dateien sind nach Inhalten versioniert, und Sie k√∂nnen cron schreiben, das alle Dateien durchl√§uft und den Namen und den Inhalt √ºberpr√ºft.  Sie k√∂nnen auch √ºberpr√ºfen, ob die Root-Map auf alle Dateien verweist und keine fehlerhaften Links enth√§lt.  Dar√ºber hinaus wird w√§hrend der Bereitstellung die Integrit√§t √ºberpr√ºft. <br><br>  Sie k√∂nnen <strong>die √Ñnderungen problemlos r√ºckg√§ngig machen</strong> , da alle alten Karten vorhanden sind.  Wir k√∂nnen die Karte einfach werfen, alles wird sofort da sein. <br><br>  F√ºr mich bedeutet die Tatsache, dass <strong>MDK in Go geschrieben ist</strong> , dass es schnell funktioniert. <br><br>  Ich habe dich wieder get√§uscht, es gibt immer noch Nachteile.  Damit das Projekt mit dem System funktioniert, ist <strong>eine wesentliche √Ñnderung des Codes erforderlich, die</strong> jedoch einfacher ist, als es auf den ersten Blick erscheinen mag.  <strong>Das System ist sehr komplex</strong> . Ich w√ºrde die Implementierung nicht empfehlen, wenn Sie keine Anforderungen wie Badoo haben.  Au√üerdem endet der Ort fr√ºher oder sp√§ter, sodass der <strong>Garbage Collector erforderlich ist</strong> . <br><br>  Wir haben spezielle Dienstprogramme zum Bearbeiten von Dateien geschrieben - echte, keine Stubs, zum Beispiel mdk-vim.  Sie geben die Datei an, sie findet die gew√ºnschte Version und bearbeitet sie. <br><br><h3>  MDK in Zahlen </h3><br>  Wir haben 50 Server im Staging, auf denen wir f√ºr 3-5 s bereitstellen <strong>.</strong>  Im Vergleich zu allem au√üer rsync ist es sehr schnell.  In der <strong>Produktion stellen</strong> wir ca. <strong>2 Minuten</strong> kleine Patches bereit - <strong>5-10 s</strong> . <br><br>  Wenn Sie aus irgendeinem Grund den gesamten Ordner mit dem Code auf allen Servern verloren haben (was niemals passieren sollte :)), <strong>dauert</strong> der <strong>Vorgang des vollst√§ndigen Hochladens etwa 40 Minuten</strong> .  Es ist uns einmal passiert, wenn auch nachts mit einem Minimum an Verkehr.  Daher wurde niemand verletzt.  Die zweite Datei befand sich 5 Minuten lang auf zwei Servern, daher ist dies nicht erw√§hnenswert. <br><br>  Das System ist nicht in Open Source, aber wenn Sie interessiert sind, schreiben Sie in die Kommentare - es kann angelegt sein ( <em>Yuri aus der Zukunft: Das System ist zum Zeitpunkt dieses Schreibens noch nicht in Open Source</em> ). <br><br><h2>  Fazit </h2><br>  <strong>H√∂r auf Rasmus, er l√ºgt nicht</strong> .  Meiner Meinung nach ist die rsync-Methode zusammen mit realpath_root die beste, obwohl Schleifen auch recht gut funktionieren. <br><br>  <strong>Denken Sie mit Ihrem Kopf</strong> : Sehen Sie sich genau an, was Ihr Projekt ben√∂tigt, und versuchen Sie nicht, ein Raumschiff zu schaffen, in dem es gen√ºgend ‚ÄûMais‚Äú gibt.  Wenn Sie jedoch immer noch √§hnliche Anforderungen haben, ist ein MDK-√§hnliches System genau das Richtige f√ºr Sie. <br><br><blockquote>  Wir haben uns entschlossen, zu diesem Thema zur√ºckzukehren, das in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> diskutiert wurde und m√∂glicherweise nicht die geb√ºhrende Aufmerksamkeit erhielt, da es nur einer von vielen Bausteinen war, um eine hohe Leistung zu erzielen.  Aber jetzt haben wir eine separate professionelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia-</a> Konferenz, die sich ausschlie√ülich mit PHP befasst.  Und hier kommen wir wirklich voll zur Geltung.  Wir werden gr√ºndlich √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standards</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools</a> sprechen - viel dar√ºber, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring</a> . <br><br>  Abonnieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> mit Aktualisierungen des Konferenzprogramms und bis zum 17. Mai. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449916/">https://habr.com/ru/post/de449916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449902/index.html">Kabelfernsehnetze f√ºr die Kleinsten. Teil 2: Zusammensetzung und Wellenform</a></li>
<li><a href="../de449904/index.html">Erstellen einer Proxy-DLL f√ºr die √úberpr√ºfung von Hijack-DLL-Vorg√§ngen</a></li>
<li><a href="../de449906/index.html">Selbstdokumentierender REST-Server (Node.JS, TypeScript, Koa, Joi, Swagger)</a></li>
<li><a href="../de449908/index.html">DDR3 oder DDR4? Warum haben wir Dell R420 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s f√ºr 99 US-Dollar in den Niederlanden angeboten?</a></li>
<li><a href="../de449910/index.html">GitLab Shell Runner. Wettbewerbsf√§higer Start von Testdiensten mit Docker Compose</a></li>
<li><a href="../de449918/index.html">Infrarot-Thermometer mit Sensor MLX90614</a></li>
<li><a href="../de449920/index.html">10 nicht standardm√§√üige M√∂glichkeiten, um SEO beim √Ñndern des CMS zu verletzen (+1 Bonus)</a></li>
<li><a href="../de449922/index.html">Probefahrt nanoCAD SPDS Metalwork 1.2. Teil 3</a></li>
<li><a href="../de449926/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 362 (22. - 28. April 2019)</a></li>
<li><a href="../de449928/index.html">Nicht nur die Verarbeitung: Wie wir aus Kafka Streams eine verteilte Datenbank erstellt haben und was daraus wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>